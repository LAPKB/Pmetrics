<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />



<title>Overview</title>

<script>// Pandoc 2.9 adds attributes on both header and div. We remove the former (to
// be compatible with the behavior of Pandoc < 2.8).
document.addEventListener('DOMContentLoaded', function(e) {
  var hs = document.querySelectorAll("div.section[class*='level'] > :first-child");
  var i, h, a;
  for (i = 0; i < hs.length; i++) {
    h = hs[i];
    if (!/^h[1-6]$/i.test(h.tagName)) continue;  // it should be a header h1-h6
    a = h.attributes;
    while (a.length > 0) h.removeAttribute(a[0].name);
  }
});
</script>

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>



<style type="text/css">
  code {
    white-space: pre;
  }
  .sourceCode {
    overflow: visible;
  }
</style>
<style type="text/css" data-origin="pandoc">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */

</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    for (var j = 0; j < rules.length; j++) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") continue;
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') continue;
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>




<style type="text/css">.caption {
color: #777;
margin-top: 10px;
}
.legacy {
background-color: #98a4a6;
color: white;
text-shadow: 1px 1px black;
border-radius: 5px;
padding: 3px;
}
.r6 {
background-color: #5296d5;
color: white;
text-shadow: 1px 1px black;
border-radius: 5px;
padding: 3px;
}
.update {
background-color: #d65645;
color: white;
text-shadow: 1px 1px black;
border-radius: 5px;
padding: 3px;
}
.to-be-reviewed {
background-color: red;
color: white;
text-shadow: 1px 1px black;
padding: 3px;
}
.script {
font-family: Arial, Helvetica, sans-serif;
background-color: lightgrey;
color: #446e9b;
}
body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; }
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
color: #5296d5;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }
code > span.kw { color: #555; font-weight: bold; } code > span.dt { color: #902000; } code > span.dv { color: #40a070; } code > span.bn { color: #d14; } code > span.fl { color: #d14; } code > span.ch { color: #d14; } code > span.st { color: #d14; } code > span.co { color: #888888; font-style: italic; } code > span.ot { color: #007020; } code > span.al { color: #ff0000; font-weight: bold; } code > span.fu { color: #900; font-weight: bold; } code > span.er { color: #a61717; background-color: #e3d2d2; } </style>




</head>

<body>




<h1 class="title toc-ignore">Overview</h1>



<div id="software-engines" class="section level2">
<h2>Software engines</h2>
<p>There are three main software engines that Pmetrics controls.</p>
<ul>
<li><p><strong>IT2B</strong> is the ITerative 2-stage Bayesian
parametric population PK modeling program. It is generally used to
estimate parameter ranges to pass to NPAG. It will estimate values for
population model parameters under the assumption that the underlying
distributions of those values are normal or transformed to normal,
e.g. log normal.</p></li>
<li><p><strong>NPAG</strong> is the Non-parametric Adaptive Grid
software. It will create a non-parametric population model consisting of
discrete support points, each with a set of estimates for all parameters
in the model plus an associated probability (weight) of that set of
estimates. There can be at most one point for each subject in the study
population. There is no need for any assumption about the underlying
distribution of model parameter values.</p></li>
<li><p>The <strong>Simulator</strong> is a semi-parametric Monte Carlo
simulation software program that can use the output of IT2B or NPAG to
build randomly generated response profiles (e.g. time-concentration
curves) for a given population model, parameter estimates, and data
input. Simulation from a non-parametric joint density model, i.e. NPAG
output, is possible, with each point serving as the mean of a
multivariate normal distribution, weighted according to the weight of
the point. The covariance matrix of the entire set of support points is
divided equally among the points for the purposes of
simulation.</p></li>
</ul>
</div>
<div id="pmetrics-control-functions" class="section level2">
<h2>Pmetrics control functions</h2>
<p><span class="r6">R6</span></p>
<p>Pmetrics uses<code>PM_data</code> to create data objects,
<code>PM_model</code> to create model objects, and <code>PM_fit</code>
to create objects that combine the model with the data, ready to be run
(fitted), generating probability distributions for primary model
parameters. These are extensively documented within R by using the
<code>help(command)</code> or <code>?command syntax</code>.</p>
<p>These functions replace the following Legacy functions:
<code>ITrun</code>, <code>ERRrun</code>, <code>NPrun</code>.</p>
<p>Invoking the simulator in R6 becomes a method attached to
<code>PM_result</code> objects or by using <code>PM_sim$run()</code> for
models, parameter value probability distributions and template data not
derived from a previous fit, e.g. when lifted from an article.</p>
<p><span class="legacy">Legacy</span></p>
<p>Pmetrics has groups of R functions named logically to run each of
these programs and to extract the output. Again, these are extensively
documented within R by using the <code>help(command)</code> or
<code>?command syntax</code>.</p>
<ul>
<li><p><code>ITrun</code>, <code>ITparse</code>,
<code>ERRrun</code></p></li>
<li><p><code>NPrun</code>, <code>NPparse</code></p></li>
<li><p><code>PMload</code>, <code>PMsave</code>,
<code>PMreport</code></p></li>
<li><p><code>SIMrun</code>, <code>SIMparse</code></p></li>
</ul>
<div id="run-functions" class="section level3">
<h3>Run functions</h3>
<p><span class="r6">R6</span></p>
<p>Once a <code>PM_fit</code> object is created, which combines a model
with a data file, it can be run by using the syntax <code>$run()</code>
to access the appropriate function defined for the <code>PM_fit</code>
object.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>fit1 <span class="ot">&lt;-</span> PM_fit<span class="sc">$</span><span class="fu">new</span>(model, data)</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>fit1<span class="sc">$</span><span class="fu">run</span>(options)</span></code></pre></div>
<p><span class="r6">R6</span> <span class="legacy">Legacy</span></p>
<p>For IT2B and NPAG, the “run” functions generate batch files, which
when executed, launch the software programs to do the analysis.
<code>$run(engine=&quot;err&quot;)</code> or <code>ERRrun()</code> is a special
implementation of IT2B designed to estimate the assay error polynomial
coefficients from the data, when they cannot be calculated from assay
validation data (using <code>makeErrorPoly()</code>) supplied by the
analytical laboratory. The batch files contain all the information
necessary to complete a run, tidy the output into a date/time stamped
directory with meaningful subdirectories, extract the information,
generate a report, and a saved Rdata file of parsed output which can be
quickly and easily loaded into R. On Mac (Unix) and Linux systems, the
batch file automatically launches in a Terminal window. Prior to v1.9,
on Windows systems, the batch file was launched manually, but as of
v1.9, this manual step is no longer necessary. The execution of the
program to do the actual model parameter estimation is independent of R,
so that the user is free to use R for other purposes.</p>
<p><span class="r6">R6</span></p>
<p>For the Simulator, the <code>$sim</code> method for a
<code>PM_result</code> object will execute the program directly within R
and return a <code>PM_sim</code> object.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>run1 <span class="ot">&lt;-</span> <span class="fu">PM_load</span>(<span class="dv">1</span>) </span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>sim1 <span class="ot">&lt;-</span> run1<span class="sc">$</span><span class="fu">sim</span>(<span class="at">data =</span> <span class="st">&quot;new.csv&quot;</span>)</span></code></pre></div>
<p>The first line loads previous results of run 1 into a PM_result
object called run1. The second line uses model and prior in run1 with
new data template.</p>
<p>An equivalent method is to run a new <code>PM_sim</code> directly
with <code>PM_sim$run()</code>. It also returns a <code>PM_sim</code>
object, i.e. there is no longer any need to run
<code>SIMparse</code>.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>sim1 <span class="ot">&lt;-</span> PM_sim<span class="sc">$</span><span class="fu">run</span>(<span class="at">poppar =</span> <span class="fu">list</span>(...), <span class="at">model =</span> <span class="st">&quot;model.txt&quot;</span>, <span class="at">data =</span> <span class="st">&quot;new.csv&quot;</span>) </span></code></pre></div>
<p>See <code>vignette(&quot;simulation&quot;)</code> for details on specifying
<code>poppar</code> this way.</p>
<p><span class="legacy">Legacy</span></p>
<p>To run the simulator in legacy mode, use <code>SIMrun</code>. Results
are saved to the hard drive in the working directory, and can be read
with <code>SIMparse</code> as described below.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="fu">SIMrun</span>(...)</span></code></pre></div>
</div>
<div id="parse-functions" class="section level3">
<h3>Parse functions</h3>
<p><span class="r6">R6</span> <span class="legacy">Legacy</span></p>
<p>For all programs, the “parse” functions will extract the primary
output from the program into meaningful R data objects. For IT2B and
NPAG in either R6 or legacy modes, this is done automatically at the end
of a successful run, and the objects are saved in the output
subdirectory as <em>IT2Bout.Rdata</em> or <em>NPAGout.Rdata</em>,
respectively. The parse functions run automatically and are not
generally necessary for the user to access.</p>
<p><span class="r6">R6</span></p>
<p>For the simulator the results are returned automatically to the
object assigned to contain the output of the simulator,
e.g. <code>sim1</code> below.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>sim1 <span class="ot">&lt;-</span> PM_result<span class="sc">$</span><span class="fu">sim</span>(...)</span></code></pre></div>
<p>As mentioned above, there is no longer any need to use the
<code>SIMparse</code> legacy function described below, because the
<code>SIMrun</code> and <code>SIMparse</code> legacy functions are
combined within the <code>$sim()</code> method for
<code>PM_result</code> objects or the <code>$run()</code> method for
<code>PM_sim</code> objects.</p>
<p><span class="legacy">Legacy</span></p>
<p>After running the simulator with <code>SIMrun</code>, the results are
saved to files in the working directory. They can be retrieved using
<code>SIMparse</code>.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>simdata <span class="ot">&lt;-</span> <span class="fu">SIMparse</span>(<span class="st">&quot;simout1.txt&quot;</span>)</span></code></pre></div>
</div>
<div id="saving-functions" class="section level3">
<h3>Saving functions</h3>
<p><span class="r6">R6</span></p>
<p>The Pmetrics R6 objects <code>PM_fit</code>, <code>PM_result</code>,
<code>PM_sim</code>, <code>PM_valid</code>, and <code>PM_pta</code> all
have a <code>$save()</code> method. This method saves the object to the
hard drive in the current working directory by default. The format is
.rds which is a binary format used by R to save individual objects. The
purpose of the <code>$save()</code> method is to enable retrieval of the
object at a later time.</p>
<p><span class="legacy">Legacy</span></p>
<p>Objects created that are attached to a particular run can be
identified by using the same suffix number as the run.
<code>PMsave</code> can add these attached objects to the .Rdata file
for that run, which is loaded with <code>PMload</code>.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>sim<span class="fl">.2</span> <span class="ot">&lt;-</span> <span class="fu">SIMparse</span>(<span class="st">&quot;simout1.txt&quot;</span>)</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="fu">PMsave</span>(<span class="dv">2</span>)</span></code></pre></div>
<p>In the above example, <code>sim.2</code> will be added to the .Rdata
file for future retrieval with <code>PMload(2)</code>.</p>
</div>
<div id="loading-functions" class="section level3">
<h3>Loading functions</h3>
<p><span class="r6">R6</span></p>
<p>After a successful IT2B or NPAG run, <code>PM_load</code> creates a
<code>PM_result</code> object rather than loading run results into the
current environment and suffixed with the run number as for legacy
mode.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>res1 <span class="ot">&lt;-</span> <span class="fu">PM_load</span>(<span class="dv">1</span>)</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>res1<span class="sc">$</span>op<span class="sc">$</span><span class="fu">plot</span>()</span></code></pre></div>
<p><code>PM_result</code>, <code>PM_fit</code>, <code>PM_sim</code>,
<code>PM_valid</code>, and <code>PM_pta</code> all have a
<code>$load()</code> method that takes as its only argument the full or
relative path (if not in the working directory) and name of an .rds file
created by the corresponding <code>$save()</code> method.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>sim1 <span class="ot">&lt;-</span> PM_sim<span class="sc">$</span><span class="fu">load</span>(<span class="st">&quot;sim.rds&quot;</span>)</span></code></pre></div>
<p><span class="legacy">Legacy</span></p>
<p>For IT2B and NPAG, the <code>PMload</code> function can be used to
load the .Rdata file after a successful run. Objects will be loaded into
the current environment in R and suffixed with “.run”, where “run” is
the run number.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="fu">PMload</span>(<span class="dv">1</span>)</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(op<span class="fl">.1</span>)</span></code></pre></div>
<p>For simulations, <code>SIMparse</code>, described above, combines the
parsing and loading functions.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>sim<span class="fl">.2</span> <span class="ot">&lt;-</span> <span class="fu">SIMparse</span>(<span class="st">&quot;simout1.txt&quot;</span>)</span></code></pre></div>
</div>
<div id="report-generation" class="section level3">
<h3>Report generation</h3>
<p><span class="r6">R6</span> <span class="legacy">Legacy</span></p>
<p>The <code>PMreport</code> function is automatically run at the end of
a successful NPAG and IT2B run, and it will generate an HTML page with
summaries of the run, as well as the .Rdata files and other objects. The
default browser will be automatically launched for viewing of the HTML
report page.
<!--It will also generate a .tex file suitable for processing by a
LATEX engine to generate a pdf report.--> See the <a href="#outputs">Pmetrics Outputs</a> section.</p>
</div>
</div>
<div id="other-functions" class="section level2">
<h2>Other functions</h2>
<p><span class="r6">R6</span> <span class="legacy">Legacy</span></p>
<p>Within Pmetrics there are also functions to manipulate data .csv
files and process and plot extracted data.</p>
<div id="data-manipulation" class="section level3">
<h3>Data manipulation</h3>
<table>
<colgroup>
<col width="46%" />
<col width="32%" />
<col width="21%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">Function</th>
<th align="left">R6</th>
<th align="left">Legacy</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Read data file</td>
<td align="left">PM_data$new()</td>
<td align="left">PMreadMatrix()</td>
</tr>
<tr class="even">
<td align="left">Check data file</td>
<td align="left">Embedded in PM_data$new()</td>
<td align="left">PMcheck()</td>
</tr>
<tr class="odd">
<td align="left">Write data file</td>
<td align="left">PM_data$write()</td>
<td align="left">PMwriteMatrix()</td>
</tr>
<tr class="even">
<td align="left">Convert calendar dates and clock times</td>
<td align="left">Embedded in PM_data$new()</td>
<td align="left">PMmatrixReltime()</td>
</tr>
<tr class="odd">
<td align="left">Convert from old USC*PACK .wrk format</td>
<td align="left">PMwrk2csv()</td>
<td align="left">PMwrk2csv()</td>
</tr>
<tr class="even">
<td align="left">Convert from NONMEM</td>
<td align="left">NM2PM()</td>
<td align="left">NM2PM()</td>
</tr>
<tr class="odd">
<td align="left">Convert from old USC*PACK .mb format</td>
<td align="left">PMmb2csv()</td>
<td align="left">PMmb2csv()</td>
</tr>
</tbody>
</table>
</div>
<div id="model-selection-and-diagnostics" class="section level3">
<h3>Model selection and diagnostics</h3>
<table>
<colgroup>
<col width="34%" />
<col width="43%" />
<col width="22%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">Function</th>
<th align="left">R6</th>
<th align="left">Legacy</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Compare models</td>
<td align="left">PM_compare(PM_result1, PMresult2,…)</td>
<td align="left">PMcompare(1, 2, …)</td>
</tr>
<tr class="even">
<td align="left">Plot residuals</td>
<td align="left">PM_result<span class="math inline">\(op\)</span>plot(resid = T,…)</td>
<td align="left">plot(op, resid = T)</td>
</tr>
<tr class="odd">
<td align="left">Construct VPC, pcVPC, NPDE</td>
<td align="left">PM_result$valid() or PM_valid$new()</td>
<td align="left">makeValid()</td>
</tr>
<tr class="even">
<td align="left">Plot VPC, pcVPC, NPDE</td>
<td align="left">PM_valid<span class="math inline">\(plot()
|plot(PMvalid) | |Stepwise covariate regression
|PM_result\)</span>step()</td>
<td align="left">PMstep()</td>
</tr>
</tbody>
</table>
</div>
<div id="other-functions-1" class="section level3">
<h3>Other functions</h3>
<pre><code>#&gt; Warning in read.table(file = file, header = header, sep = sep, quote = quote, :
#&gt; incomplete final line found by readTableHeader on &#39;Data/RLcomp_other.csv&#39;</code></pre>
<table style="width:100%;">
<colgroup>
<col width="33%" />
<col width="56%" />
<col width="10%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">Function</th>
<th align="left">R6</th>
<th align="left">Legacy</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Calculate AUC</td>
<td align="left">$auc() method for PM_result$op/$post/$pop, or
PM_sim</td>
<td align="left">makeAUC()</td>
</tr>
<tr class="even">
<td align="left">Simulate</td>
<td align="left">PM_result$sim() or PM_sim$new()</td>
<td align="left">SIMrun()</td>
</tr>
<tr class="odd">
<td align="left">Probability of target attainment</td>
<td align="left">PM_sim$pta() or PM_pta$new()</td>
<td align="left">makePTA()</td>
</tr>
</tbody>
</table>
<!-- * Process data: `makeAUC`, `makeCov`, `makeCycle`, `makeFinal`, `makeOP`, `makePTA`, -->
<!-- `makeErrorPoly` -->
<!-- * Plot data: `plot.PMcov`, `plot.PMcycle`, `plot.PMfinal`, `plot.PMmatrix`, -->
<!-- `plot.PMop`,`plot.PMsim`, `plot.PMvalid`, `plot.PMpta` -->
<!-- * Pmetrics function defaults: `setPMoptions`, `getPMoptions` -->
<p>Again, all functions have extensive help files and examples which can
be examined in R by using the <code>help(command)</code> or
<code>?command</code> syntax.</p>
</div>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
