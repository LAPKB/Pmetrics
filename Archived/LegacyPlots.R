#' Plots \emph{PMsim} objects with the option to perform a visual and numerical predictive check
#'
#' Simulated observations are plotted as quantiles on the y-axis vs. time on the x.axis.  If measured
#' observations are included, a visual and numerical predictive check will be performed.
#'
#' @title Plot Pmetrics Simulation Objects
#' @method plot PMsim
#' @param x The name of an \emph{PMsim} data object generated by \code{\link{SIMparse}}
#' @param mult Multiplication factor for y axis, e.g. to convert mg/L to ng/mL
#' @param log Boolean operator to plot in log-log space; the default is \code{False}
#' @param probs Vector of quantiles to plot; if set to \code{NA}, all simulated profiles will be plotted,
#' and numerical predictive checking will be suppressed
#' @param binSize Width of binning interval for simulated concentrations, in time units, e.g. hours.  For example,
#' a \code{binSize} of 0.5 will pull all simulated concentrations +/- 0.5 hours into the same time.  This is useful
#' for plotting PMsim objects made during \code{\link{makeValid}}. The default is 0, i.e. no binning.
#' @param outeq Which output equation to plot if more than 1
#' @param pch Controls the plotting symbol for observations; default is NA which results in no symbol.
#' Use 0 for open square, 1 for open circle, 2 for open triangle, 3 for cross, 4 for X, or 5 for a diamond.
#' Other alternatives are \dQuote{*} for asterisks, \dQuote{.} for tiny dots, or \dQuote{+} for a smaller,
#' bolder cross.  These plotting symbols are standard for R (see \code{\link{par}}).
#' @param join Boolean operator to join observations by a straight line; the default is \code{True}.
#' @param x.qlab Proportionate value of x-axis at which to draw the quantile labels; 0 is left, 1 is right.
#' The default is 0.4.
#' @param pos.qlab This allows more refined positioning of the quantile labels.  It takes standard R
#' values: 1, below; 2, left; 3, above; 4, right.
#' @param cex.qlab  Size of the quantile labels.
#' @param ci Width of confidence interval bands around simulated quantiles, from 0 to 1.  If 0, or \emph{nsim}<100, will not plot.
#' Default is 0.95, i.e. 95th percentile with tails of 2.5 percent above and below excluded.
#' @param cex.lab Size of the plot labels.
#' @param xlab Label for x-axis; default is \dQuote{Time}
#' @param ylab Label for y-axis; default is \dQuote{Output}
#' @param xlim Limits of the x-axis as a vector, e.g. \code{c(0,1)}.  It does not need to be specified, but can be.
#' @param ylim Analogous to \code{xlim}
#' @param obs The name of an \emph{makeOP} data object generated by \code{\link{makeOP}}.  If specified,
#' the observations will be overlaid upon the simulation plot enabling a visual predicitve check.  In this case,
#' a list object will be returned with two items: $npc containing the quantiles and probability that the observations
#' are below each quantile (binomial test); and $simsum, the times of each observation and the 
#' value of the simulated quantile with upper and lower confidence intervals at that time.
#' @param grid Either a boolean operator to plot a reference grid, or a list with elements x and y,
#' each of which is a vector specifying the native coordinates to plot grid lines; the default is \code{False}.
#' For example, grid=list(x=seq(0,24,2),y=1:10).  Defaults for missing x or y will be calculated by \code{\link{axTicks}}.
#' @param ocol Color for observations
#' @param add Boolean operator, if \code{True} will add lines to existing plot
#' @param out Direct output to a PDF, EPS or image file.  Format is a named list whose first argument, 
#' \code{type} is one of the following character vectors: \dQuote{pdf}, \dQuote{eps} (maps to \code{postscript}),
#' \dQuote{\code{png}}, \dQuote{\code{tiff}}, \dQuote{\code{jpeg}}, or \dQuote{\code{bmp}}.  Other named items in the list
#' are the arguments to each graphic device. PDF and EPS are vector images acceptable to most journals
#' in a very small file size, with scalable (i.e. infinite) resolution.  The others are raster images which may be very
#' large files at publication quality dots per inch (DPI), e.g. 800 or 1200. Default value is \code{NA} which means the 
#' output will go to the current graphic device (usually the monitor). For example, to output an eps file,
#' out=list(\dQuote{eps}) will generate a 7x7 inch (default) graphic.
#' @param \dots Other parameters as found in \code{\link{plot.default}}.
#' @return Plots the simulation object.  If \code{obs} is included, a list will be returned with
#' the folowing items:
#' \item{npc}{A dataframe with three columns: quantile, prop.less, pval.  \emph{quantile} are those specified
#' by the \code{prob} argument to the plot call; \emph{prop.less} are the proportion of simulated
#' observations at all times less than the quantile; \emph{pval} is the P-value of the difference in the 
#' prop.less and quantile by the beta-binomial test.}
#' \item{simsum}{A dataframe with the quantile concentration at each simulated time,
#' with lower and upper confidence intervals}
#' \item{obs}{A dataframe similar to an PMop object made by \code{\link{makeOP}}
#' with the addition of the quantile for each observation}
#' @author Michael Neely
#' @seealso \code{\link{SIMparse}}, \code{\link{plot}}, \code{\link{par}}, \code{\link{axis}}
#' @export

plot.PMsim <- function(x,mult=1,log=T,probs=c(0.05,0.25,0.5,0.75,0.95),binSize=0,outeq=1,
                       pch=NA,join=T,x.qlab=0.4,cex.qlab=0.8,pos.qlab=1,ci=0.95,
                       cex.lab=1.2,xlab="Time (h)",ylab="Output",xlim,ylim,obs,
                       grid,ocol="blue",add=F,out=NA,...){
  
  #choose output
  if(inherits(out,"list")){
    if(out$type=="eps") {setEPS();out$type <- "postscript"}
    if(length(out)>1) {do.call(out$type,args=out[-1])} else {do.call(out$type,list())}
  }
  #get other args
  otherArgs <- list(...)
  
  
  #numerical check function
  NPsimInterp <- function(time,out,sim.sum,probs){
    if (min(sim.sum$time)<=time){
      lower.time <- max(sim.sum$time[sim.sum$time<=time],na.rm=T)
    } else return(NA)
    if (max(sim.sum$time>=time)){
      upper.time <- min(sim.sum$time[sim.sum$time>=time],na.rm=T)
    } else return(NA)
    sim.quantile <- 0
    for (i in probs){
      if (lower.time != upper.time){
        lower.sim <- sim.sum$out[sim.sum$time==lower.time & sim.sum$quantile==i]
        upper.sim <- sim.sum$out[sim.sum$time==upper.time & sim.sum$quantile==i]
        slope <- (upper.sim - lower.sim) / (upper.time - lower.time)
        calc.sim <- lower.sim + slope*(time-lower.time)
      } else calc.sim <- sim.sum$out[sim.sum$time==lower.time & sim.sum$quantile==i]
      if (out >= calc.sim){
        sim.quantile <- i
      } 
    }
    return(sim.quantile)
  }
  
  simout <- x
  
  if(!(inherits(simout,"PMsim") || inherits(simout,"PM_sim"))){stop("Use SIMparse() to make object of class Psim.\n")}
  if(!missing(obs)){
    if(!inherits(obs,"PMop")){stop("Use makeOP() to make object of class PMop.\n")}
    if(inherits(obs,"list")){
      #we are dealing with old PMop
      obs <- obs[[2*outeq]]
    } else { obs <- obs[obs$outeq==outeq & obs$icen=="median" & obs$pred.type=="post",]}
  } else {obs <- data.frame(time=NA,obs=NA)}
  if (log){
    logplot <- "y"
    yaxt <- "n"
    if(all(is.na(obs$obs))){
      if(any(simout$obs<=0,na.rm=T)){
        cat("Values <= 0 omitted from log plot.\n")
        simout$obs[simout$obs <= 0] <- NA            
      }
    } else {
      if(any(obs$obs<=0,na.rm=T) | any(simout$obs<=0,na.rm=T)){
        cat("Values <= 0 omitted from log plot.\n")
        obs$obs[obs$obs <= 0] <- NA
        simout$obs[simout$obs <= 0] <- NA
      }
    }
    
  } else {
    logplot <- ""
    yaxt <- "s"
  }
  if(join){jointype <- "o"} else {jointype <- "p"}
  
  simout$obs$out <- simout$obs$out * mult
  obs$obs <- obs$obs * mult
  
  sim.out <- simout$obs[!is.na(simout$obs$out),]
  #bin times if requested
  if(binSize > 0){
    binnedTimes <- seq(floor(min(sim.out$time,na.rm=T)),ceiling(max(sim.out$time,na.rm=T)),binSize)
    sim.out$time <- binnedTimes[.bincode(sim.out$time,binnedTimes)]
  }
  
  nout <- max(sim.out$outeq)
  nsim <- nrow(simout$parValues)
  
  
  sim <- sim.out[sim.out$outeq==outeq,]
  times <- sort(unique(sim$time))
  nobs <- length(times)
  
  if(!all(is.na(probs)) & nsim>=10){
    sim.quant <- tapply(sim$out,sim$time,quantile,probs=probs,na.rm=T)
    lower.confint <- function(nsim) {
      l.ci <- ceiling(nsim*probs - qnorm(1-(1-ci)/2)*sqrt(nsim*probs*(1-probs)))
      l.ci[l.ci==0] <- NA
      return(l.ci)
    }
    
    upper.confint <- function(nsim) {
      u.ci <- ceiling(nsim*probs + qnorm(1-(1-ci)/2)*sqrt(nsim*probs*(1-probs)))
      return(u.ci)
    }
    
    sim.lconfint <- tapply(sim$out,sim$time,function(x) sort(x)[lower.confint(length(x))])
    sim.uconfint <- tapply(sim$out,sim$time,function(x) sort(x)[upper.confint(length(x))])
    sim.sum <- data.frame(time=rep(times,each=length(probs)),out=unlist(sim.quant),
                          lower.confint=unlist(sim.lconfint),upper.confint=unlist(sim.uconfint),quantile=rep(probs,nobs))
    row.names(sim.sum) <- 1:nrow(sim.sum)
    
    if (missing(ylim)){ylim <- c(min(c(sim.sum$out,obs$obs),na.rm=T),max(c(sim.sum$out,obs$obs),na.rm=T))}
    if (missing(xlim)){xlim <- c(min(c(sim.sum$time,obs$time),na.rm=T),max(c(sim.sum$time,obs$time),na.rm=T))}
    
    if(!add){
      do.call("plot",args=c(list(out~time,data=sim.sum,type="n",log=logplot,xlab=xlab,ylab=ylab,cex.lab=cex.lab,xlim=xlim,ylim=ylim,yaxt=yaxt),otherArgs))
      #plot(out~time,data=sim.sum,type="n",log=logplot,xlab=xlab,ylab=ylab,cex.lab=cex.lab,xlim=xlim,ylim=ylim,yaxt=yaxt,otherArgs2)
      if(missing(grid)){
        grid <- list(x=NA,y=NA)
      } else {
        if(inherits(grid,"logical")){
          if(grid){
            grid <- list(x=axTicks(1),y=axTicks(2))
          } else {
            grid <- list(x=NA,y=NA)
          }
        }
        if(inherits(grid,"list")){
          if(is.null(grid$x)) grid$x <- axTicks(1)
          if(is.null(grid$y)) grid$y <- axTicks(2)
        }
      }
      if(yaxt=="n") logAxis(2,grid=!all(is.na(grid$y)))
      abline(v=grid$x,lty=1,col="lightgray")
      abline(h=grid$y,lty=1,col="lightgray")
    }
    if(nsim<100) {cat("\nNote: Confidence intervals for simulation quantiles omitted when nsim < 100\n")}
    
    if(!is.na(probs[1])){
      if("lwd" %in% names(otherArgs)){
        lwd <- rep(otherArgs$lwd,length(probs))
        otherArgs[[which(names(otherArgs)=="lwd")]] <- NULL
      } else {lwd <- rep(1,length(probs))}
      if("col" %in% names(otherArgs)){
        col <- rep(otherArgs$col,length(probs))
        otherArgs[[which(names(otherArgs)=="col")]] <- NULL
      } else {col <- rep("gray50",length(probs))}
    }
    
    for (i in 1:length(probs)){
      if(nsim>=100 & ci>0){
        temp <- data.frame(x=c(sim.sum$time[sim.sum$quantile==probs[i]],rev(sim.sum$time[sim.sum$quantile==probs[i]])),
                           y=c(sim.sum$lower.confint[sim.sum$quantile==probs[i]],rev(sim.sum$upper.confint[sim.sum$quantile==probs[i]])))
        polygon(x=temp$x,y=temp$y,col="lightgrey",border=NA)
      } 
      #points(out~time,subset(sim.sum,sim.sum$quantile==probs[i]),pch=pch,lwd=lwd[i],col=col[i],otherArgs)
      do.call("points",args=c(list(out~time,data=subset(sim.sum,sim.sum$quantile==probs[i]),pch=pch,lwd=lwd[i],col=col[i]),otherArgs))
      
      if(jointype=="o") do.call(lines,args=c(list(out~time,data=subset(sim.sum,sim.sum$quantile==probs[i]),pch=pch,lwd=lwd[i],col=col[i]),otherArgs))
      
      hpos.text <- xlim[1] + x.qlab*(xlim[2]-xlim[1])
      if (!hpos.text %in% sim.sum$time){
        lower.time <- tail(sim.sum$time[sim.sum$time < hpos.text],1)
        upper.time <- head(sim.sum$time[sim.sum$time > hpos.text],1)
        lower.sim <- sim.sum$out[sim.sum$time==lower.time & sim.sum$quantile==probs[i]]
        upper.sim <- sim.sum$out[sim.sum$time==upper.time & sim.sum$quantile==probs[i]]
        if(!log){
          slope <- (upper.sim - lower.sim) / (upper.time - lower.time)
          vpos.text <- lower.sim + slope*(hpos.text-lower.time)
        } else {
          slope <- (log10(upper.sim) - log10(lower.sim)) / (log10(upper.time) - log10(lower.time))
          vpos.text <- 10**(log10(lower.sim) + slope*(log10(hpos.text)-log10(lower.time)))                
        }
      } else vpos.text <- sim.sum$out[sim.sum$time==hpos.text & sim.sum$quantile==probs[i]]
      text(x=hpos.text,y=vpos.text,labels=probs[i],cex=cex.qlab,pos=pos.qlab)
    }
    
    if(!all(is.na(obs))){
      #       #bin times if requested
      #       if(binSize > 0){
      #         binnedTimes <- seq(floor(min(obs$time)),ceiling(max(obs$time)),binSize)
      #         obs$time <- binnedTimes[.bincode(obs$time,binnedTimes)]
      #       }
      do.call("points",args=c(list(obs$obs~obs$time,col=ocol),otherArgs))
      for (i in 1:nrow(obs)){
        obs$sim.quant[i] <- ifelse(is.na(obs$obs[i]),NA,NPsimInterp(obs$time[i],obs$obs[i],sim.sum,probs=probs))
      }
      not.miss <- sum(!is.na(obs$sim.quant))
      npc <- data.frame(quantile=probs,prop.less=rep(NA,length(probs)),pval=rep(NA,length(probs)))
      for (i in 1:nrow(npc)){
        success <- sum(as.numeric(obs$sim.quant<probs[i]),na.rm=T)
        
        pval <- binom.test(success,not.miss,probs[i],alternative="two")$p.value
        npc$prop.less[i] <- round(success/not.miss,3)
        npc$pval[i] <- pval
        
      }
      
      #calculate proportion between 0.05 and 0.95
      between <- rep(NA,nrow(obs))
      for (i in 1:nrow(obs)){
        between[i] <- ifelse(is.na(obs$obs[i]),NA,NPsimInterp(obs$time[i],obs$obs[i],sim.sum,probs=c(0.05,0.95)))
      }
      success90 <- sum(as.numeric(between>=0.05 & between<0.95),na.rm=T)
      attr(npc,"05-95") <- success90/not.miss
      attr(npc,"P-90") <- binom.test(success90,not.miss,0.9,"two")$p.value
      
      if (not.miss<nrow(obs)){cat(paste("\n",nrow(obs)-not.miss," observed values were obtained beyond the \nsimulated time range of ",min(sim.sum$time)," to ",max(sim.sum$time)," and were excluded.",sep=""))}
      
      #close device if necessary
      if(inherits(out,"list")) dev.off()
      
      retVal <- list(npc=npc,simsum=sim.sum,obs=obs)
      class(retVal) <- c("PMnpc","list")
      return(retVal)
      
    } else {
      #close device if necessary
      if(inherits(out,"list")) dev.off()
      return(invisible(1))
    }
  } else {
    #probs are missing or nsim too low, plot all simulated profiles and skip numerical predictive check
    if(nsim<10) cat("\nQuantiles not calculated with fewer than 10 simulated profiles.\n")
    if (missing(ylim)){ylim <- c(min(c(sim$out,obs$obs),na.rm=T),max(c(sim$out,obs$obs),na.rm=T))}
    if (missing(xlim)){xlim <- c(min(c(sim$time,obs$time),na.rm=T),max(c(sim$time,obs$time),na.rm=T))}
    if(!add){
      do.call("plot",args=c(list(out~time,data=sim,type="n",log=logplot,xlab=xlab,ylab=ylab,cex.lab=cex.lab,xlim=xlim,ylim=ylim,yaxt=yaxt),otherArgs))
      if(missing(grid)){
        grid <- list(x=NA,y=NA)
      } else {
        if(inherits(grid,"logical")){
          if(grid){
            grid <- list(x=axTicks(1),y=axTicks(2))
          } else {
            grid <- list(x=NA,y=NA)
          }
        }
        if(inherits(grid,"list")){
          if(is.null(grid$x)) grid$x <- axTicks(1)
          if(is.null(grid$y)) grid$y <- axTicks(2)
        }
      }
      if(yaxt=="n") logAxis(2,grid=!all(is.na(grid$y)))
      abline(v=grid$x,lty=1,col="lightgray")
      abline(h=grid$y,lty=1,col="lightgray")
      
    } #end !add block
    for (i in unique(sim$id)){
      do.call("points",args=c(list(out~time,subset(sim,sim$id==i),pch=pch,type=jointype),otherArgs))
    }
    
    if(!all(is.na(obs))){do.call("points",args=c(list(obs$obs~obs$time,type="p",col=ocol),otherArgs))}
    
    #close device if necessary
    if(inherits(out,"list")) dev.off()
    
    return(invisible(1))   
  }
}