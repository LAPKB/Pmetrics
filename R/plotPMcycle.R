#' \code{plot.PMcycle} plots \emph{PMcycle} objects
#'
#' @title Plot NPAG Cycle Information
#' @method plot PMcycle
#' @param x The name of an \emph{PMcycle} data object generated by \code{\link{makeCycle}}
#' @param x.leg Porportionate location along the X-axis to place legend; 0 (default) is at left, 1 at right.
#' @param y.leg Porportionate location along the X-axis to place legend;  0 is at bottom, 1 (default) at top.
#' @param cex.leg Porportionate size of legend text.
#' @param omit Deceimal between 0 and 1 specifying the proportion of \dQuote{burn-in} cycles to omit from the plots.  If missing,
#' the first 20\% will be omitted.
#' @param col A vector of colors for the curves, which will be recycled if too short.  Not mandatory.
#' @param out Direct output to a PDF, EPS or image file.  Format is a named list whose first argument, 
#' \code{type} is one of the following character vectors: \dQuote{pdf}, \dQuote{eps} (maps to \code{postscript}),
#' \dQuote{\code{png}}, \dQuote{\code{tiff}}, \dQuote{\code{jpeg}}, or \dQuote{\code{bmp}}.  Other named items in the list
#' are the arguments to each graphic device. PDF and EPS are vector images acceptable to most journals
#' in a very small file size, with scalable (i.e. infinite) resolution.  The others are raster images which may be very
#' large files at publication quality dots per inch (DPI), e.g. 800 or 1200. Default value is \code{NA} which means the 
#' output will go to the current graphic device (usually the monitor). For example, to output an eps file,
#' out=list(\dQuote{eps}) will generate a 7x7 inch (default) graphic.
#' @param \dots Additional R plotting parameters.
#' @return Plots a panel with the following windows: -2 times the log-likelihood at each cycle, gamma/lambda at
#' each cycle; Akaike Information Criterion at each cyle and Bayesian (Schwartz) Information Criterion
#' at each cycle, the mean parameter values at each cycle (normalized to starting values); the normalized
#' standard deviation of the population distribution for each parameter at each cycle; and
#' the normalized median parameter values at each cycle.
#' @author Michael Neely
#' @seealso \code{\link{makeCycle}}, \code{\link{plot}}, \code{\link{par}}, \code{\link{axis}}
#' @export
#' @examples
#' data(PMex1)
#' plot(cycle.1)
#' plot(cycle.1,omit=0)



plot.PMcycle <- function(x,x.leg=0,y.leg=1,cex.leg=1.2,omit,col,out=NA,...){
  
  #choose output
  if(inherits(out,"list")){
    if(out$type=="eps") {setEPS();out$type <- "postscript"}
    if(length(out)>1) {do.call(out$type,args=out[-1])} else {do.call(out$type,list())}
  }
  
  data <- x
  numcycles <- nrow(data$mean)
  if (missing(omit)) {omit <- floor(0.2*nrow(data$mean))} else {omit <- floor(omit*nrow(data$mean))} 
  if(omit==0) omit <- 1
  if(missing(col)) {col <- rep(c("red","blue","green","black","purple","pink","orange","brown","gold","grey"),3)
  } else { col <- rep(col,10)}
  lnty <- rep(1:3,each=10)
  x <- omit:numcycles
  if(length(data$cycnum)==0) {cycnum <- x} else {cycnum <- data$cycnum[x]}
  nvar <- ncol(data$mean)
  nout <- ncol(data$gamlam)
  par(mfrow=c(3,2))
  
  # -2 x log-likelihood
  plot(y=data$ll[omit:numcycles],x=x,type="l",xlab="Cycle",ylab="",main="-2 x Log likelihood",xaxt="n",...)
  axis(1,at=x,labels=cycnum)
  #AIC and BIC
  aicbic <- c(data$aic[omit:numcycles],data$bic[omit:numcycles])
  plot(y=aicbic,x=c(x,x),type="n",xlab="Cycle",ylab="",main="AIC/BIC",xaxt="n",...)
  axis(1,at=x,labels=cycnum)
  lines(y=data$bic[omit:numcycles],x=x,type="l",col=col[1],...)
  lines(y=data$aic[omit:numcycles],x=x,type="l",col=col[2],...)
  legend(x=x.leg*max(x)+omit,y=min(aicbic)+y.leg*(max(aicbic)-min(aicbic)),legend=c("BIC","AIC"),
         col=col[1:2],lty=lnty[1:2],lwd=2,bg="white",cex=cex.leg,
         x.intersp=0.8,y.intersp=0.8)   
  #gamma/lambda
  if(is.null(nout)){
    plot(y=data$gamlam[omit:numcycles],x=x,type="l",xlab="Cycle",ylab="",main="Gamma/Lambda",xaxt="n",...)
    axis(1,at=x,labels=cycnum)
  } else {
    plot(y=max(data$gamlam[omit:numcycles,]),x=max(x),type="n",xlab="Cycle",ylab="",main="Gamma/Lambda",
         xlim=range(x),ylim=range(data$gamlam[omit:numcycles,]),xaxt="n",...)
    axis(1,at=x,labels=cycnum)
    for(i in 1:nout){
      lines(y=data$gamlam[omit:numcycles,i],x=x,col=col[i])
    }
    if(nout>1){
      legend(x=x.leg*max(x)+omit,y=min(data$gamlam[omit:numcycles,])+y.leg*(max(data$gamlam[omit:numcycles,])-min(data$gamlam[omit:numcycles,])),
             legend=paste("Output",1:nout),col=col[1:nvar],lty=lnty[1:nvar],lwd=2,bg="white",cex=cex.leg,
             x.intersp=0.8,y.intersp=0.8)
    }
  }
  #standardized means
  plot(y=data$mean[omit:numcycles,],x=rep(x,nvar),xlab="Cycle",ylab="",main="Normalized Mean",type="n",xaxt="n",...)
  axis(1,at=x,labels=cycnum)
  for(i in 1:nvar){
    lines(y=data$mean[omit:numcycles,i],x=x,col=col[i],lty=lnty[i])
  }
  legend(x=x.leg*max(x)+omit,y=min(data$mean[omit:numcycles,])+y.leg*(max(data$mean[omit:numcycles,])-min(data$mean[omit:numcycles,])),
         legend=data$names,col=col[1:nvar],lty=lnty[1:nvar],lwd=2,bg="white",cex=cex.leg,
         x.intersp=0.8,y.intersp=0.8)
  #standardized SD
  if(!all(is.na(data$sd))){
    plot(y=data$sd[omit:numcycles,],x=rep(x,nvar),xlab="Cycle",ylab="",main="Normalized SD",type="n",xaxt="n",...)
    axis(1,at=x,labels=cycnum)
    for(i in 1:nvar){
      lines(y=data$sd[omit:numcycles,i],x=x,col=col[i],lty=lnty[i])
    }
    legend(x=x.leg*max(x)+omit,y=min(data$sd[omit:numcycles,])+y.leg*(max(data$sd[omit:numcycles,])-min(data$sd[omit:numcycles,])),
           legend=data$names,col=col[1:nvar],lty=lnty[1:nvar],lwd=2,bg="white",cex=cex.leg,
           x.intersp=0.8,y.intersp=0.8)
  } else {
    plot(y=data$median[omit:numcycles,],x=rep(x,nvar),xlab="Cycle",ylab="",main="Normalized SD",type="n",xaxt="n",...)
    axis(1,at=x,labels=cycnum)
    text("Initial standard deviation = 0\nAssay error may be too large.",x=median(c(omit,numcycles)),y=median(data$median[omit:numcycles,]),col="gray50",cex=2)
  }
  #standardized median
  plot(y=data$median[omit:numcycles,],x=rep(x,nvar),xlab="Cycle",ylab="",main="Normalized Median",type="n",xaxt="n",...)
  axis(1,at=x,labels=cycnum)
  for(i in 1:nvar){
    lines(y=data$median[omit:numcycles,i],x=x,col=col[i],lty=lnty[i])
  }
  legend(x=x.leg*max(x)+omit,y=min(data$median[omit:numcycles,])+y.leg*(max(data$median[omit:numcycles,])-min(data$median[omit:numcycles,])),
         legend=data$names,col=col[1:nvar],lty=lnty[1:nvar],lwd=2,bg="white",cex=cex.leg,
         x.intersp=0.8,y.intersp=0.8)
  
  par(mfrow=c(1,1))
  
  #close device if necessary
  if(inherits(out,"list")) dev.off()
  
  return(invisible(1))
}

