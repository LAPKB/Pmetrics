#' @title Plot Pmetrics Simulation Objects
#' @description
#' `r lifecycle::badge('stable')`
#'
#' Plots *PM_sim* objects with the option to perform a visual and numerical predictive check
#' @details
#' Simulated observations are plotted as quantiles on the y-axis vs. time on the x.axis.  If measured
#' observations are included, a visual and numerical predictive check will be performed.
#' The default plot is to omit markers, but if the marker arugment is set to `TRUE`,
#' the resulting marker will have the following plotly properties:
#' `list(symbol = "circle-open", color = "black", size = 8)`. By default a grid is
#' omitted. The legend is also omitted by default, but if included,
#' clicking on a quantile item in the legend will hide it in the plot,
#' and double clicking will hide all other quantiles.
#'
#' @method plot PM_sim
#' @param x The name of an *PM_sim* data object generated by [PM_sim]
#' @param mult `r template("mult")`
#' @param ci Width of confidence interval bands around simulated quantiles,
#' from 0 to 1.  If 0, or *nsim*<100, will not plot.
#' Default is 0.95, i.e. 95th percentile with tails of 2.5 percent above and below excluded.
#' @param binSize Width of binning interval for simulated concentrations, in time units, e.g. hours.
#' A `binSize` of 0.5 will pull all simulated concentrations +/- 0.5 hours into
#' the same time.  This is useful
#' for plotting PMsim objects made during [makeValid]. The default is 0, i.e. no binning.
#' If an `obs` object is provided, it will be binned similarly.
#' @param outeq `r template("outeq")`
#' @param line Controls the appearance of lines. It can be specified in several ways.
#' * Default is `TRUE` which results in simulated profiles summarized
#' as quantiles, with default values of 0.05, 0.25, 0.5, 0.75, and 0.95. The default
#' format will be applied, which is solid black lines of width 1.
#' Numerical predictive checking will be calculated if observations are also included
#' (see *obs* below).
#' * `FALSE` results in no lines plotted and the plot will be blank.
#' * `NA` Quantile summaries will be suppressed, but lines joining simulated outputs
#' will be plotted in default format as above. In other words, all profiles will be plotted,
#' not just the quantiles. Numerical predictive checking will be suppressed.
#' * List of quantiles and formats to plot with the following elements:
#'     - `probs` Vector of quantiles to include. If missing, will be set to
#'     defaults above, i.e., `c(0.05, 0.25, 0.5, 0.75, and 0.95)`
#'     Example: `line = list(probs = c(0.25, 0.5, 0.75))`.
#'     - `color` Vector of color names whose order corresponds to `probs`.
#'     If shorter than `probs`, will be recycled. Default is "dodgerblue".
#'     Examples: `line = list(color = "red")` or `line = list(color = c("red", "blue"))`.
#'     - `width` Vector of widths in pixels, as for `color`. Default is 1.
#'     Example: `line = list(width = 2)`.
#'     - `dash` Vector of dash types, as for color. Default is "solid".
#'     See `plotly::schema()`, traces > scatter > attributes > line > dash > values.
#'     Example: `line = list(dash = "dashdot")`.
#' @param marker `r template("include")` Formatting will only be applied to observations
#' if included via the `obs` argument.
#' @param obs The name of a [PM_result] data object or the PM_op field in the
#' PM_result object, all generated by [PM_load].  For example, if
#' `run1 <- PM_load(1)` and `sim1` is a PM_sim object, then
#' `sim1$plot(obs = run1)` or `sim1$plot(obs = run1$op)`.
#' If specified,
#' the observations will be overlaid upon the simulation plot
#' enabling a visual predictive check.  In this case,
#' a list object will be returned with two items: $npc containing the quantiles
#' and probability that the observations
#' are below each quantile (binomial test); and $simsum, the times of each
#' observation and the
#' value of the simulated quantile with upper and lower confidence intervals at that time.
#' Additionally, the number of observations beyond the 5th and 95th percentiles will be reported
#' and the binomial test P-value if this number is different than the expected 10% value.
#' @param quiet Suppress plot if `TRUE`.
#' @param legend `r template("legend")` Default is `FALSE`
#' @param log `r template("log")` Default is `TRUE`.
#' @param grid `r template("grid")` Default is `FALSE`
#' @param xlab `r template("xlab")` Default is "Time".
#' @param ylab `r template("ylab")` Default is "Output".
#' @param title `r template("title")` Default is to have no title.
#' @param xlim `r template("xlim")`
#' @param ylim `r template("ylim")`
#' @param simnum Choose which object to plot in a PM_simlist,
#' i.e., a list of [PM_sim] objects created when more than one
#' subject is included in a simultation data template and
#' `combine = F` (the default) when parsing the results of a simulation.
#' @param \dots `r template("dotsPlotly")`
#' @return Plots the simulation object.  If `obs` is included, a list will be returned with
#' the folowing items:
#' * npc A dataframe with three columns: quantile, prop_less, pval.
#' ** quantile are those specified by the `probs` argument to the plot call
#' ** prop_less are the proportion of simulated
#' observations at all times less than the quantile
#' ** pval is the P-value of the difference in the
#' prop.less and quantile by the beta-binomial test.
#' * simsum A dataframe with the quantile concentration at each simulated time,
#' with lower and upper confidence intervals
#' * obs A data frame similar to an PMop object made by [makeOP] at the end of a run
#' with the addition of the quantile for each observation
#' @author Michael Neely
#' @seealso [PM_sim], [plot_ly], [schema]
#' @importFrom tidyr unnest_longer
#' @importFrom dplyr summarize
#' @export
#' @examples
#' library(PmetricsData)
#' simEx$plot()
#' simEx$plot(log = FALSE, line = list(color = "orange"))
#' @family PMplots

plot.PM_sim <- function(x,
                        mult = 1,
                        ci = 0.95,
                        binSize = 0,
                        outeq = 1,
                        line = TRUE,
                        marker = FALSE,
                        obs,
                        quiet = FALSE,
                        legend = FALSE,
                        log = TRUE,
                        grid = FALSE,
                        xlab, ylab,
                        title,
                        xlim, ylim,
                        simnum, ...) {
  if (all(is.na(line))) {
    line <- list(probs = NA)
  } # standardize
  if (is.logical(line)) {
    if (line) {
      lineList <- list(
        probs = c(0.05, 0.25, 0.5, 0.75, 0.95),
        color = rep("dodgerblue", 5),
        width = rep(1, 5),
        dash = rep("solid", 5)
      ) # line = T
    } else { # line = F
      lineList <- amendLine(FALSE)
      lineList$probs <- NULL # line was FALSE, so probs = NULL -> no join lines or quantiles
      lineList$width <- 0
    }
  } else { # line was not T/F
    if (!is.list(line) & length(line) > 1) {
      stop(paste0(
        "Specify the line argument as ",
        crayon::green$bold("list(probs = c(...), ...) "),
        "not probs = c(...)."
      ))
    }
    if (!is.null(purrr::pluck(line, "probs"))) {
      lineList <- list(probs = line$probs)
    } else {
      lineList <- list(probs = c(0.05, 0.25, 0.5, 0.75, 0.95))
    }
    nprobs <- length(lineList$probs)
    if (!is.null(purrr::pluck(line, "color"))) {
      lineList$color <- rep(line$color, nprobs)[1:nprobs]
    } else {
      lineList$color <- rep("dodgerblue", nprobs)
    }
    if (!is.null(purrr::pluck(line, "width"))) {
      lineList$width <- rep(line$width, nprobs)[1:nprobs]
    } else {
      lineList$width <- rep(1, nprobs)
    }
    if (!is.null(purrr::pluck(line, "dash"))) {
      lineList$dash <- rep(line$dash, nprobs)[1:nprobs]
    } else {
      lineList$dash <- rep("solid", nprobs)
    }
  }

  probValues <- lineList$probs
  probFormats <- lineList[-1] %>%
    purrr::transpose() %>%
    purrr::simplify_all()
  join <- amendLine(probFormats[[1]])

  # parse marker
  if (!missing(obs)) {
    if (!is.list(marker) && !marker) marker <- T
  }
  marker <- amendMarker(marker, default = list(color = "black", symbol = "circle-open", size = 8))

  # process dots
  layout <- amendDots(list(...))

  # axis labels
  xlab <- if (missing(xlab)) {
    "Time"
  } else {
    xlab
  }
  ylab <- if (missing(ylab)) {
    "Output"
  } else {
    ylab
  }

  layout$xaxis$title <- amendTitle(xlab)
  if (is.character(ylab)) {
    layout$yaxis$title <- amendTitle(ylab, layout$xaxis$title$font)
  } else {
    layout$yaxis$title <- amendTitle(ylab)
  }

  # grid
  layout$xaxis <- setGrid(layout$xaxis, grid)
  layout$yaxis <- setGrid(layout$yaxis, grid)

  # axis ranges
  if (!missing(xlim)) {
    layout$xaxis <- modifyList(layout$xaxis, list(range = xlim))
  }
  if (!missing(ylim)) {
    layout$yaxis <- modifyList(layout$yaxis, list(range = ylim))
  }

  # log y axis
  if (log) {
    layout$yaxis <- modifyList(layout$yaxis, list(type = "log"))
  }

  # title
  if (missing(title)) {
    title <- ""
  }
  layout$title <- amendTitle(title, default = list(size = 20))


  # legend
  legendList <- amendLegend(legend, default = list(title = list(text = "<b> Quantiles </b>")))
  layout <- modifyList(layout, list(showlegend = legendList[[1]], legend = legendList[-1]))


  # numerical check function
  NPsimInterp <- function(time, out, sim_sum, probs) {
    if (min(sim_sum$time) <= time) {
      lower_time <- max(sim_sum$time[sim_sum$time <= time], na.rm = TRUE)
    } else {
      return(NA)
    }
    if (max(sim_sum$time >= time)) {
      upper_time <- min(sim_sum$time[sim_sum$time >= time], na.rm = TRUE)
    } else {
      return(NA)
    }
    sim_quantile <- 0
    for (i in probs) {
      if (lower_time != upper_time) {
        lower_sim <- sim_sum$value[sim_sum$time == lower_time & sim_sum$quantile == i]
        upper_sim <- sim_sum$value[sim_sum$time == upper_time & sim_sum$quantile == i]
        slope <- (upper_sim - lower_sim) / (upper_time - lower_time)
        calc_sim <- lower_sim + slope * (time - lower_time)
      } else {
        calc_sim <- sim_sum$value[sim_sum$time == lower_time & sim_sum$quantile == i]
      }
      if (out >= calc_sim) {
        sim_quantile <- i
      }
    }
    return(sim_quantile)
  }

  if (inherits(x, "PM_simlist")) {
    if (missing(simnum)) {
      cat("Plotting first object in the PM_simlist.\nUse simnum argument to choose different PM_sim object in PM_simlist.\n")
      simout <- x[[1]]
    } else {
      simout <- x[[simnum]]
    }
  } else {
    simout <- x
  }


  if (!inherits(simout, c("PM_sim", "PMsim"))) {
    stop("Use PM_sim$run() to make object of class PM_sim.\n")
  }
  if (!missing(obs)) {
    if (!inherits(obs, c("PM_result", "PM_op"))) stop("Supply a PM_result or PM_op object for the obs argument.")
    if (inherits(obs, "PM_result")) {
      obs <- obs$op$data
    }
    if (inherits(obs, "PM_op")) {
      obs <- obs$data
    }
    obs <- obs %>%
      filter(
        outeq == !!outeq, icen == "median",
        pred.type == "post"
      ) %>%
      select(id, time, obs) # just need obs; median and post are arbitrary
  } else {
    obs <- data.frame(time = NA, obs = NA)
  }

  # change <=0 to NA if log plot
  if (log) {
    if (all(is.na(obs$obs))) {
      if (any(simout$obs <= 0, na.rm = TRUE)) {
        if (!quiet) {
          cat("Values <= 0 omitted from log plot.\n")
        }
        simout$obs[simout$obs <= 0] <- NA
      }
    } else {
      if (any(obs$obs <= 0, na.rm = TRUE) | any(simout$obs <= 0, na.rm = TRUE)) {
        if (!quiet) {
          cat("Values <= 0 omitted from log plot.\n")
        }
        obs$obs[obs$obs <= 0] <- NA
        simout$obs[simout$obs <= 0] <- NA
      }
    }
  }

  # multiply
  simout$obs$out <- simout$obs$out * mult
  obs$obs <- obs$obs * mult

  # simplify
  sim_out <- simout$obs[!is.na(simout$obs$out), ]

  # bin times if requested
  if (binSize > 0) {
    binned_sim_times <- seq(floor(min(sim_out$time, na.rm = TRUE)), ceiling(max(sim_out$time, na.rm = TRUE)), binSize)
    sim_out$time <- binned_sim_times[.bincode(sim_out$time, binned_sim_times, include.lowest = TRUE)]
    sim_out <- sim_out %>%
      group_by(id, time, outeq) %>%
      summarize(out = mean(out), .groups = "drop")
    if (!all(is.na(obs$obs))) {
      binned_obs_times <- seq(floor(min(obs$time, na.rm = TRUE)), ceiling(max(obs$time, na.rm = TRUE)), binSize)
      obs$time <- binned_obs_times[.bincode(obs$time, binned_obs_times, include.lowest = TRUE)]
      obs <- obs %>%
        group_by(id, time) %>%
        summarize(obs = mean(obs), .groups = "drop")
    }
  }

  nout <- max(sim_out$outeq)
  nsim <- nrow(simout$parValues)


  sim <- sim_out %>% filter(outeq == !!outeq)
  times <- sort(unique(sim$time))
  nobs <- length(times)

  if (!all(is.na(probValues)) & nsim >= 10) {
    # make DF of time, quantile and value
    sim_quant_df <- sim %>%
      dplyr::group_by(time) %>%
      group_map(~ quantile(.x$out, probs = probValues, na.rm = TRUE)) %>%
      dplyr::tibble() %>%
      tidyr::unnest_longer(1, indices_to = "quantile", values_to = "value") %>%
      dplyr::mutate(
        time = rep(times, each = length(probValues)),
        quantile = readr::parse_number(quantile) / 100
      ) %>%
      dplyr::select(time, quantile, value)

    lower_confint <- function(n) {
      l.ci <- ceiling(n * probValues - qnorm(1 - (1 - ci) / 2) * sqrt(n * probValues * (1 - probValues)))
      l.ci[l.ci == 0] <- NA
      return(l.ci)
    }

    upper_confint <- function(n) {
      u.ci <- ceiling(n * probValues + qnorm(1 - (1 - ci) / 2) * sqrt(n * probValues * (1 - probValues)))
      return(u.ci)
    }

    lconfint <- tapply(sim$out, sim$time, function(x) sort(x)[lower_confint(length(x))])
    uconfint <- tapply(sim$out, sim$time, function(x) sort(x)[upper_confint(length(x))])

    sim_quant_df$lowerCI <- unlist(lconfint)
    sim_quant_df$upperCI <- unlist(uconfint)

    # plot main data
    p <- sim_quant_df %>%
      group_by(quantile) %>%
      plotly::plot_ly(x = ~time, y = ~value)

    # add confidence intervals
    if (nsim < 100) {
      if (!quiet) {
        cat("\nNote: Confidence intervals for simulation quantiles omitted when nsim < 100\n")
      }
    } else {
      p <- p %>%
        plotly::add_ribbons(
          ymin = ~lowerCI, ymax = ~upperCI,
          color = I("grey"), opacity = 0.5,
          line = list(width = 0),
          hoverinfo = "none",
          showlegend = FALSE
        )
    }

    # add quantile lines, allowing for the independent formats
    for (i in 1:length(probValues)) {
      thisQ <- sim_quant_df %>% filter(quantile == probValues[i])
      p <- p %>% plotly::add_lines(
        x = ~time, y = ~value, data = thisQ, line = probFormats[[i]],
        hovertemplate = "Time: %{x}<br>Out: %{y}<br>Quantile: %{text}<extra></extra>",
        text = ~quantile,
        name = ~quantile
      )
    }
    retValue <- list()

    # add observations if supplied, and calculate NPC
    if (!all(is.na(obs))) {
      p <- p %>% add_markers(x = ~time, y = ~obs, data = obs, marker = marker)
      obs$sim_quant <- NA

      for (i in 1:nrow(obs)) {
        obs$sim_quant[i] <- ifelse(is.na(obs$obs[i]), NA,
          NPsimInterp(obs$time[i], obs$obs[i], sim_quant_df, probs = probValues)
        )
      }
      not.miss <- sum(!is.na(obs$sim_quant))
      npc <- data.frame(
        quantile = probValues,
        prop_less = rep(NA, length(probValues)),
        pval = rep(NA, length(probValues))
      )
      for (i in 1:nrow(npc)) {
        success <- sum(as.numeric(obs$sim_quant < probValues[i]), na.rm = TRUE)

        pval <- tryCatch(
          binom.test(success, not.miss, probValues[i],
            alternative = "two"
          )$p.value,
          error = function(e) NA
        )
        npc$prop_less[i] <- round(success / not.miss, 3)
        npc$pval[i] <- pval
      }

      # calculate proportion between 0.05 and 0.95
      between <- rep(NA, nrow(obs))
      for (i in 1:nrow(obs)) {
        between[i] <- ifelse(is.na(obs$obs[i]), NA,
          NPsimInterp(obs$time[i], obs$obs[i], sim_quant_df, probs = c(0.05, 0.95))
        )
      }
      success90 <- sum(as.numeric(between >= 0.05 & between < 0.95), na.rm = TRUE)
      attr(npc, "05-95") <- success90 / not.miss
      attr(npc, "P-90") <- binom.test(success90, not.miss, 0.9, "two")$p.value

      if (not.miss < nrow(obs)) {
        cat(paste("\n", nrow(obs) - not.miss, " observed values were obtained beyond the \nsimulated time range of ", min(sim_quant_df$time), " to ", max(sim_quant_df$time), " and were excluded.", sep = ""))
      }


      retValue <- modifyList(retValue, list(npc = npc, simsum = sim_quant_df, obs = obs))
      class(retValue) <- c("PMnpc", "list")
    }
  } else { # probs was set to NA or nsim < 10

    # plot all simulated profiles
    p <- sim %>%
      group_by(id) %>%
      plotly::plot_ly(x = ~time, y = ~out) %>%
      plotly::add_lines(line = join)
    # plot observations if available
    if (!all(is.na(obs))) {
      p <- p %>% add_markers(x = ~time, y = ~obs, data = obs, marker = marker)
    }
    retValue <- list()
  }


  # common to all plots
  p <- p %>% plotly::layout(
    xaxis = layout$xaxis,
    yaxis = layout$yaxis,
    showlegend = layout$showlegend,
    legend = layout$legend,
    title = layout$title
  )


  if (!quiet) print(p)
  retValue <- modifyList(retValue, list(p = p))
  return(invisible(retValue))
}

#' Plots a list of *PM_sim* objects created when `combine = F`.
#'
#' When simulating from a data template with multiple subjects, the
#' default is to create a list of [PM_sim] objects of class *PM_simlist*.
#' This function passes that list to [plot.PM_sim]. If the 'simnum' argument
#' is not chosen, the first object will be plotted.
#'
#' @title Plot list of Pmetrics Simulation Objects
#' @method plot PM_simlist
#' @param x The name of a *PM_simlist* object created when `combine = F`
#' is used when parsing the results of a simulation with multiple subjects
#' in the data template.
#' @param ... Parameters passsed to [plot.PM_sim].
#' @examples
#' library(PmetricsData)
#' simEx$plot(at = 2)
#' @export

plot.PM_simlist <- function(x, ...) {
  plot.PM_sim(x, ...)
}

#' @title Plot Pmetrics Simulation Objects
#' @description
#' `r lifecycle::badge('superseded')`
#'
#' This is largely now a legacy plotting function,
#' replaced by [plot.PM_sim].
#' Plots \emph{PMsim} objects with the option to perform a visual and numerical predictive check
#' @details
#' Simulated observations are plotted as quantiles on the y-axis vs. time on the x.axis.  If measured
#' observations are included, a visual and numerical predictive check will be performed.
#'
#' @method plot PMsim
#' @param x The name of an \emph{PMsim} data object generated by \code{\link{SIMparse}}
#' @param mult Multiplication factor for y axis, e.g. to convert mg/L to ng/mL
#' @param log Boolean operator to plot in log-log space; the default is \code{False}
#' @param probs Vector of quantiles to plot; if set to \code{NA}, all simulated profiles will be plotted,
#' and numerical predictive checking will be suppressed
#' @param binSize Width of binning interval for simulated concentrations, in time units, e.g. hours.  For example,
#' a \code{binSize} of 0.5 will pull all simulated concentrations +/- 0.5 hours into the same time.  This is useful
#' for plotting PMsim objects made during \code{\link{makeValid}}. The default is 0, i.e. no binning.
#' @param outeq Which output equation to plot if more than 1
#' @param pch Controls the plotting symbol for observations; default is NA which results in no symbol.
#' Use 0 for open square, 1 for open circle, 2 for open triangle, 3 for cross, 4 for X, or 5 for a diamond.
#' Other alternatives are \dQuote{*} for asterisks, \dQuote{.} for tiny dots, or \dQuote{+} for a smaller,
#' bolder cross.  These plotting symbols are standard for R (see \code{\link{par}}).
#' @param join Boolean operator to join observations by a straight line; the default is \code{True}.
#' @param x.qlab Proportionate value of x-axis at which to draw the quantile labels; 0 is left, 1 is right.
#' The default is 0.4.
#' @param pos.qlab This allows more refined positioning of the quantile labels.  It takes standard R
#' values: 1, below; 2, left; 3, above; 4, right.
#' @param cex.qlab  Size of the quantile labels.
#' @param ci Width of confidence interval bands around simulated quantiles, from 0 to 1.  If 0, or \emph{nsim}<100, will not plot.
#' Default is 0.95, i.e. 95th percentile with tails of 2.5 percent above and below excluded.
#' @param cex.lab Size of the plot labels.
#' @param xlab Label for x-axis; default is \dQuote{Time}
#' @param ylab Label for y-axis; default is \dQuote{Output}
#' @param xlim Limits of the x-axis as a vector, e.g. \code{c(0,1)}.  It does not need to be specified, but can be.
#' @param ylim Analogous to \code{xlim}
#' @param obs The name of an \emph{makeOP} data object generated by \code{\link{makeOP}}.  If specified,
#' the observations will be overlaid upon the simulation plot enabling a visual predicitve check.  In this case,
#' a list object will be returned with two items: $npc containing the quantiles and probability that the observations
#' are below each quantile (binomial test); and $simsum, the times of each observation and the
#' value of the simulated quantile with upper and lower confidence intervals at that time.
#' @param grid Either a boolean operator to plot a reference grid, or a list with elements x and y,
#' each of which is a vector specifying the native coordinates to plot grid lines; the default is \code{False}.
#' For example, grid=list(x=seq(0,24,2),y=1:10).  Defaults for missing x or y will be calculated by \code{\link{axTicks}}.
#' @param ocol Color for observations
#' @param add Boolean operator, if \code{True} will add lines to existing plot
#' @param out Direct output to a PDF, EPS or image file.  Format is a named list whose first argument,
#' \code{type} is one of the following character vectors: \dQuote{pdf}, \dQuote{eps} (maps to \code{postscript}),
#' \dQuote{\code{png}}, \dQuote{\code{tiff}}, \dQuote{\code{jpeg}}, or \dQuote{\code{bmp}}.  Other named items in the list
#' are the arguments to each graphic device. PDF and EPS are vector images acceptable to most journals
#' in a very small file size, with scalable (i.e. infinite) resolution.  The others are raster images which may be very
#' large files at publication quality dots per inch (DPI), e.g. 800 or 1200. Default value is \code{NA} which means the
#' output will go to the current graphic device (usually the monitor). For example, to output an eps file,
#' out=list(\dQuote{eps}) will generate a 7x7 inch (default) graphic.
#' @param \dots Other parameters as found in \code{\link{plot.default}}.
#' @return Plots the simulation object.  If \code{obs} is included, a list will be returned with
#' the folowing items:
#' \item{npc}{A dataframe with three columns: quantile, prop.less, pval.  \emph{quantile} are those specified
#' by the \code{prob} argument to the plot call; \emph{prop.less} are the proportion of simulated
#' observations at all times less than the quantile; \emph{pval} is the P-value of the difference in the
#' prop.less and quantile by the beta-binomial test.}
#' \item{simsum}{A dataframe with the quantile concentration at each simulated time,
#' with lower and upper confidence intervals}
#' \item{obs}{A dataframe similar to an PMop object made by \code{\link{makeOP}}
#' with the addition of the quantile for each observation}
#' @author Michael Neely
#' @examples
#' library(PmetricsData)
#' plot(simEx$data[[1]])
#' @seealso \code{\link{SIMparse}}, \code{\link{plot}}, \code{\link{par}}, \code{\link{axis}}
#' @export

plot.PMsim <- function(x, mult = 1, log = TRUE, probs = c(0.05, 0.25, 0.5, 0.75, 0.95), binSize = 0, outeq = 1,
                       pch = NA, join = TRUE, x.qlab = 0.4, cex.qlab = 0.8, pos.qlab = 1, ci = 0.95,
                       cex.lab = 1.2, xlab = "Time (h)", ylab = "Output", xlim, ylim, obs,
                       grid, ocol = "blue", add = FALSE, out = NA, ...) {
  # choose output
  if (inherits(out, "list")) {
    if (out$type == "eps") {
      setEPS()
      out$type <- "postscript"
    }
    if (length(out) > 1) {
      do.call(out$type, args = out[-1])
    } else {
      do.call(out$type, list())
    }
  }
  # get other args
  otherArgs <- list(...)


  # numerical check function
  NPsimInterp <- function(time, out, sim.sum, probs) {
    if (min(sim.sum$time) <= time) {
      lower.time <- max(sim.sum$time[sim.sum$time <= time], na.rm = TRUE)
    } else {
      return(NA)
    }
    if (max(sim.sum$time >= time)) {
      upper.time <- min(sim.sum$time[sim.sum$time >= time], na.rm = TRUE)
    } else {
      return(NA)
    }
    sim.quantile <- 0
    for (i in probs) {
      if (lower.time != upper.time) {
        lower.sim <- sim.sum$out[sim.sum$time == lower.time & sim.sum$quantile == i]
        upper.sim <- sim.sum$out[sim.sum$time == upper.time & sim.sum$quantile == i]
        slope <- (upper.sim - lower.sim) / (upper.time - lower.time)
        calc.sim <- lower.sim + slope * (time - lower.time)
      } else {
        calc.sim <- sim.sum$out[sim.sum$time == lower.time & sim.sum$quantile == i]
      }
      if (out >= calc.sim) {
        sim.quantile <- i
      }
    }
    return(sim.quantile)
  }

  simout <- x

  if (!inherits(simout, "PMsim")) {
    stop("Use SIMparse() to make object of class Psim.\n")
  }
  if (!missing(obs)) {
    if (!inherits(obs, "PMop")) {
      stop("Use makeOP() to make object of class PMop.\n")
    }
    if (inherits(obs, "list")) {
      # we are dealing with old PMop
      obs <- obs[[2 * outeq]]
    } else {
      obs <- obs[obs$outeq == outeq & obs$icen == "median" & obs$pred.type == "post", ]
    }
  } else {
    obs <- data.frame(time = NA, obs = NA)
  }
  if (log) {
    logplot <- "y"
    yaxt <- "n"
    if (all(is.na(obs$obs))) {
      if (any(simout$obs <= 0, na.rm = TRUE)) {
        cat("Values <= 0 omitted from log plot.\n")
        simout$obs[simout$obs <= 0] <- NA
      }
    } else {
      if (any(obs$obs <= 0, na.rm = TRUE) | any(simout$obs <= 0, na.rm = TRUE)) {
        cat("Values <= 0 omitted from log plot.\n")
        obs$obs[obs$obs <= 0] <- NA
        simout$obs[simout$obs <= 0] <- NA
      }
    }
  } else {
    logplot <- ""
    yaxt <- "s"
  }
  if (join) {
    jointype <- "o"
  } else {
    jointype <- "p"
  }

  simout$obs$out <- simout$obs$out * mult
  obs$obs <- obs$obs * mult

  sim.out <- simout$obs[!is.na(simout$obs$out), ]
  # bin times if requested
  if (binSize > 0) {
    binnedTimes <- seq(floor(min(sim.out$time, na.rm = TRUE)), ceiling(max(sim.out$time, na.rm = TRUE)), binSize)
    sim.out$time <- binnedTimes[.bincode(sim.out$time, binnedTimes)]
  }

  nout <- max(sim.out$outeq)
  nsim <- nrow(simout$parValues)


  sim <- sim.out[sim.out$outeq == outeq, ]
  times <- sort(unique(sim$time))
  nobs <- length(times)

  if (!all(is.na(probs)) & nsim >= 10) {
    sim.quant <- tapply(sim$out, sim$time, quantile, probs = probs, na.rm = TRUE)
    lower.confint <- function(nsim) {
      l.ci <- ceiling(nsim * probs - qnorm(1 - (1 - ci) / 2) * sqrt(nsim * probs * (1 - probs)))
      l.ci[l.ci == 0] <- NA
      return(l.ci)
    }

    upper.confint <- function(nsim) {
      u.ci <- ceiling(nsim * probs + qnorm(1 - (1 - ci) / 2) * sqrt(nsim * probs * (1 - probs)))
      return(u.ci)
    }

    sim.lconfint <- tapply(sim$out, sim$time, function(x) sort(x)[lower.confint(length(x))])
    sim.uconfint <- tapply(sim$out, sim$time, function(x) sort(x)[upper.confint(length(x))])
    sim.sum <- data.frame(
      time = rep(times, each = length(probs)), out = unlist(sim.quant),
      lower.confint = unlist(sim.lconfint), upper.confint = unlist(sim.uconfint), quantile = rep(probs, nobs)
    )
    row.names(sim.sum) <- 1:nrow(sim.sum)

    if (missing(ylim)) {
      ylim <- c(min(c(sim.sum$out, obs$obs), na.rm = TRUE), max(c(sim.sum$out, obs$obs), na.rm = TRUE))
    }
    if (missing(xlim)) {
      xlim <- c(min(c(sim.sum$time, obs$time), na.rm = TRUE), max(c(sim.sum$time, obs$time), na.rm = TRUE))
    }

    if (!add) {
      do.call("plot", args = c(list(out ~ time, data = sim.sum, type = "n", log = logplot, xlab = xlab, ylab = ylab, cex.lab = cex.lab, xlim = xlim, ylim = ylim, yaxt = yaxt), otherArgs))
      # plot(out~time,data=sim.sum,type="n",log=logplot,xlab=xlab,ylab=ylab,cex.lab=cex.lab,xlim=xlim,ylim=ylim,yaxt=yaxt,otherArgs2)
      if (missing(grid)) {
        grid <- list(x = NA, y = NA)
      } else {
        if (inherits(grid, "logical")) {
          if (grid) {
            grid <- list(x = axTicks(1), y = axTicks(2))
          } else {
            grid <- list(x = NA, y = NA)
          }
        }
        if (inherits(grid, "list")) {
          if (is.null(grid$x)) grid$x <- axTicks(1)
          if (is.null(grid$y)) grid$y <- axTicks(2)
        }
      }
      if (yaxt == "n") logAxis(2, grid = !all(is.na(grid$y)))
      abline(v = grid$x, lty = 1, col = "lightgray")
      abline(h = grid$y, lty = 1, col = "lightgray")
    }
    if (nsim < 100) {
      cat("\nNote: Confidence intervals for simulation quantiles omitted when nsim < 100\n")
    }

    if (!is.na(probs[1])) {
      if ("lwd" %in% names(otherArgs)) {
        lwd <- rep(otherArgs$lwd, length(probs))
        otherArgs[[which(names(otherArgs) == "lwd")]] <- NULL
      } else {
        lwd <- rep(1, length(probs))
      }
      if ("col" %in% names(otherArgs)) {
        col <- rep(otherArgs$col, length(probs))
        otherArgs[[which(names(otherArgs) == "col")]] <- NULL
      } else {
        col <- rep("gray50", length(probs))
      }
    }

    for (i in 1:length(probs)) {
      if (nsim >= 100 & ci > 0) {
        temp <- data.frame(
          x = c(sim.sum$time[sim.sum$quantile == probs[i]], rev(sim.sum$time[sim.sum$quantile == probs[i]])),
          y = c(sim.sum$lower.confint[sim.sum$quantile == probs[i]], rev(sim.sum$upper.confint[sim.sum$quantile == probs[i]]))
        )
        polygon(x = temp$x, y = temp$y, col = "lightgrey", border = NA)
      }
      # points(out~time,subset(sim.sum,sim.sum$quantile==probs[i]),pch=pch,lwd=lwd[i],col=col[i],otherArgs)
      do.call("points", args = c(list(out ~ time, data = subset(sim.sum, sim.sum$quantile == probs[i]), pch = pch, lwd = lwd[i], col = col[i]), otherArgs))

      if (jointype == "o") do.call(lines, args = c(list(out ~ time, data = subset(sim.sum, sim.sum$quantile == probs[i]), pch = pch, lwd = lwd[i], col = col[i]), otherArgs))

      hpos.text <- xlim[1] + x.qlab * (xlim[2] - xlim[1])
      if (!hpos.text %in% sim.sum$time) {
        lower.time <- tail(sim.sum$time[sim.sum$time < hpos.text], 1)
        upper.time <- head(sim.sum$time[sim.sum$time > hpos.text], 1)
        lower.sim <- sim.sum$out[sim.sum$time == lower.time & sim.sum$quantile == probs[i]]
        upper.sim <- sim.sum$out[sim.sum$time == upper.time & sim.sum$quantile == probs[i]]
        if (!log) {
          slope <- (upper.sim - lower.sim) / (upper.time - lower.time)
          vpos.text <- lower.sim + slope * (hpos.text - lower.time)
        } else {
          slope <- (log10(upper.sim) - log10(lower.sim)) / (log10(upper.time) - log10(lower.time))
          vpos.text <- 10**(log10(lower.sim) + slope * (log10(hpos.text) - log10(lower.time)))
        }
      } else {
        vpos.text <- sim.sum$out[sim.sum$time == hpos.text & sim.sum$quantile == probs[i]]
      }
      text(x = hpos.text, y = vpos.text, labels = probs[i], cex = cex.qlab, pos = pos.qlab)
    }

    if (!all(is.na(obs))) {
      #       #bin times if requested
      #       if(binSize > 0){
      #         binnedTimes <- seq(floor(min(obs$time)),ceiling(max(obs$time)),binSize)
      #         obs$time <- binnedTimes[.bincode(obs$time,binnedTimes)]
      #       }
      do.call("points", args = c(list(obs$obs ~ obs$time, col = ocol), otherArgs))
      for (i in 1:nrow(obs)) {
        obs$sim.quant[i] <- ifelse(is.na(obs$obs[i]), NA, NPsimInterp(obs$time[i], obs$obs[i], sim.sum, probs = probs))
      }
      not.miss <- sum(!is.na(obs$sim.quant))
      npc <- data.frame(quantile = probs, prop.less = rep(NA, length(probs)), pval = rep(NA, length(probs)))
      for (i in 1:nrow(npc)) {
        success <- sum(as.numeric(obs$sim.quant < probs[i]), na.rm = TRUE)

        pval <- binom.test(success, not.miss, probs[i], alternative = "two")$p.value
        npc$prop.less[i] <- round(success / not.miss, 3)
        npc$pval[i] <- pval
      }

      # calculate proportion between 0.05 and 0.95
      between <- rep(NA, nrow(obs))
      for (i in 1:nrow(obs)) {
        between[i] <- ifelse(is.na(obs$obs[i]), NA, NPsimInterp(obs$time[i], obs$obs[i], sim.sum, probs = c(0.05, 0.95)))
      }
      success90 <- sum(as.numeric(between >= 0.05 & between < 0.95), na.rm = TRUE)
      attr(npc, "05-95") <- success90 / not.miss
      attr(npc, "P-90") <- binom.test(success90, not.miss, 0.9, "two")$p.value

      if (not.miss < nrow(obs)) {
        cat(paste("\n", nrow(obs) - not.miss, " observed values were obtained beyond the \nsimulated time range of ", min(sim.sum$time), " to ", max(sim.sum$time), " and were excluded.", sep = ""))
      }

      # close device if necessary
      if (inherits(out, "list")) dev.off()

      retVal <- list(npc = npc, simsum = sim.sum, obs = obs)
      class(retVal) <- c("PMnpc", "list")
      return(retVal)
    } else {
      # close device if necessary
      if (inherits(out, "list")) dev.off()
      return(invisible(1))
    }
  } else {
    # probs are missing or nsim too low, plot all simulated profiles and skip numerical predictive check
    if (nsim < 10) cat("\nQuantiles not calculated with fewer than 10 simulated profiles.\n")
    if (missing(ylim)) {
      ylim <- c(min(c(sim$out, obs$obs), na.rm = TRUE), max(c(sim$out, obs$obs), na.rm = TRUE))
    }
    if (missing(xlim)) {
      xlim <- c(min(c(sim$time, obs$time), na.rm = TRUE), max(c(sim$time, obs$time), na.rm = TRUE))
    }
    if (!add) {
      do.call("plot", args = c(list(out ~ time, data = sim, type = "n", log = logplot, xlab = xlab, ylab = ylab, cex.lab = cex.lab, xlim = xlim, ylim = ylim, yaxt = yaxt), otherArgs))
      if (missing(grid)) {
        grid <- list(x = NA, y = NA)
      } else {
        if (inherits(grid, "logical")) {
          if (grid) {
            grid <- list(x = axTicks(1), y = axTicks(2))
          } else {
            grid <- list(x = NA, y = NA)
          }
        }
        if (inherits(grid, "list")) {
          if (is.null(grid$x)) grid$x <- axTicks(1)
          if (is.null(grid$y)) grid$y <- axTicks(2)
        }
      }
      if (yaxt == "n") logAxis(2, grid = !all(is.na(grid$y)))
      abline(v = grid$x, lty = 1, col = "lightgray")
      abline(h = grid$y, lty = 1, col = "lightgray")
    } # end !add block
    for (i in unique(sim$id)) {
      do.call("points", args = c(list(out ~ time, subset(sim, sim$id == i), pch = pch, type = jointype), otherArgs))
    }

    if (!all(is.na(obs))) {
      do.call("points", args = c(list(obs$obs ~ obs$time, type = "p", col = ocol), otherArgs))
    }

    # close device if necessary
    if (inherits(out, "list")) dev.off()

    return(invisible(1))
  }
}
