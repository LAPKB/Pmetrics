#' Plots *PMsim* objects with the option to perform a visual and numerical predictive check
#'
#' Simulated observations are plotted as quantiles on the y-axis vs. time on the x.axis.  If measured
#' observations are included, a visual and numerical predictive check will be performed.
#' The default plot is to omit markers, but if the marker arugment is set to `TRUE`,
#' the resulting marker will have the following plotly properties:
#' `list(symbol = "circle-open", color = "black", size = 8)`. By default a grid is
#' omitted. The legend is also omitted by default, but if included, 
#' clicking on a quantile item in the legend will hide it in the plot,
#' and double clicking will hide all other quantiles.
#'
#' @title Plot Pmetrics Simulation Objects
#' @method plot PMsim
#' @param x The name of an *PMsim* data object generated by [PM_sim]
#' @template mult
#' @template log
#' @param probs List of quantiles to plot, e.g. `probs = list(0.05, 0.5, 0.95)`. 
#' If set to `NA`, all simulated profiles will be plotted,
#' and numerical predictive checking will be suppressed. 
#' To format individual quantile lines, expand the list object for that quantile
#' For example, `probs = list(0.05, list(value = 0.5, color = "red", width = 2, dash = "dash"), 0.95)`. 
#' Use the plotly `plotly::schema()` command
#' in the console and navigate to traces > scatter > attributes > line to see all the ways the marker
#' can be formatted. Most common will be:
#' * color Fill color and outline color if not otherwise specified
#' * symbol Plotting character. See `plotly::schema()`, traces > scatter > attributes > marker > symbol > values.
#' * size Character size in points
#' * opacity Ranging between 0 (fully transparent) to 1 (fully opaque).
#' @param ci Width of confidence interval bands around simulated quantiles, 
#' from 0 to 1.  If 0, or *nsim*<100, will not plot.
#' Default is 0.95, i.e. 95th percentile with tails of 2.5 percent above and below excluded.
#' @param binSize Width of binning interval for simulated concentrations, in time units, e.g. hours.  
#' A `binSize` of 0.5 will pull all simulated concentrations +/- 0.5 hours into 
#' the same time.  This is useful
#' for plotting PMsim objects made during [makeValid]. The default is 0, i.e. no binning.
#' If an `obs` object is provided, it will be binned similarly.
#' @template outeq
#' @template marker
#' @template grid
#' @template xlab
#' @template ylab
#' @template xlim
#' @template ylim
#' @template legend
#' @param obs The name of a [PM_result] data object or the PM_op field in the 
#' PM_result object, all generated by [PM_load].  For example, if
#' `run1 <- PM_load(1)` and `sim1` is a PM_sim object, then 
#' `sim1$plot(obs = run1)` or `sim1$plot(obs = run1$op)`.
#' If specified,
#' the observations will be overlaid upon the simulation plot 
#' enabling a visual predictive check.  In this case,
#' a list object will be returned with two items: $npc containing the quantiles 
#' and probability that the observations
#' are below each quantile (binomial test); and $simsum, the times of each 
#' observation and the 
#' value of the simulated quantile with upper and lower confidence intervals at that time.
#' Additionally, the number of observations beyond the 5th and 95th percentiles will be reported
#' and the binomial test P-value if this number is different than the expected 10% value.
#' @param quiet Suppress plot if `TRUE`.
#' @param \dots Other parameters which can be passed to control axis formatting. Specify as lists
#' named either xaxis or yaxis. See `plotly::schema()` layout > xaxis/yaxis for options.
#' @return Plots the simulation object.  If `obs` is included, a list will be returned with
#' the folowing items:
#' * npc A dataframe with three columns: quantile, prop_less, pval.  
#' ** quantile are those specified by the `probs` argument to the plot call
#' ** prop_less are the proportion of simulated
#' observations at all times less than the quantile
#' ** pval is the P-value of the difference in the 
#' prop.less and quantile by the beta-binomial test.
#' * simsum A dataframe with the quantile concentration at each simulated time,
#' with lower and upper confidence intervals
#' * obs A data frame similar to an PMop object made by [makeOP] at the end of a run
#' with the addition of the quantile for each observation
#' @author Michael Neely
#' @seealso [PM_sim], [plot_ly], [schema]
#' @importFrom tidyr unnest_longer
#' @importFrom dplyr summarize
#' @export
#' @family PMplots

plot.PMsim <- function(x, 
                       mult = 1, 
                       log = T, 
                       probs = list(0.05, 0.25, 0.5, 0.75, 0.95),
                       ci = 0.95,
                       binSize = 0, 
                       outeq = 1,
                       marker = F, 
                       grid = F,
                       xlab="Time",ylab="Output",
                       xlim, ylim, 
                       legend = F, 
                       obs,
                       quiet = F,...){
  
  
  dots <- list(...)
  
  if(!missing(obs)){
    if(!marker) marker <- T
  }
  
  marker <- amendMarker(marker, default = list(color = "black", symbol = "circle-open", size = 8))
  #parse probs
  
  #Case 1: probs = NA or misspecified as vector
  if(!is.list(probs)){ #probs is not a list
    if(length(probs)>1) {stop("Specify the probs argument as a list.")}
    if(is.na(probs[1])){ #probs specified as probs = NA
      join <- amendLine(T) #apply default join
      probValues <- NA
    } else { #probs specified as probs = numeric
      stop("Specify the probs argument as a list.")
    }
    
  } else {
    if(is.list(probs[[1]])){ #first probs item is a list
      
      #Case 2: probs = list(list(value=NA)) - unnecessary, but user might do it
      
      if(is.na(probs[[1]]$value)){ #is it set to NA?
        probValues <- NA
        if(length(probs[[1]])>1){ #more than one argument
          join <- amendLine(probs[[1]]$line) #extract the join format
        } else { #first probs value is just NA
          join <- amendLine(T)
        }
      }
    } else { #first probs item was not a list 
      probValues <- rep(0, times = length(probs))
      probFormats <- purrr::map(rep(TRUE, length(probs)), amendLine)
      
      listProbs <- which(sapply(probs, function(x) which(is.list(x))) == 1)
      if(length(listProbs)>0){
        numericProbs <- which(sapply(probs, function(x) which(is.numeric(x))) == 1)
        if(length(numericProbs>0)){
          probValues[numericProbs] <- unlist(probs[numericProbs])
        }
        probValues[listProbs] <- sapply(listProbs, function(x) probs[[x]]$value)
        for(i in listProbs){
          probFormats[[i]] <- modifyList(probFormats[[i]], probs[[i]])
          probFormats[[i]]$value <- NULL
        }
      } else {
        probValues <- unlist(probs)
      }
    }
  }
  
  
  xaxis <- purrr::pluck(dots, "xaxis") #check for additional changes
  if(is.null(xaxis)){xaxis <- list()}
  
  yaxis <- purrr::pluck(dots, "yaxis")
  if(is.null(yaxis)){yaxis <- list()}

  layout <- list()
  
  #legend
  legendList <- amendLegend(legend, default = list(title = list(text = "<b> Quantiles </b>")))
  layout <- modifyList(layout, list(showlegend = legendList[[1]], legend = legendList[-1]))

  #grid
  xaxis <- setGrid(xaxis, grid)
  yaxis <- setGrid(yaxis, grid)
  
  #axis labels
  xaxis <- modifyList(xaxis, list(title = list(text = xlab)))
  yaxis <- modifyList(yaxis, list(title = list(text = ylab)))
  
  #axis ranges
  if(!missing(xlim)){xaxis <- modifyList(xaxis, list(range = xlim)) }
  if(!missing(ylim)){yaxis <- modifyList(yaxis, list(range = ylim)) }
  
  #log y axis
  if(log){
    yaxis <- modifyList(yaxis, list(type = "log"))
  }
  
  #finalize layout
  layoutList <- modifyList(layout, list(xaxis = xaxis, yaxis = yaxis))
  
  
  #numerical check function
  NPsimInterp <- function(time, out, sim_sum, probs){
    if (min(sim_sum$time) <= time){
      lower_time <- max(sim_sum$time[sim_sum$time <= time], na.rm = T)
    } else return(NA)
    if (max(sim_sum$time >= time)){
      upper_time <- min(sim_sum$time[sim_sum$time >= time], na.rm = T)
    } else return(NA)
    sim_quantile <- 0
    for (i in probs){
      if (lower_time != upper_time){
        lower_sim <- sim_sum$value[sim_sum$time == lower_time & sim_sum$quantile ==i ]
        upper_sim <- sim_sum$value[sim_sum$time == upper_time & sim_sum$quantile == i]
        slope <- (upper_sim - lower_sim) / (upper_time - lower_time)
        calc_sim <- lower_sim + slope*(time-lower_time)
      } else {calc_sim <- sim_sum$value[sim_sum$time == lower_time & sim_sum$quantile == i]}
      if (out >= calc_sim){
        sim_quantile <- i
      } 
    }
    return(sim_quantile)
  }
  
  simout <- x
  
  if(!inherits(simout,c("PM_sim", "PMsim"))){stop("Use PM_sim$run() to make object of class PM_sim.\n")}
  if(!missing(obs)){
    if(!inherits(obs, c("PM_result", "PM_op"))) stop("Supply a PM_result or PM_op object for the obs argument.")
    if(inherits(obs, "PM_result")){ obs <- obs$op$data}
    if(inherits(obs, "PM_op")){ obs <- obs$data}
    obs <- obs %>% filter(outeq == !!outeq, icen == "median", 
                          pred.type == "post") %>% select(id, time, obs) #just need obs; median and post are arbitrary
    
  } else {obs <- data.frame(time=NA,obs=NA)}
  
  #change <=0 to NA if log plot
  if(log){
    if(all(is.na(obs$obs))){
      if(any(simout$obs<=0,na.rm=T)){
        cat("Values <= 0 omitted from log plot.\n")
        simout$obs[simout$obs <= 0] <- NA            
      }
    } else {
      if(any(obs$obs<=0,na.rm=T) | any(simout$obs<=0,na.rm=T)){
        cat("Values <= 0 omitted from log plot.\n")
        obs$obs[obs$obs <= 0] <- NA
        simout$obs[simout$obs <= 0] <- NA
      }
    }
    
  } 
  
  #multiply 
  simout$obs$out <- simout$obs$out * mult
  obs$obs <- obs$obs * mult
  
  #simplify 
  sim_out <- simout$obs[!is.na(simout$obs$out),]
  
  #bin times if requested
  if(binSize > 0){
    binned_sim_times <- seq(floor(min(sim_out$time,na.rm=T)),ceiling(max(sim_out$time,na.rm=T)),binSize)
    sim_out$time <- binned_sim_times[.bincode(sim_out$time, binned_sim_times, include.lowest = T)]
    sim_out <- sim_out %>% group_by(id, time, outeq) %>% summarize(out = mean(out), .groups = "drop") 
    if(!all(is.na(obs$obs))){
      binned_obs_times <- seq(floor(min(obs$time,na.rm=T)),ceiling(max(obs$time,na.rm=T)),binSize)
      obs$time <- binned_obs_times[.bincode(obs$time, binned_obs_times, include.lowest = T)]
      obs <- obs %>% group_by(id, time) %>% summarize(obs = mean(obs), .groups = "drop") 
    }
  }
  
  nout <- max(sim_out$outeq)
  nsim <- nrow(simout$parValues)
  
  
  sim <- sim_out %>% filter(outeq == !!outeq)
  times <- sort(unique(sim$time))
  nobs <- length(times)
  
  if(!all(is.na(probValues)) & nsim>=10){
    
    #make DF of time, quantile and value
    sim_quant_df <- sim %>% 
      group_by(time) %>% 
      group_map(~quantile(.x$out, probs = probValues, na.rm = T)) %>%
      tibble() %>%
      tidyr::unnest_longer(1, indices_to = "quantile", values_to = "value") %>%
      mutate(time = rep(times, each = length(probValues)),
             quantile = readr::parse_number(quantile)/100) %>%
      select(time, quantile, value)
    
    lower_confint <- function(n) {
      l.ci <- ceiling(n*probValues - qnorm(1-(1-ci)/2)*sqrt(n*probValues*(1-probValues)))
      l.ci[l.ci==0] <- NA
      return(l.ci)
    }
    
    upper_confint <- function(n) {
      u.ci <- ceiling(n*probValues + qnorm(1-(1-ci)/2)*sqrt(n*probValues*(1-probValues)))
      return(u.ci)
    }
    
    lconfint <- tapply(sim$out,sim$time,function(x) sort(x)[lower_confint(length(x))])
    uconfint <- tapply(sim$out,sim$time,function(x) sort(x)[upper_confint(length(x))])
    
    sim_quant_df$lowerCI <- unlist(lconfint)
    sim_quant_df$upperCI <- unlist(uconfint)
    
    #plot main data
    p <- sim_quant_df %>% 
      group_by(quantile) %>%
      plotly::plot_ly(x = ~time, y = ~value)
    
    #add confidence intervals
    if(nsim<100) {
      cat("\nNote: Confidence intervals for simulation quantiles omitted when nsim < 100\n")
    } else {
      p <- p %>%
        plotly::add_ribbons(ymin = ~lowerCI, ymax = ~upperCI,
                            color = I("grey"), opacity = 0.5,
                            line = list(width = 0),
                            hoverinfo = "none", 
                            showlegend = F) 
    }
    
    #add quantile lines, allowing for the independent formats 
    for(i in 1:length(probValues)){
      thisQ <- sim_quant_df %>% filter(quantile == probValues[i])
      p <- p %>% plotly::add_lines(x = ~time, y = ~value, data = thisQ, line = probFormats[[i]],
                                   hovertemplate =  "Time: %{x}<br>Out: %{y}<br>Quantile: %{text}<extra></extra>",
                                   text = ~quantile,
                                   name = ~quantile)
    }
    retValue <- list()
    
    #add observations if supplied, and calculate NPC
    if(!all(is.na(obs))){
      p <- p %>% add_markers(x = ~time, y = ~obs, data = obs, marker = marker)
      obs$sim_quant <- NA
      
      for (i in 1:nrow(obs)){
        obs$sim_quant[i] <- ifelse(is.na(obs$obs[i]),NA,
                                   NPsimInterp(obs$time[i], obs$obs[i], sim_quant_df, probs = probValues))
      }
      not.miss <- sum(!is.na(obs$sim_quant))
      npc <- data.frame(quantile = probValues, 
                        prop_less = rep(NA, length(probValues)),
                        pval = rep(NA, length(probValues)))
      for (i in 1:nrow(npc)){
        success <- sum(as.numeric(obs$sim_quant < probValues[i]), na.rm = T)
        
        pval <- tryCatch(binom.test(success, not.miss, probValues[i], 
                                    alternative = "two")$p.value,
                         error = function(e) NA)
        npc$prop_less[i] <- round(success/not.miss, 3)
        npc$pval[i] <- pval
        
      }
      
      #calculate proportion between 0.05 and 0.95
      between <- rep(NA, nrow(obs))
      for (i in 1:nrow(obs)){
        between[i] <- ifelse(is.na(obs$obs[i]), NA,
                             NPsimInterp(obs$time[i], obs$obs[i], sim_quant_df, probs=c(0.05, 0.95)))
      }
      success90 <- sum(as.numeric(between >= 0.05 & between < 0.95), na.rm = T)
      attr(npc, "05-95") <- success90/not.miss
      attr(npc, "P-90") <- binom.test(success90, not.miss, 0.9, "two")$p.value
      
      if (not.miss < nrow(obs)){cat(paste("\n",nrow(obs)-not.miss," observed values were obtained beyond the \nsimulated time range of ",min(sim_quant_df$time)," to ",max(sim_quant_df$time)," and were excluded.", sep = ""))}
      
      
      retValue <- modifyList(retValue, list(npc=npc, simsum=sim_quant_df, obs=obs))
      class(retValue) <- c("PMnpc","list")
      
    }
  } else { #probs was set to NA or nsim < 10
    
    #plot all simulated profiles
    p <- sim %>% 
      group_by(id) %>%
      plotly::plot_ly(x = ~time, y = ~out) %>%
      plotly::add_lines(line = join)
    #plot observations if available
    if(!all(is.na(obs))){
      p <- p %>% add_markers(x = ~time, y = ~obs, data = obs, marker = marker)
    }
    retValue <- list()
  }
  
  
  #common to all plots
  p <- p %>% plotly::layout(xaxis = layoutList$xaxis,
                            yaxis = layoutList$yaxis,
                            showlegend = layoutList$showlegend,
                            legend = layoutList$legend)
  
  
  if(!quiet) print(p)
  retValue <- modifyList(retValue, list(p = p))
  return(retValue)
}

