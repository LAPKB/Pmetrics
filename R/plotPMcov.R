#' @title Plot Pmetrics Covariate objects
#' @description
#' `r lifecycle::badge("stable")`
#'
#' Plot PMcov objects
#' @details
#' This method will plot any two columns, specified using a formula, of a PMcov object, which contains covariate and Bayesian posterior parameter information
#' for each subject.  Specifiying any two variables that do not include time will result in a scatter plot with optional regression and reference lines.  If
#' time is included as the x variable, the y variable will be plotted vs. time, aggregated by subject.  This can be useful to see time varying parameters,
#' although a formula within formula approach may be required, e.g. `$plot(I(cl_0*wt**0.75) ~ time)` in order to see the change in cl over time according to
#' the change in wt over time, even though cl_0 is constant for a given subject.
#'
#' @method plot PM_cov
#' @param x The name of an [PM_cov] data object generated by [makeCov]
#' and loaded with [PM_load] as a [PM_result], e.g. `PM_result$cov`.
#' @param formula This is a mandatory formula of the form \code{y ~ x}, where \code{y} and \code{x}
#' are the two \code{data} parameters to plot.
#' @param legend Not used for this function.
#' @param include `r template("include")`
#' @param exclude `r template("exclude")`
#' @param icen `r template("icen")`
#' @param line Controls characteristics of lines. Unlike
#' some other Pmetrics plots, but like [plot.PM_op], `line` is a list of
#' three elements:
#' * `lm`  If set to `TRUE` or a list of plotly line attributes,
#' will generate a linear regression of the form y ~ x
#' Line attributes will control the appearance of the regression
#' line and the confidence interval around the line. If set to
#' `FALSE`, no linear regression will be generated. The default
#' values for the elements of the `lm` list, all of which can be
#' overriden are:
#'     - `ci` Confidence interval around the regression, default 0.95.
#'     - `color` Color of the regression line and the confidence area around
#' the line, but at opacity = 0.2. Default is "dodgerblue".
#'     - `width `Width of the regression line, default 1.
#'     - `dash` See `plotly::schema()`, traces > scatter > attributes >
#' line > dash > values. Default is "solid".
#' Example: `line = list(lm = list(color = "red", dash = "longdash", width = 2))`
#' * `loess` If set to `TRUE` or a list of plotly line attributes,
#' will generate a loess regression of the form y ~ x
#' The list elements and default values in the `loess` list are the
#' same as for `lm` except the default style is "dash".
#' Example: `line = list(lm = FALSE, loess = TRUE)`
#' * `ref` If set to `TRUE` or a list of plotly line attributes,
#' will generate a reference line with slope = 1 and intercept = 0.
#' The default values for the elements of the `ref` list are:
#'     - `color` "grey".
#'     - `width` 1.
#'     - `dash` "dot".
#' Note that there is no *ci* argument for the *ref* list.
#' Example: `line = list(lm = FALSE, loess = TRUE, ref = list(color = "lightgrey"))`
#' If the `line` argument is missing, it will be set to
#' `line = list(lm = FALSE, loess = TRUE, ref = FALSE)`, i.e. there will be a linear
#' regression with reference line, but no loess regression.
#' If *time* is chosen as the x variable in the formula, linear, loess and reference
#' lines will be suppressed, although formatting specified in the loess line (except color,
#' see below) will be applied to the lines joining the subject values.
#' @param marker `r template("marker")` Default is
#' `marker = list(color = orange, shape = "circle", size = 10, opacity = 0.5, line = list(color = black, width = 1))`.
#' @param colors to use for subjects when *time* is set as the x parameter.
#' This can be a palette or a vector of colors.
#' For accepted palette names see `RColorBrewer::brewer.pal.info`. Examples include
#' "BrBG", or "Set2". An example vector could be `c("red", "green", "blue")`. It is not
#' necessary to specify the same number of colors as groups within `color`, as colors
#' will be interpolated to generate the correct number. The default
#' is the "Spectral" palette. This will override any color in the `marker` or `line`.
#' @param log `r template("log")`
#' @param grid `r template("grid")`
#' @param xlim `r template("xlim")`
#' @param ylim `r template("ylim")`
#' @param xlab `r template("xlab")`   If missing, will default to the name of the
#' x variable in the formula.
#' @param ylab `r template("ylab")`   If missing, will default to the name of the
#' y variable in the formula.
#' @param title `r template("title")` Default is to have no title.
#' @param stats Add the statistics from linear regression to the plot. If
#' `FALSE`, will be suppressed. Default is `TRUE` which results in default format of
#' `list(x= 0.8, y = 0.1, bold = F, font = list(color = "black", family = "Arial", size = 14))`.
#' The coordinates are relative to the plot with lower left = (0,0), upper right = (1,1). This
#' argument maps to `plotly::add_text()`.
#' @param \dots `r template("dotsPlotly")`
#' @return Plots the object.
#' @author Michael Neely
#' @seealso [makeCov], [PM_result], [schema]
#' @export
#' @examples
#' library(PmetricsData)
#' NPex$cov$plot(V ~ wt)
#' NPex$cov$plot(Ke ~ wt, line = list(lm = TRUE, ref = FALSE, loess = FALSE))
#' NPex$cov$plot(Ke ~ wt, line = list(loess = list(ci = 0.9, color = "green")))
#' NPex$cov$plot(V ~ time, marker = list(color = "blue"))
#' NPex$cov$plot(V ~ wt,
#'   line = list(lm = TRUE, loess = FALSE),
#'   stats = list(x = 0.5, y = 0.2, font = list(size = 7, color = "blue"))
#' )
#'
#' @family PMplots

plot.PM_cov <- function(x,
                        formula,
                        line = list(lm = NULL, loess = NULL, ref = NULL),
                        marker = TRUE,
                        colors,
                        icen = "median",
                        include, exclude,
                        legend,
                        log = FALSE,
                        grid = TRUE,
                        xlab, ylab,
                        title,
                        stats = TRUE,
                        xlim, ylim, ...) {
  x <- if (inherits(x, "PM_cov")) {
    x$data
  } else {
    x
  }
  # include/exclude
  if (missing(include)) include <- unique(x$id)
  if (missing(exclude)) exclude <- NA

  if (missing(formula)) stop("Please supply a formula of the form y ~ x")


  vars <- names(get_all_vars(formula = formula, data = x))
  timearg <- "time" %in% vars

  if (!timearg) { # if time is not part of the formula, collapse to summary
    x <- summary.PMcov(x, icen = icen) %>%
      includeExclude(include, exclude) %>%
      dplyr::arrange(id, time)
  } else { # time is part of formula, so select icen but don't summarize
    x <- x %>%
      filter(icen == !!icen) %>%
      includeExclude(include, exclude) %>%
      dplyr::arrange(id, time) %>%
      select(-icen)
  }

  # final data, calling columns x and y
  dat <- x %>% select(id, x = vars[2], y = vars[1])



  # process reference lines
  if (any(!names(line) %in% c("lm", "loess", "ref"))) { # ref/pred?
    cat(paste0(crayon::red("Warning: "), crayon::blue("line"), " should be a list with at most three named elements: ", crayon::blue("lm"), ", ", crayon::blue("loess"), " and/or ", crayon::blue("ref"), ".\n See help(\"plot.PM_op\")."))
  }
  if (!is.list(line)) {
    cat(paste0(crayon::red("Error: "), crayon::blue("line"), " should be a list(). See help(\"plot.PM_op\")."))
  }

  # defaults
  if (is.null(line$lm)) {
    line$lm <- FALSE
  }
  if (is.null(line$loess)) {
    line$loess <- TRUE
  }
  if (is.null(line$ref)) {
    line$ref <- FALSE
  }

  marker <- amendMarker(marker, default = list(color = "orange"))
  lmLine <- amendLine(line$lm, default = list(color = "dodgerblue", dash = "solid"))
  loessLine <- amendLine(line$loess, default = list(color = "dodgerblue", dash = "dash"))
  refLine <- amendLine(line$ref, default = list(color = "grey", dash = "dot"))

  if (missing(colors)) {
    colors <- "Spectral"
  }

  if (is.logical(line$lm)) {
    lmLine$plot <- line$lm
  } else {
    lmLine$plot <- T
  }

  if (is.logical(line$loess)) {
    loessLine$plot <- line$loess
  } else {
    loessLine$plot <- T
  }

  if (is.logical(line$ref)) {
    refLine$plot <- line$ref
  } else {
    refLine$plot <- T
  }


  # process dots
  layout <- amendDots(list(...))

  # legend - not needed for this function
  layout <- modifyList(layout, list(showlegend = F))

  # grid
  layout$xaxis <- setGrid(layout$xaxis, grid)
  layout$yaxis <- setGrid(layout$yaxis, grid)

  # axis ranges
  if (!missing(xlim)) {
    layout$xaxis <- modifyList(layout$xaxis, list(range = xlim))
  }
  if (!missing(ylim)) {
    layout$yaxis <- modifyList(layout$yaxis, list(range = ylim))
  }

  # title
  if (missing(title)) {
    title <- ""
  }
  layout$title <- amendTitle(title, default = list(size = 20))

  # axis labels
  xlab <- if (missing(xlab)) {
    vars[2]
  } else {
    xlab
  }
  ylab <- if (missing(ylab)) {
    vars[1]
  } else {
    ylab
  }

  layout$xaxis$title <- amendTitle(xlab)
  if (is.character(ylab)) {
    layout$yaxis$title <- amendTitle(ylab, layout$xaxis$title$font)
  } else {
    layout$yaxis$title <- amendTitle(ylab)
  }

  # log axes
  if (log) {
    layout$xaxis <- modifyList(layout$xaxis, list(type = "log"))
    layout$yaxis <- modifyList(layout$yaxis, list(type = "log"))
  }

  # PLOTS -------------------------------------------------------------------
  if (!timearg) { # default plot

    p <- dat %>%
      plotly::plot_ly(x = ~x) %>%
      plotly::add_markers(
        y = ~y,
        marker = marker,
        text = ~id,
        hovertemplate = paste0(vars[2], ": %{x:.2f}<br>", vars[1], ": %{y:.2f}<br>ID: %{text}<extra></extra>")
      )

    if (lmLine$plot) { # linear regression
      lmLine$plot <- NULL # remove to allow only formatting arguments below
      if (is.null(purrr::pluck(lmLine$ci))) {
        ci <- 0.95
      } else {
        ci <- lmLine$ci
        lmLine$ci <- NULL # remove to allow only formatting arguments below
      }

      p <- p %>% add_smooth(x = ~x, y = ~y, ci = ci, line = lmLine, stats = stats)
    }

    if (loessLine$plot) { # loess regression
      loessLine$plot <- NULL # remove to allow only formatting arguments below
      if (is.null(purrr::pluck(loessLine$ci))) {
        ci <- 0.95
      } else {
        ci <- loessLine$ci
        loessLine$ci <- NULL # remove to allow only formatting arguments below
      }
      p <- p %>% add_smooth(x = ~x, y = ~y, ci = ci, line = loessLine, method = "loess")
    }

    if (refLine$plot) { # reference line
      refLine$plot <- NULL # remove to allow only formatting arguments below
      # get ref line
      layout$refLine <- list(
        type = "line",
        x0 = ~ max(min(x), min(y)),
        y0 = ~ max(min(x), min(y)),
        x1 = ~ min(max(x), max(y)),
        y1 = ~ min(max(x), max(y)),
        xref = "x",
        yref = "y",
        line = refLine
      )
    }

    # set layout
    p <- p %>%
      plotly::layout(
        xaxis = layout$xaxis,
        yaxis = layout$yaxis,
        showlegend = layout$showlegend,
        shapes = layout$refLine,
        title = layout$title
      )

    print(p)
    return(p)
  } else { # timearg plot
    marker$color <- NULL
    loessLine$color <- NULL
    
    
    n_colors <- length(unique(dat$id))
    if(requireNamespace("RColorBrewer", quietly = TRUE)){
      palettes <- RColorBrewer::brewer.pal.info %>% mutate(name = rownames(.))
      max_colors <- palettes$maxcolors[match(colors, palettes$name)]
      # expand colors as needed
      if (all(colors %in% palettes$name)) {
        colors <- colorRampPalette(RColorBrewer::brewer.pal(max_colors, colors))(n_colors)
      } else {
        colors <- colorRampPalette(colors)(n_colors)
      }
    } else {
      cat(paste0(crayon::green("Note: "), "Colors are better with RColorBrewer package installed.\n"))
      colors <- getDefaultColors(n_colors) #in plotly_Utils
    }
    
    
    
    p <- dat %>%
      group_by(id) %>%
      plotly::plot_ly(
        x = ~x,
        color = ~ as.factor(id),
        colors = colors
      ) %>%
      plotly::add_markers(
        y = ~y,
        marker = marker,
        text = ~id,
        hovertemplate = paste0(vars[2], ": %{x:.2f}<br>", vars[1], ": %{y:.2f}<br>ID: %{text}<extra></extra>")
      ) %>%
      plotly::add_lines(
        y = ~y,
        line = loessLine
      )



    # set layout
    p <- p %>%
      plotly::layout(
        xaxis = layout$xaxis,
        yaxis = layout$yaxis,
        showlegend = layout$showlegend,
        shapes = layout$refLine,
        title = layout$title
      )

    print(p)
    return(p)
  }
}
#' @title Plot Pmetrics Covariate objects
#' @description
#' `r lifecycle::badge("superseded")`
#'
#' This method is largely superseded by [plot.PM_cov].
#' @details
#' It will plot any two columns, specified using a formula, of a *PMcov* object,
#' which contains covariate and Bayesian posterior parameter information
#' for each subject.  *PMcov* objects can be
#' accessed as the `$data` object within the `$cov` field of a [PM_result] object, e.g.
#' `PM_result$cov$data`.
#' Specifying any two variables that do not include time will result in a scatter plot with optional regression and reference lines.  If
#' time is included as the x variable, the y variable will be plotted vs. time, aggregated by subject.  This can be useful to see time varying parameters,
#' although a formula within formula approach may be required, e.g. plot(cov.1,I(cl_0*wt**0.75)~time) in order to see the change in cl over time according to
#' the change in wt over time, even though cl_0 is constant for a given subject.
#'
#' @method plot PMcov
#' @param x The name of an \emph{PMcov} data object generated by \code{\link{makeCov}}
#' @param formula This is a mandatory formula of the form \code{y ~ x}, where \code{y} and \code{x}
#' are the two \code{data} parameters to plot.
#' @param icen A character vector to summarize covariate and parameter values.  Default is \dQuote{median}, but can also be one of \dQuote{none},
#' \dQuote{mean}.  If \code{time} is a variable in \code{formula}, the value will be set to \dQuote{none} and the \code{y} values
#' will be aggregated by subject ID vs. time.
#' @param include A vector of subject IDs to include in the plot, e.g. c(1:3,5,15)
#' @param exclude A vector of subject IDs to exclude in the plot, e.g. c(4,6:14,16:20)
#' @param mult Multiplication factor for y axis, e.g. to convert mg/L to ng/mL
#' @param log Boolean operator to plot in log-log space; the default is \code{False}
#' @param square Boolean operator to force a square plot with equal x and y limits; the default is \code{True}
#' @param ref Boolean operator to draw a unity line; the default is \code{True} unless \dQuote{time} is the x value in \code{formula} in which case this is ignored
#' @param lowess Boolean operator to draw a lowess regression line; the default is \code{False} and this is ignored if \dQuote{time} is the x value in \code{formula}
#' @param reg Boolean operator to draw a linear regression line; the default is \code{True} unless \dQuote{time} is the x value in \code{formula} in which case this is ignored.
#' If this option is selected, regression statistics will be printed on the plot if at least 3 subjects are included.
#' @param ident Boolean operator to plot points as ID numbers; the default is \code{False}.
#' This option is useful to identify outliers.
#' @param grid Either a boolean operator to plot a reference grid, or a list with elements x and y,
#' each of which is a vector specifying the native coordinates to plot grid lines; the default is \code{False}.
#' For example, grid=list(x=seq(0,24,2),y=1:10).  Defaults for missing x or y will be calculated by \code{\link{axTicks}}.
#' @param ci The confidence interval for the linear regression parameter estimates; the default is 0.95.
#' @param cex Size of the plot symbols.
#' @param cex.lab Size of the plot labels.
#' @param x.stat Horizontal position to plot the linear regression statistics;
#' the units are relative to the origin, i.e. extreme left is 0 and extreme right is 1.
#' @param y.stat Vertical position to plot the linear regression statistics;
#' the units are relative to the origin, i.e. extreme bottom is 0 and extreme top is 1.
#' @param col.stat Color of the text for the regression statistics.
#' @param cex.stat Size of the text for the regression statistics.
#' @param lwd Width of the various regression or reference lines (unity, linear regression, or
#' lowess regression)
#' @param col This parameter will be applied to the plotting symbol and is \dQuote{red} by default.
#' @param xlim Limits of the x-axis as a vector, e.g. \code{c(0,1)}.  It does not need to be specified, but can be.
#' @param ylim Analogous to \code{xlim}
#' @param xlab Label for the x-axis.  If missing, will default to the name of the x-variable.
#' @param ylab Label for the y-axis.  If missing, will default to the name of the y-variable.
#' @param out Direct output to a PDF, EPS or image file.  Format is a named list whose first argument,
#' \code{type} is one of the following character vectors: \dQuote{pdf}, \dQuote{eps} (maps to \code{postscript}),
#' \dQuote{\code{png}}, \dQuote{\code{tiff}}, \dQuote{\code{jpeg}}, or \dQuote{\code{bmp}}.  Other named items in the list
#' are the arguments to each graphic device. PDF and EPS are vector images acceptable to most journals
#' in a very small file size, with scalable (i.e. infinite) resolution.  The others are raster images which may be very
#' large files at publication quality dots per inch (DPI), e.g. 800 or 1200. Default value is \code{NA} which means the
#' output will go to the current graphic device (usually the monitor). For example, to output an eps file,
#' out=list(\dQuote{eps}) will generate a 7x7 inch (default) graphic.
#' @param \dots Other parameters as found in \code{\link{plot.default}}.
#' @return Plots the object.
#' @author Michael Neely
#' @seealso \code{\link{makeCov}}, \code{\link{plot}}, \code{\link{par}}, \code{\link{axis}}
#' @export
#' @examples
#' library(PmetricsData)
#' plot(NPex$cov$data, V ~ wt)
plot.PMcov <- function(x, formula, icen = "median", include, exclude, mult = 1, log = F, square = F, ref = F, lowess = F, grid = F, ident = F, reg = F, ci = 0.95, cex = 1,
                       cex.lab = 1.2, x.stat = 0.6, y.stat = 0.1, col.stat = "black", cex.stat = 0.8, lwd = 2, col = "red",
                       xlim, ylim, xlab, ylab, out = NA, ...) {
  if (missing(formula)) stop("Please supply a formula of the form y ~ x")
  if (!missing(include)) x <- subset(x, as.character(x$id) %in% as.character(include))
  if (!missing(exclude)) x <- subset(x, !sub("[[:space:]]+", "", as.character(x$id)) %in% as.character(exclude))

  # choose output
  if (inherits(out, "list")) {
    if (out$type == "eps") {
      setEPS()
      out$type <- "postscript"
    }
    if (length(out) > 1) {
      do.call(out$type, args = out[-1])
    } else {
      do.call(out$type, list())
    }
  }

  vars <- names(get_all_vars(formula = formula, data = x))
  if ("time" %in% vars) {
    timearg <- T
  } else {
    timearg <- F
  }
  choice <- function(x, icen) {
    switch(icen,
      mean = mean(x),
      median = median(x),
      mode = as.numeric(names(sort(-table(x)))[1]),
      median(x)
    )
  }
  # use summary of covariate or not
  if ("icen" %in% names(x)) {
    data <- x[x$icen == icen, ]
    data <- subset(data, select = -icen)
  } else {
    data <- x
    cat("\nPlease use makeCov and PMsave to update your PMcov object.\n")
    flush.console()
  }

  temp3 <- NA
  if (icen != "none" & !timearg) { # if time is not part of the formula, or no summary
    id <- unique(data$id)
    for (i in id) {
      temp <- data[data$id == i, -1]
      if (nrow(temp) > 1) {
        temp2 <- apply(temp, 2, choice, icen = icen)
      } else {
        temp2 <- temp
      }
      temp3 <- rbind(temp3, temp2)
    }
    temp3 <- temp3[-1, ]

    if (is.null(nrow(temp3))) {
      data <- data.frame(id = as.character(id), t(temp3), row.names = 1)
    } else {
      data <- data.frame(id = as.character(id), temp3, row.names = 1:nrow(temp3))
    }
  }

  data2 <- model.frame(formula = formula, data = data)
  x <- data2[, 2]
  y <- data2[, 1]
  id <- data$id


  if (!is.factor(x)) {
    x <- mult * x
  }
  if (!is.factor(y)) {
    y <- mult * y
  }

  if (missing(xlab)) xlab <- as.character(attr(terms(formula), "variables")[3])
  if (missing(ylab)) ylab <- as.character(attr(terms(formula), "variables")[2])

  if (log) {
    if (is.factor(y) & is.factor(x) & length(x) > 2) {
      op.r <- glm(y ~ x, family = "binomial")
      logplot <- ""
      xaxt <- "s"
      yaxt <- "s"
    }
    if (is.factor(y) & !is.factor(x) & length(x) > 2) {
      op.r <- glm(y ~ log10(x), family = "binomial")
      logplot <- "x"
      xaxt <- "n"
      yaxt <- "s"
    }
    if (!is.factor(y) & is.factor(x) & length(x) > 2) {
      op.r <- lm(log10(y) ~ x)
      logplot <- "y"
      xaxt <- "s"
      yaxt <- "n"
    }
    if (!is.factor(y) & !is.factor(x) & length(x) > 2) {
      op.r <- lm(log10(y) ~ log10(x))
      logplot <- "xy"
      xaxt <- "n"
      yaxt <- "n"
    }
  } else {
    if (is.factor(y) & length(x) > 2) {
      op.r <- glm(y ~ x, family = "binomial")
    }
    if (!is.factor(y) & length(x) > 2) {
      op.r <- lm(y ~ x)
    }
    logplot <- ""
    xaxt <- "s"
    yaxt <- "s"
  }
  if (!is.factor(y) & !is.factor(x) & length(x) > 2) {
    text <- paste("R-squared = ", round(summary(op.r)$r.squared, 2),
      "\nInter = ", round(coef(op.r)[1], 2), " (", ci * 100, "%CI ", round(confint(op.r, level = ci)[1, 1], 2), " to ", round(confint(op.r, level = ci)[1, 2], 2), ")",
      "\nSlope = ", round(coef(op.r)[2], 2), " (", ci * 100, "%CI ", round(confint(op.r, level = ci)[2, 1], 2), " to ", round(confint(op.r, level = ci)[2, 2], 2), ")",
      sep = ""
    )
  }
  if (!is.factor(y) & is.factor(x) & length(x) > 2) {
    text <- paste(xlab, " mean effect: ", round(coef(op.r)[2], 2), " (", ci * 100, "%CI ", round(confint(op.r, level = ci)[2, 1], 2), " to ", round(confint(op.r, level = ci)[2, 2], 2), ")", sep = "")
  }
  if (missing(xlim)) {
    if (!is.factor(x)) {
      xlim <- base::range(x, na.rm = T)
    } else {
      xlim <- c(0.5, 0.5 + length(levels(x)))
    }
  }
  if (missing(ylim)) {
    ylim <- base::range(y, na.rm = T)
  }
  if (square) {
    xlim <- c(min(xlim, ylim), max(xlim, ylim))
    ylim <- xlim
  }
  if (log) {
    hpos.text <- 10**(log10(xlim[1]) + x.stat * diff(log10(xlim)))
    vpos.text <- 10**(log10(ylim[1]) + y.stat * diff(log10(ylim)))
  } else {
    hpos.text <- xlim[1] + x.stat * diff(xlim)
    vpos.text <- ylim[1] + y.stat * diff(ylim)
  }
  graph_data <- data.frame(
    x = x,
    y = y,
    label = id
  )

  p <- ggplot2::ggplot(data = graph_data, ggplot2::aes(x = x, y = y, label = label)) +
    ggplot2::geom_point() +
    ggplot2::ggtitle(formula) +
    ggplot2::xlab(xlab) +
    ggplot2::ylab(ylab)

  if (log) {
    xtran <- "identity"
    ytran <- "identity"
    if (grepl("xy", logplot, fixed = T)) {
      xtran <- "log10"
      ytran <- "log10"
    } else if (grepl("x", logplot, fixed = T)) {
      xtran <- "log10"
    } else if (grepl("y", logplot, fixed = T)) {
      ytran <- "log10"
    }
    p <- p + ggplot2::coord_trans(x = xtran, y = ytran)
  }

  # plot(y~x,type="n",xlab=xlab,ylab=ylab,cex.lab=cex.lab,log=logplot,xlim=xlim,ylim=ylim,xaxt=xaxt,yaxt=yaxt,...)
  if (missing(grid)) {
    #     grid <- list(x=NA,y=NA)
    p <- p + ggplot2::theme(panel.grid = ggplot2::element_blank())
    #   } else {
    #     if(inherits(grid,"logical")){
    #       if(grid){
    #         grid <- list(x=axTicks(1),y=axTicks(2))
    #       } else {
    #         grid <- list(x=NA,y=NA)
    #       }
    #     }
    #     if(inherits(grid,"list")){
    #       if(is.null(grid$x)) grid$x <- axTicks(1)
    #       if(is.null(grid$y)) grid$y <- axTicks(2)
    #     }
  }

  #   if(xaxt=="n") logAxis(1,grid=!all(is.na(grid$x)))
  #   if(yaxt=="n") logAxis(2,grid=!all(is.na(grid$y)))
  #   # abline(v=grid$x,lty=1,col="lightgray")
  #   # abline(h=grid$y,lty=1,col="lightgray")
  if (ident) p <- p + ggplot2::geom_text()
  #   if(!ident){
  #     points(x=x,y=y,col=col,cex=cex,...)
  #   } else {
  #     if(length(grep("SIM",id))>0) id <- as.numeric(gsub("[[:alpha:]]","",id))
  #     text(x=x,y=y,labels=id,col=col,cex=cex,...)}
  #   if(timearg){  #there's a time argument, so aggregate by subject vs. time
  #     nsub <- length(unique(data$id))
  #     for(i in 1:nsub){
  #       lines(x=x[which(id==unique(id)[i])],y=y[which(id==unique(id)[i])],col=col,...)
  #     }
  #   }
  #   if(ref & !timearg) abline(a=0,b=1,lty="dashed")
  if (lowess & !timearg) {
    # lines(lowess(x=x,y=y),lty="dotted",lwd=lwd)
    p <- p + ggplot2::geom_smooth()
  }

  if (reg & !timearg & length(x) > 2) {
    # if(!is.factor(y) & !is.factor(x)){abline(op.r,col=col.stat,lwd=lwd)}
    # text(x=hpos.text,y=vpos.text,text,pos=4,col=col.stat,cex=cex.stat)
    p <- p + ggplot2::geom_smooth(method = "lm") + ggplot2::annotate("text", label = text, x = hpos.text, y = vpos.text)
  }

  #   #close device if necessary
  #   if(inherits(out,"list")) dev.off()

  #   return(invisible(1))
  p
}
