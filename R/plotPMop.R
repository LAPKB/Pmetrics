#' @export
tidy <- function(x,icen = "median", pred.type = "post", outeq = 1, block = 1,include, exclude,mult = 1){
  if(inherits(x, "PM_op")) {x <- x$data}
  struct <- x %>%
    dplyr::filter(icen==!!icen, outeq==!!outeq, pred.type==!!pred.type, block==!!block) %>%
    includeExclude(include,exclude) %>%
    dplyr::filter(!is.na(obs)) %>%
    mutate(pred = pred * mult, obs = obs * mult) %>%
    arrange(time)

  class(struct) <- append("tidy_op",class(struct))
  return(struct)
}

#' @export
plot.tidy_op <- function(x,...){
  plot.PM_op(x,...)
}

#' Plot PM_op objects
#'
#' Plot Pmetrics Observed vs. Predicted Objects
#' 
#' Generates a plot of Observed vs. Predicted observations. The default 
#' is to generate an observed vs. predicted plot of predictions based on the 
#' median of the Bayesian posterior distributions for each subject. 
#' @method plot PM_op
#' @param x The name of an [PM_op] data object generated by [makeOP] 
#' and loaded with [PM_load] as a [PM_result], e.g. `PM_result$op`.
#' @param include `r template("include")`
#' @param exclude `r template("exclude")`
#' @param icen `r template("icen")`
#' @param pred.type Either 'post' for a posterior object or 'pop' for a population object.  Default is 'post'.
#' @param outeq `r template("outeq")` 
#' @param block `r template("block")` 
#' @param marker `r template("marker")` Default is
#' `marker = list(color = orange, shape = "circle", size = 10, opacity = 0.5, line = list(color = black, width = 1))`.
#' @param line Controls characteristics of lines. Unlike
#' some other Pmetrics plots, for plot.PM_op, `line` is a list of
#' three elements:
#' * `lm`  If set to `TRUE` or a list of plotly line attributes,
#' will generate a linear regression of the form obs ~ pred.
#' Line attributes will control the appearance of the regression
#' line and the confidence interval around the line. If set to 
#' `FALSE`, no linear regression will be generated. The default
#' values for the elements of the `lm` list, all of which can be 
#' overriden are:
#'     - `ci` Confidence interval around the regression, default 0.95.
#'     - `color` Color of the regression line and the confidence area around
#' the line, but at opacity = 0.2. Default is "dodgerblue".
#'     - `width `Width of the regression line, default 1.
#'     - `dash` See `plotly::schema()`, traces > scatter > attributes > 
#' line > dash > values. Default is "solid".
#' Example: `line = list(lm = list(color = "red", dash = "longdash", width = 2))`
#' * `loess` If set to `TRUE` or a list of plotly line attributes,
#' will generate a loess regression of the form obs ~ pred.
#' The list elements and default values in the `loess` list are the
#' same as for `lm` except the default style is "dash".
#' Example: `line = list(lm = F, loess = T)`
#' * `ref` If set to `TRUE` or a list of plotly line attributes,
#' will generate a reference line with slope = 1 and intercept = 0.
#' The default values for the elements of the `ref` list are:
#'     - `color` "grey".
#'     - `width` 1.
#'     - `dash` "dot".
#' Note that there is no *ci* argument for the *ref* list.
#' Example: `line = list(lm = F, loess = T, ref = list(color = "lightgrey"))`
#' If the `line` argument is missing, it will be set to
#' `line = list(lm = F, loess = T, ref = T)`, i.e. there will be a loess
#' regression with reference line, but no linear regression.
#' @param mult `r template("mult")` 
#' @param resid Boolean operator to generate a plot of weighted prediction error vs. time,
#' a plot of weighted prediction error vs. prediction. Prediction error is
#' pred - obs. By default a loess regression will indicate deviation from
#' zero prediction error.
#' @param log `r template("log")` 
#' @param grid `r template("grid")` 
#' @param xlim `r template("xlim")` 
#' @param ylim `r template("ylim")` 
#' @param xlab `r template("xlab")`   If missing, will default to "Predicted" for 
#' plots when `resid = F` and either "Time" or "Predicted" for residual plots.
#' @param ylab `r template("ylab")`   If missing, will default to "Observed" for
#' plots when `resid = F` and either "Individual weighted residuals" or 
#' "Population weighted residuals" for residual plots, depending on the value of
#' `pred.type`.
#' @param title `r template("title")` Default is to have no title.
#' @param \dots `r template("dotsPlotly")`
#' @return Plots the object.
#' @author Michael Neely
#' @seealso [PM_result], [schema]
#' @export
#' @examples
#' NPex$op$plot()
#' NPex$op$plot(pred.type = "pop")
#' NPex$op$plot(line = list(lm = T, ref = T, loess = F))
#' NPex$op$plot(line = list(loess = list(ci = 0.9, color = "green")))
#' NPex$op$plot(marker = list(color = "blue"))
#' NPex$op$plot(resid = T)
#' @family PMplots
plot.PM_op <- function(x,  
                       line,
                       marker = T,
                       resid = F,                      
                       icen = "median", pred.type = "post", outeq = 1, block = 1,include, exclude,mult = 1,
                       legend,
                       log = F, 
                       grid = T,
                       xlab, ylab,
                       title,
                       xlim, ylim,...){
  

  
  if(!inherits(x, "tidy")) {sub1 <- tidy(x,icen, pred.type, outeq, block,include, exclude,mult)}
  #unnecessary arguments for consistency with other plot functions
  if(!missing(legend)){notNeeded("legend", "plot.PM_op")}
  
  #process reference lines
  if(missing(line)){
    line <- list(lm = F, loess = T, ref = T)
  } else {
    if(any(!names(line)%in% c("lm", "loess", "pred"))){
      cat(paste0(crayon::red("Warning: "),crayon::blue("line")," should be a list with at most three named elements: ",crayon::blue("lm"),", ",crayon::blue("loess"), " and/or ",crayon::blue("ref"),".\n See help(\"plot.PM_op\")."))
    }
    if(is.null(line$lm)) {line$lm <- F}
    if(is.null(line$loess)) {line$loess <- T}
    if(is.null(line$ref)) {line$ref <- T}
  }
  
  marker <- amendMarker(marker, default = list(color = "orange"))
  lmLine <- amendLine(line$lm, default = list(color = "dodgerblue", dash = "solid"))
  loessLine <- amendLine(line$loess, default = list(color = "dodgerblue", dash = "dash"))
  refLine <- amendLine(line$ref, default = list(color = "grey", dash = "dot"))
  
  if(is.logical(line$lm)){
    lmLine$plot <- line$lm
  } else {
    lmLine$plot <- T
  }
  
  if(is.logical(line$loess)){
    loessLine$plot <- line$loess
  } else {
    loessLine$plot <- T
  }
  
  if(is.logical(line$ref)){
    refLine$plot <- line$ref
  } else {
    refLine$plot <- T
  }
  
  #include/exclude
  if(missing(include)) include <- unique(x$id)
  if(missing(exclude)) exclude <- NA
  
  #process dots
  layout <- amendDots(list(...))
  
  #legend - not needed for this function
  layout <- modifyList(layout, list(showlegend = F))
  
  #grid
  layout$xaxis <- setGrid(layout$xaxis, grid)
  layout$yaxis <- setGrid(layout$yaxis, grid)
  
  #axis ranges
  if(!missing(xlim)){layout$xaxis <- modifyList(layout$xaxis, list(range = xlim)) }
  if(!missing(ylim)){layout$yaxis <- modifyList(layout$yaxis, list(range = ylim)) }
  
  #title
  if(missing(title)){ title <- ""}
  layout$title <- amendTitle(title, default = list(size = 20))
  
  
  # PLOTS -------------------------------------------------------------------
  
  
  
  if(!resid){
    
    #axis labels
    xlab <- if(missing(xlab)){"Predicted"} else {xlab}
    ylab <- if(missing(ylab)){"Observed"} else {ylab}

    layout$xaxis$title <- amendTitle(xlab)
    if(is.character(ylab)){
      layout$yaxis$title <- amendTitle(ylab, layout$xaxis$title$font)
    } else {
      layout$yaxis$title <- amendTitle(ylab)
    }
    
    #log axes
    if(log){
      layout$xaxis <- modifyList(layout$xaxis, list(type = "log"))
      layout$yaxis <- modifyList(layout$yaxis, list(type = "log"))
    }
    
    #make square
    #define anchor axis as the one with largest
    if(max(x$obs, na.rm = T) > max(x$pred, na.rm = T)){ #anchor is y axis
      layout$xaxis <- modifyList(layout$xaxis, list(matches = "y"))
    } else { #anchor is x axis
      layout$yaxis <- modifyList(layout$yaxis, list(matches = "x"))
    }
    
     
    p <- sub1 %>%
      plotly::plot_ly(x = ~pred) %>%
      plotly::add_markers(y = ~obs, 
                          marker = marker,
                          text = ~id,
                          hovertemplate = "Pred: %{x:.2f}<br>Obs: %{y:.2f}<br>ID: %{text}<extra></extra>")
    
    if(lmLine$plot){
      
      lmLine$plot <- NULL
      if(is.null(purrr::pluck(lmLine$ci))){
        ci <- 0.95
      } else {
        ci <- lmLine$ci
        lmLine$ci <- NULL
      }
      lm1 <- lm(obs~pred, sub1)
      inter <- format(coef(lm1)[1],digits=3)
      slope <- format(coef(lm1)[2],digits=3)
      if(is.na(summary(lm1)$coefficients[1,2])) {ci.inter <- rep("NA",2)} else {ci.inter <- c(format(confint(lm1,level=ci)[1,1],digits=3),format(confint(lm1,level=ci)[1,2],digits=3)) }
      if(is.na(summary(lm1)$coefficients[2,2])) {ci.slope <- rep("NA",2)} else {ci.slope <- c(format(confint(lm1,level=ci)[2,1],digits=3),format(confint(lm1,level=ci)[2,2],digits=3)) }
      
      zVal <- qnorm(1 - (1 - ci)/2)
      seFit <- predict(lm1, newdata = sub1, se.fit = T)
      upper <- seFit$fit + zVal * seFit$se.fit
      lower <- seFit$fit - zVal * seFit$se.fit
      
      p <- p %>% 
        plotly::add_lines(y = fitted(lm1), 
                          hoverinfo = "text",
                          text = paste0("R-squared = ",format(summary(lm1)$r.squared,digits=3),"<br>",
                                        "Inter = ",inter," (",ci*100,"%CI ",ci.inter[1]," to ",ci.inter[2],")","<br>",
                                        "Slope = ",slope," (",ci*100,"%CI ",ci.slope[1]," to ",ci.slope[2],")","<br>"
                                        #"Bias = ",format(summary(data,pred.type=pred.type,icen=icen,outeq=outeq)$pe$mwpe,digits=3),"<br>"
                                        #"Imprecision  = ",format(summary(data,pred.type=pred.type,icen=icen,outeq=outeq)$pe$bamwspe,digits=3)
                          ), 
                          line = lmLine)
      if(ci > 0){
        p <- p %>% 
          plotly::add_ribbons(ymin = ~lower, ymax = ~upper, 
                              fillcolor = lmLine$color,
                              line = list(color = lmLine$color),
                              opacity = 0.2,
                              name = "Linear regression",
                              hovertemplate = paste0("Predicted: %{x:.2f}<br>", 100*ci, 
                                                     "% CI: %{y:.2f}<extra>%{fullData.name}</extra>"))
      }
    } 
    
    if(loessLine$plot){
      
      loessLine$plot <- NULL
      if(is.null(purrr::pluck(loessLine$ci))){
        ci <- 0.95
      } else {
        ci <- loessLine$ci
        loessLine$ci <- NULL
      }
      lo1 <- loess(obs~pred,sub1)
      zVal <- qnorm(1 - (1 - ci)/2)
      seFit <- predict(lo1, newdata = sub1, se = T)
      upper <- seFit$fit + zVal * seFit$se.fit
      lower <- seFit$fit - zVal * seFit$se.fit
      
      p <- p %>% 
        plotly::add_lines(y = fitted(lo1), 
                          hoverinfo = "none", 
                          line = loessLine) 
      if(ci > 0){
        p <- p %>%
          plotly::add_ribbons(ymin = ~lower, ymax = ~upper, 
                              fillcolor = loessLine$color,
                              line = list(color = loessLine$color),
                              opacity = 0.2,
                              name = "Loess regression",
                              hovertemplate = paste0("Predicted: %{x:.2f}<br>", 100*ci, 
                                                     "% CI: %{y:.2f}<extra>%{fullData.name}</extra>"))
        
      }
    } 
    
    if(refLine$plot){
      
      refLine$plot <- NULL
      layout$refLine <- list(type = "line",
                                 x0 = 0,
                                 y0 = 0,
                                 x1 = 1,
                                 y1 = 1,
                                 xref = "paper",
                                 yref = "paper",
                                 line = refLine)
    }
    
    #set layout
    p <- p %>%
      plotly::layout(xaxis = layout$xaxis,
                     yaxis = layout$yaxis,
                     showlegend = layout$showlegend,
                     shapes = layout$refLine,
                     title = layout$title)
    
    print(p)
    return(p)
    
    
    
    
  } else { #residual plot
    
    
    #Y axis and point labels
    if(pred.type == "post"){
      ylab <- "Individual weighted residuals (pred - obs)"
      pointLab <- "IWRES"
    } else {
      ylab <- "Population weighted residuals (pred - obs)"
      pointLab <- "PWRES"
    }
    layout$yaxis$title <- amendTitle(ylab)
    if(is.character(ylab)){
      layout$yaxis$title <- amendTitle(ylab, layout$xaxis$title$font)
    } else {
      layout$yaxis$title <- amendTitle(ylab)
    }
    
    #res vs. time
    p1 <- sub1 %>%
      plotly::plot_ly(x = ~time) %>%
      add_markers(y = ~wd,
                  marker = marker,
                  text = ~id,
                  hovertemplate = paste0("Time: %{x:.2f}<br>",pointLab,": %{y:.2f}<br>ID: %{text}<extra></extra>"))
    
    
    if(lmLine$plot){
      
      lmLine$plot <- NULL
      if(is.null(purrr::pluck(lmLine$ci))){
        ci <- 0.95
      } else {
        ci <- lmLine$ci
        lmLine$ci <- NULL
      }
      lm1 <- lm(wd ~ time, sub1)
      inter <- format(coef(lm1)[1],digits=3)
      slope <- format(coef(lm1)[2],digits=3)
      if(is.na(summary(lm1)$coefficients[1,2])) {ci.inter <- rep("NA",2)} else {ci.inter <- c(format(confint(lm1,level=ci)[1,1],digits=3),format(confint(lm1,level=ci)[1,2],digits=3)) }
      if(is.na(summary(lm1)$coefficients[2,2])) {ci.slope <- rep("NA",2)} else {ci.slope <- c(format(confint(lm1,level=ci)[2,1],digits=3),format(confint(lm1,level=ci)[2,2],digits=3)) }
      
      zVal <- qnorm(1 - (1 - ci)/2)
      seFit <- predict(lm1, newdata = sub1, se.fit = T)
      upper <- seFit$fit + zVal * seFit$se.fit
      lower <- seFit$fit - zVal * seFit$se.fit
      
      p <- p %>% 
        plotly::add_lines(y = fitted(lm1), 
                          hoverinfo = "text",
                          text = paste0("R-squared = ",format(summary(lm1)$r.squared,digits=3),"<br>",
                                        "Inter = ",inter," (",ci*100,"%CI ",ci.inter[1]," to ",ci.inter[2],")","<br>",
                                        "Slope = ",slope," (",ci*100,"%CI ",ci.slope[1]," to ",ci.slope[2],")","<br>"
                                        #"Bias = ",format(summary(data,pred.type=pred.type,icen=icen,outeq=outeq)$pe$mwpe,digits=3),"<br>"
                                        #"Imprecision  = ",format(summary(data,pred.type=pred.type,icen=icen,outeq=outeq)$pe$bamwspe,digits=3)
                          ), 
                          line = lmLine)
      if(ci > 0){
        p <- p %>% 
          plotly::add_ribbons(ymin = ~lower, ymax = ~upper, 
                              fillcolor = lmLine$color,
                              line = list(color = lmLine$color),
                              opacity = 0.2,
                              name = "Linear regression",
                              hovertemplate = paste0("Predicted: %{x:.2f}<br>", 100*ci, 
                                                     "% CI: %{y:.2f}<extra>%{fullData.name}</extra>"))
      }
    } 
    
    if(loessLine$plot){
      if(is.null(purrr::pluck(loessLine$ci))){
        ci <- 0.95
      } else {
        ci <- loessLine$ci
        loessLine$ci <- NULL
      }
      lo1 <- loess(wd ~ time, sub1)
      zVal <- qnorm(1 - (1 - ci)/2)
      seFit <- predict(lo1, newdata = sub1$time, se = T)
      upper <- seFit$fit + zVal * seFit$se.fit
      lower <- seFit$fit - zVal * seFit$se.fit
      
      p1 <- p1 %>% 
        plotly::add_lines(y = fitted(lo1), 
                          hoverinfo = "none",
                          line = within(loessLine, rm(plot)))
      
      if(ci > 0){
        p1 <- p1 %>%
          plotly::add_ribbons(ymin = ~lower, ymax = ~upper, 
                              fillcolor = loessLine$color,
                              line = list(color = loessLine$color),
                              opacity = 0.2,
                              name = "Loess regression",
                              hovertemplate = paste0("Predicted: %{x:.2f}<br>", 100*ci, 
                                                     "% CI: %{y:.2f}<extra>%{fullData.name}</extra>"))
        
      }
    }
    #set layout
    layout$xaxis$title <- amendTitle("Time")
    p1 <- p1 %>%
      plotly::layout(xaxis = layout$xaxis,
                     yaxis = layout$yaxis,
                     showlegend = layout$showlegend)
    
    
    #res vs. pred
    p2 <- sub1 %>%
      plotly::plot_ly(x = ~pred) %>%
      add_markers(y = ~wd,
                  marker = marker,
                  text = ~id,
                  hovertemplate = paste0("Pred: %{x:.2f}<br>",pointLab,": %{y:.2f}<br>ID: %{text}<extra></extra>"))
    if(lmLine$plot){
      lmLine$plot <- NULL
      lm2 <- lm(wd ~ pred, sub1)
      inter <- format(coef(lm2)[1],digits=3)
      slope <- format(coef(lm2)[2],digits=3)
      if(is.na(summary(lm2)$coefficients[1,2])) {ci.inter <- rep("NA",2)} else {ci.inter <- c(format(confint(lm2,level=ci)[1,1],digits=3),format(confint(lm2,level=ci)[1,2],digits=3)) }
      if(is.na(summary(lm2)$coefficients[2,2])) {ci.slope <- rep("NA",2)} else {ci.slope <- c(format(confint(lm2,level=ci)[2,1],digits=3),format(confint(lm2,level=ci)[2,2],digits=3)) }
      
      zVal <- qnorm(1 - (1 - ci)/2)
      seFit <- predict(lm2, newdata = sub1, se.fit = T)
      upper <- seFit$fit + zVal * seFit$se.fit
      lower <- seFit$fit - zVal * seFit$se.fit
      
      p <- p %>% 
        plotly::add_lines(y = fitted(lm2), 
                          hoverinfo = "text",
                          text = paste0("R-squared = ",format(summary(lm2)$r.squared,digits=3),"<br>",
                                        "Inter = ",inter," (",ci*100,"%CI ",ci.inter[1]," to ",ci.inter[2],")","<br>",
                                        "Slope = ",slope," (",ci*100,"%CI ",ci.slope[1]," to ",ci.slope[2],")","<br>"
                                        #"Bias = ",format(summary(data,pred.type=pred.type,icen=icen,outeq=outeq)$pe$mwpe,digits=3),"<br>"
                                        #"Imprecision  = ",format(summary(data,pred.type=pred.type,icen=icen,outeq=outeq)$pe$bamwspe,digits=3)
                          ), 
                          line = lmLine)
      if(ci > 0){
        p <- p %>% 
          plotly::add_ribbons(ymin = ~lower, ymax = ~upper, 
                              fillcolor = lmLine$color,
                              line = list(color = lmLine$color),
                              opacity = 0.2,
                              name = "Linear regression",
                              hovertemplate = paste0("Predicted: %{x:.2f}<br>", 100*ci, 
                                                     "% CI: %{y:.2f}<extra>%{fullData.name}</extra>"))
      }
    } 
    
    if(loessLine$plot){
      loessLine$plot <- NULL
      lo2 <- loess(wd~pred, sub1)
      zVal <- qnorm(1 - (1 - ci)/2)
      seFit <- predict(lo2, newdata = sub1, se = T)
      upper <- seFit$fit + zVal * seFit$se.fit
      lower <- seFit$fit - zVal * seFit$se.fit
      
      p2 <- p2 %>% 
        plotly::add_lines(y = fitted(lo2), 
                          hoverinfo = "none", 
                          line = loessLine) 
      if(ci > 0){
        p2 <- p2 %>%
          plotly::add_ribbons(ymin = ~lower, ymax = ~upper, 
                              fillcolor = loessLine$color,
                              line = list(color = loessLine$color),
                              opacity = 0.2,
                              name = "Loess regression",
                              hovertemplate = paste0("Predicted: %{x:.2f}<br>", 100*ci, 
                                                     "% CI: %{y:.2f}<extra>%{fullData.name}</extra>"))
        
      }
    }
    
    
    #set layout
    layout$xaxis$title <- amendTitle("Predicted")
    p2 <- p2 %>%
      plotly::layout(xaxis = layout$xaxis,
                     yaxis = layout$yaxis,
                     showlegend = layout$showlegend,
                     title = layout$title)
    
    #final residual plot
    p <- subplot(p1, p2, nrows = 1,
                 shareY = T, shareX = F, titleX = T)
    print(p)
    return(p)
    
  } #end resid plot
}



#' Plot PMop objects
#'
#' Plot Legacy Pmetrics Observed vs. Predicted Objects
#' 
#' This function is for legacy Pmetrics objects loaded with [PMload] prior to 
#' Pmetrics version 2.
#' 
#' @method plot PMop
#' @param x The name of an \emph{PMop} data object generated by \code{\link{makeOP}}.
#' @param include A vector of subject IDs to include in the plot, e.g. c(1:3,5,15)
#' @param exclude A vector of subject IDs to exclude in the plot, e.g. c(4,6:14,16:20)
#' @param pred.type Either 'post' for a posterior object or 'pop' for a population object.  Default is 'post'.
#' @param icen Can be either "median" for the predictions based on medians of \code{pred.type} parameter value
#' distributions, or "mean".  Default is "median".
#' @param outeq Output equation number.  Default is 1.
#' @param mult Multiplication factor for x and y axes, e.g. to convert mg/L to ng/mL.  Ignored for residual plots.
#' @param resid Boolean operator to generate a plot of weighted prediction error vs. prediction,
#' a plot of weighted prediction error vs. time, and histogram plot of the weighted prediction errors,
#' with overlying normal distribution of the same mean and variance if \code{ref} is true, and
#' a P-value for the Kolmogorov-Smirnov test for non-normality if \code{reg} is true.  The default is \code{False}.
#' @param log Boolean operator to plot in log-log space.  This parameter is ignored for residual plots.  The default is \code{False}
#' @param square Boolean operator to force a observed vs. predicted plots to be square with equal x and y limits.
#' This parameter is ignored for residual plots.  The default is \code{True}
#' @param ref Boolean operator to draw a reference line of slope 1 in observed vs. predicted plots and
#' slope 0 in residual plots, or a reference normal distribution in residual histogram; the default is \code{True}
#' @param lowess Boolean operator to draw a lowess regression line in observed vs. predicted or
#' residual plots; the default is \code{False}
#' @param reg Boolean operator to draw a linear regression line and print regression statistics on the plot.
#' For weighted residual plots, it will print the mean weighted prediction error with P value for difference from 0,
#' and the standard deviation of the weighted prediction errors, as well as the probability that the distribution of
#' weighted residuals is not different from normal by the Kolmogorov-Smirnov test.  The default is \code{True}.
#' @param grid Either a boolean operator to plot a reference grid, or a list with elements x and y,
#' each of which is a vector specifying the native coordinates to plot grid lines; the default is \code{False}.
#' For example, grid=list(x=seq(0,24,2),y=1:10).  Defaults for missing x or y will be calculated by \code{\link{axTicks}}.
#' For residual plots, list values for \code{grid} will be interpreted as \code{True}, i.e. custom grid lines are not allowed.
#' @param ident Boolean operator to plot points as ID numbers; the default is \code{False}.
#' This option is useful to identify outliers.
#' @param ci The confidence interval for the linear regression parameter estimates; the default is 0.95.
#' @param cex Size of the plot symbols.
#' @param cex.lab Size of the plot labels.
#' @param x.stat Horizontal position to plot the regression or residual statistics;
#' the units are relative to the origin, i.e. extreme left is 0 and extreme right is 1.
#' @param y.stat Vertical position to plot the regression or residual statistics; 
#' the units are relative to the origin, i.e. extreme bottom is 0 and extreme top is 1.
#' @param col.stat Color of the text for the regression or residual statistics.
#' @param cex.stat Size of the text for the regression or residual statistics
#' @param lwd Width of the various regression or reference lines (reference, linear regression, or
#' lowess regression)
#' @param col This parameter will be applied to the plotting symbol and is \dQuote{red} by default.
#' @param xlim Limits of the x-axis as a vector, e.g. \code{c(0,1)}.  It does not need to be specified, but can be.
#' @param ylim Analogous to \code{xlim}
#' @param xlab Label for the x-axis.  If missing, will default to \dQuote{Observed}.
#' @param ylab Label for the y-axis.  If missing, will default to \dQuote{Predicted}.
#' @param out Direct output to a PDF, EPS or image file.  Format is a named list whose first argument, 
#' \code{type} is one of the following character vectors: \dQuote{pdf}, \dQuote{eps} (maps to \code{postscript}),
#' \dQuote{\code{png}}, \dQuote{\code{tiff}}, \dQuote{\code{jpeg}}, or \dQuote{\code{bmp}}.  Other named items in the list
#' are the arguments to each graphic device. PDF and EPS are vector images acceptable to most journals
#' in a very small file size, with scalable (i.e. infinite) resolution.  The others are raster images which may be very
#' large files at publication quality dots per inch (DPI), e.g. 800 or 1200. Default value is \code{NA} which means the 
#' output will go to the current graphic device (usually the monitor). For example, to output an eps file,
#' out=list(\dQuote{eps}) will generate a 7x7 inch (default) graphic.
#' @param \dots Other parameters as found in \code{\link{plot.default}}.
#' @return Plots the object.
#' @author Michael Neely
#' @seealso \code{\link{makeOP}}, \code{\link{plot}}, \code{\link{par}}, \code{\link{axis}}
#' @export

plot.PMop <- function(x,include,exclude,pred.type="post",icen="median",outeq=1,mult=1,resid=F,log=F,square=T,ref=T,lowess=F,reg=T,grid,ident=F,ci=0.95,cex=1,
                      cex.lab=1.2,x.stat=0.4,y.stat=0.1,col.stat="black",cex.stat=1.2,lwd=2,col="red",
                      xlim,ylim,xlab,ylab,out=NA,...){ 
  
  if(inherits(x,"list")){ #we are dealing with the old list object 
    cat("\nPlease use makeOP and PMsave to update your PMop object.\n")
    opindex <- which(names(x)==paste(pred.type,outeq,sep=""))
    if(length(opindex)==0) {stop(paste("$",pred.type,outeq," is not present.\n",sep=""))} else {data <- x[[opindex]]} 
    data$pred.type <- pred.type
    data$icen <- "median"
    icen <- "median"
    listOPflag <- T
  } else { #we are dealing with the new data.frame format
    data <- x
    data <- data[data$outeq==outeq & data$pred.type==pred.type & data$icen==icen,]
    listOPflag <- F}
  
  argList <- list(...)
  if("type" %in% names(argList)){
    cat("The 'type' argument has been updated to 'pred.type'.\nPlease update your script.\n")
    return(invisible())
  }
  
  #choose output
  if(inherits(out,"list")){
    if(out$type=="eps") {setEPS();out$type <- "postscript"}
    if(length(out)>1) {do.call(out$type,args=out[-1])} else {do.call(out$type,list())}
  }
  
  #filter includes and excludes
  if(!missing(include)) data <- subset(data,as.character(data$id) %in% as.character(include))
  if(!missing(exclude)) data <- subset(data,!sub("[[:space:]]+","",as.character(data$id)) %in% as.character(exclude))
  
  #filter missing observations and predictions
  data <- data[!is.na(data$obs) & !is.na(data$pred),]
  #check for no observations
  if(nrow(data)==0){
    plot(x=1:10,y=1:10,xaxt="n",yaxt="n",xlab="Predicted",ylab="Observed",type="n")
    text("No observations",x=5.5,y=5,)
    return(invisible())
  }
  data$obs <- mult*data$obs
  data$pred <- mult*data$pred
  if (log){
    if(any(data$pred<=0) | any(data$obs<=0)){
      cat("Observations/predictions <= 0 omitted from log plot.\n")
      data$obs[data$obs<=0] <- NA
      data$pred[data$pred<=0] <- NA
    }
    op.r<-lm(log10(data$obs)~log10(data$pred))
    logplot <- "xy"
    xaxt <- "n"
    yaxt <- "n"
  } else {
    op.r<-lm(data$obs~data$pred)
    logplot <- ""
    xaxt <- "s"
    yaxt <- "s"
  }
  data <- data[!is.na(data$obs),]
  if(length(grep("SIM",data$id))>0) data$id <- as.numeric(gsub("[[:alpha:]]","",data$id))
  
  if(!resid){
    #this is not a residual plot
    
    if (missing(xlim)){xlim <- base::range(data$pred,na.rm=T)}
    if (missing(ylim)){ylim <- base::range(data$obs,na.rm=T)}
    
    if (missing(xlab)) xlab <- "Predicted"
    if (missing(ylab)) ylab <- "Observed"
    
    if (square){
      xlim <- c(min(xlim,ylim),max(xlim,ylim))
      ylim <- xlim
    }
    
    if (log) {
      hpos.text <- 10**(log10(xlim[1])+x.stat*diff(log10(xlim)))
      vpos.text <- 10**(log10(ylim[1])+y.stat*diff(log10(ylim)))
    } else {
      hpos.text <- xlim[1]+x.stat*diff(xlim)
      vpos.text <- ylim[1]+y.stat*diff(ylim)
    }
    par(mar=c(5,5,4,2)+0.1)    
    plot(y=data$obs,x=data$pred,type="n",xlab=xlab,ylab=ylab,cex=cex,cex.lab=cex.lab,log=logplot,xlim=xlim,ylim=ylim,xaxt=xaxt,yaxt=yaxt,...)
    if(missing(grid)){
      grid <- list(x=NA,y=NA)
    } else {
      if(inherits(grid,"logical")){
        if(grid){
          grid <- list(x=axTicks(1),y=axTicks(2))
        } else {
          grid <- list(x=NA,y=NA)
        }
      }
      if(inherits(grid,"list")){
        if(is.null(grid$x)) grid$x <- axTicks(1)
        if(is.null(grid$y)) grid$y <- axTicks(2)
      }
    }
    if(xaxt=="n") logAxis(1,grid=!all(is.na(grid$x)))
    if(yaxt=="n") logAxis(2,grid=!all(is.na(grid$y)))
    abline(v=grid$x,lty=1,col="lightgray")
    abline(h=grid$y,lty=1,col="lightgray")
    if(!ident) {
      points(y=data$obs,x=data$pred,col=col,cex=cex,...)
    } else {text(y=data$obs,x=data$pred,labels=data$id,col=col,cex=cex,...)}
    if(ref) abline(a=0,b=1,lty="dashed",lwd=lwd)
    if(lowess) lines(lowess(x=data$pred,y=data$obs),lty="dotted",lwd=lwd)
    if(reg){
      if(any(is.na(op.r$coeff))){
        text(x=hpos.text,y=vpos.text,"Linear regression not possible",pos=4,col=col.stat,cex=cex.stat)
      } else {
        abline(op.r,col=col.stat)
        inter <- format(coef(op.r)[1],digits=3)
        slope <- format(coef(op.r)[2],digits=3)
        if(is.na(summary(op.r)$coefficients[1,2])) {ci.inter <- rep("NA",2)} else {ci.inter <- c(format(confint(op.r,level=ci)[1,1],digits=3),format(confint(op.r,level=ci)[1,2],digits=3)) }
        if(is.na(summary(op.r)$coefficients[2,2])) {ci.slope <- rep("NA",2)} else {ci.slope <- c(format(confint(op.r,level=ci)[2,1],digits=3),format(confint(op.r,level=ci)[2,2],digits=3)) }
        text(x=hpos.text,y=vpos.text,paste("R-squared = ",format(summary(op.r)$r.squared,digits=3),
                                           "\nInter = ",inter," (",ci*100,"%CI ",ci.inter[1]," to ",ci.inter[2],")",
                                           "\nSlope = ",slope," (",ci*100,"%CI ",ci.slope[1]," to ",ci.slope[2],")",
                                           "\nBias = ",format(summary(data,pred.type=pred.type,icen=icen,outeq=outeq)$pe$mwpe,digits=3),
                                           "\nImprecision  = ",format(summary(data,pred.type=pred.type,icen=icen,outeq=outeq)$pe$bamwspe,digits=3),
                                           sep=""),
             pos=4,col=col.stat,cex=cex.stat)
      }
    }
    par(mar=c(5,4,4,2)+0.1)
    
  } else {
    
    #this is a residual plot
    par(mfrow=c(1,3))
    if(missing(ylim)){
      ylim <- base::range(pretty(base::range(data$wd,na.rm=T)))
    }
    par(mar=c(5,5,4,2)+0.1)
    plot(wd~pred,data,xlab="Predicted",ylab="Weighted residual error (pred - obs)",type="n",ylim=ylim,...)
    if(missing(grid)){
      grid <- list(x=NA,y=NA)
    } else {
      if(inherits(grid,"logical")){
        if(grid){
          grid <- list(x=axTicks(1),y=axTicks(2))
        } else {
          grid <- list(x=NA,y=NA)
        }
      }
      if(inherits(grid,"list")){
        grid$x <- axTicks(1)
        grid$y <- axTicks(2)
      }
    }
    abline(v=grid$x,lty=1,col="lightgray")
    abline(h=grid$y,lty=1,col="lightgray")
    if(!ident){
      points(x=data$pred,y=data$wd,col=col,cex=cex,...)
    } else {text(x=data$pred,y=data$wd,labels=data$id,col=col,cex=cex,...)}
    if(lowess) lines(lowess(x=data$pred,y=data$wd),lwd=lwd,...)
    if(ref) abline(h=0,lty="dashed",lwd=lwd)
    p.val <- t.test(data$wd)$p.value
    p.txt <- ifelse(p.val<0.001,"<0.001",paste("=",round(p.val,3),sep=""))
    if(reg){text(x=min(data$pred)+x.stat*diff(base::range(data$pred)),y=min(data$wd)+y.stat*diff(base::range(data$wd)),
                 labels=paste("Mean: ",round(mean(data$wd),2)," (P",p.txt,"), SD: ",round(sd(data$wd),2),sep=""),adj=0,cex=cex.stat,col=col.stat)}
    
    
    plot(wd~time,data,xlab="Time",ylab="Weighted residual error",type="n",ylim=ylim,...)
    if(!all(is.na(grid$x))){
      grid$x <- axTicks(1)
      grid$y <- axTicks(2)
    }
    abline(v=grid$x,lty=1,col="lightgray")
    abline(h=grid$y,lty=1,col="lightgray")
    if(!ident){
      points(x=data$time,y=data$wd,col=col,cex=cex,...)
    } else {text(x=data$time,y=data$wd,labels=data$id,col=col,cex=cex,...)}
    if(lowess) lines(lowess(x=data$time,y=data$wd),lwd=lwd,...)
    if(ref) abline(h=0,lty="dashed",lwd=lwd)
    p.val <- t.test(data$wd)$p.value
    p.txt <- ifelse(p.val<0.001,"<0.001",paste("=",round(p.val,3),sep=""))
    if(reg) {text(x=min(data$time)+x.stat*diff(base::range(data$time)),y=min(data$wd)+y.stat*diff(base::range(data$wd)),
                  labels=paste("Mean: ",round(mean(data$wd),2)," (P",p.txt,"), SD: ",round(sd(data$wd),2),sep=""),adj=0,cex=cex.stat,col=col.stat)}
    
    resid.hist <- hist(data$wd,breaks=30,plot=F)
    plot(resid.hist,col="gray",xlab="Weighted residual error",main="",xlim=c(floor(min(c(min(resid.hist$mids),-3))),ceiling(max(c(max(resid.hist$mids),3)))),
         cex.lab=cex.lab)
    if(ref) {
      xref <- min(data$wd,na.rm=T) + c(0:100)/100 * (max(data$wd,na.rm=T) - min(data$wd,na.rm=T))
      yref <- dnorm(xref)
      yref <- yref/max(yref,na.rm=T) * max(resid.hist$counts,na.rm=T)
      lines(xref,yref,col="black",lty=2,lwd=2)
    }
    ks <- ks.test(x=data$wd,y="pnorm",mean(data$wd,na.rm=T),var(data$wd,na.rm=T))
    agostino.test <- function (x, alternative = c("two.sided", "less", "greater")){
      DNAME <- deparse(substitute(x))
      x <- sort(x[complete.cases(x)])
      n <- length(x)
      s <- match.arg(alternative)
      alter <- switch(s, two.sided = 0, less = 1, greater = 2)
      if ((n < 8 || n > 46340)) 
        stop("sample size must be between 8 and 46340")
      s3 <- (sum((x - mean(x))^3)/n)/(sum((x - mean(x))^2)/n)^(3/2)
      y <- s3 * sqrt((n + 1) * (n + 3)/(6 * (n - 2)))
      b2 <- 3 * (n * n + 27 * n - 70) * (n + 1) * (n + 3)/((n - 
                                                              2) * (n + 5) * (n + 7) * (n + 9))
      w <- sqrt(-1 + sqrt(2 * (b2 - 1)))
      d <- 1/sqrt(log10(w))
      a <- sqrt(2/(w * w - 1))
      z <- d * log10(y/a + sqrt((y/a)^2 + 1))
      pval <- pnorm(z, lower.tail = FALSE)
      if (alter == 0) {
        pval <- 2 * pval
        if (pval > 1) 
          pval <- 2 - pval
        alt <- "data have a skewness"
      }
      else if (alter == 1) {
        alt <- "data have positive skewness"
      }
      else {
        pval <- 1 - pval
        alt <- "data have negative skewness"
      }
      RVAL <- list(statistic = c(skew = s3, z = z), p.value = pval, 
                   alternative = alt, method = "D'Agostino skewness test", 
                   data.name = DNAME)
      class(RVAL) <- "htest"
      return(RVAL)
    }
    a <- agostino.test(x=data$wd)
    sw <- shapiro.test(x=data$wd)
    if(reg) text(x=resid.hist$mids[1],y=max(resid.hist$counts),labels=paste("D'Agostino P = ",round(a$p.value,3),"\nShapiro-Wilk P = ",round(sw$p.value,3),"\nKolmogorov-Smirnoff P = ",round(ks$p.value,3),sep=""),adj=0,cex=cex.stat,col=col.stat)       
    #clean up
    par(mfrow=c(1,1))
    par(mar=c(5,4,4,2)+0.1)
    
  }
  
  #close device if necessary
  if(inherits(out,"list")) dev.off()
  
  #end
  return(invisible(1))
  
}




