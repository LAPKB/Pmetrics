#' @title Plot Pmetrics Observed vs. Predicted Objects
#' @description
#' `r lifecycle::badge("stable")`
#'
#' Plot PM_op objects
#' @details
#' Generates a plot of Observed vs. Predicted observations. The default
#' is to generate an observed vs. predicted plot of predictions based on the
#' median of the Bayesian posterior distributions for each subject.
#' @method plot PM_op
#' @param x The name of an [PM_op] data object generated by [makeOP]
#' and loaded with [PM_load] as a [PM_result], e.g. `PM_result$op`.
#' @param include `r template("include")`
#' @param exclude `r template("exclude")`
#' @param icen `r template("icen")`
#' @param pred.type Either 'post' for a posterior object or 'pop' for a population object.  Default is 'post'.
#' @param outeq `r template("outeq")`
#' @param block `r template("block")` Default is missing, which results in all blocks included.
#' @param marker `r template("marker")` Default is
#' `marker = list(color = orange, shape = "circle", size = 10, opacity = 0.5, line = list(color = black, width = 1))`.
#' @param line Controls characteristics of lines. Unlike
#' some other Pmetrics plots, for plot.PM_op, `line` is a list of
#' three elements:
#' * `lm`  If set to `TRUE` or a list of plotly line attributes,
#' will generate a linear regression of the form obs ~ pred.
#' Line attributes will control the appearance of the regression
#' line and the confidence interval around the line. If set to
#' `FALSE`, no linear regression will be generated. The default
#' values for the elements of the `lm` list, all of which can be
#' overriden are:
#'     - `ci` Confidence interval around the regression, default 0.95.
#'     - `color` Color of the regression line and the confidence area around
#' the line, but at opacity = 0.2. Default is "dodgerblue".
#'     - `width `Width of the regression line, default 1.
#'     - `dash` See `plotly::schema()`, traces > scatter > attributes >
#' line > dash > values. Default is "solid".
#' Example: `line = list(lm = list(color = "red", dash = "longdash", width = 2))`
#' * `loess` If set to `TRUE` or a list of plotly line attributes,
#' will generate a loess regression of the form obs ~ pred.
#' The list elements and default values in the `loess` list are the
#' same as for `lm` except the default style is "dash".
#' Example: `line = list(lm = FALSE, loess = TRUE)`
#' * `ref` If set to `TRUE` or a list of plotly line attributes,
#' will generate a reference line with slope = 1 and intercept = 0.
#' The default values for the elements of the `ref` list are:
#'     - `color` "grey".
#'     - `width` 1.
#'     - `dash` "dot".
#' Note that there is no *ci* argument for the *ref* list.
#' Example: `line = list(lm = FALSE, loess = TRUE, ref = list(color = "lightgrey"))`
#' If the `line` argument is missing, it will be set to
#' `line = list(lm = TRUE, loess = FALSE, ref = TRUE)`, i.e. there will be a linear
#' regression with reference line, but no loess regression. However, if `resid = T`,
#' the default will become `line = list(lm = FALSE, loess = TRUE, ref = TRUE)`, i.e.,
#' loess regression with reference line, but no linear regression.
#' @param mult `r template("mult")`
#' @param legend Ignored for this plot.
#' @param resid Boolean operator to generate a plot of weighted prediction error vs. time,
#' a plot of weighted prediction error vs. prediction. Prediction error is
#' pred - obs. By default a loess regression will indicate deviation from
#' zero prediction error.
#' @param log `r template("log")`
#' @param grid `r template("grid")`
#' @param xlim `r template("xlim")`
#' @param ylim `r template("ylim")`
#' @param xlab `r template("xlab")`   If missing, will default to "Predicted" for
#' plots when `resid = F` and either "Time" or "Predicted" for residual plots.
#' @param ylab `r template("ylab")`   If missing, will default to "Observed" for
#' plots when `resid = F` and either "Individual weighted residuals" or
#' "Population weighted residuals" for residual plots, depending on the value of
#' `pred.type`.
#' @param title `r template("title")` Default is to have no title.
#' @param stats Add the statistics from linear regression to the plot. If 
#' `FALSE`, will be suppressed. Default is `TRUE` which results in default format of 
#' `list(x= 0.8, y = 0.1, font = list(color = "black", family = "Arial", size = 14, bold = FALSE))`.
#' The coordinates are relative to the plot with lower left = (0,0), upper right = (1,1). This
#' argument maps to `plotly::add_text()`.
#' @param ... `r template("dotsPlotly")`
#' @return Plots the object.
#' @author Michael Neely
#' @seealso [makeOP], [PM_result], [schema]
#' @export
#' @examples
#' NPex$op$plot()
#' NPex$op$plot(pred.type = "pop")
#' NPex$op$plot(line = list(lm = TRUE, ref = TRUE, loess = FALSE))
#' NPex$op$plot(line = list(loess = list(ci = 0.9, color = "green")))
#' NPex$op$plot(marker = list(color = "blue"))
#' NPex$op$plot(resid = TRUE)
#' NPex$op$plot(stats = list(x = 0.5, y = 0.2, font = list(size = 7, color = "blue")))
#'
#' @family PMplots
plot.PM_op <- function(x,
                       line = list(lm = NULL, loess = NULL, ref = NULL),
                       marker = TRUE,
                       resid = FALSE,
                       icen = "median", pred.type = "post", outeq = 1, block,
                       include, exclude,
                       mult = 1,
                       legend,
                       log = FALSE,
                       grid = TRUE,
                       xlab, ylab,
                       title,
                       stats = TRUE,
                       xlim, ylim, ...) {
  x <- if (inherits(x, "PM_op")) {
    x$data
  } else {
    x
  }
  # include/exclude
  if (missing(include)) include <- unique(x$id)
  if (missing(exclude)) exclude <- NA
  if (missing(block)) {
    block <- unique(x$block)
  }

  sub1 <- x %>%
    dplyr::filter(
      icen == !!icen, outeq == !!outeq, pred.type == !!pred.type,
      block %in% !!block
    ) %>%
    includeExclude(include, exclude) %>%
    dplyr::filter(!is.na(obs)) %>%
    dplyr::mutate(pred = pred * mult, obs = obs * mult) %>%
    dplyr::arrange(id, time)
  
  
  #unnecessary arguments for consistency with other plot functions
  if(!missing(legend)){notNeeded("legend", "plot.PM_op")}
  
  #process reference lines
  if(any(!names(line)%in% c("lm", "loess", "ref"))){ 
    cat(paste0(crayon::red("Warning: "),crayon::blue("line")," should be a list with at most three named elements: ",crayon::blue("lm"),", ",crayon::blue("loess"), " and/or ",crayon::blue("ref"),".\n See help(\"plot.PM_op\")."))
  }
  if (!is.list(line)) {
    cat(paste0(crayon::red("Error: "), crayon::blue("line"), " should be a list(). See help(\"plot.PM_op\")."))
  }

  if (!resid) { # defaults
    if (is.null(line$lm)) {
      line$lm <- T
    }
    if (is.null(line$loess)) {
      line$loess <- F
    }
    if (is.null(line$ref)) {
      line$ref <- T
    }
  } else { # defaults for residual plot
    if (is.null(line$lm)) {
      line$lm <- F
    }
    if (is.null(line$loess)) {
      line$loess <- T
    }
    if (is.null(line$ref)) {
      line$ref <- T
    }
  }
  marker <- amendMarker(marker, default = list(color = "orange"))
  lmLine <- amendLine(line$lm, default = list(color = "dodgerblue", dash = "solid"))
  loessLine <- amendLine(line$loess, default = list(color = "dodgerblue", dash = "dash"))
  refLine <- amendLine(line$ref, default = list(color = "grey", dash = "dot"))

  if (is.logical(line$lm)) {
    lmLine$plot <- line$lm
  } else {
    lmLine$plot <- T
  }

  if (is.logical(line$loess)) {
    loessLine$plot <- line$loess
  } else {
    loessLine$plot <- T
  }

  if (is.logical(line$ref)) {
    refLine$plot <- line$ref
  } else {
    refLine$plot <- T
  }


  # process dots
  layout <- amendDots(list(...))

  # legend - not needed for this function
  layout <- modifyList(layout, list(showlegend = FALSE))

  # grid
  layout$xaxis <- setGrid(layout$xaxis, grid)
  layout$yaxis <- setGrid(layout$yaxis, grid)

  # axis ranges
  if (!missing(xlim)) {
    layout$xaxis <- modifyList(layout$xaxis, list(range = xlim))
  }
  if (!missing(ylim)) {
    layout$yaxis <- modifyList(layout$yaxis, list(range = ylim))
  }

  # title
  if (missing(title)) {
    title <- ""
  }
  layout$title <- amendTitle(title, default = list(size = 20))



  # PLOTS -------------------------------------------------------------------
  if (!resid) { # default plot

    # axis labels
    xlab <- if (missing(xlab)) {
      "Predicted"
    } else {
      xlab
    }
    ylab <- if (missing(ylab)) {
      "Observed"
    } else {
      ylab
    }

    layout$xaxis$title <- amendTitle(xlab)
    if (is.character(ylab)) {
      layout$yaxis$title <- amendTitle(ylab, layout$xaxis$title$font)
    } else {
      layout$yaxis$title <- amendTitle(ylab)
    }

    # log axes
    if (log) {
      layout$xaxis <- modifyList(layout$xaxis, list(type = "log"))
      layout$yaxis <- modifyList(layout$yaxis, list(type = "log"))
    }

    # make square
    # define anchor axis as the one with largest
    if (max(x$obs, na.rm = TRUE) > max(x$pred, na.rm = TRUE)) { # anchor is y axis
      layout$xaxis <- modifyList(layout$xaxis, list(matches = "y"))
    } else { # anchor is x axis
      layout$yaxis <- modifyList(layout$yaxis, list(matches = "x"))
    }


    p <- sub1 %>%
      plotly::plot_ly(x = ~pred) %>%
      plotly::add_markers(
        y = ~obs,
        marker = marker,
        text = ~id,
        hovertemplate = "Pred: %{x:.2f}<br>Obs: %{y:.2f}<br>ID: %{text}<extra></extra>"
      )

    if (lmLine$plot) { # linear regression
      lmLine$plot <- NULL # remove to allow only formatting arguments below
      if (is.null(purrr::pluck(lmLine$ci))) {
        ci <- 0.95
      } else {
        ci <- lmLine$ci
        lmLine$ci <- NULL # remove to allow only formatting arguments below
      }

      p <- p %>% add_smooth(ci = ci, line = lmLine, stats = stats)
    }

    if (loessLine$plot) { # loess regression
      loessLine$plot <- NULL # remove to allow only formatting arguments below
      if (is.null(purrr::pluck(loessLine$ci))) {
        ci <- 0.95
      } else {
        ci <- loessLine$ci
        loessLine$ci <- NULL # remove to allow only formatting arguments below
      }
      p <- p %>% add_smooth(ci = ci, line = loessLine, method = "loess")
    }

    if (refLine$plot) { # reference line
      refLine$plot <- NULL # remove to allow only formatting arguments below
      layout$refLine <- list(
        type = "line",
        x0 = 0,
        y0 = 0,
        x1 = 1,
        y1 = 1,
        xref = "paper",
        yref = "paper",
        line = refLine
      )
    }

    # set layout
    p <- p %>%
      plotly::layout(
        xaxis = layout$xaxis,
        yaxis = layout$yaxis,
        showlegend = layout$showlegend,
        shapes = layout$refLine,
        title = layout$title
      )

    print(p)
    return(p)
  } else { # residual plot
    # Y axis and point labels
    if (pred.type == "post") {
      ylab <- "Individual weighted residuals (pred - obs)"
      pointLab <- "IWRES"
    } else {
      ylab <- "Population weighted residuals (pred - obs)"
      pointLab <- "PWRES"
    }

    layout$yaxis$title <- amendTitle(ylab)
    # amend xaxis title later


    # res vs. time
    p1 <- sub1 %>%
      plotly::plot_ly(x = ~time) %>%
      plotly::add_markers(
        y = ~wd,
        marker = marker,
        text = ~id,
        hovertemplate = paste0("Time: %{x:.2f}<br>", pointLab, ": %{y:.2f}<br>ID: %{text}<extra></extra>")
      )


    # res vs. pred
    p2 <- sub1 %>%
      plotly::plot_ly(x = ~pred) %>%
      plotly::add_markers(
        y = ~wd,
        marker = marker,
        text = ~id,
        hovertemplate = paste0("Pred: %{x:.2f}<br>", pointLab, ": %{y:.2f}<br>ID: %{text}<extra></extra>")
      )

    # add reference lines
    if (lmLine$plot) {
      lmLine$plot <- NULL # remove to allow only formatting arguments below
      if (is.null(purrr::pluck(lmLine$ci))) {
        ci <- 0.95
      } else {
        ci <- lmLine$ci
        lmLine$ci <- NULL # remove to allow only formatting arguments below
      }
      p1 <- p1 %>% add_smooth(ci = ci, line = lmLine, stats = stats)
      p2 <- p2 %>% add_smooth(ci = ci, line = lmLine, stats = stats)
    }

    if (loessLine$plot) {
      loessLine$plot <- NULL # remove to allow only formatting arguments below
      if (is.null(purrr::pluck(loessLine$ci))) {
        ci <- 0.95
      } else {
        ci <- loessLine$ci
        loessLine$ci <- NULL # remove to allow only formatting arguments below
      }
      p1 <- p1 %>% add_smooth(ci = ci, line = loessLine, method = "loess")
      p2 <- p2 %>% add_smooth(ci = ci, line = loessLine, method = "loess")
    }
    # set layout
    layout$xaxis$title <- amendTitle("Time")
    p1 <- p1 %>%
      plotly::layout(
        xaxis = layout$xaxis,
        yaxis = layout$yaxis,
        showlegend = layout$showlegend
      )

    layout$xaxis$title <- amendTitle("Predicted")
    p2 <- p2 %>%
      plotly::layout(
        xaxis = layout$xaxis,
        yaxis = layout$yaxis,
        showlegend = layout$showlegend,
        title = layout$title
      )

    # final residual plot
    p <- subplot(p1, p2,
      nrows = 1,
      shareY = TRUE, shareX = FALSE, titleX = TRUE
    )
    print(p)
    return(p)
  } # end resid plot
}



#' @title Plot Pmetrics Observed vs. Predicted Objects
#' @description
#' `r lifecycle::badge("superseded")`
#'
#' It is largely now a legacy plotting function,
#' replaced by [plot.PM_op].
#'
#' @details
#' This function is for *PMop* objects which can be
#' accessed as the `$data` object within the `$op` field of a [PM_result] object, e.g.
#' `PM_result$op$data`.
#' @method plot PMop
#' @param x The name of an \emph{PMop} data object generated by \code{\link{makeOP}}.
#' @param include A vector of subject IDs to include in the plot, e.g. c(1:3,5,15)
#' @param exclude A vector of subject IDs to exclude in the plot, e.g. c(4,6:14,16:20)
#' @param pred.type Either 'post' for a posterior object or 'pop' for a population object.  Default is 'post'.
#' @param icen Can be either "median" for the predictions based on medians of \code{pred.type} parameter value
#' distributions, or "mean".  Default is "median".
#' @param outeq Output equation number.  Default is 1.
#' @param mult Multiplication factor for x and y axes, e.g. to convert mg/L to ng/mL.  Ignored for residual plots.
#' @param resid Boolean operator to generate a plot of weighted prediction error vs. prediction,
#' a plot of weighted prediction error vs. time, and histogram plot of the weighted prediction errors,
#' with overlying normal distribution of the same mean and variance if \code{ref} is true, and
#' a P-value for the Kolmogorov-Smirnov test for non-normality if \code{reg} is true.  The default is \code{False}.
#' @param log Boolean operator to plot in log-log space.  This parameter is ignored for residual plots.  The default is \code{False}
#' @param square Boolean operator to force a observed vs. predicted plots to be square with equal x and y limits.
#' This parameter is ignored for residual plots.  The default is \code{True}
#' @param ref Boolean operator to draw a reference line of slope 1 in observed vs. predicted plots and
#' slope 0 in residual plots, or a reference normal distribution in residual histogram; the default is \code{True}
#' @param lowess Boolean operator to draw a lowess regression line in observed vs. predicted or
#' residual plots; the default is \code{False}
#' @param reg Boolean operator to draw a linear regression line and print regression statistics on the plot.
#' For weighted residual plots, it will print the mean weighted prediction error with P value for difference from 0,
#' and the standard deviation of the weighted prediction errors, as well as the probability that the distribution of
#' weighted residuals is not different from normal by the Kolmogorov-Smirnov test.  The default is \code{True}.
#' @param grid Either a boolean operator to plot a reference grid, or a list with elements x and y,
#' each of which is a vector specifying the native coordinates to plot grid lines; the default is \code{False}.
#' For example, grid=list(x=seq(0,24,2),y=1:10).  Defaults for missing x or y will be calculated by \code{\link{axTicks}}.
#' For residual plots, list values for \code{grid} will be interpreted as \code{True}, i.e. custom grid lines are not allowed.
#' @param ident Boolean operator to plot points as ID numbers; the default is \code{False}.
#' This option is useful to identify outliers.
#' @param ci The confidence interval for the linear regression parameter estimates; the default is 0.95.
#' @param cex Size of the plot symbols.
#' @param cex.lab Size of the plot labels.
#' @param x.stat Horizontal position to plot the regression or residual statistics;
#' the units are relative to the origin, i.e. extreme left is 0 and extreme right is 1.
#' @param y.stat Vertical position to plot the regression or residual statistics;
#' the units are relative to the origin, i.e. extreme bottom is 0 and extreme top is 1.
#' @param col.stat Color of the text for the regression or residual statistics.
#' @param cex.stat Size of the text for the regression or residual statistics
#' @param lwd Width of the various regression or reference lines (reference, linear regression, or
#' lowess regression)
#' @param col This parameter will be applied to the plotting symbol and is \dQuote{red} by default.
#' @param xlim Limits of the x-axis as a vector, e.g. \code{c(0,1)}.  It does not need to be specified, but can be.
#' @param ylim Analogous to \code{xlim}
#' @param xlab Label for the x-axis.  If missing, will default to \dQuote{Predicted}.
#' @param ylab Label for the y-axis.  If missing, will default to \dQuote{Observed}.
#' @param out Direct output to a PDF, EPS or image file.  Format is a named list whose first argument,
#' \code{type} is one of the following character vectors: \dQuote{pdf}, \dQuote{eps} (maps to \code{postscript}),
#' \dQuote{\code{png}}, \dQuote{\code{tiff}}, \dQuote{\code{jpeg}}, or \dQuote{\code{bmp}}.  Other named items in the list
#' are the arguments to each graphic device. PDF and EPS are vector images acceptable to most journals
#' in a very small file size, with scalable (i.e. infinite) resolution.  The others are raster images which may be very
#' large files at publication quality dots per inch (DPI), e.g. 800 or 1200. Default value is \code{NA} which means the
#' output will go to the current graphic device (usually the monitor). For example, to output an eps file,
#' out=list(\dQuote{eps}) will generate a 7x7 inch (default) graphic.
#' @param \dots Other parameters as found in \code{\link{plot.default}}.
#' @return Plots the object.
#' @author Michael Neely
#' @seealso \code{\link{makeOP}}, \code{\link{plot}}, \code{\link{par}}, \code{\link{axis}}
#' @examples
#' plot(NPex$op$data)
#'
#' @export

plot.PMop <- function(x, include, exclude, pred.type = "post", icen = "median", outeq = 1, mult = 1, resid = FALSE, log = FALSE, square = TRUE, ref = TRUE, lowess = FALSE, reg = TRUE, grid, ident = FALSE, ci = 0.95, cex = 1,
                      cex.lab = 1.2, x.stat = 0.4, y.stat = 0.1, col.stat = "black", cex.stat = 1.2, lwd = 2, col = "red",
                      xlim, ylim, xlab, ylab, out = NA, ...) {
  if (inherits(x, "list")) { # we are dealing with the old list object
    cat("\nPlease use makeOP and PMsave to update your PMop object.\n")
    opindex <- which(names(x) == paste(pred.type, outeq, sep = ""))
    if (length(opindex) == 0) {
      stop(paste("$", pred.type, outeq, " is not present.\n", sep = ""))
    } else {
      data <- x[[opindex]]
    }
    data$pred.type <- pred.type
    data$icen <- "median"
    icen <- "median"
    listOPflag <- T
  } else { # we are dealing with the new data.frame format
    data <- x
    data <- data[data$outeq == outeq & data$pred.type == pred.type & data$icen == icen, ]
    listOPflag <- F
  }

  argList <- list(...)
  if ("type" %in% names(argList)) {
    cat("The 'type' argument has been updated to 'pred.type'.\nPlease update your script.\n")
    return(invisible())
  }

  # choose output
  if (inherits(out, "list")) {
    if (out$type == "eps") {
      setEPS()
      out$type <- "postscript"
    }
    if (length(out) > 1) {
      do.call(out$type, args = out[-1])
    } else {
      do.call(out$type, list())
    }
  }

  # filter includes and excludes
  if (!missing(include)) data <- subset(data, as.character(data$id) %in% as.character(include))
  if (!missing(exclude)) data <- subset(data, !sub("[[:space:]]+", "", as.character(data$id)) %in% as.character(exclude))

  # filter missing observations and predictions
  data <- data[!is.na(data$obs) & !is.na(data$pred), ]
  # check for no observations
  if (nrow(data) == 0) {
    plot(x = 1:10, y = 1:10, xaxt = "n", yaxt = "n", xlab = "Predicted", ylab = "Observed", type = "n")
    text("No observations", x = 5.5, y = 5, )
    return(invisible())
  }
  data$obs <- mult * data$obs
  data$pred <- mult * data$pred
  if (log) {
    if (any(data$pred <= 0) | any(data$obs <= 0)) {
      cat("Observations/predictions <= 0 omitted from log plot.\n")
      data$obs[data$obs <= 0] <- NA
      data$pred[data$pred <= 0] <- NA
    }
    op.r <- lm(log10(data$obs) ~ log10(data$pred))
    logplot <- "xy"
    xaxt <- "n"
    yaxt <- "n"
  } else {
    op.r <- lm(data$obs ~ data$pred)
    logplot <- ""
    xaxt <- "s"
    yaxt <- "s"
  }
  data <- data[!is.na(data$obs), ]
  if (length(grep("SIM", data$id)) > 0) data$id <- as.numeric(gsub("[[:alpha:]]", "", data$id))

  if (!resid) {
    # this is not a residual plot

    if (missing(xlim)) {
      xlim <- base::range(data$pred, na.rm = TRUE)
    }
    if (missing(ylim)) {
      ylim <- base::range(data$obs, na.rm = TRUE)
    }

    if (missing(xlab)) xlab <- "Predicted"
    if (missing(ylab)) ylab <- "Observed"

    if (square) {
      xlim <- c(min(xlim, ylim), max(xlim, ylim))
      ylim <- xlim
    }

    if (log) {
      hpos.text <- 10**(log10(xlim[1]) + x.stat * diff(log10(xlim)))
      vpos.text <- 10**(log10(ylim[1]) + y.stat * diff(log10(ylim)))
    } else {
      hpos.text <- xlim[1] + x.stat * diff(xlim)
      vpos.text <- ylim[1] + y.stat * diff(ylim)
    }
    par(mar = c(5, 5, 4, 2) + 0.1)
    plot(y = data$obs, x = data$pred, type = "n", xlab = xlab, ylab = ylab, cex = cex, cex.lab = cex.lab, log = logplot, xlim = xlim, ylim = ylim, xaxt = xaxt, yaxt = yaxt, ...)
    if (missing(grid)) {
      grid <- list(x = NA, y = NA)
    } else {
      if (inherits(grid, "logical")) {
        if (grid) {
          grid <- list(x = axTicks(1), y = axTicks(2))
        } else {
          grid <- list(x = NA, y = NA)
        }
      }
      if (inherits(grid, "list")) {
        if (is.null(grid$x)) grid$x <- axTicks(1)
        if (is.null(grid$y)) grid$y <- axTicks(2)
      }
    }
    if (xaxt == "n") logAxis(1, grid = !all(is.na(grid$x)))
    if (yaxt == "n") logAxis(2, grid = !all(is.na(grid$y)))
    abline(v = grid$x, lty = 1, col = "lightgray")
    abline(h = grid$y, lty = 1, col = "lightgray")
    if (!ident) {
      points(y = data$obs, x = data$pred, col = col, cex = cex, ...)
    } else {
      text(y = data$obs, x = data$pred, labels = data$id, col = col, cex = cex, ...)
    }
    if (ref) abline(a = 0, b = 1, lty = "dashed", lwd = lwd)
    if (lowess) lines(lowess(x = data$pred, y = data$obs), lty = "dotted", lwd = lwd)
    if (reg) {
      if (any(is.na(op.r$coeff))) {
        text(x = hpos.text, y = vpos.text, "Linear regression not possible", pos = 4, col = col.stat, cex = cex.stat)
      } else {
        abline(op.r, col = col.stat)
        inter <- format(coef(op.r)[1], digits = 3)
        slope <- format(coef(op.r)[2], digits = 3)
        if (is.na(summary(op.r)$coefficients[1, 2])) {
          ci.inter <- rep("NA", 2)
        } else {
          ci.inter <- c(format(confint(op.r, level = ci)[1, 1], digits = 3), format(confint(op.r, level = ci)[1, 2], digits = 3))
        }
        if (is.na(summary(op.r)$coefficients[2, 2])) {
          ci.slope <- rep("NA", 2)
        } else {
          ci.slope <- c(format(confint(op.r, level = ci)[2, 1], digits = 3), format(confint(op.r, level = ci)[2, 2], digits = 3))
        }
        text(
          x = hpos.text, y = vpos.text, paste("R-squared = ", format(summary(op.r)$r.squared, digits = 3),
            "\nInter = ", inter, " (", ci * 100, "%CI ", ci.inter[1], " to ", ci.inter[2], ")",
            "\nSlope = ", slope, " (", ci * 100, "%CI ", ci.slope[1], " to ", ci.slope[2], ")",
            "\nBias = ", format(summary(data, pred.type = pred.type, icen = icen, outeq = outeq)$pe$mwpe, digits = 3),
            "\nImprecision  = ", format(summary(data, pred.type = pred.type, icen = icen, outeq = outeq)$pe$bamwspe, digits = 3),
            sep = ""
          ),
          pos = 4, col = col.stat, cex = cex.stat
        )
      }
    }
    par(mar = c(5, 4, 4, 2) + 0.1)
  } else {
    # this is a residual plot
    par(mfrow = c(1, 3))
    if (missing(ylim)) {
      ylim <- base::range(pretty(base::range(data$wd, na.rm = TRUE)))
    }
    par(mar = c(5, 5, 4, 2) + 0.1)
    plot(wd ~ pred, data, xlab = "Predicted", ylab = "Weighted residual error (pred - obs)", type = "n", ylim = ylim, ...)
    if (missing(grid)) {
      grid <- list(x = NA, y = NA)
    } else {
      if (inherits(grid, "logical")) {
        if (grid) {
          grid <- list(x = axTicks(1), y = axTicks(2))
        } else {
          grid <- list(x = NA, y = NA)
        }
      }
      if (inherits(grid, "list")) {
        grid$x <- axTicks(1)
        grid$y <- axTicks(2)
      }
    }
    abline(v = grid$x, lty = 1, col = "lightgray")
    abline(h = grid$y, lty = 1, col = "lightgray")
    if (!ident) {
      points(x = data$pred, y = data$wd, col = col, cex = cex, ...)
    } else {
      text(x = data$pred, y = data$wd, labels = data$id, col = col, cex = cex, ...)
    }
    if (lowess) lines(lowess(x = data$pred, y = data$wd), lwd = lwd, ...)
    if (ref) abline(h = 0, lty = "dashed", lwd = lwd)
    p.val <- t.test(data$wd)$p.value
    p.txt <- ifelse(p.val < 0.001, "<0.001", paste("=", round(p.val, 3), sep = ""))
    if (reg) {
      text(
        x = min(data$pred) + x.stat * diff(base::range(data$pred)), y = min(data$wd) + y.stat * diff(base::range(data$wd)),
        labels = paste("Mean: ", round(mean(data$wd), 2), " (P", p.txt, "), SD: ", round(sd(data$wd), 2), sep = ""), adj = 0, cex = cex.stat, col = col.stat
      )
    }


    plot(wd ~ time, data, xlab = "Time", ylab = "Weighted residual error", type = "n", ylim = ylim, ...)
    if (!all(is.na(grid$x))) {
      grid$x <- axTicks(1)
      grid$y <- axTicks(2)
    }
    abline(v = grid$x, lty = 1, col = "lightgray")
    abline(h = grid$y, lty = 1, col = "lightgray")
    if (!ident) {
      points(x = data$time, y = data$wd, col = col, cex = cex, ...)
    } else {
      text(x = data$time, y = data$wd, labels = data$id, col = col, cex = cex, ...)
    }
    if (lowess) lines(lowess(x = data$time, y = data$wd), lwd = lwd, ...)
    if (ref) abline(h = 0, lty = "dashed", lwd = lwd)
    p.val <- t.test(data$wd)$p.value
    p.txt <- ifelse(p.val < 0.001, "<0.001", paste("=", round(p.val, 3), sep = ""))
    if (reg) {
      text(
        x = min(data$time) + x.stat * diff(base::range(data$time)), y = min(data$wd) + y.stat * diff(base::range(data$wd)),
        labels = paste("Mean: ", round(mean(data$wd), 2), " (P", p.txt, "), SD: ", round(sd(data$wd), 2), sep = ""), adj = 0, cex = cex.stat, col = col.stat
      )
    }

    resid.hist <- hist(data$wd, breaks = 30, plot = FALSE)
    plot(resid.hist,
      col = "gray", xlab = "Weighted residual error", main = "", xlim = c(floor(min(c(min(resid.hist$mids), -3))), ceiling(max(c(max(resid.hist$mids), 3)))),
      cex.lab = cex.lab
    )
    if (ref) {
      xref <- min(data$wd, na.rm = TRUE) + c(0:100) / 100 * (max(data$wd, na.rm = TRUE) - min(data$wd, na.rm = TRUE))
      yref <- dnorm(xref)
      yref <- yref / max(yref, na.rm = TRUE) * max(resid.hist$counts, na.rm = TRUE)
      lines(xref, yref, col = "black", lty = 2, lwd = 2)
    }
    ks <- ks.test(x = data$wd, y = "pnorm", mean(data$wd, na.rm = TRUE), var(data$wd, na.rm = TRUE))
    agostino.test <- function(x, alternative = c("two.sided", "less", "greater")) {
      DNAME <- deparse(substitute(x))
      x <- sort(x[complete.cases(x)])
      n <- length(x)
      s <- match.arg(alternative)
      alter <- switch(s,
        two.sided = 0,
        less = 1,
        greater = 2
      )
      if ((n < 8 || n > 46340)) {
        stop("sample size must be between 8 and 46340")
      }
      s3 <- (sum((x - mean(x))^3) / n) / (sum((x - mean(x))^2) / n)^(3 / 2)
      y <- s3 * sqrt((n + 1) * (n + 3) / (6 * (n - 2)))
      b2 <- 3 * (n * n + 27 * n - 70) * (n + 1) * (n + 3) / ((n -
        2) * (n + 5) * (n + 7) * (n + 9))
      w <- sqrt(-1 + sqrt(2 * (b2 - 1)))
      d <- 1 / sqrt(log10(w))
      a <- sqrt(2 / (w * w - 1))
      z <- d * log10(y / a + sqrt((y / a)^2 + 1))
      pval <- pnorm(z, lower.tail = FALSE)
      if (alter == 0) {
        pval <- 2 * pval
        if (pval > 1) {
          pval <- 2 - pval
        }
        alt <- "data have a skewness"
      } else if (alter == 1) {
        alt <- "data have positive skewness"
      } else {
        pval <- 1 - pval
        alt <- "data have negative skewness"
      }
      RVAL <- list(
        statistic = c(skew = s3, z = z), p.value = pval,
        alternative = alt, method = "D'Agostino skewness test",
        data.name = DNAME
      )
      class(RVAL) <- "htest"
      return(RVAL)
    }
    a <- agostino.test(x = data$wd)
    sw <- shapiro.test(x = data$wd)
    if (reg) text(x = resid.hist$mids[1], y = max(resid.hist$counts), labels = paste("D'Agostino P = ", round(a$p.value, 3), "\nShapiro-Wilk P = ", round(sw$p.value, 3), "\nKolmogorov-Smirnoff P = ", round(ks$p.value, 3), sep = ""), adj = 0, cex = cex.stat, col = col.stat)
    # clean up
    par(mfrow = c(1, 1))
    par(mar = c(5, 4, 4, 2) + 0.1)
  }

  # close device if necessary
  if (inherits(out, "list")) dev.off()

  # end
  return(invisible(1))
}
