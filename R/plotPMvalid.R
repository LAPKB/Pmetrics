#' Plot PMvalid objects
#'
#' @title Plot Pmetrics Validation Objects
#' @method plot PMvalid
#' @param x The name of an \emph{PMvalid} data object generated by \code{\link{makeValid}}.
#' @param type Default is \dQuote{vpc} for a visual prective check, but could be \dQuote{pcvpc} for a 
#' prediction-corrected visual predictive check.
#' @param tad Plot using time after dose if \code{TRUE}.  Default is \code{FALSE} which plots using standard
#' relative time.  This will be the only option if \code{tad} was not set to \code{TRUE} when making the 
#' PMvalid object.
#' @param icen Can be either \dQuote{median} for the predictions based on medians of the population parameter value
#' distributions, or \dQuote{mean}.  Default is \dQuote{median}.
#' @param outeq The number of the output equation to simulate/test.  Default is 1.
#' @param lower The lower quantile displayed for the observed and simulated profiles. Default is 0.025.
#' @param upper The upper quantile displayed for the observed and simulated profiles. Default is 0.975.
#' @param log Boolean operator to plot in semilog space.  The default is \code{FALSE}.
#' @param pch.obs Control the plotting character used for observations.  Default is 1, i.e. an open circle.
#' See \code{\link{points}} for other values of \code{pch}.
#' @param col.obs Color for observations.  Default is black.
#' @param cex.obs Size for observatins.  Default is 1.
#' @param theme Default is \dQuote{color}, but could be \dQuote{grey} or \dQuote{gray}.
#' @param col.obs.ci Color of the observation confidence interval (set by \code{lower} and \code{upper}).
#' Default is blue.
#' @param col.obs.med Color of the observation median.
#' Default is red.
#' @param col.sim.ci Color of the simulation confidence interval (set by \code{lower} and \code{upper}).
#' Default is dodgerblue.
#' @param col.sim.med Color of the simulation median.
#' Default is lightpink.
#' @param xlab Label for x axis.  Default is \dQuote{Time}.
#' @param ylab Label for y axis.  Default is \dQuote{Observation}.
#' @param xlim Limits for x axis
#' @param ylim Limits for y axis
#' @param \dots Not currently used
#' @return Plots the object using ggplot2.
#' @author Michael Neely
#' @seealso \code{\link{makeValid}}, \code{\link{plot}}, \code{\link{par}}, \code{\link{points}}
#' @export

plot.PMvalid <- function(x, type = "vpc", tad = F, outeq = 1,
                         log = F,
                         marker = T,
                         upper = T,
                         lower = T,
                         mid = T,
                         grid = T,
                         legend = F,
                         xlim, ylim,
                         xlab = "Time", ylab = "Output", ...
                         
){
  
  #to avoid modifying original object, x
  opDF <- x$opDF
  simdata <- x$simdata$obs
  
  
  if(outeq > max(opDF$outeq)){stop(paste("Your data do not contain",outeq,"output equations.\n"))}
  
  opDF <- opDF[opDF$outeq == outeq,] #filter to outeq
  simdata <- simdata[simdata$outeq == outeq,] #filter to outeq
  
  dots <- list(...)
  
  marker <- amendMarker(marker, default = list(color = "black", symbol = "circle-open", size = 8))
  upper <- amendCI(upper, default = list(value = 0.975))
  mid <- amendCI(mid, default = list(value = 0.5, color = "red", dash = "solid"))
  lower <- amendCI(lower, default = list(value = 0.025))
  
  xaxis <- purrr::pluck(dots, "xaxis") #check for additional changes
  xaxis <- if(is.null(xaxis)) xaxis <- list()
  yaxis <- purrr::pluck(dots, "yaxis")
  yaxis <- if(is.null(yaxis)) yaxis <- list()
  
  if(!is.null(purrr::pluck(dots, "layout"))){stop("Specify individual layout elements, not layout.")}
  layout <- list()
  
  #legend
  legendList <- amendLegend(legend)
  layout <- modifyList(layout, list(showlegend = legendList[[1]]))
  if(!is.null(legendList[[2]])){layout <- modifyList(layout, list(legend = legendList[[2]]))}
  
  #grid
  xaxis <- setGrid(xaxis, grid)
  yaxis <- setGrid(yaxis, grid)
  
  #axis labels
  xaxis <- modifyList(xaxis, list(title = xlab))
  yaxis <- modifyList(yaxis, list(title = ylab))
  
  #axis ranges
  if(!missing(xlim)){xaxis <- modifyList(xaxis, list(range = xlim)) }
  if(!missing(ylim)){yaxis <- modifyList(yaxis, list(range = ylim)) }
  
  #log y axis
  if(log){
    yaxis <- modifyList(yaxis, list(type = "log"))
  }
  
  #finalize layout
  layoutList <- modifyList(layout, list(xaxis = xaxis, yaxis = yaxis))
  
  #select correct time
  if(!tad){
    use.timeBinMedian <- unique(opDF$timeBinMedian)
    use.optimes <- opDF$time
    use.opTimeBinMedian <- opDF$timeBinMedian
    use.opTimeBinNum <- opDF$timeBinNum
    use.simBinNum <- simdata$timeBinNum
  } else {
    if(!all(is.na(opDF$tadBinMedian))){
      cat("Warning: Using time after dose is misleading if not under steady-state conditions.\n")
      use.timeBinMedian <- unique(opDF$tadBinMedian)
      use.optimes <- opDF$tad
      use.opTimeBinMedian <- opDF$tadBinMedian
      use.opTimeBinNum <- opDF$tadBinNum
      use.simBinNum <- simdata$tadBinNum
      if(xaxis$title=="Time") {xaxis$title <- "Time after dose"}
      
    } else {stop("Rerun makePMvalid and set tad argument to TRUE.\n")}
  }
  
  #calculate lower, 50th and upper percentiles for pcYij by time bins
  quant_pcObs <- tapply(opDF$pcObs,use.opTimeBinNum,quantile,probs=c(lower$value,mid$value,upper$value),na.rm=T)
  #calculate lower, 50th and upper percentiles for Yij by time bin
  quant_Obs <- tapply(opDF$obs,use.opTimeBinNum,quantile,probs=c(lower$value,mid$value,upper$value),na.rm=T)
  
  #find lower, median, upper percentiles by sim and bin
  simMed <- tapply(simdata$out,list(simdata$simnum,use.simBinNum),FUN=quantile,na.rm=T, mid$value) #nsim row, timeBinNum col
  simLower <- tapply(simdata$out,list(simdata$simnum,use.simBinNum),FUN=quantile,na.rm=T,lower$value) #nsim row, timeBinNum col
  simUpper <- tapply(simdata$out,list(simdata$simnum,use.simBinNum),FUN=quantile,na.rm=T,upper$value) #nsim row, timeBinNum col
  
  #calculate median and CI for upper, median, and lower for each bin
  
  upperLower <- apply(simUpper,2,quantile,lower$value,na.rm=T)[order(use.timeBinMedian)]
  upperUpper <- apply(simUpper,2,quantile,upper$value,na.rm=T)[order(use.timeBinMedian)]
  medianLower <- apply(simMed,2,quantile,lower$value,na.rm=T)[order(use.timeBinMedian)]
  medianUpper <- apply(simMed,2,quantile,upper$value,na.rm=T)[order(use.timeBinMedian)]
  lowerLower <- apply(simLower,2,quantile,lower$value,na.rm=T)[order(use.timeBinMedian)]
  lowerUpper <- apply(simLower,2,quantile,upper$value,na.rm=T)[order(use.timeBinMedian)]
  
  #calculate time boundaries for each bin
  if(tad){
    minBin <- tapply(opDF$tad,opDF$tadBinNum,min)
    maxBin <- tapply(opDF$tad,opDF$tadBinNum,max)
  } else {
    minBin <- tapply(opDF$time,opDF$timeBinNum,min)
    maxBin <- tapply(opDF$time,opDF$timeBinNum,max)
  }
  timeBinNum <- length(minBin)
  
  polytime <- use.timeBinMedian
  
  upperDF <- data.frame(time=c(polytime,rev(polytime)),value=c(upperUpper,rev(upperLower)))
  medDF <- data.frame(time=c(polytime,rev(polytime)),value=c(medianUpper,rev(medianLower)))
  lowerDF <- data.frame(time=c(polytime,rev(polytime)),value=c(lowerUpper,rev(lowerLower)))
  
  
  #type specific options
  if(type=="vpc"){ plotData <- list(obsQuant=quant_Obs,obs=opDF$obs,binTime=use.timeBinMedian,
                                    obsTime=use.optimes,upperDF=upperDF,lowerDF=lowerDF,
                                    medDF=medDF)
  }
  if(type=="pcvpc"){ plotData <- list(obsQuant=quant_pcObs,obs=opDF$pcObs,binTime=use.timeBinMedian,
                                      obsTime=use.opTimeBinMedian,upperDF=upperDF,lowerDF=lowerDF,
                                      medDF=medDF)
  }
  
  if(type=="vpc" | type=="pcvpc"){
    
    #GENERATE THE PLOT
    p <-  plotly::plot_ly(x = ~plotData$binTime, 
                          y = ~unlist(lapply(plotData$obsQuant,function(x) x[3]))) %>%
      plotly::add_ribbons(ymin = ~upperLower, ymax = ~upperUpper,
                          color = I(upper$color), opacity = upper$opacity,
                          line = list(width = 0),
                          hoverinfo = "none") %>%
      plotly::add_ribbons(ymin = ~lowerLower, ymax = ~lowerUpper,
                          color = I(lower$color), opacity = lower$opacity,
                          line = list(width = 0),
                          hoverinfo = "none") %>%
      plotly::add_ribbons(ymin = ~medianLower, ymax = ~medianUpper,
                          color = I(mid$color), opacity = mid$opacity,
                          line = list(width = 0),
                          hoverinfo = "none") %>%
      plotly::add_lines(line = list(color = upper$color, dash = upper$dash),
                        hovertemplate = "Time: %{x}<br>Out: %{y}<br><extra></extra>") %>%
      plotly::add_lines(y = ~unlist(lapply(plotData$obsQuant,function(x) x[2])),
                        line = list(color = mid$color, dash = mid$dash),
                        hovertemplate = "Time: %{x}<br>Out: %{y}<br><extra></extra>") %>%
      plotly::add_lines(y = ~unlist(lapply(plotData$obsQuant,function(x) x[1])),
                        line = list(color = lower$color, dash = lower$dash),
                        hovertemplate = "Time: %{x}<br>Out: %{y}<br><extra></extra>") %>%
      plotly::add_markers(x = ~plotData$obsTime, y = ~plotData$obs,
                          marker = marker,
                          hovertemplate = "Time: %{x}<br>Out: %{y}<br>ID: %{text}<extra></extra>",
                          text = ~opDF$id) 
    
    p <- p %>% layout(xaxis = layoutList$xaxis,
                      yaxis = layoutList$yaxis,
                      showlegend = layoutList$showlegend,
                      legend = layoutList$legend) 
    
    #SEND TO CONSOLE
    print(p)
  }
  
  if(type=="npde"){
    #cat("NPDE temporarily disabled pending code cleaning.\n")
    if(is.null(x$npde)) stop("No npde object found.  Re-run makeValid.\n")
    if(inherits(x$npde[[outeq]], "NpdeObject")){
      plot(x$npde[[outeq]])
      par(mfrow=c(1,1))
    } else {
      cat(paste0("Unable to calculate NPDE for outeq ",outeq))
    }
    p <- NULL
  }
  return(p)
}
