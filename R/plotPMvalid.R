#' Plot PM_valid objects
#'
#' Plot Pmetrics Validation Objects
#' 
#' Generates a plot of outputs (typically concentrations) on the y axis and time 
#' on the x axis. If `tad` was set to `TRUE`
#' when [make_valid] was called, then time may be either absolute (default) or time
#' after dose, controlled by the `tad` argument to this plot function.
#' The following items are included in the plot:
#' * Observed outputs. These may be either as measured for `type = "vpc"` or 
#' prediction corrected for `type = "pcvpc"`. Format of the observations is
#' controlled by the `marker` argument. The default is 
#' `list(color = "black", symbol = "circle-open", size = 8)`.
#' * Quantiles vs. time for observations. These are plotted by default as dashed
#' blue lines for the 2.5th and 97.5th percentiles and a solid red line for the 
#' median. Formatting and the value for each quantile can be controlled 
#' with the `upper`, `mid`, and `lower` arguments.
#' * 95% CI around the same quantiles of combined simulations from each subject.
#' The values and formatting for these quantile CIs are the same as for the observations, 
#' and also controlled with the `upper`, `mid`, and `lower` arguments.
#' 
#' Good vpc/pcvpc plots are considered to be those where the quantile lines for 
#' the oberservations lie within the 95%CI quantile regions for simulations, 
#' indicated that the model is "centered" on the data and faithfully captures the 
#' variability in the data. For an npde plot, one expects to see approximately 
#' normally distributed normalized prediction errors.
#' @method plot PM_valid
#' @param x The name of an *PM_valid* data object generated by the [make_valid]
#' fundtion, which is usually called by the `$validate` method for [PM_result]
#' objects.
#' @param type Default is "vpc" for a visual predictive check, but could be 
#' "pcvpc" for a prediction-corrected visual predictive check, or
#' "npde" for a normalized prediction distribution error analysis/plot.
#' @param tad `r template("tad")`
#' @param outeq `r template("outeq")`
#' @param log `r template("log")`
#' @param marker `r template("marker")`
#' @param line A list of three elements `$upper`, `$mid`, and `$lower`, 
#' each of which controls characteristics of corresponding quantiles.
#' The arguments to each of these list elements map to several plotly attributes.
#' Each can be a boolean value or a list.
#' `TRUE` will plot default characteristics. `FALSE` will suppress quantile plots.
#' The elements of the list for each argument are as follows:
#' * `value` The quantile value. Default for lower is 0.025, mid is 0.5, 
#' and upper is 0.975.
#' * `color` The color for both the 95%CI region around simulated quantile vs. time,
#' and the color of the line for the observation quantile vs. time.
#' Default for lower and upper is "dodgerblue" and for mid it is "red".
#' * `dash` The style of the obervation quantile line.  
#' See `plotly::schema()`, traces > scatter > attributes > line > dash > values.
#' Default for lower and upper is "dash" and for mid it is "solid".
#' * `width` Default is 1 for lower, mid, and upper.
#' * `opacity` The opacity of the 95%CI region around simulated quantile vs. time.
#' Default is 0.4 for lower, mid and upper, 
#' but can range between 0 (fully transparent) to 1 (fully opaque).
#' Example: `line = list(upper = list(value = 0.9, color = "red", dash = "longdash", opacity = 0.5, width = 2))`
#' @param legend `r template("legend")` Default is `FALSE`
#' @param log `r template("log")` 
#' @param grid `r template("grid")` 
#' @param xlim `r template("xlim")` 
#' @param ylim `r template("ylim")` 
#' @param xlab `r template("xlab")` Default is "Time" or "Time after dose" if `tad = TRUE`.
#' @param ylab `r template("ylab")` Default is "Output".
#' @param title `r template("title")` Default is to have no title.
#' @param \dots `r template("dotsPlotly")`
#' @return Plots and returns the plotly object
#' @author Michael Neely
#' @seealso [makeValid]
#' @importFrom dplyr summarise
#' @importFrom dplyr quo
#' @export
#' @examples 
#' #VPC
#' NPex_val$valid$plot()
#' 
#' #pcVPC
#' NPex_val$valid$plot(type = "pcvpc")
#' 
#' #modify median line and marker
#' NPex_val$valid$plot(
#' line = list(mid = list(color = "orange", dash = "dashdot")),
#' marker = list(color = "blue", size = 12, symbol = "diamond",
#' line = list(color = "navy")))
#' @family PMplots

plot.PM_valid <- function(x, 
                         type = "vpc", 
                         tad = F, 
                         outeq = 1,
                         line = T,
                         marker = T,
                         legend = F, 
                         log = F, 
                         grid = T,
                         xlab, ylab,
                         title,
                         xlim, ylim,...){
  
  #to avoid modifying original object, x
  opDF <- x$opDF
  simdata <- x$simdata$obs
  
  
  if(outeq > max(opDF$outeq)){stop(paste("Your data do not contain",outeq,"output equations.\n"))}
  
  opDF <- opDF %>% filter(outeq == !!outeq) #filter to outeq
  simdata <- simdata %>% filter(outeq == !!outeq)  #filter to outeq
  

  
  #process CI lines
  if(is.logical(line)){
    if(line){
      line <- list(lower = T, mid = T, upper = T)
    } else {
      line <- list(lower = F, mid = F, upper = F)
    }
  } else {
    if(is.null(line$lower)) {line$lower <- T}
    if(is.null(line$mid)) {line$mid <- T}
    if(is.null(line$upper)) {line$upper <- T}
  }
  
  upper <- amendCI(line$upper, default = list(value = 0.975))
  mid <- amendCI(line$mid, default = list(value = 0.5, color = "red", dash = "solid"))
  lower <- amendCI(line$lower, default = list(value = 0.025))

  #process marker
  marker <- amendMarker(marker, default = list(color = "black", symbol = "circle-open", size = 8))

  #process dots
  layout <- amendDots(list(...))
  
  #grid
  layout$xaxis <- setGrid(layout$xaxis, grid)
  layout$yaxis <- setGrid(layout$yaxis, grid)
  
  #axis labels if needed
  if(missing(xlab)){xlab = c("Time", "Time after dose"[1 + as.numeric(tad)])}
  if(missing(ylab)){ylab = "Output"}
  
  layout$xaxis$title <- amendTitle(xlab)
  layout$yaxis$title <- amendTitle(ylab)
  
  #axis ranges
  if(!missing(xlim)){layout$xaxis <- modifyList(layout$xaxis, list(range = xlim)) }
  if(!missing(ylim)){layout$yaxis <- modifyList(layout$yaxis, list(range = ylim)) }
  
  #log y axis
  if(log){
    layout$yaxis <- modifyList(layout$yaxis, list(type = "log"))
  }
  
  #title
  if(missing(title)){ title <- ""}
  layout$title <- amendTitle(title, default = list(size = 20))
  
  #legend
  legendList <- amendLegend(legend)
  layout <- modifyList(layout, list(showlegend = legendList$showlegend))
  if(length(legendList)>1){layout <- modifyList(layout, list(legend = within(legendList,rm(showlegend))))}
  
  #select correct time
  if(!tad){
    use.timeBinMedian <- sort(unique(opDF$timeBinMedian))
    use.optimes <- opDF$time
    use.opTimeBinMedian <- x$timeBinMedian$time
    use.opTimeBinNum <- x$timeBinMedian$bin
    use.simBinNum <- simdata$timeBinNum
  } else {
    if(!all(is.na(opDF$tadBinMedian))){
      cat("Warning: Using time after dose is misleading if not under steady-state conditions.\n")
      use.timeBinMedian <- sort(unique(opDF$tadBinMedian))
      use.optimes <- opDF$tad
      use.opTimeBinMedian <- x$tadBinMedian$time
      use.opTimeBinNum <- x$tadBinMedian$bin
      use.simBinNum <- simdata$tadBinNum
      if(xaxis$title=="Time") {xaxis$title <- "Time after dose"}
      
    } else {stop("Rerun makePMvalid and set tad argument to TRUE.\n")}
  }
  
  #calculate lower, 50th and upper percentiles for pcYij by time bins
  groupVar <- if(tad){quo(tadBinMedian)} else {quo(timeBinMedian)}
  quant_pcObs <- opDF %>%
    group_by(!!groupVar) %>%
    summarise(value = quantile(pcObs, probs = c(lower$value,mid$value,upper$value),na.rm = T),
              q = c(lower$value,mid$value,upper$value), .groups = "keep")
  names(quant_pcObs)[1] <- "time"
  
  #calculate lower, 50th and upper percentiles for Yij by time bin
  quant_Obs <- opDF %>%
    group_by(!!groupVar) %>%
    summarise(value = quantile(obs, probs = c(lower$value,mid$value,upper$value),na.rm = T),
              q = c(lower$value,mid$value,upper$value), .groups = "keep")
  names(quant_Obs)[1] <- "time"
  
  #calculate median and CI for upper, median, and lower for each bin
  simGroupVar <- if(tad){quo(tadBinNum)} else {quo(timeBinNum)}
  simCI <- simdata %>% group_by(simnum, !!simGroupVar) %>% summarise(value = quantile(out, probs = c(lower$value,mid$value,upper$value),na.rm = T),
                                                                     q = c("lower","mid","upper"), .groups = "keep") %>%
    group_by(bin = !!simGroupVar, q) %>% summarise(value = quantile(value, probs = c(lower$value,upper$value),na.rm = T),
                                                   ci = c(lower$value,upper$value), .groups = "keep") %>%
    pivot_wider(names_from = ci, values_from = value, names_prefix = "q")
  
  #combine obs and simCI
  quant_pcObs <- quant_pcObs %>% select(-q) %>% bind_cols(simCI)
  quant_Obs <- quant_Obs %>% select(-q) %>% bind_cols(simCI)
  
  
  
  #type specific options
  if(type=="vpc"){ 
    timeVar <- if(tad){quo(tad)} else {quo(time)}
    plotData <- list(obsQuant = quant_Obs,
                                    obs = opDF %>% 
                                      select(id, time = !!timeVar, obs))
                                   
  }
  if(type=="pcvpc"){ 
    timeVar <- if(tad){quo(tadBinMedian)} else {quo(timeBinMedian)}
    plotData <- list(obsQuant = quant_pcObs,
                                      obs = opDF %>% 
                                        select(id, time = !!timeVar, obs))
  }
  if(type=="vpc" | type=="pcvpc"){
    
    #GENERATE THE PLOT
    p <-  plotData$obsQuant %>% group_by(q) %>%
      plotly::plot_ly(x = ~time, y = ~value, 
                      colors = c(upper$color, mid$color, lower$color), 
                      linetypes = c(upper$dash, mid$dash, lower$dash),
                      color = ~q,
                      linetype = ~q) %>%
      #add simulation quantile CIs
      plotly::add_ribbons(ymin = ~q0.025, ymax = ~q0.975,
                          opacity = upper$opacity,
                          line = list(width = 0),
                          hoverinfo = "none") %>%
      #add observation quantiles
      plotly::add_lines(hovertemplate = "Time: %{x}<br>Out: %{y}<br><extra></extra>") %>%
      #add observations
      plotly::add_markers(data = plotData$obs,
                          x = ~time, y = ~obs, marker = marker, 
                          hovertemplate = "Time: %{x}<br>Out: %{y}<br>ID: %{text}<extra></extra>",
                          text = ~id,
                          inherit = F) %>%
      #add layout
      
      plotly::layout(xaxis = layout$xaxis,
                     yaxis = layout$yaxis,
                     showlegend = layout$showlegend,
                     legend = layout$legend,
                     title = layout$title) 
    
    #SEND TO CONSOLE
    print(p)
  }
  
  if(type=="npde"){
    if(!tad){
      if(is.null(x$npde)) stop("No npde object found.  Re-run makeValid.\n")
      if(inherits(x$npde[[outeq]], "NpdeObject")){
        plot(x$npde[[outeq]])
        par(mfrow=c(1,1))
      } else {
        cat(paste0("Unable to calculate NPDE for outeq ",outeq))
      }
    } else {
      if(is.null(x$npde_tad)) stop("No npde_tad object found.  Re-run makeValid with tad = T.\n")
      if(inherits(x$npde_tad[[outeq]], "NpdeObject")){
        plot(x$npde_tad[[outeq]])
        par(mfrow=c(1,1))
      } else {
        cat(paste0("Unable to calculate NPDE with TAD for outeq ",outeq))
      }
    }
    
    p <- NULL
  }
  return(p)
}


#' Plot PMvalid objects
#'
#' @title Plot Pmetrics Validation Objects
#' @method plot PMvalid
#' @param x The name of an \emph{PMvalid} data object generated by \code{\link{makeValid}}.
#' @param type Default is \dQuote{vpc} for a visual prective check, but could be \dQuote{pcvpc} for a 
#' prediction-corrected visual predictive check.
#' @param tad Plot using time after dose if \code{TRUE}.  Default is \code{FALSE} which plots using standard
#' relative time.  This will be the only option if \code{tad} was not set to \code{TRUE} when making the 
#' PMvalid object.
#' @param icen Can be either \dQuote{median} for the predictions based on medians of the population parameter value
#' distributions, or \dQuote{mean}.  Default is \dQuote{median}.
#' @param outeq The number of the output equation to simulate/test.  Default is 1.
#' @param lower The lower quantile displayed for the observed and simulated profiles. Default is 0.025.
#' @param upper The upper quantile displayed for the observed and simulated profiles. Default is 0.975.
#' @param log Boolean operator to plot in semilog space.  The default is \code{FALSE}.
#' @param pch.obs Control the plotting character used for observations.  Default is 1, i.e. an open circle.
#' See \code{\link{points}} for other values of \code{pch}.
#' @param col.obs Color for observations.  Default is black.
#' @param cex.obs Size for observatins.  Default is 1.
#' @param theme Default is \dQuote{color}, but could be \dQuote{grey} or \dQuote{gray}.
#' @param col.obs.ci Color of the observation confidence interval (set by \code{lower} and \code{upper}).
#' Default is blue.
#' @param col.obs.med Color of the observation median.
#' Default is red.
#' @param col.sim.ci Color of the simulation confidence interval (set by \code{lower} and \code{upper}).
#' Default is dodgerblue.
#' @param col.sim.med Color of the simulation median.
#' Default is lightpink.
#' @param xlab Label for x axis.  Default is \dQuote{Time}.
#' @param ylab Label for y axis.  Default is \dQuote{Observation}.
#' @param xlim Limits for x axis
#' @param ylim Limits for y axis
#' @param \dots Not currently used
#' @return Plots the object using ggplot2.
#' @author Michael Neely
#' @seealso \code{\link{makeValid}}, \code{\link{plot}}, \code{\link{par}}, \code{\link{points}}
#' @export

plot.PMvalid <- function(x,type="vpc",tad=F,icen="median",outeq=1,lower=0.025,upper=0.975,
                         log=F,pch.obs = 1,col.obs="black",cex.obs=1,data_theme="color",plot_theme=theme_grey(),
                         col.obs.ci="blue",col.obs.med="red",col.sim.ci="dodgerblue",col.sim.med="lightpink",
                         axis.x = NULL,
                         axis.y = NULL
                         
){
  
  #parse dots
  #arglist <- list(...)
  #names_theme <- names(formals(ggplot2::theme)) #check for elements of ggplot2::theme
  #argsTheme <- arglist[which(names(arglist) %in% names_theme)]
  
  #checkRequiredPackages("ggplot2")
  if(outeq > max(x$opDF$outeq)){stop(paste("Your data do not contain",outeq,"output equations.\n"))}
  if(icen!="mean" & icen!="median"){stop(paste("Use \"mean\" or \"median\" for icen.\n",sep=""))}
  
  x$opDF <- x$opDF[x$opDF$icen==icen & x$opDF$outeq==outeq,] #filter to icen & outeq
  x$simdata$obs <- x$simdata$obs[x$simdat$obs$outeq==outeq,] #filter to outeq
  
  #select correct time
  if(!tad){
    use.timeBinMedian <- x$timeBinMedian$time
    use.optimes <- x$opDF$time
    use.opTimeBinMedian <- x$opDF$timeBinMedian
    use.opTimeBinNum <- x$opDF$timeBinNum
    use.simBinNum <- x$simdata$obs$timeBinNum
  } else {
    if(!all(is.na(x$tadBinMedian))){
      cat("Warning: Using time after dose is misleading if not under steady-state conditions.\n")
      use.timeBinMedian <- x$tadBinMedian$time
      use.optimes <- x$opDF$tad
      use.opTimeBinMedian <- x$opDF$tadBinMedian
      use.opTimeBinNum <- x$opDF$tadBinNum
      use.simBinNum <- x$simdata$obs$tadBinNum
      if(axis.x$name=="Time") {axis.y$name <- "Time after dose"}
      
    } else {stop("Rerun makePMvalid and set tad argument to TRUE.\n")}
  }
  
  #calculate lower, 50th and upper percentiles for pcYij by time bins
  quant_pcObs <- tapply(x$opDF$pcObs,use.opTimeBinNum ,quantile,probs=c(lower,0.5,upper),na.rm=T)
  #calculate lower, 50th and upper percentiles for Yij by time bin
  quant_Obs <- tapply(x$opDF$obs,use.opTimeBinNum,quantile,probs=c(lower,0.5,upper),na.rm=T)
  
  #find lower, median, upper percentiles by sim and bin
  simMed <- tapply(x$simdata$obs$out,list(x$simdata$obs$simnum,use.simBinNum),FUN=median,na.rm=T) #nsim row, timeBinNum col
  simLower <- tapply(x$simdata$obs$out,list(x$simdata$obs$simnum,use.simBinNum),FUN=quantile,na.rm=T,lower) #nsim row, timeBinNum col
  simUpper <- tapply(x$simdata$obs$out,list(x$simdata$obs$simnum,use.simBinNum),FUN=quantile,na.rm=T,upper) #nsim row, timeBinNum col
  
  #calculate median and CI for upper, median, and lower for each bin
  
  upperLower <- apply(simUpper,2,quantile,lower,na.rm=T)[order(use.timeBinMedian)]
  upperUpper <- apply(simUpper,2,quantile,upper,na.rm=T)[order(use.timeBinMedian)]
  medianLower <- apply(simMed,2,quantile,lower,na.rm=T)[order(use.timeBinMedian)]
  medianUpper <- apply(simMed,2,quantile,upper,na.rm=T)[order(use.timeBinMedian)]
  lowerLower <- apply(simLower,2,quantile,lower,na.rm=T)[order(use.timeBinMedian)]
  lowerUpper <- apply(simLower,2,quantile,upper,na.rm=T)[order(use.timeBinMedian)]
  
  #calculate time boundaries for each bin
  if(tad){
    minBin <- tapply(x$opDF$tad,x$opDF$tadBinNum,min)
    maxBin <- tapply(x$opDF$tad,x$opDF$tadBinNum,max)
  } else {
    minBin <- tapply(x$opDF$time,x$opDF$timeBinNum,min)
    maxBin <- tapply(x$opDF$time,x$opDF$timeBinNum,max)
  }
  timeBinNum <- length(minBin)
  
  #polytime <- c(mitimeBinNum[1],rep(sapply(1:(timeBinNum-1),function(x) mean(c(mitimeBinNum[x+1],maxBin[x]))),each=2),maxBin[timeBinNum])
  polytime <- use.timeBinMedian
  
  # upperDF <- data.frame(time=c(polytime,rev(polytime)),value=c(rep(upperUpper,each=2),rev(rep(upperLower,each=2))))
  # medDF <- data.frame(time=c(polytime,rev(polytime)),value=c(rep(medianUpper,each=2),rev(rep(medianLower,each=2))))
  # lowerDF <- data.frame(time=c(polytime,rev(polytime)),value=c(rep(lowerUpper,each=2),rev(rep(lowerLower,each=2))))
  upperDF <- data.frame(time=c(polytime,rev(polytime)),value=c(upperUpper,rev(upperLower)))
  medDF <- data.frame(time=c(polytime,rev(polytime)),value=c(medianUpper,rev(medianLower)))
  lowerDF <- data.frame(time=c(polytime,rev(polytime)),value=c(lowerUpper,rev(lowerLower)))
  
  
  #type specific options
  if(type=="vpc"){ plotData <- list(obsQuant=quant_Obs,obs=x$opDF$obs,binTime=use.timeBinMedian,
                                    obsTime=use.optimes,upperDF=upperDF,lowerDF=lowerDF,
                                    medDF=medDF)
  }
  if(type=="pcvpc"){ plotData <- list(obsQuant=quant_pcObs,obs=x$opDF$pcObs,binTime=use.timeBinMedian,
                                      obsTime=use.opTimeBinMedian,upperDF=upperDF,lowerDF=lowerDF,
                                      medDF=medDF)
  }
  
  #common options
  if(type=="vpc" | type=="pcvpc"){
    
    #set names if not specified
    if(!"name" %in% names(axis.x)){axis.x$name <- "Time"}
    if(!"name" %in% names(axis.y)){axis.y$name <- "Observation"}
    
    
    #set limits if not specified
    if(!"limits" %in% names(axis.x)){axis.x$limits <- c(range(plotData$obsTime))}
    if(!"limits" %in% names(axis.y)){axis.y$limits <- c(min(plotData$obs,plotData$lower$value),
                                                        max(plotData$obs,plotData$upperDF$value))}
    
    
    #override colors to make greyscale
    if(data_theme=="grey"|data_theme=="gray"){ #set to grayscale
      col.obs <- "black"
      col.obs.ci <- "grey20"
      col.obs.med <- "grey20"
      col.sim.ci <- "grey75"
      col.sim.med <- "grey50"
    }
    #GENERATE THE PLOT
    p <- with(plotData,
              ggplot(mapping=aes(x=binTime,y=unlist(lapply(obsQuant,function(x) x[3])))) +
                geom_line(col=col.obs.ci,lty=2,lwd=1) + 
                geom_polygon(aes(x=time,y=value),data=upperDF,fill=col.sim.ci,alpha=0.25) +
                geom_polygon(aes(x=time,y=value),data=medDF,fill=col.sim.med,alpha=0.25) +
                geom_polygon(aes(x=time,y=value),data=lowerDF,fill=col.sim.ci,alpha=0.25) +
                geom_line(aes(x=binTime,
                              y=unlist(lapply(obsQuant,function(x) x[2]))),col=col.obs.med,lty=1,lwd=1) +
                geom_line(aes(x=binTime,
                              y=unlist(lapply(obsQuant,function(x) x[1]))),col=col.obs.ci,lty=2,lwd=1) + 
                geom_point(aes(x=obsTime,y=obs),col=col.obs,pch=pch.obs,cex=cex.obs) + 
                do.call(scale_x_continuous,axis.x) + 
                do.call(scale_y_continuous,axis.y) +
                do.call(theme,plot_theme)
    )
    #SEND TO CONSOLE
    print(p)
  }
  
  if(type=="npde"){
    #cat("NPDE temporarily disabled pending code cleaning.\n")
    if(is.null(x$npde)) stop("No npde object found.  Re-run makeValid.\n")
    plot(x$npde)
    par(mfrow=c(1,1))
    p <- NULL
  }
  return(p)
}

