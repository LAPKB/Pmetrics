      IMPLICIT REAL*8(A-H,O-Z)
      PARAMETER(MAXDIM=30,MAXNUMEQ=7)
      DIMENSION VALFIX(20),AMEAN(150,30),COF(150),COV(150,30,30),
     1 IRAN(32),ATOL(20),C0(MAXNUMEQ),C1(MAXNUMEQ),C2(MAXNUMEQ),
     2 C3(MAXNUMEQ),CORR(30,30),BOUND(32,2),ILIMIT(32),XVERIFY(900)
      CHARACTER FILNFO*32,PREFIX*3,EXT*3,PAR(30)*11,PARFIX(20)*11,
     1   SAVFIL*32,FILOUT*32,FILEIN*32,PATH*61,TMPFILE*32,
     2   PATHFILE*93,CODE*14,FORFILE*32,OUTNPAG*20,OUTCSVNAME*32,
     3   TEXTFILE*20,ERRFIL*20
      COMMON/TOUSER/NDIM,MF,RTOL,ATOL
      COMMON/NOISE/ C0DT,C1DT,C2DT,C3DT,C0DA,C1DA,C2DA,C3DA,
     1   C0OT,C1OT,C2OT,C3OT
      COMMON/ERROR/ERRFIL
      CHARACTER(LEN=20) :: OSName
      CHARACTER(LEN=5) :: CopyFile
      CHARACTER(LEN=4) :: DeleteFile
      CHARACTER(LEN=6) :: ClearScreen
      CHARACTER(LEN=10) :: ListDir
      ERRFIL = 'ERRORLOG'
       CALL GET_COMMAND_ARGUMENT(1,OSName)
       IF ((INDEX(OSName,"MacOSX",.TRUE.).EQ.1)
     $ .OR.(INDEX(OSName,"Darwin",.TRUE.).EQ.1)
     $ .OR.(INDEX(OSName,"BSD",.TRUE.).EQ.1)) THEN
          PRINT *,"Requested OS is ", OSName
          OSName="UNIX"
          PRINT *,"Setting OS to ", OSName
          PRINT *,""
          CopyFile="cp "
          DeleteFile="rm "
          ClearScreen="clear "
          ListDir="ls -tp "
       ELSE IF ((INDEX(OSName,"DOS",.TRUE.).EQ.1)
     $ .OR.(INDEX(OSName,"WinXP",.TRUE.).EQ.1)
     $ .OR.(INDEX(OSName,"XP",.TRUE.).EQ.1)
     $ .OR.(INDEX(OSName,"WinXP",.TRUE.).EQ.1)
     $ .OR.(INDEX(OSName,"Vista",.TRUE.).EQ.1)
     $ .OR.(INDEX(OSName,"Win7",.TRUE.).EQ.1)) THEN
          PRINT *,"Requested OS is ", OSName
          OSName="DOS"
          PRINT *,"Setting OS to ", OSName
          CopyFile="COPY "
          DeleteFile="DEL "
          ClearScreen="CLS "
          ListDir="DIR /OD "
       ELSE
          PRINT *,"WARNING: Operating system not declared."
          PRINT *,"WARNING: Can not initialize system calls."
          PRINT *,""
          PRINT *,"Possible command line error, try:"
          PRINT *,"C:\> npbig.exe <DOS,Win,XP,Vista,or Win7>"
          PRINT *,"unix$ npbig <MacOSX,Darwin,BSD>"
          PRINT *,""
          PRINT *,"NPAG Exiting with status 2"
          PRINT *,""
          CALL EXIT(2)
       END IF
  138   FORMAT(/' PLEASE ENTER ONE OF THE REQUESTED VALUES: ')
    2 FORMAT(A32)
  222 FORMAT(A3)
 2222 FORMAT(A3)
     	CALL GETPATH(PATH,NOB)
        OUTNPAG(1:20) = '                    '
        TEXTFILE(1:20) = '                    '
  145	WRITE(*,38)
   38   FORMAT(/' ENTER 0 IF INPUT IS TO BE FROM THE KEYBOARD; '/
     1' ENTER 1 IF INPUT IS TO BE FROM A FILE: ')
	READ(*,*,ERR=145) INOPT
	IF(INOPT .NE. 0 .AND. INOPT .NE. 1) THEN
	   WRITE(*,138)
	   GO TO 145
	ENDIF
	IF(INOPT .EQ. 1) THEN
	 WRITE(*,39)
   39 	 FORMAT(/' ENTER THE NAME OF THE INSTRUCTION FILE; '/
     1' ENTER -99 TO SEE ALL OR A PART OF YOUR DIRECTORY: ')
	 READ(*,2) FILNFO
	 IF(FILNFO(1:3) .EQ. '-99') CALL SEEDIR(PATH,NOB,FILNFO,
     1      OSname,ListDir)
	 TMPFILE = ' '
	 TMPFILE = FILNFO
	 CALL FULLNAME(PATH,TMPFILE,PATHFILE)
	 OPEN(23,FILE=PATHFILE,ERR=6330,STATUS='OLD')
	 GO TO 6335
 6330    WRITE(*,5316) PATHFILE
 5316    FORMAT(//' THE FOLLOWING FILE DOES NOT EXIST ... '/
     1' ',A93)
	 GO TO 145
 6335    CONTINUE
	 READ(23,7123) CODE
 7123    FORMAT(A14)
	 ICODE = 0
	 IF(CODE .EQ. 'MONTBIG APR_04') ICODE = 01
	 IF(CODE .EQ. 'MONTBIG MAR_07') ICODE = 02
	 IF(CODE .EQ. 'MONTBIG JUN_08') ICODE = 03
	 IF(CODE .EQ. 'MONTBIG JUL_08') ICODE = 04
	 IF(CODE .EQ. 'MONTBIG AUG_08') ICODE = 05
       IF(CODE .EQ. 'MONTBIG SEP_10') ICODE = 06
       IF(CODE .EQ. 'MONTBIG MAY_11') ICODE = 07
       IF(CODE .EQ. 'MONTBIG JUN_11') ICODE = 08
       IF(CODE .EQ. 'MONTBIG MAR_12') ICODE = 09
	 IF(ICODE .LT. 5) THEN
	  WRITE(*,7124)
 7124   FORMAT(/' THIS FILE IS NOT AN UP-TO-DATE INSTRUCTION FILE'/
     1' FOR THIS PROGRAM. '//
     2' YOU HAVE THE FOLLOWING 2 OPTIONS:'//
     3' YOU MAY USE A SAVED INSTRUCTION FILE FROM A PREVIOUS RUNNING '/
     4' OF THIS PROGRAM. THE 1ST LINE OF THE SAVED FILE MUST HAVE '/
     5' MONTBIG XXX_XX, WHERE XXX_XX IS AUG_08 OR A MORE RECENT DATE.'//
     6' OR YOU MAY SIMPLY ENTER DATA FROM THE KEYBOARD.'/)
	  CALL PAUSE
	  GO TO 145
	 ENDIF
        IF(ICODE .GE. 7) THEN
         READ(23,*)
        ENDIF
	READ(23,2) FORFILE
	WRITE(*,919) FORFILE
  919   FORMAT(/' YOUR MODEL FILE, ',A32,' MUST BE AN EDITED VERSION'/
     1' OF THE TEMPLATE FILE, TSTMULTM.FOR. AND IT MUST ALREADY HAVE'/
     2' BEEN COMPILED AND LINKED WITH THIS PROGRAM. IF THIS IS NOT'/
     3' THE CASE, STOP NOW, AND THEN RERUN THE PROGRAM. '//
     4' NOTE THAT IF YOU USE A MODEL FILE BASED ON A PREVIOUS '/
     5' TEMPLATE FILE, YOUR RESULTS WILL BE UNPREDICTABLE.'///)
	CALL PAUSE
 5010	TMPFILE = ' '
	TMPFILE = FORFILE
	CALL FULLNAME(PATH,TMPFILE,PATHFILE)
        OPEN(28,FILE=PATHFILE,ERR=50,STATUS='OLD',POSITION='APPEND')
	GO TO 30
   50   WRITE(*,4406) FORFILE
 4406    FORMAT(//' THE FOLLOWING FILE DOES NOT EXIST ... '/
     1'    ',A93/
     2' ENTER THE CORRECT FILENAME OR ... '/
     2' ENTER -99 TO SEE ALL OR A PART OF YOUR DIRECTORY: ')
	READ(*,2) FORFILE
	IF(FORFILE(1:3) .EQ. '-99') CALL SEEDIR(PATH,NOB,FORFILE,
     1     OSname,ListDir)
	GO TO 5010
   30	CALL USERPREP(NDIM,NP,NVAR,MAXDIM,PAR,NOFIX,PARFIX,IRAN,INOPT,
     1  ICODE,ILIMIT,BOUND)
	CLOSE(28)
        IF(ICODE .GE. 7) THEN
         IF(ICODE .EQ. 7) THEN
          READ(23,*)
          READ(23,2222) PREFIX
          READ(23,*)
          READ(23,222) EXT
         ENDIF
         READ(23,*)
         READ(23,*) ICSVFILE
         READ(23,*)
         READ(23,2) FILEIN
        IF(ICSVFILE .EQ. 0) THEN
         TMPFILE = ' '
         TMPFILE = FILEIN
         CALL FULLNAME(PATH,TMPFILE,PATHFILE)
         OPEN(67,FILE=PATHFILE,ERR=8440,STATUS='OLD')
         GO TO 8455
 8440    WRITE(*,5316) PATHFILE
        OPEN(42,FILE=ERRFIL)
         WRITE(42,5316) PATHFILE
        CLOSE(42)
         CALL PAUSE
         STOP
 8455    CLOSE(67)
        ENDIF
        IF(ICSVFILE .EQ. 1) THEN
         TMPFILE = ' '
         TMPFILE = FILEIN
         CALL FULLNAME(PATH,TMPFILE,PATHFILE)
         OPEN(87,FILE=PATHFILE,STATUS='OLD')
        CALL CONVERTCSV
         OPEN(67)
         CALL NEWCSV
         CALL CSVCHANGE
         REWIND(66)
         CALL READBLOCK2(PATH,C0,C1,C2,C3)
         CLOSE(66)
         TMPFILE = ' '
         TMPFILE = 'XQZPJ001.ZMQ'
         CALL FULLNAME(PATH,TMPFILE,PATHFILE)
         OPEN(21,FILE=PATHFILE,ERR=8465,STATUS='OLD')
         GO TO 8470
 8465    WRITE(*,5466) PATHFILE,FILEIN
        OPEN(42,FILE=ERRFIL)
         WRITE(42,5466) PATHFILE,FILEIN
        CLOSE(42)
         CALL PAUSE
         STOP
 8470    CONTINUE
         CLOSE(21)
        ENDIF
         READ(23,*)
         READ(23,*) NSUB
         READ(23,*)
         READ(23,*) NOFIX
         READ(23,*)
         IF(NOFIX .GT. 0) READ(23,*) (VALFIX(I),I=1,NOFIX)
	 IF(NOFIX .GT. 20) THEN
	  WRITE(*,3177) NOFIX
 3177     FORMAT(/' NOFIX WAS READ IN FROM THE INSTRUCTION FILE TO '/
     1' BE ', I3,'. THIS IS > 20, THE MAXIMUM ALLOWED VALUE.'//
     2' PLEASE RERUN THE PROGRAM WITH KEYBOARD ENTRY, OR USE AN '/
     3' INSTRUCTION FILE HAVING NOFIX .LE. 20.')
        OPEN(42,FILE=ERRFIL)
         WRITE(42,3177) NOFIX
        CLOSE(42)
	  CALL PAUSE
	  STOP
	 ENDIF
         READ(23,*)
         READ(23,*) TOLER
	   RTOL = TOLER
         DO I=1,NDIM
          ATOL(I) = TOLER
         END DO
         MF = 22
         READ(23,*)
         READ(23,*) NUMEQT
         READ(23,*)
         DO IEQ=1,NUMEQT
          READ(23,*) C0(IEQ),C1(IEQ),C2(IEQ),C3(IEQ)
         END DO
         READ(23,*)
         READ(23,*) C0DT,C1DT,C2DT,C3DT
         READ(23,*)
         READ(23,*) C0DA,C1DA,C2DA,C3DA
         READ(23,*)
         READ(23,*) C0OT,C1OT,C2OT,C3OT
         READ(23,*)
         READ(23,*) IDIST
         READ(23,*)
         READ(23,*) NGAUS
         READ(23,*)
         DO IGAUS=1,NGAUS
          READ(23,*) COF(IGAUS)
          READ(23,*) (AMEAN(IGAUS,I),I=1,NVAR)
           DO I=1,NVAR
            READ(23,*) (COV(IGAUS,I,J),J=1,I)
           END DO
         END DO
         READ(23,*)
         READ(23,2) FILOUT
         READ(23,*)
         READ(23,*) IPRNPAT
         IF(ICODE .EQ. 7) THEN
          IF(IPRNPAT .EQ. 1) IPRNPAT = 2
         ENDIF
         IF(ICODE .GE. 8) THEN
          READ(23,*)
          READ(23,2) OUTCSVNAME
          READ(23,*)
          READ(23,2222) PREFIX
          READ(23,*)
          READ(23,222) EXT
         ENDIF
         READ(23,*)
         READ(23,*) ISEEDIND
         CLOSE(23)
         GO TO 7300
        ENDIF
        READ(23,2222) PREFIX
        READ(23,222) EXT
        IF(ICODE .LT. 6) ICSVFILE = 0
        IF(ICODE .GE. 6) READ(23,*) ICSVFILE
	 READ(23,2) FILEIN
        IF(ICSVFILE .EQ. 0) THEN
         TMPFILE = ' '
         TMPFILE = FILEIN
         CALL FULLNAME(PATH,TMPFILE,PATHFILE)
         OPEN(67,FILE=PATHFILE,ERR=7440,STATUS='OLD')
         GO TO 7455
 7440    WRITE(*,5316) PATHFILE
        OPEN(42,FILE=ERRFIL)
         WRITE(42,5316) PATHFILE
        CLOSE(42)
         CALL PAUSE
         STOP
 7455    CLOSE(67)
        ENDIF
        IF(ICSVFILE .EQ. 1) THEN
         TMPFILE = ' '
         TMPFILE = FILEIN
         CALL FULLNAME(PATH,TMPFILE,PATHFILE)
         OPEN(87,FILE=PATHFILE,STATUS='OLD')
        CALL CONVERTCSV
         OPEN(67)
         CALL NEWCSV
         CALL CSVCHANGE
         REWIND(66)
         CALL READBLOCK2(PATH,C0,C1,C2,C3)
         CLOSE(66)
         TMPFILE = ' '
         TMPFILE = 'XQZPJ001.ZMQ'
         CALL FULLNAME(PATH,TMPFILE,PATHFILE)
         OPEN(21,FILE=PATHFILE,ERR=7465,STATUS='OLD')
         GO TO 7470
 7465    WRITE(*,5466) PATHFILE,FILEIN
        OPEN(42,FILE=ERRFIL)
         WRITE(42,5466) PATHFILE,FILEIN
        CLOSE(42)
         CALL PAUSE
         STOP
 7470    CONTINUE
         CLOSE(21)
        ENDIF
	 READ(23,*) NSUB
	 READ(23,*) NOFIX
	 IF(NOFIX .GT. 0) READ(23,*) (VALFIX(I),I=1,NOFIX)
	 IF(NOFIX .GT. 20) THEN
	  WRITE(*,3177) NOFIX
        OPEN(42,FILE=ERRFIL)
         WRITE(42,3177) NOFIX
        CLOSE(42)
	  CALL PAUSE
	  STOP
	 ENDIF
	 READ(23,*) TOLER
	 RTOL = TOLER
	 DO I=1,NDIM
	  ATOL(I) = TOLER
	 END DO
	 MF = 22
	 READ(23,*) NUMEQT
	 DO IEQ=1,NUMEQT
	  READ(23,*) C0(IEQ),C1(IEQ),C2(IEQ),C3(IEQ)
	 END DO
	 READ(23,*) C0DT,C1DT,C2DT,C3DT
	 READ(23,*) C0DA,C1DA,C2DA,C3DA
	 READ(23,*) C0OT,C1OT,C2OT,C3OT
	 READ(23,*) IDIST
	 READ(23,*) NGAUS
	 DO IGAUS=1,NGAUS
	  READ(23,*) COF(IGAUS)
	  READ(23,*) (AMEAN(IGAUS,I),I=1,NVAR)
	   DO I=1,NVAR
          READ(23,*) (COV(IGAUS,I,J),J=1,I)
	   END DO
	 END DO
	 READ(23,2) FILOUT
	 READ(23,*) IPRNPAT
       IF(IPRNPAT .EQ. 1) IPRNPAT = 2
	 READ(23,*) ISEEDIND
	 CLOSE(23)
	ENDIF
	IF(INOPT .EQ. 0) THEN
        WRITE(*,5001)
 5001   FORMAT(/' ENTER THE NAME OF THE FORTRAN FILE WHICH HAS BEEN'/
     1' LINKED WITH THIS PROGRAM. NOTE THAT IT MUST BE AN EDITED '/
     2' VERSION OF THE TEMPLATE FILE, TSTMULTM.FOR. IF THIS IS NOT'/
     3' THE CASE, STOP NOW, AND THEN RERUN THE PROGRAM. '//
     4' NOTE THAT IF YOU USE A MODEL FILE BASED ON A PREVIOUS '/
     5' TEMPLATE FILE, YOUR RESLTS WILL BE UNPREDICTABLE.'///
     6' ENTER YOUR MODEL FILE NOW IF IT IS AN EDITED VERSION OF '/
     7' TSTMULTM.FOR: ')
     	  READ(*,2) FORFILE
 9010	TMPFILE = ' '
	TMPFILE = FORFILE
	CALL FULLNAME(PATH,TMPFILE,PATHFILE)
        OPEN(28,FILE=PATHFILE,ERR=950,STATUS='OLD',POSITION='APPEND')
	GO TO 930
  950   WRITE(*,4406) FORFILE
	READ(*,2) FORFILE
	IF(FORFILE(1:3) .EQ. '-99') CALL SEEDIR(PATH,NOB,FORFILE,
     1     OSname,ListDir)
	GO TO 9010
  930	CALL USERPREP(NDIM,NP,NVAR,MAXDIM,PAR,NOFIX,PARFIX,IRAN,INOPT,
     1  ICODE,ILIMIT,BOUND)
	CLOSE(28)
 5020   WRITE(*,5002)
 5002   FORMAT(/' THE DOSE/COVARIATE AND OBSERVATION TIME INFORMATION'/
     1' WHICH WILL BE USED TO SIMULATE THE PATIENT DATA FILES CAN BE'/
     2' INPUT VIA A (MULTIPLE DRUG) WORKING COPY PATIENT DATA FILE OR'/
     3' VIA A BLOCK MATRIX .CSV FILE (THE INFO WILL COME FROM THE '/
     4' DATE OF THE FIRST SUBJECT IN THIS CASE).'//
     5' ENTER 1 TO ENTER INFO USING A .CSV FILE; '/
     6' ENTER 0 TO ENTER INFO USING A WORKING COPY PATIENT DATA FILE: ')
        READ(*,*,ERR=5020) ICSVFILE
        IF(ICSVFILE .NE. 1 .AND. ICSVFILE .NE. 0) GO TO 5020
        IF(ICSVFILE .EQ. 0) THEN
        WRITE(*,1021)
 1021   FORMAT(/' ENTER THE NAME OF THE WORKING COPY PATIENT DATA FILE'/
     1' WHICH CONTAINS THE DOSE/COVARIATE INFORMATION WHICH WILL BE'/
     2' USED TO SIMULATE THE PATIENT DATA FILES.'//
     3' BE SURE THAT THIS IS A MULTI-DRUG WORKING COPY DATA FILE.'//
     1' ENTER -99 TO SEE ALL OR A PART OF YOUR DIRECTORY: ')
     	  READ(*,2) FILEIN
        IF(FILEIN(1:3) .EQ. '-99') CALL SEEDIR(PATH,NOB,FILEIN,
     1     OSname,ListDir)
	TMPFILE = ' '
	TMPFILE = FILEIN
	CALL FULLNAME(PATH,TMPFILE,PATHFILE)
	OPEN(21,FILE=PATHFILE,ERR=6440,STATUS='OLD')
	GO TO 6455
 6440   WRITE(*,5316) PATHFILE
	GO TO 5020
 6455   CONTINUE
        ENDIF
        IF(ICSVFILE .EQ. 1) THEN
        WRITE(*,3021)
 3021   FORMAT(/' ENTER THE NAME OF THE BLOCK MATRIX .CSV FILE. ONLY'/
     1' THE DATA FROM THE FIRST SUBJECT IN THIS FILE WILL BE READ TO'/
     2' OBTAIN THE DOSE/COVARIATE INFORMATION WHICH WILL BE USED TO'/
     3' TO SIMULATE THE PATIENT DATA FILES.'//
     1' ENTER -99 TO SEE ALL OR A PART OF YOUR DIRECTORY: ')
     	  READ(*,2) FILEIN
        IF(FILEIN(1:3) .EQ. '-99') CALL SEEDIR(PATH,NOB,FILEIN,
     1     OSname,ListDir)
        TMPFILE = ' '
        TMPFILE = FILEIN
        CALL FULLNAME(PATH,TMPFILE,PATHFILE)
        OPEN(87,FILE=PATHFILE,ERR=5440,STATUS='OLD')
        GO TO 5455
 5440   WRITE(*,5316) PATHFILE
        GO TO 5020
 5455   CONTINUE
        CALL CONVERTCSV
         OPEN(67)
         CALL NEWCSV
         CALL CSVCHANGE
         REWIND(66)
         CALL READBLOCK2(PATH,C0,C1,C2,C3)
         CLOSE(66)
        TMPFILE = ' '
        TMPFILE = 'XQZPJ001.ZMQ'
        CALL FULLNAME(PATH,TMPFILE,PATHFILE)
        OPEN(21,FILE=PATHFILE,ERR=5465,STATUS='OLD')
        GO TO 5470
 5465   WRITE(*,5466) PATHFILE,FILEIN
 5466   FORMAT(//' THE FOLLOWING FILE DOES NOT EXIST ... '/
     1' ',A93/
     2' WHICH MEANS THAT YOUR .CSV FILE, ',A20,' WAS NOT READ '/
     3' PROPERLY. PLEASE CHECK THIS FILE TO MAKE SURE IT IS CORRECT.'//)
        GO TO 5020
 5470   CONTINUE
        ENDIF
	CALL GETNUMEQ(NUMEQT)
	CLOSE(21)
        WRITE(*,21)
   21   FORMAT(/' ENTER THE NO. OF SUBJECTS TO BE SIMULATED. THIS '/
     1' NUMBER MUST BE LESS THAN OR EQUAL TO 10000.'//
     2' NOTE THAT IF YOU SELECT TO HAVE ONE SUBJECT SIMULATED WITH'/
     3' EXACTLY THE PARAMETER VALUES OF EACH GRID PT. FROM THE LAST'/
     4' CYCLE OF AN NPAG RUN, THIS VALUE WILL BE IRRELEVANT: ')
 4070	READ(*,*,ERR=4075) NSUB
        GO TO 4078
 4075	WRITE(*,4076)
 4076	FORMAT(/' SEE ABOVE; ENTER AN INTEGER BETWEEN 1 AND 10000: ')
	GO TO 4070
 4078	IF(NSUB .LE. 0 .OR. NSUB .GT. 10000) GO TO 4075
	IF(NOFIX .GT. 0) THEN
	  WRITE(*,4836) NOFIX
 4836     FORMAT(/' ENTER, THE ',I2,' FIXED PARAMETER VALUES: ')
	  DO 9190 I=1,NOFIX
	  WRITE(*,2112) PARFIX(I)
 2112     FORMAT(/' ',A11,': ')
 7110     READ(*,*,ERR=7115) VALFIX(I)
	  GO TO 9190
 7115     WRITE(*,7116)
 7116     FORMAT(/' SEE ABOVE; ENTER A NON-NEGATIVE NUMBER: ')
	  GO TO 7110
 9190     CONTINUE
	ENDIF
  915   WRITE(*,913)
  913   FORMAT(/' ENTER 1 TO SET ALL TOLERANCES (FOR THE O.D.E. '/
     1'         SOLVER) TO THE DEFAULT VALUE ... 1.D-4.'/
     2' ENTER 0 TO SELECT A DIFFERENT VALUE FOR THE TOLERANCES: ')
	READ(*,*,ERR=915) ITOL
	IF(ITOL .NE. 0 .AND. ITOL .NE. 1) GO TO 915
	TOLER=1.D-4
	IF(ITOL .EQ. 0) THEN
  910	WRITE(*,914)
  914  FORMAT(/' ENTER A POSITIVE VALUE FOR THE TOLERANCE PARAMETERS: ')
	READ(*,*,ERR=910) TOLER
	IF(TOLER .LE. 0.D0) GO TO 910
	ENDIF
	RTOL = TOLER
	DO I=1,NDIM
	 ATOL(I) = TOLER
	END DO
	MF = 22
	WRITE(*,19)
   19 FORMAT(//' FOR EACH OUTPUT EQUATION, ENTER, IN ORDER, '/
     1' C0,C1,C2,C3, WHERE, FOR EACH OBSERVED VALUE, Y, THE ASSAY'/
     3' STANDARD DEVIATION IS SD = C0+C1*Y+C2*Y**2+C3*Y**3):')
	DO IEQ = 1,NUMEQT
	 WRITE(*,1119) IEQ
 1119    FORMAT(/' ENTER THE VALUES FOR [C0,C1,C2,C3] FOR OUTPUT'/
     1'  EQUATION ',I1,': ')
 4140    READ(*,*,ERR=4145) C0(IEQ),C1(IEQ),C2(IEQ),C3(IEQ)
   	 GO TO 2120
 4145    WRITE(*,4146)
 4146    FORMAT(/' SEE ABOVE; PLEASE ENTER FOUR REAL NUMBERS: ')
	 GO TO 4140
 2120	 CONTINUE
	END DO
 2020	WRITE(*,219)
  219 FORMAT(//' THE DOSE TIMES, THE DOSE AMOUNTS (INCLUDING ALL BOLUS'/
     1' VALUES AND THE IV RATE WHICH IS ASSUMED TO BE THE 2ND ENTRY'/
     2' IN EACH DOSE ROW), AND THE OBSERVATION TIMES WHICH THE PROGRAM'/
     3' HAS READ FROM THE WORKING COPY PATIENT DATA FILE ABOVE WILL '/
     4' ALL BE ASSUMED TO BE "NOISY" VALUES.'//
     5' ENTER 0 FOR AN EXPLANATION OF HOW THE "NOISY" VALUES ARE OBTAINE
     1D.'/
     6' ENTER 1 TO CONTINUE: ')
	READ(*,*,ERR= 2020) ICONT
	IF(ICONT .NE. 0 .AND. ICONT .NE. 1) GO TO 2020
	IF(ICONT .EQ. 0) CALL EXPLAINOISE
	WRITE(*,6223)
 6223   FORMAT(/' ENTER C0,C1,C2,C3 FOR THE DOSE TIMES: ')
 6140   READ(*,*,ERR=6145) C0DT,C1DT,C2DT,C3DT
   	GO TO 6120
 6145   WRITE(*,4146)
	GO TO 6140
 6120	CONTINUE
	WRITE(*,7223)
 7223   FORMAT(/' ENTER C0,C1,C2,C3 FOR THE DOSE AMOUNTS: ')
 7140   READ(*,*,ERR=7145) C0DA,C1DA,C2DA,C3DA
   	GO TO 7120
 7145   WRITE(*,4146)
	GO TO 7140
 7120	CONTINUE
	WRITE(*,8223)
 8223   FORMAT(/' ENTER C0,C1,C2,C3 FOR THE OBSERVATION TIMES: ')
 8140   READ(*,*,ERR=8145) C0OT,C1OT,C2OT,C3OT
   	GO TO 8120
 8145   WRITE(*,4146)
	GO TO 8140
 8120	CONTINUE
	CALL GETDIST(IDIST,NGAUS,NVAR,COF,AMEAN,COV,PATH,NOB,OUTNPAG,
     1 TEXTFILE,OSname,ListDir)
      WRITE(*,1117)
 1117 FORMAT(/,' ENTER THE OUTPUT FILENAME WHICH WILL CONTAIN ALL THE'/
     1' GENERATED DATA OF THIS PROGRAM: ')
      READ(*,2) FILOUT
 1230	  WRITE(*,1234) NSUB,NSUB
 1234   FORMAT(/' ENTER 1 IF YOU WOULD LIKE THE INFORMATION FROM '/
     1'         THE ',I5,' SIMULATED PATIENT DATA FILES TO BE SAVED'/
     2'         IN BLOCK FORMAT TO A .CSV FILE; '/
     3' ENTER 2 IF YOU WOULD LIKE TO CREATE THE ',I5,' SIMULATED '/
     4'         PATIENT DATA FILES IN WORKING COPY FORMAT; '/
     5' ENTER 3 IF YOU WOULD LIKE BOTH A .CSV FILE AND A SET OF '/
     6'         WORKING COPY FILES TO BE MADE;'/
     7' ENTER 0 IF YOU DO NOT NEED A .CSV FILE OR A SET OF WORKING '/
     8'         COPY FILES (I.E., YOU ONLY NEED THE INFO THAT IS '/
     9'         SUPPLIED IN THE OUTPUT FILE): ')
        READ(*,*,ERR=1230) IPRNPAT
        IF(IPRNPAT .LT. 0 .OR. IPRNPAT .GT. 3) GO TO 1230
        IF(IPRNPAT .EQ. 1 .OR. IPRNPAT .EQ. 3) THEN
 1390    WRITE(*,1236)
 1236    FORMAT(/' ENTER THE NAME OF THE FILE WHICH WILL STORE THE'/
     1' SIMULATED INFO IN .CSV FORMAT: ')
         READ(*,2) OUTCSVNAME
 1380	   TMPFILE = ' '
         TMPFILE = OUTCSVNAME
         CALL FULLNAME(PATH,TMPFILE,PATHFILE)
         OPEN(29,FILE=PATHFILE,ERR=1370,STATUS='NEW')
         GO TO 1375
 1370    WRITE(*,9826) PATHFILE
         READ(*,*,ERR=1370) IFILE
         IF(IFILE .NE. 0 .AND. IFILE .NE. 1) GO TO 1370
         IF(IFILE .EQ. 0) GO TO 1390
         IF(IFILE .EQ. 1) OPEN(29,FILE=PATHFILE)
 1375    CLOSE(29)
        ENDIF
        IF(IPRNPAT .EQ. 2 .OR. IPRNPAT .EQ. 3) THEN
         WRITE(*,4041)
 4041    FORMAT(/' ENTER THE 3-CHAR PREFIX FOR THE SIMULATED PATIENT'/
     1' FILENAMES : ')
         READ(*,2222) PREFIX
         WRITE(*,4043)
 4043	   FORMAT(/' IF THERE IS A 3-CHAR EXTENSION FOR THE PATIENT '/
     1' FILENAMES, ENTER IT NOW; OTHERWISE, PRESS ENTER: ')
         READ(*,222) EXT
        ENDIF
 1240	WRITE(*,1231)
 1231   FORMAT(/' ENTER 1 IF YOU WISH THE STARTING SEED NO. FOR THE'/
     1' 	SIMULATOR TO BE THE DEFAULT VALUE OF -17;'/
     2' ENTER 0 IF YOU WISH THE STARTING SEED NO. TO BE READ FROM'/
     3'		THE FILE, "SEEDTO.MON" (IN THIS CASE THIS FILE WILL'/
     4'		HAVE ITS SEED NO. DECREASED BY 123 FOR THE NEXT RUN): ')
	READ(*,*,ERR=1240) ISEEDIND
	IF(ISEEDIND .NE. 1 .AND. ISEEDIND .NE. 0) GO TO 1240
	ENDIF
 7300    CONTINUE
	CALL VERIF1(PREFIX,EXT,NSUB,NVAR,C0,C1,C2,C3,NOFIX,VALFIX,
     1   PARFIX,FILEIN,IDIST,NGAUS,COF,AMEAN,COV,FILOUT,PATH,NOB,
     2   NUMEQT,IPRNPAT,C0DT,C1DT,C2DT,C3DT,C0DA,C1DA,C2DA,C3DA,
     3   C0OT,C1OT,C2OT,C3OT,ISEEDIND,PAR,ICSVFILE,OUTNPAG,TEXTFILE,
     4   OUTCSVNAME,OSname,ListDir,ILIMIT,BOUND)
       IF(IDIST .EQ. 0) NSUB = NGAUS
 1980	TMPFILE = ' '
	TMPFILE = FILOUT
	CALL FULLNAME(PATH,TMPFILE,PATHFILE)
     	OPEN(23,FILE=PATHFILE,ERR=1970,STATUS='NEW')
	GO TO 1975
 1970   WRITE(*,9826) PATHFILE
 9826   FORMAT(/' THE FOLLOWING FILE ALREADY EXISTS ....'/
     1'    ',A93/
     1' ENTER 0 TO ENTER A NEW FILENAME;'/
     2' ENTER 1 TO OVERWRITE THIS FILE: ')
	READ(*,*,ERR=1970) IFILE
	IF(IFILE .NE. 0 .AND. IFILE .NE. 1) GO TO 1970
	IF(IFILE .EQ. 0) THEN
	 WRITE(*,*)' ENTER THE NAME OF THE OUTPUT FILE. ALL OUTPUT FROM'
	 WRITE(*,*)' THE PROGRAM WILL BE PUT INTO THIS FILE: '
	 READ(*,2) FILOUT
	 GO TO 1980
	ENDIF
	IF(IFILE .EQ. 1) OPEN(23,FILE=PATHFILE)
 1975   CLOSE(23)
	WRITE(*,1118)
 1118   FORMAT(//' ENTER 1 TO SAVE THE INPUT DATA INTO AN INPUT FILE;'/
     1' ENTER 0 OTHERWISE : ')
 1120   READ(*,*,ERR=1125) ISAVFL
	IF(ISAVFL .EQ. 0 .OR. ISAVFL .EQ. 1) GO TO 1130
 1125   WRITE(*,1126)
 1126   FORMAT(/' SEE ABOVE; ENTER 0 OR 1: ')
	GO TO 1120
 1130   IF(ISAVFL .EQ. 1) THEN
	 WRITE(*,1131)
 1131	 FORMAT(/' ENTER NAME OF FILE TO SAVE INPUT DATA : ')
	 READ(*,2) SAVFIL
 1180	TMPFILE = ' '
	TMPFILE = SAVFIL
	CALL FULLNAME(PATH,TMPFILE,PATHFILE)
     	OPEN(24,FILE=PATHFILE,ERR=1170,STATUS='NEW')
	GO TO 1175
 1170   WRITE(*,9826) PATHFILE
	READ(*,*,ERR=1170) IFILE
	IF(IFILE .NE. 0 .AND. IFILE .NE. 1) GO TO 1170
	IF(IFILE .EQ. 0) THEN
	 WRITE(*,*)' ENTER THE NAME OF THE FILE TO SAVE INPUT DATA: '
	 READ(*,2) SAVFIL
	 GO TO 1180
	ENDIF
	IF(IFILE .EQ. 1) OPEN(24,FILE=PATHFILE)
 1175   CONTINUE
	 CODE = 'MONTBIG MAR_12'
       WRITE(24,7123) CODE
       WRITE(24,8111)
 8111  FORMAT(' MODEL FILENAME')
	 WRITE(24,2) FORFILE
       WRITE(24,8112)
 8112  FORMAT(' IRAN INDICES')
	 WRITE(24,*) (IRAN(I),I=1,NP)
       WRITE(24,8151)
 8151  FORMAT(' BOUNDARIES FOR RANDOM VARIABLES')
       DO I = 1,NVAR
        IF(ILIMIT(I) .EQ. 1) THEN
         BOUND(I,1) = -99
         BOUND(I,2) = -99
        ENDIF
        XVERIFY(1) = BOUND(I,1)
        XVERIFY(2) = BOUND(I,2)
        CALL VERIFYVAL(2,XVERIFY)
         WRITE(24,8152) ILIMIT(I),XVERIFY(1),XVERIFY(2)
 8152   FORMAT(5X,I1,2X,2(G19.9,1X))
       END DO
       WRITE(24,8116)
 8116  FORMAT(' ICSVFILE')
       WRITE(24,*) ICSVFILE
       WRITE(24,8117)
 8117  FORMAT(' FILEIN')
	 WRITE(24,2) FILEIN
       WRITE(24,8118)
 8118  FORMAT(' NSUB')
	 WRITE(24,*) NSUB
 2416  FORMAT(30(G14.7,1X))
       WRITE(24,8119)
 8119  FORMAT(' NOFIX')
	 WRITE(24,*) NOFIX
      IF(NOFIX .GT. 0) THEN
       DO I=1,NOFIX
        XVERIFY(I) = VALFIX(I)
       END DO
       CALL VERIFYVAL(NOFIX,XVERIFY)
      ENDIF
       WRITE(24,8121)
 8121  FORMAT(' VALFIX ARRAY IF NOFIX > 0')
       IF(NOFIX .GT. 0) WRITE(24,2416) (XVERIFY(I),I=1,NOFIX)
       WRITE(24,8122)
 8122  FORMAT(' TOLER')
	 WRITE(24,*) TOLER
       WRITE(24,8123)
 8123  FORMAT(' NUMEQT')
	 WRITE(24,*) NUMEQT
       WRITE(24,8124)
 8124  FORMAT(' NUMEQT LINES OF ASSAY COEFFICIENTS')
       DO IEQ=1,NUMEQT
        XVERIFY(1) = C0(IEQ)
        XVERIFY(2) = C1(IEQ)
        XVERIFY(3) = C2(IEQ)
        XVERIFY(4) = C3(IEQ)
        CALL VERIFYVAL(4,XVERIFY)
        WRITE(24,2416) (XVERIFY(IXV),IXV=1,4)
	 END DO
       WRITE(24,8126)
 8126  FORMAT(' ERROR COEFFS. FOR DOSE TIMES')
        XVERIFY(1) = C0DT
        XVERIFY(2) = C1DT
        XVERIFY(3) = C2DT
        XVERIFY(4) = C3DT
        CALL VERIFYVAL(4,XVERIFY)
        WRITE(24,2416) (XVERIFY(IXV),IXV=1,4)
       WRITE(24,8127)
 8127  FORMAT(' ERROR COEFFS. FOR DOSE AMOUNTS')
        XVERIFY(1) = C0DA
        XVERIFY(2) = C1DA
        XVERIFY(3) = C2DA
        XVERIFY(4) = C3DA
        CALL VERIFYVAL(4,XVERIFY)
        WRITE(24,2416) (XVERIFY(IXV),IXV=1,4)
       WRITE(24,8128)
 8128  FORMAT(' ERROR COEFFS. FOR OBSERVATION TIMES')
        XVERIFY(1) = C0OT
        XVERIFY(2) = C1OT
        XVERIFY(3) = C2OT
        XVERIFY(4) = C3OT
        CALL VERIFYVAL(4,XVERIFY)
        WRITE(24,2416) (XVERIFY(IXV),IXV=1,4)
       WRITE(24,8129)
 8129  FORMAT(' IDIST')
	 WRITE(24,*) IDIST
       WRITE(24,8131)
 8131  FORMAT(' NGAUS')
	 WRITE(24,*) NGAUS
       WRITE(24,8132)
 8132  FORMAT(' NGAUS SETS OF COF(.), AMEAN(.,.), COV(.,.,.)')
       DO IGAUS = 1,NGAUS
	  WRITE(24,*) COF(IGAUS)
        DO I = 1,NVAR
         XVERIFY(I) = AMEAN(IGAUS,I)
        END DO
        CALL VERIFYVAL(NVAR,XVERIFY)
        WRITE(24,2416) (XVERIFY(I),I=1,NVAR)
        DO I = 1,NVAR
         DO J = 1,I
          XVERIFY(J) = COV(IGAUS,I,J)
         END DO
         CALL VERIFYVAL(I,XVERIFY)
         WRITE(24,2416) (XVERIFY(J),J=1,I)
        END DO
       END DO
       WRITE(24,8133)
 8133  FORMAT(' FILOUT')
	 WRITE(24,2) FILOUT
       WRITE(24,8134)
 8134  FORMAT(' IPRNPAT')
	 WRITE(24,*) IPRNPAT
       WRITE(24,8139)
 8139  FORMAT(' OUTCSVNAME')
       IF(IPRNPAT .EQ. 0 .OR. IPRNPAT .EQ. 2) WRITE(24,8141)
 8141  FORMAT(' NOT APPLICABLE')
       IF(IPRNPAT .EQ. 1 .OR. IPRNPAT .EQ. 3) WRITE(24,2) OUTCSVNAME
       WRITE(24,8142)
 8142  FORMAT(' PREFIX')
       IF(IPRNPAT .EQ. 0 .OR. IPRNPAT .EQ. 1) WRITE(24,8141)
       IF(IPRNPAT .EQ. 2 .OR. IPRNPAT .EQ. 3) WRITE(24,2222) PREFIX
       WRITE(24,8143)
 8143  FORMAT(' EXT')
       IF(IPRNPAT .EQ. 0 .OR. IPRNPAT .EQ. 1) WRITE(24,8141)
       IF(IPRNPAT .EQ. 2 .OR. IPRNPAT .EQ. 3) WRITE(24,222) EXT
       WRITE(24,8136)
 8136  FORMAT(' ISEEDIND')
	 WRITE(24,*) ISEEDIND
	 CLOSE(24)
	ENDIF
      TMPFILE = ' '
	TMPFILE = FILOUT
	CALL FULLNAME(PATH,TMPFILE,PATHFILE)
	OPEN(23,FILE=PATHFILE)
        WRITE(23,231)
  231   FORMAT(/' THE USER-INPUT INSTRUCTIONS FOR THIS RUN FOLLOW: ')
        WRITE(23,233) FORFILE
  233   FORMAT(/' THE FORTRAN MODEL FILE USED WAS ',A32)
        WRITE(23,234)
  234   FORMAT(/' THE IRAN VECTOR IS SHOWN BELOW, WHERE IRAN(I)= 1'/
     1' IF PARAMATER I WAS RANDOM; 0 IF PARAMETER I WAS FIXED.')
        WRITE(23,*) (IRAN(I),I=1,NP)
        WRITE(23,2234)
 2234   FORMAT(/' THE REQUIRED BOUNDARIES FOR THE RANDOM VARIABLES'/
     1' WHICH ARE USED TO SIMULATE SUBJECTS ARE AS FOLLOWS: ')
        DO I = 1,NVAR
         IF(ILIMIT(I) .EQ. 1) WRITE(23,2236) PAR(I)
 2236     FORMAT(1X,A11,' <-- NO RESTRICTIONS ON PARAMETER VALUES ')
         IF(ILIMIT(I) .EQ. 0) WRITE(23,2237) PAR(I),BOUND(I,1),
     1    BOUND(I,2)
 2237     FORMAT(1X,A11,2X,G19.9,'  TO  ',G19.9)
        END DO
        IF(ICSVFILE .EQ. 0) THEN
         WRITE(23,238)
  238    FORMAT(/' THE NAME OF THE WORKING COPY PATIENT DATA FILE'/
     1' WHICH CONTAINS THE DOSE/COVARIATE INFORMATION WHICH WILL BE'/
     2' USED TO SIMULATE THE PATIENT DATA FILES IS: ')
         WRITE(23,2) FILEIN
        ENDIF
        IF(ICSVFILE .EQ. 1) THEN
         WRITE(23,1238)
 1238    FORMAT(/' THE NAME OF THE .CSV FILE WHICH CONTAINS THE DOSE/'/
     1' COVARIATE INFORMATION (IN ITS FIRST SUBJECT BLOCK) WHICH WILL '/
     2' BE USED TO SIMULATE THE PATIENT DATA FILES IS: ')
         WRITE(23,2) FILEIN
        ENDIF
        WRITE(23,239) NSUB
  239   FORMAT(/' THE NO. OF SIMULATED SUBJECTS WAS ',I6)
        IF(NOFIX .EQ. 0) WRITE(23,241)
  241   FORMAT(/' THERE WERE NO FIXED PARAMETERS IN THIS RUN.')
        IF(NOFIX .GT. 0) THEN
         DO I=1,NOFIX
          XVERIFY(I) = VALFIX(I)
         END DO
         CALL VERIFYVAL(NOFIX,XVERIFY)
         WRITE(23,242)
  242    FORMAT(/' THE FIXED PARAMETER VALUES, IN ORDER, WERE: ')
          WRITE(23,2416) (XVERIFY(I),I=1,NOFIX)
        ENDIF
        WRITE(23,243)
  243   FORMAT(/' THE TOLERANCES FOR THE O.D.E. SOLVER WERE ALL ')
        WRITE(23,*) TOLER
        WRITE(23,244) NUMEQT
  244   FORMAT(/' THE NO. OF OUTPUT EQUATIONS WAS ',I3)
        WRITE(23,246)
  246   FORMAT(/' THE ASSAY COEFFICIENTS FOR EACH OF THE OUTPUT '/
     1' EQUATIONS, IN ORDER, WERE: ')
        DO IEQ = 1,NUMEQT
         XVERIFY(1) = C0(IEQ)
         XVERIFY(2) = C1(IEQ)
         XVERIFY(3) = C2(IEQ)
         XVERIFY(4) = C3(IEQ)
         CALL VERIFYVAL(4,XVERIFY)
         WRITE(23,2416) (XVERIFY(IXV),IXV=1,4)
        END DO
       WRITE(23,247)
  247  FORMAT(/' THE DOSE TIMES, THE DOSE AMOUNTS (INCLUDING ALL BOLUS'/
     1' VALUES AND THE IV RATES), AND THE OBSERVATION TIMES WHICH THE'/
     2' PROGRAM READ FROM THE WORKING COPY PATIENT DATA FILE ABOVE'/
     3' WERE ALL ASSUMED TO BE "NOISY" VALUES.'//
     5' EACH DOSE TIME IS MADE "NOISY" AS FOLLOWS:'/
     1' THE FIRST DOSE TIME, WITH A TRUE VALUE OF VTRUE, WILL BE '/
     2' CHANGED TO BE VNOISY, WHERE VNOISY = VTRUE + Ei, WHERE'/
     3' Ei ~ N(0,STDI**2), WHERE '/
     4' STDI = C0 + C1*VTRUE + C2*VTRUE**2 + C3*VTRUE**3'//
     5' FOR SUBSEQUENT DOSE TIMES, THE NOISY DOSE TIME IS '/
     6' DETERMINED AS FOLLOWS:'/
     7' a. SET DUR = NOMINAL DURATION BETWEEN THE PREVIOUS DOSE TIME '/
     8'    AND THE CURRENT DOSE TIME.'/
     3' b. CALC. THE NOISY DURATION, DURNOISY, AS '/
     4'    DURNOISY = DUR + Ei, Ei ~ N(0,STDI**2), WHERE '/
     7'    STDI = C0 + C1*DUR + C2*DUR**2 + C3*DUR**3'/
     8' c. ... BUT LIMIT DURNOISY TO BE .GE. .5*DUR AND .LE. 2*DUR.'/
     9' d. SET THE CURRENT NOISY DOSE TIME = PREVIOUS NOISY DOSE TIME'/
     1'    + DURNOISY.'//
     2' THE SAME LOGIC APPLIES FOR OBS. TIMES. '//
     3' NOTE THIS LOGIC --> TIMES CANNOT BE OUT OF ORDER.'//
     4' EACH IV RATE AND EACH BOLUS VALUE WHICH = 0 WILL NOT'/
     1' BE MADE NOISY. I.E., IT IS ASSUMED THAT IF A RATE OR BOLUS IS'/
     2' INTENDED TO BE 0, IT WILL BE ACHIEVED WITHOUT ERROR.'
     2/
     3' A NON-ZERO IV OR BOLUS VALUE, WITH A TRUE VALUE OF VTRUE, '/
     4' WILL BE CHANGED TO BE VNOISY, WHERE VNOISY = VTRUE + Ei, WHERE'/
     6' Ei ~ N(0,STDI**2), WHERE '/
     7' STDI = C0 + C1*VTRUE + C2*VTRUE**2 + C3*VTRUE**3')
        WRITE(23,248)
  248   FORMAT(/' C0,C1,C2,C3 FOR THE DOSE TIMES WERE: ')
        XVERIFY(1) = C0DT
        XVERIFY(2) = C1DT
        XVERIFY(3) = C2DT
        XVERIFY(4) = C3DT
        CALL VERIFYVAL(4,XVERIFY)
        WRITE(23,2416) (XVERIFY(IXV),IXV=1,4)
        WRITE(23,249)
  249   FORMAT(/' C0,C1,C2,C3 FOR THE DOSE AMOUNTS WERE: ')
        XVERIFY(1) = C0DA
        XVERIFY(2) = C1DA
        XVERIFY(3) = C2DA
        XVERIFY(4) = C3DA
        CALL VERIFYVAL(4,XVERIFY)
        WRITE(23,2416) (XVERIFY(IXV),IXV=1,4)
        WRITE(23,251)
  251   FORMAT(/' C0,C1,C2,C3 FOR THE OBSERVATION TIMES WERE: ')
        XVERIFY(1) = C0OT
        XVERIFY(2) = C1OT
        XVERIFY(3) = C2OT
        XVERIFY(4) = C3OT
        CALL VERIFYVAL(4,XVERIFY)
        WRITE(23,2416) (XVERIFY(IXV),IXV=1,4)
        IF(OUTNPAG(1:10) .NE. '          ') WRITE(23,351) NGAUS,OUTNPAG
  351    FORMAT(/' THE MIXTURE OF ',I3,' DISTRIBUTION(S) DESCRIBED '/
     1' BELOW CAME FROM THE BIG NPAG OUTPUT FILE, ',A20)
       IF(TEXTFILE(1:10) .NE. '          ') WRITE(23,751) NGAUS,TEXTFILE
  751  FORMAT(/' THE MIXTURE OF ',I3,' DISTRIBUTION(S) DESCRIBED '/
     1' BELOW CAME FROM THE TEXT FILE, ',A20)
      IF(IDIST .EQ. 0) THEN
        WRITE(23,254) NGAUS
  254   FORMAT(/' THE OBSERVATIONS FOR EACH OF THE ',I3,' SUBJECT'/
     1' VECTORS WERE GENERATED BY ASSUMING EACH SUBJECT HAD EXACTLY'/
     2' THE PARAMETER VALUES OF ONE OF THE GRID PTS. IN THE FINAL'/
     3' CYCLE DENSITY FROM THE INPUT NPAG RUN. THESE GRID PTS. ARE: '/)
       DO IGAUS = 1,NGAUS
        WRITE(23,9004) IGAUS
 9004   FORMAT(//' GRID PT. NO: ',I3)
        DO I = 1,NVAR
         XVERIFY(I) = AMEAN(IGAUS,I)
        END DO
        CALL VERIFYVAL(NVAR,XVERIFY)
        WRITE(23,9007) (XVERIFY(I),I=1,NVAR)
 9007   FORMAT(/' PAR. VALUES: ',150G10.3)
       END DO
      ENDIF
        IF(IDIST .EQ. 1) WRITE(23,252) NGAUS
  252   FORMAT(/' THE SUBJECT VECTORS WERE GENERATED FROM A MIXTURE'/
     1' OF ',I3,' GAUSSIAN DISTRIBUTIONS. THE FOLLOWING DESCRIBES '/
     2' THESE DISTRIBUTIONS: ')
        IF(IDIST .EQ. 2) WRITE(23,253) NGAUS
  253   FORMAT(/' THE SUBJECT VECTORS WERE GENERATED FROM A MIXTURE'/
     1' OF ',I3,' LOGNORMAL DISTRIBUTIONS. THE FOLLOWING DESCRIBES '/
     2' THESE DISTRIBUTIONS: ')
      IF(IDIST .NE. 0) THEN
	DO 8020 IGAUS=1,NGAUS
	WRITE(23,8004) IGAUS
 8004 FORMAT(//' DISTRIBUTION NO: ',I3)
      XVERIFY(1) = COF(IGAUS)
      CALL VERIFYVAL(1,XVERIFY)
      WRITE(23,8006) XVERIFY(1)
 8006 FORMAT(/' WEIGHTING COEFFICIENT: ',F10.3)
       DO I = 1,NVAR
        XVERIFY(I) = AMEAN(IGAUS,I)
       END DO
       CALL VERIFYVAL(NVAR,XVERIFY)
       WRITE(23,8007) (XVERIFY(I),I=1,NVAR)
 8007  FORMAT(/' MEAN VECTOR: ',150G10.3)
       WRITE(23,8008)
 8008   FORMAT(/' THE COVARIANCE MATRIX, IN LOWER-TRIANGULAR FORM IS: ')
        DO I=1,NVAR
         DO J = 1,I
          XVERIFY(J) = COV(IGAUS,I,J)
         END DO
         CALL VERIFYVAL(I,XVERIFY)
         WRITE(23,2416) (XVERIFY(J),J=1,I)
        END DO
	DO I = 1,NVAR
	 DO J = 1,I
	  CORR(I,J)= COV(IGAUS,I,J)/DSQRT(COV(IGAUS,I,I)*COV(IGAUS,J,J))
	 END DO
	END DO
      WRITE(23,8009)
 8009 FORMAT(/' THE CORRELATION MATRIX, IN LOWER-TRIANGULAR FORM IS:')
        DO I = 1,NVAR
         DO J = 1,I
          XVERIFY(J) = CORR(I,J)
         END DO
         CALL VERIFYVAL(I,XVERIFY)
         WRITE(23,2416) (XVERIFY(J),J=1,I)
        END DO
 8020   CONTINUE
      ENDIF
        IF(IPRNPAT .EQ. 1 .OR. IPRNPAT .EQ. 3)
     1   WRITE(23,9013) NSUB,OUTCSVNAME
 9013   FORMAT(/' THE INFORMATION FROM THE ',I5,' SIMULATED PATIENT'/
     1' DATA FILES WAS SAVED IN BLOCK FORMAT TO '/
     2' FILE ',A32)
        IF(IPRNPAT .EQ. 2 .OR. IPRNPAT .EQ. 3)
     1   WRITE(23,8013) NSUB,PREFIX,EXT
 8013   FORMAT(/' THIS RUN CREATED ',I5,' SIMULATED PATIENT DATA '/
     1' FILES, WITH PREFIX ',A3,' AND EXTENSION ',A3)
        IF(IPRNPAT .EQ. 0) WRITE(23,8014) NSUB
 8014   FORMAT(/' THE INFORMATION FROM THE ',I5,' SIMULATED PATIENT'/
     1' DATA FILES WAS NOT SAVED IN BLOCK FORMAT TO A .CSV FILE, AND'/
     2' NO SIMULATED PATIENT DATA FILES WERE CREATED')
	IF(ISEEDIND .EQ. 1) WRITE(23,257)
  257   FORMAT(/' THIS RUN USED THE DEFAULT SEED NO. -17.')
	IF(ISEEDIND .EQ. 0) WRITE(23,258)
  258   FORMAT(/' THIS RUN USED THE SEED NO. STORED IN "SEEDTO.MON" '/
     1' (SEE BELOW) AND UPDATED THE VALUE IN THAT FILE BY -123 FOR THE'/
     2' NEXT RUN.')
	WRITE(23,232)
  232   FORMAT(/' THE USER-INPUT INSTRUCTIONS FOR THIS RUN ARE ABOVE.'/
     1/
     2'*************************************************************'/
     3'*************************************************************'//
     4'********** THE FOLLOWING ARE THE RESULTS OF THIS RUN ********'//)
	CALL SIMBIG(PREFIX,EXT,FILEIN,NSUB,NVAR,NOFIX,IRAN,VALFIX,
     1   C0,C1,C2,C3,IDIST,NGAUS,COF,AMEAN,COV,PATH,NDIM,PAR,
     2   IPRNPAT,ISEEDIND,ICSVFILE,OUTCSVNAME,OSname,DeleteFile,
     3   ListDir,ILIMIT,BOUND)
      STOP
      END
      SUBROUTINE GNRAT(N,MEAN,COV,VEC,IDUM)
      IMPLICIT REAL*8(A-H,O-Z)
      DIMENSION MEAN(594),COV(594,594),VEC(594),SIG(594,594),RVEC(594),
     1 ID(594),A(594,594),R(594)
      DOUBLE PRECISION MEAN
      DO 10 I=1,N
   10 ID(I)=1
      DO 30 I=1,N
      DO 20 J=1,I
   20 SIG(I,J)=COV(I,J)
      IF(SIG(I,I) .EQ. 0.D0) THEN
         SIG(I,I)=1.D-4
         ID(I)=0
         ENDIF
   30 CONTINUE
      CALL SQROOT(N,SIG,A)
      DO 40 I=1,N
   40 R(I)=GASDEV(IDUM)
      DO 60 I=1,N
      SUM=0.D0
      DO 50 J=1,I
   50 SUM=SUM+A(I,J)*R(J)
   60 RVEC(I)=SUM
      DO 70 I=1,N
      VEC(I)=RVEC(I)+MEAN(I)
   70 IF(ID(I) .EQ. 0) VEC(I)=MEAN(I)
      RETURN
      END
      SUBROUTINE SQROOT(N,SIG,A)
      IMPLICIT REAL*8(A-H,O-Z)
      DIMENSION SIG(594,594),A(594,594)
      CHARACTER ERRFIL*20
      COMMON/ERROR/ERRFIL
      DO 10 I=1,N
      DO 10 J=I+1,N
   10 A(I,J)=0.D0
      DO 100 I=1,N
      DO 100 J=1,I
      IF(I .EQ. J) THEN
	SUM=0.D0
	DO 20 K=1,I-1
   20 	SUM=SUM+A(I,K)*A(I,K)
	RAD=SIG(I,I)-SUM
	IF(RAD .LE. 0.D0) THEN
	  WRITE(*,101)
  101   FORMAT(/' COV MATRIX IS NOT POS-DEF; PROGRAM STOPS. ')
	  WRITE(23,101)
        OPEN(42,FILE=ERRFIL)
         WRITE(42,101)
        CLOSE(42)
        CALL PAUSE
	  STOP
	 ENDIF
	A(I,I)=DSQRT(RAD)
	ELSE
	SUM=0.D0
	DO 30 K=1,J-1
   30   SUM=SUM+A(I,K)*A(J,K)
	A(I,J)=(SIG(I,J)-SUM)/A(J,J)
	ENDIF
  100 CONTINUE
      RETURN
      END
      REAL*8 FUNCTION GASDEV(IDUM)
        IMPLICIT REAL*8 (A-H,O-Z)
      DATA ISET/0/
      double precision, save :: GSET
      IF (ISET.EQ.0) THEN
1       V1=2.*RAN1(IDUM)-1.
        V2=2.*RAN1(IDUM)-1.
        R=V1**2+V2**2
        IF(R.GE.1.)GO TO 1
        FAC=SQRT(-2.*LOG(R)/R)
        GSET=V1*FAC
        GASDEV=V2*FAC
        ISET=1
      ELSE
        GASDEV=GSET
        ISET=0
      ENDIF
      RETURN
      END
      DOUBLE PRECISION FUNCTION RAN1(IDUM)
        IMPLICIT REAL*8 (A-H,O-Z)
      DIMENSION R(97)
      DOUBLE PRECISION,SAVE :: rrr
      DOUBLE PRECISION,DIMENSION(97),SAVE :: zzz
      INTEGER*4 IX1
      INTEGER*4 IX2
      INTEGER*4 IX3
      SAVE :: IX1, IX2, IX3
      PARAMETER (M1=259200,IA1=7141,IC1=54773,RM1=3.8580247E-6)
      PARAMETER (M2=134456,IA2=8121,IC2=28411,RM2=7.4373773E-6)
      PARAMETER (M3=243000,IA3=4561,IC3=51349)
      DATA IFF /0/
      IF (IDUM.LT.0.OR.IFF.EQ.0) THEN
        IFF=1
        IX1=MOD(IC1-IDUM,M1)
        IX1=MOD(IA1*IX1+IC1,M1)
        IX2=MOD(IX1,M2)
        IX1=MOD(IA1*IX1+IC1,M1)
        IX3=MOD(IX1,M3)
        DO 11 J=1,97
          IX1=MOD(IA1*IX1+IC1,M1)
          IX2=MOD(IA2*IX2+IC2,M2)
          R(J)=(FLOAT(IX1)+FLOAT(IX2)*RM2)*RM1
          zzz(J) = R(J)
11      CONTINUE
        IDUM=1
      ENDIF
      IX1=MOD(IA1*IX1+IC1,M1)
      IX2=MOD(IA2*IX2+IC2,M2)
      IX3=MOD(IA3*IX3+IC3,M3)
      J=1+(97*IX3)/M3
      IF(J.GT.97.OR.J.LT.1) THEN
        CALL init_random_seed(J)
        CALL RANDOM_NUMBER(rrr)
        PRINT *, 'In RAN1() old J corresponds to: ', J, IX1, IX2, IX3
        J = 97*rrr
        IF(J.LT.1) J=J+1
        write(*,FMT = 1112) J
 1112   FORMAT( 'WARNING: Increment into rvec went out of range: ', I5 )
      ENDIF
      RAN1=zzz(J)
      R(J)=(FLOAT(IX1)+FLOAT(IX2)*RM2)*RM1
      zzz(J)=R(J)
      RETURN
      END
       SUBROUTINE init_random_seed(j)
          INTEGER :: i, j, n, clock
          INTEGER, DIMENSION(:), ALLOCATABLE :: seed
          CALL RANDOM_SEED(size = n)
          ALLOCATE(seed(n))
          CALL SYSTEM_CLOCK(COUNT=clock)
          seed = clock + 37 * (/ (i - 1, i = 1, n) /)
          CALL RANDOM_SEED(PUT = seed)
          DEALLOCATE(seed)
       END SUBROUTINE
      SUBROUTINE NOSGEN(M,VAR,IDUM,AS1)
      IMPLICIT REAL*8(A-H,O-Z)
      DIMENSION AS1(594),AM(594),COV(594,594)
      DO 10 I=1,M
   10 AM(I)=0.D0
      DO 20 I=1,M
      DO 20 J=1,I
   20 COV(I,J)=0.D0
      DO 30 I=1,M
   30 COV(I,I)=VAR
      CALL GNRAT(M,AM,COV,AS1,IDUM)
      RETURN
      END
      SUBROUTINE STATT(NSUB,NP,V,SAMMEN,SAMCOV)
      IMPLICIT REAL*8(A-H,O-Z)
      DIMENSION V(100000,30),SAMMEN(30),SAMCOV(30,30),SUM(30),
     1SUMPRD(30,30)
      DO 10 J=1,NP
   10 SUM(J)=0.D0
      DO 30 J=1,NP
      DO 20 I=1,NSUB
   20 SUM(J)=SUM(J)+V(I,J)
   30 SAMMEN(J)=SUM(J)/NSUB
      DO 40 J=1,NP
      DO 40 K=1,J
   40 SUMPRD(J,K)=0.D0
      DO 60 J=1,NP
      DO 60 K=1,J
      DO 50 I=1,NSUB
   50 SUMPRD(J,K)=SUMPRD(J,K)+V(I,J)*V(I,K)
   60 SAMCOV(J,K)=(SUMPRD(J,K)-NSUB*SAMMEN(J)*SAMMEN(K))/NSUB
      RETURN
      END
	SUBROUTINE VERIF1(PREFIX,EXT,NSUB,NVAR,C0,C1,C2,C3,
     1   NOFIX,VALFIX,PARFIX,FILEIN,IDIST,NGAUS,COF,AMEAN,COV,FILOUT,
     2   PATH,NOB,NUMEQT,IPRNPAT,C0DT,C1DT,C2DT,C3DT,
     3   C0DA,C1DA,C2DA,C3DA,C0OT,C1OT,C2OT,C3OT,ISEEDIND,PAR,ICSVFILE,
     4   OUTNPAG,TEXTFILE,OUTCSVNAME,OSname,ListDir,ILIMIT,BOUND)
	IMPLICIT REAL*8(A-H,O-Z)
	PARAMETER(MAXNUMEQ=7)
	DIMENSION VALFIX(20),COF(150),AMEAN(150,30),COV(150,30,30),
     1 C0(MAXNUMEQ),C1(MAXNUMEQ),C2(MAXNUMEQ),C3(MAXNUMEQ),
     2 CORR(30,30),ILIMIT(32),BOUND(32,2),XVERIFY(900)
	CHARACTER PREFIX*3,EXT*3,PARFIX(20)*11,PAR(30)*11,
     1   FILOUT*32,FILEIN*32,PATH*61,TMPFILE*32,PATHFILE*93,OUTNPAG*20,
     2   OUTCSVNAME*32,OSname*20,ListDir*10,TEXTFILE*20
  102   FORMAT(A32)
  103   FORMAT(A3)
  104   FORMAT(A3)
 8040   WRITE(*,1)
    1   FORMAT(///' THE FOLLOWING INFO WAS READ IN; IF ANY OF IT IS '/
     1' INCORRECT, MAKE THE DESIRED CHANGES.')
        IF(ICSVFILE .EQ. 0) WRITE(*,8002) FILEIN
 8002   FORMAT(/' THE PATIENT DOSE/COVARIATE AND OBS. TIME INFO WILL '/
     1' BE INPUT FROM THE WORKING COPY PATIENT FILE: ',A32)
        IF(ICSVFILE .EQ. 1) WRITE(*,8023) FILEIN
 8023   FORMAT(/' THE PATIENT DOSE/COVARIATE AND OBS. TIME INFO WILL '/
     1' BE FROM THE DATA OF THE FIRST SUBJECT IN THE BLOCK MATRIX '/
     2' .CSV FILE: ',A32)
	CALL CHANGE(ICHANG)
	IF(ICHANG .EQ. 0) THEN
 5020   WRITE(*,5002)
 5002   FORMAT(/' THE DOSE/COVARIATE AND OBSERVATION TIME INFORMATION'/
     1' WHICH WILL BE USED TO SIMULATE THE PATIENT DATA FILES CAN BE'/
     2' INPUT VIA A (MULTIPLE DRUG) WORKING COPY PATIENT DATA FILE OR'/
     3' VIA A BLOCK MATRIX .CSV FILE (THE INFO WILL COME FROM THE '/
     4' DATE OF THE FIRST SUBJECT IN THIS CASE).'//
     5' ENTER 1 TO ENTER INFO USING A .CSV FILE; '/
     6' ENTER 0 TO ENTER INFO USING A WORKING COPY PATIENT DATA FILE: ')
        READ(*,*,ERR=5020) ICSVFILE
        IF(ICSVFILE .NE. 1 .AND. ICSVFILE .NE. 0) GO TO 5020
        IF(ICSVFILE .EQ. 0) THEN
        WRITE(*,1021)
 1021   FORMAT(/' ENTER THE NAME OF THE WORKING COPY PATIENT DATA FILE'/
     1' WHICH CONTAINS THE DOSE/COVARIATE INFORMATION WHICH WILL BE'/
     2' USED TO SIMULATE THE PATIENT DATA FILES.'//
     3' BE SURE THAT THIS IS A MULTI-DRUG WORKING COPY DATA FILE.'//
     1' ENTER -99 TO SEE ALL OR A PART OF YOUR DIRECTORY: ')
        READ(*,212) FILEIN
        IF(FILEIN(1:3) .EQ. '-99') CALL SEEDIR(PATH,NOB,FILEIN,
     1     OSname,ListDir)
	TMPFILE = ' '
	TMPFILE = FILEIN
	CALL FULLNAME(PATH,TMPFILE,PATHFILE)
	OPEN(21,FILE=PATHFILE,ERR=6440,STATUS='OLD')
	GO TO 6455
 6440 WRITE(*,5316) PATHFILE
 5316 FORMAT(//' THE FOLLOWING FILE DOES NOT EXIST ... '/
     1' ',A93)
	GO TO 5020
 6455 CONTINUE
        ENDIF
        IF(ICSVFILE .EQ. 1) THEN
        WRITE(*,3021)
 3021   FORMAT(/' ENTER THE NAME OF THE BLOCK MATRIX .CSV FILE. ONLY'/
     1' THE DATA FROM THE FIRST SUBJECT IN THIS FILE WILL BE READ TO'/
     2' OBTAIN THE DOSE/COVARIATE INFORMATION WHICH WILL BE USED TO'/
     3' TO SIMULATE THE PATIENT DATA FILES.'//
     1' ENTER -99 TO SEE ALL OR A PART OF YOUR DIRECTORY: ')
     	  READ(*,212) FILEIN
  212   FORMAT(A32)
        IF(FILEIN(1:3) .EQ. '-99') CALL SEEDIR(PATH,NOB,FILEIN,
     1     OSname,ListDir)
        TMPFILE = ' '
        TMPFILE = FILEIN
        CALL FULLNAME(PATH,TMPFILE,PATHFILE)
        OPEN(87,FILE=PATHFILE,ERR=5440,STATUS='OLD')
        GO TO 5455
 5440   WRITE(*,5316) PATHFILE
        GO TO 5020
 5455   CONTINUE
        CALL CONVERTCSV
         OPEN(67)
         CALL NEWCSV
         CALL CSVCHANGE
         REWIND(66)
         CALL READBLOCK2(PATH,C0,C1,C2,C3)
         CLOSE(66)
        TMPFILE = ' '
        TMPFILE = 'XQZPJ001.ZMQ'
        CALL FULLNAME(PATH,TMPFILE,PATHFILE)
        OPEN(21,FILE=PATHFILE,ERR=5465,STATUS='OLD')
        GO TO 5470
 5465   WRITE(*,5466) PATHFILE,FILEIN
 5466   FORMAT(//' THE FOLLOWING FILE DOES NOT EXIST ... '/
     1' ',A93/
     2' WHICH MEANS THAT YOUR .CSV FILE, ',A20,' WAS NOT READ '/
     3' PROPERLY. PLEASE CHECK THIS FILE TO MAKE SURE IT IS CORRECT.'//)
        GO TO 5020
 5470   CONTINUE
        ENDIF
	CALL GETNUMEQ(NUMEQT2)
	CLOSE(21)
	IF(NUMEQT .NE. NUMEQT2) THEN
	 WRITE(*,7512) NUMEQT2,NUMEQT
 7512    FORMAT(//' YOUR NEW WORKING COPY FILE HAS ',I4,' OUTPUT'/
     1' EQUATION(S), RATHER THAN THE ',I4,' OUTPUT EQUATION(S) THAT '/
     2' YOUR ORIGINAL WORKING COPY FILE HAD. BE SURE TO CHANGE THE '/
     3' ASSAY COEFFICIENT INFORMATION BELOW, IF NEEDED.')
	 IF(NUMEQT .LT. NUMEQT2) THEN
	  DO IEQ = NUMEQT+1,NUMEQT2
	   C0(IEQ) = 1
	   C1(IEQ) = 1
	   C2(IEQ) = 1
	   C3(IEQ) = 1
	  END DO
	 ENDIF
	NUMEQT = NUMEQT2
	ENDIF
	ENDIF
	WRITE(*,6) NSUB
    6   FORMAT(/' THE NO. OF PATIENT FILES TO BE SIMULATED IS: ',I5)
	CALL CHANGE(ICHANG)
	IF(ICHANG .EQ. 0) THEN
 4070   WRITE(*,121)
  121   FORMAT(/' ENTER THE NO. OF SUBJECTS TO BE SIMULATED (LESS THAN'/
     1'		10000): ')
	READ(*,*,ERR=4070) NSUB
	IF(NSUB .LE. 0 .OR. NSUB .GT. 10000) GO TO 4070
        ENDIF
	WRITE(*,5183)
 5183   FORMAT(//' IF YOU WOULD LIKE TO CHANGE YOUR FORTRAN MODEL'/
     1' FILE OR THE DESIGNATION OF WHICH PARAMETERS ARE TO BE RANDOM'/
     2' AND WHICH FIXED, PLEASE STOP THIS PROGRAM NOW, AND THEN '/
     3' RERUN IT.'//
     4' YOU WILL, HOWEVER, BE ABLE TO CHANGE THE FIXED PARAMETER'/
     5' VALUES, AS WELL AS THE DISTRIBUTION OF THE RANDOM PARAMETERS,'/
     6' AND THEIR BOUNDARIES, BELOW.'//)
	CALL PAUSE
	WRITE(*,201)
  201   FORMAT(/' THE USER-ENTERED FIXED PARAMETER VALUE(S) IS (ARE):')
	IF(NOFIX .EQ. 0) WRITE(*,*)' ... NONE SELECTED.'
	IF(NOFIX .GT. 0) THEN
	  DO 210 I=1,NOFIX
  210     WRITE(*,211) PARFIX(I),VALFIX(I)
	ENDIF
  211   FORMAT(/' ',A11,': ',G17.10)
	WRITE(*,12)
   12   FORMAT(/' THE ASSAY S.D. COEFFICIENTS, [C0,C1,C2,C3] ARE, FOR'/
     1' EACH OUPUT EQUATION, AS FOLLOWS: ')
       DO IEQ = 1,NUMEQT
        XVERIFY(1) = C0(IEQ)
        XVERIFY(2) = C1(IEQ)
        XVERIFY(3) = C2(IEQ)
        XVERIFY(4) = C3(IEQ)
        CALL VERIFYVAL(4,XVERIFY)
        WRITE(*,162) IEQ,(XVERIFY(IXV),IXV=1,4)
	  CALL PAUSE
       END DO
  162   FORMAT(' EQ. ',I2,': ',4(G16.10,1X))
	CALL CHANGE(ICHANG)
	IF(ICHANG .EQ. 0) THEN
	WRITE(*,119)
  119 FORMAT(//' FOR EACH OUTPUT EQUATION, ENTER, IN ORDER, '/
     1' C0,C1,C2,C3, WHERE, FOR EACH OBSERVED VALUE, Y, THE ASSAY'/
     3' STANDARD DEVIATION IS SD = C0+C1*Y+C2*Y**2+C3*Y**3):')
	DO IEQ = 1,NUMEQT
	 WRITE(*,1119) IEQ
 1119    FORMAT(/' ENTER THE VALUES FOR [C0,C1,C2,C3] FOR OUTPUT'/
     1'  EQUATION ',I1,': ')
 4140    READ(*,*,ERR=4145) C0(IEQ),C1(IEQ),C2(IEQ),C3(IEQ)
   	 GO TO 2120
 4145    WRITE(*,4146)
 4146    FORMAT(/' SEE ABOVE; PLEASE ENTER FOUR REAL NUMBERS: ')
	 GO TO 4140
 2120	 CONTINUE
	END DO
	ENDIF
 2020	WRITE(*,2219)
 2219 FORMAT(//' THE DOSE TIMES, THE DOSE AMOUNTS (INCLUDING ALL IV'/
     1' RATES AND BOLUS VALUES), AND THE OBSERVATION TIMES WHICH THE'/
     2' PROGRAM HAS READ FROM THE WORKING COPY PATIENT DATA FILE '/
     3' ABOVE WILL ALL BE ASSUMED TO BE "NOISY" VALUES.'//
     5' ENTER 0 FOR AN EXPLANATION OF HOW THE "NOISY" VALUES ARE OBTAINE
     1D.'/
     6' ENTER 1 TO CONTINUE: ')
	READ(*,*,ERR= 2020) ICONT
	IF(ICONT .NE. 0 .AND. ICONT .NE. 1) GO TO 2020
	IF(ICONT .EQ. 0) CALL EXPLAINOISE
        XVERIFY(1) = C0DT
        XVERIFY(2) = C1DT
        XVERIFY(3) = C2DT
        XVERIFY(4) = C3DT
        CALL VERIFYVAL(4,XVERIFY)
        WRITE(*,2221) (XVERIFY(IXV),IXV=1,4)
 2221   FORMAT(/' FOR THE DOSE TIMES, THE Cs ARE ',4(G14.8,1X))
        XVERIFY(1) = C0DA
        XVERIFY(2) = C1DA
        XVERIFY(3) = C2DA
        XVERIFY(4) = C3DA
        CALL VERIFYVAL(4,XVERIFY)
        WRITE(*,2222) (XVERIFY(IXV),IXV=1,4)
 2222   FORMAT(/' FOR THE DOSE AMOUNTS, THE Cs ARE ',4(G14.8,1X))
        XVERIFY(1) = C0OT
        XVERIFY(2) = C1OT
        XVERIFY(3) = C2OT
        XVERIFY(4) = C3OT
        CALL VERIFYVAL(4,XVERIFY)
        WRITE(*,2223) (XVERIFY(IXV),IXV=1,4)
 2223   FORMAT(/' FOR THE OBS. TIMES, THE Cs ARE ',4(G14.8,1X))
	CALL CHANGE(ICHANG)
	IF(ICHANG .EQ. 0) THEN
	WRITE(*,6223)
 6223   FORMAT(/' ENTER C0,C1,C2,C3 FOR THE DOSE TIMES: ')
 6140   READ(*,*,ERR=6145) C0DT,C1DT,C2DT,C3DT
   	GO TO 6120
 6145   WRITE(*,4146)
	GO TO 6140
 6120	CONTINUE
	WRITE(*,7223)
 7223   FORMAT(/' ENTER C0,C1,C2,C3 FOR THE DOSE AMOUNTS: ')
 7140   READ(*,*,ERR=7145) C0DA,C1DA,C2DA,C3DA
   	GO TO 7120
 7145   WRITE(*,4146)
	GO TO 7140
 7120	CONTINUE
	WRITE(*,8223)
 8223   FORMAT(/' ENTER C0,C1,C2,C3 FOR THE OBSERVATION TIMES: ')
 8140   READ(*,*,ERR=8145) C0OT,C1OT,C2OT,C3OT
   	GO TO 8120
 8145   WRITE(*,4146)
	GO TO 8140
 8120	CONTINUE
	ENDIF
      IF(IDIST .EQ. 0) THEN
        WRITE(*,254) NGAUS
  254   FORMAT(/' THE OBSERVATIONS FOR EACH OF THE ',I3,' SUBJECT'/
     1' VECTORS WILL BE GENERATED BY ASSUMING EACH SUBJECT HAS EXACTLY'/
     2' THE PARAMETER VALUES OF ONE OF THE GRID PTS. IN THE FINAL'/
     3' CYCLE DENSITY FROM THE INPUT NPAG RUN. THESE GRID PTS. ARE: '/)
        CALL PAUSE
       DO IGAUS = 1,NGAUS
        WRITE(*,9004) IGAUS
 9004   FORMAT(//' GRID PT. NO: ',I3)
        DO I = 1,NVAR
         XVERIFY(I) = AMEAN(IGAUS,I)
        END DO
        CALL VERIFYVAL(NVAR,XVERIFY)
        WRITE(*,9007) (XVERIFY(I),I=1,NVAR)
 9007   FORMAT(/' PAR. VALUES: ',30G10.3)
       END DO
      ENDIF
	IF(IDIST .EQ. 1) WRITE(*,8003) NGAUS
 8003   FORMAT(/' THE SUBJECT VECTORS WILL BE GENERATED FROM A MIXTURE'/
     1' OF ',I3,' GAUSSIAN DISTRIBUTIONS. THE FOLLOWING DESCRIBES '/
     2' THESE DISTRIBUTIONS: ')
	IF(IDIST .EQ. 2) WRITE(*,9003) NGAUS
 9003   FORMAT(/' THE SUBJECT VECTORS WILL BE GENERATED FROM A MIXTURE'/
     1' OF ',I3,' LOGNORMAL DISTRIBUTIONS. THE FOLLOWING DESCRIBES '/
     2' THESE DISTRIBUTIONS: ')
      IF(IDIST .NE. 0) THEN
 4320	WRITE(*,4321)
 4321   FORMAT(/' ENTER 1 TO SEE INFO IN TERMS OF CORRELATIONS; '/
     1' ENTER 0 TO SEE INFO IN TERMS OF COVARIANCES: ')
	READ(*,*,ERR=4320) ICORR
	IF(ICORR .NE. 1 .AND. ICORR .NE. 0) GO TO 4320
	DO 8020 IGAUS=1,NGAUS
        WRITE(*,8004) IGAUS
 8004   FORMAT(//' DISTRIBUTION NO: ',I3)
        XVERIFY(1) = COF(IGAUS)
        CALL VERIFYVAL(1,XVERIFY)
        WRITE(*,8006) XVERIFY(1)
 8006   FORMAT(/' WEIGHTING COEFFICIENT: ',F10.3)
        IF(ICORR .EQ. 0) THEN
         DO I = 1,NVAR
          XVERIFY(I) = AMEAN(IGAUS,I)
         END DO
         CALL VERIFYVAL(NVAR,XVERIFY)
         WRITE(*,8007) (XVERIFY(I),I=1,NVAR)
 8007    FORMAT(/' MEAN VECTOR: ',30G10.3)
         WRITE(*,8008)
 8008    FORMAT(/' THE COVARIANCE MATRIX, IN LOWER-TRIANGULAR FORM IS:')
         DO I=1,NVAR
          WRITE(*,*) (COV(IGAUS,I,J),J=1,I)
         END DO
	  ENDIF
        IF(ICORR .EQ. 1) THEN
         DO I = 1,NVAR
         XVERIFY(1) = AMEAN(IGAUS,I)
         XVERIFY(2) = DSQRT(COV(IGAUS,I,I))
         CALL VERIFYVAL(2,XVERIFY)
         WRITE(*,4323) PAR(I),(XVERIFY(IXV),IXV=1,2)
 4323   FORMAT(/' THE MEAN AND STD. DEV. FOR ',A30,' ARE ',2(G10.3,2X)
     1)
         END DO
         WRITE(*,4324)
 4324    FORMAT(/' THE CORR. MATRIX IN LOWER-TRIANGULAR FORM IS: ')
	 DO I = 1,NVAR
	  DO J = 1,I
	   CORR(I,J)=COV(IGAUS,I,J)/DSQRT(COV(IGAUS,I,I)*COV(IGAUS,J,J))
	  END DO
	 END DO
	 DO I = 1,NVAR
	  WRITE(*,*) (CORR(I,J),J=1,I)
	 END DO
        ENDIF
	CALL PAUSE
 8020   CONTINUE
      ENDIF
      CALL CHANGE(ICHANG)
      IF(ICHANG .EQ. 0) THEN
        OUTNPAG(1:20) = '                    '
        TEXTFILE(1:20) = '                    '
       CALL GETDIST(IDIST,NGAUS,NVAR,COF,AMEAN,COV,PATH,NOB,OUTNPAG,
     1  TEXTFILE,OSname,ListDir)
      ENDIF
      IF(IDIST .EQ. 0) THEN
       DO I =1,NVAR
        ILIMIT(I) = 1
       END DO
      ENDIF
      IF(IDIST .NE. 0) THEN
      WRITE(*,143)
  143 FORMAT(/' THE ALLOWABLE BOUNDARIES FOR EACH R.V. ARE SHOWN'/
     1' BELOW. IF A SIMULATED R.V. IS OUTSIDE ITS ALLOWABLE'/
     2' BOUNDARIES, THE CORRESPONDING PARAMETER SET WILL NOT BE USED'/
     3' TO SIMULATE A SUBJECT, BUT WILL BE INCLUDED IN THE CALCULATION'/
     4' OF THE OVERALL SUMMARY STATISTICS IN THE OUTPUT FILE.'//)
       DO I = 1,NVAR
        IF(ILIMIT(I) .EQ. 1) WRITE(*,141) PAR(I)
  141   FORMAT(/1X,A11,' HAS NO RESTRICTIONS ON ITS SIMULATED VALUES')
        XVERIFY(1) = BOUND(I,1)
        XVERIFY(2) = BOUND(I,2)
        CALL VERIFYVAL(2,XVERIFY)
        IF(ILIMIT(I) .EQ. 0) WRITE(*,142) PAR(I),(XVERIFY(IXV),IXV=1,2)
  142   FORMAT(/1X,A11,' HAS BOUNDARIES: ',G19.9,'  TO  ',G19.9)
       END DO
	 CALL CHANGE(ICHANG)
       IF(ICHANG .EQ. 0) THEN
       DO I = 1,NVAR
  160   WRITE(*,146) PAR(I)
  146   FORMAT(//' FOR ',A11/
     1/' ENTER 1 IF THERE ARE TO BE NO RESTRICTIONS ON ITS SIMULATED VAL
     2UES;'/
     3' ENTER 0 IF THE SIMULATED VALUES ARE TO BE RESTRICTED: ')
        READ(*,*,ERR=160) ILIMIT(I)
        IF(ILIMIT(I) .NE. 1 .AND. ILIMIT(I) .NE. 0) GO TO 160
        IF(ILIMIT(I) .EQ. 0) THEN
  170    WRITE(*,144)
  144    FORMAT(/' ENTER THE DESIRED BOUNDARIES [L,U], WHERE L < U: ')
         READ(*,*,ERR=170) BOUND(I,1),BOUND(I,2)
         IF(BOUND(I,1) .GE. BOUND(I,2)) GO TO 170
        ENDIF
        END DO
       ENDIF
      ENDIF
	WRITE(*,8011) FILOUT
 8011   FORMAT(/' THE OUTPUT FILE, WHICH WILL CONTAIN ALL THE'/
     1' GENERATED DATA OF THE PROGRAM IS: ',A32)
	CALL CHANGE(ICHANG)
	IF(ICHANG .EQ. 0) THEN
      WRITE(*,1117)
 1117 FORMAT(/,' ENTER THE OUTPUT FILENAME WHICH WILL CONTAIN ALL THE'/
     1' GENERATED DATA OF THIS PROGRAM: ')
      READ(*,102) FILOUT
	ENDIF
        IF(IPRNPAT .EQ. 1 .OR. IPRNPAT .EQ. 3)
     1   WRITE(*,9013) NSUB,OUTCSVNAME
 9013   FORMAT(/' THE INFORMATION FROM THE ',I5,' SIMULATED PATIENT'/
     1' DATA FILES WILL BE SAVED IN BLOCK FORMAT TO '/
     2' FILE ',A32)
        IF(IPRNPAT .EQ. 2 .OR. IPRNPAT .EQ. 3)
     1   WRITE(*,8013) NSUB,PREFIX,EXT
 8013   FORMAT(/' THIS RUN WILL CREATE ',I5,' SIMULATED PATIENT DATA '/
     1' FILES, WITH PREFIX ',A3,' AND EXTENSION ',A3)
        IF(IPRNPAT .EQ. 0) WRITE(*,8014)
 8014   FORMAT(/' THE INFORMATION FROM THIS RUN WILL NOT BE SAVED IN'/
     1' BLOCK FORMAT TO A .CSV FILE, AND NO SIMULATED PATIENT DATA '/
     2' FILES WILL BE CREATED. THIS MEANS THAT YOU ARE ONLY INTERESTED'/
     3' IN THE INFORMATION WRITTEN TO THE OUTPUT FILE.')
        CALL CHANGE(ICHANG)
        IF(ICHANG .EQ. 0) THEN
 1230	  WRITE(*,1234) NSUB,NSUB
 1234   FORMAT(/' ENTER 1 IF YOU WOULD LIKE THE INFORMATION FROM '/
     1'         THE ',I5,' SIMULATED PATIENT DATA FILES TO BE SAVED'/
     2'         IN BLOCK FORMAT TO A .CSV FILE; '/
     3' ENTER 2 IF YOU WOULD LIKE TO CREATE THE ',I5,' SIMULATED '/
     4'         PATIENT DATA FILES IN WORKING COPY FORMAT; '/
     5' ENTER 3 IF YOU WOULD LIKE BOTH A .CSV FILE AND A SET OF '/
     6'         WORKING COPY FILES TO BE MADE;'/
     7' ENTER 0 IF YOU DO NOT NEED A .CSV FILE OR A SET OF WORKING '/
     8'         COPY FILES (I.E., YOU ONLY NEED THE INFO THAT IS '/
     9'         SUPPLIED IN THE OUTPUT FILE): ')
        READ(*,*,ERR=1230) IPRNPAT
        IF(IPRNPAT .LT. 0 .OR. IPRNPAT .GT. 3) GO TO 1230
        IF(IPRNPAT .EQ. 1 .OR. IPRNPAT .EQ. 3) THEN
 1390    WRITE(*,1236)
 1236    FORMAT(/' ENTER THE NAME OF THE FILE WHICH WILL STORE THE'/
     1' SIMULATED INFO IN .CSV FORMAT: ')
         READ(*,102) OUTCSVNAME
 1380	   TMPFILE = ' '
         TMPFILE = OUTCSVNAME
         CALL FULLNAME(PATH,TMPFILE,PATHFILE)
         OPEN(29,FILE=PATHFILE,ERR=1370,STATUS='NEW')
         GO TO 1375
 1370    WRITE(*,9826) PATHFILE
 9826    FORMAT(/' THE FOLLOWING FILE ALREADY EXISTS ....'/
     1'    ',A93/
     1' ENTER 0 TO ENTER A NEW FILENAME;'/
     2' ENTER 1 TO OVERWRITE THIS FILE: ')
         READ(*,*,ERR=1370) IFILE
         IF(IFILE .NE. 0 .AND. IFILE .NE. 1) GO TO 1370
         IF(IFILE .EQ. 0) GO TO 1390
         IF(IFILE .EQ. 1) OPEN(29,FILE=PATHFILE)
 1375    CLOSE(29)
        ENDIF
        IF(IPRNPAT .EQ. 2 .OR. IPRNPAT .EQ. 3) THEN
         WRITE(*,4041)
 4041    FORMAT(/' ENTER THE 3-CHAR PREFIX FOR THE SIMULATED PATIENT'/
     1' FILENAMES : ')
         READ(*,104) PREFIX
         WRITE(*,4043)
 4043	   FORMAT(/' IF THERE IS A 3-CHAR EXTENSION FOR THE PATIENT '/
     1' FILENAMES, ENTER IT NOW; OTHERWISE, PRESS ENTER: ')
         READ(*,103) EXT
        ENDIF
        ENDIF
	IF(ISEEDIND .EQ. 1) WRITE(*,1251)
 1251   FORMAT(/' THE STARTING SEED NO. FOR THE SIMULATOR WILL BE THE'/
     1' DEFAULT VALUE OF -17.')
	IF(ISEEDIND .EQ. 0) WRITE(*,1252)
 1252   FORMAT(/' THE STARTING SEED NO. FOR THE SIMULATOR WILL BE READ'/
     1' FROM THE FILE, "SEEDTO.MON", AND THIS FILE WILL THEN HAVE ITS '/
     2' SEED NO. DECREASED BY 123 FOR THE NEXT RUN.')
	CALL CHANGE(ICHANG)
	IF(ICHANG .EQ. 0) THEN
 1240	WRITE(*,1231)
 1231   FORMAT(/' ENTER 1 IF YOU WISH THE STARTING SEED NO. FOR THE'/
     1' 	SIMULATOR TO BE THE DEFAULT VALUE OF -17;'/
     2' ENTER 0 IF YOU WISH THE STARTING SEED NO. TO BE READ FROM'/
     3'		THE FILE, "SEEDTO.MON" (IN THIS CASE THIS FILE WILL'/
     4'		HAVE ITS SEED NO. DECREASED BY 123 FOR THE NEXT RUN): ')
	READ(*,*,ERR=1240) ISEEDIND
	IF(ISEEDIND .NE. 1 .AND. ISEEDIND .NE. 0) GO TO 1240
	ENDIF
 5005   WRITE(*,5001)
 5001   FORMAT(///' ENTER 1 IF ALL INSTRUCTIONS ARE NOW CORRECT;'/
     2' ENTER 0 OTHERWISE: ')
        READ(*,*,ERR=5005) ICHANG
	IF(ICHANG .NE. 0 .AND. ICHANG .NE. 1) GO TO 5005
	IF(ICHANG .EQ. 0) GO TO 8040
	RETURN
	END
	SUBROUTINE CHANGE(ICHANG)
   10   WRITE(*,1)
    1   FORMAT(//' ENTER 1 IF THE ABOVE INFORMATION IS CORRECT;'/
     1' ENTER 0 IF IT SHOULD BE CHANGED: ')
	READ(*,*,ERR=10) ICHANG
	IF(ICHANG .NE. 0 .AND. ICHANG .NE. 1) GO TO 10
	RETURN
	END
	SUBROUTINE OldSEEDIR(PATH,NOB,FILENAME)
	CHARACTER FILENAME*32,PATH*61,PRTDIR*47,TEMP*72,PRTDIR2*47
   10	PRTDIR = ' '
	WRITE(*,6)
    6   FORMAT(/' PRESS THE ENTER KEY TO SEE YOUR ENTIRE DIRECTORY;'//
     1' ENTER A PARTIAL FILENAME (WITH THE * WILDCARD) TO SEE A '/
     2'       PARTICULAR SUBSET OF FILENAMES IN YOUR DIRECTORY. '/
     3'       e.g., ENTER  "TO*.INS TO SEE A LIST OF ALL FILES WHICH'/
     4'       BEGIN WITH "TO" AND HAVE A .INS SUFFIX '//
     5' NOTE THAT THE FILES WILL AUTOMATICALLY BE TIME-ORDERED FROM '/
     6' OLDEST TO NEWEST.'//
     7' ENTER YOUR CHOICE NOW: ')
	READ(*,1) PRTDIR
    1   FORMAT(A47)
	IF(PRTDIR .EQ. ' ') TEMP = 'DIR/OD '//PATH(1:NOB)//' |MORE'
	IF(PRTDIR .NE. ' ') THEN
	 PRTDIR2 = ' '
	 J = 0
	 DO I=1,47
	  IF(PRTDIR(I:I) .NE. ' ') THEN
	   J = J+1
	   PRTDIR2(J:J) = PRTDIR(I:I)
	  ENDIF
	 END DO
	 TEMP = 'DIR/OD '//PATH(1:NOB)//PRTDIR2(1:J)//' |MORE'
	ENDIF
        CALL SYSTEM(TEMP)
     	WRITE(*,3)
    3   FORMAT(/' ENTER THE NAME OF THE DESIRED FILE (WITHOUT THE PATH);
     1'/
     2' ENTER -99 TO ENTER A DIFFERENT FILE SPECIFICATION: ')
	READ(*,2) FILENAME
    2   FORMAT(A32)
	IF(FILENAME(1:3) .EQ. '-99') GO TO 10
	RETURN
	END
        SUBROUTINE SEEDIR(PATH,NOB,FILENAME,OSName,ListDir)
        CHARACTER FILENAME*20,PATH*60,PRTDIR*47,TEMP*72,PRTDIR2*47,
     1  OSName*20,ListDir*10
   10   PRTDIR = ' '
        IF (INDEX(OSName,"UNIX",.TRUE.).eq.1) THEN
          WRITE(*,7)
        ELSE IF (INDEX(OSName,"DOS",.TRUE.).eq.1) THEN
          WRITE(*,6)
        END IF
    7   FORMAT(/' Press the ENTER key to call system(ls -t). '//
     1' Or type a partial filename (use the * wildcard) to call '/
     2'       system(ls -t arg_1), '/
     3'       e.g., type "to*.f ENTER" to see a list of all files '/
     4'       that begin with "to" and have a .f suffix. '//
     5' ENTER YOUR CHOICE NOW: ')
    6   FORMAT(/' PRESS THE ENTER KEY TO SEE YOUR ENTIRE DIRECTORY;'//
     1' ENTER A PARTIAL FILENAME (WITH THE * WILDCARD) TO SEE A '/
     2'       PARTICULAR SUBSET OF FILENAMES IN YOUR DIRECTORY. '/
     3'       e.g., ENTER  "TO*.INS TO SEE A LIST OF ALL FILES WHICH'/
     4'       BEGIN WITH "TO" AND HAVE A .INS SUFFIX '//
     5' NOTE THAT THE FILES WILL AUTOMATICALLY BE TIME-ORDERED FROM '/
     6' OLDEST TO NEWEST.'//
     7' ENTER YOUR CHOICE NOW: ')
        READ(*,1) PRTDIR
    1   FORMAT(A47)
        IF (INDEX(OSName,"UNIX",.TRUE.).eq.1) THEN
           IF(PRTDIR .EQ. ' ') THEN
             TEMP = ListDir//PATH(1:NOB)
           ENDIF
        ELSE IF (INDEX(OSName,"DOS",.TRUE.).eq.1) THEN
           IF(PRTDIR .EQ. ' ') THEN
             TEMP = ListDir//PATH(1:NOB)//' |MORE'
           ENDIF
        ENDIF
        IF(PRTDIR .NE. ' ') THEN
         PRTDIR2 = ' '
         J = 0
         DO I=1,47
          IF(PRTDIR(I:I) .NE. ' ') THEN
           J = J+1
           PRTDIR2(J:J) = PRTDIR(I:I)
          ENDIF
         END DO
         IF (INDEX(OSName,"UNIX",.TRUE.).eq.1) THEN
           TEMP = ListDir//PATH(1:NOB)//PRTDIR2(1:J)
         ELSE IF (INDEX(OSName,"DOS",.TRUE.).eq.1) THEN
           TEMP = ListDir//PATH(1:NOB)//PRTDIR2(1:J)//' |MORE'
         ENDIF
        ENDIF
        CALL SYSTEM(TEMP)
        WRITE(*,3)
    3   FORMAT(/' ENTER THE NAME OF THE DESIRED FILE (WITHOUT THE PATH);
     1'/
     2' ENTER -99 TO ENTER A DIFFERENT FILE SPECIFICATION,'/
     3' OR TO VIEW THE DIRECTORY LISTING AGAIN ')
        READ(*,2) FILENAME
    2   FORMAT(A20)
        IF(FILENAME(1:3) .EQ. '-99') GO TO 10
        RETURN
        END
	SUBROUTINE FULLNAME(PATH,FILE,FILE2)
	CHARACTER PATH*61,FILE2*93,FILE*32,FILE1*93
	FILE2 = ' '
	FILE1 = ' '
	FILE1 = PATH//FILE
	J = 0
        DO I=1,93
	 IF(FILE1(I:I) .NE. ' ') THEN
	  J= J+1
	  FILE2(J:J) = FILE1(I:I)
	 ENDIF
	END DO
	RETURN
	END
	SUBROUTINE GETPATH(PATH,NOB)
	CHARACTER PATH*61
   10	WRITE(*,1)
    1   FORMAT(/' ENTER 1 IF THE FILES FOR THIS RUN ARE IN THE CURRENT D
     1IRECTORY; '/
     1' ENTER 0 OTHERWISE: ')
	READ(*,*,ERR=10) IPATH
	IF(IPATH .NE. 0 .AND. IPATH .NE. 1) GO TO 10
	IF(IPATH .EQ. 1) PATH = ' '
	NOB = 0
	IF(IPATH .EQ. 0) THEN
	 WRITE(*,3)
    3    FORMAT(/' ENTER THE LOCATION (PATH) OF YOUR INPUT FILES. NOTE'/
     1' THAT THE PATH IS LIMITED TO 60 CHARACTERS AND THAT EACH SUB-DIRE
     2CTORY'/
     3' CAN HAVE AT MOST 8 CHARACTERS (E.G, INSTEAD OF " \DIRECTORY ", U
     4SE '/
     5' THE DOS-EQUIVALENT NAME, WHICH MIGHT BE " \DIRECT~1 "). '//
     6' ENTER THE PATH NOW: ')
	 READ(*,2) PATH
    2    FORMAT(A60)
	 DO I=1,60
	  J = 60 + 1 - I
	  IF(PATH(J:J) .NE. ' ') THEN
	   NOB = J
	   IF(PATH(J:J) .NE. '\') THEN
	    PATH(J+1:J+1) = '\'
	    NOB = J+1
	   ENDIF
	   RETURN
	  ENDIF
	 END DO
	ENDIF
	RETURN
	END
	SUBROUTINE USERPREP(NDIM,NP,NVAR,MAXDIM,PAR,NOFIX,
     1  PARFIX,IRAN,INOPT,ICODE,ILIMIT,BOUND)
        IMPLICIT REAL*8(A-H,O-Z)
	DIMENSION IRAN(32),BOUND(32,2),ILIMIT(32)
        CHARACTER PAR(30)*11,PARFIX(20)*11,READLINE*78,PSYM(32)*11,
     1  RR*1,TEMP*11,C*1,ERRFIL*20
      COMMON/ERROR/ERRFIL
    2   FORMAT(A78)
   30	BACKSPACE(28)
	BACKSPACE(28)
	READ(28,2) READLINE
	IF(READLINE(8:9) .NE. 'N=') GO TO 30
	BACKSPACE(28)
	READ(28,3) NDIM
    3   FORMAT(T10,I3)
   40	READ(28,2) READLINE
	IF(READLINE(8:9) .NE. 'NP') GO TO 40
	BACKSPACE(28)
	READ(28,4) NP
    4   FORMAT(T11,I3)
   50	READ(28,2) READLINE
	IF(READLINE(8:11) .NE. 'PSYM') GO TO 50
	BACKSPACE(28)
	DO 70 I=1,NP
	IF(I .LE. 9) READ(28,14) TEMP
	IF(I .GE. 10 .AND. I .LE. 99) READ(28,6) TEMP
	C = ''''
	PSYM(I) = TEMP
	DO J=1,11
	 IF(TEMP(J:J) .EQ. C) THEN
	  PSYM(I) = TEMP(1:J-1)
	  GO TO 70
	 ENDIF
	END DO
   70   CONTINUE
   14   FORMAT(T17,A11)
    6   FORMAT(T18,A11)
        IF(INOPT .EQ. 1) THEN
        IF(ICODE .GE. 7) READ(23,*)
	 READ(23,*) (IRAN(I),I=1,NP)
	 WRITE(*,201)
  201    FORMAT(/' YOU HAVE SELECTED YOUR PARAMETERS TO BE RANDOM'/
     1' OR FIXED AS INDICATED BELOW. IF YOU WANT TO CHANGE THIS, YOU'/
     2' WILL HAVE TO RERUN THIS PROGRAM WITHOUT AN INSTRUCTION FILE'/
     3' SINCE THE REST OF THIS INSTRUCTION FILE (BOUNDARIES AND/OR'/
     4' FIXED VALUES WILL NOT BE COMPATIBLE WITH YOUR CHANGED '/
     5' DESIGNATIONS.'/)
	 CALL PAUSE
	 NVAR = 0
	 NOFIX = 0
	 DO I = 1,NP
	  IF(IRAN(I) .EQ. 1) THEN
	   TEMP = 'RANDOM'
	   NVAR = NVAR+1
	   PAR(NVAR) = PSYM(I)
	  ENDIF
	  IF(IRAN(I) .EQ. 0) THEN
	   TEMP = 'FIXED'
	   NOFIX = NOFIX + 1
	   PARFIX(NOFIX) = PSYM(I)
	  ENDIF
	  WRITE(*,202) PSYM(I),TEMP
  202     FORMAT(2X,A11,2X,A11)
	 END DO
  210	 WRITE(*,203)
  203    FORMAT(/' ENTER 1 IF THE ABOVE DESIGNATIONS ARE CORRECT;'/
     1' ENTER 0 OTHERWISE: ')
	 READ(*,*,ERR=210) ICORRECT
	 IF(ICORRECT .NE. 1 .AND. ICORRECT .NE. 0) GO TO 210
	 IF(ICORRECT .EQ. 0) THEN
	  WRITE(*,204)
  204     FORMAT(//' PLEASE RERUN THE PROGRAM WITH KEYBOARD ENTRY.'/)
        OPEN(42,FILE=ERRFIL)
         WRITE(42,204)
        CLOSE(42)
        CALL PAUSE
	  STOP
	 ENDIF
  	IF(NVAR .GT. MAXDIM) THEN
	 WRITE(*,207) NVAR,MAXDIM
  207    FORMAT(//' SOMEHOW, YOUR INSTRUCTION FILE HAS ',I2,/
     1' PARAMETERS DESIGNATED TO BE RANDOM VARIABLES. THE LIMIT IS '/
     2' CURRENTLY ',I2,'. PLEASE USE A CURRENT INSTRUCTION FILE OR'/
     3' RERUN THE PROGRAM WITH KEYBOARD ENTRY.'//)
        OPEN(42,FILE=ERRFIL)
         WRITE(42,207) NVAR,MAXDIM
        CLOSE(42)
	 CALL PAUSE
	 STOP
	ENDIF
	IF(NOFIX .GT. 20) THEN
	 WRITE(*,208) NOFIX
  208    FORMAT(//' SOMEHOW, YOUR INSTRUCTION FILE HAS ',I2,/
     1' PARAMETERS DESIGNATED TO BE FIXED. THE LIMIT IS CURRENTLY 20.'/
     2' PLEASE USE A CURRENT INSTRUCTION FILE OR RERUN THE PROGRAM'/
     3' WITH KEYBOARD ENTRY.'//)
        OPEN(42,FILE=ERRFIL)
         WRITE(42,208) NOFIX
        CLOSE(42)
	 CALL PAUSE
	 STOP
	ENDIF
	IF(NVAR + NOFIX .GT. 32) THEN
	 WRITE(*,209) NVAR + NOFIX
  209    FORMAT(//' SOMEHOW, YOUR INSTRUCTION FILE HAS ',I2,' TOTAL'/
     1' PARAMETERS. THE LIMIT IS CURRENTLY 32. PLEASE USE A CURRENT '/
     2' INSTRUCTION FILE OR RERUN THE PROGRAM WITH KEYBOARD ENTRY.'//)
        OPEN(42,FILE=ERRFIL)
         WRITE(42,209) NVAR + NOFIX
        CLOSE(42)
	 CALL PAUSE
	 STOP
	ENDIF
      IF(ICODE .GE. 9) READ(23,*)
       NVAR = 0
       DO I = 1,NP
        IF(IRAN(I) .EQ. 1) THEN
         NVAR = NVAR+1
         IF(ICODE .LE. 8) ILIMIT(NVAR) = 1
         IF(ICODE .GE. 9) READ(23,*) ILIMIT(NVAR),BOUND(NVAR,1),
     1    BOUND(NVAR,2)
        ENDIF
       END DO
      ENDIF
	IF(INOPT .EQ. 0) THEN
   80	WRITE(*,7) NP
    7   FORMAT(/' FOR EACH OF THE ',I2,' PARAMETERS, '//
     1' ENTER "R" IF IT IS TO BE A RANDOM VARIABLE;'/
     2' ENTER "F" IF IT IS TO BE A FIXED PARAMETER.'//)
	NVAR = 0
	NOFIX = 0
	DO I=1,NP
   8     FORMAT(1X,A11,':  ')
   60	 WRITE(*,8) PSYM(I)
	 READ(*,9) RR
    9    FORMAT(A1)
	 IF(RR .NE. 'R' .AND. RR .NE. 'r' .AND. RR .NE. 'F'
     1      .AND. RR .NE. 'f') GO TO 60
	 IF(RR .EQ. 'R' .OR. RR .EQ. 'r') THEN
	  NVAR = NVAR+1
	  PAR(NVAR) = PSYM(I)
	  IRAN(I) = 1
  120 WRITE(*,119)
  119 FORMAT(/' ENTER 1 IF THE SIMULATED VALUES FOR THIS VARIABLE'/
     1'         WILL BE SOLELY DETERMINED BY THE PARAMETERS OF ITS'/
     2'         DISTRIBUTION (AS SPECIFIED BELOW);'/
     3' ENTER 0 IF THE SIMULATED VALUES FOR THIS VARIABLE WILL BE'/
     4'         DETERMINED BY THE PARAMETERS OF ITS DISTRIBUTION ...'/
     5'         SUBJECT TO THE ADDITIONAL CONTRAINT THAT THESE VALUES'/
     6'         BE WITHIN A SPECIFIED INTERVAL THAT YOU ENTER BELOW: '//
     7)
      READ(*,*,ERR=120) ILIMIT(NVAR)
      IF(ILIMIT(NVAR) .NE. 1 .AND. ILIMIT(NVAR) .NE. 0) GO TO 120
      IF(ILIMIT(NVAR) .EQ. 0) THEN
  130  WRITE(*,131)
  131  FORMAT(/' ENTER THE ALLOWABLE BOUNDS (LOWER,UPPER) FOR THE'/
     1' SIMULATED VALUES FOR THIS VARIABLE: ')
       READ(*,*,ERR=130) (BOUND(NVAR,J),J=1,2)
       IF(BOUND(NVAR,1) .GE. BOUND(NVAR,2)) THEN
        WRITE(*,132)
  132   FORMAT(/' THE LOWER BOUNDARY MUST BE < THE UPPER BOUNDARY.')
        GO TO 130
       ENDIF
      ENDIF
      ENDIF
	 IF(RR .EQ. 'F' .OR. RR .EQ. 'f') THEN
	  NOFIX = NOFIX+1
        PARFIX(NOFIX) = PSYM(I)
	  IRAN(I) = 0
	 ENDIF
	END DO
  	IF(NVAR .GT. MAXDIM) THEN
	 WRITE(*,111) NVAR,MAXDIM
  111    FORMAT(//' YOU HAVE SELECTED ',I2,' PARAMETERS TO BE RANDOM'/
     1' VARIABLES. THE LIMIT IS CURRENTLY ',I2,'. PLEASE RESELECT YOUR'/
     2' RANDOM VARIABLES WITH THIS LIMIT IN MIND.'//)
	 GO TO 80
	ENDIF
	IF(NOFIX .GT. 20) THEN
	 WRITE(*,112) NOFIX
  112    FORMAT(//' YOU HAVE SELECTED ',I2,' PARAMETERS TO BE FIXED'/
     1' PARAMETERS. THE LIMIT IS CURRENTLY 20. PLEASE RESELECT YOUR'/
     2' RANDOM VARIABLES WITH THIS LIMIT IN MIND.'//)
	 GO TO 80
	ENDIF
	IF(NVAR + NOFIX .GT. 32) THEN
	 WRITE(*,113) NVAR + NOFIX
  113    FORMAT(//' YOUR MODEL FILE HAS A TOTAL OF ',I2,' PARAMETERS.'/
     1' THE LIMIT IS CURRENTLY 32. PLEASE EDIT YOUR MODEL FILE SO '/
     2' THAT IT HAS .LE. 32 PARAMETERS. '//)
        OPEN(42,FILE=ERRFIL)
         WRITE(42,113) NVAR + NOFIX
        CLOSE(42)
	 CALL PAUSE
	 STOP
	ENDIF
	ENDIF
	RETURN
	END
        SUBROUTINE SIMBIG(PREFIX,EXT,FILEIN,NSUB,NVAR,NOFIX,IRAN,VALFIX,
     1   C0,C1,C2,C3,IDIST,NGAUS,COF,AMEAN,COV,PATH,NDIM,PAR,
     2   IPRNPAT,ISEEDIND,ICSVFILE,OUTCSVNAME,OSname,DeleteFile,Listdir,
     3   ILIMIT,BOUND)
        IMPLICIT REAL*8(A-H,O-Z)
	PARAMETER(MAXNUMEQ=7)
        DIMENSION TIM(594),SIG(5000),Y(594,MAXNUMEQ),RS(5000,34),
     1   BS(5000,7),AMEAN(150,30),COV(150,30,30),ALF(594),
     2   AS(594,MAXNUMEQ),AMEANC(594),
     2   COVC(594,594),VALALF(100000,30),SAMMEN(30),SAMCOV(30,30),
     3   COF(150),YPRED(594,MAXNUMEQ),IRAN(32),AS1(594),PX(32),
     4   C0(MAXNUMEQ),C1(MAXNUMEQ),C2(MAXNUMEQ),C3(MAXNUMEQ),
     5   YPREDSUB(10000,594,MAXNUMEQ),YMEAN(594,MAXNUMEQ),
     1   YMIN(594,MAXNUMEQ),YMAX(594,MAXNUMEQ),YSD(594,MAXNUMEQ),
     2   Y025(594,MAXNUMEQ),Y25(594,MAXNUMEQ),Y50(594,MAXNUMEQ),
     3   Y75(594,MAXNUMEQ),Y975(594,MAXNUMEQ),ASUB(10000,594,MAXNUMEQ),
     3   XPRED(594,20),XPREDSUB(10000,594,20),SAMCOR(30,30),
     4   TIMORIG(594),ILIMIT(32),BOUND(32,2),OVERALF(100000,30),
     5   VALFIX(20),XVERIFY(900)
	CHARACTER PREFIX*3,EXT*3,FILEIN*32,NUMBER(99999)*5,
     1   PATFIL*32,PATH*61,TMPFILE*32,PATHFILE*93,PATHFIL2*93,
     2   PATHFIL3*93,PAR(30)*11,CHARSUB*5,READBOT(99)*72,OUTCSVNAME*32,
     3   READBOTL*72,OSname*20,Deletefile*4,ListDir*10,ERRFIL*20
      COMMON/ERROR/ERRFIL
	COMMON/OBSER/ TIM,SIG,RS,Y,BS
	COMMON/SUM2/ M,NPNL
        COMMON/CNST2/ NPL,NOS,NDRUG,NADD
	COMMON/COMAMT/XPRED
	COMMON/BOTPART/NBOTLINE,READBOT
	DO JSUB = 1,NSUB
	 CALL GETCHAR(JSUB,CHARSUB)
	 NUMBER(JSUB) = CHARSUB
	END DO
	IDUM = -17
	IF(ISEEDIND .EQ. 0) THEN
        TMPFILE = ' '
	TMPFILE = 'SEEDTO.MON'
	CALL FULLNAME(PATH,TMPFILE,PATHFILE)
     	OPEN(25,FILE=PATHFILE,ERR=1200,STATUS='OLD')
	GO TO 1210
 1200   WRITE(*,1201)
 1201   FORMAT(/' PLEASE PUT THE SEED NO. FOR THE RANDOM NO. GENERATOR'/
     1' INTO THE TOP LINE OF THE FILE SEEDTO.MON, AND THEN RERUN THE '/
     2' PROGRAM.'//
     3' THE FILE, SEEDTO.MON, MUST BE IN THE SAME DIRECTORY AS THE'/
     4' WORKING DIRECTORY FOR THIS RUN. '//)
	WRITE(23,1201)
        OPEN(42,FILE=ERRFIL)
         WRITE(42,1201)
        CLOSE(42)
      CALL PAUSE
	STOP
 1210   READ(25,*) IDUM
	JDUM = IDUM - 123
	BACKSPACE(25)
	WRITE(25,*) JDUM
	CLOSE(25)
	ENDIF
     	WRITE(23,1202) IDUM
 1202   FORMAT(I9,' <-- SEED NO. FOR THE FOLLOWING SIMULATION. '/)
        IF(ICSVFILE .EQ. 0) TMPFILE = FILEIN
        IF(ICSVFILE .EQ. 1) TMPFILE = 'XQZPJ001.ZMQ'
	 CALL FULLNAME(PATH,TMPFILE,PATHFIL2)
        IF(IPRNPAT .EQ. 1) THEN
         PREFIX = '7Q9'
         EXT = 'Z3Q'
        ENDIF
        ITOTSETS = 0
        DO 9900 ISUB = 1,NSUB
	 IF(IPRNPAT .GE. 1) THEN
	  PATFIL=PREFIX//NUMBER(ISUB)//'.'//EXT
	  TMPFILE = PATFIL
	  CALL FULLNAME(PATH,TMPFILE,PATHFIL3)
	 ENDIF
         CALL INOUT(ISUB,PATHFIL2,PATHFIL3,IPRNPAT,TIMORIG)
        IF(IDIST .EQ. 0) THEN
         DO I = 1,NVAR
          ALF(I) = AMEAN(ISUB,I)
         END DO
         GO TO 6510
        ENDIF
 9800   ZRAN=RAN1(IDUM)
        STRTIN=0.D0
        DO IGAUS = 1,NGAUS
         ENDIN = STRTIN + COF(IGAUS)
         IF(ZRAN .GE. STRTIN .AND. ZRAN .LE. ENDIN) THEN
          ICOMP=IGAUS
          GO TO 5060
         ENDIF
         STRTIN = ENDIN
        END DO
 5060    DO I=1,NVAR
          AMEANC(I) = AMEAN(ICOMP,I)
          DO J=1,I
  	   COVC(I,J) = COV(ICOMP,I,J)
	  END DO
	 END DO
	IF(IDIST .EQ. 2) THEN
	 DO I=1,NVAR
	  DO J=1,NVAR
	   COVC(I,J) = DLOG(COVC(I,J)/AMEANC(I)/AMEANC(J)+1.D0)
	  END DO
	 END DO
	 DO I=1,NVAR
	  AMEANC(I) = DLOG(AMEANC(I)) - COVC(I,I)/2.D0
	 END DO
	ENDIF
	 CALL GNRAT(NVAR,AMEANC,COVC,ALF,IDUM)
	 IF(IDIST .EQ. 2) THEN
	  DO I = 1,NVAR
	   ALF(I) = DEXP(ALF(I))
	  END DO
	 ENDIF
      IOK = 1
      DO I = 1,NVAR
       IF(ILIMIT(I) .EQ. 0) THEN
        IF(ALF(I) .LT. BOUND(I,1) .OR. ALF(I) .GT. BOUND(I,2)) IOK = 0
       ENDIF
      END DO
 6510  CONTINUE
      ITOTSETS = ITOTSETS + 1
      IF(ITOTSETS .GT. 100000) THEN
       WRITE(*,9801) NSUB
 9801  FORMAT(//' BECAUSE OF THE BOUNDARY RESTRICTIONS ON PARAMETER'/
     1' VALUES, THE DESIRED NO. OF SUBJECTS, ',I6,', COULD NOT BE '/
     2' SIMULATED BEFORE THE MAXIMUM NO. OF SIMULATED PARAMETER SETS,'/
     3' 100000, WAS REACHED.'//
     4' THE PROGRAM STOPS.'//
     5' PLEASE RERUN THE PROGRAM WITH LESS RESTRICTIVE BOUNDARIES.'//)
        OPEN(42,FILE=ERRFIL)
         WRITE(42,9801) NSUB
        CLOSE(42)
       CALL PAUSE
       STOP
      ENDIF
      DO I = 1,NVAR
       OVERALF(ITOTSETS,I)=ALF(I)
      END DO
      IF(IOK .EQ. 0) GO TO 9800
       DO I=1,NVAR
        VALALF(ISUB,I)=ALF(I)
       END DO
	 IF(IPRNPAT .GE. 1) WRITE(*,9009) ISUB
 9009    FORMAT(' SIMULATING SUBJECT NO. ',I7)
	 IF(IPRNPAT .EQ. 0) WRITE(*,9019) ISUB
 9019    FORMAT(' SUBJECT NO. ',I7)
	 DO J=1,NOS
	  CALL NOSGEN(M,1.D0,IDUM,AS1)
	   DO I=1,M
	    AS(I,J) = AS1(I)
	    ASUB(ISUB,I,J) = AS(I,J)
	   END DO
	 END DO
	OPEN(31,FILE=PATHFIL2,STATUS='OLD')
       OPEN(41)
       CALL NEWWORK1
       REWIND(41)
       CALL STOREOBSER
	 CALL MAKEVEC(NVAR,NOFIX,IRAN,ALF,VALFIX,PX)
	 CALL IDCALCY(NVAR+NOFIX,NDIM,PX,YPRED,IDUM)
	DO J=1,NOS
	 DO I=1,M
          STDIJ=C0(J) + C1(J)*YPRED(I,J) + C2(J)*YPRED(I,J)**2 +
     1          C3(J)*YPRED(I,J)**3
 	  YPRED(I,J)=YPRED(I,J)+AS(I,J)*STDIJ
	  IF(YPRED(I,J) .LE. 1.D-8) YPRED(I,J) = 1.D-8
	  IF(Y(I,J) .LE. -99.D0) YPRED(I,J) = -99.D0
	  YPREDSUB(ISUB,I,J) = YPRED(I,J)
	 END DO
	END DO
        NNN = NDIM
        IF(NDIM .EQ. -1) NNN = 3
         DO ICOMPART = 1,NNN
          DO I = 1,M
           XPP = XPRED(I,ICOMPART)
           IF(XPP .LE. 1.D-8) XPP = 1.D-8
           XPREDSUB(ISUB,I,ICOMPART) = XPP
          END DO
         END DO
	 IF(IPRNPAT .GE. 1) THEN
        DO I = 1,M
         XVERIFY(1) = TIMORIG(I)
         DO J = 1,NOS
          XVERIFY(1+J) = YPRED(I,J)
         END DO
         CALL VERIFYVAL(1+NOS,XVERIFY)
         WRITE(21,245) (XVERIFY(IXV),IXV=1,1+NOS)
        END DO
245       FORMAT(' ',F14.7,21(',',G14.7))
        DO I = 1,NBOTLINE
         READBOTL = READBOT(I)
         IF(READBOTL(1:18) .EQ. 'ASSAY COEFFICIENTS') GO TO 9105
         WRITE(21,303) READBOT(I)
        END DO
  303    FORMAT(A72)
 9105   CONTINUE
        READBOTL = 'ASSAY COEFFICIENTS FOLLOW, ONE SET FOR EACH OUTPUT E
     1QUATION:'
        WRITE(21,303) READBOTL
        DO IEQ = 1,NOS
         XVERIFY(1) = C0(IEQ)
         XVERIFY(2) = C1(IEQ)
         XVERIFY(3) = C2(IEQ)
         XVERIFY(4) = C3(IEQ)
         CALL VERIFYVAL(4,XVERIFY)
         WRITE(21,9106) (XVERIFY(IXV),IXV=1,4)
 9106    FORMAT(1X,4(G14.7,2X))
        END DO
	  CLOSE(21)
	 ENDIF
 9900   CONTINUE
        IF(IPRNPAT .EQ. 1 .OR. IPRNPAT .EQ. 3)
     1   CALL WORKTOCSV(NSUB,PATH,PREFIX,EXT,OUTCSVNAME)
        IF(IPRNPAT .EQ. 1) THEN
         DO ISUB=1,NSUB
          PATFIL=PREFIX//NUMBER(ISUB)//'.'//EXT
          TMPFILE = PATFIL
          CALL FULLNAME(PATH,TMPFILE,PATHFIL3)
          CALL SYSTEM(DeleteFile//PATHFIL3)
         END DO
        ENDIF
	NWRITE = NSUB
	IF(NSUB .GT. 10000) NWRITE = 10000
	IF(NSUB .GT. 10000) WRITE(23,6013)
 6013   FORMAT(//' THE FOLLOWING 10000 LINES HAVE THE SIMULATED '/
     1' PARAMETER VALUES FOR THE FIRST 10000 SUBJECTS ONLY.'//
     2' SIMILARLY, ALL THE BLOCKS BELOW WILL HAVE VALUES ONLY FOR'/
     3' THE FIRST 10000 SUBJECTS.')
	IF(NSUB .LE. 10000) WRITE(23,7013) NSUB
 7013   FORMAT(//' THE FOLLOWING ',I7,' LINES HAVE THE SIMULATED '/
     1' PARAMETER VALUES FOR ALL THE SUBJECTS.')
	WRITE(23,7006) (PAR(J),J=1,NVAR)
 7006   FORMAT(/' SUBJ.    ',30(A12,3X))
      DO ISUB = 1,NWRITE
       DO J=1,NVAR
        XVERIFY(J) = VALALF(ISUB,J)
       END DO
       CALL VERIFYVAL(NVAR,XVERIFY)
       WRITE(23,7007) ISUB, (XVERIFY(J),J=1,NVAR)
      END DO
 7007   FORMAT(I6,1X,200(G14.7,1X))
	WRITE(23,7014) NOS,M
 7014   FORMAT(//' THE FOLLOWING ',I2,' BLOCK(S) CONTAIN THE SIMULATED A
     1SSAY'/
     2' NOISE FOR EACH OUTPUT EQUATION. EACH BLOCK HAS THE NOISE FOR'/
     3' THE ',I4,' OBSERVED VALUES FOR EACH SUBJECT ON ONE LINE.'/)
	WRITE(23,7009)
 7009   FORMAT(/'        <---- OBSERVATION TIMES ... ')
       DO I=1,M
        XVERIFY(I) = TIMORIG(I)
       END DO
       CALL VERIFYVAL(M,XVERIFY)
       WRITE(23,7008) (XVERIFY(I),I=1,M)
 7008   FORMAT(/'SUBJ ',200(G14.7,1X))
      DO IOUTEQ = 1,NOS
       WRITE(23,7017) IOUTEQ
 7017  FORMAT(/' OUTPUT EQUATION NO. ',I2/)
       DO ISUB = 1,NWRITE
        DO I=1,M
         XVERIFY(I) = ASUB(ISUB,I,IOUTEQ)
        END DO
        CALL VERIFYVAL(M,XVERIFY)
        WRITE(23,7007) ISUB,(XVERIFY(I),I=1,M)
       END DO
      END DO
	WRITE(23,7016) NOS,M
 7016   FORMAT(//' THE FOLLOWING ',I2,' BLOCK(S) CONTAIN THE SIMULATED O
     1BSERVED'/
     2' VALUES FOR EACH OUTPUT EQUATION. EACH BLOCK HAS THE ',I4,' OBSER
     3VED VALUES'/
     4' FOR EACH SUBJECT ON ONE LINE.'/)
       DO I=1,M
        XVERIFY(I) = TIMORIG(I)
       END DO
       CALL VERIFYVAL(M,XVERIFY)
       WRITE(23,7009)
       WRITE(23,7008) (XVERIFY(I),I=1,M)
      DO IOUTEQ = 1,NOS
       WRITE(23,7017) IOUTEQ
       DO ISUB = 1,NWRITE
        DO I=1,M
         XVERIFY(I) = YPREDSUB(ISUB,I,IOUTEQ)
        END DO
        CALL VERIFYVAL(M,XVERIFY)
        WRITE(23,7007) ISUB,(XVERIFY(I),I=1,M)
       END DO
      END DO
        NNN = NDIM
        IF(NDIM .EQ. -1) NNN = 3
	WRITE(23,7021) NNN,M
 7021   FORMAT(//' THE FOLLOWING ',I2,' BLOCK(S) CONTAIN THE SIMULATED'/
     1' AMOUNTS FOR EACH COMPARTMENT. EACH BLOCK SHOWS THE ',I4,' AMOUNT
     2S '/
     2' FOR EACH SUBJECT ON ONE LINE. '/)
       DO I=1,M
        XVERIFY(I) = TIMORIG(I)
       END DO
       CALL VERIFYVAL(M,XVERIFY)
       WRITE(23,7009)
       WRITE(23,7008) (XVERIFY(I),I=1,M)
      DO IDIM = 1,NNN
       WRITE(23,7022) IDIM
 7022  FORMAT(/' COMPARTMENT NO. ',I2/)
       DO ISUB = 1,NWRITE
        DO I=1,M
         XVERIFY(I) = XPREDSUB(ISUB,I,IDIM)
        END DO
        CALL VERIFYVAL(M,XVERIFY)
        WRITE(23,7007) ISUB,(XVERIFY(I),I=1,M)
       END DO
      END DO
	WRITE(23,7019)
 7019   FORMAT(//'******************************************************
     1**********'//
     2' SUMMARY STATISTICS FOLLOW ...'/)
      IF(ITOTSETS .GT. NSUB) THEN
       WRITE(23,9802) ITOTSETS,NSUB,ITOTSETS
 9802  FORMAT(//' BECAUSE OF PARAMETER BOUNDARY RESTRICTIONS, IT TOOK'/
     1I9,' PARAMETER SETS TO OBTAIN THE ',I8,' WHICH WERE ACCEPTABLE'/
     2' FOR THE SUBJECT SIMULATIONS.'//
     3' THE SAMPLE MEANS, COV. MATRIX, AND CORR. MATRIX FOR THE '/
     4' ENTIRE ',I9,' PARAMETER SETS WERE AS FOLLOWS: ')
	CALL STATT(ITOTSETS,NVAR,OVERALF,SAMMEN,SAMCOV)
        DO I = 1,NVAR
         XVERIFY(I) = SAMMEN(I)
        END DO
        CALL VERIFYVAL(NVAR,XVERIFY)
        WRITE(23,9804) (XVERIFY(I),I=1,NVAR)
 9804   FORMAT(//' SAMPLE MEANS OF ALL PARAMETER DATA ARE:'/
     1  30(F12.4,1X))
        WRITE(23,9806)
 9806   FORMAT(//' SAMPLE COV. MATRIX OF ALL PARAMETER DATA IS:')
        DO I=1,NVAR
         DO J = 1,I
          XVERIFY(J) = SAMCOV(I,J)
         END DO
         CALL VERIFYVAL(I,XVERIFY)
         WRITE(23,9012) I,(XVERIFY(J),J=1,I)
        END DO
 9012   FORMAT(' ROW ',I2,1X,200(G14.7,1X))
        DO I = 1,NVAR
         DO J = 1,I
          SAMCOR(I,J)=SAMCOV(I,J)/DSQRT(SAMCOV(I,I)*SAMCOV(J,J))
         END DO
        END DO
        WRITE(23,9807)
 9807   FORMAT(//' SAMPLE CORR. MATRIX OF ALL PARAMETER DATA IS:')
        DO I=1,NVAR
         DO J = 1,I
          XVERIFY(J) = SAMCOR(I,J)
         END DO
         CALL VERIFYVAL(I,XVERIFY)
         WRITE(23,9012) I,(XVERIFY(J),J=1,I)
        END DO
       WRITE(23,9803) NSUB
 9803  FORMAT(//' CORRESPONDING VALUES FOR THE ',I8,' PARAMETER SETS'/
     1' WHICH WERE ACTUALLY USED TO SIMULATE SUBJECTS WERE ...')
      ENDIF
      IF(ITOTSETS .EQ. NSUB) WRITE(23,9808) NSUB
 9808 FORMAT(//' ALL SIMULATED PARAMETER SETS WERE USED TO SIMULATE'/
     1' THE ',I8,' SUBJECTS; I.E., NONE WAS THROWN OUT BECAUSE OF '/
     2' PARAMETER BOUNDARY RESTRICTIONS. SO THE FOLLOWING SAMPLE'/
     3' MEANS, COV. MATRIX AND CORR. MATRIX ARE FOR ALL PARAMETER'/
     4' SETS.')
	CALL STATT(NSUB,NVAR,VALALF,SAMMEN,SAMCOV)
        DO I = 1,NVAR
         XVERIFY(I) = SAMMEN(I)
        END DO
        CALL VERIFYVAL(NVAR,XVERIFY)
        WRITE(23,9876) (XVERIFY(I),I=1,NVAR)
 9876   FORMAT(/' SAMPLE MEANS OF PARAMETERS USED TO SIMULATE SUBJECTS:
     1 '/
     2  30(F12.4,1X))
        WRITE(23,9878)
 9878   FORMAT(//' SAMPLE COV. MATRIX OF PARAMETERS USED TO SIMULATE SUB
     1JECTS: '/)
        DO I=1,NVAR
         DO J = 1,I
          XVERIFY(J) = SAMCOV(I,J)
         END DO
         CALL VERIFYVAL(I,XVERIFY)
         WRITE(23,9012) I,(XVERIFY(J),J=1,I)
        END DO
	 DO I = 1,NVAR
	  DO J = 1,I
	   SAMCOR(I,J)=SAMCOV(I,J)/DSQRT(SAMCOV(I,I)*SAMCOV(J,J))
	  END DO
	 END DO
        WRITE(23,9877)
 9877   FORMAT(//' SAMPLE CORR. MATRIX OF PARAMETERS USED TO SIMULATE SU
     1BJECTS: '/)
        DO I=1,NVAR
         DO J = 1,I
          XVERIFY(J) = SAMCOR(I,J)
         END DO
         CALL VERIFYVAL(I,XVERIFY)
         WRITE(23,9012) I,(XVERIFY(J),J=1,I)
        END DO
	CALL STAT2(NSUB,M,NOS,YPREDSUB,YMEAN,YMIN,YMAX,YSD,Y025,
     1   Y25,Y50,Y75,Y975)
	WRITE(23,9971) NOS,M,NSUB
 9971   FORMAT(//' THE STATISTICS FOR EACH OF THE ',I2,' OUTPUT '/
     1' EQUATION(S) AND ',I4,' OBSERVATION TIMES FOLLOW: '//
     2' FOR EACH OUTPUT EQUATION AND OBSERVATION, THE 9 VALUES '/
     3' REPRESENT, IN ORDER, THE MEAN, MINIMUM, MAXIMUM, STD. DEV.,'/
     4' 2.5%-TILE, 25%-TILE, 50%-TILE (MEDIAN), 75%-TILE, AND 97.5%-TILE
     5'/
     6' ... OVER ALL ',I7,' SUBJECTS.'/)
      DO IN = 1,NOS
	 WRITE(23,9972) IN
 9972    FORMAT(/' OUTPUT EQUATION ',I1,':')
       DO IM = 1,M
        WRITE(23,9973) IM
 9973   FORMAT(/' FOR OBSERVATION ',I4,':')
        XVERIFY(1) = YMEAN(IM,IN)
        XVERIFY(2) = YMIN(IM,IN)
        XVERIFY(3) = YMAX(IM,IN)
        XVERIFY(4) = YSD(IM,IN)
        XVERIFY(5) = Y025(IM,IN)
        XVERIFY(6) = Y25(IM,IN)
        XVERIFY(7) = Y50(IM,IN)
        XVERIFY(8) = Y75(IM,IN)
        XVERIFY(9) = Y975(IM,IN)
        CALL VERIFYVAL(9,XVERIFY)
        WRITE(23,9974) (XVERIFY(IXV),IXV=1,9)
 9974   FORMAT(9(1X,F10.3))
	 END DO
	END DO
	CLOSE(23)
	RETURN
	END
	SUBROUTINE INOUT(ISUB,PATHFIL2,PATHFIL3,IPRNPAT,TIMORIG)
	IMPLICIT REAL*8(A-H,O-Z)
	PARAMETER(MAXNUMEQ=7)
	CHARACTER SEX*1,READLINE*300,PATHFIL2*93,PATHFIL3*93,
     1   READLIN2*72,READBOT(99)*72,ERRFIL*20,CHARSUB*5
      COMMON/ERROR/ERRFIL
      DIMENSION TIM(594),SIG(5000),RS(5000,34),YO(594,MAXNUMEQ),
     1 BS(5000,7),TIMORIG(594)
	COMMON/OBSER/ TIM,SIG,RS,YO,BS
	COMMON/CNST/ N,ND,NI,NUP,NUIC,NP
	COMMON/CNST2/ NPL,NUMEQT,NDRUG,NADD
	COMMON/SUM2/ M,NPNL
	COMMON/DESCR/AGE,HEIGHT,ISEX,IETHFLG
	COMMON/BOTPART/NBOTLINE,READBOT
      OPEN(21,FILE=PATHFIL2,STATUS='OLD')
	DO I=1,7
	 READ(21,*)
	END DO
	READ(21,*) AGE
	READ(21,2) SEX
    2   FORMAT(A1)
	ISEX=1
	IF(SEX .EQ. 'F') ISEX=2
	READ(21,*) HEIGHT
	READ(21,*) IETHFLG
    1   FORMAT(A300)
   10	READ(21,1) READLINE
	IF(READLINE(12:23) .NE. 'NO. OF DRUGS') GO TO 10
	BACKSPACE(21)
    3   FORMAT(T2,I5)
        READ(21,3) NDRUG
	IF(NDRUG .GT. 7) THEN
	 WRITE(*,124)
  124    FORMAT(' YOUR PATIENT DATA FILES CANNOT HAVE MORE THAN 7'/
     1' DRUGS. THE PROGRAM IS NOW STOPPING. '/)
        OPEN(42,FILE=ERRFIL)
         WRITE(42,124)
        CLOSE(42)
       CALL PAUSE
	 STOP
	ENDIF
        READ(21,3) NADD
	NI = 2*NDRUG + NADD
	IF(NI .GT. 34) THEN
  	 WRITE(*,123)
  123    FORMAT(/' YOUR PATIENT DATA FILES HAVE TOO MANY COLUMNS IN '/
     1' THE DOSAGE REGIMEN BLOCK. THE NO. OF ADDITIONAL COVARIATES '/
     2' PLUS TWICE THE NO. OF DRUGS CANNOT EXCEED 34. THE PROGRAM IS'/
     3' NOW STOPPING. '/)
        OPEN(42,FILE=ERRFIL)
         WRITE(42,123)
        CLOSE(42)
	 CALL PAUSE
	 STOP
	ENDIF
        READ(21,3) ND
	IF(ND .GT. 5000) THEN
	 WRITE(*,125)
  125  FORMAT(' YOUR PATIENT DATA FILES CANNOT HAVE MORE THAN 5000'/
     1' DOSE EVENTS. THE PROGRAM IS NOW STOPPING. '/)
        OPEN(42,FILE=ERRFIL)
         WRITE(42,125)
        CLOSE(42)
       CALL PAUSE
	 STOP
	ENDIF
	READ(21,*)
	READ(21,*)
        IF(ND.EQ.0) GO TO 40
	DO I = 1,ND
         READ(21,*) SIG(I),(RS(I,J),J=1,NI)
	END DO
        DO I=1,ND
         DO J=1,NDRUG
          BS(I,J) = RS(I,2*J)
	 END DO
	END DO
   40	READ(21,1) READLINE
	IF(READLINE(12:23) .NE. 'NO. OF TOTAL') GO TO 40
	BACKSPACE(21)
        READ(21,3) NUMEQT
        READ(21,3) M
	IF(M .GT. 594) THEN
	 WRITE(*,*) 'NO. OF OBSERVATIONS MUST BE .LE. 594'
	 WRITE(*,*) 'ONLY THE 1ST 594 OBSERVATION TIMES ARE USED.'
	 M=594
	ENDIF
	IF(NUMEQT .GT. MAXNUMEQ) THEN
  	 WRITE(*,127) NUMEQT,MAXNUMEQ
  127    FORMAT(/' YOUR PATIENT DATA FILE HAS ',I3,' OUTPUT EQ.'/
     1' COLUMNS, WHICH IS MORE THAN ',I3,', THE MAX. ALLOWABLE NO. '/
     2' THE PROGRAM IS NOW STOPPING. '/)
        OPEN(42,FILE=ERRFIL)
         WRITE(42,127) NUMEQT,MAXNUMEQ
        CLOSE(42)
       CALL PAUSE
	 STOP
	ENDIF
        DO I=1,M
         READ(21,*) TIM(I),(YO(I,J),J=1,NUMEQT)
         TIMORIG(I) = TIM(I)
        END DO
	NBOTLINE = 0
 1010	READ(21,22,IOSTAT=IEND) READLIN2
	IF(IEND .LT. 0) GO TO 1025
	NBOTLINE = NBOTLINE + 1
	READBOT(NBOTLINE) = READLIN2
	GO TO 1010
 1025	CLOSE(21)
 	IF(IPRNPAT .GE. 1) THEN
       OPEN(21,FILE=PATHFIL3)
       CALL GETCHAR(ISUB,CHARSUB)
   22 FORMAT(A72)
	READLIN2 = '  LAST AND FIRST NAMES ARE: YOWZA '//CHARSUB
	WRITE(21,22) READLIN2
	READLIN2 = ' CHART NUMBER IS: 1234'
	WRITE(21,22) READLIN2
	WRITE(21,*)
	READLIN2= ' WARD NO, PATIENT AGE (YEARS), SEX, HEIGHT (INCHES),'
	WRITE(21,22) READLIN2
	READLIN2 = ' ETHNICITY FLAG, AND ETHNICITY DESCRIPTION (IF ANY)
     1FOLLOW ON'
	WRITE(21,22) READLIN2
	READLIN2 = ' THE NEXT 6 LINES:'
	WRITE(21,22) READLIN2
	READLIN2 = '56'
	WRITE(21,22) READLIN2
	READLIN2 = ' 74.000000'
	WRITE(21,22) READLIN2
	READLIN2 = 'M'
	WRITE(21,22) READLIN2
	READLIN2 = ' 67.89'
	WRITE(21,22) READLIN2
	READLIN2 = '1'
	WRITE(21,22) READLIN2
	WRITE(21,*)
	WRITE(21,*)
	READLIN2 = ' DATE OF FIRST THERAPY IS    7  12  98'
	WRITE(21,22) READLIN2
	READLIN2 = 'CCR ML/MIN/    0.00 150.00'
	WRITE(21,22) READLIN2
	READLIN2 = 'HOURS    MG     MG/HR    MCG/ML KG       MG/DL    60
     1.00'
	WRITE(21,22) READLIN2
        WRITE(21,*)
	WRITE(21,1011) NDRUG
 1011   FORMAT(5X,I1,' ... NO. OF DRUGS')
	WRITE(21,1012) NADD
 1012   FORMAT(4X,I2,' ... NO. OF ADDITIONAL COVARIATES')
	WRITE(21,1013) ND
 1013   FORMAT(1X,I5,' ... NO. OF DOSE EVENTS')
	WRITE(21,1014)
 1014   FORMAT(/'    TIME, IV/PO FOR EACH DRUG; ADDITIONAL COVARIATES IF
     1 ANY')
	DO I = 1,ND
         WRITE(21,*) SIG(I),(RS(I,J),J=1,NI)
	END DO
	WRITE(21,*)
	WRITE(21,1016) NUMEQT
 1016   FORMAT(5X,I1,' ... NO. OF TOTAL OUTPUT EQUATIONS')
	WRITE(21,1017) M
 1017   FORMAT(2X,I4,' ... NO. OF OBSERVED VALUE TIMES')
	ENDIF
	RETURN
	END
	SUBROUTINE IDCALCY(NPP,NDIM,ESTML,YPRED,IDUM)
        IMPLICIT REAL*8(A-H,O-Z)
        PARAMETER(MAXNUMEQ=7)
        DIMENSION ESTML(32),YPRED(594,MAXNUMEQ),P(32)
        COMMON/CNST/ N,ND,NI,NUP,NUIC,NP
        COMMON/PARAMD/ P
	CALL SYMBOL
	N = NDIM
	NP = NPP
        DO I=1,NP
	  P(I) = ESTML(I)
	END DO
	CALL EVAL2(YPRED,IDUM)
        RETURN
	END
      SUBROUTINE FUNC2(M,F,IDUM)
      IMPLICIT REAL*8(A-H,O-Z)
	PARAMETER(MAXNUMEQ=7)
      COMMON/BOLUSCOMP/NBCOMP
      COMMON/OBSER/ TIM,SIG,RS,YO,BS
      COMMON/CNST/ N,ND,NI,NUP,NUIC,NP
      COMMON/INPUT/ R,B
      COMMON/PARAMD/ P
      COMMON/CNST2/ NPL,NOS,NDRUG,NADD
      COMMON/STATE/ X
      COMMON/COMAMT/XPRED
      COMMON/NOISE/ C0DT,C1DT,C2DT,C3DT,C0DA,C1DA,C2DA,C3DA,
     1   C0OT,C1OT,C2OT,C3OT
      CHARACTER ERRFIL*20
      COMMON/ERROR/ERRFIL
      DIMENSION X(20),P(32),TIM(594),SIG(5000),R(37),RS(5000,34),
     1 YT(MAXNUMEQ),YO(594,MAXNUMEQ),F(594,MAXNUMEQ),BS(5000,7),
     2Y(594,MAXNUMEQ),B(20),NBCOMP(7),TLAG(7),FA(7),XPRED(594,20),
     3AS1(594),SIGN(5000),TIMN(594),RSN(5000,34),BSN(5000,7),
     4XSTORE(100,20),XXPRED(20),XVERIFY(900)
	DO I = 1,ND
        IF(SIG(I) .LE. 0.D0) SIGN(I) = SIG(I)
         IF(SIG(I) .GT. 0) THEN
          DUR = SIG(I) - SIG(I-1)
          CALL NOSGEN(1,1.D0,IDUM,AS1)
          SI= C0DT + C1DT*DUR + C2DT*DUR**2.D0 + C3DT*DUR**3.D0
          DURNOISY = DUR + SI*AS1(1)
          IF(DURNOISY .LT. .5D0*DUR) DURNOISY = .5D0*DUR
          IF(DURNOISY .GT. 2.D0*DUR) DURNOISY = 2.D0*DUR
          SIGN(I) = SIGN(I-1) + DURNOISY
         ENDIF
	 CALL NOSGEN(2*NDRUG,1.D0,IDUM,AS1)
	  DO J = 1,2*NDRUG
	   SI = C0DA + C1DA*RS(I,J) + C2DA*RS(I,J)**2.D0 +
     1        C3DA*RS(I,J)**3.D0
	   RSN(I,J) = RS(I,J)
	   IF(RS(I,J) .GT. 0.D0) RSN(I,J) = RS(I,J) + SI*AS1(J)
       IF(RSN(I,J) .LT. 0.D0) THEN
        XVERIFY(1) = RSN(I,J)
        CALL VERIFYVAL(1,XVERIFY)
        WRITE(*,126) J,I,XVERIFY(1)
  126   FORMAT(/' THE NOISY VALUE OF DOSE NO. ',I5,' FOR DOSE'/
     1' TIME ',I5,' IS ',F12.4,' WHICH IS A NEGATIVE NUMBER.'//
     2' PLEASE RERUN THE PROGRAM AND SELECT SMALLER NOISE COEFFICIENTS'/
     3' FOR THE DOSAGE AMOUNTS.')
        WRITE(23,126) J,I,XVERIFY(1)
        OPEN(42,FILE=ERRFIL)
        WRITE(42,126) J,I,XVERIFY(1)
        CLOSE(42)
        CALL PAUSE
	  STOP
       ENDIF
	  END DO
	 DO J = 2*NDRUG+1,NI
	  RSN(I,J) = RS(I,J)
	 END DO
	END DO
	DO I = 1,M
	 IF(I .EQ. 1) THEN
	  CALL NOSGEN(1,1.D0,IDUM,AS1)
	  SI = C0OT + C1OT*TIM(I) + C2OT*TIM(I)**2.D0 + C3OT*TIM(I)**3.D0
	  TIMN(I) = TIM(I) + SI*AS1(1)
	 ENDIF
        IF(I .GT. 1) THEN
         CALL THESAME(TIM(I),0.D0,ISAME)
         IF(ISAME .EQ. 1) TIMN(I) = 0.D0
         IF(ISAME .EQ. 0) THEN
          DUR = TIM(I) - TIM(I-1)
          CALL NOSGEN(1,1.D0,IDUM,AS1)
          SI= C0OT + C1OT*DUR + C2OT*DUR**2.D0 + C3OT*DUR**3.D0
          DURNOISY = DUR + SI*AS1(1)
          IF(DURNOISY .LT. .5D0*DUR) DURNOISY = .5D0*DUR
          IF(DURNOISY .GT. 2.D0*DUR) DURNOISY = 2.D0*DUR
          TIMN(I) = TIMN(I-1) + DURNOISY
         ENDIF
        ENDIF
	END DO
      KNS=1
      KNT=1
        T=0.0D0
      ISKIPBOL = 0
      DO I = 1,NDRUG
       R(2*I-1) = 0.D0
      END DO
      DO I=1,NI
       R(I)=RSN(KNS,I)
      END DO
	 CALL GETFA(FA)
        IF(N .EQ. 0) GO TO 75
	 CALL GETIX(N,X)
   75	 CALL GETTLAG(TLAG)
        NTL = 0
	DO ID = 1,NDRUG
	 IF(TLAG(ID) .NE. 0) NTL = 1
	END DO
	IF(NTL .EQ. 1) THEN
	 NDO = ND
	 CALL SHIFT(TLAG,ND,SIGN,NDRUG,NADD,RSN)
	ENDIF
      DO I=1,ND
       DO J=1,NDRUG
        BSN(I,J)=RSN(I,2*J)
       END DO
      END DO
        IF(TIMN(KNT).GE.SIGN(KNS)) GO TO 12
        IF(TIMN(KNT).NE.0.0D0) GO TO 45
      CALL OUTPUT(0.D0,YT)
      DO 2000 I=1,NOS
2000    Y(KNT,I)=YT(I)
        KNT=KNT+1
        GO TO 45
12    IF(TIMN(KNT).GT.SIGN(KNS)) GO TO 13
	IF(TIMN(KNT).NE.0.0D0) GO TO 45
        CALL OUTPUT(0.D0,YT)
	DO 2005 I=1,NOS
2005    Y(KNT,I)=YT(I)
        IF(N .GT. 0) THEN
         DO ICOMPART = 1,N
          XPRED(KNT,ICOMPART) = X(ICOMPART)
         END DO
        ENDIF
        IF(N .EQ. -1) THEN
         DO ICOMPART = 1,3
          XPRED(KNT,ICOMPART) = X(ICOMPART)
         END DO
        ENDIF
       KNT=KNT+1
13      IF(SIGN(KNS) .GT. 0.0D0) GO TO 45
      ISTEADY = 0
      IF(SIGN(KNS) .LT. 0.D0) THEN
       ISTEADY = 1
       NSET = 1
       DOSEINT = -SIGN(KNS)
       SIGN(KNS) = 0
      ENDIF
      DO I=1,NI
       R(I)=RSN(KNS,I)
      END DO
	IF(NDRUG .EQ. 0) GO TO 81
	 CALL GETFA(FA)
        IF(N .EQ. 0) GO TO 120
        DO I=1,NDRUG
	 X(NBCOMP(I))=X(NBCOMP(I))+BSN(KNS,I)*FA(I)
	END DO
	GO TO 81
120     DO I=1,NDRUG
	 B(I)=BSN(KNS,I)*FA(I)
	END DO
81      KNS=KNS+1
45    IF(KNS.GT.ND) GO TO 15
	IF(TIMN(KNT) .EQ. 0.D0 .AND. KNT .GT. 1) THEN
      DO IKNS = KNS,ND
       IF(SIGN(IKNS) .LE. 0.D0) GO TO 110
      END DO
      XVERIFY(1) = SIGN(KNS)
      CALL VERIFYVAL(1,XVERIFY)
      WRITE(*,111) ND,KNS,XVERIFY(1)
      WRITE(25,111) ND,KNS,XVERIFY(1)
 111  FORMAT(//' THE CURRENT SUBJECT HAS AN OBSERVATION TIME RESET'/
     1' ROW WITHOUT AN ACCOMPANYING DOSE RESET ROW. THE PROGRAM NOW'/
     2' STOPS. '//
     3' REVIEW YOUR PATIENT FILES AND CORRECT THE ERROR.'//
     4' NOTE THAT THE ',I4,' DOSE TIMES (POSSIBLY ALTERED BY TIMELAGS'/
     5' ARE THE FOLLOWING (AND THERE IS NO TIME .LE. 0 AFTER TIME'/
     6' NO. ',I4,' WHICH HAS CORRESPONDING TIME ',F15.4,'):')
      OPEN(42,FILE=ERRFIL)
       WRITE(42,111) ND,KNS,XVERIFY(1)
      DO I = 1,ND
       WRITE(*,*) SIGN(I)
       WRITE(25,*) SIGN(I)
       WRITE(42,*) SIGN(I)
      END DO
        CLOSE(42)
      CALL PAUSE
      STOP
  110 KNS = IKNS
      DO I=1,NI
       R(I)=RSN(KNS,I)
      END DO
       CALL GETIX(N,X)
       T = 0.D0
      ISTEADY = 0
      IF(SIGN(KNS) .LT. 0.D0) THEN
       ISTEADY = 1
       NSET = 1
       DOSEINT = -SIGN(KNS)
       SIGN(KNS) = 0
      ENDIF
	ENDIF
      IF(TIMN(KNT).NE.SIGN(KNS)) GO TO 20
      ID=2
      TOUT=TIMN(KNT)
      KNT=KNT+1
      KNS=KNS+1
      IF(N .EQ. 0) GO TO 31
      GO TO 30
20    IF(TIMN(KNT) .GT. SIGN(KNS) .AND. SIGN(KNS) .GT. 0) GO TO 25
15    ID=0
      TOUT=TIMN(KNT)
      KNT=KNT+1
      IF(N .EQ. 0) GO TO 31
      GO TO 30
25    ID=1
      TOUT=SIGN(KNS)
      KNS=KNS+1
      IF(N .EQ. 0) GO TO 31
30      CONTINUE
32      IF(N .NE. -1) CALL USERANAL(X,T,TOUT)
        IF(N .EQ. -1) CALL ANAL3(X,T,TOUT)
      IF(ISTEADY .EQ. 1) THEN
       CALL THESAME(TOUT,DOSEINT*NSET,ISAME)
       IF(ISAME .EQ. 1) THEN
        NN = N
        IF(N .EQ. -1) NN = 3
        DO J = 1,NN
         XSTORE(NSET,J) = X(J)
        END DO
        IF(NSET .GE. 5) THEN
         CALL PREDLAST3(NN,NSET,XSTORE,XXPRED,ICONV)
         IF(ICONV .EQ. 1) THEN
          ISTEADY = 0
          DO J = 1,NN
           X(J) = XXPRED(J)
          END DO
          T = 100.D0*DOSEINT
          DO I = KNS,ND
           IF(SIGN(I) .GE. 100.D0*DOSEINT .OR. SIGN(I) .LE. 0.D0) THEN
            KNSNEW = I
            GO TO 100
           ENDIF
          END DO
          KNS = ND+1
          GO TO 200
  100     KNS = KNSNEW
  200     CONTINUE
          ISKIPBOL = 1
         ENDIF
        ENDIF
        NSET = NSET + 1
       ENDIF
      ENDIF
31      CONTINUE
        IF(ID.EQ.1) GO TO 35
        KNTM1=KNT-1
        CALL OUTPUT(TIMN(KNTM1),YT)
	DO 2010 I=1,NOS
2010    Y(KNTM1,I)=YT(I)
        IF(N .GT. 0) THEN
         DO ICOMPART = 1,N
          XPRED(KNTM1,ICOMPART) = X(ICOMPART)
         END DO
        ENDIF
        IF(N .EQ. -1) THEN
         DO ICOMPART = 1,3
          XPRED(KNTM1,ICOMPART) = X(ICOMPART)
         END DO
        ENDIF
55      IF(ID.EQ.0) GO TO 40
  35    CONTINUE
	IF(NI .EQ. 0) GO TO 83
        DO I=1,NI
	 R(I)=RSN(KNS-1,I)
	END DO
	 CALL GETFA(FA)
83      IF(NDRUG .EQ. 0 .OR. N .EQ. 0) GO TO 82
        IF(ISKIPBOL .EQ. 0) THEN
         DO I=1,NDRUG
          X(NBCOMP(I))=X(NBCOMP(I))+BSN(KNS-1,I)*FA(I)
         END DO
        ENDIF
      ISKIPBOL = 0
82      CONTINUE
40      IF(KNT .LE. M) GO TO 45
	DO J=1,NOS
         DO I=1,M
	  F(I,J) = Y(I,J)
	 END DO
	END DO
	IF(NTL .EQ. 1) THEN
	 ND = NDO
	ENDIF
      RETURN
      END
	SUBROUTINE EVAL2(Y,IDUM)
	IMPLICIT REAL*8(A-H,O-Z)
	PARAMETER(MAXNUMEQ=7)
      COMMON/SUM2/ M,NPNL
      COMMON/CNST2/ NPL,NOS,NDRUG,NADD
      DIMENSION Y(594,MAXNUMEQ)
	CALL FUNC2(M,Y,IDUM)
	RETURN
	END
        SUBROUTINE USERANAL(X,TIN,TOUT)
        IMPLICIT REAL*8(A-H,O-Z)
        DIMENSION X(20),ATOL(20),RWORK(1002),IWORK(50)
     1   ,RTOL(1),RPAR(256),IPAR(256) 
	EXTERNAL DIFFEQ,JACOB
	COMMON/TOUSER/NDIM,MF,RTOL,ATOL
	ITOL=2
	ITASK=1
	ISTATE=1
	IOPT=0
	LRW = 1002
	LIW = 50
      CALL DVODE(DIFFEQ,NDIM,X,TIN,TOUT,ITOL,RTOL,ATOL,ITASK,ISTATE,
     1            IOPT,RWORK,LRW,IWORK,LIW,JACOB,MF,RPAR,IPAR)
	TIN=TOUT
        RETURN
        END
	SUBROUTINE JACOB(NDIM, T, X, ML, MU, PD, NRPD, RPAR, IPAR)
	IMPLICIT REAL*8(A-H,O-Z)
        COMMON/PARAMD/ P
        COMMON/INPUT/ R,B
        DIMENSION X(NDIM),PD(NRPD,NDIM),P(32),R(37),B(20)
        RETURN
        END
	SUBROUTINE MAKEVEC(NVAR,NOFIX,IRAN,X,VALFIX,PX)
	IMPLICIT REAL*8(A-H,O-Z)
	DIMENSION IRAN(32),X(150),VALFIX(20),PX(32)
	NNNVAR=0
	NNNFIX=0
	DO I=1,NVAR+NOFIX
	IF(IRAN(I) .EQ. 1) THEN
	 NNNVAR=NNNVAR+1
	 PX(I) = X(NNNVAR)
	ENDIF
	IF(IRAN(I) .EQ. 0) THEN
	 NNNFIX=NNNFIX+1
	 PX(I) = VALFIX(NNNFIX)
	ENDIF
	END DO
	RETURN
	END
      SUBROUTINE SHIFT(TAU,ND,SIG,NDRUG,NADD,RS)
      IMPLICIT REAL*8(A-H,O-Z)
      DIMENSION SIG(5000),RS(5000,34),TAU(7),XIV(7,5000,2),
     1  BOL(7,5000,2),COV(20,5000,2),INDIV(7),INDBOL(7),INDCOV(20),
     2  TIMCAN(34)
      CHARACTER ERRFIL*20
      COMMON/ERROR/ERRFIL
	DO I = 1,NDRUG
	 XIV(I,1,1) = 1.D29
	 IND = 0
	 VALAST = -99.D0
	DO IDOSE = 1,ND
	  RR = RS(IDOSE,2*I-1)
	  IF(SIG(IDOSE) .LE. 0 .AND. IDOSE .GT. 1) THEN
	    IND = IND + 1
	    XIV(I,IND,1) = 1.D19
	    XIV(I,IND,2) = XIV(I,IND-1,2)
	    IND = IND + 1
	    XIV(I,IND,1) = SIG(IDOSE)
	    XIV(I,IND,2) = RR
	    XIV(I,IND+1,1) = 1.D29
	    VALAST = RR
	    GO TO 200
	  ENDIF
	  IF(RR .NE. VALAST) THEN
         IND = IND + 1
	   XIV(I,IND,1) = SIG(IDOSE)
	   XIV(I,IND,2) = RR
	   XIV(I,IND+1,1) = 1.D29
	   VALAST = RR
	  ENDIF
  200     CONTINUE
	 END DO
	END DO
        IF(NADD .GT. 0) THEN
	DO I = 1, NADD
	 COV(I,1,1) = 1.D29
	 IND = 0
	 VALAST = -99.D0
	 DO IDOSE = 1,ND
	  RR = RS(IDOSE,2*NDRUG+I)
	  IF(SIG(IDOSE) .LE. 0 .AND. IDOSE .GT. 1) THEN
	    IND = IND + 1
	    COV(I,IND,1) = 1.D19
	    COV(I,IND,2) = COV(I,IND-1,2)
	    IND = IND + 1
	    COV(I,IND,1) = SIG(IDOSE)
	    COV(I,IND,2) = RR
	    COV(I,IND+1,1) = 1.D29
	    VALAST = RR
	    GO TO 300
	  ENDIF
	  IF(RR .NE. VALAST) THEN
           IND = IND + 1
	   COV(I,IND,1) = SIG(IDOSE)
	   COV(I,IND,2) = RR
	   COV(I,IND+1,1) = 1.D29
	   VALAST = RR
	  ENDIF
  300     CONTINUE
	 END DO
	END DO
        ENDIF
	DO I = 1,NDRUG
	 BOL(I,1,1) = 1.D29
	 IND = 0
	 DO IDOSE = 1,ND
	  RR = RS(IDOSE,2*I)
	  IF(SIG(IDOSE) .LE. 0 .AND. IDOSE .GT. 1) THEN
	    IND = IND + 1
	    BOL(I,IND,1) = 1.D19
	    BOL(I,IND,2) = 0.D0
	    IND = IND + 1
      CALL THESAME(SIG(IDOSE),0.D0,ISAME1)
      CALL THESAME(TAU(I),0.D0,ISAME2)
      CALL THESAME(RR,0.D0,ISAME3)
      IF(ISAME1 .EQ. 1) BOL(I,IND,1) = TAU(I)
      IF(ISAME1 .EQ. 0) THEN
       BOL(I,IND,1) = SIG(IDOSE)
       IF(ISAME2 .EQ. 0 .AND. ISAME3 .EQ. 0) BOL(I,IND,1) = TAU(I)
      ENDIF
	    BOL(I,IND,2) = RR
	    BOL(I,IND+1,1) = 1.D29
	    VALAST = RR
	    GO TO 400
	  ENDIF
	  IF(RR .NE. 0.D0) THEN
           IND = IND + 1
         IF(SIG(IDOSE) .GE. 0.D0) BOL(I,IND,1) = SIG(IDOSE) + TAU(I)
         IF(SIG(IDOSE) .LT. 0.D0) BOL(I,IND,1) = TAU(I)
	   BOL(I,IND,2) = RR
	   BOL(I,IND+1,1) = 1.D29
	  ENDIF
  400     CONTINUE
	 END DO
	END DO
	NI = 2*NDRUG + NADD
	ND = 0
	DO I = 1,NDRUG
	 INDIV(I) = 1
	 INDBOL(I) = 1
	END DO
        IF(NADD .GT. 0) THEN
         DO I = 1,NADD
          INDCOV(I) = 1
         END DO
        ENDIF
        TIMNXT = -9999999.D0
  100   CONTINUE
        DO I = 1,NDRUG
	 IF(XIV(I,INDIV(I),1) .GT. TIMNXT) TIMCAN(I)=XIV(I,INDIV(I),1)
	 IF(XIV(I,INDIV(I),1) .EQ. TIMNXT) TIMCAN(I)=XIV(I,INDIV(I)+1,1)
	END DO
        DO I = 1,NDRUG
	 IF(BOL(I,INDBOL(I),1) .GT. TIMNXT) TIMCAN(NDRUG+I) =
     1    BOL(I,INDBOL(I),1)
	 IF(BOL(I,INDBOL(I),1) .EQ. TIMNXT) TIMCAN(NDRUG+I) =
     1    BOL(I,INDBOL(I)+1,1)
	END DO
        IF(NADD .GT. 0) THEN
         DO I = 1,NADD
          IF(COV(I,INDCOV(I),1) .GT. TIMNXT) TIMCAN(2*NDRUG+I) =
     1     COV(I,INDCOV(I),1)
          IF(COV(I,INDCOV(I),1) .EQ. TIMNXT) TIMCAN(2*NDRUG+I) =
     1     COV(I,INDCOV(I)+1,1)
         END DO
        ENDIF
	TIMNXT = TIMCAN(1)
	DO I = 2,NI
	 IF(TIMCAN(I) .LT. TIMNXT) TIMNXT = TIMCAN(I)
	END DO
	IF(TIMNXT .EQ. 1.D29) RETURN
	IF(TIMNXT .EQ. 1.D19) THEN
	 DO I = 1,NDRUG
	  INDIV(I) = INDIV(I) + 1
	  INDBOL(I) = INDBOL(I) + 1
	 END DO
        IF(NADD .GT. 0) THEN
         DO I = 1,NADD
          INDCOV(I) = INDCOV(I) + 1
         END DO
        ENDIF
	 TIMNXT = -9999999.D0
	 GO TO 100
	ENDIF
	ND = ND+1
	IF(ND .GT. 5000) THEN
   10	 WRITE(*,1) ND
    1   FORMAT(/' THE NUMBER OF DOSE EVENTS, AFTER TAKING INTO'/
     1' ACCOUNT DIFFERING TIMES DUE TO TIMELAGS IS ',I6,', MORE THAN'/
     2' THE ALLOWABLE MAXIMUM OF 5000. THE PROGRAM IS STOPPING. PLEASE'/
     3' RERUN WITH PATIENTS HAVING FEWER DOSE EVENTS, OR WITH FEWER'/
     4' TIMELAG VALUES SELECTED AS FIXED OR RANDOM PARAMETERS.'//)
        OPEN(42,FILE=ERRFIL)
         WRITE(42,1) ND
        CLOSE(42)
       CALL PAUSE
	 STOP
	ENDIF
	SIG(ND) = TIMNXT
        DO I = 1,NDRUG
	 IF(TIMNXT .LT. XIV(I,INDIV(I),1)) THEN
	  RS(ND,2*I-1) = RS(ND-1,2*I-1)
	 ENDIF
	 IF(TIMNXT .EQ. XIV(I,INDIV(I),1)) THEN
	  RS(ND,2*I-1) = XIV(I,INDIV(I),2)
	  INDIV(I) = INDIV(I) + 1
	 ENDIF
	 IF(TIMNXT .LT. BOL(I,INDBOL(I),1)) THEN
	  RS(ND,2*I) = 0.D0
	 ENDIF
	 IF(TIMNXT .EQ. BOL(I,INDBOL(I),1)) THEN
	  RS(ND,2*I) = BOL(I,INDBOL(I),2)
	  INDBOL(I) = INDBOL(I) + 1
	 ENDIF
	END DO
        IF(NADD .GT. 0) THEN
         DO I = 1,NADD
          IF(TIMNXT .LT. COV(I,INDCOV(I),1))
     1     RS(ND,2*NDRUG+I) = RS(ND-1,2*NDRUG+I)
          IF(TIMNXT .EQ. COV(I,INDCOV(I),1)) THEN
           RS(ND,2*NDRUG+I) = COV(I,INDCOV(I),2)
           INDCOV(I) = INDCOV(I) + 1
          ENDIF
         END DO
        ENDIF
	GO TO 100
	END
	SUBROUTINE GETCHAR(JSUB,CHARSUB)
	CHARACTER CHARSUB*5
	CHARACTER*1 A,B,C,D,E
	ILEFT = JSUB
	I5 = ILEFT/10000
	ILEFT = ILEFT - I5*10000
	I4 = ILEFT/1000
	ILEFT = ILEFT - I4*1000
	I3 = ILEFT/100
	ILEFT = ILEFT - I3*100
	I2 = ILEFT/10
 	ILEFT = ILEFT - I2*10
	I1 = ILEFT
	IF(I5 .EQ. 1) A='1'
	IF(I5 .EQ. 2) A='2'
	IF(I5 .EQ. 3) A='3'
	IF(I5 .EQ. 4) A='4'
	IF(I5 .EQ. 5) A='5'
	IF(I5 .EQ. 6) A='6'
	IF(I5 .EQ. 7) A='7'
	IF(I5 .EQ. 8) A='8'
	IF(I5 .EQ. 9) A='9'
	IF(I5 .EQ. 0) A='0'
	IF(I4 .EQ. 1) B='1'
	IF(I4 .EQ. 2) B='2'
	IF(I4 .EQ. 3) B='3'
	IF(I4 .EQ. 4) B='4'
	IF(I4 .EQ. 5) B='5'
	IF(I4 .EQ. 6) B='6'
	IF(I4 .EQ. 7) B='7'
	IF(I4 .EQ. 8) B='8'
	IF(I4 .EQ. 9) B='9'
	IF(I4 .EQ. 0) B='0'
	IF(I3 .EQ. 1) C='1'
	IF(I3 .EQ. 2) C='2'
	IF(I3 .EQ. 3) C='3'
	IF(I3 .EQ. 4) C='4'
	IF(I3 .EQ. 5) C='5'
	IF(I3 .EQ. 6) C='6'
	IF(I3 .EQ. 7) C='7'
	IF(I3 .EQ. 8) C='8'
	IF(I3 .EQ. 9) C='9'
	IF(I3 .EQ. 0) C='0'
	IF(I2 .EQ. 1) D='1'
	IF(I2 .EQ. 2) D='2'
	IF(I2 .EQ. 3) D='3'
	IF(I2 .EQ. 4) D='4'
	IF(I2 .EQ. 5) D='5'
	IF(I2 .EQ. 6) D='6'
	IF(I2 .EQ. 7) D='7'
	IF(I2 .EQ. 8) D='8'
	IF(I2 .EQ. 9) D='9'
	IF(I2 .EQ. 0) D='0'
	IF(I1 .EQ. 1) E='1'
	IF(I1 .EQ. 2) E='2'
	IF(I1 .EQ. 3) E='3'
	IF(I1 .EQ. 4) E='4'
	IF(I1 .EQ. 5) E='5'
	IF(I1 .EQ. 6) E='6'
	IF(I1 .EQ. 7) E='7'
	IF(I1 .EQ. 8) E='8'
	IF(I1 .EQ. 9) E='9'
	IF(I1 .EQ. 0) E='0'
	CHARSUB = A//B//C//D//E
	RETURN
	END
      SUBROUTINE DVODE (F, NEQ, Y, T, TOUT, ITOL, RTOL, ATOL, ITASK,
     1            ISTATE, IOPT, RWORK, LRW, IWORK, LIW, JAC, MF,
     2            RPAR, IPAR)
      EXTERNAL F, JAC
      DOUBLE PRECISION Y, T, TOUT, RTOL, ATOL, RWORK, RPAR
      INTEGER NEQ, ITOL, ITASK, ISTATE, IOPT, LRW, IWORK, LIW,
     1        MF, IPAR
      DIMENSION Y(*), RTOL(*), ATOL(*), RWORK(LRW), IWORK(LIW),
     1          RPAR(*), IPAR(*)
      DOUBLE PRECISION ACNRM, CCMXJ, CONP, CRATE, DRC, EL,
     1     ETA, ETAMAX, H, HMIN, HMXI, HNEW, HSCAL, PRL1,
     2     RC, RL1, TAU, TQ, TN, UROUND
      INTEGER ICF, INIT, IPUP, JCUR, JSTART, JSV, KFLAG, KUTH,
     1        L, LMAX, LYH, LEWT, LACOR, LSAVF, LWM, LIWM,
     2        LOCJS, MAXORD, METH, MITER, MSBJ, MXHNIL, MXSTEP,
     3        N, NEWH, NEWQ, NHNIL, NQ, NQNYH, NQWAIT, NSLJ,
     4        NSLP, NYH
      DOUBLE PRECISION HU
      INTEGER NCFN, NETF, NFE, NJE, NLU, NNI, NQU, NST
      EXTERNAL DVNLSD
      LOGICAL IHIT
      DOUBLE PRECISION ATOLI, BIG, EWTI, FOUR, H0, HMAX, HMX, HUN, ONE,
     1   PT2, RH, RTOLI, SIZE, TCRIT, TNEXT, TOLSF, TP, TWO, ZERO
      INTEGER I, IER, IFLAG, IMXER, JCO, KGO, LENIW, LENJ, LENP, LENRW,
     1   LENWM, LF0, MBAND, ML, MORD, MU, MXHNL0, MXSTP0, NITER, NSLAST
      CHARACTER*80 MSG
      DOUBLE PRECISION D1MACH, DVNORM
      DIMENSION MORD(2)
      SAVE MORD, MXHNL0, MXSTP0
      SAVE ZERO, ONE, TWO, FOUR, PT2, HUN
      COMMON /DVOD01/ ACNRM, CCMXJ, CONP, CRATE, DRC, EL(13),
     1                ETA, ETAMAX, H, HMIN, HMXI, HNEW, HSCAL, PRL1,
     2                RC, RL1, TAU(13), TQ(5), TN, UROUND,
     3                ICF, INIT, IPUP, JCUR, JSTART, JSV, KFLAG, KUTH,
     4                L, LMAX, LYH, LEWT, LACOR, LSAVF, LWM, LIWM,
     5                LOCJS, MAXORD, METH, MITER, MSBJ, MXHNIL, MXSTEP,
     6                N, NEWH, NEWQ, NHNIL, NQ, NQNYH, NQWAIT, NSLJ,
     7                NSLP, NYH
      COMMON /DVOD02/ HU, NCFN, NETF, NFE, NJE, NLU, NNI, NQU, NST
      DATA  MORD(1) /12/, MORD(2) /5/, MXSTP0 /500/, MXHNL0 /10/
      DATA ZERO /0.0D0/, ONE /1.0D0/, TWO /2.0D0/, FOUR /4.0D0/,
     1     PT2 /0.2D0/, HUN /100.0D0/
      IF (ISTATE .LT. 1 .OR. ISTATE .GT. 3) GO TO 601
      IF (ITASK .LT. 1 .OR. ITASK .GT. 5) GO TO 602
      IF (ISTATE .EQ. 1) GO TO 10
      IF (INIT .NE. 1) GO TO 603
      IF (ISTATE .EQ. 2) GO TO 200
      GO TO 20
 10   INIT = 0
      IF (TOUT .EQ. T) RETURN
 20   IF (NEQ .LE. 0) GO TO 604
      IF (ISTATE .EQ. 1) GO TO 25
      IF (NEQ .GT. N) GO TO 605
 25   N = NEQ
      IF (ITOL .LT. 1 .OR. ITOL .GT. 4) GO TO 606
      IF (IOPT .LT. 0 .OR. IOPT .GT. 1) GO TO 607
      JSV = SIGN(1,MF)
      MF = ABS(MF)
      METH = MF/10
      MITER = MF - 10*METH
      IF (METH .LT. 1 .OR. METH .GT. 2) GO TO 608
      IF (MITER .LT. 0 .OR. MITER .GT. 5) GO TO 608
      IF (MITER .LE. 3) GO TO 30
      ML = IWORK(1)
      MU = IWORK(2)
      IF (ML .LT. 0 .OR. ML .GE. N) GO TO 609
      IF (MU .LT. 0 .OR. MU .GE. N) GO TO 610
 30   CONTINUE
      IF (IOPT .EQ. 1) GO TO 40
      MAXORD = MORD(METH)
      MXSTEP = MXSTP0
      MXHNIL = MXHNL0
      IF (ISTATE .EQ. 1) H0 = ZERO
      HMXI = ZERO
      HMIN = ZERO
      GO TO 60
 40   MAXORD = IWORK(5)
      IF (MAXORD .LT. 0) GO TO 611
      IF (MAXORD .EQ. 0) MAXORD = 100
      MAXORD = MIN(MAXORD,MORD(METH))
      MXSTEP = IWORK(6)
      IF (MXSTEP .LT. 0) GO TO 612
      IF (MXSTEP .EQ. 0) MXSTEP = MXSTP0
      MXHNIL = IWORK(7)
      IF (MXHNIL .LT. 0) GO TO 613
      IF (MXHNIL .EQ. 0) MXHNIL = MXHNL0
      IF (ISTATE .NE. 1) GO TO 50
      H0 = RWORK(5)
      IF ((TOUT - T)*H0 .LT. ZERO) GO TO 614
 50   HMAX = RWORK(6)
      IF (HMAX .LT. ZERO) GO TO 615
      HMXI = ZERO
      IF (HMAX .GT. ZERO) HMXI = ONE/HMAX
      HMIN = RWORK(7)
      IF (HMIN .LT. ZERO) GO TO 616
 60   LYH = 21
      IF (ISTATE .EQ. 1) NYH = N
      LWM = LYH + (MAXORD + 1)*NYH
      JCO = MAX(0,JSV)
      IF (MITER .EQ. 0) LENWM = 0
      IF (MITER .EQ. 1 .OR. MITER .EQ. 2) THEN
        LENWM = 2 + (1 + JCO)*N*N
        LOCJS = N*N + 3
      ENDIF
      IF (MITER .EQ. 3) LENWM = 2 + N
      IF (MITER .EQ. 4 .OR. MITER .EQ. 5) THEN
        MBAND = ML + MU + 1
        LENP = (MBAND + ML)*N
        LENJ = MBAND*N
        LENWM = 2 + LENP + JCO*LENJ
        LOCJS = LENP + 3
        ENDIF
      LEWT = LWM + LENWM
      LSAVF = LEWT + N
      LACOR = LSAVF + N
      LENRW = LACOR + N - 1
      IWORK(17) = LENRW
      LIWM = 1
      LENIW = 30 + N
      IF (MITER .EQ. 0 .OR. MITER .EQ. 3) LENIW = 30
      IWORK(18) = LENIW
      IF (LENRW .GT. LRW) GO TO 617
      IF (LENIW .GT. LIW) GO TO 618
      RTOLI = RTOL(1)
      ATOLI = ATOL(1)
      DO 70 I = 1,N
        IF (ITOL .GE. 3) RTOLI = RTOL(I)
        IF (ITOL .EQ. 2 .OR. ITOL .EQ. 4) ATOLI = ATOL(I)
        IF (RTOLI .LT. ZERO) GO TO 619
        IF (ATOLI .LT. ZERO) GO TO 620
 70     CONTINUE
      IF (ISTATE .EQ. 1) GO TO 100
      JSTART = -1
      IF (NQ .LE. MAXORD) GO TO 90
      CALL DCOPY (N, RWORK(LWM), 1, RWORK(LSAVF), 1)
 90   IF (MITER .GT. 0) RWORK(LWM) = SQRT(UROUND)
 100  UROUND = D1MACH(4)
      TN = T
      IF (ITASK .NE. 4 .AND. ITASK .NE. 5) GO TO 110
      TCRIT = RWORK(1)
      IF ((TCRIT - TOUT)*(TOUT - T) .LT. ZERO) GO TO 625
      IF (H0 .NE. ZERO .AND. (T + H0 - TCRIT)*H0 .GT. ZERO)
     1   H0 = TCRIT - T
 110  JSTART = 0
      IF (MITER .GT. 0) RWORK(LWM) = SQRT(UROUND)
      CCMXJ = PT2
      MSBJ = 50
      NHNIL = 0
      NST = 0
      NJE = 0
      NNI = 0
      NCFN = 0
      NETF = 0
      NLU = 0
      NSLJ = 0
      NSLAST = 0
      HU = ZERO
      NQU = 0
      LF0 = LYH + NYH
      CALL F (N, T, Y, RWORK(LF0), RPAR, IPAR)
      NFE = 1
      CALL DCOPY (N, Y, 1, RWORK(LYH), 1)
      NQ = 1
      H = ONE
      CALL DEWSET (N, ITOL, RTOL, ATOL, RWORK(LYH), RWORK(LEWT))
      DO 120 I = 1,N
        IF (RWORK(I+LEWT-1) .LE. ZERO) GO TO 621
 120    RWORK(I+LEWT-1) = ONE/RWORK(I+LEWT-1)
      IF (H0 .NE. ZERO) GO TO 180
      CALL DVHIN (N, T, RWORK(LYH), RWORK(LF0), F, RPAR, IPAR, TOUT,
     1   UROUND, RWORK(LEWT), ITOL, ATOL, Y, RWORK(LACOR), H0,
     2   NITER, IER)
      NFE = NFE + NITER
      IF (IER .NE. 0) GO TO 622
 180  RH = ABS(H0)*HMXI
      IF (RH .GT. ONE) H0 = H0/RH
      H = H0
      CALL DSCAL (N, H0, RWORK(LF0), 1)
      GO TO 270
 200  NSLAST = NST
      KUTH = 0
      GO TO (210, 250, 220, 230, 240), ITASK
 210  IF ((TN - TOUT)*H .LT. ZERO) GO TO 250
      CALL DVINDY (TOUT, 0, RWORK(LYH), NYH, Y, IFLAG)
      IF (IFLAG .NE. 0) GO TO 627
      T = TOUT
      GO TO 420
 220  TP = TN - HU*(ONE + HUN*UROUND)
      IF ((TP - TOUT)*H .GT. ZERO) GO TO 623
      IF ((TN - TOUT)*H .LT. ZERO) GO TO 250
      GO TO 400
 230  TCRIT = RWORK(1)
      IF ((TN - TCRIT)*H .GT. ZERO) GO TO 624
      IF ((TCRIT - TOUT)*H .LT. ZERO) GO TO 625
      IF ((TN - TOUT)*H .LT. ZERO) GO TO 245
      CALL DVINDY (TOUT, 0, RWORK(LYH), NYH, Y, IFLAG)
      IF (IFLAG .NE. 0) GO TO 627
      T = TOUT
      GO TO 420
 240  TCRIT = RWORK(1)
      IF ((TN - TCRIT)*H .GT. ZERO) GO TO 624
 245  HMX = ABS(TN) + ABS(H)
      IHIT = ABS(TN - TCRIT) .LE. HUN*UROUND*HMX
      IF (IHIT) GO TO 400
      TNEXT = TN + HNEW*(ONE + FOUR*UROUND)
      IF ((TNEXT - TCRIT)*H .LE. ZERO) GO TO 250
      H = (TCRIT - TN)*(ONE - FOUR*UROUND)
      KUTH = 1
 250  CONTINUE
      IF ((NST-NSLAST) .GE. MXSTEP) GO TO 500
      CALL DEWSET (N, ITOL, RTOL, ATOL, RWORK(LYH), RWORK(LEWT))
      DO 260 I = 1,N
        IF (RWORK(I+LEWT-1) .LE. ZERO) GO TO 510
 260    RWORK(I+LEWT-1) = ONE/RWORK(I+LEWT-1)
 270  TOLSF = UROUND*DVNORM (N, RWORK(LYH), RWORK(LEWT))
      IF (TOLSF .LE. ONE) GO TO 280
      TOLSF = TOLSF*TWO
      IF (NST .EQ. 0) GO TO 626
      GO TO 520
 280  IF ((TN + H) .NE. TN) GO TO 290
      NHNIL = NHNIL + 1
      IF (NHNIL .GT. MXHNIL) GO TO 290
      MSG = 'DVODE--  Warning..internal T (=R1) and H (=R2) are'
      CALL XERRWD (MSG, 50, 101, 1, 0, 0, 0, 0, ZERO, ZERO)
      MSG='      such that in the machine, T + H = T on the next step  '
      CALL XERRWD (MSG, 60, 101, 1, 0, 0, 0, 0, ZERO, ZERO)
      MSG = '      (H = step size). solver will continue anyway'
      CALL XERRWD (MSG, 50, 101, 1, 0, 0, 0, 2, TN, H)
      IF (NHNIL .LT. MXHNIL) GO TO 290
      MSG = 'DVODE--  Above warning has been issued I1 times.  '
      CALL XERRWD (MSG, 50, 102, 1, 0, 0, 0, 0, ZERO, ZERO)
      MSG = '      it will not be issued again for this problem'
      CALL XERRWD (MSG, 50, 102, 1, 1, MXHNIL, 0, 0, ZERO, ZERO)
 290  CONTINUE
      CALL DVSTEP (Y, RWORK(LYH), NYH, RWORK(LYH), RWORK(LEWT),
     1   RWORK(LSAVF), Y, RWORK(LACOR), RWORK(LWM), IWORK(LIWM),
     2   F, JAC, F, DVNLSD, RPAR, IPAR)
      KGO = 1 - KFLAG
      GO TO (300, 530, 540), KGO
 300  INIT = 1
      KUTH = 0
      GO TO (310, 400, 330, 340, 350), ITASK
 310  IF ((TN - TOUT)*H .LT. ZERO) GO TO 250
      CALL DVINDY (TOUT, 0, RWORK(LYH), NYH, Y, IFLAG)
      T = TOUT
      GO TO 420
 330  IF ((TN - TOUT)*H .GE. ZERO) GO TO 400
      GO TO 250
 340  IF ((TN - TOUT)*H .LT. ZERO) GO TO 345
      CALL DVINDY (TOUT, 0, RWORK(LYH), NYH, Y, IFLAG)
      T = TOUT
      GO TO 420
 345  HMX = ABS(TN) + ABS(H)
      IHIT = ABS(TN - TCRIT) .LE. HUN*UROUND*HMX
      IF (IHIT) GO TO 400
      TNEXT = TN + HNEW*(ONE + FOUR*UROUND)
      IF ((TNEXT - TCRIT)*H .LE. ZERO) GO TO 250
      H = (TCRIT - TN)*(ONE - FOUR*UROUND)
      KUTH = 1
      GO TO 250
 350  HMX = ABS(TN) + ABS(H)
      IHIT = ABS(TN - TCRIT) .LE. HUN*UROUND*HMX
 400  CONTINUE
      CALL DCOPY (N, RWORK(LYH), 1, Y, 1)
      T = TN
      IF (ITASK .NE. 4 .AND. ITASK .NE. 5) GO TO 420
      IF (IHIT) T = TCRIT
 420  ISTATE = 2
      RWORK(11) = HU
      RWORK(12) = HNEW
      RWORK(13) = TN
      IWORK(11) = NST
      IWORK(12) = NFE
      IWORK(13) = NJE
      IWORK(14) = NQU
      IWORK(15) = NEWQ
      IWORK(19) = NLU
      IWORK(20) = NNI
      IWORK(21) = NCFN
      IWORK(22) = NETF
      RETURN
 500  MSG = 'DVODE--  At current T (=R1), MXSTEP (=I1) steps   '
      CALL XERRWD (MSG, 50, 201, 1, 0, 0, 0, 0, ZERO, ZERO)
      MSG = '      taken on this call before reaching TOUT     '
      CALL XERRWD (MSG, 50, 201, 1, 1, MXSTEP, 0, 1, TN, ZERO)
      ISTATE = -1
      GO TO 580
 510  EWTI = RWORK(LEWT+I-1)
      MSG = 'DVODE--  At T (=R1), EWT(I1) has become R2 .le. 0.'
      CALL XERRWD (MSG, 50, 202, 1, 1, I, 0, 2, TN, EWTI)
      ISTATE = -6
      GO TO 580
 520  MSG = 'DVODE--  At T (=R1), too much accuracy requested  '
      CALL XERRWD (MSG, 50, 203, 1, 0, 0, 0, 0, ZERO, ZERO)
      MSG = '      for precision of machine..  see TOLSF (=R2) '
      CALL XERRWD (MSG, 50, 203, 1, 0, 0, 0, 2, TN, TOLSF)
      RWORK(14) = TOLSF
      ISTATE = -2
      GO TO 580
 530  MSG = 'DVODE--  At T(=R1) and step size H(=R2), the error'
      CALL XERRWD (MSG, 50, 204, 1, 0, 0, 0, 0, ZERO, ZERO)
      MSG = '      test failed repeatedly or with abs(H) = HMIN'
      CALL XERRWD (MSG, 50, 204, 1, 0, 0, 0, 2, TN, H)
      ISTATE = -4
      GO TO 560
 540  MSG = 'DVODE--  At T (=R1) and step size H (=R2), the    '
      CALL XERRWD (MSG, 50, 205, 1, 0, 0, 0, 0, ZERO, ZERO)
      MSG = '      corrector convergence failed repeatedly     '
      CALL XERRWD (MSG, 50, 205, 1, 0, 0, 0, 0, ZERO, ZERO)
      MSG = '      or with abs(H) = HMIN   '
      CALL XERRWD (MSG, 30, 205, 1, 0, 0, 0, 2, TN, H)
      ISTATE = -5
 560  BIG = ZERO
      IMXER = 1
      DO 570 I = 1,N
        SIZE = ABS(RWORK(I+LACOR-1)*RWORK(I+LEWT-1))
        IF (BIG .GE. SIZE) GO TO 570
        BIG = SIZE
        IMXER = I
 570    CONTINUE
      IWORK(16) = IMXER
 580  CONTINUE
      CALL DCOPY (N, RWORK(LYH), 1, Y, 1)
      T = TN
      RWORK(11) = HU
      RWORK(12) = H
      RWORK(13) = TN
      IWORK(11) = NST
      IWORK(12) = NFE
      IWORK(13) = NJE
      IWORK(14) = NQU
      IWORK(15) = NQ
      IWORK(19) = NLU
      IWORK(20) = NNI
      IWORK(21) = NCFN
      IWORK(22) = NETF
      RETURN
 601  MSG = 'DVODE--  ISTATE (=I1) illegal '
      CALL XERRWD (MSG, 30, 1, 1, 1, ISTATE, 0, 0, ZERO, ZERO)
      IF (ISTATE .LT. 0) GO TO 800
      GO TO 700
 602  MSG = 'DVODE--  ITASK (=I1) illegal  '
      CALL XERRWD (MSG, 30, 2, 1, 1, ITASK, 0, 0, ZERO, ZERO)
      GO TO 700
 603  MSG='DVODE--  ISTATE (=I1) .gt. 1 but DVODE not initialized      '
      CALL XERRWD (MSG, 60, 3, 1, 1, ISTATE, 0, 0, ZERO, ZERO)
      GO TO 700
 604  MSG = 'DVODE--  NEQ (=I1) .lt. 1     '
      CALL XERRWD (MSG, 30, 4, 1, 1, NEQ, 0, 0, ZERO, ZERO)
      GO TO 700
 605  MSG = 'DVODE--  ISTATE = 3 and NEQ increased (I1 to I2)  '
      CALL XERRWD (MSG, 50, 5, 1, 2, N, NEQ, 0, ZERO, ZERO)
      GO TO 700
 606  MSG = 'DVODE--  ITOL (=I1) illegal   '
      CALL XERRWD (MSG, 30, 6, 1, 1, ITOL, 0, 0, ZERO, ZERO)
      GO TO 700
 607  MSG = 'DVODE--  IOPT (=I1) illegal   '
      CALL XERRWD (MSG, 30, 7, 1, 1, IOPT, 0, 0, ZERO, ZERO)
      GO TO 700
 608  MSG = 'DVODE--  MF (=I1) illegal     '
      CALL XERRWD (MSG, 30, 8, 1, 1, MF, 0, 0, ZERO, ZERO)
      GO TO 700
 609  MSG = 'DVODE--  ML (=I1) illegal.. .lt.0 or .ge.NEQ (=I2)'
      CALL XERRWD (MSG, 50, 9, 1, 2, ML, NEQ, 0, ZERO, ZERO)
      GO TO 700
 610  MSG = 'DVODE--  MU (=I1) illegal.. .lt.0 or .ge.NEQ (=I2)'
      CALL XERRWD (MSG, 50, 10, 1, 2, MU, NEQ, 0, ZERO, ZERO)
      GO TO 700
 611  MSG = 'DVODE--  MAXORD (=I1) .lt. 0  '
      CALL XERRWD (MSG, 30, 11, 1, 1, MAXORD, 0, 0, ZERO, ZERO)
      GO TO 700
 612  MSG = 'DVODE--  MXSTEP (=I1) .lt. 0  '
      CALL XERRWD (MSG, 30, 12, 1, 1, MXSTEP, 0, 0, ZERO, ZERO)
      GO TO 700
 613  MSG = 'DVODE--  MXHNIL (=I1) .lt. 0  '
      CALL XERRWD (MSG, 30, 13, 1, 1, MXHNIL, 0, 0, ZERO, ZERO)
      GO TO 700
 614  MSG = 'DVODE--  TOUT (=R1) behind T (=R2)      '
      CALL XERRWD (MSG, 40, 14, 1, 0, 0, 0, 2, TOUT, T)
      MSG = '      integration direction is given by H0 (=R1)  '
      CALL XERRWD (MSG, 50, 14, 1, 0, 0, 0, 1, H0, ZERO)
      GO TO 700
 615  MSG = 'DVODE--  HMAX (=R1) .lt. 0.0  '
      CALL XERRWD (MSG, 30, 15, 1, 0, 0, 0, 1, HMAX, ZERO)
      GO TO 700
 616  MSG = 'DVODE--  HMIN (=R1) .lt. 0.0  '
      CALL XERRWD (MSG, 30, 16, 1, 0, 0, 0, 1, HMIN, ZERO)
      GO TO 700
 617  CONTINUE
      MSG='DVODE--  RWORK length needed, LENRW (=I1), exceeds LRW (=I2)'
      CALL XERRWD (MSG, 60, 17, 1, 2, LENRW, LRW, 0, ZERO, ZERO)
      GO TO 700
 618  CONTINUE
      MSG='DVODE--  IWORK length needed, LENIW (=I1), exceeds LIW (=I2)'
      CALL XERRWD (MSG, 60, 18, 1, 2, LENIW, LIW, 0, ZERO, ZERO)
      GO TO 700
 619  MSG = 'DVODE--  RTOL(I1) is R1 .lt. 0.0        '
      CALL XERRWD (MSG, 40, 19, 1, 1, I, 0, 1, RTOLI, ZERO)
      GO TO 700
 620  MSG = 'DVODE--  ATOL(I1) is R1 .lt. 0.0        '
      CALL XERRWD (MSG, 40, 20, 1, 1, I, 0, 1, ATOLI, ZERO)
      GO TO 700
 621  EWTI = RWORK(LEWT+I-1)
      MSG = 'DVODE--  EWT(I1) is R1 .le. 0.0         '
      CALL XERRWD (MSG, 40, 21, 1, 1, I, 0, 1, EWTI, ZERO)
      GO TO 700
 622  CONTINUE
      MSG='DVODE--  TOUT (=R1) too close to T(=R2) to start integration'
      CALL XERRWD (MSG, 60, 22, 1, 0, 0, 0, 2, TOUT, T)
      GO TO 700
 623  CONTINUE
      MSG='DVODE--  ITASK = I1 and TOUT (=R1) behind TCUR - HU (= R2)  '
      CALL XERRWD (MSG, 60, 23, 1, 1, ITASK, 0, 2, TOUT, TP)
      GO TO 700
 624  CONTINUE
      MSG='DVODE--  ITASK = 4 or 5 and TCRIT (=R1) behind TCUR (=R2)   '
      CALL XERRWD (MSG, 60, 24, 1, 0, 0, 0, 2, TCRIT, TN)
      GO TO 700
 625  CONTINUE
      MSG='DVODE--  ITASK = 4 or 5 and TCRIT (=R1) behind TOUT (=R2)   '
      CALL XERRWD (MSG, 60, 25, 1, 0, 0, 0, 2, TCRIT, TOUT)
      GO TO 700
 626  MSG = 'DVODE--  At start of problem, too much accuracy   '
      CALL XERRWD (MSG, 50, 26, 1, 0, 0, 0, 0, ZERO, ZERO)
      MSG='      requested for precision of machine..  see TOLSF (=R1) '
      CALL XERRWD (MSG, 60, 26, 1, 0, 0, 0, 1, TOLSF, ZERO)
      RWORK(14) = TOLSF
      GO TO 700
 627  MSG='DVODE--  Trouble from DVINDY.  ITASK = I1, TOUT = R1.       '
      CALL XERRWD (MSG, 60, 27, 1, 1, ITASK, 0, 1, TOUT, ZERO)
 700  CONTINUE
      ISTATE = -3
      RETURN
 800  MSG = 'DVODE--  Run aborted.. apparent infinite loop     '
      CALL XERRWD (MSG, 50, 303, 2, 0, 0, 0, 0, ZERO, ZERO)
      RETURN
      END
      SUBROUTINE DVHIN (N, T0, Y0, YDOT, F, RPAR, IPAR, TOUT, UROUND,
     1   EWT, ITOL, ATOL, Y, TEMP, H0, NITER, IER)
      EXTERNAL F
      DOUBLE PRECISION T0, Y0, YDOT, RPAR, TOUT, UROUND, EWT, ATOL, Y,
     1   TEMP, H0
      INTEGER N, IPAR, ITOL, NITER, IER
      DIMENSION Y0(*), YDOT(*), EWT(*), ATOL(*), Y(*),
     1   TEMP(*), RPAR(*), IPAR(*)
      DOUBLE PRECISION AFI, ATOLI, DELYI, HALF, HG, HLB, HNEW, HRAT,
     1     HUB, HUN, PT1, T1, TDIST, TROUND, TWO, YDDNRM
      INTEGER I, ITER
      DOUBLE PRECISION DVNORM
      SAVE HALF, HUN, PT1, TWO
      DATA HALF /0.5D0/, HUN /100.0D0/, PT1 /0.1D0/, TWO /2.0D0/
      NITER = 0
      TDIST = ABS(TOUT - T0)
      TROUND = UROUND*MAX(ABS(T0),ABS(TOUT))
      IF (TDIST .LT. TWO*TROUND) GO TO 100
      HLB = HUN*TROUND
      HUB = PT1*TDIST
      ATOLI = ATOL(1)
      DO 10 I = 1, N
        IF (ITOL .EQ. 2 .OR. ITOL .EQ. 4) ATOLI = ATOL(I)
        DELYI = PT1*ABS(Y0(I)) + ATOLI
        AFI = ABS(YDOT(I))
        IF (AFI*HUB .GT. DELYI) HUB = DELYI/AFI
 10     CONTINUE
      ITER = 0
      HG = SQRT(HLB*HUB)
      IF (HUB .LT. HLB) THEN
        H0 = HG
        GO TO 90
      ENDIF
 50   CONTINUE
      T1 = T0 + HG
      DO 60 I = 1, N
 60     Y(I) = Y0(I) + HG*YDOT(I)
      CALL F (N, T1, Y, TEMP, RPAR, IPAR)
      DO 70 I = 1, N
 70     TEMP(I) = (TEMP(I) - YDOT(I))/HG
      YDDNRM = DVNORM (N, TEMP, EWT)
      IF (YDDNRM*HUB*HUB .GT. TWO) THEN
        HNEW = SQRT(TWO/YDDNRM)
      ELSE
        HNEW = SQRT(HG*HUB)
      ENDIF
      ITER = ITER + 1
      IF (ITER .GE. 4) GO TO 80
      HRAT = HNEW/HG
      IF ( (HRAT .GT. HALF) .AND. (HRAT .LT. TWO) ) GO TO 80
      IF ( (ITER .GE. 2) .AND. (HNEW .GT. TWO*HG) ) THEN
        HNEW = HG
        GO TO 80
      ENDIF
      HG = HNEW
      GO TO 50
 80   H0 = HNEW*HALF
      IF (H0 .LT. HLB) H0 = HLB
      IF (H0 .GT. HUB) H0 = HUB
 90   H0 = SIGN(H0, TOUT - T0)
      NITER = ITER
      IER = 0
      RETURN
 100  IER = -1
      RETURN
      END
      SUBROUTINE DVINDY (T, K, YH, LDYH, DKY, IFLAG)
      DOUBLE PRECISION T, YH, DKY
      INTEGER K, LDYH, IFLAG
      DIMENSION YH(LDYH,*), DKY(*)
      DOUBLE PRECISION ACNRM, CCMXJ, CONP, CRATE, DRC, EL,
     1     ETA, ETAMAX, H, HMIN, HMXI, HNEW, HSCAL, PRL1,
     2     RC, RL1, TAU, TQ, TN, UROUND
      INTEGER ICF, INIT, IPUP, JCUR, JSTART, JSV, KFLAG, KUTH,
     1        L, LMAX, LYH, LEWT, LACOR, LSAVF, LWM, LIWM,
     2        LOCJS, MAXORD, METH, MITER, MSBJ, MXHNIL, MXSTEP,
     3        N, NEWH, NEWQ, NHNIL, NQ, NQNYH, NQWAIT, NSLJ,
     4        NSLP, NYH
      DOUBLE PRECISION HU
      INTEGER NCFN, NETF, NFE, NJE, NLU, NNI, NQU, NST
      DOUBLE PRECISION C, HUN, R, S, TFUZZ, TN1, TP, ZERO
      INTEGER I, IC, J, JB, JB2, JJ, JJ1, JP1
      CHARACTER*80 MSG
      SAVE HUN, ZERO
      COMMON /DVOD01/ ACNRM, CCMXJ, CONP, CRATE, DRC, EL(13),
     1                ETA, ETAMAX, H, HMIN, HMXI, HNEW, HSCAL, PRL1,
     2                RC, RL1, TAU(13), TQ(5), TN, UROUND,
     3                ICF, INIT, IPUP, JCUR, JSTART, JSV, KFLAG, KUTH,
     4                L, LMAX, LYH, LEWT, LACOR, LSAVF, LWM, LIWM,
     5                LOCJS, MAXORD, METH, MITER, MSBJ, MXHNIL, MXSTEP,
     6                N, NEWH, NEWQ, NHNIL, NQ, NQNYH, NQWAIT, NSLJ,
     7                NSLP, NYH
      COMMON /DVOD02/ HU, NCFN, NETF, NFE, NJE, NLU, NNI, NQU, NST
      DATA HUN /100.0D0/, ZERO /0.0D0/
      IFLAG = 0
      IF (K .LT. 0 .OR. K .GT. NQ) GO TO 80
      TFUZZ = HUN*UROUND*(TN + HU)
      TP = TN - HU - TFUZZ
      TN1 = TN + TFUZZ
      IF ((T-TP)*(T-TN1) .GT. ZERO) GO TO 90
      S = (T - TN)/H
      IC = 1
      IF (K .EQ. 0) GO TO 15
      JJ1 = L - K
      DO 10 JJ = JJ1, NQ
 10     IC = IC*JJ
 15   C = REAL(IC)
      DO 20 I = 1, N
 20     DKY(I) = C*YH(I,L)
      IF (K .EQ. NQ) GO TO 55
      JB2 = NQ - K
      DO 50 JB = 1, JB2
        J = NQ - JB
        JP1 = J + 1
        IC = 1
        IF (K .EQ. 0) GO TO 35
        JJ1 = JP1 - K
        DO 30 JJ = JJ1, J
 30       IC = IC*JJ
 35     C = REAL(IC)
        DO 40 I = 1, N
 40       DKY(I) = C*YH(I,JP1) + S*DKY(I)
 50     CONTINUE
      IF (K .EQ. 0) RETURN
 55   R = H**(-K)
      CALL DSCAL (N, R, DKY, 1)
      RETURN
 80   MSG = 'DVINDY-- K (=I1) illegal      '
      CALL XERRWD (MSG, 30, 51, 1, 1, K, 0, 0, ZERO, ZERO)
      IFLAG = -1
      RETURN
 90   MSG = 'DVINDY-- T (=R1) illegal      '
      CALL XERRWD (MSG, 30, 52, 1, 0, 0, 0, 1, T, ZERO)
      MSG='      T not in interval TCUR - HU (= R1) to TCUR (=R2)      '
      CALL XERRWD (MSG, 60, 52, 1, 0, 0, 0, 2, TP, TN)
      IFLAG = -2
      RETURN
      END
      SUBROUTINE DVSTEP (Y, YH, LDYH, YH1, EWT, SAVF, VSAV, ACOR,
     1                  WM, IWM, F, JAC, PSOL, VNLS, RPAR, IPAR)
      EXTERNAL F, JAC, PSOL, VNLS
      DOUBLE PRECISION Y, YH, YH1, EWT, SAVF, VSAV, ACOR, WM, RPAR
      INTEGER LDYH, IWM, IPAR
      DIMENSION Y(*), YH(LDYH,*), YH1(*), EWT(*), SAVF(*), VSAV(*),
     1   ACOR(*), WM(*), IWM(*), RPAR(*), IPAR(*)
      DOUBLE PRECISION ACNRM, CCMXJ, CONP, CRATE, DRC, EL,
     1     ETA, ETAMAX, H, HMIN, HMXI, HNEW, HSCAL, PRL1,
     2     RC, RL1, TAU, TQ, TN, UROUND
      INTEGER ICF, INIT, IPUP, JCUR, JSTART, JSV, KFLAG, KUTH,
     1        L, LMAX, LYH, LEWT, LACOR, LSAVF, LWM, LIWM,
     2        LOCJS, MAXORD, METH, MITER, MSBJ, MXHNIL, MXSTEP,
     3        N, NEWH, NEWQ, NHNIL, NQ, NQNYH, NQWAIT, NSLJ,
     4        NSLP, NYH
      DOUBLE PRECISION HU
      INTEGER NCFN, NETF, NFE, NJE, NLU, NNI, NQU, NST
      DOUBLE PRECISION ADDON, BIAS1,BIAS2,BIAS3, CNQUOT, DDN, DSM, DUP,
     1     ETACF, ETAMIN, ETAMX1, ETAMX2, ETAMX3, ETAMXF,
     2     ETAQ, ETAQM1, ETAQP1, FLOTL, ONE, ONEPSM,
     3     R, THRESH, TOLD, ZERO
      INTEGER I, I1, I2, IBACK, J, JB, KFC, KFH, MXNCF, NCF, NFLAG
      DOUBLE PRECISION DVNORM
      SAVE ADDON, BIAS1, BIAS2, BIAS3,
     1     ETACF, ETAMIN, ETAMX1, ETAMX2, ETAMX3, ETAMXF,
     2     KFC, KFH, MXNCF, ONEPSM, THRESH, ONE, ZERO
      COMMON /DVOD01/ ACNRM, CCMXJ, CONP, CRATE, DRC, EL(13),
     1                ETA, ETAMAX, H, HMIN, HMXI, HNEW, HSCAL, PRL1,
     2                RC, RL1, TAU(13), TQ(5), TN, UROUND,
     3                ICF, INIT, IPUP, JCUR, JSTART, JSV, KFLAG, KUTH,
     4                L, LMAX, LYH, LEWT, LACOR, LSAVF, LWM, LIWM,
     5                LOCJS, MAXORD, METH, MITER, MSBJ, MXHNIL, MXSTEP,
     6                N, NEWH, NEWQ, NHNIL, NQ, NQNYH, NQWAIT, NSLJ,
     7                NSLP, NYH
      COMMON /DVOD02/ HU, NCFN, NETF, NFE, NJE, NLU, NNI, NQU, NST
      DATA KFC/-3/, KFH/-7/, MXNCF/10/
      DATA ADDON  /1.0D-6/,    BIAS1  /6.0D0/,     BIAS2  /6.0D0/,
     1     BIAS3  /10.0D0/,    ETACF  /0.25D0/,    ETAMIN /0.1D0/,
     2     ETAMXF /0.2D0/,     ETAMX1 /1.0D4/,     ETAMX2 /10.0D0/,
     3     ETAMX3 /10.0D0/,    ONEPSM /1.00001D0/, THRESH /1.5D0/
      DATA ONE/1.0D0/, ZERO/0.0D0/
      KFLAG = 0
      TOLD = TN
      NCF = 0
      JCUR = 0
      NFLAG = 0
      IF (JSTART .GT. 0) GO TO 20
      IF (JSTART .EQ. -1) GO TO 100
      LMAX = MAXORD + 1
      NQ = 1
      L = 2
      NQNYH = NQ*LDYH
      TAU(1) = H
      PRL1 = ONE
      RC = ZERO
      ETAMAX = ETAMX1
      NQWAIT = 2
      HSCAL = H
      GO TO 200
 20   CONTINUE
      IF (KUTH .EQ. 1) THEN
        ETA = MIN(ETA,H/HSCAL)
        NEWH = 1
        ENDIF
 50   IF (NEWH .EQ. 0) GO TO 200
      IF (NEWQ .EQ. NQ) GO TO 150
      IF (NEWQ .LT. NQ) THEN
        CALL DVJUST (YH, LDYH, -1)
        NQ = NEWQ
        L = NQ + 1
        NQWAIT = L
        GO TO 150
        ENDIF
      IF (NEWQ .GT. NQ) THEN
        CALL DVJUST (YH, LDYH, 1)
        NQ = NEWQ
        L = NQ + 1
        NQWAIT = L
        GO TO 150
      ENDIF
 100  CONTINUE
      LMAX = MAXORD + 1
      IF (N .EQ. LDYH) GO TO 120
      I1 = 1 + (NEWQ + 1)*LDYH
      I2 = (MAXORD + 1)*LDYH
      IF (I1 .GT. I2) GO TO 120
      DO 110 I = I1, I2
 110    YH1(I) = ZERO
 120  IF (NEWQ .LE. MAXORD) GO TO 140
      FLOTL = REAL(LMAX)
      IF (MAXORD .LT. NQ-1) THEN
        DDN = DVNORM (N, SAVF, EWT)/TQ(1)
        ETA = ONE/((BIAS1*DDN)**(ONE/FLOTL) + ADDON)
        ENDIF
      IF (MAXORD .EQ. NQ .AND. NEWQ .EQ. NQ+1) ETA = ETAQ
      IF (MAXORD .EQ. NQ-1 .AND. NEWQ .EQ. NQ+1) THEN
        ETA = ETAQM1
        CALL DVJUST (YH, LDYH, -1)
        ENDIF
      IF (MAXORD .EQ. NQ-1 .AND. NEWQ .EQ. NQ) THEN
        DDN = DVNORM (N, SAVF, EWT)/TQ(1)
        ETA = ONE/((BIAS1*DDN)**(ONE/FLOTL) + ADDON)
        CALL DVJUST (YH, LDYH, -1)
        ENDIF
      ETA = MIN(ETA,ONE)
      NQ = MAXORD
      L = LMAX
 140  IF (KUTH .EQ. 1) ETA = MIN(ETA,ABS(H/HSCAL))
      IF (KUTH .EQ. 0) ETA = MAX(ETA,HMIN/ABS(HSCAL))
      ETA = ETA/MAX(ONE,ABS(HSCAL)*HMXI*ETA)
      NEWH = 1
      NQWAIT = L
      IF (NEWQ .LE. MAXORD) GO TO 50
 150  R = ONE
      DO 180 J = 2, L
        R = R*ETA
        CALL DSCAL (N, R, YH(1,J), 1 )
 180    CONTINUE
      H = HSCAL*ETA
      HSCAL = H
      RC = RC*ETA
      NQNYH = NQ*LDYH
 200  TN = TN + H
      I1 = NQNYH + 1
      DO 220 JB = 1, NQ
        I1 = I1 - LDYH
        DO 210 I = I1, NQNYH
 210      YH1(I) = YH1(I) + YH1(I+LDYH)
 220  CONTINUE
      CALL DVSET
      RL1 = ONE/EL(2)
      RC = RC*(RL1/PRL1)
      PRL1 = RL1
      CALL VNLS (Y, YH, LDYH, VSAV, SAVF, EWT, ACOR, IWM, WM,
     1           F, JAC, PSOL, NFLAG, RPAR, IPAR)
      IF (NFLAG .EQ. 0) GO TO 450
        NCF = NCF + 1
        NCFN = NCFN + 1
        ETAMAX = ONE
        TN = TOLD
        I1 = NQNYH + 1
        DO 430 JB = 1, NQ
          I1 = I1 - LDYH
          DO 420 I = I1, NQNYH
 420        YH1(I) = YH1(I) - YH1(I+LDYH)
 430      CONTINUE
        IF (NFLAG .LT. -1) GO TO 680
        IF (ABS(H) .LE. HMIN*ONEPSM) GO TO 670
        IF (NCF .EQ. MXNCF) GO TO 670
        ETA = ETACF
        ETA = MAX(ETA,HMIN/ABS(H))
        NFLAG = -1
        GO TO 150
 450  CONTINUE
      DSM = ACNRM/TQ(2)
      IF (DSM .GT. ONE) GO TO 500
      KFLAG = 0
      NST = NST + 1
      HU = H
      NQU = NQ
      DO 470 IBACK = 1, NQ
        I = L - IBACK
 470    TAU(I+1) = TAU(I)
      TAU(1) = H
      DO 480 J = 1, L
        CALL DAXPY (N, EL(J), ACOR, 1, YH(1,J), 1 )
 480    CONTINUE
      NQWAIT = NQWAIT - 1
      IF ((L .EQ. LMAX) .OR. (NQWAIT .NE. 1)) GO TO 490
      CALL DCOPY (N, ACOR, 1, YH(1,LMAX), 1 )
      CONP = TQ(5)
 490  IF (ETAMAX .NE. ONE) GO TO 560
      IF (NQWAIT .LT. 2) NQWAIT = 2
      NEWQ = NQ
      NEWH = 0
      ETA = ONE
      HNEW = H
      GO TO 690
 500  KFLAG = KFLAG - 1
      NETF = NETF + 1
      NFLAG = -2
      TN = TOLD
      I1 = NQNYH + 1
      DO 520 JB = 1, NQ
        I1 = I1 - LDYH
        DO 510 I = I1, NQNYH
 510      YH1(I) = YH1(I) - YH1(I+LDYH)
 520  CONTINUE
      IF (ABS(H) .LE. HMIN*ONEPSM) GO TO 660
      ETAMAX = ONE
      IF (KFLAG .LE. KFC) GO TO 530
      FLOTL = REAL(L)
      ETA = ONE/((BIAS2*DSM)**(ONE/FLOTL) + ADDON)
      ETA = MAX(ETA,HMIN/ABS(H),ETAMIN)
      IF ((KFLAG .LE. -2) .AND. (ETA .GT. ETAMXF)) ETA = ETAMXF
      GO TO 150
 530  IF (KFLAG .EQ. KFH) GO TO 660
      IF (NQ .EQ. 1) GO TO 540
      ETA = MAX(ETAMIN,HMIN/ABS(H))
      CALL DVJUST (YH, LDYH, -1)
      L = NQ
      NQ = NQ - 1
      NQWAIT = L
      GO TO 150
 540  ETA = MAX(ETAMIN,HMIN/ABS(H))
      H = H*ETA
      HSCAL = H
      TAU(1) = H
      CALL F (N, TN, Y, SAVF, RPAR, IPAR)
      NFE = NFE + 1
      DO 550 I = 1, N
 550    YH(I,2) = H*SAVF(I)
      NQWAIT = 10
      GO TO 200
 560  FLOTL = REAL(L)
      ETAQ = ONE/((BIAS2*DSM)**(ONE/FLOTL) + ADDON)
      IF (NQWAIT .NE. 0) GO TO 600
      NQWAIT = 2
      ETAQM1 = ZERO
      IF (NQ .EQ. 1) GO TO 570
      DDN = DVNORM (N, YH(1,L), EWT)/TQ(1)
      ETAQM1 = ONE/((BIAS1*DDN)**(ONE/(FLOTL - ONE)) + ADDON)
 570  ETAQP1 = ZERO
      IF (L .EQ. LMAX) GO TO 580
      CNQUOT = (TQ(5)/CONP)*(H/TAU(2))**L
      DO 575 I = 1, N
 575    SAVF(I) = ACOR(I) - CNQUOT*YH(I,LMAX)
      DUP = DVNORM (N, SAVF, EWT)/TQ(3)
      ETAQP1 = ONE/((BIAS3*DUP)**(ONE/(FLOTL + ONE)) + ADDON)
 580  IF (ETAQ .GE. ETAQP1) GO TO 590
      IF (ETAQP1 .GT. ETAQM1) GO TO 620
      GO TO 610
 590  IF (ETAQ .LT. ETAQM1) GO TO 610
 600  ETA = ETAQ
      NEWQ = NQ
      GO TO 630
 610  ETA = ETAQM1
      NEWQ = NQ - 1
      GO TO 630
 620  ETA = ETAQP1
      NEWQ = NQ + 1
      CALL DCOPY (N, ACOR, 1, YH(1,LMAX), 1)
 630  IF (ETA .LT. THRESH .OR. ETAMAX .EQ. ONE) GO TO 640
      ETA = MIN(ETA,ETAMAX)
      ETA = ETA/MAX(ONE,ABS(H)*HMXI*ETA)
      NEWH = 1
      HNEW = H*ETA
      GO TO 690
 640  NEWQ = NQ
      NEWH = 0
      ETA = ONE
      HNEW = H
      GO TO 690
 660  KFLAG = -1
      GO TO 720
 670  KFLAG = -2
      GO TO 720
 680  IF (NFLAG .EQ. -2) KFLAG = -3
      IF (NFLAG .EQ. -3) KFLAG = -4
      GO TO 720
 690  ETAMAX = ETAMX3
      IF (NST .LE. 10) ETAMAX = ETAMX2
 700  R = ONE/TQ(2)
      CALL DSCAL (N, R, ACOR, 1)
 720  JSTART = 1
      RETURN
      END
      SUBROUTINE DVSET
      DOUBLE PRECISION ACNRM, CCMXJ, CONP, CRATE, DRC, EL,
     1     ETA, ETAMAX, H, HMIN, HMXI, HNEW, HSCAL, PRL1,
     2     RC, RL1, TAU, TQ, TN, UROUND
      INTEGER ICF, INIT, IPUP, JCUR, JSTART, JSV, KFLAG, KUTH,
     1        L, LMAX, LYH, LEWT, LACOR, LSAVF, LWM, LIWM,
     2        LOCJS, MAXORD, METH, MITER, MSBJ, MXHNIL, MXSTEP,
     3        N, NEWH, NEWQ, NHNIL, NQ, NQNYH, NQWAIT, NSLJ,
     4        NSLP, NYH
      DOUBLE PRECISION AHATN0, ALPH0, CNQM1, CORTES, CSUM, ELP, EM,
     1     EM0, FLOTI, FLOTL, FLOTNQ, HSUM, ONE, RXI, RXIS, S, SIX,
     2     T1, T2, T3, T4, T5, T6, TWO, XI, ZERO
      INTEGER I, IBACK, J, JP1, NQM1, NQM2
      DIMENSION EM(13)
      SAVE CORTES, ONE, SIX, TWO, ZERO
      COMMON /DVOD01/ ACNRM, CCMXJ, CONP, CRATE, DRC, EL(13),
     1                ETA, ETAMAX, H, HMIN, HMXI, HNEW, HSCAL, PRL1,
     2                RC, RL1, TAU(13), TQ(5), TN, UROUND,
     3                ICF, INIT, IPUP, JCUR, JSTART, JSV, KFLAG, KUTH,
     4                L, LMAX, LYH, LEWT, LACOR, LSAVF, LWM, LIWM,
     5                LOCJS, MAXORD, METH, MITER, MSBJ, MXHNIL, MXSTEP,
     6                N, NEWH, NEWQ, NHNIL, NQ, NQNYH, NQWAIT, NSLJ,
     7                NSLP, NYH
      DATA CORTES /0.1D0/
      DATA ONE  /1.0D0/, SIX /6.0D0/, TWO /2.0D0/, ZERO /0.0D0/
      FLOTL = REAL(L)
      NQM1 = NQ - 1
      NQM2 = NQ - 2
      GO TO (100, 200), METH
 100  IF (NQ .NE. 1) GO TO 110
      EL(1) = ONE
      EL(2) = ONE
      TQ(1) = ONE
      TQ(2) = TWO
      TQ(3) = SIX*TQ(2)
      TQ(5) = ONE
      GO TO 300
 110  HSUM = H
      EM(1) = ONE
      FLOTNQ = FLOTL - ONE
      DO 115 I = 2, L
 115    EM(I) = ZERO
      DO 150 J = 1, NQM1
        IF ((J .NE. NQM1) .OR. (NQWAIT .NE. 1)) GO TO 130
        S = ONE
        CSUM = ZERO
        DO 120 I = 1, NQM1
          CSUM = CSUM + S*EM(I)/REAL(I+1)
 120      S = -S
        TQ(1) = EM(NQM1)/(FLOTNQ*CSUM)
 130    RXI = H/HSUM
        DO 140 IBACK = 1, J
          I = (J + 2) - IBACK
 140      EM(I) = EM(I) + EM(I-1)*RXI
        HSUM = HSUM + TAU(J)
 150    CONTINUE
      S = ONE
      EM0 = ZERO
      CSUM = ZERO
      DO 160 I = 1, NQ
        FLOTI = REAL(I)
        EM0 = EM0 + S*EM(I)/FLOTI
        CSUM = CSUM + S*EM(I)/(FLOTI+ONE)
 160    S = -S
      S = ONE/EM0
      EL(1) = ONE
      DO 170 I = 1, NQ
 170    EL(I+1) = S*EM(I)/REAL(I)
      XI = HSUM/H
      TQ(2) = XI*EM0/CSUM
      TQ(5) = XI/EL(L)
      IF (NQWAIT .NE. 1) GO TO 300
      RXI = ONE/XI
      DO 180 IBACK = 1, NQ
        I = (L + 1) - IBACK
 180    EM(I) = EM(I) + EM(I-1)*RXI
      S = ONE
      CSUM = ZERO
      DO 190 I = 1, L
        CSUM = CSUM + S*EM(I)/REAL(I+1)
 190    S = -S
      TQ(3) = FLOTL*EM0/CSUM
      GO TO 300
 200  DO 210 I = 3, L
 210    EL(I) = ZERO
      EL(1) = ONE
      EL(2) = ONE
      ALPH0 = -ONE
      AHATN0 = -ONE
      HSUM = H
      RXI = ONE
      RXIS = ONE
      IF (NQ .EQ. 1) GO TO 240
      DO 230 J = 1, NQM2
        HSUM = HSUM + TAU(J)
        RXI = H/HSUM
        JP1 = J + 1
        ALPH0 = ALPH0 - ONE/REAL(JP1)
        DO 220 IBACK = 1, JP1
          I = (J + 3) - IBACK
 220      EL(I) = EL(I) + EL(I-1)*RXI
 230    CONTINUE
      ALPH0 = ALPH0 - ONE/REAL(NQ)
      RXIS = -EL(2) - ALPH0
      HSUM = HSUM + TAU(NQM1)
      RXI = H/HSUM
      AHATN0 = -EL(2) - RXI
      DO 235 IBACK = 1, NQ
        I = (NQ + 2) - IBACK
 235    EL(I) = EL(I) + EL(I-1)*RXIS
 240  T1 = ONE - AHATN0 + ALPH0
      T2 = ONE + REAL(NQ)*T1
      TQ(2) = ABS(ALPH0*T2/T1)
      TQ(5) = ABS(T2/(EL(L)*RXI/RXIS))
      IF (NQWAIT .NE. 1) GO TO 300
      CNQM1 = RXIS/EL(L)
      T3 = ALPH0 + ONE/REAL(NQ)
      T4 = AHATN0 + RXI
      ELP = T3/(ONE - T4 + T3)
      TQ(1) = ABS(ELP/CNQM1)
      HSUM = HSUM + TAU(NQ)
      RXI = H/HSUM
      T5 = ALPH0 - ONE/REAL(NQ+1)
      T6 = AHATN0 - RXI
      ELP = T2/(ONE - T6 + T5)
      TQ(3) = ABS(ELP*RXI*(FLOTL + ONE)*T5)
 300  TQ(4) = CORTES*TQ(2)
      RETURN
      END
      SUBROUTINE DVJUST (YH, LDYH, IORD)
      DOUBLE PRECISION YH
      INTEGER LDYH, IORD
      DIMENSION YH(LDYH,*)
      DOUBLE PRECISION ACNRM, CCMXJ, CONP, CRATE, DRC, EL,
     1     ETA, ETAMAX, H, HMIN, HMXI, HNEW, HSCAL, PRL1,
     2     RC, RL1, TAU, TQ, TN, UROUND
      INTEGER ICF, INIT, IPUP, JCUR, JSTART, JSV, KFLAG, KUTH,
     1        L, LMAX, LYH, LEWT, LACOR, LSAVF, LWM, LIWM,
     2        LOCJS, MAXORD, METH, MITER, MSBJ, MXHNIL, MXSTEP,
     3        N, NEWH, NEWQ, NHNIL, NQ, NQNYH, NQWAIT, NSLJ,
     4        NSLP, NYH
      DOUBLE PRECISION ALPH0, ALPH1, HSUM, ONE, PROD, T1, XI,XIOLD, ZERO
      INTEGER I, IBACK, J, JP1, LP1, NQM1, NQM2, NQP1
      SAVE ONE, ZERO
      COMMON /DVOD01/ ACNRM, CCMXJ, CONP, CRATE, DRC, EL(13),
     1                ETA, ETAMAX, H, HMIN, HMXI, HNEW, HSCAL, PRL1,
     2                RC, RL1, TAU(13), TQ(5), TN, UROUND,
     3                ICF, INIT, IPUP, JCUR, JSTART, JSV, KFLAG, KUTH,
     4                L, LMAX, LYH, LEWT, LACOR, LSAVF, LWM, LIWM,
     5                LOCJS, MAXORD, METH, MITER, MSBJ, MXHNIL, MXSTEP,
     6                N, NEWH, NEWQ, NHNIL, NQ, NQNYH, NQWAIT, NSLJ,
     7                NSLP, NYH
      DATA ONE /1.0D0/, ZERO /0.0D0/
      IF ((NQ .EQ. 2) .AND. (IORD .NE. 1)) RETURN
      NQM1 = NQ - 1
      NQM2 = NQ - 2
      GO TO (100, 200), METH
 100  CONTINUE
      IF (IORD .EQ. 1) GO TO 180
      DO 110 J = 1, LMAX
 110    EL(J) = ZERO
      EL(2) = ONE
      HSUM = ZERO
      DO 130 J = 1, NQM2
        HSUM = HSUM + TAU(J)
        XI = HSUM/HSCAL
        JP1 = J + 1
        DO 120 IBACK = 1, JP1
          I = (J + 3) - IBACK
 120      EL(I) = EL(I)*XI + EL(I-1)
 130    CONTINUE
      DO 140 J = 2, NQM1
 140    EL(J+1) = REAL(NQ)*EL(J)/REAL(J)
      DO 170 J = 3, NQ
        DO 160 I = 1, N
 160      YH(I,J) = YH(I,J) - YH(I,L)*EL(J)
 170    CONTINUE
      RETURN
 180  CONTINUE
      LP1 = L + 1
      DO 190 I = 1, N
 190    YH(I,LP1) = ZERO
      RETURN
 200  CONTINUE
      IF (IORD .EQ. 1) GO TO 300
      DO 210 J = 1, LMAX
 210    EL(J) = ZERO
      EL(3) = ONE
      HSUM = ZERO
      DO 230 J = 1,NQM2
        HSUM = HSUM + TAU(J)
        XI = HSUM/HSCAL
        JP1 = J + 1
        DO 220 IBACK = 1, JP1
          I = (J + 4) - IBACK
 220      EL(I) = EL(I)*XI + EL(I-1)
 230    CONTINUE
      DO 250 J = 3,NQ
        DO 240 I = 1, N
 240      YH(I,J) = YH(I,J) - YH(I,L)*EL(J)
 250    CONTINUE
      RETURN
 300  DO 310 J = 1, LMAX
 310    EL(J) = ZERO
      EL(3) = ONE
      ALPH0 = -ONE
      ALPH1 = ONE
      PROD = ONE
      XIOLD = ONE
      HSUM = HSCAL
      IF (NQ .EQ. 1) GO TO 340
      DO 330 J = 1, NQM1
        JP1 = J + 1
        HSUM = HSUM + TAU(JP1)
        XI = HSUM/HSCAL
        PROD = PROD*XI
        ALPH0 = ALPH0 - ONE/REAL(JP1)
        ALPH1 = ALPH1 + ONE/XI
        DO 320 IBACK = 1, JP1
          I = (J + 4) - IBACK
 320      EL(I) = EL(I)*XIOLD + EL(I-1)
        XIOLD = XI
 330    CONTINUE
 340  CONTINUE
      T1 = (-ALPH0 - ALPH1)/PROD
      LP1 = L + 1
      DO 350 I = 1, N
 350    YH(I,LP1) = T1*YH(I,LMAX)
      NQP1 = NQ + 1
      DO 370 J = 3, NQP1
        CALL DAXPY (N, EL(J), YH(1,LP1), 1, YH(1,J), 1 )
 370  CONTINUE
      RETURN
      END
      SUBROUTINE DVNLSD (Y, YH, LDYH, VSAV, SAVF, EWT, ACOR, IWM, WM,
     1                 F, JAC, PDUM, NFLAG, RPAR, IPAR)
      EXTERNAL F, JAC, PDUM
      DOUBLE PRECISION Y, YH, VSAV, SAVF, EWT, ACOR, WM, RPAR
      INTEGER LDYH, IWM, NFLAG, IPAR
      DIMENSION Y(*), YH(LDYH,*), VSAV(*), SAVF(*), EWT(*), ACOR(*),
     1          IWM(*), WM(*), RPAR(*), IPAR(*)
      DOUBLE PRECISION ACNRM, CCMXJ, CONP, CRATE, DRC, EL,
     1     ETA, ETAMAX, H, HMIN, HMXI, HNEW, HSCAL, PRL1,
     2     RC, RL1, TAU, TQ, TN, UROUND
      INTEGER ICF, INIT, IPUP, JCUR, JSTART, JSV, KFLAG, KUTH,
     1        L, LMAX, LYH, LEWT, LACOR, LSAVF, LWM, LIWM,
     2        LOCJS, MAXORD, METH, MITER, MSBJ, MXHNIL, MXSTEP,
     3        N, NEWH, NEWQ, NHNIL, NQ, NQNYH, NQWAIT, NSLJ,
     4        NSLP, NYH
      DOUBLE PRECISION HU
      INTEGER NCFN, NETF, NFE, NJE, NLU, NNI, NQU, NST
      DOUBLE PRECISION CCMAX, CRDOWN, CSCALE, DCON, DEL, DELP, ONE,
     1     RDIV, TWO, ZERO
      INTEGER I, IERPJ, IERSL, M, MAXCOR, MSBP
      DOUBLE PRECISION DVNORM
      SAVE CCMAX, CRDOWN, MAXCOR, MSBP, RDIV, ONE, TWO, ZERO
      COMMON /DVOD01/ ACNRM, CCMXJ, CONP, CRATE, DRC, EL(13),
     1                ETA, ETAMAX, H, HMIN, HMXI, HNEW, HSCAL, PRL1,
     2                RC, RL1, TAU(13), TQ(5), TN, UROUND,
     3                ICF, INIT, IPUP, JCUR, JSTART, JSV, KFLAG, KUTH,
     4                L, LMAX, LYH, LEWT, LACOR, LSAVF, LWM, LIWM,
     5                LOCJS, MAXORD, METH, MITER, MSBJ, MXHNIL, MXSTEP,
     6                N, NEWH, NEWQ, NHNIL, NQ, NQNYH, NQWAIT, NSLJ,
     7                NSLP, NYH
      COMMON /DVOD02/ HU, NCFN, NETF, NFE, NJE, NLU, NNI, NQU, NST
      DATA CCMAX /0.3D0/, CRDOWN /0.3D0/, MAXCOR /3/, MSBP /20/,
     1     RDIV  /2.0D0/
      DATA ONE /1.0D0/, TWO /2.0D0/, ZERO /0.0D0/
      IF (JSTART .EQ. 0) NSLP = 0
      IF (NFLAG .EQ. 0) ICF = 0
      IF (NFLAG .EQ. -2) IPUP = MITER
      IF ( (JSTART .EQ. 0) .OR. (JSTART .EQ. -1) ) IPUP = MITER
      IF (MITER .EQ. 0) THEN
        CRATE = ONE
        GO TO 220
      ENDIF
      DRC = ABS(RC-ONE)
      IF (DRC .GT. CCMAX .OR. NST .GE. NSLP+MSBP) IPUP = MITER
 220  M = 0
      DELP = ZERO
      CALL DCOPY (N, YH(1,1), 1, Y, 1 )
      CALL F (N, TN, Y, SAVF, RPAR, IPAR)
      NFE = NFE + 1
      IF (IPUP .LE. 0) GO TO 250
      CALL DVJAC (Y, YH, LDYH, EWT, ACOR, SAVF, WM, IWM, F, JAC, IERPJ,
     1           RPAR, IPAR)
      IPUP = 0
      RC = ONE
      DRC = ZERO
      CRATE = ONE
      NSLP = NST
      IF (IERPJ .NE. 0) GO TO 430
 250  DO 260 I = 1,N
 260    ACOR(I) = ZERO
 270  IF (MITER .NE. 0) GO TO 350
      DO 280 I = 1,N
 280    SAVF(I) = RL1*(H*SAVF(I) - YH(I,2))
      DO 290 I = 1,N
 290    Y(I) = SAVF(I) - ACOR(I)
      DEL = DVNORM (N, Y, EWT)
      DO 300 I = 1,N
 300    Y(I) = YH(I,1) + SAVF(I)
      CALL DCOPY (N, SAVF, 1, ACOR, 1)
      GO TO 400
 350  DO 360 I = 1,N
 360    Y(I) = (RL1*H)*SAVF(I) - (RL1*YH(I,2) + ACOR(I))
      CALL DVSOL (WM, IWM, Y, IERSL)
      NNI = NNI + 1
      IF (IERSL .GT. 0) GO TO 410
      IF (METH .EQ. 2 .AND. RC .NE. ONE) THEN
        CSCALE = TWO/(ONE + RC)
        CALL DSCAL (N, CSCALE, Y, 1)
      ENDIF
      DEL = DVNORM (N, Y, EWT)
      CALL DAXPY (N, ONE, Y, 1, ACOR, 1)
      DO 380 I = 1,N
 380    Y(I) = YH(I,1) + ACOR(I)
 400  IF (M .NE. 0) CRATE = MAX(CRDOWN*CRATE,DEL/DELP)
      DCON = DEL*MIN(ONE,CRATE)/TQ(4)
      IF (DCON .LE. ONE) GO TO 450
      M = M + 1
      IF (M .EQ. MAXCOR) GO TO 410
      IF (M .GE. 2 .AND. DEL .GT. RDIV*DELP) GO TO 410
      DELP = DEL
      CALL F (N, TN, Y, SAVF, RPAR, IPAR)
      NFE = NFE + 1
      GO TO 270
 410  IF (MITER .EQ. 0 .OR. JCUR .EQ. 1) GO TO 430
      ICF = 1
      IPUP = MITER
      GO TO 220
 430  CONTINUE
      NFLAG = -1
      ICF = 2
      IPUP = MITER
      RETURN
 450  NFLAG = 0
      JCUR = 0
      ICF = 0
      IF (M .EQ. 0) ACNRM = DEL
      IF (M .GT. 0) ACNRM = DVNORM (N, ACOR, EWT)
      RETURN
      END
      SUBROUTINE DVJAC (Y, YH, LDYH, EWT, FTEM, SAVF, WM, IWM, F, JAC,
     1                 IERPJ, RPAR, IPAR)
      EXTERNAL F, JAC
      DOUBLE PRECISION Y, YH, EWT, FTEM, SAVF, WM, RPAR
      INTEGER LDYH, IWM, IERPJ, IPAR
      DIMENSION Y(*), YH(LDYH,*), EWT(*), FTEM(*), SAVF(*),
     1   WM(*), IWM(*), RPAR(*), IPAR(*)
      DOUBLE PRECISION ACNRM, CCMXJ, CONP, CRATE, DRC, EL,
     1     ETA, ETAMAX, H, HMIN, HMXI, HNEW, HSCAL, PRL1,
     2     RC, RL1, TAU, TQ, TN, UROUND
      INTEGER ICF, INIT, IPUP, JCUR, JSTART, JSV, KFLAG, KUTH,
     1        L, LMAX, LYH, LEWT, LACOR, LSAVF, LWM, LIWM,
     2        LOCJS, MAXORD, METH, MITER, MSBJ, MXHNIL, MXSTEP,
     3        N, NEWH, NEWQ, NHNIL, NQ, NQNYH, NQWAIT, NSLJ,
     4        NSLP, NYH
      DOUBLE PRECISION HU
      INTEGER NCFN, NETF, NFE, NJE, NLU, NNI, NQU, NST
      DOUBLE PRECISION CON, DI, FAC, HRL1, ONE, PT1, R, R0, SRUR, THOU,
     1     YI, YJ, YJJ, ZERO
      INTEGER I, I1, I2, IER, II, J, J1, JJ, JOK, LENP, MBA, MBAND,
     1        MEB1, MEBAND, ML, ML3, MU, NP1
      DOUBLE PRECISION DVNORM
      SAVE ONE, PT1, THOU, ZERO
      COMMON /DVOD01/ ACNRM, CCMXJ, CONP, CRATE, DRC, EL(13),
     1                ETA, ETAMAX, H, HMIN, HMXI, HNEW, HSCAL, PRL1,
     2                RC, RL1, TAU(13), TQ(5), TN, UROUND,
     3                ICF, INIT, IPUP, JCUR, JSTART, JSV, KFLAG, KUTH,
     4                L, LMAX, LYH, LEWT, LACOR, LSAVF, LWM, LIWM,
     5                LOCJS, MAXORD, METH, MITER, MSBJ, MXHNIL, MXSTEP,
     6                N, NEWH, NEWQ, NHNIL, NQ, NQNYH, NQWAIT, NSLJ,
     7                NSLP, NYH
      COMMON /DVOD02/ HU, NCFN, NETF, NFE, NJE, NLU, NNI, NQU, NST
      DATA ONE /1.0D0/, THOU /1000.0D0/, ZERO /0.0D0/, PT1 /0.1D0/
      IERPJ = 0
      HRL1 = H*RL1
      JOK = JSV
      IF (JSV .EQ. 1) THEN
        IF (NST .EQ. 0 .OR. NST .GT. NSLJ+MSBJ) JOK = -1
        IF (ICF .EQ. 1 .AND. DRC .LT. CCMXJ) JOK = -1
        IF (ICF .EQ. 2) JOK = -1
      ENDIF
      IF (JOK .EQ. -1 .AND. MITER .EQ. 1) THEN
      NJE = NJE + 1
      NSLJ = NST
      JCUR = 1
      LENP = N*N
      DO 110 I = 1,LENP
 110    WM(I+2) = ZERO
      CALL JAC (N, TN, Y, 0, 0, WM(3), N, RPAR, IPAR)
      IF (JSV .EQ. 1) CALL DCOPY (LENP, WM(3), 1, WM(LOCJS), 1)
      ENDIF
      IF (JOK .EQ. -1 .AND. MITER .EQ. 2) THEN
      NJE = NJE + 1
      NSLJ = NST
      JCUR = 1
      FAC = DVNORM (N, SAVF, EWT)
      R0 = THOU*ABS(H)*UROUND*REAL(N)*FAC
      IF (R0 .EQ. ZERO) R0 = ONE
      SRUR = WM(1)
      J1 = 2
      DO 230 J = 1,N
        YJ = Y(J)
        R = MAX(SRUR*ABS(YJ),R0/EWT(J))
        Y(J) = Y(J) + R
        FAC = ONE/R
        CALL F (N, TN, Y, FTEM, RPAR, IPAR)
        DO 220 I = 1,N
 220      WM(I+J1) = (FTEM(I) - SAVF(I))*FAC
        Y(J) = YJ
        J1 = J1 + N
 230    CONTINUE
      NFE = NFE + N
      LENP = N*N
      IF (JSV .EQ. 1) CALL DCOPY (LENP, WM(3), 1, WM(LOCJS), 1)
      ENDIF
      IF (JOK .EQ. 1 .AND. (MITER .EQ. 1 .OR. MITER .EQ. 2)) THEN
      JCUR = 0
      LENP = N*N
      CALL DCOPY (LENP, WM(LOCJS), 1, WM(3), 1)
      ENDIF
      IF (MITER .EQ. 1 .OR. MITER .EQ. 2) THEN
      CON = -HRL1
      CALL DSCAL (LENP, CON, WM(3), 1)
      J = 3
      NP1 = N + 1
      DO 250 I = 1,N
        WM(J) = WM(J) + ONE
 250    J = J + NP1
      NLU = NLU + 1
      !CALL DGEFA (WM(3), N, N, IWM(31), IER)
      CALL DGETRF(N,N,WM(3),N,IWM(31),IER)
      IF (IER .NE. 0) IERPJ = 1
      RETURN
      ENDIF
      IF (MITER .EQ. 3) THEN
      NJE = NJE + 1
      JCUR = 1
      WM(2) = HRL1
      R = RL1*PT1
      DO 310 I = 1,N
 310    Y(I) = Y(I) + R*(H*SAVF(I) - YH(I,2))
      CALL F (N, TN, Y, WM(3), RPAR, IPAR)
      NFE = NFE + 1
      DO 320 I = 1,N
        R0 = H*SAVF(I) - YH(I,2)
        DI = PT1*R0 - H*(WM(I+2) - SAVF(I))
        WM(I+2) = ONE
        IF (ABS(R0) .LT. UROUND/EWT(I)) GO TO 320
        IF (ABS(DI) .EQ. ZERO) GO TO 330
        WM(I+2) = PT1*R0/DI
 320    CONTINUE
      RETURN
 330  IERPJ = 1
      RETURN
      ENDIF
      ML = IWM(1)
      MU = IWM(2)
      ML3 = ML + 3
      MBAND = ML + MU + 1
      MEBAND = MBAND + ML
      LENP = MEBAND*N
      IF (JOK .EQ. -1 .AND. MITER .EQ. 4) THEN
      NJE = NJE + 1
      NSLJ = NST
      JCUR = 1
      DO 410 I = 1,LENP
 410    WM(I+2) = ZERO
      CALL JAC (N, TN, Y, ML, MU, WM(ML3), MEBAND, RPAR, IPAR)
      IF (JSV .EQ. 1)
     1   CALL DACOPY (MBAND, N, WM(ML3), MEBAND, WM(LOCJS), MBAND)
      ENDIF
      IF (JOK .EQ. -1 .AND. MITER .EQ. 5) THEN
      NJE = NJE + 1
      NSLJ = NST
      JCUR = 1
      MBA = MIN(MBAND,N)
      MEB1 = MEBAND - 1
      SRUR = WM(1)
      FAC = DVNORM (N, SAVF, EWT)
      R0 = THOU*ABS(H)*UROUND*REAL(N)*FAC
      IF (R0 .EQ. ZERO) R0 = ONE
      DO 560 J = 1,MBA
        DO 530 I = J,N,MBAND
          YI = Y(I)
          R = MAX(SRUR*ABS(YI),R0/EWT(I))
 530      Y(I) = Y(I) + R
        CALL F (N, TN, Y, FTEM, RPAR, IPAR)
        DO 550 JJ = J,N,MBAND
          Y(JJ) = YH(JJ,1)
          YJJ = Y(JJ)
          R = MAX(SRUR*ABS(YJJ),R0/EWT(JJ))
          FAC = ONE/R
          I1 = MAX(JJ-MU,1)
          I2 = MIN(JJ+ML,N)
          II = JJ*MEB1 - ML + 2
          DO 540 I = I1,I2
 540        WM(II+I) = (FTEM(I) - SAVF(I))*FAC
 550      CONTINUE
 560    CONTINUE
      NFE = NFE + MBA
      IF (JSV .EQ. 1)
     1   CALL DACOPY (MBAND, N, WM(ML3), MEBAND, WM(LOCJS), MBAND)
      ENDIF
      IF (JOK .EQ. 1) THEN
      JCUR = 0
      CALL DACOPY (MBAND, N, WM(LOCJS), MBAND, WM(ML3), MEBAND)
      ENDIF
      CON = -HRL1
      CALL DSCAL (LENP, CON, WM(3), 1 )
      II = MBAND + 2
      DO 580 I = 1,N
        WM(II) = WM(II) + ONE
 580    II = II + MEBAND
      NLU = NLU + 1
      !CALL DGBFA (WM(3), MEBAND, N, ML, MU, IWM(31), IER)
      CALL DGBTRF(N,N,ML,MU,WM(3),MEBAND,IWM(31),IER) 
      IF (IER .NE. 0) IERPJ = 1
      RETURN
      END
      SUBROUTINE DACOPY (NROW, NCOL, A, NROWA, B, NROWB)
      DOUBLE PRECISION A, B
      INTEGER NROW, NCOL, NROWA, NROWB
      DIMENSION A(NROWA,NCOL), B(NROWB,NCOL)
      INTEGER IC
      DO 20 IC = 1,NCOL
        CALL DCOPY (NROW, A(1,IC), 1, B(1,IC), 1)
 20     CONTINUE
      RETURN
      END
      SUBROUTINE DVSOL (WM, IWM, X, IERSL)
      DOUBLE PRECISION WM, X
      INTEGER IWM, IERSL
      DIMENSION WM(*), IWM(*), X(*)
      DOUBLE PRECISION ACNRM, CCMXJ, CONP, CRATE, DRC, EL,
     1     ETA, ETAMAX, H, HMIN, HMXI, HNEW, HSCAL, PRL1,
     2     RC, RL1, TAU, TQ, TN, UROUND
      INTEGER ICF, INIT, IPUP, JCUR, JSTART, JSV, KFLAG, KUTH,
     1        L, LMAX, LYH, LEWT, LACOR, LSAVF, LWM, LIWM,
     2        LOCJS, MAXORD, METH, MITER, MSBJ, MXHNIL, MXSTEP,
     3        N, NEWH, NEWQ, NHNIL, NQ, NQNYH, NQWAIT, NSLJ,
     4        NSLP, NYH
      INTEGER I, MEBAND, ML, MU
      DOUBLE PRECISION DI, HRL1, ONE, PHRL1, R, ZERO
      SAVE ONE, ZERO
      COMMON /DVOD01/ ACNRM, CCMXJ, CONP, CRATE, DRC, EL(13),
     1                ETA, ETAMAX, H, HMIN, HMXI, HNEW, HSCAL, PRL1,
     2                RC, RL1, TAU(13), TQ(5), TN, UROUND,
     3                ICF, INIT, IPUP, JCUR, JSTART, JSV, KFLAG, KUTH,
     4                L, LMAX, LYH, LEWT, LACOR, LSAVF, LWM, LIWM,
     5                LOCJS, MAXORD, METH, MITER, MSBJ, MXHNIL, MXSTEP,
     6                N, NEWH, NEWQ, NHNIL, NQ, NQNYH, NQWAIT, NSLJ,
     7                NSLP, NYH
      DATA ONE /1.0D0/, ZERO /0.0D0/
      IERSL = 0
      GO TO (100, 100, 300, 400, 400), MITER
 !100  CALL DGESL (WM(3), N, N, IWM(31), X, 0)
 100  CALL DGETRS('N',N,1,WM(3),N,IWM(31),X,N,INFO)  
      RETURN
 300  PHRL1 = WM(2)
      HRL1 = H*RL1
      WM(2) = HRL1
      IF (HRL1 .EQ. PHRL1) GO TO 330
      R = HRL1/PHRL1
      DO 320 I = 1,N
        DI = ONE - R*(ONE - ONE/WM(I+2))
        IF (ABS(DI) .EQ. ZERO) GO TO 390
 320    WM(I+2) = ONE/DI
 330  DO 340 I = 1,N
 340    X(I) = WM(I+2)*X(I)
      RETURN
 390  IERSL = 1
      RETURN
 400  ML = IWM(1)
      MU = IWM(2)
      MEBAND = 2*ML + MU + 1
      !CALL DGBSL (WM(3), MEBAND, N, ML, MU, IWM(31), X, 0)
      CALL DGBTRS('N',N,ML,MU,1,WM(3),MEBAND,IWM(31),X,N,INFO)
      RETURN
      END
      SUBROUTINE DVSRCO (RSAV, ISAV, JOB)
      DOUBLE PRECISION RSAV
      INTEGER ISAV, JOB
      DIMENSION RSAV(*), ISAV(*)
      DOUBLE PRECISION RVOD1, RVOD2
      INTEGER IVOD1, IVOD2
      INTEGER I, LENIV1, LENIV2, LENRV1, LENRV2
      SAVE LENRV1, LENIV1, LENRV2, LENIV2
      COMMON /DVOD01/ RVOD1(48), IVOD1(33)
      COMMON /DVOD02/ RVOD2(1), IVOD2(8)
      DATA LENRV1/48/, LENIV1/33/, LENRV2/1/, LENIV2/8/
      IF (JOB .EQ. 2) GO TO 100
      DO 10 I = 1,LENRV1
 10     RSAV(I) = RVOD1(I)
      DO 15 I = 1,LENRV2
 15     RSAV(LENRV1+I) = RVOD2(I)
      DO 20 I = 1,LENIV1
 20     ISAV(I) = IVOD1(I)
      DO 25 I = 1,LENIV2
 25     ISAV(LENIV1+I) = IVOD2(I)
      RETURN
 100  CONTINUE
      DO 110 I = 1,LENRV1
 110     RVOD1(I) = RSAV(I)
      DO 115 I = 1,LENRV2
 115     RVOD2(I) = RSAV(LENRV1+I)
      DO 120 I = 1,LENIV1
 120     IVOD1(I) = ISAV(I)
      DO 125 I = 1,LENIV2
 125     IVOD2(I) = ISAV(LENIV1+I)
      RETURN
      END
      SUBROUTINE DEWSET (N, ITOL, RTOL, ATOL, YCUR, EWT)
      DOUBLE PRECISION RTOL, ATOL, YCUR, EWT
      INTEGER N, ITOL
      DIMENSION RTOL(*), ATOL(*), YCUR(N), EWT(N)
      INTEGER I
      GO TO (10, 20, 30, 40), ITOL
 10   CONTINUE
      DO 15 I = 1, N
 15     EWT(I) = RTOL(1)*ABS(YCUR(I)) + ATOL(1)
      RETURN
 20   CONTINUE
      DO 25 I = 1, N
 25     EWT(I) = RTOL(1)*ABS(YCUR(I)) + ATOL(I)
      RETURN
 30   CONTINUE
      DO 35 I = 1, N
 35     EWT(I) = RTOL(I)*ABS(YCUR(I)) + ATOL(1)
      RETURN
 40   CONTINUE
      DO 45 I = 1, N
 45     EWT(I) = RTOL(I)*ABS(YCUR(I)) + ATOL(I)
      RETURN
      END
      DOUBLE PRECISION FUNCTION DVNORM (N, V, W)
      DOUBLE PRECISION V, W
      INTEGER N
      DIMENSION V(N), W(N)
      DOUBLE PRECISION SUM
      INTEGER I
      SUM = 0.0D0
      DO 10 I = 1, N
 10     SUM = SUM + (V(I)*W(I))**2
      DVNORM = SQRT(SUM/REAL(N))
      RETURN
      END
      DOUBLE PRECISION FUNCTION D1MACH (IDUM)
      INTEGER IDUM
      DOUBLE PRECISION U, COMP
      U = 1.0D0
 10   U = U*0.5D0
      COMP = 1.0D0 + U
      IF (COMP .NE. 1.0D0) GO TO 10
      D1MACH = U*2.0D0
      RETURN
      END
      SUBROUTINE XERRWD (MSG, NMES, NERR, LEVEL, NI, I1, I2, NR, R1, R2)
      DOUBLE PRECISION R1, R2
      INTEGER NMES, NERR, LEVEL, NI, I1, I2, NR
      CHARACTER*1 MSG(NMES)
      CHARACTER ERRFIL*20
      COMMON/ERROR/ERRFIL
	COMMON/NXER/NXE
      INTEGER I, LUNIT, LUNSAV, MESFLG, MFLGSV
	NXE = NXE + 1
	GO TO 100
      MESFLG = MFLGSV (0,.FALSE.)
      LUNIT = LUNSAV (0,.FALSE.)
      IF (MESFLG .EQ. 0) GO TO 100
      WRITE (LUNIT,10) (MSG(I),I=1,NMES)
 10   FORMAT(1X,80A1)
      IF (NI .EQ. 1) WRITE (LUNIT, 20) I1
 20   FORMAT(6X,'In above message,  I1 =',I10)
      IF (NI .EQ. 2) WRITE (LUNIT, 30) I1,I2
 30   FORMAT(6X,'In above message,  I1 =',I10,3X,'I2 =',I10)
      IF (NR .EQ. 1) WRITE (LUNIT, 40) R1
 40   FORMAT(6X,'In above message,  R1 =',D21.13)
      IF (NR .EQ. 2) WRITE (LUNIT, 50) R1,R2
 50   FORMAT(6X,'In above,  R1 =',D21.13,3X,'R2 =',D21.13)
 100  IF (LEVEL .NE. 2) RETURN
        OPEN(42,FILE=ERRFIL)
         WRITE(42,51)
   51    FORMAT(/' LEVEL 2 (FATAL) IN SUBROUTINE XERRWD. '/)
        CLOSE(42)
      CALL PAUSE
      STOP
      END
      SUBROUTINE XSETF (MFLAG)
      INTEGER MFLAG, JUNK, MFLGSV
      IF (MFLAG .EQ. 0 .OR. MFLAG .EQ. 1) JUNK = MFLGSV (MFLAG,.TRUE.)
      RETURN
      END
      SUBROUTINE XSETUN (LUN)
      INTEGER LUN, JUNK, LUNSAV
      IF (LUN .GT. 0) JUNK = LUNSAV (LUN,.TRUE.)
      RETURN
      END
      INTEGER FUNCTION MFLGSV (IVALUE, ISET)
      LOGICAL ISET
      INTEGER IVALUE
      INTEGER MESFLG
      SAVE MESFLG
      DATA MESFLG/1/
      MFLGSV = MESFLG
      IF (ISET) MESFLG = IVALUE
      RETURN
      END
      INTEGER FUNCTION LUNSAV (IVALUE, ISET)
      LOGICAL ISET
      INTEGER IVALUE
      INTEGER LUNIT
      SAVE LUNIT
      DATA LUNIT/6/
      LUNSAV = LUNIT
      IF (ISET) LUNIT = IVALUE
      RETURN
      END
      subroutine dgefa(a,lda,n,ipvt,info)
      integer lda,n,ipvt(1),info
      double precision a(lda,1)
      double precision t
      integer idamax,j,k,kp1,l,nm1
      info = 0
      nm1 = n - 1
      if (nm1 .lt. 1) go to 70
      do 60 k = 1, nm1
         kp1 = k + 1
         l = idamax(n-k+1,a(k,k),1) + k - 1
         ipvt(k) = l
         if (a(l,k) .eq. 0.0d0) go to 40
            if (l .eq. k) go to 10
               t = a(l,k)
               a(l,k) = a(k,k)
               a(k,k) = t
   10       continue
            t = -1.0d0/a(k,k)
            call dscal(n-k,t,a(k+1,k),1)
            do 30 j = kp1, n
               t = a(l,j)
               if (l .eq. k) go to 20
                  a(l,j) = a(k,j)
                  a(k,j) = t
   20          continue
               call daxpy(n-k,t,a(k+1,k),1,a(k+1,j),1)
   30       continue
         go to 50
   40    continue
            info = k
   50    continue
   60 continue
   70 continue
      ipvt(n) = n
      if (a(n,n) .eq. 0.0d0) info = n
      return
      end
      subroutine dgesl(a,lda,n,ipvt,b,job)
      integer lda,n,ipvt(1),job
      double precision a(lda,1),b(1)
      double precision ddot,t
      integer k,kb,l,nm1
      nm1 = n - 1
      if (job .ne. 0) go to 50
         if (nm1 .lt. 1) go to 30
         do 20 k = 1, nm1
            l = ipvt(k)
            t = b(l)
            if (l .eq. k) go to 10
               b(l) = b(k)
               b(k) = t
   10       continue
            call daxpy(n-k,t,a(k+1,k),1,b(k+1),1)
   20    continue
   30    continue
         do 40 kb = 1, n
            k = n + 1 - kb
            b(k) = b(k)/a(k,k)
            t = -b(k)
            call daxpy(k-1,t,a(1,k),1,b(1),1)
   40    continue
      go to 100
   50 continue
         do 60 k = 1, n
            t = ddot(k-1,a(1,k),1,b(1),1)
            b(k) = (b(k) - t)/a(k,k)
   60    continue
         if (nm1 .lt. 1) go to 90
         do 80 kb = 1, nm1
            k = n - kb
            b(k) = b(k) + ddot(n-k,a(k+1,k),1,b(k+1),1)
            l = ipvt(k)
            if (l .eq. k) go to 70
               t = b(l)
               b(l) = b(k)
               b(k) = t
   70       continue
   80    continue
   90    continue
  100 continue
      return
      end
      subroutine dgbfa(abd,lda,n,ml,mu,ipvt,info)
      integer lda,n,ml,mu,ipvt(1),info
      double precision abd(lda,1)
      double precision t
      integer i,idamax,i0,j,ju,jz,j0,j1,k,kp1,l,lm,m,mm,nm1
      m = ml + mu + 1
      info = 0
      j0 = mu + 2
      j1 = min0(n,m) - 1
      if (j1 .lt. j0) go to 30
      do 20 jz = j0, j1
         i0 = m + 1 - jz
         do 10 i = i0, ml
            abd(i,jz) = 0.0d0
   10    continue
   20 continue
   30 continue
      jz = j1
      ju = 0
      nm1 = n - 1
      if (nm1 .lt. 1) go to 130
      do 120 k = 1, nm1
         kp1 = k + 1
         jz = jz + 1
         if (jz .gt. n) go to 50
         if (ml .lt. 1) go to 50
            do 40 i = 1, ml
               abd(i,jz) = 0.0d0
   40       continue
   50    continue
         lm = min0(ml,n-k)
         l = idamax(lm+1,abd(m,k),1) + m - 1
         ipvt(k) = l + k - m
         if (abd(l,k) .eq. 0.0d0) go to 100
            if (l .eq. m) go to 60
               t = abd(l,k)
               abd(l,k) = abd(m,k)
               abd(m,k) = t
   60       continue
            t = -1.0d0/abd(m,k)
            call dscal(lm,t,abd(m+1,k),1)
            ju = min0(max0(ju,mu+ipvt(k)),n)
            mm = m
            if (ju .lt. kp1) go to 90
            do 80 j = kp1, ju
               l = l - 1
               mm = mm - 1
               t = abd(l,j)
               if (l .eq. mm) go to 70
                  abd(l,j) = abd(mm,j)
                  abd(mm,j) = t
   70          continue
               call daxpy(lm,t,abd(m+1,k),1,abd(mm+1,j),1)
   80       continue
   90       continue
         go to 110
  100    continue
            info = k
  110    continue
  120 continue
  130 continue
      ipvt(n) = n
      if (abd(m,n) .eq. 0.0d0) info = n
      return
      end
      subroutine dgbsl(abd,lda,n,ml,mu,ipvt,b,job)
      integer lda,n,ml,mu,ipvt(1),job
      double precision abd(lda,1),b(1)
      double precision ddot,t
      integer k,kb,l,la,lb,lm,m,nm1
      m = mu + ml + 1
      nm1 = n - 1
      if (job .ne. 0) go to 50
         if (ml .eq. 0) go to 30
         if (nm1 .lt. 1) go to 30
            do 20 k = 1, nm1
               lm = min0(ml,n-k)
               l = ipvt(k)
               t = b(l)
               if (l .eq. k) go to 10
                  b(l) = b(k)
                  b(k) = t
   10          continue
               call daxpy(lm,t,abd(m+1,k),1,b(k+1),1)
   20       continue
   30    continue
         do 40 kb = 1, n
            k = n + 1 - kb
            b(k) = b(k)/abd(m,k)
            lm = min0(k,m) - 1
            la = m - lm
            lb = k - lm
            t = -b(k)
            call daxpy(lm,t,abd(la,k),1,b(lb),1)
   40    continue
      go to 100
   50 continue
         do 60 k = 1, n
            lm = min0(k,m) - 1
            la = m - lm
            lb = k - lm
            t = ddot(lm,abd(la,k),1,b(lb),1)
            b(k) = (b(k) - t)/abd(m,k)
   60    continue
         if (ml .eq. 0) go to 90
         if (nm1 .lt. 1) go to 90
            do 80 kb = 1, nm1
               k = n - kb
               lm = min0(ml,n-k)
               b(k) = b(k) + ddot(lm,abd(m+1,k),1,b(k+1),1)
               l = ipvt(k)
               if (l .eq. k) go to 70
                  t = b(l)
                  b(l) = b(k)
                  b(k) = t
   70          continue
   80       continue
   90    continue
  100 continue
      return
      end
      subroutine checkd(corden,new,nactveold,ab,maxgrd,nvar,iclose)
      implicit real*8 (a-h,o-z)
      real*8 ab(30,2), corden(maxgrd,1)
      iclose=0
      do ibas=1,nactveold
       sum=0.
       do i=1,nvar
       sum=sum+abs(corden(new,i)-corden(ibas,i))/(ab(i,2)-ab(i,1))
       enddo
      if(sum.le.1.d-4) then
      iclose=1
      return
      endif
      enddo
      return
      end
      subroutine emint(psi,ldpsi,theta,ldtheta,npoint,nsub,ijob,
     &                 x,dx,y,dy,fobj,gap,nvar,keep)
      implicit real*8 (a-h,o-z)
      real*8 mu
      dimension psi(ldpsi,*),theta(ldtheta,*),x(*),dx(*),y(*),dy(*)
      CHARACTER ERRFIL*20
      COMMON/ERROR/ERRFIL
	COMMON/SUPRES/ISUPRES
      parameter (MAXSUBem=999,MAXACTem=10000000)
      dimension w(MAXSUBem),dw(MAXSUBem),Ptx(MAXSUBem),
     &          hess(MAXSUBem,2*MAXSUBem)
      dimension psisum(MAXSUBem)
      integer kpvt(MAXSUBem), ipivot(MAXACTem), list(MAXACTem)
      keep = nactve
      if(nsub.gt.MAXSUBem) then
      write(6,*) 'nsub =',nsub, ' is greater than MAXSUBem=',MAXSUBem
      write(6,*) 'MAXSUBem needs to be reset as large as nsub'
      write(6,*) 'in PARAMETER statement in subroutine emint'
        OPEN(42,FILE=ERRFIL)
      write(42,*) 'nsub =',nsub, ' is greater than MAXSUBem=',MAXSUBem
      write(42,*) 'MAXSUBem needs to be reset as large as nsub'
      write(42,*) 'in PARAMETER statement in subroutine emint'
        CLOSE(42)
      CALL PAUSE
      stop
      endif
      if(npoint.gt.MAXACTem) then
      write(6,*) 'npoint=',npoint,' is larger than MAXACTem=',MAXACTem
      write(6,*) 'MAXACTem needs to be reset as large as npoint'
      write(6,*) 'in PARAMETER statement in subroutine emint'
        OPEN(42,FILE=ERRFIL)
      write(42,*) 'npoint=',npoint,' is larger than MAXACTem=',MAXACTem
      write(42,*) 'MAXACTem needs to be reset as large as npoint'
      write(42,*) 'in PARAMETER statement in subroutine emint'
        CLOSE(42)
      CALL PAUSE
      stop
      endif
      psimin=0.
      do j=1,nsub
      do i=1,npoint
      if(psi(j,i).le.psimin) psimin=psi(j,i)
      enddo
      enddo
      if(psimin.lt.0) then
	  write(6,*) 'Psi matrix not non-negative -stop'
        OPEN(42,FILE=ERRFIL)
	   write(42,*) 'Psi matrix not non-negative -stop'
        CLOSE(42)
	  CALL PAUSE
	  stop
      endif
      colsummin=1.e10
      do j=1,nsub
        s=0.
        do i=1,npoint
           x(i)=1.d0
           s=s+psi(j,i)
        enddo
      psisum(j) = s
        Ptx(j)=s
        if(s.le.colsummin) colsummin=s
        if(s.le.0) then
           write(6,*) 'psi has a zero row -stop'
        OPEN(42,FILE=ERRFIL)
	   write(42,*) 'psi has a zero row -stop'
        CLOSE(42)
	   CALL PAUSE
           stop
        endif
        w(j)=1./s
      enddo
      shrink=0.
      do i=1,npoint
        sum=0.d0
        do j=1,nsub
           sum=sum+psi(j,i)*w(j)
        enddo
        y(i)=sum
        if(sum.gt.shrink) shrink=sum
      enddo
      shrink=2.d0*shrink
      if(s.le.0) then
	  write(6,*) 'Psi has a zero column -stop'
        OPEN(42,FILE=ERRFIL)
	   write(42,*) 'Psi has a zero column -stop'
        CLOSE(42)
	  CALL PAUSE
	  stop
      endif
      eps=1.d-10
      sig=0.d0
      mu=0.d0
      do i=1,npoint
        x(i)=1.d0*shrink
        y(i)=y(i)/shrink
        y(i)=1.d0-y(i)
        mu=mu+x(i)*y(i)
      enddo
      mu=mu/npoint
      rmax = -1.e38
      do j=1,nsub
        w(j)=w(j)/shrink
        Ptx(j)=Ptx(j)*shrink
        if(dabs(1.d0-w(j)*Ptx(j)).ge.rmax) rmax =
     &  dabs(1.d0-w(j)*Ptx(j))
      enddo
      gap=1.d0
      iter=0
100   continue
      if(mu.le.eps.and.rmax.le.eps.and.gap.le.eps) go to 9000
      iter=iter+1
      tbuilda=0
      smu=sig*mu
      do j=1,nsub
        do k=1,nsub
           hess(j,k)=0.
        enddo
      enddo
      do i=1,npoint
        scale=x(i)/y(i)
       do j=1,nsub
         fact=scale*psi(j,i)
         do k=j,nsub
           hess(k,j)=hess(k,j)+fact*psi(k,i)
         enddo
       enddo
      enddo
      do j=1,nsub-1
      do k=j+1,nsub
      hess(j,k)=hess(k,j)
      enddo
      enddo
      do j=1,nsub
        hess(j,j)=hess(j,j)+Ptx(j)/w(j)
      enddo
      tbuildb=0
      tbuild=tbuildb-tbuilda
      IF(ISUPRES .EQ. 0) write(6,*) 'tbuild=',tbuild
      CALL DPOTRF( 'L', nsub, hess, MAXSUBem, INFO )
      tbuildc=0
      tfactor=tbuildc-tbuildb
      IF(ISUPRES .EQ. 0) write(6,*) 'tfactor=',tfactor
      if(info.ne.0) then
      WRITE(*,163)
  163  FORMAT(//' Hessian matrix in interior point EM algorithm'/
     1' is singular.  Possibly number of grid points is too small,'/
     2' or assay coefficients are too large. '//
     3' Try again with a new assay polynomial or larger grid.'//
     4' Suggested quick fix: rerun and select error model 2)'/
     5' in response to the initial question; then enter a'/
     6' initial value gamma = 10.0 in response to the prompt for'/
     7' that value.'/)
        OPEN(42,FILE=ERRFIL)
         WRITE(42,163)
        CLOSE(42)
      CALL PAUSE
      stop
      endif
      do j=1,nsub
        sum=0.d0
        do i=1,npoint
          sum=sum+psi(j,i)*smu/y(i)
        enddo
        dw(j)=1.d0/w(j)-sum
      enddo
      call DPOTRS( 'L', nsub, 1, hess, MAXSUBem, dw, nsub, INFO )
      do i=1,npoint
        sum=0.
        do j=1,nsub
          sum=sum+psi(j,i)*dw(j)
        enddo
        dy(i)=-sum
        dx(i)=smu/y(i)-x(i)-dy(i)*x(i)/y(i)
      enddo
      alfpri=-.5
      do i=1,npoint
        if(dx(i)/x(i).le.alfpri) alfpri=dx(i)/x(i)
      enddo
      alfpri=-1.d0/alfpri
      alfpri=min(1.d0,0.99995*alfpri)
      alfdual=-0.5d0
      do i=1,npoint
        if(dy(i)/y(i).le.alfdual) alfdual=dy(i)/y(i)
      enddo
      alfdual=-1.d0/alfdual
      alfdual=min(1.d0,0.99995*alfdual)
      mu=0.d0
      do i=1,npoint
        x(i)=x(i)+alfpri*dx(i)
        y(i)=y(i)+alfdual*dy(i)
        mu=mu+x(i)*y(i)
      enddo
      mu=mu/npoint
      do j=1,nsub
        sum=0.d0
        do i=1,npoint
          sum=sum+psi(j,i)*x(i)
        enddo
        Ptx(j)=sum
      enddo
      do j=1,nsub
        w(j)=w(j)+alfdual*dw(j)
      enddo
      rmax=0.
      do j=1,nsub
        rtest=1.d0-w(j)*Ptx(j)
        if(dabs(rtest).gt.rmax) rmax=dabs(rtest)
      enddo
      sumlogw=0.d0
      sumlgPtx=0.d0
      do j=1,nsub
        sumlogw=sumlogw+dlog(w(j))
        sumlgPtx=sumlgPtx+dlog(Ptx(j))
      enddo
      gap = dabs(sumlogw+sumlgPtx)/(1.d0+dabs(sumlgPtx))
      if(mu.lt.eps.and.rmax.gt.eps) then
        sig=1.d0
      else
        c2=1.d2
        term1=(1.d0-alfpri)**2
        term2=(1.d0-alfdual)**2
        term3=(rmax-mu)/(rmax+c2*mu)
        term=max(term1,term2)
        term=max(term,term3)
        sig=min(0.3d0,term)
      endif
      sumx=0.d0
      do i=1,npoint
        sumx=sumx+x(i)
      enddo
      fobj=0.
      do j=1,nsub
        fobj=fobj+dlog(Ptx(j)/sumx)
      enddo
      go to 100
9000  continue
      sumx=0.
      do i=1,npoint
      sumx=sumx+x(i)
      enddo
      do i=1,npoint
      x(i)=x(i)/sumx
      enddo
      if(ijob.eq.0) return
      isum=0
      xlim=0.
      do i=1,npoint
      if(x(i).gt.xlim) xlim=x(i)
      enddo
      xlim=xlim*1.d-3
      isum = 0
      do i=1,npoint
      if(x(i).gt.xlim) then
        isum = isum + 1
        list(isum) = i
        do j=1,nsub
        psi(j,isum) = psi(j,i)
        enddo
      do j=1,nvar
      theta(isum,j)=theta(i,j)
      enddo
      x(isum)=x(i)
      endif
      enddo
      job=1
      do k=1,npoint
      ipivot(k)=0
      enddo
      do i=1,isum
      do j=1,nsub
      psi(j,i+isum)=psi(j,i)
      enddo
      enddo
      do i=1,isum
      do j=1,nsub
      psi(j,i) = psi(j,i)/psisum(j)
      enddo
      enddo
      call dqrdc(psi,ldpsi,nsub,isum,y,ipivot,dy,job)
      keep = 0
      limloop = nsub
      if(isum.lt.nsub) limloop = isum
      do i=1,limloop
      test=dnrm2(i,psi(1,i),1)
      if(dabs(psi(i,i)/test).ge.1.d-8) keep=keep+1
      enddo
      if(isum.gt.1) then
      do i=1,keep-1
      do j=i,keep
      if(ipivot(i)*ipivot(j).ne.0.and.ipivot(i).gt.ipivot(j)) then
         itemp=ipivot(i)
         ipivot(i)=ipivot(j)
         ipivot(j)=itemp
      endif
      enddo
      enddo
      endif
      do i=1,isum
      do j=1,nsub
      psi(j,i)=psi(j,i+isum)
      enddo
      enddo
      do k=1,npoint
      dx(k)=0
      enddo
      sumkeep = 0.
      do k=1,keep
      j=ipivot(k)
      if(j.ne.0) then
         do jj=1,nsub
         psi(jj,k)=psi(jj,j)
         enddo
      do jvar=1,nvar
      theta(k,jvar) = theta(j,jvar)
      enddo
      endif
      if(j.gt.0) dx(list(j))=1.
      if(j.gt.0) sumkeep = sumkeep + x(list(j))
      if(j.gt.0) w(k)=x(list(j))
      enddo
      return
      end
      subroutine dpoco(a,lda,n,rcond,z,info)
      integer lda,n,info
      double precision a(lda,1),z(1)
      double precision rcond
      double precision ddot,ek,t,wk,wkm
      double precision anorm,s,dasum,sm,ynorm
      integer i,j,jm1,k,kb,kp1
      do 30 j = 1, n
         z(j) = dasum(j,a(1,j),1)
         jm1 = j - 1
         if (jm1 .lt. 1) go to 20
         do 10 i = 1, jm1
            z(i) = z(i) + dabs(a(i,j))
   10    continue
   20    continue
   30 continue
      anorm = 0.0d0
      do 40 j = 1, n
         anorm = dmax1(anorm,z(j))
   40 continue
      call dpofa(a,lda,n,info)
      if (info .ne. 0) go to 180
         ek = 1.0d0
         do 50 j = 1, n
            z(j) = 0.0d0
   50    continue
         do 110 k = 1, n
            if (z(k) .ne. 0.0d0) ek = dsign(ek,-z(k))
            if (dabs(ek-z(k)) .le. a(k,k)) go to 60
               s = a(k,k)/dabs(ek-z(k))
               call dscal(n,s,z,1)
               ek = s*ek
   60       continue
            wk = ek - z(k)
            wkm = -ek - z(k)
            s = dabs(wk)
            sm = dabs(wkm)
            wk = wk/a(k,k)
            wkm = wkm/a(k,k)
            kp1 = k + 1
            if (kp1 .gt. n) go to 100
               do 70 j = kp1, n
                  sm = sm + dabs(z(j)+wkm*a(k,j))
                  z(j) = z(j) + wk*a(k,j)
                  s = s + dabs(z(j))
   70          continue
               if (s .ge. sm) go to 90
                  t = wkm - wk
                  wk = wkm
                  do 80 j = kp1, n
                     z(j) = z(j) + t*a(k,j)
   80             continue
   90          continue
  100       continue
            z(k) = wk
  110    continue
         s = 1.0d0/dasum(n,z,1)
         call dscal(n,s,z,1)
         do 130 kb = 1, n
            k = n + 1 - kb
            if (dabs(z(k)) .le. a(k,k)) go to 120
               s = a(k,k)/dabs(z(k))
               call dscal(n,s,z,1)
  120       continue
            z(k) = z(k)/a(k,k)
            t = -z(k)
            call daxpy(k-1,t,a(1,k),1,z(1),1)
  130    continue
         s = 1.0d0/dasum(n,z,1)
         call dscal(n,s,z,1)
         ynorm = 1.0d0
         do 150 k = 1, n
            z(k) = z(k) - ddot(k-1,a(1,k),1,z(1),1)
            if (dabs(z(k)) .le. a(k,k)) go to 140
               s = a(k,k)/dabs(z(k))
               call dscal(n,s,z,1)
               ynorm = s*ynorm
  140       continue
            z(k) = z(k)/a(k,k)
  150    continue
         s = 1.0d0/dasum(n,z,1)
         call dscal(n,s,z,1)
         ynorm = s*ynorm
         do 170 kb = 1, n
            k = n + 1 - kb
            if (dabs(z(k)) .le. a(k,k)) go to 160
               s = a(k,k)/dabs(z(k))
               call dscal(n,s,z,1)
               ynorm = s*ynorm
  160       continue
            z(k) = z(k)/a(k,k)
            t = -z(k)
            call daxpy(k-1,t,a(1,k),1,z(1),1)
  170    continue
         s = 1.0d0/dasum(n,z,1)
         call dscal(n,s,z,1)
         ynorm = s*ynorm
         if (anorm .ne. 0.0d0) rcond = ynorm/anorm
         if (anorm .eq. 0.0d0) rcond = 0.0d0
  180 continue
      return
      end
      subroutine dpofa(a,lda,n,info)
      integer lda,n,info
      double precision a(lda,1)
      double precision ddot,t
      double precision s
      integer j,jm1,k
         do 30 j = 1, n
            info = j
            s = 0.0d0
            jm1 = j - 1
            if (jm1 .lt. 1) go to 20
            do 10 k = 1, jm1
               t = a(k,j) - ddot(k-1,a(1,k),1,a(1,j),1)
               t = t/a(k,k)
               a(k,j) = t
               s = s + t*t
   10       continue
   20       continue
            s = a(j,j) - s
            if (s .le. 0.0d0) go to 40
            a(j,j) = dsqrt(s)
   30    continue
         info = 0
   40 continue
      return
      end
      subroutine dposl(a,lda,n,b)
      integer lda,n
      double precision a(lda,1),b(1)
      double precision ddot,t
      integer k,kb
      do 10 k = 1, n
         t = ddot(k-1,a(1,k),1,b(1),1)
         b(k) = (b(k) - t)/a(k,k)
   10 continue
      do 20 kb = 1, n
         k = n + 1 - kb
         b(k) = b(k)/a(k,k)
         t = -b(k)
         call daxpy(k-1,t,a(1,k),1,b(1),1)
   20 continue
      return
      end
      subroutine dsifa(a,lda,n,kpvt,info)
      integer lda,n,kpvt(1),info
      double precision a(lda,1)
      double precision ak,akm1,bk,bkm1,denom,mulk,mulkm1,t
      double precision absakk,alpha,colmax,rowmax
      integer imax,imaxp1,j,jj,jmax,k,km1,km2,kstep,idamax
      logical swap
      alpha = (1.0d0 + dsqrt(17.0d0))/8.0d0
      info = 0
      k = n
   10 continue
         if (k .eq. 0) go to 200
         if (k .gt. 1) go to 20
            kpvt(1) = 1
            if (a(1,1) .eq. 0.0d0) info = 1
            go to 200
   20    continue
         km1 = k - 1
         absakk = dabs(a(k,k))
         imax = idamax(k-1,a(1,k),1)
         colmax = dabs(a(imax,k))
         if (absakk .lt. alpha*colmax) go to 30
            kstep = 1
            swap = .false.
         go to 90
   30    continue
            rowmax = 0.0d0
            imaxp1 = imax + 1
            do 40 j = imaxp1, k
               rowmax = dmax1(rowmax,dabs(a(imax,j)))
   40       continue
            if (imax .eq. 1) go to 50
               jmax = idamax(imax-1,a(1,imax),1)
               rowmax = dmax1(rowmax,dabs(a(jmax,imax)))
   50       continue
            if (dabs(a(imax,imax)) .lt. alpha*rowmax) go to 60
               kstep = 1
               swap = .true.
            go to 80
   60       continue
            if (absakk .lt. alpha*colmax*(colmax/rowmax)) go to 70
               kstep = 1
               swap = .false.
            go to 80
   70       continue
               kstep = 2
               swap = imax .ne. km1
   80       continue
   90    continue
         if (dmax1(absakk,colmax) .ne. 0.0d0) go to 100
            kpvt(k) = k
            info = k
         go to 190
  100    continue
         if (kstep .eq. 2) go to 140
            if (.not.swap) go to 120
               call dswap(imax,a(1,imax),1,a(1,k),1)
               do 110 jj = imax, k
                  j = k + imax - jj
                  t = a(j,k)
                  a(j,k) = a(imax,j)
                  a(imax,j) = t
  110          continue
  120       continue
            do 130 jj = 1, km1
               j = k - jj
               mulk = -a(j,k)/a(k,k)
               t = mulk
               call daxpy(j,t,a(1,k),1,a(1,j),1)
               a(j,k) = mulk
  130       continue
            kpvt(k) = k
            if (swap) kpvt(k) = imax
         go to 190
  140    continue
            if (.not.swap) go to 160
               call dswap(imax,a(1,imax),1,a(1,k-1),1)
               do 150 jj = imax, km1
                  j = km1 + imax - jj
                  t = a(j,k-1)
                  a(j,k-1) = a(imax,j)
                  a(imax,j) = t
  150          continue
               t = a(k-1,k)
               a(k-1,k) = a(imax,k)
               a(imax,k) = t
  160       continue
            km2 = k - 2
            if (km2 .eq. 0) go to 180
               ak = a(k,k)/a(k-1,k)
               akm1 = a(k-1,k-1)/a(k-1,k)
               denom = 1.0d0 - ak*akm1
               do 170 jj = 1, km2
                  j = km1 - jj
                  bk = a(j,k)/a(k-1,k)
                  bkm1 = a(j,k-1)/a(k-1,k)
                  mulk = (akm1*bk - bkm1)/denom
                  mulkm1 = (ak*bkm1 - bk)/denom
                  t = mulk
                  call daxpy(j,t,a(1,k),1,a(1,j),1)
                  t = mulkm1
                  call daxpy(j,t,a(1,k-1),1,a(1,j),1)
                  a(j,k) = mulk
                  a(j,k-1) = mulkm1
  170          continue
  180       continue
            kpvt(k) = 1 - k
            if (swap) kpvt(k) = -imax
            kpvt(k-1) = kpvt(k)
  190    continue
         k = k - kstep
      go to 10
  200 continue
      return
      end
      subroutine dsisl(a,lda,n,kpvt,b)
      integer lda,n,kpvt(1)
      double precision a(lda,1),b(1)
      double precision ak,akm1,bk,bkm1,ddot,denom,temp
      integer k,kp
      k = n
   10 if (k .eq. 0) go to 80
         if (kpvt(k) .lt. 0) go to 40
            if (k .eq. 1) go to 30
               kp = kpvt(k)
               if (kp .eq. k) go to 20
                  temp = b(k)
                  b(k) = b(kp)
                  b(kp) = temp
   20          continue
               call daxpy(k-1,b(k),a(1,k),1,b(1),1)
   30       continue
            b(k) = b(k)/a(k,k)
            k = k - 1
         go to 70
   40    continue
            if (k .eq. 2) go to 60
               kp = iabs(kpvt(k))
               if (kp .eq. k - 1) go to 50
                  temp = b(k-1)
                  b(k-1) = b(kp)
                  b(kp) = temp
   50          continue
               call daxpy(k-2,b(k),a(1,k),1,b(1),1)
               call daxpy(k-2,b(k-1),a(1,k-1),1,b(1),1)
   60       continue
            ak = a(k,k)/a(k-1,k)
            akm1 = a(k-1,k-1)/a(k-1,k)
            bk = b(k)/a(k-1,k)
            bkm1 = b(k-1)/a(k-1,k)
            denom = ak*akm1 - 1.0d0
            b(k) = (akm1*bk - bkm1)/denom
            b(k-1) = (ak*bkm1 - bk)/denom
            k = k - 2
   70    continue
      go to 10
   80 continue
      k = 1
   90 if (k .gt. n) go to 160
         if (kpvt(k) .lt. 0) go to 120
            if (k .eq. 1) go to 110
               b(k) = b(k) + ddot(k-1,a(1,k),1,b(1),1)
               kp = kpvt(k)
               if (kp .eq. k) go to 100
                  temp = b(k)
                  b(k) = b(kp)
                  b(kp) = temp
  100          continue
  110       continue
            k = k + 1
         go to 150
  120    continue
            if (k .eq. 1) go to 140
               b(k) = b(k) + ddot(k-1,a(1,k),1,b(1),1)
               b(k+1) = b(k+1) + ddot(k-1,a(1,k+1),1,b(1),1)
               kp = iabs(kpvt(k))
               if (kp .eq. k) go to 130
                  temp = b(k)
                  b(k) = b(kp)
                  b(kp) = temp
  130          continue
  140       continue
            k = k + 2
  150    continue
      go to 90
  160 continue
      return
      end
      subroutine dqrdc(x,ldx,n,p,qraux,jpvt,work,job)
      integer ldx,n,p,job
      integer jpvt(1)
      double precision x(ldx,1),qraux(1),work(1)
      integer j,jp,l,lp1,lup,maxj,pl,pu
      double precision maxnrm,dnrm2,tt
      double precision ddot,nrmxl,t
      logical negj,swapj
      pl = 1
      pu = 0
      if (job .eq. 0) go to 60
         do 20 j = 1, p
            swapj = jpvt(j) .gt. 0
            negj = jpvt(j) .lt. 0
            jpvt(j) = j
            if (negj) jpvt(j) = -j
            if (.not.swapj) go to 10
               if (j .ne. pl) call dswap(n,x(1,pl),1,x(1,j),1)
               jpvt(j) = jpvt(pl)
               jpvt(pl) = j
               pl = pl + 1
   10       continue
   20    continue
         pu = p
         do 50 jj = 1, p
            j = p - jj + 1
            if (jpvt(j) .ge. 0) go to 40
               jpvt(j) = -jpvt(j)
               if (j .eq. pu) go to 30
                  call dswap(n,x(1,pu),1,x(1,j),1)
                  jp = jpvt(pu)
                  jpvt(pu) = jpvt(j)
                  jpvt(j) = jp
   30          continue
               pu = pu - 1
   40       continue
   50    continue
   60 continue
      if (pu .lt. pl) go to 80
      do 70 j = pl, pu
         qraux(j) = dnrm2(n,x(1,j),1)
         work(j) = qraux(j)
   70 continue
   80 continue
      lup = min0(n,p)
      do 200 l = 1, lup
         if (l .lt. pl .or. l .ge. pu) go to 120
            maxnrm = 0.0d0
            maxj = l
            do 100 j = l, pu
               if (qraux(j) .le. maxnrm) go to 90
                  maxnrm = qraux(j)
                  maxj = j
   90          continue
  100       continue
            if (maxj .eq. l) go to 110
               call dswap(n,x(1,l),1,x(1,maxj),1)
               qraux(maxj) = qraux(l)
               work(maxj) = work(l)
               jp = jpvt(maxj)
               jpvt(maxj) = jpvt(l)
               jpvt(l) = jp
  110       continue
  120    continue
         qraux(l) = 0.0d0
         if (l .eq. n) go to 190
            nrmxl = dnrm2(n-l+1,x(l,l),1)
            if (nrmxl .eq. 0.0d0) go to 180
               if (x(l,l) .ne. 0.0d0) nrmxl = dsign(nrmxl,x(l,l))
               call dscal(n-l+1,1.0d0/nrmxl,x(l,l),1)
               x(l,l) = 1.0d0 + x(l,l)
               lp1 = l + 1
               if (p .lt. lp1) go to 170
               do 160 j = lp1, p
                  t = -ddot(n-l+1,x(l,l),1,x(l,j),1)/x(l,l)
                  call daxpy(n-l+1,t,x(l,l),1,x(l,j),1)
                  if (j .lt. pl .or. j .gt. pu) go to 150
                  if (qraux(j) .eq. 0.0d0) go to 150
                     tt = 1.0d0 - (dabs(x(l,j))/qraux(j))**2
                     tt = dmax1(tt,0.0d0)
                     t = tt
                     tt = 1.0d0 + 0.05d0*tt*(qraux(j)/work(j))**2
                     if (tt .eq. 1.0d0) go to 130
                        qraux(j) = qraux(j)*dsqrt(t)
                     go to 140
  130                continue
                        qraux(j) = dnrm2(n-l,x(l+1,j),1)
                        work(j) = qraux(j)
  140                continue
  150             continue
  160          continue
  170          continue
               qraux(l) = x(l,l)
               x(l,l) = -nrmxl
  180       continue
  190    continue
  200 continue
      return
      end
      SUBROUTINE DPOTRF( UPLO, N, A, LDA, INFO )
      CHARACTER          UPLO
      INTEGER            INFO, LDA, N
      DOUBLE PRECISION   A( LDA, * )
      DOUBLE PRECISION   ONE
      PARAMETER          ( ONE = 1.0D+0 )
      LOGICAL            UPPER
      INTEGER            J, JB, NB
      LOGICAL            LSAME
      EXTERNAL           LSAME
      EXTERNAL           DGEMM, DPOTF2, DSYRK, DTRSM, XERBLA
      INTRINSIC          MAX, MIN
      INFO = 0
      UPPER = LSAME( UPLO, 'U' )
      IF( .NOT.UPPER .AND. .NOT.LSAME( UPLO, 'L' ) ) THEN
         INFO = -1
      ELSE IF( N.LT.0 ) THEN
         INFO = -2
      ELSE IF( LDA.LT.MAX( 1, N ) ) THEN
         INFO = -4
      END IF
      IF( INFO.NE.0 ) THEN
         CALL XERBLA( 'DPOTRF', -INFO )
         RETURN
      END IF
      IF( N.EQ.0 )
     $   RETURN
      nb = 16
      IF( NB.LE.1 .OR. NB.GE.N ) THEN
         CALL DPOTF2( UPLO, N, A, LDA, INFO )
      ELSE
         IF( UPPER ) THEN
            DO 10 J = 1, N, NB
               JB = MIN( NB, N-J+1 )
               CALL DSYRK( 'Upper', 'Transpose', JB, J-1, -ONE,
     $                     A( 1, J ), LDA, ONE, A( J, J ), LDA )
               CALL DPOTF2( 'Upper', JB, A( J, J ), LDA, INFO )
               IF( INFO.NE.0 )
     $            GO TO 30
               IF( J+JB.LE.N ) THEN
                  CALL DGEMM( 'Transpose', 'No transpose', JB, N-J-JB+1,
     $                        J-1, -ONE, A( 1, J ), LDA, A( 1, J+JB ),
     $                        LDA, ONE, A( J, J+JB ), LDA )
                  CALL DTRSM( 'Left', 'Upper', 'Transpose', 'Non-unit',
     $                        JB, N-J-JB+1, ONE, A( J, J ), LDA,
     $                        A( J, J+JB ), LDA )
               END IF
   10       CONTINUE
         ELSE
            DO 20 J = 1, N, NB
               JB = MIN( NB, N-J+1 )
               CALL DSYRK( 'Lower', 'No transpose', JB, J-1, -ONE,
     $                     A( J, 1 ), LDA, ONE, A( J, J ), LDA )
               CALL DPOTF2( 'Lower', JB, A( J, J ), LDA, INFO )
               IF( INFO.NE.0 )
     $            GO TO 30
               IF( J+JB.LE.N ) THEN
                  CALL DGEMM( 'No transpose', 'Transpose', N-J-JB+1, JB,
     $                        J-1, -ONE, A( J+JB, 1 ), LDA, A( J, 1 ),
     $                        LDA, ONE, A( J+JB, J ), LDA )
                  CALL DTRSM( 'Right', 'Lower', 'Transpose', 'Non-unit',
     $                        N-J-JB+1, JB, ONE, A( J, J ), LDA,
     $                        A( J+JB, J ), LDA )
               END IF
   20       CONTINUE
         END IF
      END IF
      GO TO 40
   30 CONTINUE
      INFO = INFO + J - 1
   40 CONTINUE
      RETURN
      END
      SUBROUTINE DPOTRS( UPLO, N, NRHS, A, LDA, B, LDB, INFO )
      CHARACTER          UPLO
      INTEGER            INFO, LDA, LDB, N, NRHS
      DOUBLE PRECISION   A( LDA, * ), B( LDB, * )
      DOUBLE PRECISION   ONE
      PARAMETER          ( ONE = 1.0D+0 )
      LOGICAL            UPPER
      LOGICAL            LSAME
      EXTERNAL           LSAME
      EXTERNAL           DTRSM, XERBLA
      INTRINSIC          MAX
      INFO = 0
      UPPER = LSAME( UPLO, 'U' )
      IF( .NOT.UPPER .AND. .NOT.LSAME( UPLO, 'L' ) ) THEN
         INFO = -1
      ELSE IF( N.LT.0 ) THEN
         INFO = -2
      ELSE IF( NRHS.LT.0 ) THEN
         INFO = -3
      ELSE IF( LDA.LT.MAX( 1, N ) ) THEN
         INFO = -5
      ELSE IF( LDB.LT.MAX( 1, N ) ) THEN
         INFO = -7
      END IF
      IF( INFO.NE.0 ) THEN
         CALL XERBLA( 'DPOTRS', -INFO )
         RETURN
      END IF
      IF( N.EQ.0 .OR. NRHS.EQ.0 )
     $   RETURN
      IF( UPPER ) THEN
         CALL DTRSM( 'Left', 'Upper', 'Transpose', 'Non-unit', N, NRHS,
     $               ONE, A, LDA, B, LDB )
         CALL DTRSM( 'Left', 'Upper', 'No transpose', 'Non-unit', N,
     $               NRHS, ONE, A, LDA, B, LDB )
      ELSE
         CALL DTRSM( 'Left', 'Lower', 'No transpose', 'Non-unit', N,
     $               NRHS, ONE, A, LDA, B, LDB )
         CALL DTRSM( 'Left', 'Lower', 'Transpose', 'Non-unit', N, NRHS,
     $               ONE, A, LDA, B, LDB )
      END IF
      RETURN
      END
      SUBROUTINE DPOTF2( UPLO, N, A, LDA, INFO )
      CHARACTER          UPLO
      INTEGER            INFO, LDA, N
      DOUBLE PRECISION   A( LDA, * )
      DOUBLE PRECISION   ONE, ZERO
      PARAMETER          ( ONE = 1.0D+0, ZERO = 0.0D+0 )
      LOGICAL            UPPER
      INTEGER            J
      DOUBLE PRECISION   AJJ
      LOGICAL            LSAME
      DOUBLE PRECISION   DDOT
      EXTERNAL           LSAME, DDOT
      EXTERNAL           DGEMV, DSCAL, XERBLA
      INTRINSIC          MAX, SQRT
      INFO = 0
      UPPER = LSAME( UPLO, 'U' )
      IF( .NOT.UPPER .AND. .NOT.LSAME( UPLO, 'L' ) ) THEN
         INFO = -1
      ELSE IF( N.LT.0 ) THEN
         INFO = -2
      ELSE IF( LDA.LT.MAX( 1, N ) ) THEN
         INFO = -4
      END IF
      IF( INFO.NE.0 ) THEN
         CALL XERBLA( 'DPOTF2', -INFO )
         RETURN
      END IF
      IF( N.EQ.0 )
     $   RETURN
      IF( UPPER ) THEN
         DO 10 J = 1, N
            AJJ = A( J, J ) - DDOT( J-1, A( 1, J ), 1, A( 1, J ), 1 )
            IF( AJJ.LE.ZERO ) THEN
               A( J, J ) = AJJ
               GO TO 30
            END IF
            AJJ = SQRT( AJJ )
            A( J, J ) = AJJ
            IF( J.LT.N ) THEN
               CALL DGEMV( 'Transpose', J-1, N-J, -ONE, A( 1, J+1 ),
     $                     LDA, A( 1, J ), 1, ONE, A( J, J+1 ), LDA )
               CALL DSCAL( N-J, ONE / AJJ, A( J, J+1 ), LDA )
            END IF
   10    CONTINUE
      ELSE
         DO 20 J = 1, N
            AJJ = A( J, J ) - DDOT( J-1, A( J, 1 ), LDA, A( J, 1 ),
     $            LDA )
            IF( AJJ.LE.ZERO ) THEN
               A( J, J ) = AJJ
               GO TO 30
            END IF
            AJJ = SQRT( AJJ )
            A( J, J ) = AJJ
            IF( J.LT.N ) THEN
               CALL DGEMV( 'No transpose', N-J, J-1, -ONE, A( J+1, 1 ),
     $                     LDA, A( J, 1 ), LDA, ONE, A( J+1, J ), 1 )
               CALL DSCAL( N-J, ONE / AJJ, A( J+1, J ), 1 )
            END IF
   20    CONTINUE
      END IF
      GO TO 40
   30 CONTINUE
      INFO = J
   40 CONTINUE
      RETURN
      END
      LOGICAL          FUNCTION LSAME( CA, CB )
      CHARACTER          CA, CB
      INTRINSIC          ICHAR
      INTEGER            INTA, INTB, ZCODE
      LSAME = CA.EQ.CB
      IF( LSAME )
     $   RETURN
      ZCODE = ICHAR( 'Z' )
      INTA = ICHAR( CA )
      INTB = ICHAR( CB )
      IF( ZCODE.EQ.90 .OR. ZCODE.EQ.122 ) THEN
         IF( INTA.GE.97 .AND. INTA.LE.122 ) INTA = INTA - 32
         IF( INTB.GE.97 .AND. INTB.LE.122 ) INTB = INTB - 32
      ELSE IF( ZCODE.EQ.233 .OR. ZCODE.EQ.169 ) THEN
         IF( INTA.GE.129 .AND. INTA.LE.137 .OR.
     $       INTA.GE.145 .AND. INTA.LE.153 .OR.
     $       INTA.GE.162 .AND. INTA.LE.169 ) INTA = INTA + 64
         IF( INTB.GE.129 .AND. INTB.LE.137 .OR.
     $       INTB.GE.145 .AND. INTB.LE.153 .OR.
     $       INTB.GE.162 .AND. INTB.LE.169 ) INTB = INTB + 64
      ELSE IF( ZCODE.EQ.218 .OR. ZCODE.EQ.250 ) THEN
         IF( INTA.GE.225 .AND. INTA.LE.250 ) INTA = INTA - 32
         IF( INTB.GE.225 .AND. INTB.LE.250 ) INTB = INTB - 32
      END IF
      LSAME = INTA.EQ.INTB
      END
      SUBROUTINE XERBLA( SRNAME, INFO )
      CHARACTER*6        SRNAME
      INTEGER            INFO
      CHARACTER ERRFIL*20
      COMMON/ERROR/ERRFIL
      WRITE( *, FMT = 9999 )SRNAME, INFO
        OPEN(42,FILE=ERRFIL)
      WRITE( 42, FMT = 9999 )SRNAME, INFO
        CLOSE(42)
      CALL PAUSE
      STOP
 9999 FORMAT( ' ** On entry to ', A6, ' parameter number ', I2, ' had ',
     $      'an illegal value' )
      END
      SUBROUTINE DGEMM ( TRANSA, TRANSB, M, N, K, ALPHA, A, LDA, B, LDB,
     $                   BETA, C, LDC )
      CHARACTER*1        TRANSA, TRANSB
      INTEGER            M, N, K, LDA, LDB, LDC
      DOUBLE PRECISION   ALPHA, BETA
      DOUBLE PRECISION   A( LDA, * ), B( LDB, * ), C( LDC, * )
      LOGICAL            LSAME
      EXTERNAL           LSAME
      EXTERNAL           XERBLA
      INTRINSIC          MAX
      LOGICAL            NOTA, NOTB
      INTEGER            I, INFO, J, L, NCOLA, NROWA, NROWB
      DOUBLE PRECISION   TEMP
      DOUBLE PRECISION   ONE         , ZERO
      PARAMETER        ( ONE = 1.0D+0, ZERO = 0.0D+0 )
      NOTA  = LSAME( TRANSA, 'N' )
      NOTB  = LSAME( TRANSB, 'N' )
      IF( NOTA )THEN
         NROWA = M
         NCOLA = K
      ELSE
         NROWA = K
         NCOLA = M
      END IF
      IF( NOTB )THEN
         NROWB = K
      ELSE
         NROWB = N
      END IF
      INFO = 0
      IF(      ( .NOT.NOTA                 ).AND.
     $         ( .NOT.LSAME( TRANSA, 'C' ) ).AND.
     $         ( .NOT.LSAME( TRANSA, 'T' ) )      )THEN
         INFO = 1
      ELSE IF( ( .NOT.NOTB                 ).AND.
     $         ( .NOT.LSAME( TRANSB, 'C' ) ).AND.
     $         ( .NOT.LSAME( TRANSB, 'T' ) )      )THEN
         INFO = 2
      ELSE IF( M  .LT.0               )THEN
         INFO = 3
      ELSE IF( N  .LT.0               )THEN
         INFO = 4
      ELSE IF( K  .LT.0               )THEN
         INFO = 5
      ELSE IF( LDA.LT.MAX( 1, NROWA ) )THEN
         INFO = 8
      ELSE IF( LDB.LT.MAX( 1, NROWB ) )THEN
         INFO = 10
      ELSE IF( LDC.LT.MAX( 1, M     ) )THEN
         INFO = 13
      END IF
      IF( INFO.NE.0 )THEN
         CALL XERBLA( 'DGEMM ', INFO )
         RETURN
      END IF
      IF( ( M.EQ.0 ).OR.( N.EQ.0 ).OR.
     $    ( ( ( ALPHA.EQ.ZERO ).OR.( K.EQ.0 ) ).AND.( BETA.EQ.ONE ) ) )
     $   RETURN
      IF( ALPHA.EQ.ZERO )THEN
         IF( BETA.EQ.ZERO )THEN
            DO 20, J = 1, N
               DO 10, I = 1, M
                  C( I, J ) = ZERO
   10          CONTINUE
   20       CONTINUE
         ELSE
            DO 40, J = 1, N
               DO 30, I = 1, M
                  C( I, J ) = BETA*C( I, J )
   30          CONTINUE
   40       CONTINUE
         END IF
         RETURN
      END IF
      IF( NOTB )THEN
         IF( NOTA )THEN
            DO 90, J = 1, N
               IF( BETA.EQ.ZERO )THEN
                  DO 50, I = 1, M
                     C( I, J ) = ZERO
   50             CONTINUE
               ELSE IF( BETA.NE.ONE )THEN
                  DO 60, I = 1, M
                     C( I, J ) = BETA*C( I, J )
   60             CONTINUE
               END IF
               DO 80, L = 1, K
                  IF( B( L, J ).NE.ZERO )THEN
                     TEMP = ALPHA*B( L, J )
                     DO 70, I = 1, M
                        C( I, J ) = C( I, J ) + TEMP*A( I, L )
   70                CONTINUE
                  END IF
   80          CONTINUE
   90       CONTINUE
         ELSE
            DO 120, J = 1, N
               DO 110, I = 1, M
                  TEMP = ZERO
                  DO 100, L = 1, K
                     TEMP = TEMP + A( L, I )*B( L, J )
  100             CONTINUE
                  IF( BETA.EQ.ZERO )THEN
                     C( I, J ) = ALPHA*TEMP
                  ELSE
                     C( I, J ) = ALPHA*TEMP + BETA*C( I, J )
                  END IF
  110          CONTINUE
  120       CONTINUE
         END IF
      ELSE
         IF( NOTA )THEN
            DO 170, J = 1, N
               IF( BETA.EQ.ZERO )THEN
                  DO 130, I = 1, M
                     C( I, J ) = ZERO
  130             CONTINUE
               ELSE IF( BETA.NE.ONE )THEN
                  DO 140, I = 1, M
                     C( I, J ) = BETA*C( I, J )
  140             CONTINUE
               END IF
               DO 160, L = 1, K
                  IF( B( J, L ).NE.ZERO )THEN
                     TEMP = ALPHA*B( J, L )
                     DO 150, I = 1, M
                        C( I, J ) = C( I, J ) + TEMP*A( I, L )
  150                CONTINUE
                  END IF
  160          CONTINUE
  170       CONTINUE
         ELSE
            DO 200, J = 1, N
               DO 190, I = 1, M
                  TEMP = ZERO
                  DO 180, L = 1, K
                     TEMP = TEMP + A( L, I )*B( J, L )
  180             CONTINUE
                  IF( BETA.EQ.ZERO )THEN
                     C( I, J ) = ALPHA*TEMP
                  ELSE
                     C( I, J ) = ALPHA*TEMP + BETA*C( I, J )
                  END IF
  190          CONTINUE
  200       CONTINUE
         END IF
      END IF
      RETURN
      END
      SUBROUTINE DGEMV ( TRANS, M, N, ALPHA, A, LDA, X, INCX,
     $                   BETA, Y, INCY )
      DOUBLE PRECISION   ALPHA, BETA
      INTEGER            INCX, INCY, LDA, M, N
      CHARACTER*1        TRANS
      DOUBLE PRECISION   A( LDA, * ), X( * ), Y( * )
      DOUBLE PRECISION   ONE         , ZERO
      PARAMETER        ( ONE = 1.0D+0, ZERO = 0.0D+0 )
      DOUBLE PRECISION   TEMP
      INTEGER            I, INFO, IX, IY, J, JX, JY, KX, KY, LENX, LENY
      LOGICAL            LSAME
      EXTERNAL           LSAME
      EXTERNAL           XERBLA
      INTRINSIC          MAX
      INFO = 0
      IF     ( .NOT.LSAME( TRANS, 'N' ).AND.
     $         .NOT.LSAME( TRANS, 'T' ).AND.
     $         .NOT.LSAME( TRANS, 'C' )      )THEN
         INFO = 1
      ELSE IF( M.LT.0 )THEN
         INFO = 2
      ELSE IF( N.LT.0 )THEN
         INFO = 3
      ELSE IF( LDA.LT.MAX( 1, M ) )THEN
         INFO = 6
      ELSE IF( INCX.EQ.0 )THEN
         INFO = 8
      ELSE IF( INCY.EQ.0 )THEN
         INFO = 11
      END IF
      IF( INFO.NE.0 )THEN
         CALL XERBLA( 'DGEMV ', INFO )
         RETURN
      END IF
      IF( ( M.EQ.0 ).OR.( N.EQ.0 ).OR.
     $    ( ( ALPHA.EQ.ZERO ).AND.( BETA.EQ.ONE ) ) )
     $   RETURN
      IF( LSAME( TRANS, 'N' ) )THEN
         LENX = N
         LENY = M
      ELSE
         LENX = M
         LENY = N
      END IF
      IF( INCX.GT.0 )THEN
         KX = 1
      ELSE
         KX = 1 - ( LENX - 1 )*INCX
      END IF
      IF( INCY.GT.0 )THEN
         KY = 1
      ELSE
         KY = 1 - ( LENY - 1 )*INCY
      END IF
      IF( BETA.NE.ONE )THEN
         IF( INCY.EQ.1 )THEN
            IF( BETA.EQ.ZERO )THEN
               DO 10, I = 1, LENY
                  Y( I ) = ZERO
   10          CONTINUE
            ELSE
               DO 20, I = 1, LENY
                  Y( I ) = BETA*Y( I )
   20          CONTINUE
            END IF
         ELSE
            IY = KY
            IF( BETA.EQ.ZERO )THEN
               DO 30, I = 1, LENY
                  Y( IY ) = ZERO
                  IY      = IY   + INCY
   30          CONTINUE
            ELSE
               DO 40, I = 1, LENY
                  Y( IY ) = BETA*Y( IY )
                  IY      = IY           + INCY
   40          CONTINUE
            END IF
         END IF
      END IF
      IF( ALPHA.EQ.ZERO )
     $   RETURN
      IF( LSAME( TRANS, 'N' ) )THEN
         JX = KX
         IF( INCY.EQ.1 )THEN
            DO 60, J = 1, N
               IF( X( JX ).NE.ZERO )THEN
                  TEMP = ALPHA*X( JX )
                  DO 50, I = 1, M
                     Y( I ) = Y( I ) + TEMP*A( I, J )
   50             CONTINUE
               END IF
               JX = JX + INCX
   60       CONTINUE
         ELSE
            DO 80, J = 1, N
               IF( X( JX ).NE.ZERO )THEN
                  TEMP = ALPHA*X( JX )
                  IY   = KY
                  DO 70, I = 1, M
                     Y( IY ) = Y( IY ) + TEMP*A( I, J )
                     IY      = IY      + INCY
   70             CONTINUE
               END IF
               JX = JX + INCX
   80       CONTINUE
         END IF
      ELSE
         JY = KY
         IF( INCX.EQ.1 )THEN
            DO 100, J = 1, N
               TEMP = ZERO
               DO 90, I = 1, M
                  TEMP = TEMP + A( I, J )*X( I )
   90          CONTINUE
               Y( JY ) = Y( JY ) + ALPHA*TEMP
               JY      = JY      + INCY
  100       CONTINUE
         ELSE
            DO 120, J = 1, N
               TEMP = ZERO
               IX   = KX
               DO 110, I = 1, M
                  TEMP = TEMP + A( I, J )*X( IX )
                  IX   = IX   + INCX
  110          CONTINUE
               Y( JY ) = Y( JY ) + ALPHA*TEMP
               JY      = JY      + INCY
  120       CONTINUE
         END IF
      END IF
      RETURN
      END
      SUBROUTINE DSYRK ( UPLO, TRANS, N, K, ALPHA, A, LDA,
     $                   BETA, C, LDC )
      CHARACTER*1        UPLO, TRANS
      INTEGER            N, K, LDA, LDC
      DOUBLE PRECISION   ALPHA, BETA
      DOUBLE PRECISION   A( LDA, * ), C( LDC, * )
      LOGICAL            LSAME
      EXTERNAL           LSAME
      EXTERNAL           XERBLA
      INTRINSIC          MAX
      LOGICAL            UPPER
      INTEGER            I, INFO, J, L, NROWA
      DOUBLE PRECISION   TEMP
      DOUBLE PRECISION   ONE ,         ZERO
      PARAMETER        ( ONE = 1.0D+0, ZERO = 0.0D+0 )
      IF( LSAME( TRANS, 'N' ) )THEN
         NROWA = N
      ELSE
         NROWA = K
      END IF
      UPPER = LSAME( UPLO, 'U' )
      INFO = 0
      IF(      ( .NOT.UPPER               ).AND.
     $         ( .NOT.LSAME( UPLO , 'L' ) )      )THEN
         INFO = 1
      ELSE IF( ( .NOT.LSAME( TRANS, 'N' ) ).AND.
     $         ( .NOT.LSAME( TRANS, 'T' ) ).AND.
     $         ( .NOT.LSAME( TRANS, 'C' ) )      )THEN
         INFO = 2
      ELSE IF( N  .LT.0               )THEN
         INFO = 3
      ELSE IF( K  .LT.0               )THEN
         INFO = 4
      ELSE IF( LDA.LT.MAX( 1, NROWA ) )THEN
         INFO = 7
      ELSE IF( LDC.LT.MAX( 1, N     ) )THEN
         INFO = 10
      END IF
      IF( INFO.NE.0 )THEN
         CALL XERBLA( 'DSYRK ', INFO )
         RETURN
      END IF
      IF( ( N.EQ.0 ).OR.
     $    ( ( ( ALPHA.EQ.ZERO ).OR.( K.EQ.0 ) ).AND.( BETA.EQ.ONE ) ) )
     $   RETURN
      IF( ALPHA.EQ.ZERO )THEN
         IF( UPPER )THEN
            IF( BETA.EQ.ZERO )THEN
               DO 20, J = 1, N
                  DO 10, I = 1, J
                     C( I, J ) = ZERO
   10             CONTINUE
   20          CONTINUE
            ELSE
               DO 40, J = 1, N
                  DO 30, I = 1, J
                     C( I, J ) = BETA*C( I, J )
   30             CONTINUE
   40          CONTINUE
            END IF
         ELSE
            IF( BETA.EQ.ZERO )THEN
               DO 60, J = 1, N
                  DO 50, I = J, N
                     C( I, J ) = ZERO
   50             CONTINUE
   60          CONTINUE
            ELSE
               DO 80, J = 1, N
                  DO 70, I = J, N
                     C( I, J ) = BETA*C( I, J )
   70             CONTINUE
   80          CONTINUE
            END IF
         END IF
         RETURN
      END IF
      IF( LSAME( TRANS, 'N' ) )THEN
         IF( UPPER )THEN
            DO 130, J = 1, N
               IF( BETA.EQ.ZERO )THEN
                  DO 90, I = 1, J
                     C( I, J ) = ZERO
   90             CONTINUE
               ELSE IF( BETA.NE.ONE )THEN
                  DO 100, I = 1, J
                     C( I, J ) = BETA*C( I, J )
  100             CONTINUE
               END IF
               DO 120, L = 1, K
                  IF( A( J, L ).NE.ZERO )THEN
                     TEMP = ALPHA*A( J, L )
                     DO 110, I = 1, J
                        C( I, J ) = C( I, J ) + TEMP*A( I, L )
  110                CONTINUE
                  END IF
  120          CONTINUE
  130       CONTINUE
         ELSE
            DO 180, J = 1, N
               IF( BETA.EQ.ZERO )THEN
                  DO 140, I = J, N
                     C( I, J ) = ZERO
  140             CONTINUE
               ELSE IF( BETA.NE.ONE )THEN
                  DO 150, I = J, N
                     C( I, J ) = BETA*C( I, J )
  150             CONTINUE
               END IF
               DO 170, L = 1, K
                  IF( A( J, L ).NE.ZERO )THEN
                     TEMP      = ALPHA*A( J, L )
                     DO 160, I = J, N
                        C( I, J ) = C( I, J ) + TEMP*A( I, L )
  160                CONTINUE
                  END IF
  170          CONTINUE
  180       CONTINUE
         END IF
      ELSE
         IF( UPPER )THEN
            DO 210, J = 1, N
               DO 200, I = 1, J
                  TEMP = ZERO
                  DO 190, L = 1, K
                     TEMP = TEMP + A( L, I )*A( L, J )
  190             CONTINUE
                  IF( BETA.EQ.ZERO )THEN
                     C( I, J ) = ALPHA*TEMP
                  ELSE
                     C( I, J ) = ALPHA*TEMP + BETA*C( I, J )
                  END IF
  200          CONTINUE
  210       CONTINUE
         ELSE
            DO 240, J = 1, N
               DO 230, I = J, N
                  TEMP = ZERO
                  DO 220, L = 1, K
                     TEMP = TEMP + A( L, I )*A( L, J )
  220             CONTINUE
                  IF( BETA.EQ.ZERO )THEN
                     C( I, J ) = ALPHA*TEMP
                  ELSE
                     C( I, J ) = ALPHA*TEMP + BETA*C( I, J )
                  END IF
  230          CONTINUE
  240       CONTINUE
         END IF
      END IF
      RETURN
      END
      SUBROUTINE DTRSM ( SIDE, UPLO, TRANSA, DIAG, M, N, ALPHA, A, LDA,
     $                   B, LDB )
      CHARACTER*1        SIDE, UPLO, TRANSA, DIAG
      INTEGER            M, N, LDA, LDB
      DOUBLE PRECISION   ALPHA
      DOUBLE PRECISION   A( LDA, * ), B( LDB, * )
      LOGICAL            LSAME
      EXTERNAL           LSAME
      EXTERNAL           XERBLA
      INTRINSIC          MAX
      LOGICAL            LSIDE, NOUNIT, UPPER
      INTEGER            I, INFO, J, K, NROWA
      DOUBLE PRECISION   TEMP
      DOUBLE PRECISION   ONE         , ZERO
      PARAMETER        ( ONE = 1.0D+0, ZERO = 0.0D+0 )
      LSIDE  = LSAME( SIDE  , 'L' )
      IF( LSIDE )THEN
         NROWA = M
      ELSE
         NROWA = N
      END IF
      NOUNIT = LSAME( DIAG  , 'N' )
      UPPER  = LSAME( UPLO  , 'U' )
      INFO   = 0
      IF(      ( .NOT.LSIDE                ).AND.
     $         ( .NOT.LSAME( SIDE  , 'R' ) )      )THEN
         INFO = 1
      ELSE IF( ( .NOT.UPPER                ).AND.
     $         ( .NOT.LSAME( UPLO  , 'L' ) )      )THEN
         INFO = 2
      ELSE IF( ( .NOT.LSAME( TRANSA, 'N' ) ).AND.
     $         ( .NOT.LSAME( TRANSA, 'T' ) ).AND.
     $         ( .NOT.LSAME( TRANSA, 'C' ) )      )THEN
         INFO = 3
      ELSE IF( ( .NOT.LSAME( DIAG  , 'U' ) ).AND.
     $         ( .NOT.LSAME( DIAG  , 'N' ) )      )THEN
         INFO = 4
      ELSE IF( M  .LT.0               )THEN
         INFO = 5
      ELSE IF( N  .LT.0               )THEN
         INFO = 6
      ELSE IF( LDA.LT.MAX( 1, NROWA ) )THEN
         INFO = 9
      ELSE IF( LDB.LT.MAX( 1, M     ) )THEN
         INFO = 11
      END IF
      IF( INFO.NE.0 )THEN
         CALL XERBLA( 'DTRSM ', INFO )
         RETURN
      END IF
      IF( N.EQ.0 )
     $   RETURN
      IF( ALPHA.EQ.ZERO )THEN
         DO 20, J = 1, N
            DO 10, I = 1, M
               B( I, J ) = ZERO
   10       CONTINUE
   20    CONTINUE
         RETURN
      END IF
      IF( LSIDE )THEN
         IF( LSAME( TRANSA, 'N' ) )THEN
            IF( UPPER )THEN
               DO 60, J = 1, N
                  IF( ALPHA.NE.ONE )THEN
                     DO 30, I = 1, M
                        B( I, J ) = ALPHA*B( I, J )
   30                CONTINUE
                  END IF
                  DO 50, K = M, 1, -1
                     IF( B( K, J ).NE.ZERO )THEN
                        IF( NOUNIT )
     $                     B( K, J ) = B( K, J )/A( K, K )
                        DO 40, I = 1, K - 1
                           B( I, J ) = B( I, J ) - B( K, J )*A( I, K )
   40                   CONTINUE
                     END IF
   50             CONTINUE
   60          CONTINUE
            ELSE
               DO 100, J = 1, N
                  IF( ALPHA.NE.ONE )THEN
                     DO 70, I = 1, M
                        B( I, J ) = ALPHA*B( I, J )
   70                CONTINUE
                  END IF
                  DO 90 K = 1, M
                     IF( B( K, J ).NE.ZERO )THEN
                        IF( NOUNIT )
     $                     B( K, J ) = B( K, J )/A( K, K )
                        DO 80, I = K + 1, M
                           B( I, J ) = B( I, J ) - B( K, J )*A( I, K )
   80                   CONTINUE
                     END IF
   90             CONTINUE
  100          CONTINUE
            END IF
         ELSE
            IF( UPPER )THEN
               DO 130, J = 1, N
                  DO 120, I = 1, M
                     TEMP = ALPHA*B( I, J )
                     DO 110, K = 1, I - 1
                        TEMP = TEMP - A( K, I )*B( K, J )
  110                CONTINUE
                     IF( NOUNIT )
     $                  TEMP = TEMP/A( I, I )
                     B( I, J ) = TEMP
  120             CONTINUE
  130          CONTINUE
            ELSE
               DO 160, J = 1, N
                  DO 150, I = M, 1, -1
                     TEMP = ALPHA*B( I, J )
                     DO 140, K = I + 1, M
                        TEMP = TEMP - A( K, I )*B( K, J )
  140                CONTINUE
                     IF( NOUNIT )
     $                  TEMP = TEMP/A( I, I )
                     B( I, J ) = TEMP
  150             CONTINUE
  160          CONTINUE
            END IF
         END IF
      ELSE
         IF( LSAME( TRANSA, 'N' ) )THEN
            IF( UPPER )THEN
               DO 210, J = 1, N
                  IF( ALPHA.NE.ONE )THEN
                     DO 170, I = 1, M
                        B( I, J ) = ALPHA*B( I, J )
  170                CONTINUE
                  END IF
                  DO 190, K = 1, J - 1
                     IF( A( K, J ).NE.ZERO )THEN
                        DO 180, I = 1, M
                           B( I, J ) = B( I, J ) - A( K, J )*B( I, K )
  180                   CONTINUE
                     END IF
  190             CONTINUE
                  IF( NOUNIT )THEN
                     TEMP = ONE/A( J, J )
                     DO 200, I = 1, M
                        B( I, J ) = TEMP*B( I, J )
  200                CONTINUE
                  END IF
  210          CONTINUE
            ELSE
               DO 260, J = N, 1, -1
                  IF( ALPHA.NE.ONE )THEN
                     DO 220, I = 1, M
                        B( I, J ) = ALPHA*B( I, J )
  220                CONTINUE
                  END IF
                  DO 240, K = J + 1, N
                     IF( A( K, J ).NE.ZERO )THEN
                        DO 230, I = 1, M
                           B( I, J ) = B( I, J ) - A( K, J )*B( I, K )
  230                   CONTINUE
                     END IF
  240             CONTINUE
                  IF( NOUNIT )THEN
                     TEMP = ONE/A( J, J )
                     DO 250, I = 1, M
                       B( I, J ) = TEMP*B( I, J )
  250                CONTINUE
                  END IF
  260          CONTINUE
            END IF
         ELSE
            IF( UPPER )THEN
               DO 310, K = N, 1, -1
                  IF( NOUNIT )THEN
                     TEMP = ONE/A( K, K )
                     DO 270, I = 1, M
                        B( I, K ) = TEMP*B( I, K )
  270                CONTINUE
                  END IF
                  DO 290, J = 1, K - 1
                     IF( A( J, K ).NE.ZERO )THEN
                        TEMP = A( J, K )
                        DO 280, I = 1, M
                           B( I, J ) = B( I, J ) - TEMP*B( I, K )
  280                   CONTINUE
                     END IF
  290             CONTINUE
                  IF( ALPHA.NE.ONE )THEN
                     DO 300, I = 1, M
                        B( I, K ) = ALPHA*B( I, K )
  300                CONTINUE
                  END IF
  310          CONTINUE
            ELSE
               DO 360, K = 1, N
                  IF( NOUNIT )THEN
                     TEMP = ONE/A( K, K )
                     DO 320, I = 1, M
                        B( I, K ) = TEMP*B( I, K )
  320                CONTINUE
                  END IF
                  DO 340, J = K + 1, N
                     IF( A( J, K ).NE.ZERO )THEN
                        TEMP = A( J, K )
                        DO 330, I = 1, M
                           B( I, J ) = B( I, J ) - TEMP*B( I, K )
  330                   CONTINUE
                     END IF
  340             CONTINUE
                  IF( ALPHA.NE.ONE )THEN
                     DO 350, I = 1, M
                        B( I, K ) = ALPHA*B( I, K )
  350                CONTINUE
                  END IF
  360          CONTINUE
            END IF
         END IF
      END IF
      RETURN
      END
      subroutine  dcopy(n,dx,incx,dy,incy)
      double precision dx(*),dy(*)
      integer i,incx,incy,ix,iy,m,mp1,n
      if(n.le.0)return
      if(incx.eq.1.and.incy.eq.1)go to 20
      ix = 1
      iy = 1
      if(incx.lt.0)ix = (-n+1)*incx + 1
      if(incy.lt.0)iy = (-n+1)*incy + 1
      do 10 i = 1,n
        dy(iy) = dx(ix)
        ix = ix + incx
        iy = iy + incy
   10 continue
      return
   20 m = mod(n,7)
      if( m .eq. 0 ) go to 40
      do 30 i = 1,m
        dy(i) = dx(i)
   30 continue
      if( n .lt. 7 ) return
   40 mp1 = m + 1
      do 50 i = mp1,n,7
        dy(i) = dx(i)
        dy(i + 1) = dx(i + 1)
        dy(i + 2) = dx(i + 2)
        dy(i + 3) = dx(i + 3)
        dy(i + 4) = dx(i + 4)
        dy(i + 5) = dx(i + 5)
        dy(i + 6) = dx(i + 6)
   50 continue
      return
      end
      subroutine  dscal(n,da,dx,incx)
      double precision da,dx(*)
      integer i,incx,m,mp1,n,nincx
      if( n.le.0 .or. incx.le.0 )return
      if(incx.eq.1)go to 20
      nincx = n*incx
      do 10 i = 1,nincx,incx
        dx(i) = da*dx(i)
   10 continue
      return
   20 m = mod(n,5)
      if( m .eq. 0 ) go to 40
      do 30 i = 1,m
        dx(i) = da*dx(i)
   30 continue
      if( n .lt. 5 ) return
   40 mp1 = m + 1
      do 50 i = mp1,n,5
        dx(i) = da*dx(i)
        dx(i + 1) = da*dx(i + 1)
        dx(i + 2) = da*dx(i + 2)
        dx(i + 3) = da*dx(i + 3)
        dx(i + 4) = da*dx(i + 4)
   50 continue
      return
      end
      subroutine daxpy(n,da,dx,incx,dy,incy)
      double precision dx(*),dy(*),da
      integer i,incx,incy,ix,iy,m,mp1,n
      if(n.le.0)return
      if (da .eq. 0.0d0) return
      if(incx.eq.1.and.incy.eq.1)go to 20
      ix = 1
      iy = 1
      if(incx.lt.0)ix = (-n+1)*incx + 1
      if(incy.lt.0)iy = (-n+1)*incy + 1
      do 10 i = 1,n
        dy(iy) = dy(iy) + da*dx(ix)
        ix = ix + incx
        iy = iy + incy
   10 continue
      return
   20 m = mod(n,4)
      if( m .eq. 0 ) go to 40
      do 30 i = 1,m
        dy(i) = dy(i) + da*dx(i)
   30 continue
      if( n .lt. 4 ) return
   40 mp1 = m + 1
      do 50 i = mp1,n,4
        dy(i) = dy(i) + da*dx(i)
        dy(i + 1) = dy(i + 1) + da*dx(i + 1)
        dy(i + 2) = dy(i + 2) + da*dx(i + 2)
        dy(i + 3) = dy(i + 3) + da*dx(i + 3)
   50 continue
      return
      end
      double precision function ddot(n,dx,incx,dy,incy)
      double precision dx(*),dy(*),dtemp
      integer i,incx,incy,ix,iy,m,mp1,n
      ddot = 0.0d0
      dtemp = 0.0d0
      if(n.le.0)return
      if(incx.eq.1.and.incy.eq.1)go to 20
      ix = 1
      iy = 1
      if(incx.lt.0)ix = (-n+1)*incx + 1
      if(incy.lt.0)iy = (-n+1)*incy + 1
      do 10 i = 1,n
        dtemp = dtemp + dx(ix)*dy(iy)
        ix = ix + incx
        iy = iy + incy
   10 continue
      ddot = dtemp
      return
   20 m = mod(n,5)
      if( m .eq. 0 ) go to 40
      do 30 i = 1,m
        dtemp = dtemp + dx(i)*dy(i)
   30 continue
      if( n .lt. 5 ) go to 60
   40 mp1 = m + 1
      do 50 i = mp1,n,5
        dtemp = dtemp + dx(i)*dy(i) + dx(i + 1)*dy(i + 1) +
     *   dx(i + 2)*dy(i + 2) + dx(i + 3)*dy(i + 3) + dx(i + 4)*dy(i + 4)
   50 continue
   60 ddot = dtemp
      return
      end
      integer function idamax(n,dx,incx)
      double precision dx(*),dmax
      integer i,incx,ix,n
      idamax = 0
      if( n.lt.1 .or. incx.le.0 ) return
      idamax = 1
      if(n.eq.1)return
      if(incx.eq.1)go to 20
      ix = 1
      dmax = dabs(dx(1))
      ix = ix + incx
      do 10 i = 2,n
         if(dabs(dx(ix)).le.dmax) go to 5
         idamax = i
         dmax = dabs(dx(ix))
    5    ix = ix + incx
   10 continue
      return
   20 dmax = dabs(dx(1))
      do 30 i = 2,n
         if(dabs(dx(i)).le.dmax) go to 30
         idamax = i
         dmax = dabs(dx(i))
   30 continue
      return
      end
      subroutine  dswap (n,dx,incx,dy,incy)
      double precision dx(*),dy(*),dtemp
      integer i,incx,incy,ix,iy,m,mp1,n
      if(n.le.0)return
      if(incx.eq.1.and.incy.eq.1)go to 20
      ix = 1
      iy = 1
      if(incx.lt.0)ix = (-n+1)*incx + 1
      if(incy.lt.0)iy = (-n+1)*incy + 1
      do 10 i = 1,n
        dtemp = dx(ix)
        dx(ix) = dy(iy)
        dy(iy) = dtemp
        ix = ix + incx
        iy = iy + incy
   10 continue
      return
   20 m = mod(n,3)
      if( m .eq. 0 ) go to 40
      do 30 i = 1,m
        dtemp = dx(i)
        dx(i) = dy(i)
        dy(i) = dtemp
   30 continue
      if( n .lt. 3 ) return
   40 mp1 = m + 1
      do 50 i = mp1,n,3
        dtemp = dx(i)
        dx(i) = dy(i)
        dy(i) = dtemp
        dtemp = dx(i + 1)
        dx(i + 1) = dy(i + 1)
        dy(i + 1) = dtemp
        dtemp = dx(i + 2)
        dx(i + 2) = dy(i + 2)
        dy(i + 2) = dtemp
   50 continue
      return
      end
      double precision function dasum(n,dx,incx)
      double precision dx(*),dtemp
      integer i,incx,m,mp1,n,nincx
      dasum = 0.0d0
      dtemp = 0.0d0
      if( n.le.0 .or. incx.le.0 )return
      if(incx.eq.1)go to 20
      nincx = n*incx
      do 10 i = 1,nincx,incx
        dtemp = dtemp + dabs(dx(i))
   10 continue
      dasum = dtemp
      return
   20 m = mod(n,6)
      if( m .eq. 0 ) go to 40
      do 30 i = 1,m
        dtemp = dtemp + dabs(dx(i))
   30 continue
      if( n .lt. 6 ) go to 60
   40 mp1 = m + 1
      do 50 i = mp1,n,6
        dtemp = dtemp + dabs(dx(i)) + dabs(dx(i + 1)) + dabs(dx(i + 2))
     *  + dabs(dx(i + 3)) + dabs(dx(i + 4)) + dabs(dx(i + 5))
   50 continue
   60 dasum = dtemp
      return
      end
   !   DOUBLE PRECISION FUNCTION DNRM2 ( N, X, INCX )
   !   INTEGER                           INCX, N
   !   DOUBLE PRECISION                  X( * )
   !   DOUBLE PRECISION      ONE         , ZERO
   !   PARAMETER           ( ONE = 1.0D+0, ZERO = 0.0D+0 )
   !   INTEGER               IX
   !   DOUBLE PRECISION      ABSXI, NORM, SCALE, SSQ
   !   INTRINSIC             ABS, SQRT
   !   IF( N.LT.1 .OR. INCX.LT.1 )THEN
   !      NORM  = ZERO
   !   ELSE IF( N.EQ.1 )THEN
   !      NORM  = ABS( X( 1 ) )
   !   ELSE
   !      SCALE = ZERO
   !      SSQ   = ONE
   !      DO 10, IX = 1, 1 + ( N - 1 )*INCX, INCX
   !         IF( X( IX ).NE.ZERO )THEN
   !            ABSXI = ABS( X( IX ) )
   !            IF( SCALE.LT.ABSXI )THEN
   !               SSQ   = ONE   + SSQ*( SCALE/ABSXI )**2
   !               SCALE = ABSXI
   !            ELSE
   !               SSQ   = SSQ   +     ( ABSXI/SCALE )**2
   !            END IF
   !         END IF
   !10    CONTINUE
   !      NORM  = SCALE * SQRT( SSQ )
   !   END IF
   !   DNRM2 = NORM
   !   RETURN
   !   END
	SUBROUTINE GETNUMEQ(NUMEQT)
	IMPLICIT REAL*8(A-H,O-Z)
	DIMENSION XX(14)
	CHARACTER READLINE*78,ERRFIL*20
      COMMON/ERROR/ERRFIL
	WRITE(*,4)
    4   FORMAT(//' YOUR WORKING COPY FILE WILL NOW BE OPENED TO'/
     1' READ THE NUMBER OF OUTPUT EQUATIONS. LATER, YOU WILL HAVE THE '/
     2' OPTION TO CHANGE YOUR WORKING COPY FILE. IF YOU DO THIS, MAKE '/
     3' SURE THAT THE NEW FILE HAS THE SAME NUMBER OF OUTPUT '/
     4' EQUATIONS.'//)
	CALL PAUSE
   33   FORMAT(A78)
	READ(21,33) READLINE
	IF(READLINE(1:16) .NE. '  LAST AND FIRST') THEN
	 WRITE(*,37)
   37   FORMAT(/' RESTRICTION: THIS PROGRAM CAN ONLY READ WORKING COPY'/
     1'              FILES WHICH HAVE BEEN CREATED BY A RECENT VERSION'/
     2'              (1998 OR NEWER) OF THIS PROGRAM. THESE WORKING '/
     3'              COPY FILES MUST HAVE NAME, AGE, SEX, ETC. INFO '/
     4'              AT THE TOP.'//
     7' 	     YOU ARE TRYING TO USE A WORKING COPY PATIENT DATA'/
     1' 	     FILE WHICH WAS MADE BY AN OLDER VERSION OF THIS'/
     2'		     PROGRAM.'//
     3'		     PLEASE RERUN THE PROGRAM WITH AN APPROPRIATE '/
     4'              PATIENT DATA FILE.'/)
        OPEN(42,FILE=ERRFIL)
         WRITE(42,37)
        CLOSE(42)
       CALL PAUSE
	 STOP
	ENDIF
    3   FORMAT(T2,I5)
   50	READ(21,33) READLINE
      IF(READLINE(12:23) .NE. 'NO. OF TOTAL') GO TO 50
      BACKSPACE(21)
      READ(21,3) NUMEQT
	RETURN
	END
        SUBROUTINE GETDIST(IDIST,NGAUS,NVAR,COF,AMEAN,COV,PATH,NOB,
     1   OUTNPAG,TEXTFILE,OSname,ListDir)
        IMPLICIT REAL*8(A-H,O-Z)
        DIMENSION AMEAN(150,30),COF(150),COV(150,30,30),CORR(30,30),
     1   STD(30),XVERIFY(900)
        CHARACTER OUTNPAG*20,PATH*61,OSname*20,ListDir*10,TEXTFILE*20
      WRITE(*,1)
    1 FORMAT(/' THIS PROGRAM GENERATES SUBJECT VECTORS FROM A'/
     1' SET OF DISTRIBUTIONS WHICH WILL BE INPUT VIA THE KEYBOARD'/
     2' OR FROM THE OUTPUT OF A PREVIOUS NPAG RUN. ')
 2070   WRITE(*,1071)
 1071   FORMAT(/' ENTER 1 IF THE MIXTURE INDICATED ABOVE WILL BE INPUT'/
     1'         VIA THE KEYBOARD; '/
     2' ENTER 2 IF THE MIXTURE WILL COME FROM THE RESULTS OF A BIG'/
     3'         NPAG RUN: ')
        READ(*,*,ERR= 2070) KEYNPAG
        IF(KEYNPAG .NE. 1 .AND. KEYNPAG .NE. 2) GO TO 2070
        IF(KEYNPAG .EQ. 1) THEN
 1030   WRITE(*,1032)
 1032   FORMAT(/' FOR THE MIXTURE INDICATED ABOVE, ENTER THE NUMBER '/
     1' OF DISTRIBUTIONS DESIRED (BETWEEN 1 AND 30): ')
        READ(*,*,ERR=1030) NGAUS
        IF(NGAUS .LT. 1 .OR. NGAUS .GT. 30) GO TO 1030
 4320	WRITE(*,4321)
 4321   FORMAT(/' ENTER 1 TO ENTER INFO IN TERMS OF CORRELATIONS; '/
     1' ENTER 0 TO ENTER INFO IN TERMS OF COVARIANCES: ')
	READ(*,*,ERR=4320) ICORR
	IF(ICORR .NE. 1 .AND. ICORR .NE. 0) GO TO 4320
 1045   WRITE(*,1046)
 1046   FORMAT(/' FOR EACH COMPONENT OF THE MIXTURE, ENTER THE '/
     1' REQUESTED INFORMATION AS PROMPTED ...')
      DO 1100 IGAUS=1,NGAUS
      WRITE(*,1051) IGAUS
 1051 FORMAT(//' FOR MIXTURE COMPONENT NO. ',I3,': ')
      WRITE(*,1052)
 1052 FORMAT(/' ENTER THE WEIGHT: ')
 1055 READ(*,*,ERR=1060) COF(IGAUS)
      IF(COF(IGAUS) .GT. 0.) GO TO 1065
 1060 WRITE(*,1061)
 1061 FORMAT(/' SEE ABOVE; ENTER A POSITIVE REAL NO.: ')
      GO TO 1055
 1065 CONTINUE
	IF(ICORR .EQ. 0) THEN
      WRITE(*,1066)
 1066 FORMAT(/,' ENTER THE PARAMETER MEAN VECTOR: ')
 1070 READ(*,*,ERR=1075) (AMEAN(IGAUS,I),I=1,NVAR)
      GO TO 2080
 1075 WRITE(*,1076) NVAR
 1076 FORMAT(/' SEE ABOVE; ENTER ',I2,' REAL NUMBERS: ')
      GO TO 1070
 2080 WRITE(*,2081)
 2081 FORMAT(/' ENTER 1 TO SELECT A DIAGONAL COV. MATRIX WITH EACH'/
     1' 	STD. DEV. EXACTLY 25% OF THE CORRESPONDING MEAN. THIS'/
     2'		WILL ENSURE THAT NO PARAMETER VALUES ARE NEGATIVE.'/
     3' ENTER 0 TO ENTER A DIFFERENT COV. MATRIX (IN THIS CASE, YOU'/
     4'		WILL HAVE THE RESPONSIBILITY TO MAKE SURE THAT THE'/
     5'		COV. MATRIX IS CHOSEN PROPERLY SO THAT NO PARAMETER'/
     6'		VALUES ARE NEGATIVE: ')
	READ(*,*,ERR=2080) ICMAT
	IF(ICMAT .NE. 0 .AND. ICMAT .NE. 1) GO TO 2080
	 DO I = 1,NVAR
	  DO J = 1,NVAR
	   COV(IGAUS,I,J) = 0.D0
	  END DO
	 END DO
	IF(ICMAT .EQ. 1) THEN
	 DO I = 1,NVAR
	  COV(IGAUS,I,I) = (.25D0*AMEAN(IGAUS,I))**2.D0
	 END DO
	ENDIF
	IF(ICMAT .EQ. 0) THEN
 	 WRITE(*,1081)
 1081    FORMAT(/,' ENTER, ROW x ROW, LOWER-TRI PART OF THE COV MATRIX')
         DO 1095 I=1,NVAR
          WRITE(*,1086)I
 1085     READ(*,*,ERR=1090) (COV(IGAUS,I,J),J=1,I)
          GO TO 1095
 1090     WRITE(*,1076) I
          GO TO 1085
 1095    CONTINUE
 1086    FORMAT(' ',' ROW ',I3,' : ')
	ENDIF
	ENDIF
	IF(ICORR .EQ. 1) THEN
 3065 WRITE(*,3066)
 3066 FORMAT(/,' ENTER EACH PARAMETER MEAN AND STD. DEV. AS PROMPTED: ')
	DO I = 1,NVAR
 3070	 WRITE(*,3067) I
 3067    FORMAT(/' MEAN AND STD. DEV. FOR PARAMETER NO. ',I3,': ')
	 READ(*,*,ERR=3070) AMEAN(IGAUS,I),STD(I)
	END DO
 3080 WRITE(*,3081)
 3081 FORMAT(/,' ENTER, ROW x ROW, THE LOWER-TRI PART OF THE CORR '/
     1' MATRIX. RECALL THAT EACH DIAGONAL VALUE MUST BE 1.0 ')
      DO I=1,NVAR
 3090  WRITE(*,3086) I
 3085  READ(*,*,ERR=3090) (CORR(I,J),J=1,I)
      END DO
 3086 FORMAT(' ',' ROW ',I3,': ')
	 DO I = 1,NVAR
	  DO J = 1,I
	   COV(IGAUS,I,J) = CORR(I,J)*STD(I)*STD(J)
	  END DO
	 END DO
	ENDIF
 1100 CONTINUE
      SUMCOF=0.D0
      DO 1110 IGAUS=1,NGAUS
 1110 SUMCOF=SUMCOF+COF(IGAUS)
      DO 1115 IGAUS=1,NGAUS
 1115 COF(IGAUS)=COF(IGAUS)/SUMCOF
        DO I = 1,NGAUS
         XVERIFY(I) = COF(I)
        END DO
        CALL VERIFYVAL(NGAUS,XVERIFY)
        WRITE(*,1116) (XVERIFY(IXV),IXV=1,NGAUS)
 1116 FORMAT(/' THE NORMALIZED COEFFICIENTS ARE: ',150F8.4)
        ENDIF
      IF(KEYNPAG .EQ. 2) THEN
 3010    WRITE(*,2)
    2    FORMAT(/' ENTER 1 IF EACH OF THE ACTIVE GRID PTS. WILL BE'/
     4'         A DISTRIBUTION WITH THE COORDINATES OF EACH GRID PT.'/
     5'         BEING THE MEAN OF THE DISTRIBUTION, AND THE PROB. OF'/
     6'         THE GRID PT. BEING THE WEIGHT. ALSO, THE COV. OF EACH'/
     7'         DIST. WILL BE THE FINAL CYCLE COV. MATRIX, DIVIDED BY'/
     8'         THE NO. OF ACTIVE PTS.); '/
     9' ENTER 2 IF EACH OF THE ACTIVE GRID PTS. WILL BE USED ONCE EACH'/
     1'         AS THE PARAMETER SET FOR A SIMULATED SUBJECT: ')
       READ(*,*,ERR=3010) KKEY
       IF(KKEY .NE. 1 .AND. KKEY .NE. 2) GO TO 3010
        CALL READNPAG(NGAUS,KKEY,NVAR,COF,AMEAN,COV,PATH,NOB,OUTNPAG,
     1   TEXTFILE,OSname,ListDir)
      ENDIF
       IF(KKEY .EQ. 2) KEYNPAG = 3
        IF(KEYNPAG .EQ. 3) IDIST = 0
        IF(KEYNPAG .EQ. 1 .OR. KEYNPAG .EQ. 2) THEN
 2040   WRITE(*,2031)
 2031   FORMAT(/' THIS PROGRAM GENERATES SUBJECT VECTORS FROM A'/
     1' DISTRIBUTION WHICH IS A MIXTURE OF GAUSSIAN DISTRIBUTIONS '/
     2' OR LOGNORMAL DISTRIBUTIONS. '/
     3' ENTER 1 FOR GAUSSIAN DISTRIBUTIONS;'/
     4' ENTER 2 FOR LOGNORMAL DISTRIBUTIONS: ')
	READ(*,*,ERR=2040) IDIST
	IF(IDIST .NE. 1 .AND. IDIST .NE. 2) GO TO 2040
      ENDIF
        RETURN
        END
        SUBROUTINE STAT2(NSUB,M,NOS,YPREDSUB,YMEAN,YMIN,YMAX,YSD,Y025,
     1   Y25,Y50,Y75,Y975)
        IMPLICIT REAL*8(A-H,O-Z)
	PARAMETER(MAXNUMEQ=7)
        DIMENSION YPREDSUB(10000,594,MAXNUMEQ),YMEAN(594,MAXNUMEQ),
     1   YMIN(594,MAXNUMEQ),YMAX(594,MAXNUMEQ),YSD(594,MAXNUMEQ),
     2   Y025(594,MAXNUMEQ),Y25(594,MAXNUMEQ),Y50(594,MAXNUMEQ),
     3   Y75(594,MAXNUMEQ),Y975(594,MAXNUMEQ),X(10000)
	  IF(NSUB .EQ. 1) THEN
	   WRITE(23,101)
  101      FORMAT(/' SINCE NSUB = 1, SUBROUTINE STAT2 WILL CALCULATE'/
     1' NOTHING.')
	   RETURN
	  ENDIF
	DO IM = 1,M
	 DO IN = 1,NOS
	  DO ISUB = 1,NSUB
	   X(ISUB) = YPREDSUB(ISUB,IM,IN)
	  END DO
	  SUM = 0.D0
	  SUMSQ = 0.D0
	   DO ISUB = 1,NSUB
	    SUM = SUM + X(ISUB)
	    SUMSQ = SUMSQ + X(ISUB)*X(ISUB)
	   END DO
	  YMEAN(IM,IN) = SUM/NSUB
	  XBAR = YMEAN(IM,IN)
	  ARG = (SUMSQ - NSUB*XBAR*XBAR)/(NSUB - 1.D0)
	  IF(ARG .LT. 0.D0) ARG = 0.D0
	  YSD(IM,IN) = DSQRT(ARG)
	  CALL PERCENT(NSUB,X,XMIN,XMAX,X025,X25,X50,X75,X975)
	   YMIN(IM,IN) = XMIN
	   YMAX(IM,IN) = XMAX
	   Y025(IM,IN) = X025
	    Y25(IM,IN) = X25
	    Y50(IM,IN) = X50
 	    Y75(IM,IN) = X75
	   Y975(IM,IN) = X975
	 END DO
	END DO
      RETURN
      END
	SUBROUTINE PERCENT(NSUB,X,XMIN,XMAX,X025,X25,X50,X75,X975)
        IMPLICIT REAL*8(A-H,O-Z)
        DIMENSION X(10000),XI(10001),CUMPROP(0:10000),NUM(10000)
	XMAX = -1.D30
	XMIN =  1.D30
	DO ISUB = 1,NSUB
	 IF(X(ISUB) .GT. XMAX) XMAX = X(ISUB)
	 IF(X(ISUB) .LT. XMIN) XMIN = X(ISUB)
	END DO
	XINT=(XMAX - XMIN)/10000.D0
	XI(1) = XMIN
	XI(10001) = XMAX
	DO I = 1, 9999
         XI(I+1) = XI(I) + XINT
	END DO
	DO INTR = 1,10000
	 N = 0
	  DO ISUB = 1,NSUB
	   XX = X(ISUB)
	   IF(XX .GE. XI(INTR) .AND. XX .LT. XI(INTR+1)) N = N + 1
	   IF(INTR .EQ. 10000 .AND. XX .GE. XI(INTR+1)) N = N + 1
	  END DO
	 NUM(INTR) = N
	END DO
	CUMPROP(0)=0.D0
	DO INTR = 1,10000
	 CUMPROP(INTR) = CUMPROP(INTR-1) + 1.D0*NUM(INTR)/NSUB
	 IF(CUMPROP(INTR-1) .LT. .025D0 .AND. CUMPROP(INTR) .GE. .025D0)
     1    IND025=INTR
	 IF(CUMPROP(INTR-1) .LT. .25D0 .AND. CUMPROP(INTR) .GE. .25D0)
     1    IND25=INTR
	 IF(CUMPROP(INTR-1) .LT. .50D0 .AND. CUMPROP(INTR) .GE. .50D0)
     1    IND50=INTR
	 IF(CUMPROP(INTR-1) .LT. .75D0 .AND. CUMPROP(INTR) .GE. .75D0)
     1    IND75=INTR
	 IF(CUMPROP(INTR-1) .LT. .975D0 .AND. CUMPROP(INTR) .GE. .975D0)
     1    IND975=INTR
	END DO
	X025 = XI(IND025) + (XI(IND025+1)-XI(IND025))*
     1  (.025D0-CUMPROP(IND025-1))/(CUMPROP(IND025)-CUMPROP(IND025-1))
	X25 = XI(IND25)+(XI(IND25+1)-XI(IND25))*
     1  (.25D0-CUMPROP(IND25-1))/(CUMPROP(IND25)-CUMPROP(IND25-1))
	X50 = XI(IND50)+(XI(IND50+1)-XI(IND50))*
     1  (.50D0-CUMPROP(IND50-1))/(CUMPROP(IND50)-CUMPROP(IND50-1))
	X75 = XI(IND75)+(XI(IND75+1)-XI(IND75))*
     1  (.75D0-CUMPROP(IND75-1))/(CUMPROP(IND75)-CUMPROP(IND75-1))
	X975 = XI(IND975)+(XI(IND975+1)-XI(IND975))*
     1  (.975D0-CUMPROP(IND975-1))/(CUMPROP(IND975)-CUMPROP(IND975-1))
	RETURN
	END
	SUBROUTINE EXPLAINOISE
   20	WRITE(*,1)
    1   FORMAT(/' THE DOSE TIMES, DOSE AMOUNTS, AND OBSERVATION '/
     1' TIMES ARE MADE "NOISY" USING THE COEFFICIENTS YOU ENTER FOR'/
     2' EACH SET.'//
     3' ENTER 1 FOR NO MORE DETAIL;'/
     4' ENTER 2 FOR AN EXPLANATION OF THE "NOISY" DOSE TIMES AND'/
     4'         "NOISY" OBS. TIMES;'/
     4' ENTER 3 FOR AN EXPLANATION OF THE "NOISY" DOSE AMOUNTS: ')
	READ(*,*,ERR=20) IEXP
	IF(IEXP .NE. 1 .AND. IEXP .NE. 2 .AND. IEXP .NE. 3) GO TO 20
	IF(IEXP .EQ. 1) RETURN
	IF(IEXP .EQ. 2) WRITE(*,12)
	IF(IEXP .EQ. 3) WRITE(*,13)
	GO TO 20
   12   FORMAT(/' EACH DOSE TIME IS MADE "NOISY" AS FOLLOWS:'/
     1' THE FIRST DOSE TIME, WITH A TRUE VALUE OF VTRUE, WILL BE '/
     2' CHANGED TO BE VNOISY, WHERE VNOISY = VTRUE + Ei, WHERE'/
     3' Ei ~ N(0,STDI**2), WHERE '/
     4' STDI = C0 + C1*VTRUE + C2*VTRUE**2 + C3*VTRUE**3'//
     5' FOR SUBSEQUENT DOSE TIMES, THE NOISY DOSE TIME IS '/
     6' DETERMINED AS FOLLOWS:'/
     7' a. SET DUR = NOMINAL DURATION BETWEEN THE PREVIOUS DOSE TIME '/
     8'    AND THE CURRENT DOSE TIME.'/
     3' b. CALC. THE NOISY DURATION, DURNOISY, AS '/
     4'    DURNOISY = DUR + Ei, Ei ~ N(0,STDI**2), WHERE '/
     7'    STDI = C0 + C1*DUR + C2*DUR**2 + C3*DUR**3'/
     8' c. ... BUT LIMIT DURNOISY TO BE .GE. .5*DUR AND .LE. 2*DUR.'/
     9' d. SET THE CURRENT NOISY DOSE TIME = PREVIOUS NOISY DOSE TIME'/
     1'    + DURNOISY.'//
     2' THE SAME LOGIC APPLIES FOR OBS. TIMES. '//
     3' NOTE THIS LOGIC --> TIMES CANNOT BE OUT OF ORDER.')
   13   FORMAT(/' EACH IV RATE AND EACH BOLUS VALUE WHICH = 0 WILL NOT'/
     1' BE MADE NOISY. I.E., IT IS ASSUMED THAT IF A RATE OR BOLUS IS'/
     2' INTENDED TO BE 0, IT WILL BE ACHIEVED WITHOUT ERROR.'
     2/
     3' A NON-ZERO IV OR BOLUS VALUE, WITH A TRUE VALUE OF VTRUE, '/
     4' WILL BE CHANGED TO BE VNOISY, WHERE VNOISY = VTRUE + Ei, WHERE'/
     6' Ei ~ N(0,STDI**2), WHERE '/
     7' STDI = C0 + C1*VTRUE + C2*VTRUE**2 + C3*VTRUE**3')
	END
        SUBROUTINE READNPAG(NGAUS,KKEY,NVAR,COF,AMEAN,COV,PATH,NOB,
     1   OUTNPAG,TEXTFILE,OSname,ListDir)
        IMPLICIT REAL*8(A-H,O-Z)
        DIMENSION AMEAN(150,30),COF(150),COV(150,30,30),COVV(30,30),
     1   VALFIX(20),RANFIXEST(20)
        CHARACTER OUTNPAG*20,PATH*61,TMPFILE*32,PATHFILE*93,READLIN2*78,
     1   READLINE*1000,OSname*20,ListDir*10,TEXTFILE*20,ERRFIL*20
      COMMON/ERROR/ERRFIL
    1   FORMAT(A20)
      IF(KKEY .EQ. 2) THEN
  180  WRITE(*,6321)
 6321  FORMAT(//' ENTER 1 TO INPUT THE ACTIVE GRID PTS. MANUALLY;'/
     1' ENTER 2 TO INPUT THE ACTIVE GRID PTS. FROM THE OUTPUT FILE'/
     2'         OF AN NPAG RUN;'/
     3' ENTER 3 TO INPUT THE ACTIVE GRID PTS. FROM A SIMPLE TEXT FILE: '
     4)
       READ(*,*,ERR=180) INHOW
       IF(INHOW .NE. 1 .AND. INHOW .NE. 2 .AND. INHOW .NE. 3) GO TO 180
       IF(INHOW .EQ. 2) GO TO 170
  280   WRITE(*,6322)
 6322   FORMAT(/' ENTER THE NO. OF ACTIVE GRID PTS. THIS NUMBER MUST'/
     1' BE .LE. 150: ')
        READ(*,*,ERR=280) NGAUS
        IF(NGAUS .LT. 1 .OR. NGAUS .GT. 150) GO TO 280
       IF(INHOW .EQ. 1) THEN
        WRITE(*,6323) NGAUS,NVAR
 6323   FORMAT(/' ENTER ',I4,' ROWS OF PARAMETER VALUES. EACH ROW MUST'/
     1' HAVE THE ',I3,' PARAMETER VALUES FOR THAT GRID PT. '//)
        DO IGAUS = 1,NGAUS
  220    WRITE(*,6324) NVAR,IGAUS
 6324    FORMAT(' ENTER ',I3,' PAR. VALUES FOR GRID PT. ',I4,': ')
         READ(*,*,ERR=220) (AMEAN(IGAUS,J),J=1,NVAR)
        END DO
        GO TO 260
       ENDIF
       IF(INHOW .EQ. 3) THEN
  230   WRITE(*,6326) NGAUS,NVAR
 6326   FORMAT(/' ENTER THE NAME OF THE TEXT FILE WHICH HAS A MATRIX'/
     1' OF ',I4,' ROWS OF PARAMETER VALUES, EACH ROW HAVING THE ',I3/
     2' PARAMETER VALUES FOR A GRID PT.: ')
        WRITE(*,*)' ENTER -99 TO SEE ALL OR A PART OF YOUR DIRECTORY: '
        READ(*,1) TEXTFILE
        IF(TEXTFILE(1:3) .EQ. '-99') CALL SEEDIR(PATH,NOB,TEXTFILE,
     1     OSName,ListDir)
     	  TMPFILE = ' '
        TMPFILE = TEXTFILE
        CALL FULLNAME(PATH,TMPFILE,PATHFILE)
        OPEN(45,FILE=PATHFILE,STATUS='OLD',ERR=250)
        GO TO 240
  250   WRITE(*,5316) PATHFILE
        GO TO 230
  240   DO IGAUS = 1,NGAUS
         READ(45,*) (AMEAN(IGAUS,J),J=1,NVAR)
        END DO
        CLOSE(45)
        GO TO 260
       ENDIF
      ENDIF
  170   WRITE(*,5321)
 5321   FORMAT(//' ENTER THE NAME OF A "COMBINED" OUTPUT FILE FROM A'/
     1' PREVIOUS RUN.'//
     4' IT WILL BE OF THE FORM OUTxxxx, WHERE xxxx WAS THE JOB NUMBER'/
     5' ASSIGNED TO THE RUN.'//)
        WRITE(*,*)' ENTER -99 TO SEE ALL OR A PART OF YOUR DIRECTORY: '
        READ(*,1) OUTNPAG
        IF(OUTNPAG(1:3) .EQ. '-99') CALL SEEDIR(PATH,NOB,OUTNPAG,
     1     OSName,ListDir)
        CALL PAUSE
     	TMPFILE = ' '
	TMPFILE = OUTNPAG
	CALL FULLNAME(PATH,TMPFILE,PATHFILE)
	OPEN(45,FILE=PATHFILE,STATUS='OLD',ERR=95)
	GO TO 210
   95   WRITE(*,5316) PATHFILE
 5316   FORMAT(//' THE FOLLOWING FILE DOES NOT EXIST ... '/
     1'    ',A73)
	GO TO 170
  210   IVER=0
        READ(45,2) READLINE
        IF(READLINE(2:11) .EQ. 'VERSION 36') IVER=36
        IF(READLINE(2:11) .EQ. 'VERSION 37') IVER=37
        IF(READLINE(2:11) .EQ. 'VERSION 38') IVER=38
        IF(READLINE(2:11) .EQ. 'VERSION 39') IVER=39
        IF(READLINE(2:11) .EQ. 'VERSION 40') IVER=40
        IF(READLINE(2:11) .EQ. 'VERSION 41') IVER=41
        IF(READLINE(2:11) .EQ. 'VERSION 42') IVER=42
        IF(READLINE(2:11) .EQ. 'VERSION 43') IVER=43
        IF(IVER .EQ. 0) THEN
         WRITE(*,3013)
 3013    FORMAT(//' YOUR OUTPUT FILE IS NOT A "COMBINED" OUTPUT FILE'/
     1' AS REQUIRED BY THIS PROGRAM. SUCH A FILE WILL HAVE A VERSION '/
     2' NO. OF AT LEAST 36 ON THE FIRST LINE.')
         GO TO 170
        ENDIF
   70   READ(45,2) READLINE
        IF(READLINE(1:21) .NE. ' THE RANDOM VARIABLES') GO TO 70
        READ(45,2) READLINE
        NVARR = 0
   80   READ(45,2) READLINE
        IF(READLINE(13:13) .EQ. ':') THEN
         NVARR = NVARR + 1
         GO TO 80
        ENDIF
        IF(READLINE(1:9) .EQ. ' THE USER') GO TO 100
        IF(READLINE(1:9) .EQ. ' NO FIXED') GO TO 100
        GO TO 80
  100   IF(NVARR .NE. NVAR) THEN
         WRITE(*,81) NVARR,NVAR,NVAR
   81    FORMAT(/' THE NO. OF RANDOM VARIABLES IN YOUR OUTPUT FILE'/
     1' IS ',I3,'. THIS IS DIFFERENT THAN THE NO. YOU ENTERED ABOVE,'/
     2' ... ',I3,'. PLEASE ENTER AN OUTPUT FILE WITH ',I3,' RANDOM'/
     3' VARIABLES.')
         GO TO 170
        ENDIF
      WRITE(*,*)
      WRITE(*,*)
      WRITE(*,*)' THE FOLLOWING INFO SUMMARIZES THE INPUT INSTRUCTIONS'
      WRITE(*,*)' FOR THE RUN WHOSE OUTPUT FILE YOU JUST ENTERED: '
      WRITE(*,*)
        ILINES=3
    2   FORMAT(A1000)
  202   FORMAT(A78)
  150	READ(45,202) READLIN2
	ILINES=ILINES+1
	WRITE(*,1102) READLIN2
 1102   FORMAT(' ',A78)
	IF(ILINES .EQ. 20) THEN
	  ILINES=0
	ENDIF
	IF(READLIN2(5:15) .NE. '***********') GO TO 150
  160	WRITE(*,12)
   12   FORMAT(//' ENTER 1 IF THE OUTPUT FILE DESCRIBED ABOVE IS THE'/
     1'         ONE FROM THE RUN FROM WHICH YOU WISH TO INPUT THE '/
     2'         DISTRIBUTION MIXTURE FOR THIS RUN;'/
     3' ENTER 0 IF YOU WISH TO ENTER ANOTHER OUTPUT FILE: ')
	READ(*,*,ERR=160) IANOT
	IF(IANOT .NE. 0 .AND. IANOT .NE. 1) GO TO 160
	IF(IANOT .EQ. 0) THEN
	  CLOSE(45)
	  GO TO 170
	ENDIF
        CLOSE(45)
        OPEN(45,FILE=PATHFILE,POSITION='APPEND')
   30	  BACKSPACE(45)
	  BACKSPACE(45)
	  READ(45,2) READLINE
	  IF(READLINE(1:10) .NE. ' CYCLE NO.') GO TO 30
   40   READ(45,2) READLINE
        IF(READLINE(1:15) .EQ. ' THE COV MATRIX') GO TO 50
        IF(READLINE(1:15) .EQ. ' THE VARIANCE F' .AND. KKEY .EQ. 1)
     1   GO TO 60
        IF(READLINE(1:15) .EQ. ' THE VARIANCE F' .AND. KKEY .EQ. 2)
     1   GO TO 90
        GO TO 40
   50   READ(45,2) READLINE
        DO IVAR = 1,NVAR
         READ(45,*) (COVV(IVAR,J),J=1,IVAR)
        END DO
        ICOVMAT = 1
        GO TO 90
   60   WRITE(*,61)
   61 FORMAT(/' YOUR OUTPUT FILE HAS NO FINAL CYCLE COV. MATRIX'/
     1' SINCE AT LEAST ONE PARAMETER HAD A VARIANCE NUMERICALLY .LE. 0.'
     2//
     3' SO THE COV. MATRIX ASSOCIATED WITH EACH GRID PT. IN THE '/
     4' BIG NPAG RUN WILL DEFAULT TO A DIAGONAL COV. MATRIX WITH EACH'/
     5' STD. DEV. EXACTLY 25% OF THE CORRESPONDING MEAN. THIS WILL'/
     6' ENSURE THAT NO SIMULATED PARAMETER VALUES ARE NEGATIVE.'/)
      ICOVMAT = 0
   90   CONTINUE
  110   READ(45,2) READLINE
        IF(READLINE(19:34) .NE. 'START OF THE DEN') GO TO 110
        DO I = 1,4
         READ(45,2) READLINE
        END DO
        READ(45,*) NGAUS
        IF(NGAUS .GT. 150) THEN
  120    WRITE(*,121) NGAUS
  121    FORMAT(/' YOUR OUTPUT FILE HAS A FINAL CYCLE WITH ',I5,/
     1' ACTIVE GRID POINTS. THIS IS MORE THAN THE ALLOWABLE VALUE OF '/
     2' 150. YOU HAVE THE OPTION OF STOPPING NOW, OR OF SIMPLY USING'/
     3' THE FIRST 150 GRID POINTS.'//
     4' ENTER 1 TO STOP;'/
     5' ENTER 2 TO CONTINUE, USING THE FIRST 150 GRID POINT: ')
         READ(*,*,ERR=120) ISTOP
         IF(ISTOP .NE. 1 .AND. ISTOP .NE. 2) GO TO 120
         IF(ISTOP .EQ. 1) STOP
         NGAUS = 150
        ENDIF
        READ(45,2) READLINE
        DO I = 1,NVAR
         READ(45,2) READLINE
        END DO
        READ(45,*) NOFIX
         DO I = 1,NOFIX
          READ(45,2) READLINE
         END DO
        IF(IVER .GE. 43) THEN
         READ(45,*) NRANFIX
         DO I = 1,NRANFIX
          READ(45,2) READLINE
         END DO
        ENDIF
        DO I = 1,NVAR
         READ(45,2) READLINE
        END DO
        READ(45,*) (VALFIX(I),I=1,NOFIX)
        IF(IVER .GE. 43) READ(45,*) (RANFIXEST(I),I=1,NOFIX)
        READ(45,*) NINT
        IF(NINT .NE. 100) THEN
         WRITE(*,111) NINT
  111    FORMAT(/' IN THE DENSITY PART OF THE FILE, NINT WAS READ'/
     1' AS ',I7,' BUT IT SHOULD HAVE BEEN 100. THE PROGRAM STOPS.'/
     2' PLEASE RECHECK YOUR OUTPUT FILE OR ASK LAPK TO ANALYZE YOUR'/
     3' FILE FOR YOU.'/)
        OPEN(42,FILE=ERRFIL)
         WRITE(42,111) NINT
        CLOSE(42)
         CALL PAUSE
         STOP
        ENDIF
        READ(45,2) READLINE
        READ(45,2) READLINE
        SUMWEIGHT = 0.D0
        DO IGAUS = 1,NGAUS
         READ(45,*) (AMEAN(IGAUS,J),J=1,NVAR),COF(IGAUS)
         SUMWEIGHT = SUMWEIGHT + COF(IGAUS)
        END DO
        CLOSE(45)
      IF(KKEY .EQ. 1) THEN
        DO IGAUS = 1,NGAUS
         COF(IGAUS) = COF(IGAUS)/SUMWEIGHT
        END DO
        IF(ICOVMAT .EQ. 1) THEN
          DO IGAUS = 1,NGAUS
           DO I = 1,NVAR
            DO J = 1,I
             COV(IGAUS,I,J) = COVV(I,J)/NGAUS
            END DO
          END DO
         END DO
        ENDIF
        IF(ICOVMAT .EQ. 0) THEN
          DO IGAUS = 1,NGAUS
           DO I = 1,NVAR
            DO J = 1,I
             COV(IGAUS,I,J) = 0.D0
             IF(I .EQ. J) COV(IGAUS,I,I) = AMEAN(IGAUS,I)*.0625D0
            END DO
          END DO
         END DO
        ENDIF
      ENDIF
  260 CONTINUE
      IF(KKEY .EQ. 2) THEN
       DO IGAUS = 1,NGAUS
        COF(IGAUS) = 1.D0
       END DO
       DO IGAUS = 1,NGAUS
        DO I = 1,NVAR
         DO J = 1,I
          COV(IGAUS,I,J) = 0.D0
         END DO
        END DO
       END DO
      ENDIF
        RETURN
        END
        SUBROUTINE READBLOCK2(PATH,C0,C1,C2,C3)
	  IMPLICIT REAL*8(A-H,O-Z)
	PARAMETER(MAXNUMEQ=7)
        DIMENSION TIMOUT(1,MAXNUMEQ,650),TIMIV(1,7,5200),
     1   NTIMOUT(1,MAXNUMEQ),NTIMIV(1,7),RATEIV(1,7,5200),
     2   BOLUS(1,7,5200),OUT(1,MAXNUMEQ,650),COV(1,26,5200),
     3   ICOVTYPE(26),TIMBOL(1,7,5200),NTIMBOL(1,7),NTIMCOV(1,26),
     4   TIMCOV(1,26,5200),TIMALL(1,24000),NTIMALL(1),TIMI(24000),
     5   C0(MAXNUMEQ),C1(MAXNUMEQ),C2(MAXNUMEQ),C3(MAXNUMEQ),
     6   CSUB(1,4,MAXNUMEQ),NSST(1),DOSELINEST(1,99,100),XVERIFY(900)
        CHARACTER READLINE*1000,COVNAME(26)*11,NUMBER(1)*3,
     1   PATFIL*20,CHARSUB*3,SUBID*11,SUBIDPREV*11,SUBARRAY(1)*11,
     3   PATH*61,TMPFILE*32,PATHFILE*93,ERRFIL*20
      COMMON/ERROR/ERRFIL
    1   FORMAT(A1000)
        MAXSUB = 1
	NDRUG = 0
	NOUT = 0
      DO ISUB = 1,MAXSUB
       NSST(ISUB) = 0
      END DO
	READ(66,*)
	  READ(66,1) READLINE
	NCOMMA = 0
	DO ISTART = 1,1000
	 IF(READLINE(ISTART:ISTART) .EQ. ',') THEN
	  NCOMMA = NCOMMA + 1
	 ENDIF
	END DO
	NCOVA = NCOMMA - 11
	IF(NCOVA .GT. 0) THEN
	REWIND(66)
  120	READ(66,1) READLINE
	IF(READLINE(1:3) .NE. '#ID' .AND. READLINE(1:4).NE. '"#ID'
     1  .AND. READLINE(1:3) .NE. '#id' .AND. READLINE(1:4).NE. '"#id')
     2   GO TO 120
	 DO ICOV = 1,NCOVA
	  CALL AFTERCOMMA(NCOVA,READLINE,11+ICOV)
	  BACKSPACE(57)
	  READ(57,2) COVNAME(ICOV)
    2     FORMAT(A11)
	  CLOSE(57)
	 END DO
	ENDIF
	CALL GETMAXTIM(NCOVA,TIMAX)
	IF(TIMAX .LT. 0) THEN
	 WRITE(*,11)
   11    FORMAT(/' THERE IS SOMETHING WRONG WITH YOUR BLOCK FORMAT'/
     1' FILE. THE TIMES IN COLUMN 3 AND/OR THE TIME DURATIONS'/
     2' IN COLUMN 4 ARE BAD. PLEASE CHECK YOUR VALUES. '//
     3' THE PROGRAM STOPS.')
        OPEN(42,FILE=ERRFIL)
         WRITE(42,11)
        CLOSE(42)
	 CALL PAUSE
	 STOP
	ENDIF
   	TIMADD = TIMAX + 1.D0
	REWIND(66)
	READ(66,1)
	READ(66,1)
	SUBIDPREV = '%^&*'
	NSUB = 0
   10	READ(66,1,IOSTAT=IEND) READLINE
	IF(IEND .LT. 0) GO TO 100
	IF(READLINE(1:1) .EQ. '#' .OR. READLINE(1:2) .EQ. '"#') GO TO 10
	CALL AFTERCOMMA(NCOVA,READLINE,0)
	BACKSPACE(57)
	READ(57,2) SUBID
	CLOSE(57)
	CALL GETID(SUBID)
	IF(SUBID .NE. SUBIDPREV) THEN
	 SUBIDPREV = SUBID
	 NSUB = NSUB + 1
        IF(NSUB .EQ. 2) GO TO 100
	 WRITE(*,8888) NSUB
 8888    FORMAT('+ ',' NOW WORKING ON SUBJECT NO. ',I4)
	 SUBARRAY(NSUB) = SUBID
	 NTIMALL(NSUB) = 0
	 DO K = 1,7
	  NTIMIV(NSUB,K) = 0
	  NTIMBOL(NSUB,K) = 0
	 END DO
	 DO K = 1,26
	  NTIMCOV(NSUB,K) = 0
	 END DO
        DO K = 1,MAXNUMEQ
         NTIMOUT(NSUB,K) = 0
         CSUB(NSUB,1,K) = C0(K)
         CSUB(NSUB,2,K) = C1(K)
         CSUB(NSUB,3,K) = C2(K)
         CSUB(NSUB,4,K) = C3(K)
        END DO
	NRESETADD = 0
	NRESET = 0
	TIMERESET = TIMADD*NRESET
       NRESETLAST = -1
       DOSELINEST(NSUB,1,100) = -99
	CALL AFTERCOMMA(NCOVA,READLINE,1)
	BACKSPACE(57)
	READ(57,*) IDEVENT
	CLOSE(57)
	IF(IDEVENT .NE. 1) THEN
	 WRITE(*,402) SUBARRAY(NSUB),IDEVENT
  402    FORMAT(/' THERE IS AN ERROR IN THE BLOCK FORMAT. FOR SUBJECT '/
     1 1X,A11,', THE FIRST EVENT ID IS NOT 1 AS REQUIRED. IT IS ',I3/
     3' THE PROGRAM STOPS.'/)
        OPEN(42,FILE=ERRFIL)
         WRITE(42,402) SUBARRAY(NSUB),IDEVENT
        CLOSE(42)
	 CALL PAUSE
	 STOP
	ENDIF
	ENDIF
	CALL AFTERCOMMA(NCOVA,READLINE,1)
	BACKSPACE(57)
	READ(57,*) IDEVENT
	CLOSE(57)
	IF(IDEVENT .EQ. 4) THEN
	 NRESET = NRESET + 1
	 TIMERESET = TIMADD*NRESET
	ENDIF
	CALL AFTERCOMMA(NCOVA,READLINE,2)
	BACKSPACE(57)
	READ(57,*) TIMEVENT
	CLOSE(57)
      IF(TIMEVENT .LT. 0.D0) THEN
       IF(NRESET .GT. NRESETLAST) THEN
        NSST(NSUB) = NSST(NSUB) + 1
        IF(NSST(NSUB) .GT. 99) THEN
         WRITE(*,172) NSUB
  172    FORMAT(/' FOR SUBJECT NO. ',I5,' THE NO. OF STEADY STATE DOSE'/
     1' SETS IS MORE THAN 99, THE MAXIMUM ALLOWED. PLEASE RERUN THE'/
     2' PROGRAM AFTER REDUCING THE NO. OF STEADY STATE DOSE SETS TO'/
     3' NO MORE THAN 99.'//
     4' THE PROGRAM STOPS.'/)
	  WRITE(*,401) NSUB,SUBARRAY(NSUB)
        OPEN(42,FILE=ERRFIL)
         WRITE(42,172) NSUB
        CLOSE(42)
         CALL PAUSE
         STOP
        ENDIF
        DOSELINEST(NSUB,NSST(NSUB),100) = NRESET
        DOSELINEST(NSUB,NSST(NSUB),1) = TIMEVENT
        DO I = 1,7
         DOSELINEST(NSUB,NSST(NSUB),2*I) = 0.D0
         DOSELINEST(NSUB,NSST(NSUB),2*I+1) = 0.D0
        END DO
        IF(NCOVA .GT. 0) THEN
         DO 110 ICOV = 1,NCOVA
          CALL AFTERCOMMA(NCOVA,READLINE,11+ICOV)
          BACKSPACE(57)
 	    READ(57,*,ERR=95) COVVAL
	    CLOSE(57)
          DOSELINEST(NSUB,NSST(NSUB),19+ICOV) = COVVAL
          GO TO 110
   95     DOSELINEST(NSUB,NSST(NSUB),19+ICOV) = -99.D0
  110    CONTINUE
        ENDIF
       IF(NRESET .GT. 0) THEN
        DO IOUTEQ = 1,MAXNUMEQ
         NTIMOUT(NSUB,IOUTEQ) = NTIMOUT(NSUB,IOUTEQ) + 1
         TIMOUT(NSUB,IOUTEQ,NTIMOUT(NSUB,IOUTEQ)) = TIMERESET
         OUT(NSUB,IOUTEQ,NTIMOUT(NSUB,IOUTEQ)) = -99.D0
        END DO
       ENDIF
       ENDIF
        CALL AFTERCOMMA(NCOVA,READLINE,3)
        BACKSPACE(57)
        READ(57,*,ERR=170) DUR
        CLOSE(57)
        CALL AFTERCOMMA(NCOVA,READLINE,4)
        BACKSPACE(57)
        READ(57,*,ERR=170) TOTDOS
        CLOSE(57)
        CALL AFTERCOMMA(NCOVA,READLINE,5)
        BACKSPACE(57)
        READ(57,*,ERR=170) IDRUGNO
	  IF(NDRUG .LT. IDRUGNO) NDRUG = IDRUGNO
        CLOSE(57)
        IF(DUR .LE. 0.D0)
     1   DOSELINEST(NSUB,NSST(NSUB),2*IDRUGNO) = 0.D0
        IF(DUR .GT. 0.D0)
     1   DOSELINEST(NSUB,NSST(NSUB),2*IDRUGNO) = TOTDOS/DUR
        DOSELINEST(NSUB,NSST(NSUB),2*IDRUGNO+1) = TOTDOS
       NRESETLAST = NRESET
       GO TO 10
  170  WRITE(*,171) NSUB,READLINE(1:75)
  171  FORMAT(/' THERE IS AN ERROR IN YOUR BLOCK FORMAT FILE FOR '/
     1' SUBJECT NO. ',I5,'. EITHER THE DURATION, THE DOSE, OR THE '/
     2' DRUG NUMBER IS MISSING. THE 1ST 75 CHARACTERS OF THE LINE ARE:'/
     2A75//
     3' THE PROGRAM STOPS.'/)
	 WRITE(*,401) NSUB,SUBARRAY(NSUB)
        OPEN(42,FILE=ERRFIL)
         WRITE(42,401) NSUB,SUBARRAY(NSUB)
        CLOSE(42)
  	 CALL PAUSE
	 STOP
      ENDIF
	TIMEVENT = TIMEVENT + TIMERESET
	IF(IDEVENT .EQ. 0) THEN
	CALL AFTERCOMMA(NCOVA,READLINE,6)
	BACKSPACE(57)
	READ(57,*,ERR=30) YVAL
	CLOSE(57)
	CALL AFTERCOMMA(NCOVA,READLINE,7)
	BACKSPACE(57)
	READ(57,*,ERR=30) IOUTEQ
	IF(NOUT .LT. IOUTEQ) NOUT = IOUTEQ
	CLOSE(57)
	NTIMOUT(NSUB,IOUTEQ) = NTIMOUT(NSUB,IOUTEQ) + 1
	TIMOUT(NSUB,IOUTEQ,NTIMOUT(NSUB,IOUTEQ)) = TIMEVENT
	OUT(NSUB,IOUTEQ,NTIMOUT(NSUB,IOUTEQ)) = YVAL
	NRESETADD = 0
	GO TO 20
   30   XVERIFY(1) = TIMEVENT - TIMERESET
        CALL VERIFYVAL(1,XVERIFY)
        WRITE(*,31) NSUB, XVERIFY(1)
   31   FORMAT(/' THERE IS AN ERROR IN THE BLOCK FORMAT. FOR SUBJECT '/
     1' NO. ',I4,' AND TIME ',F10.4, ' A LINE HAS AN EVENT ID OF 0 IN'/
     2' COL. 2, INDICATING OBSERVED VALUE INFORMATION. BUT THERE IS '/
     3' EITHER NO OBSERVED VALUE IN COL. 7, OR NO OUTPUT EQUATION NO.'/
     4' IN ENTRY 8. '//
     3' THE PROGRAM STOPS.')
	  WRITE(*,401) NSUB,SUBARRAY(NSUB)
  401   FORMAT(/' NOTE: THE ID FOR SUBJECT NO. ',I4,' IS ',A11/)
        OPEN(42,FILE=ERRFIL)
         WRITE(42,31) NSUB, XVERIFY(1)
         WRITE(42,401) NSUB,SUBARRAY(NSUB)
        CLOSE(42)
        CALL PAUSE
        STOP
   20 CONTINUE
        IMISSC0 = 0
        IMISSC1 = 0
        IMISSC2 = 0
        IMISSC3 = 0
        CALL AFTERCOMMA(NCOVA,READLINE,8)
        BACKSPACE(57)
        READ(57,*,ERR=230) C00
        CLOSE(57)
        GO TO 235
  230   IMISSC0 = 1
  235   CALL AFTERCOMMA(NCOVA,READLINE,9)
        BACKSPACE(57)
        READ(57,*,ERR=240) C11
        CLOSE(57)
        GO TO 245
  240   IMISSC1 = 1
  245   CALL AFTERCOMMA(NCOVA,READLINE,10)
        BACKSPACE(57)
        READ(57,*,ERR=250) C22
        CLOSE(57)
        GO TO 255
  250   IMISSC2 = 1
  255   CALL AFTERCOMMA(NCOVA,READLINE,11)
        BACKSPACE(57)
        READ(57,*,ERR=260) C33
        CLOSE(57)
        GO TO 265
  260   IMISSC3 = 1
  265   CONTINUE
        ISUMC = IMISSC0 + IMISSC1 + IMISSC2 + IMISSC3
        IF(ISUMC .EQ. 0) THEN
         CSUB(NSUB,1,IOUTEQ) = C00
         CSUB(NSUB,2,IOUTEQ) = C11
         CSUB(NSUB,3,IOUTEQ) = C22
         CSUB(NSUB,4,IOUTEQ) = C33
        ENDIF
        IF(ISUMC .NE. 0 .AND. ISUMC .NE. 4) THEN
         XVERIFY(1) = TIMEVENT - TIMERESET
         CALL VERIFYVAL(1,XVERIFY)
         WRITE(*,231) NSUB, XVERIFY(1),IOUTEQ
  231    FORMAT(/' THERE IS AN ERROR IN THE BLOCK FORMAT. FOR SUBJECT '/
     1' NO. ',I4,' AND TIME ',F10.4, ' A LINE HAS AN EVENT ID OF 0 IN'/
     2' COL. 2, INDICATING OBSERVED VALUE INFORMATION, BUT THIS LINE'/
     3' HAS AN INCOMPLETE SET OF ASSAY COEFFICIENTS FOR OUTPUT EQ. '/
     4' NUMBER ',I3,'. THERE MUST BE EITHER 4 ASSAY COEFFICIENTS ON'/
     5' AN OUTPUT LINE, OR NONE (IF NO OUTPUT LINES FOR A PARTICULAR'/
     6' SUBJECT x OUTPUT EQ. COMBO HAVE ASSAY COEFFICIENTS, THEN THE'/
     7' POPULATION COEFFICIENTS WILL BE USED).'//
     8' THE PROGRAM STOPS.')
         WRITE(*,401) NSUB,SUBARRAY(NSUB)
        OPEN(42,FILE=ERRFIL)
         WRITE(42,231) NSUB, XVERIFY(1),IOUTEQ
         WRITE(42,401) NSUB,SUBARRAY(NSUB)
        CLOSE(42)
         CALL PAUSE
         STOP
        ENDIF
	ENDIF
	IF(IDEVENT .EQ. 1 .OR. IDEVENT .EQ. 4) THEN
	CALL AFTERCOMMA(NCOVA,READLINE,4)
	BACKSPACE(57)
	READ(57,*,ERR=40) TOTDOS
	CLOSE(57)
	CALL AFTERCOMMA(NCOVA,READLINE,3)
	BACKSPACE(57)
	READ(57,*,ERR=50) DUR
	CLOSE(57)
	CALL AFTERCOMMA(NCOVA,READLINE,5)
	BACKSPACE(57)
	READ(57,*,ERR=50) IDRUGNO
	IF(NDRUG .LT. IDRUGNO) NDRUG = IDRUGNO
	CLOSE(57)
	IF(DUR .GT. 0) THEN
	 NTIMALL(NSUB) = NTIMALL(NSUB) + 1
	 IF(NTIMALL(NSUB) .GT. 24000) THEN
	  WRITE(*,3001) NSUB
 3001     FORMAT(/' THE NO. OF LINES IN THE DOSAGE REGIMEN FOR SUBJECT'/
     1' NO. ',I5,' IS MORE THAN THE LIMIT OF 24000. PLEASE RERUN THE'/
     2' PROGRAM AFTER REDUCING THIS NO. TO BE LESS THAN 24000.'/)
	  WRITE(*,401) NSUB,SUBARRAY(NSUB)
        OPEN(42,FILE=ERRFIL)
         WRITE(42,3001) NSUB
         WRITE(42,401) NSUB,SUBARRAY(NSUB)
        CLOSE(42)
	  CALL PAUSE
	  STOP
	 ENDIF
	 TIMALL(NSUB,NTIMALL(NSUB)) = TIMEVENT
      IF(IDEVENT .EQ. 4) THEN
       IF(NRESETADD .EQ. 0) THEN
        DO IOUTEQ = 1,MAXNUMEQ
         NTIMOUT(NSUB,IOUTEQ) = NTIMOUT(NSUB,IOUTEQ) + 1
         TIMOUT(NSUB,IOUTEQ,NTIMOUT(NSUB,IOUTEQ)) = TIMEVENT
   	   OUT(NSUB,IOUTEQ,NTIMOUT(NSUB,IOUTEQ)) = -99.D0
        END DO
        NRESETADD = 1
       ENDIF
	 ENDIF
        ISAME = 0
        IF(NTIMIV(NSUB,IDRUGNO) .GT. 0)
     1   CALL THESAME(TIMEVENT,TIMIV(NSUB,IDRUGNO,NTIMIV(NSUB,IDRUGNO)),
     2 ISAME)
        IF(ISAME .EQ. 0) NTIMIV(NSUB,IDRUGNO) = NTIMIV(NSUB,IDRUGNO) + 1
        TIMIV(NSUB,IDRUGNO,NTIMIV(NSUB,IDRUGNO)) = TIMEVENT
        RATEIV(NSUB,IDRUGNO,NTIMIV(NSUB,IDRUGNO)) = TOTDOS/DUR
	 NTIMALL(NSUB) = NTIMALL(NSUB) + 1
	 IF(NTIMALL(NSUB) .GT. 24000) THEN
	  WRITE(*,3001) NSUB
	  WRITE(*,401) NSUB,SUBARRAY(NSUB)
        OPEN(42,FILE=ERRFIL)
         WRITE(42,3001) NSUB
         WRITE(42,401) NSUB,SUBARRAY(NSUB)
        CLOSE(42)
	  CALL PAUSE
	  STOP
	 ENDIF
	 TIMALL(NSUB,NTIMALL(NSUB)) = TIMEVENT + DUR
	 NTIMIV(NSUB,IDRUGNO) = NTIMIV(NSUB,IDRUGNO) + 1
	 TIMIV(NSUB,IDRUGNO,NTIMIV(NSUB,IDRUGNO)) = TIMEVENT + DUR
	 RATEIV(NSUB,IDRUGNO,NTIMIV(NSUB,IDRUGNO)) = 0.D0
	ENDIF
	IF(DUR .LE. 0) THEN
	 NTIMALL(NSUB) = NTIMALL(NSUB) + 1
	 IF(NTIMALL(NSUB) .GT. 24000) THEN
	  WRITE(*,3001) NSUB
	  WRITE(*,401) NSUB,SUBARRAY(NSUB)
        OPEN(42,FILE=ERRFIL)
         WRITE(42,3001) NSUB
         WRITE(42,401) NSUB,SUBARRAY(NSUB)
        CLOSE(42)
	  CALL PAUSE
	  STOP
	 ENDIF
	 TIMALL(NSUB,NTIMALL(NSUB)) = TIMEVENT
      IF(IDEVENT .EQ. 4) THEN
       IF(NRESETADD .EQ. 0) THEN
        DO IOUTEQ = 1,MAXNUMEQ
         NTIMOUT(NSUB,IOUTEQ) = NTIMOUT(NSUB,IOUTEQ) + 1
         TIMOUT(NSUB,IOUTEQ,NTIMOUT(NSUB,IOUTEQ)) = TIMEVENT
   	   OUT(NSUB,IOUTEQ,NTIMOUT(NSUB,IOUTEQ)) = -99.D0
        END DO
        NRESETADD = 1
       ENDIF
	 ENDIF
	 NTIMBOL(NSUB,IDRUGNO) = NTIMBOL(NSUB,IDRUGNO) + 1
	 TIMBOL(NSUB,IDRUGNO,NTIMBOL(NSUB,IDRUGNO)) = TIMEVENT
	 BOLUS(NSUB,IDRUGNO,NTIMBOL(NSUB,IDRUGNO)) = TOTDOS
	ENDIF
	GO TO 40
   50 XVERIFY(1) = TIMEVENT - TIMERESET
      CALL VERIFYVAL(1,XVERIFY)
      WRITE(*,51) NSUB, XVERIFY(1)
   51 FORMAT(/' THERE IS AN ERROR IN THE BLOCK FORMAT. FOR SUBJECT '/
     1' NO. ',I4,' AND TIME ',F10.4,' A LINE HAS A DOSAGE AMT., BUT NO'/
     2' DURATION (EVEN A BOLUS SHOULD HAVE A DURATION OF 0) IN '/
     3' ENTRY 4., OR NO DRUG NO. IN ENTRY 5.'//
     3' THE PROGRAM STOPS.')
	WRITE(*,401) NSUB,SUBARRAY(NSUB)
        OPEN(42,FILE=ERRFIL)
         WRITE(42,51) NSUB, XVERIFY(1)
         WRITE(42,401) NSUB,SUBARRAY(NSUB)
        CLOSE(42)
	CALL PAUSE
	STOP
   40   CONTINUE
	IF(NCOVA .GT. 0) THEN
         DO 60 ICOV = 1,NCOVA
	  CALL AFTERCOMMA(NCOVA,READLINE,11+ICOV)
	  BACKSPACE(57)
 	  READ(57,*,ERR=70) COVVAL
	  CLOSE(57)
	  NTIMALL(NSUB) = NTIMALL(NSUB) + 1
	 IF(NTIMALL(NSUB) .GT. 24000) THEN
	  WRITE(*,3001) NSUB
	  WRITE(*,401) NSUB,SUBARRAY(NSUB)
        OPEN(42,FILE=ERRFIL)
         WRITE(42,3001) NSUB
         WRITE(42,401) NSUB,SUBARRAY(NSUB)
        CLOSE(42)
	  CALL PAUSE
	  STOP
	 ENDIF
	 TIMALL(NSUB,NTIMALL(NSUB)) = TIMEVENT
      IF(IDEVENT .EQ. 4) THEN
       IF(NRESETADD .EQ. 0) THEN
        DO IOUTEQ = 1,MAXNUMEQ
         NTIMOUT(NSUB,IOUTEQ) = NTIMOUT(NSUB,IOUTEQ) + 1
         TIMOUT(NSUB,IOUTEQ,NTIMOUT(NSUB,IOUTEQ)) = TIMEVENT
   	   OUT(NSUB,IOUTEQ,NTIMOUT(NSUB,IOUTEQ)) = -99.D0
        END DO
        NRESETADD = 1
       ENDIF
	 ENDIF
	  IF(NTIMCOV(NSUB,ICOV) .GT. 0) THEN
	   CALL THESAME(TIMEVENT,TIMCOV(NSUB,ICOV,NTIMCOV(NSUB,ICOV)),
     1                  ISAMETIME)
	   CALL THESAME(COVVAL,COV(NSUB,ICOV,NTIMCOV(NSUB,ICOV)),
     1                  ISAMECOV)
	   IF(ISAMETIME .EQ. 1 .AND. ISAMECOV .EQ. 1) GO TO 60
	   IF(ISAMETIME .EQ. 1 .AND. ISAMECOV .EQ. 0) THEN
        XVERIFY(1) = TIMEVENT - TIMERESET
        XVERIFY(2) = COV(NSUB,ICOV,NTIMCOV(NSUB,ICOV))
        XVERIFY(3) = COVVAL
        CALL VERIFYVAL(3,XVERIFY)
        WRITE(*,41) NSUB,XVERIFY(1),ICOV,XVERIFY(2),XVERIFY(3)
   41   FORMAT(/' FOR SUBJECT, 'I3,' AT TIME ',G14.7,', COVARIATE'/
     1' NO. ',I2,' WAS SET TO BOTH ',G14.7,' AND ',G14.7,'. YOU SHOULD'/
     2' CHECK YOUR BLOCK FILE. FOR NOW, THE FIRST VALUE WILL BE USED.')
	    GO TO 60
	   ENDIF
	  ENDIF
	  NTIMCOV(NSUB,ICOV) = NTIMCOV(NSUB,ICOV) + 1
	  TIMCOV(NSUB,ICOV,NTIMCOV(NSUB,ICOV)) = TIMEVENT
	  COV(NSUB,ICOV,NTIMCOV(NSUB,ICOV)) = COVVAL
	  GO TO 60
   70     CONTINUE
   60   CONTINUE
	ENDIF
	ENDIF
	GO TO 10
  100   NSUB = 1
	IF(NCOVA .GT. 0) THEN
	 WRITE(*,111) NCOVA
  111    FORMAT(/' YOUR BLOCK FORMAT PATIENT INFORMATION FILE SHOWS'/
     1' ',I2,' COVARIATES. EACH COVARIATE MUST BE SPECIFIED TO BE '/
     2' EITHER A PIECEWISE CONSTANT COVARIATE OR AN INTERPOLATED '/
     3' COVARIATE.'//
     4' A PIECEWISE CONSTANT COVARIATE WILL HAVE THE SAME VALUE FROM'/
     5' ONE EXPLICITLY CODED VALUE, THROUGH ALL INTERVEENING DOSE'/
     6' TIMES, TO THE NEXT EXPLICITLY CODED VALUE (WHEN IT WILL CHANGE).
     7 '//
     8' AN INTERPOLATED COVARIATE WILL HAVE INTERPOLATED VALUES FROM'/
     9' ONE EXPLICITY CODED VALUE, THROUGH ALL INTERVEENING DOSE '/
     1' TIMES, TO THE NEXT EXPLCITLY CODED VALUE.'//)
	 DO ICOV = 1,NCOVA
  130	  WRITE(*,112) COVNAME(ICOV)
  112     FORMAT(/' FOR COVARIATE ',A11/
     1'  ENTER 1 IF IT IS TO BE PIECEWISE CONSTANT; '/
     2'  ENTER 2 IF IT IS TO BE INTERPOLATED: ')
	  READ(*,*,ERR=130) ITYPE
	  IF(ITYPE .NE. 1 .AND. ITYPE .NE. 2) GO TO 130
	  ICOVTYPE(ICOV) = ITYPE
	 END DO
	ENDIF
	DO JSUB = 1,NSUB
	 CALL GETCHAR2(JSUB,CHARSUB)
	 NUMBER(JSUB) = CHARSUB
	END DO
	DO 1000 ISUB = 1,NSUB
	 PATFIL = 'XQZPJ'//NUMBER(ISUB)//'.ZMQ'
         TMPFILE = ' '
	 TMPFILE = PATFIL
	 CALL FULLNAME(PATH,TMPFILE,PATHFILE)
	 OPEN(33,FILE=PATHFILE)
	 IF(NDRUG .GT. 7) THEN
	  WRITE(*,101) NDRUG
  101     FORMAT(/' NO. OF DRUGS IN THIS PATIENT DATA SET IS ',I2/
     1'  THIS IS MORE THAN 7, THE MAXIMUM --> PROGRAM STOPS.'/)
	  WRITE(*,401) ISUB,SUBARRAY(ISUB)
        OPEN(42,FILE=ERRFIL)
         WRITE(42,101) NDRUG
         WRITE(42,401) ISUB,SUBARRAY(ISUB)
        CLOSE(42)
	  CALL PAUSE
	  STOP
	 ENDIF
	 IF(NOUT .GT. MAXNUMEQ) THEN
        WRITE(*,106) NOUT,MAXNUMEQ
  106   FORMAT(/' NO. OF OUTPUT EQS. THIS PATIENT DATA SET IS ',I2/
     1' THIS IS MORE THAN THE MAX. ALLOWED VALUE OF ',I2,'. SO THE'/
     2' PROGRAM STOPS.'/)
	  WRITE(*,401) ISUB,SUBARRAY(ISUB)
        OPEN(42,FILE=ERRFIL)
         WRITE(42,106) NOUT,MAXNUMEQ
         WRITE(42,401) ISUB,SUBARRAY(ISUB)
        CLOSE(42)
	  CALL PAUSE
	  STOP
	 ENDIF
	 IF(NCOVA .GT. 26) THEN
	  WRITE(*,103) NCOVA
  103     FORMAT(/' NO. OF COVARIATES IN THIS PATIENT DATA SET IS ',I3/
     1'  THIS IS MORE THAN 26, THE MAXIMUM --> PROGRAM STOPS.'/)
	  WRITE(*,401) ISUB,SUBARRAY(ISUB)
        OPEN(42,FILE=ERRFIL)
         WRITE(42,103) NCOVA
         WRITE(42,401) ISUB,SUBARRAY(ISUB)
        CLOSE(42)
	  CALL PAUSE
	  STOP
	 ENDIF
	 CALL TIMESET(MAXSUB,ISUB,SUBARRAY(ISUB),NTIMALL,TIMALL,NTIMI,
     1    TIMI)
	 CALL WRITEDOS(ISUB,NTIMIV,TIMIV,RATEIV,NTIMBOL,TIMBOL,BOLUS,
     1    NTIMCOV,TIMCOV,COV,ICOVTYPE,NDRUG,NCOVA,NOUT,NTIMOUT,
     2    TIMOUT,OUT,SUBARRAY(ISUB),COVNAME,MAXSUB,NTIMI,TIMI,TIMADD,
     3    CSUB,NSST,DOSELINEST)
 1000   CONTINUE
	RETURN
	END
	SUBROUTINE AFTERCOMMA(NCOVA,READLINE,NCOMMA)
	CHARACTER READLINE*1000,ERRFIL*20
      COMMON/ERROR/ERRFIL
    1   FORMAT(A1000)
	IF(NCOMMA .EQ. 0) THEN
	 ISTART = 0
	 GO TO 10
	ENDIF
	ICOMMA = 0
	DO ISTART = 1,300
	 IF(READLINE(ISTART:ISTART) .EQ. ',') THEN
	  ICOMMA = ICOMMA + 1
	  IF(ICOMMA .EQ. NCOMMA) GO TO 10
	 ENDIF
	END DO
	WRITE(*,2) NCOMMA,ICOMMA,READLINE
    2   FORMAT(/' THE FOLLOWING LINE WAS SUPPOSED TO HAVE AT LEAST ',I3/
     1' COMMAS, BUT IT HAD ONLY ',I3,' SO THE PROGRAM STOPS.'//
     2A1000)
        OPEN(42,FILE=ERRFIL)
         WRITE(42,2) NCOMMA,ICOMMA,READLINE
        CLOSE(42)
	CALL PAUSE
	STOP
   10	ICOMMA = 0
	DO IEND = 1,300
	 IF(READLINE(IEND:IEND) .EQ. ',') THEN
	  ICOMMA = ICOMMA + 1
	  IF(ICOMMA .EQ. NCOMMA+1) GO TO 20
	 ENDIF
	END DO
	IF(NCOMMA .LT. 11 + NCOVA) THEN
	 WRITE(*,2) NCOMMA+1,ICOMMA,READLINE
        OPEN(42,FILE=ERRFIL)
         WRITE(42,2) NCOMMA+1,ICOMMA,READLINE
        CLOSE(42)
	 CALL PAUSE
	 STOP
	ENDIF
	IF(NCOMMA .EQ. 11 + NCOVA) IEND = 301
   20	OPEN(57,STATUS='SCRATCH')
        NUMCHAR = IEND - ISTART - 1
        IF(NUMCHAR .EQ. 1) WRITE(57,101) READLINE(ISTART+1:IEND-1)
  101   FORMAT(A1)
        IF(NUMCHAR .EQ. 2) WRITE(57,102) READLINE(ISTART+1:IEND-1)
  102   FORMAT(A2)
        IF(NUMCHAR .EQ. 3) WRITE(57,103) READLINE(ISTART+1:IEND-1)
  103   FORMAT(A3)
        IF(NUMCHAR .EQ. 4) WRITE(57,104) READLINE(ISTART+1:IEND-1)
  104   FORMAT(A4)
        IF(NUMCHAR .EQ. 5) WRITE(57,105) READLINE(ISTART+1:IEND-1)
  105   FORMAT(A5)
        IF(NUMCHAR .EQ. 6) WRITE(57,106) READLINE(ISTART+1:IEND-1)
  106   FORMAT(A6)
        IF(NUMCHAR .EQ. 7) WRITE(57,107) READLINE(ISTART+1:IEND-1)
  107   FORMAT(A7)
        IF(NUMCHAR .EQ. 8) WRITE(57,108) READLINE(ISTART+1:IEND-1)
  108   FORMAT(A8)
        IF(NUMCHAR .EQ. 9) WRITE(57,109) READLINE(ISTART+1:IEND-1)
  109   FORMAT(A9)
        IF(NUMCHAR .EQ. 10) WRITE(57,110) READLINE(ISTART+1:IEND-1)
  110   FORMAT(A10)
        IF(NUMCHAR .EQ. 11) WRITE(57,111) READLINE(ISTART+1:IEND-1)
  111   FORMAT(A11)
        IF(NUMCHAR .GT. 11) WRITE(57,*) READLINE(ISTART+1:IEND-1)
	RETURN
	END
        SUBROUTINE WRITEDOS(ISUB,NTIMIV,TIMIV,RATEIV,NTIMBOL,TIMBOL,
     1   BOLUS,NTIMCOV,TIMCOV,COV,ICOVTYPE,NDRUG,NCOVA,NOUT,NTIMOUT,
     2   TIMOUT,OUT,SUBID,COVNAME,MAXSUB,NTIMI,TIMI,TIMADD,CSUB,
     3   NSST,DOSELINEST)
         IMPLICIT REAL*8(A-H,O-Z)
         PARAMETER(MAXNUMEQ=7)
      DIMENSION BOLVAL(7),COVVAL(26),XIVVAL(7),DOSELINE(5200,43),
     1 TIMOUT(MAXSUB,MAXNUMEQ,650),TIMIV(MAXSUB,7,5200),
     2 NTIMOUT(MAXSUB,MAXNUMEQ),NTIMIV(MAXSUB,7),RATEIV(MAXSUB,7,5200),
     3 BOLUS(MAXSUB,7,5200),OUT(MAXSUB,MAXNUMEQ,650),
     4 COV(MAXSUB,26,5200),ICOVTYPE(26),TIMBOL(MAXSUB,7,5200),
     5 NTIMBOL(MAXSUB,7),NTIMCOV(MAXSUB,26),TIMCOV(MAXSUB,26,5200),
     6 INDIV(7),INDBOL(7),INDCOV(26),TIMI(24000),TIMORD(3900),
     7 BLOCKOUT(3900,MAXNUMEQ),CSUB(MAXSUB,4,MAXNUMEQ),NSST(MAXSUB),
     8 DOSELINEST(MAXSUB,99,100),DOSELINES(100),XVERIFY(900)
	CHARACTER SUBID*11,COVNAME(26)*11,ERRFIL*20
      COMMON/ERROR/ERRFIL
	WRITE(33,301) SUBID
  301   FORMAT('  LAST AND FIRST NAMES ARE: ',A11)
	WRITE(33,302) SUBID
  302   FORMAT(' CHART NUMBER IS: ',A11//
     1' WARD NO, PATIENT AGE (YEARS), SEX, HEIGHT (INCHES),'/
     2' ETHNICITY FLAG, AND ETHNICITY DESCRIPTION (IF ANY)   FOLLOW ON'/
     3' THE NEXT 6 LINES:'/
     4'-99'/
     5'-99'/
     6'M'/
     7'-99'/
     8'1'/
     9'Ethnicity Description'//
     1' DATE OF FIRST THERAPY IS   1   1   08'/
     2'CCR ML/MIN/    0.00 150.00'/
     3'HOURS    MG     MG/HR    MCG/ML KG       MG/DL    60  .00 ')
	 WRITE(33,102) NDRUG
  102    FORMAT(/'     ',I1,' ... NO. OF DRUGS')
	 WRITE(33,104) NCOVA
  104    FORMAT('    ',I2,' ... NO. OF ADDITIONAL COVARIATES')
	WRITE(33,2) NTIMI + NSST(ISUB)
    2   FORMAT('   ',I3,' ... NO. OF DOSE EVENTS'//
     1'    TIME, IV/PO FOR EACH DRUG; ADDITIONAL COVARIATES IF ANY')
	DO IDRUG = 1,NDRUG
	 XIVVAL(IDRUG) = 0.D0
	 BOLVAL(IDRUG) = 0.D0
	END DO
	DO ICOV = 1,NCOVA
	 COVVAL(ICOV) = COV(ISUB,ICOV,1)
	END DO
	DO IDRUG = 1,NDRUG
	 INDIV(IDRUG) = 1
	 INDBOL(IDRUG) = 1
	END DO
	DO ICOV = 1,NCOVA
	 INDCOV(ICOV) = 1
	END DO
	NRESET = 0
	TIMERESET = TIMADD*NRESET
      NSSEVENTS = 1
      CALL THESAME(DOSELINEST(ISUB,1,100),0.D0,ISAME)
      IF(ISAME .EQ. 1) THEN
	 DOSELINES(1) = DOSELINEST(ISUB,1,1)
	 NENTRY = 1
	 DO IDRUG = 1,NDRUG
	  NENTRY = NENTRY+1
        DOSELINES(NENTRY) = DOSELINEST(ISUB,1,2*IDRUG)
	  NENTRY = NENTRY+1
	  DOSELINES(NENTRY) = DOSELINEST(ISUB,1,2*IDRUG+1)
	 END DO
       IF(NCOVA .GT. 0) THEN
	  DO ICOV = 1,NCOVA
	   NENTRY = NENTRY+1
	   DOSELINES(NENTRY) = DOSELINEST(ISUB,1,19+ICOV)
	  END DO
       ENDIF
        DO J = 1,NENTRY
         XVERIFY(J) = DOSELINES(J)
        END DO
        CALL VERIFYVAL(NENTRY,XVERIFY)
        WRITE(33,1) (XVERIFY(J),J=1,NENTRY)
       NSSEVENTS = NSSEVENTS + 1
      ENDIF
	DO 1000 ITIM = 1,NTIMI
	 TIME = TIMI(ITIM)
       CALL THESAME(TIME,TIMADD*(NRESET+1),ISAMERESET)
       IF(TIME .GE. TIMADD*(NRESET+1)) THEN
	  NRESET = NRESET + 1
	  TIMERESET = TIMADD*NRESET
        IF(NSSEVENTS .LE. NSST(ISUB)) THEN
         XRESET = NRESET
         CALL THESAME(DOSELINEST(ISUB,NSSEVENTS,100),XRESET,ISAME)
         IF(ISAME .EQ. 1) THEN
          DOSELINES(1) = DOSELINEST(ISUB,NSSEVENTS,1)
          NENTRY = 1
          DO IDRUG = 1,NDRUG
           NENTRY = NENTRY+1
           DOSELINES(NENTRY) = DOSELINEST(ISUB,NSSEVENTS,2*IDRUG)
           NENTRY = NENTRY+1
           DOSELINES(NENTRY) = DOSELINEST(ISUB,NSSEVENTS,2*IDRUG+1)
          END DO
          IF(NCOVA .GT. 0) THEN
           DO ICOV = 1,NCOVA
            NENTRY = NENTRY+1
            DOSELINES(NENTRY) = DOSELINEST(ISUB,NSSEVENTS,19+ICOV)
           END DO
          ENDIF
        DO J = 1,NENTRY
         XVERIFY(J) = DOSELINES(J)
        END DO
        CALL VERIFYVAL(NENTRY,XVERIFY)
        WRITE(33,1) (XVERIFY(J),J=1,NENTRY)
          NSSEVENTS = NSSEVENTS + 1
         ENDIF
        ENDIF
	 ENDIF
	DO IDRUG = 1,NDRUG
	 IF(INDBOL(IDRUG) .GT. NTIMBOL(ISUB,IDRUG)) TIMEB = -99.D0
	 IF(INDBOL(IDRUG) .LE. NTIMBOL(ISUB,IDRUG)) THEN
	  TIMEB = TIMBOL(ISUB,IDRUG,INDBOL(IDRUG))
	 ENDIF
	 CALL THESAME(TIME,TIMEB,ISAME)
	  IF(ISAME .EQ. 0) BOLVAL(IDRUG) = 0.D0
	  IF(ISAME .EQ. 1) THEN
	   BOLVAL(IDRUG) = BOLUS(ISUB,IDRUG,INDBOL(IDRUG))
	   INDBOL(IDRUG) = INDBOL(IDRUG) + 1
	  ENDIF
	 END DO
	DO ICOV = 1,NCOVA
	 IF(INDCOV(ICOV) .GT. NTIMCOV(ISUB,ICOV)) TIMEC = -99.D0
	 IF(INDCOV(ICOV) .LE. NTIMCOV(ISUB,ICOV)) THEN
	  TIMEC = TIMCOV(ISUB,ICOV,INDCOV(ICOV))
	 ENDIF
	 CALL THESAME(TIME,TIMEC,ISAME)
	  IF(ISAME .EQ. 1) THEN
	   COVVAL(ICOV) = COV(ISUB,ICOV,INDCOV(ICOV))
	   INDCOV(ICOV) = INDCOV(ICOV) + 1
	  ENDIF
	IF(ISAME .EQ. 0) THEN
	 INTERP = 1
	 IF(ICOVTYPE(ICOV) .EQ. 1 .OR. ICOVTYPE(ICOV) .EQ. 0)
     1    INTERP = 0
	 IF(TIMEC .LE. -99) INTERP = 0
	 IF(ISAMERESET .EQ. 1) INTERP = 0
	 IF(TIMEC .GE. TIMERESET + TIMADD) INTERP = 0
	 IF(INDCOV(ICOV) .EQ. 1) THEN
	  WRITE(*,111) ICOV
  111     FORMAT(/' THERE IS A MISTAKE IN THE BLOCK FORMAT PATIENT'/
     1' DATA FILE. THE FIRST VALUE FOR COVARIATE NO. ',I2,' WAS NOT'/
     2' SPECIFIED AT THE ORIGINAL TIME = 0, AS IS REQUIRED. PLEASE'/
     3' FIX THIS ERROR AND RERUN THE PROGRAM. '//)
	  WRITE(*,401) ISUB,SUBID
  401   FORMAT(/' NOTE: THE ID FOR SUBJECT NO. ',I4,' IS ',A11/)
        OPEN(42,FILE=ERRFIL)
         WRITE(42,111) ICOV
         WRITE(42,401) ISUB,SUBID
        CLOSE(42)
	  CALL PAUSE
	  STOP
	 ENDIF
	 CLAST = COV(ISUB,ICOV,INDCOV(ICOV)-1)
	 IF(INTERP .EQ. 0) COVVAL(ICOV) = CLAST
	 IF(INTERP .EQ. 1) THEN
	  TLAST = TIMCOV(ISUB,ICOV,INDCOV(ICOV)-1) - TIMERESET
	  CNEXT = COV(ISUB,ICOV,INDCOV(ICOV))
	  TNEXT = TIMCOV(ISUB,ICOV,INDCOV(ICOV)) - TIMERESET
	  TIMEREAL = TIME - TIMERESET
	  COVVAL(ICOV) = (TIMEREAL-TLAST)/(TNEXT-TLAST) * (CNEXT-CLAST)
     1     + CLAST
	 ENDIF
	ENDIF
	 END DO
	DO IDRUG = 1,NDRUG
	 IF(INDIV(IDRUG) .GT. NTIMIV(ISUB,IDRUG)) TIMEI = -99.D0
	 IF(INDIV(IDRUG) .LE. NTIMIV(ISUB,IDRUG)) THEN
	  TIMEI = TIMIV(ISUB,IDRUG,INDIV(IDRUG))
	 ENDIF
	 CALL THESAME(TIME,TIMEI,ISAME)
	  IF(ISAME .EQ. 1) THEN
	   XIVVAL(IDRUG) = RATEIV(ISUB,IDRUG,INDIV(IDRUG))
	   INDIV(IDRUG) = INDIV(IDRUG) + 1
	  ENDIF
	 END DO
	 DOSELINE(ITIM,1) = TIME - TIMERESET
	 NENTRY = 1
	 DO IDRUG = 1,NDRUG
	  NENTRY = NENTRY+1
	  DOSELINE(ITIM,NENTRY) = XIVVAL(IDRUG)
	  NENTRY = NENTRY+1
	  DOSELINE(ITIM,NENTRY) = BOLVAL(IDRUG)
	 END DO
	 DO ICOV = 1,NCOVA
	  NENTRY = NENTRY+1
	  DOSELINE(ITIM,NENTRY) = COVVAL(ICOV)
	 END DO
        DO J = 1,NENTRY
         XVERIFY(J) = DOSELINE(ITIM,J)
        END DO
        CALL VERIFYVAL(NENTRY,XVERIFY)
        WRITE(33,1) (XVERIFY(J),J=1,NENTRY)
    1   FORMAT(43(G19.9,1X))
 1000   CONTINUE
 1010   CONTINUE
        IF(NSSEVENTS .LE. NSST(ISUB)) THEN
          DOSELINES(1) = DOSELINEST(ISUB,NSSEVENTS,1)
          NENTRY = 1
          DO IDRUG = 1,NDRUG
           NENTRY = NENTRY+1
           DOSELINES(NENTRY) = DOSELINEST(ISUB,NSSEVENTS,2*IDRUG)
           NENTRY = NENTRY+1
           DOSELINES(NENTRY) = DOSELINEST(ISUB,NSSEVENTS,2*IDRUG+1)
          END DO
          IF(NCOVA .GT. 0) THEN
           DO ICOV = 1,NCOVA
            NENTRY = NENTRY+1
            DOSELINES(NENTRY) = DOSELINEST(ISUB,NSSEVENTS,19+ICOV)
           END DO
          ENDIF
        DO J = 1,NENTRY
         XVERIFY(J) = DOSELINES(J)
        END DO
        CALL VERIFYVAL(NENTRY,XVERIFY)
        WRITE(33,1) (XVERIFY(J),J=1,NENTRY)
          NSSEVENTS = NSSEVENTS + 1
          GO TO 1010
        ENDIF
	WRITE(33,106) NOUT
  106   FORMAT(/'     ',I1,' ... NO. OF TOTAL OUTPUT EQUATIONS')
	CALL FIXOUTIM(MAXSUB,ISUB,SUBID,NOUT,NTIMOUT,TIMOUT,OUT,NTIMORD,
     1   TIMORD,BLOCKOUT,TIMADD)
      	WRITE(33,62) NTIMORD
   62   FORMAT('  ',I4,' ... NO. OF OBSERVED VALUE TIMES')
       DO I = 1,NTIMORD
        XVERIFY(1) = TIMORD(I)
        DO J = 1,NOUT
         XVERIFY(1+J) = BLOCKOUT(I,J)
        END DO
        CALL VERIFYVAL(1+NOUT,XVERIFY)
        WRITE(33,63) (XVERIFY(IXV),IXV=1,1+NOUT)
   63   FORMAT(7(G16.8,1X))
       END DO
	WRITE(33,303)
  303   FORMAT(/' COVARIATE NAMES AND VALUES (1ST, LAST, AND MEAN) FOLLO
     1W:')
      XMEAN = -99
      DO ICOV = 1,NCOVA
       XVERIFY(1) = COV(ISUB,ICOV,1)
       XVERIFY(2) = COV(ISUB,ICOV,NTIMCOV(ISUB,ICOV))
       XVERIFY(3) = XMEAN
       CALL VERIFYVAL(3,XVERIFY)
       WRITE(33,304) COVNAME(ICOV),(XVERIFY(I),I=1,3)
      END DO
  304 FORMAT(A11,3X,3(F15.5,1X))
	WRITE(33,306)
  306   FORMAT(/'ASSAY COEFFICIENTS FOLLOW, ONE SET FOR EACH OUTPUT EQUA
     1TION:')
        DO K = 1,NOUT
         DO I=1,4
          XVERIFY(I) = CSUB(ISUB,I,K)
         END DO
         CALL VERIFYVAL(4,XVERIFY)
         WRITE(33,3061) (XVERIFY(I),I=1,4)
        END DO
 3061   FORMAT(4(F17.8,1X))
	CLOSE(33)
	RETURN
	END
	SUBROUTINE THESAME(X1,X2,ISAME)
	IMPLICIT REAL*8(A-H,O-Z)
	ISAME = 0
	XDEL = DABS(X1-X2)
	IF(XDEL .LE. 1.D-10) ISAME = 1
	RETURN
	END
	SUBROUTINE GETID(SUBID)
	CHARACTER SUBID*11,SUB*11
	SUB = '           '
	DO I = 1,11
	 IF(SUBID(I:I) .NE. ',') SUB(I:I) = SUBID(I:I)
	 IF(SUBID(I:I) .EQ. ',') GO TO 10
	END DO
   10   SUBID = SUB
	RETURN
	END
	SUBROUTINE TIMESET(MAXSUB,ISUB,SUBID,NTIMALL,TIMALL,NTIMI,
     1    TIMI)
      IMPLICIT REAL*8(A-H,O-Z)
      DIMENSION TIMALL(MAXSUB,24000),NTIMALL(MAXSUB),TIMI(24000),
     1   TIM(24000)
	CHARACTER SUBID*11
	CALL THESAME(TIMALL(ISUB,1),0.D0,ISAME)
	DO I = 1,NTIMALL(ISUB)
	 TIM(I) = TIMALL(ISUB,I)
	END DO
	CALL PUTORDER(NTIMALL(ISUB),TIM)
	TIMELAST = -1.D39
	NTIMI = 0
	DO I = 1,NTIMALL(ISUB)
	 TIME = TIM(I)
	 CALL THESAME(TIME,TIMELAST,ISAME)
	 IF(ISAME .EQ. 1) GO TO 30
	  NTIMI = NTIMI + 1
	  TIMI(NTIMI) = TIME
	  TIMELAST = TIME
   30    CONTINUE
	END DO
	RETURN
	END
	SUBROUTINE PUTORDER(NX,XX)
      IMPLICIT REAL*8(A-H,O-Z)
      DIMENSION XX(24000),Y(24000),IZ(24000),IZZ(24000)
	 DO I=1,NX
	  Y(I) = XX(I)
	  IZ(I) = -99
	 END DO
	 DO IPLACE = 1,NX
	  TEMP = 1.D50
	  DO I=1,NX
	   IF(Y(I) .LT. TEMP .AND. IZ(I) .EQ. -99) THEN
	    TEMP = Y(I)
	    IND = I
	   ENDIF
	  END DO
	  IZZ(IPLACE) = IND
	  IZ(IND) = 0
	 END DO
	 DO I = 1,NX
	  XX(I) = Y(IZZ(I))
	 END DO
	RETURN
	END
	SUBROUTINE FIXOUTIM(MAXSUB,ISUB,SUBID,NOUT,NTIMOUT,TIMOUT,OUT,
     1   NTIMORD,TIMORD,BLOCKOUT,TIMADD)
	IMPLICIT REAL*8(A-H,O-Z)
	PARAMETER(MAXNUMEQ=7)
      DIMENSION TIMOUT(MAXSUB,MAXNUMEQ,650),NTIMOUT(MAXSUB,MAXNUMEQ),
     1 IENTRY(MAXNUMEQ),OUT(MAXSUB,MAXNUMEQ,650),TIMORD(3900),
     2 BLOCKOUT(3900,MAXNUMEQ)
	CHARACTER SUBID*11,ERRFIL*20
      COMMON/ERROR/ERRFIL
	DO IOUT = 1,NOUT
	 IENTRY(IOUT) = 1
	END DO
	INEXT = 1
   20	TIMENEXT = 1.D50
	 IANOTHER = 0
        DO IOUT	= 1,NOUT
	 IF(IENTRY(IOUT) .LE. NTIMOUT(ISUB,IOUT)) THEN
	  IANOTHER = 1
	  IF(TIMOUT(ISUB,IOUT,IENTRY(IOUT)) .LE. TIMENEXT)
     1     TIMENEXT = TIMOUT(ISUB,IOUT,IENTRY(IOUT))
	 ENDIF
	END DO
	IF(IANOTHER .EQ. 0) GO TO 100
	IF(INEXT .GT. 3900) THEN
	 WRITE(*,1)
    1    FORMAT(/' THE TOTAL NO. OF OBSERVATION TIMES IS GREATER THAN'/
     1' THE MAXIMUM ALLOWABLE VALUE OF 3900 (SUBROUTINE FIXOUTIM).'/
     2' RERUN THE PROGRAM AFTER REDUCING THE NO. OF OBS. TIMES.'/)
	 WRITE(*,401) ISUB,SUBID
  401    FORMAT(/' NOTE: THE ID FOR SUBJECT NO. ',I4,' IS ',A11/)
        OPEN(42,FILE=ERRFIL)
         WRITE(42,1)
         WRITE(42,401) ISUB,SUBID
        CLOSE(42)
	 CALL PAUSE
	 STOP
	ENDIF
	TIMORD(INEXT) = TIMENEXT
        DO IOUT	= 1,NOUT
	  BLOCKOUT(INEXT,IOUT) = -99.D0
	  CALL THESAME(TIMENEXT,TIMOUT(ISUB,IOUT,IENTRY(IOUT)),ISAME)
	  IF(ISAME .EQ. 1) THEN
	   BLOCKOUT(INEXT,IOUT) = OUT(ISUB,IOUT,IENTRY(IOUT))
	   IENTRY(IOUT) = IENTRY(IOUT) + 1
	  ENDIF
	END DO
	INEXT = INEXT + 1
	GO TO 20
  100   NTIMORD = INEXT - 1
	NRESET = 0
	TIMERESET = TIMADD*NRESET
	DO I = 1,NTIMORD
	 CALL THESAME(TIMORD(I),TIMADD*(NRESET+1),ISAME)
	 IF(ISAME .EQ. 1) THEN
	  NRESET = NRESET + 1
	  TIMERESET = TIMADD*NRESET
	 ENDIF
	 TIMORD(I) = TIMORD(I) - TIMERESET
	END DO
	RETURN
	END
	SUBROUTINE GETMAXTIM(NCOVA,TIMAX)
	IMPLICIT REAL*8(A-H,O-Z)
	CHARACTER READLINE*1000
	TIMAX = -1.D0
   10   READ(66,1,IOSTAT=IEND) READLINE
    1   FORMAT(A1000)
	IF(IEND .LT. 0) RETURN
	IF(READLINE(1:1) .EQ. '#' .OR. READLINE(1:2) .EQ. '"#') GO TO 10
	 CALL AFTERCOMMA(NCOVA,READLINE,2)
	 BACKSPACE(57)
	 READ(57,*) TIMEVENT
	 CLOSE(57)
	 CALL AFTERCOMMA(NCOVA,READLINE,3)
	 BACKSPACE(57)
	 READ(57,*,ERR=15) TIMDUR
	 GO TO 20
   15    TIMDUR = 0.D0
   20    TIME = TIMEVENT + TIMDUR
	 CLOSE(57)
	 IF(TIMAX .LT. TIME) TIMAX = TIME
	 GO TO 10
	END
	SUBROUTINE GETCHAR2(JSUB,CHARSUB)
	CHARACTER CHARSUB*3
	CHARACTER*1 B,C,D
	ILEFT = JSUB
	I3 = ILEFT/100
	ILEFT = ILEFT - I3*100
	I2 = ILEFT/10
 	ILEFT = ILEFT - I2*10
	I1 = ILEFT
	IF(I3 .EQ. 1) B='1'
	IF(I3 .EQ. 2) B='2'
	IF(I3 .EQ. 3) B='3'
	IF(I3 .EQ. 4) B='4'
	IF(I3 .EQ. 5) B='5'
	IF(I3 .EQ. 6) B='6'
	IF(I3 .EQ. 7) B='7'
	IF(I3 .EQ. 8) B='8'
	IF(I3 .EQ. 9) B='9'
	IF(I3 .EQ. 0) B='0'
	IF(I2 .EQ. 1) C='1'
	IF(I2 .EQ. 2) C='2'
	IF(I2 .EQ. 3) C='3'
	IF(I2 .EQ. 4) C='4'
	IF(I2 .EQ. 5) C='5'
	IF(I2 .EQ. 6) C='6'
	IF(I2 .EQ. 7) C='7'
	IF(I2 .EQ. 8) C='8'
	IF(I2 .EQ. 9) C='9'
	IF(I2 .EQ. 0) C='0'
	IF(I1 .EQ. 1) D='1'
	IF(I1 .EQ. 2) D='2'
	IF(I1 .EQ. 3) D='3'
	IF(I1 .EQ. 4) D='4'
	IF(I1 .EQ. 5) D='5'
	IF(I1 .EQ. 6) D='6'
	IF(I1 .EQ. 7) D='7'
	IF(I1 .EQ. 8) D='8'
	IF(I1 .EQ. 9) D='9'
	IF(I1 .EQ. 0) D='0'
	CHARSUB = B//C//D
	RETURN
	END
        SUBROUTINE PAUSE
        WRITE(*,1)
    1   FORMAT(' HIT ANY KEY TO CONTINUE: ')
        READ(*,*,ERR=10) IKEY
        IF(IKEY .EQ. 1) RETURN
   10   RETURN
        END
        SUBROUTINE NEWCSV
        IMPLICIT REAL*8(A-H,O-Z)
        CHARACTER READLINE*1000
   10   READ(77,4,IOSTAT=IEND) READLINE
    4   FORMAT(A1000)
        IF(IEND .LT. 0) GO TO 100
        DO IENDL = 1000,1,-1
         IF(READLINE(IENDL:IENDL) .NE. ' ') GO TO 20
        END DO
   20   CONTINUE
        DO I = 1,IENDL-2
         IF(READLINE(I:I+2) .EQ. ',.,') READLINE(I:I+2) = ',n,'
        END DO
        IF(READLINE(IENDL-1:IENDL) .EQ. ',.')
     1   READLINE(IENDL-1:IENDL) = ',n'
	IF(IENDL .LE. 26) THEN
	 WRITE(67,26) READLINE
   26    FORMAT(A26)
	 GO TO 10
	ENDIF
	IF(IENDL .LE. 51) THEN
	 WRITE(67,51) READLINE
   51    FORMAT(A51)
	 GO TO 10
	ENDIF
	IF(IENDL .LE. 76) THEN
	 WRITE(67,76) READLINE
   76    FORMAT(A76)
	 GO TO 10
	ENDIF
	IF(IENDL .LE. 101) THEN
	 WRITE(67,101) READLINE
  101    FORMAT(A101)
	 GO TO 10
	ENDIF
	IF(IENDL .LE. 126) THEN
	 WRITE(67,126) READLINE
  126    FORMAT(A126)
	 GO TO 10
	ENDIF
	IF(IENDL .LE. 151) THEN
	 WRITE(67,151) READLINE
  151    FORMAT(A151)
	 GO TO 10
	ENDIF
	IF(IENDL .LE. 176) THEN
	 WRITE(67,176) READLINE
  176    FORMAT(A176)
	 GO TO 10
	ENDIF
	IF(IENDL .LE. 201) THEN
	 WRITE(67,201) READLINE
  201    FORMAT(A201)
	 GO TO 10
	ENDIF
	IF(IENDL .LE. 226) THEN
	 WRITE(67,226) READLINE
  226    FORMAT(A226)
	 GO TO 10
	ENDIF
	IF(IENDL .LE. 251) THEN
	 WRITE(67,251) READLINE
  251    FORMAT(A251)
	 GO TO 10
	ENDIF
	IF(IENDL .LE. 276) THEN
	 WRITE(67,276) READLINE
  276    FORMAT(A276)
	 GO TO 10
	ENDIF
	IF(IENDL .LE. 301) THEN
	 WRITE(67,301) READLINE
  301    FORMAT(A301)
	 GO TO 10
	ENDIF
	IF(IENDL .LE. 326) THEN
	 WRITE(67,326) READLINE
  326    FORMAT(A326)
	 GO TO 10
	ENDIF
	IF(IENDL .LE. 351) THEN
	 WRITE(67,351) READLINE
  351    FORMAT(A351)
	 GO TO 10
	ENDIF
	IF(IENDL .LE. 376) THEN
	 WRITE(67,376) READLINE
  376    FORMAT(A376)
	 GO TO 10
	ENDIF
	IF(IENDL .LE. 401) THEN
	 WRITE(67,401) READLINE
  401    FORMAT(A401)
	 GO TO 10
	ENDIF
	IF(IENDL .LE. 426) THEN
	 WRITE(67,426) READLINE
  426    FORMAT(A426)
	 GO TO 10
	ENDIF
	IF(IENDL .LE. 451) THEN
	 WRITE(67,451) READLINE
  451    FORMAT(A451)
	 GO TO 10
	ENDIF
	IF(IENDL .LE. 476) THEN
	 WRITE(67,476) READLINE
  476    FORMAT(A476)
	 GO TO 10
	ENDIF
	IF(IENDL .LE. 501) THEN
	 WRITE(67,501) READLINE
  501    FORMAT(A501)
	 GO TO 10
	ENDIF
	IF(IENDL .LE. 526) THEN
	 WRITE(67,526) READLINE
  526    FORMAT(A526)
	 GO TO 10
	ENDIF
	IF(IENDL .LE. 551) THEN
	 WRITE(67,551) READLINE
  551    FORMAT(A551)
	 GO TO 10
	ENDIF
	IF(IENDL .LE. 576) THEN
	 WRITE(67,576) READLINE
  576    FORMAT(A576)
	 GO TO 10
	ENDIF
	IF(IENDL .LE. 601) THEN
	 WRITE(67,601) READLINE
  601    FORMAT(A601)
	 GO TO 10
	ENDIF
	IF(IENDL .LE. 626) THEN
	 WRITE(67,626) READLINE
  626    FORMAT(A626)
	 GO TO 10
	ENDIF
	IF(IENDL .LE. 651) THEN
	 WRITE(67,651) READLINE
  651    FORMAT(A651)
	 GO TO 10
	ENDIF
	IF(IENDL .LE. 676) THEN
	 WRITE(67,676) READLINE
  676    FORMAT(A676)
	 GO TO 10
	ENDIF
	IF(IENDL .LE. 701) THEN
	 WRITE(67,701) READLINE
  701    FORMAT(A701)
	 GO TO 10
	ENDIF
	IF(IENDL .LE. 726) THEN
	 WRITE(67,726) READLINE
  726    FORMAT(A726)
	 GO TO 10
	ENDIF
	IF(IENDL .LE. 751) THEN
	 WRITE(67,751) READLINE
  751    FORMAT(A751)
	 GO TO 10
	ENDIF
	IF(IENDL .LE. 776) THEN
	 WRITE(67,776) READLINE
  776    FORMAT(A776)
	 GO TO 10
	ENDIF
	IF(IENDL .LE. 801) THEN
	 WRITE(67,801) READLINE
  801    FORMAT(A801)
	 GO TO 10
	ENDIF
	IF(IENDL .LE. 826) THEN
	 WRITE(67,826) READLINE
  826    FORMAT(A826)
	 GO TO 10
	ENDIF
	IF(IENDL .LE. 851) THEN
	 WRITE(67,851) READLINE
  851    FORMAT(A851)
	 GO TO 10
	ENDIF
	IF(IENDL .LE. 876) THEN
	 WRITE(67,876) READLINE
  876    FORMAT(A876)
	 GO TO 10
	ENDIF
	IF(IENDL .LE. 901) THEN
	 WRITE(67,901) READLINE
  901    FORMAT(A901)
	 GO TO 10
	ENDIF
	IF(IENDL .LE. 926) THEN
	 WRITE(67,926) READLINE
  926    FORMAT(A926)
	 GO TO 10
	ENDIF
	IF(IENDL .LE. 951) THEN
	 WRITE(67,951) READLINE
  951    FORMAT(A951)
	 GO TO 10
	ENDIF
	IF(IENDL .LE. 976) THEN
	 WRITE(67,976) READLINE
  976    FORMAT(A976)
	 GO TO 10
	ENDIF
	WRITE(67,4) READLINE
	GO TO 10
  100   CLOSE(77)
        REWIND(67)
        RETURN
        END
        SUBROUTINE WORKTOCSV(NSUB,PATH,PREFIX,EXT,OUTCSVNAME)
        PARAMETER(MAXSUB=10000,MAXNUMEQ=7)
        IMPLICIT REAL*8(A-H,O-Z)
      DIMENSION SIG(5000),RS(5000,34),YO(594,MAXNUMEQ),C0(MAXNUMEQ),
     1 C1(MAXNUMEQ),C2(MAXNUMEQ),C3(MAXNUMEQ),TIM(594)
        CHARACTER PREFIX*3,EXT*3,NUMBER(MAXSUB)*5,PATFIL*32,PATH*61,
     1   TMPFILE*32,PATHFILE*93,SUBID*11,DESCR(26)*20,OUTCSVNAME*32,
     2   PATHFILE2*93,TOPLINE*1000,TOP1*58,READLINE*80,CHARSUB*5,
     3   COVTIGHT*550,CODE*14
        CODE = 'POPDATA DEC_11'
         TMPFILE = ' '
         TMPFILE = OUTCSVNAME
         CALL FULLNAME(PATH,TMPFILE,PATHFILE2)
         OPEN(29,FILE=PATHFILE2)
        DO ISUB = 1,NSUB
         CALL GETCHAR(ISUB,CHARSUB)
         NUMBER(ISUB) = CHARSUB
        END DO
	DO 1000 ISUB = 1,NSUB
	 PATFIL = PREFIX//NUMBER(ISUB)//'.'//EXT
         TMPFILE = ' '
         TMPFILE = PATFIL
         CALL FULLNAME(PATH,TMPFILE,PATHFILE)
         OPEN(33,FILE=PATHFILE)
         READ(33,9) SUBID
    9    FORMAT(T29,A11)
         SUBID = 'SIM'//NUMBER(ISUB)
         IF(ISUB .EQ. 1) THEN
          WRITE(29,14) CODE
   14     FORMAT(A14)
          CALL GETCOVNAME(NCOVA,DESCR)
          TOP1 = '#ID,EVID,TIME,DUR,DOSE,ADDL,II,INPUT,OUT,OUTEQ,C0,C1,C
     12,C3'
          TOPLINE = TOP1
          IF(NCOVA .GT. 0) THEN
           CALL COVSTRING(NCOVA,DESCR,COVTIGHT,NCOVTIGHT)
           TOPLINE = TOP1//COVTIGHT(1:NCOVTIGHT)
          ENDIF
          CALL CONDENSE(TOPLINE)
         ENDIF
   10	   READ(33,22) READLINE
   22    FORMAT(A80)
         IF(READLINE(12:23) .NE. 'NO. OF DRUGS') GO TO 10
         BACKSPACE(33)
         READ(33,13) NDRUG
   13    FORMAT(T2,I5)
         READ(33,*)
         NI = 2*NDRUG + NCOVA
         READ(33,13) ND
         READ(33,*)
         READ(33,*)
         IF(ND.EQ.0) GO TO 40
         DO I = 1,ND
          READ(33,*) SIG(I),(RS(I,J),J=1,NI)
         END DO
   40	   READ(33,22) READLINE
         IF(READLINE(12:23) .NE. 'NO. OF TOTAL') GO TO 40
         BACKSPACE(33)
         READ(33,13) NUMEQT
         READ(33,13) M
         DO I=1,M
          READ(33,*) TIM(I),(YO(I,J),J=1,NUMEQT)
         END DO
   50	   READ(33,22) READLINE
	   IF(READLINE(1:18) .NE. 'ASSAY COEFFICIENTS') GO TO 50
         IF(READLINE(20:25) .EQ. 'FOLLOW') THEN
          DO IEQ = 1,NUMEQT
           READ(33,*) C0(IEQ),C1(IEQ),C2(IEQ),C3(IEQ)
          END DO
         ENDIF
         IF(READLINE(20:25) .NE. 'FOLLOW') THEN
          DO IEQ = 1,NUMEQT
           C0(IEQ) = 0.D0
           C1(IEQ) = 0.D0
           C2(IEQ) = 0.D0
           C3(IEQ) = 0.D0
          END DO
         ENDIF
         CLOSE(33)
         CALL WRITECSV(SUBID,NDRUG,NCOVA,ND,SIG,RS,NUMEQT,M,TIM,YO,C0,
     1    C1,C2,C3)
 1000   CONTINUE
        CLOSE(29)
        RETURN
        END
	SUBROUTINE GETCOVNAME(NCOVA,DESCR)
	IMPLICIT REAL*8(A-H,O-Z)
	CHARACTER READLINE*1000,DESCR(26)*20
    2   FORMAT(A20)
   33   FORMAT(A1000)
        REWIND(33)
   10	READ(33,33) READLINE
	IF(READLINE(12:28) .NE. 'NO. OF ADDITIONAL') GO TO 10
	BACKSPACE(33)
    3 FORMAT(T2,I5)
      READ(33,3) NCOVA
   20	READ(33,33) READLINE
	IF(READLINE(2:16) .NE. 'COVARIATE NAMES') GO TO 20
        IF(NCOVA .GT. 0) THEN
         DO J = 1,NCOVA
          READ(33,33) READLINE
          DO I = 3,20
           IF(READLINE(I:I) .EQ. ' ') GO TO 30
          END DO
   30     DESCR(J) = READLINE(1:I-1)
         END DO
        ENDIF
	REWIND(33)
	RETURN
	END
        SUBROUTINE WRITECSV(SUBID,NDRUG,NCOVA,ND,SIG,RS,NUMEQT,M,TIM,
     1   YO,C0,C1,C2,C3)
        IMPLICIT REAL*8(A-H,O-Z)
        PARAMETER(MAXNUMEQ=7)
      DIMENSION SIG(5000),RS(5000,34),YO(594,MAXNUMEQ),C0(MAXNUMEQ),
     1 C1(MAXNUMEQ),C2(MAXNUMEQ),C3(MAXNUMEQ),TIM(594),BS(5000,7),
     2 NOIV(7),AMTIV(7,5000),DURIV(7,5000),IVDOSE(7,5000),XVERIFY(900)
        CHARACTER SUBID*11,DOSESTRING*12,OBSSTRING*52,BIGLINE*1000,
     1   SMALLLINE*1000
        IDOSENEXT = 0
        DO IDOSE = 1,ND
         DO JDRUG = 1,NDRUG
          BS(IDOSE,JDRUG) = RS(IDOSE,2*JDRUG)
         END DO
        END DO
        TIMOBSMAX = -1.D39
        DO I = 1,M
         IF(TIM(I) .GT. TIMOBSMAX) TIMOBSMAX = TIM(I)
        END DO
        DO JDRUG = 1,NDRUG
         NOIV(JDRUG) = 0
         IDOSE = 0
   40    IDOSE = IDOSE + 1
          IF(IDOSE .GT. ND) GO TO 60
          IF(SIG(IDOSE) .LT. 0.D0) GO TO 40
          CALL THESAME(RS(IDOSE,2*JDRUG-1),0.D0,ISAME)
          IF(ISAME .EQ. 0) THEN
           PREVIV = RS(IDOSE,2*JDRUG-1)
           IIDOSE = IDOSE
   50      IIDOSE = IIDOSE + 1
            IF(SIG(IIDOSE) .LE. 0.D0) THEN
             TIMIV = TIMOBSMAX - SIG(IDOSE)
             TOTIV = TIMIV*RS(IDOSE,2*JDRUG-1)
             GO TO 30
            ENDIF
            CALL THESAME(RS(IIDOSE,2*JDRUG-1),PREVIV,ISAME)
            IF(ISAME .EQ. 0) THEN
             TIMIV = SIG(IIDOSE) - SIG(IDOSE)
             TOTIV = TIMIV*RS(IDOSE,2*JDRUG-1)
             GO TO 30
            ENDIF
           IF(IIDOSE .LT. ND) GO TO 50
            TIMIV = TIMOBSMAX - SIG(IDOSE)
            TOTIV = TIMIV*RS(IDOSE,2*JDRUG-1)
            IIDOSE = ND + 1
   30      NOIV(JDRUG) = NOIV(JDRUG) + 1
           AMTIV(JDRUG,NOIV(JDRUG)) = TOTIV
           DURIV(JDRUG,NOIV(JDRUG)) = TIMIV
           IVDOSE(JDRUG,NOIV(JDRUG)) = IDOSE
           IDOSE = IIDOSE - 1
           GO TO 40
          ENDIF
         GO TO 40
   60    CONTINUE
        END DO
        DOSESTRING = ',.,.,.,.,.,.'
        DO I = 1,52
         OBSSTRING(I:I) = ' '
        END DO
        IF(NCOVA .GE. 1) THEN
         OBSSTRING(1:2) = ',.'
         ILASTOBS = 2
        ENDIF
        IF(NCOVA .GT. 1) THEN
         DO ICOVA = 2,NCOVA
          DO I = 52,1,-1
           IF(OBSSTRING(I:I) .NE. ' ') GO TO 65
          END DO
   65     ILAST = I
          OBSSTRING = OBSSTRING(1:ILAST)//',.'
         END DO
         ILASTOBS = ILAST + 2
        ENDIF
        IDOSE = 1
        IOBS = 1
  100   CONTINUE
        IF(IOBS .GT. M .AND. IDOSE .GT. ND) RETURN
        IF(IOBS .GT. M) GO TO 10
        IF(IDOSE .GT. ND) GO TO 20
        IDOSERESET = 0
        CALL THESAME(SIG(IDOSE),0.D0,ISAME)
        IF(ISAME .EQ. 1 .AND. IDOSE .GT. 1) IDOSERESET = 1
        IF(SIG(IDOSE) .LT. 0.D0 .AND. IDOSE .GT. 1) IDOSERESET = 1
        IOBSRESET = 0
        CALL THESAME(TIM(IOBS),0.D0,ISAME)
        IF(ISAME .EQ. 1 .AND. IOBS .GT. 1) IOBSRESET = 1
        IF(IDOSERESET .EQ. 1 .AND. IOBSRESET .EQ. 1) THEN
         IDOSENEXT = 1
         GO TO 20
        ENDIF
        IF(IDOSERESET .EQ. 1 .AND. IOBSRESET .EQ. 0) GO TO 20
        IF(IDOSERESET .EQ. 0 .AND. IOBSRESET .EQ. 1) GO TO 10
        IF(SIG(IDOSE) .GE. TIM(IOBS)) GO TO 20
   10    CONTINUE
        IDEVENT = 1
        CALL THESAME(SIG(IDOSE),0.D0,ISAME)
        IF(ISAME .EQ. 1 .AND. IDOSE .GT. 1) IDEVENT = 4
        IF(SIG(IDOSE) .LT. 0.D0 .AND. IDOSE .GT. 1) IDEVENT = 4
        IF(SIG(IDOSE) .LT. 0.D0) THEN
         CALL WRITESTEADY(NCOVA,NDRUG,IDOSE,SIG,RS,BS,DOSESTRING,
     1    SUBID,IDEVENT)
         IDOSE = IDOSE + 1
         IDOSENEXT = 0
         GO TO 100
        ENDIF
         IDOSWRITE = 0
         DO JDRUG = 1,NDRUG
          CALL THESAME(BS(IDOSE,JDRUG),0.D0,ISAME)
          IF(ISAME .EQ. 0) THEN
           OPEN(37)
           IF(NCOVA .GT. 0) THEN
            XVERIFY(1) = SIG(IDOSE)
            XVERIFY(2) = BS(IDOSE,JDRUG)
            DO K = 1,NCOVA
             XVERIFY(2+K) = RS(IDOSE,2*NDRUG+K)
            END DO
            CALL VERIFYVAL(2+NCOVA,XVERIFY)
            WRITE(37,13) SUBID,IDEVENT,XVERIFY(1),XVERIFY(2),
     1      JDRUG,DOSESTRING,(XVERIFY(2+K),K=1,NCOVA)
           ENDIF
   13      FORMAT(A11,',',I1,',',G14.7,',0,',G14.7,',.,.,',I1,A12,
     1      26(',',G14.7))
           IF(NCOVA .EQ. 0) THEN
            XVERIFY(1) = SIG(IDOSE)
            XVERIFY(2) = BS(IDOSE,JDRUG)
            CALL VERIFYVAL(2,XVERIFY)
            WRITE(37,14) SUBID,IDEVENT,XVERIFY(1),XVERIFY(2),
     1      JDRUG,DOSESTRING
           ENDIF
   14      FORMAT(A11,',',I1,',',G14.7,',0,',G14.7,',.,.,',I1,A12)
           BACKSPACE(37)
           READ(37,12) BIGLINE
           CLOSE(37)
           CALL REDUCE(BIGLINE,SMALLLINE)
           CALL CONDENSE(SMALLLINE)
           IDOSWRITE = 1
           IDEVENT = 1
          ENDIF
          IF(NOIV(JDRUG) .GE. 1) THEN
           DO IN = 1,NOIV(JDRUG)
            IF(IVDOSE(JDRUG,IN) .EQ. IDOSE) THEN
             OPEN(37)
           IF(NCOVA .GT. 0) THEN
            XVERIFY(1) = SIG(IDOSE)
            XVERIFY(2) = DURIV(JDRUG,IN)
            XVERIFY(3) = AMTIV(JDRUG,IN)
            DO K = 1,NCOVA
             XVERIFY(3+K) = RS(IDOSE,2*NDRUG+K)
            END DO
            CALL VERIFYVAL(3+NCOVA,XVERIFY)
            WRITE(37,16) SUBID,IDEVENT,(XVERIFY(IXV),IXV=1,3),
     1      JDRUG,DOSESTRING,(XVERIFY(3+K),K=1,NCOVA)
           ENDIF
   16      FORMAT(A11,',',I1,',',G14.7,',',G14.7,',',G14.7,',.,.,',I1,
     1      A12,26(',',G14.7))
           IF(NCOVA .EQ. 0) THEN
            XVERIFY(1) = SIG(IDOSE)
            XVERIFY(2) = DURIV(JDRUG,IN)
            XVERIFY(3) = AMTIV(JDRUG,IN)
            CALL VERIFYVAL(3,XVERIFY)
            WRITE(37,17) SUBID,IDEVENT,(XVERIFY(IXV),IXV=1,3),
     1       JDRUG,DOSESTRING
           ENDIF
   17      FORMAT(A11,',',I1,',',G14.7,',',G14.7,',',G14.7,',.,.,',I1,
     1      A12)
             BACKSPACE(37)
             READ(37,12) BIGLINE
             CLOSE(37)
             CALL REDUCE(BIGLINE,SMALLLINE)
             CALL CONDENSE(SMALLLINE)
             IDOSWRITE = 1
             IDEVENT = 1
             GO TO 70
            ENDIF
           END DO
          ENDIF
   70     CONTINUE
         END DO
         IF(IDOSWRITE .EQ. 0) THEN
          OPEN(37)
          IF(NCOVA .GT. 0) THEN
           XVERIFY(1) = SIG(IDOSE)
            DO K = 1,NCOVA
             XVERIFY(1+K) = RS(IDOSE,2*NDRUG+K)
            END DO
            CALL VERIFYVAL(1+NCOVA,XVERIFY)
           WRITE(37,18) SUBID,IDEVENT,XVERIFY(1),
     1     DOSESTRING,(XVERIFY(1+K),K=1,NCOVA)
          ENDIF
   18     FORMAT(A11,',',I1,',',G14.7,',0,0,.,.,1',A12,26(',',G14.7))
          IF(NCOVA .EQ. 0) THEN
           XVERIFY(1) = SIG(IDOSE)
            CALL VERIFYVAL(1,XVERIFY)
            WRITE(37,19) SUBID,IDEVENT,XVERIFY(1),DOSESTRING
          ENDIF
   19     FORMAT(A11,',',I1,',',G14.7,',0,0,.,.,1',A12)
          BACKSPACE(37)
          READ(37,12) BIGLINE
          CLOSE(37)
          CALL REDUCE(BIGLINE,SMALLLINE)
          CALL CONDENSE(SMALLLINE)
         ENDIF
         IDOSE = IDOSE + 1
         IDOSENEXT = 0
         GO TO 100
   20   CONTINUE
         DO IEQ = 1,NUMEQT
          CALL THESAME(YO(IOBS,IEQ),-99.D0,ISAME)
          IF(ISAME .EQ. 0) THEN
           OPEN(37)
           IF(NCOVA .GT. 0) THEN
            XVERIFY(1) = TIM(IOBS)
            XVERIFY(2) = YO(IOBS,IEQ)
            XVERIFY(3) = C0(IEQ)
            XVERIFY(4) = C1(IEQ)
            XVERIFY(5) = C2(IEQ)
            XVERIFY(6) = C3(IEQ)
            CALL VERIFYVAL(6,XVERIFY)
            WRITE(37,11)SUBID,XVERIFY(1),XVERIFY(2),IEQ,
     1      (XVERIFY(K),K=3,6),OBSSTRING(1:ILASTOBS)
           ENDIF
   11       FORMAT(A11,',0,',G14.7,',.,.,.,.,.,',G14.7,',',I1,',',
     1       G14.7,',',G14.7,',',G14.7,',',G14.7,A)
           IF(NCOVA .EQ. 0) THEN
            XVERIFY(1) = TIM(IOBS)
            XVERIFY(2) = YO(IOBS,IEQ)
            XVERIFY(3) = C0(IEQ)
            XVERIFY(4) = C1(IEQ)
            XVERIFY(5) = C2(IEQ)
            XVERIFY(6) = C3(IEQ)
            CALL VERIFYVAL(6,XVERIFY)
            WRITE(37,111)SUBID,XVERIFY(1),XVERIFY(2),IEQ,
     1      (XVERIFY(K),K=3,6)
           ENDIF
  111      FORMAT(A11,',0,',G14.7,',.,.,.,.,.,',G14.7,',',I1,',',
     1      G14.7,',',G14.7,',',G14.7,',',G14.7)
           BACKSPACE(37)
           READ(37,12) BIGLINE
   12      FORMAT(A1000)
           CLOSE(37)
           CALL REDUCE(BIGLINE,SMALLLINE)
           CALL CONDENSE(SMALLLINE)
          ENDIF
         END DO
         IOBS = IOBS + 1
         IF(IDOSENEXT .EQ. 1) GO TO 10
         GO TO 100
        END
        SUBROUTINE REDUCE(BIGLINE,SMALLLINE)
        CHARACTER BIGLINE*1000,SMALLLINE*1000
        DO I = 1,1000
         SMALLLINE(I:I) = ' '
        END DO
        SMALLLINE(1:11) = BIGLINE(1:11)
        IENTRY = 11
        DO I = 12,1000
         IF(BIGLINE(I:I) .NE. ' ') THEN
          IENTRY = IENTRY + 1
          SMALLLINE(IENTRY:IENTRY) = BIGLINE(I:I)
         ENDIF
        END DO
        IF(SMALLLINE(IENTRY:IENTRY) .EQ. ',')
     1   SMALLLINE(IENTRY:IENTRY) = ' '
        RETURN
        END
        SUBROUTINE CONDENSE(READLINE)
        CHARACTER READLINE*1000
	DO IEND = 1000,1,-1
	 IF(READLINE(IEND:IEND) .NE. ' ') GO TO 20
	END DO
   20   CONTINUE
	IF(IEND .LE. 26) THEN
	 WRITE(29,26) READLINE
   26    FORMAT(A26)
	 RETURN
	ENDIF
	IF(IEND .LE. 51) THEN
	 WRITE(29,51) READLINE
   51    FORMAT(A51)
	 RETURN
	ENDIF
	IF(IEND .LE. 76) THEN
	 WRITE(29,76) READLINE
   76    FORMAT(A76)
	 RETURN
	ENDIF
	IF(IEND .LE. 101) THEN
	 WRITE(29,101) READLINE
  101    FORMAT(A101)
	 RETURN
	ENDIF
	IF(IEND .LE. 126) THEN
	 WRITE(29,126) READLINE
  126    FORMAT(A126)
	 RETURN
	ENDIF
	IF(IEND .LE. 151) THEN
	 WRITE(29,151) READLINE
  151    FORMAT(A151)
	 RETURN
	ENDIF
	IF(IEND .LE. 176) THEN
	 WRITE(29,176) READLINE
  176    FORMAT(A176)
	 RETURN
	ENDIF
	IF(IEND .LE. 201) THEN
	 WRITE(29,201) READLINE
  201    FORMAT(A201)
	 RETURN
	ENDIF
	IF(IEND .LE. 226) THEN
	 WRITE(29,226) READLINE
  226    FORMAT(A226)
	 RETURN
	ENDIF
	IF(IEND .LE. 251) THEN
	 WRITE(29,251) READLINE
  251    FORMAT(A251)
	 RETURN
	ENDIF
	IF(IEND .LE. 276) THEN
	 WRITE(29,276) READLINE
  276    FORMAT(A276)
	 RETURN
	ENDIF
	IF(IEND .LE. 301) THEN
	 WRITE(29,301) READLINE
  301    FORMAT(A301)
	 RETURN
	ENDIF
	IF(IEND .LE. 326) THEN
	 WRITE(29,326) READLINE
  326    FORMAT(A326)
	 RETURN
	ENDIF
	IF(IEND .LE. 351) THEN
	 WRITE(29,351) READLINE
  351    FORMAT(A351)
	 RETURN
	ENDIF
	IF(IEND .LE. 376) THEN
	 WRITE(29,376) READLINE
  376    FORMAT(A376)
	 RETURN
	ENDIF
	IF(IEND .LE. 401) THEN
	 WRITE(29,401) READLINE
  401    FORMAT(A401)
	 RETURN
	ENDIF
	IF(IEND .LE. 426) THEN
	 WRITE(29,426) READLINE
  426    FORMAT(A426)
	 RETURN
	ENDIF
	IF(IEND .LE. 451) THEN
	 WRITE(29,451) READLINE
  451    FORMAT(A451)
	 RETURN
	ENDIF
	IF(IEND .LE. 476) THEN
	 WRITE(29,476) READLINE
  476    FORMAT(A476)
	 RETURN
	ENDIF
	IF(IEND .LE. 501) THEN
	 WRITE(29,501) READLINE
  501    FORMAT(A501)
	 RETURN
	ENDIF
	IF(IEND .LE. 526) THEN
	 WRITE(29,526) READLINE
  526    FORMAT(A526)
	 RETURN
	ENDIF
	IF(IEND .LE. 551) THEN
	 WRITE(29,551) READLINE
  551    FORMAT(A551)
	 RETURN
	ENDIF
	IF(IEND .LE. 576) THEN
	 WRITE(29,576) READLINE
  576    FORMAT(A576)
	 RETURN
	ENDIF
	IF(IEND .LE. 601) THEN
	 WRITE(29,601) READLINE
  601    FORMAT(A601)
	 RETURN
	ENDIF
	IF(IEND .LE. 626) THEN
	 WRITE(29,626) READLINE
  626    FORMAT(A626)
	 RETURN
	ENDIF
	IF(IEND .LE. 651) THEN
	 WRITE(29,651) READLINE
  651    FORMAT(A651)
	 RETURN
	ENDIF
	IF(IEND .LE. 676) THEN
	 WRITE(29,676) READLINE
  676    FORMAT(A676)
	 RETURN
	ENDIF
	IF(IEND .LE. 701) THEN
	 WRITE(29,701) READLINE
  701    FORMAT(A701)
	 RETURN
	ENDIF
	IF(IEND .LE. 726) THEN
	 WRITE(29,726) READLINE
  726    FORMAT(A726)
	 RETURN
	ENDIF
	IF(IEND .LE. 751) THEN
	 WRITE(29,751) READLINE
  751    FORMAT(A751)
	 RETURN
	ENDIF
	IF(IEND .LE. 776) THEN
	 WRITE(29,776) READLINE
  776    FORMAT(A776)
	 RETURN
	ENDIF
	IF(IEND .LE. 801) THEN
	 WRITE(29,801) READLINE
  801    FORMAT(A801)
	 RETURN
	ENDIF
	IF(IEND .LE. 826) THEN
	 WRITE(29,826) READLINE
  826    FORMAT(A826)
	 RETURN
	ENDIF
	IF(IEND .LE. 851) THEN
	 WRITE(29,851) READLINE
  851    FORMAT(A851)
	 RETURN
	ENDIF
	IF(IEND .LE. 876) THEN
	 WRITE(29,876) READLINE
  876    FORMAT(A876)
	 RETURN
	ENDIF
	IF(IEND .LE. 901) THEN
	 WRITE(29,901) READLINE
  901    FORMAT(A901)
	 RETURN
	ENDIF
	IF(IEND .LE. 926) THEN
	 WRITE(29,926) READLINE
  926    FORMAT(A926)
	 RETURN
	ENDIF
	IF(IEND .LE. 951) THEN
	 WRITE(29,951) READLINE
  951    FORMAT(A951)
	 RETURN
	ENDIF
	IF(IEND .LE. 976) THEN
	 WRITE(29,976) READLINE
  976    FORMAT(A976)
	 RETURN
	ENDIF
	WRITE(29,4) READLINE
    4    FORMAT(A1000)
        RETURN
        END
        SUBROUTINE COVSTRING(NCOVA,DESCR,COVTIGHT,NCOVTIGHT)
        CHARACTER DESCR(26)*20,COVTIGHT*550,BIGLINE*1000
        DO I = 1,1000
         BIGLINE(I:I) = ' '
        END DO
        BIGLINE(1:21) = ','//DESCR(1)
        IF(NCOVA .GT. 1) THEN
        DO I = 2,NCOVA
         CALL CALCSTART(BIGLINE,ILAST)
         BIGLINE = BIGLINE(1:ILAST)//','//DESCR(I)
        END DO
        ENDIF
        IF(NCOVA .EQ. 1) ILAST = 1
        NCOVTIGHT = ILAST + 20
        COVTIGHT = BIGLINE(1:NCOVTIGHT)
        RETURN
        END
        SUBROUTINE CALCSTART(BIGLINE,ILAST)
        CHARACTER BIGLINE*1000
        DO I = 1000,1,-1
         IF(BIGLINE(I:I) .NE. ' ') GO TO 10
        END DO
        ILAST = 0
        RETURN
   10   ILAST = I
        RETURN
        END
      SUBROUTINE CONVERTCSV
      IMPLICIT REAL*8(A-H,O-Z)
      CHARACTER READLINE*1000,ERRFIL*20
      COMMON/ERROR/ERRFIL
        READ(87,*)
        READ(87,4) READLINE
        ICOMMA = 0
        ISEMICOLON = 0
        DO I = 1,20
         IF(READLINE(I:I) .EQ. ',') ICOMMA = 1
         IF(READLINE(I:I) .EQ. ';') ISEMICOLON = 1
        END DO
        IF(ICOMMA .EQ. 1 .AND. ISEMICOLON .EQ. 1) THEN
         WRITE(*,121)
  121    FORMAT(/' YOUR .CSV FILE HAS BOTH COMMAS AND SEMICOLONS IN '/
     1' THE SECOND LINE. THIS IS A CONFLICT. IF YOU ARE USING THE '/
     2' "EUROPEAN" VERSION OF A .CSV FILE, WITH SEMICOLONS AS FIELD'/
     3' SEPARATORS AND COMMAS TO SEPARATE THE WHOLE AND FRACTIONAL'/
     4' PARTS OF NUMBERS, THERE SHOULD BE NO COMMAS IN THE SECOND'/
     5' LINE.'//
     6' SIMILARLY IF YOU ARE USING THE "AMERICAN" VERSION OF A .CSV'/
     7' FILE, WITH COMMAS AS FIELD SEPARATORS, AND PERIODS TO SEPARTE'/
     8' THE WHOLE AND FRACTIONAL PARTS OF NUMBERS, THERE SHOULD BE NO'/
     9' SEMICOLONS IN THE SECOND LINE.'//
     1' PLEASE CORRECT YOUR .CSV FILE AND RERUN THE PROGRAM.'//)
        OPEN(42,FILE=ERRFIL)
         WRITE(42,121)
        CLOSE(42)
         CALL PAUSE
         STOP
        ENDIF
        IF(ICOMMA .EQ. 1 .AND. ISEMICOLON .EQ. 0) ICONVERT = 0
        IF(ICOMMA .EQ. 0 .AND. ISEMICOLON .EQ. 1) ICONVERT = 1
        REWIND(87)
        OPEN(77)
   10   READ(87,4,IOSTAT=IEND) READLINE
    4   FORMAT(A1000)
        IF(IEND .LT. 0) GO TO 100
        DO IENDL = 1000,1,-1
         IF(READLINE(IENDL:IENDL) .NE. ' ') GO TO 20
        END DO
   20   CONTINUE
        DO I = 1,IENDL
         IF(ICONVERT .EQ. 1) THEN
          IF(READLINE(I:I) .EQ. ',') READLINE(I:I) = '.'
          IF(READLINE(I:I) .EQ. ';') READLINE(I:I) = ','
         ENDIF
        END DO
	IF(IENDL .LE. 26) THEN
	 WRITE(77,26) READLINE
   26    FORMAT(A26)
	 GO TO 10
	ENDIF
	IF(IENDL .LE. 51) THEN
	 WRITE(77,51) READLINE
   51    FORMAT(A51)
	 GO TO 10
	ENDIF
	IF(IENDL .LE. 76) THEN
	 WRITE(77,76) READLINE
   76    FORMAT(A76)
	 GO TO 10
	ENDIF
	IF(IENDL .LE. 101) THEN
	 WRITE(77,101) READLINE
  101    FORMAT(A101)
	 GO TO 10
	ENDIF
	IF(IENDL .LE. 126) THEN
	 WRITE(77,126) READLINE
  126    FORMAT(A126)
	 GO TO 10
	ENDIF
	IF(IENDL .LE. 151) THEN
	 WRITE(77,151) READLINE
  151    FORMAT(A151)
	 GO TO 10
	ENDIF
	IF(IENDL .LE. 176) THEN
	 WRITE(77,176) READLINE
  176    FORMAT(A176)
	 GO TO 10
	ENDIF
	IF(IENDL .LE. 201) THEN
	 WRITE(77,201) READLINE
  201    FORMAT(A201)
	 GO TO 10
	ENDIF
	IF(IENDL .LE. 226) THEN
	 WRITE(77,226) READLINE
  226    FORMAT(A226)
	 GO TO 10
	ENDIF
	IF(IENDL .LE. 251) THEN
	 WRITE(77,251) READLINE
  251    FORMAT(A251)
	 GO TO 10
	ENDIF
	IF(IENDL .LE. 276) THEN
	 WRITE(77,276) READLINE
  276    FORMAT(A276)
	 GO TO 10
	ENDIF
	IF(IENDL .LE. 301) THEN
	 WRITE(77,301) READLINE
  301    FORMAT(A301)
	 GO TO 10
	ENDIF
	IF(IENDL .LE. 326) THEN
	 WRITE(77,326) READLINE
  326    FORMAT(A326)
	 GO TO 10
	ENDIF
	IF(IENDL .LE. 351) THEN
	 WRITE(77,351) READLINE
  351    FORMAT(A351)
	 GO TO 10
	ENDIF
	IF(IENDL .LE. 376) THEN
	 WRITE(77,376) READLINE
  376    FORMAT(A376)
	 GO TO 10
	ENDIF
	IF(IENDL .LE. 401) THEN
	 WRITE(77,401) READLINE
  401    FORMAT(A401)
	 GO TO 10
	ENDIF
	IF(IENDL .LE. 426) THEN
	 WRITE(77,426) READLINE
  426    FORMAT(A426)
	 GO TO 10
	ENDIF
	IF(IENDL .LE. 451) THEN
	 WRITE(77,451) READLINE
  451    FORMAT(A451)
	 GO TO 10
	ENDIF
	IF(IENDL .LE. 476) THEN
	 WRITE(77,476) READLINE
  476    FORMAT(A476)
	 GO TO 10
	ENDIF
	IF(IENDL .LE. 501) THEN
	 WRITE(77,501) READLINE
  501    FORMAT(A501)
	 GO TO 10
	ENDIF
	IF(IENDL .LE. 526) THEN
	 WRITE(77,526) READLINE
  526    FORMAT(A526)
	 GO TO 10
	ENDIF
	IF(IENDL .LE. 551) THEN
	 WRITE(77,551) READLINE
  551    FORMAT(A551)
	 GO TO 10
	ENDIF
	IF(IENDL .LE. 576) THEN
	 WRITE(77,576) READLINE
  576    FORMAT(A576)
	 GO TO 10
	ENDIF
	IF(IENDL .LE. 601) THEN
	 WRITE(77,601) READLINE
  601    FORMAT(A601)
	 GO TO 10
	ENDIF
	IF(IENDL .LE. 626) THEN
	 WRITE(77,626) READLINE
  626    FORMAT(A626)
	 GO TO 10
	ENDIF
	IF(IENDL .LE. 651) THEN
	 WRITE(77,651) READLINE
  651    FORMAT(A651)
	 GO TO 10
	ENDIF
	IF(IENDL .LE. 676) THEN
	 WRITE(77,676) READLINE
  676    FORMAT(A676)
	 GO TO 10
	ENDIF
	IF(IENDL .LE. 701) THEN
	 WRITE(77,701) READLINE
  701    FORMAT(A701)
	 GO TO 10
	ENDIF
	IF(IENDL .LE. 726) THEN
	 WRITE(77,726) READLINE
  726    FORMAT(A726)
	 GO TO 10
	ENDIF
	IF(IENDL .LE. 751) THEN
	 WRITE(77,751) READLINE
  751    FORMAT(A751)
	 GO TO 10
	ENDIF
	IF(IENDL .LE. 776) THEN
	 WRITE(77,776) READLINE
  776    FORMAT(A776)
	 GO TO 10
	ENDIF
	IF(IENDL .LE. 801) THEN
	 WRITE(77,801) READLINE
  801    FORMAT(A801)
	 GO TO 10
	ENDIF
	IF(IENDL .LE. 826) THEN
	 WRITE(77,826) READLINE
  826    FORMAT(A826)
	 GO TO 10
	ENDIF
	IF(IENDL .LE. 851) THEN
	 WRITE(77,851) READLINE
  851    FORMAT(A851)
	 GO TO 10
	ENDIF
	IF(IENDL .LE. 876) THEN
	 WRITE(77,876) READLINE
  876    FORMAT(A876)
	 GO TO 10
	ENDIF
	IF(IENDL .LE. 901) THEN
	 WRITE(77,901) READLINE
  901    FORMAT(A901)
	 GO TO 10
	ENDIF
	IF(IENDL .LE. 926) THEN
	 WRITE(77,926) READLINE
  926    FORMAT(A926)
	 GO TO 10
	ENDIF
	IF(IENDL .LE. 951) THEN
	 WRITE(77,951) READLINE
  951    FORMAT(A951)
	 GO TO 10
	ENDIF
	IF(IENDL .LE. 976) THEN
	 WRITE(77,976) READLINE
  976    FORMAT(A976)
	 GO TO 10
	ENDIF
	WRITE(77,4) READLINE
	GO TO 10
  100   CLOSE(87)
        REWIND(77)
        RETURN
        END
      SUBROUTINE CSVCHANGE
      IMPLICIT REAL*8(A-H,O-Z)
      DIMENSION TIMENTRY(99999),IDENTRY(99999)
      CHARACTER READLINE*1000,CODEPAT*15,
     1 READLINE2*1000,HOLDMAT(99999)*150,TIMCHAR*50,SUBID*11,
     2 SUBIDPREV*11,ERRFIL*20
      COMMON/ERROR/ERRFIL
    1 FORMAT(A1000)
    2 FORMAT(A20)
      OPEN(66)
      ICODEPAT = 0
    6 FORMAT(A15)
      ICODEPAT = -1
      READ(67,6) CODEPAT
      IF(CODEPAT .EQ. '"POPDATA DEC_11') ICODEPAT = 1
      IF(CODEPAT(1:14) .EQ. 'POPDATA DEC_11') ICODEPAT = 1
      IF(CODEPAT .EQ. '"POPDATA APR_11') ICODEPAT = 0
      IF(CODEPAT(1:14) .EQ. 'POPDATA APR_11') ICODEPAT = 0
      IF(ICODEPAT .EQ. -1) THEN
       WRITE(*,7)
    7  FORMAT(//' YOUR PATIENT DATA BLOCK FILE IS NOT FROM THE'/
     1' ALLOWABLE SET OF SUCH FILES.'//
     2' A PATIENT DATA BLOCK FILE MUST HAVE "POPDATA XXX_XX IN'/
     3' COLUMNS 1 THROUGH 15 ON LINE 1, WHERE  XXX_XX  IS APR_11 OR A '/
     4' MORE RECENT DATE.'//)
       WRITE(*,*)' THE PROGRAM STOPS.'
        OPEN(42,FILE=ERRFIL)
         WRITE(42,7)
         WRITE(42,*)' THE PROGRAM STOPS.'
        CLOSE(42)
       CALL PAUSE
       STOP
      ENDIF
      IF(ICODEPAT .EQ. 0) THEN
       CODEPAT = 'POPDATA APR_11'
       WRITE(66,6) CODEPAT
 1020  READ(67,1,IOSTAT=IEND) READLINE
        IF(IEND .LT. 0) THEN
         CLOSE(67)
         RETURN
        ENDIF
       WRITE(66,1) READLINE
       GO TO 1020
      ENDIF
      CODEPAT = 'POPDATA APR_11'
      WRITE(66,6) CODEPAT
      READ(67,1) READLINE
      DO I = 1,50
       IF(READLINE(I:I+7) .EQ. ',ADDL,II') THEN
        ISS = I
        GO TO 10
       ENDIF
      END DO
       WRITE(*,8)
    8  FORMAT(//' YOUR PATIENT DATA BLOCK FILE IS NOT FROM THE '/
     1' ALLOWABLE SET OF SUCH FILES.'//
     2' A PATIENT DATA BLOCK FILE MUST HAVE ",ADDL,II" AS THE 6TH AND'/
     3' 7TH COLUMN HEADINGS ON LINE 2.'//)
       WRITE(*,*)' THE PROGRAM STOPS.'
        OPEN(42,FILE=ERRFIL)
         WRITE(42,8)
         WRITE(42,*)' THE PROGRAM STOPS.'
        CLOSE(42)
       CALL PAUSE
       STOP
   10 CONTINUE
      READLINE2(1:ISS-1) = READLINE(1:ISS-1)
      READLINE2(ISS:992) = READLINE(ISS+8:1000)
      WRITE(66,1) READLINE2
        NCOMMA = 0
        DO ISTART = 1,1000
         IF(READLINE(ISTART:ISTART) .EQ. ',') THEN
          NCOMMA = NCOMMA + 1
         ENDIF
        END DO
        NCOVA = NCOMMA - 13
	SUBIDPREV = '%^&*'
	SUBID = '%^&*'
      NROW = 0
   20 READ(67,1,IOSTAT=IEND) READLINE
	IF(IEND .LT. 0) GO TO 100
      IF(READLINE(1:1) .EQ. '#') GO TO 20
	CALL AFTERCOMMA(NCOVA,READLINE,0)
	BACKSPACE(57)
	READ(57,222) SUBID
  222 FORMAT(A11)
	CLOSE(57)
	CALL GETID(SUBID)
      IF(SUBID .NE. SUBIDPREV) GO TO 100
	CALL AFTERCOMMA(NCOVA,READLINE,1)
	BACKSPACE(57)
	READ(57,*) IDEVENT
	CLOSE(57)
      IF(IDEVENT .EQ. 0) THEN
       NROW = NROW + 1
       CALL GETCOM(NCOMMA,READLINE,I5,I7)
       HOLDMAT(NROW) = READLINE(1:I5)//READLINE(I7+1:150)
      ENDIF
      IF(IDEVENT .EQ. 1 .OR. IDEVENT .EQ. 4) THEN
       CALL AFTERCOMMA(NCOVA,READLINE,5)
       BACKSPACE(57)
       READ(57,*,ERR=25) IADDL
       CLOSE(57)
       GO TO 30
   25  IADDL = 0
   30  CONTINUE
       IF(IADDL .GE. 0) THEN
        NROW = NROW + 1
        CALL GETCOM(NCOMMA,READLINE,I5,I7)
        HOLDMAT(NROW) = READLINE(1:I5)//READLINE(I7+1:150)
       ENDIF
       IF(IADDL .GT. 0) THEN
	  CALL AFTERCOMMA(NCOVA,READLINE,6)
	  BACKSPACE(57)
	  READ(57,*,ERR=35) XII
	  CLOSE(57)
        GO TO 40
   35   WRITE(*,36) NROW + 3
   36   FORMAT(/' THE INTERDOSE INTERVAL IS MISSING ON LINE NO. ',I6//
     1' PLEASE CORRECT YOUR .csv FILE AND RERUN THE PROGRAM.'/)
        OPEN(42,FILE=ERRFIL)
         WRITE(42,36) NROW + 3
        CLOSE(42)
        CALL PAUSE
        STOP
   40   CONTINUE
	  CALL AFTERCOMMA(NCOVA,READLINE,2)
	  BACKSPACE(57)
	  READ(57,*) TIM
	  CLOSE(57)
        DO IADD = 1,IADDL
         READLINE(1:150) = HOLDMAT(NROW)
         OPEN(57,STATUS='SCRATCH')
         WRITE(57,*) TIM + XII*IADD
         BACKSPACE(57)
         READ(57,41) TIMCHAR
   41    FORMAT(A50)
         DO IEND = 50,1,-1
          IF(TIMCHAR(IEND:IEND) .NE. ' ') GO TO 50
         END DO
   50    CONTINUE
         ICOMMA = 0
         DO I = 1,150
          IF(READLINE(I:I) .EQ. ',') THEN
           ICOMMA = ICOMMA + 1
           IF(ICOMMA .EQ. 2) I2 = I
           IF(ICOMMA .EQ. 3) THEN
            I3 = I
            GO TO 60
           ENDIF
          ENDIF
         END DO
   60    READLINE2 =
     1    READLINE(1:I2)//TIMCHAR(1:IEND)//READLINE(I3:150)
         NROW = NROW + 1
         HOLDMAT(NROW) = READLINE2(1:150)
        END DO
       ENDIF
       IF(IADDL .EQ. -1) THEN
	  CALL AFTERCOMMA(NCOVA,READLINE,6)
	  BACKSPACE(57)
	  READ(57,*,ERR=65) XII
	  CLOSE(57)
        GO TO 70
   65   WRITE(*,36) NROW + 3
        OPEN(42,FILE=ERRFIL)
         WRITE(42,36) NROW + 3
        CLOSE(42)
        CALL PAUSE
        STOP
   70   CONTINUE
        NROW = NROW + 1
        CALL GETCOM(NCOMMA,READLINE,I5,I7)
        HOLDMAT(NROW) = READLINE(1:I5)//READLINE(I7+1:150)
        READLINE(1:150) = HOLDMAT(NROW)
         OPEN(57,STATUS='SCRATCH')
         WRITE(57,*) -XII
         BACKSPACE(57)
         READ(57,41) TIMCHAR
         DO IEND = 50,1,-1
          IF(TIMCHAR(IEND:IEND) .NE. ' ') GO TO 80
         END DO
   80    CONTINUE
         ICOMMA = 0
         DO I = 1,150
          IF(READLINE(I:I) .EQ. ',') THEN
           ICOMMA = ICOMMA + 1
           IF(ICOMMA .EQ. 2) I2 = I
           IF(ICOMMA .EQ. 3) THEN
            I3 = I
            GO TO 90
           ENDIF
          ENDIF
         END DO
   90    READLINE2 =
     1    READLINE(1:I2)//TIMCHAR(1:IEND)//READLINE(I3:150)
         HOLDMAT(NROW) = READLINE2(1:150)
       ENDIF
      ENDIF
      GO TO 20
  100 CONTINUE
      DO I = 1,NROW
       READLINE(1:150) = HOLDMAT(I)
       CALL AFTERCOMMA(NCOVA,READLINE,1)
	 BACKSPACE(57)
	 READ(57,*) IDEVENT
       IDENTRY(I) = IDEVENT
	 CLOSE(57)
       CALL AFTERCOMMA(NCOVA,READLINE,2)
	 BACKSPACE(57)
	 READ(57,*) TIM
       TIMENTRY(I) = TIM
	 CLOSE(57)
      END DO
      NN = 0
      NFIRST = 1
  150 CONTINUE
      NN = NN + 1
      IF(NN .GT. NROW) GO TO 200
      IF(IDENTRY(NN) .NE. 4 .AND. NN .LT. NROW) GO TO 150
      IF(NN .EQ. NROW) NLAST = NROW
      IF(IDENTRY(NN) .EQ. 4) NLAST = NN - 1
      CALL ORDERHOLD(HOLDMAT,NFIRST,NLAST,IDENTRY,TIMENTRY)
  151 FORMAT(A150)
      DO I = NFIRST,NLAST
       WRITE(66,151) HOLDMAT(I)
      END DO
      NFIRST = NLAST + 1
      GO TO 150
  200 CONTINUE
	IF(IEND .LT. 0) THEN
       CLOSE(67)
       RETURN
      ENDIF
      SUBIDPREV = SUBID
      NROW = 0
      BACKSPACE(67)
      GO TO 20
      END
      SUBROUTINE GETCOM(NCOMMA,READLINE,I5,I7)
      CHARACTER READLINE*1000,ERRFIL*20
      COMMON/ERROR/ERRFIL
    1 FORMAT(A1000)
      ICOMMA = 0
      DO I = 1,300
       IF(READLINE(I:I) .EQ. ',') THEN
        ICOMMA = ICOMMA + 1
         IF(ICOMMA .EQ. 5) I5 = I
          IF(ICOMMA .EQ. 7) THEN
           I7 = I
           RETURN
          ENDIF
       ENDIF
      END DO
      WRITE(*,2) NCOMMA,READLINE(1:70)
    2 FORMAT(/' ONE OF THE LINES IN YOUR .cvs FILE HAS AN ERROR.'/
     1' IT IS SUPPOSED TO HAVE ',I2,' COMMAS, BUT IT HAS FEWER THAN'/
     2' 7. THE FOLLOWING LINE SHOWS THE 1ST 70 CHARACTERS OF THE LINE:'/
     3' ',A70//
     4' THE PROGRAM STOPS.'/)
        OPEN(42,FILE=ERRFIL)
         WRITE(42,2) NCOMMA,READLINE(1:70)
        CLOSE(42)
      CALL PAUSE
      STOP
      END
      SUBROUTINE ORDERHOLD(HOLDMAT,NFIRST,NLAST,IDENTRY,TIMENTRY)
      IMPLICIT REAL*8(A-H,O-Z)
      DIMENSION TIMENTRY(99999),IDENTRY(99999),IZ(99999),IZZ(99999),
     1 DOSTIME(99999)
      CHARACTER HOLDMAT(99999)*150,HOLDMAT2(99999)*150
      NDOSE = 0
      DO I = NFIRST,NLAST
       IF(IDENTRY(I) .EQ. 1 .OR. IDENTRY(I) .EQ. 4) THEN
        NDOSE = NDOSE + 1
        HOLDMAT2(NDOSE) = HOLDMAT(I)
        DOSTIME(NDOSE) = TIMENTRY(I)
        IZ(NDOSE) = -99
       ENDIF
      END DO
      NEXT = NDOSE
      DO I = NFIRST,NLAST
       IF(IDENTRY(I) .EQ. 0) THEN
        NEXT = NEXT + 1
        HOLDMAT2(NEXT) = HOLDMAT(I)
       ENDIF
      END DO
	 DO IPLACE = 1,NDOSE
	  TEMP = 1.D50
	  DO I=1,NDOSE
	   IF(DOSTIME(I) .LT. TEMP .AND. IZ(I) .EQ. -99) THEN
	    TEMP = DOSTIME(I)
	    IND = I
	   ENDIF
	  END DO
	  IZZ(IPLACE) = IND
	  IZ(IND) = 0
	 END DO
      DO IDOSE = 1,NDOSE
       HOLDMAT(NFIRST-1+IDOSE) = HOLDMAT2(IZZ(IDOSE))
      END DO
      NEXT = NDOSE
      DO IOBS = NFIRST + NDOSE,NLAST
       NEXT = NEXT + 1
       HOLDMAT(IOBS) = HOLDMAT2(NEXT)
      END DO
      RETURN
      END
      SUBROUTINE PREDLAST3(NN,NSET,XSTORE,XPRED,ICONV)
      IMPLICIT REAL*8(A-H,O-Z)
      DIMENSION XSTORE(100,20),XPRED(20),COMP(5,20)
        TOL1 = .0005D0
        TOL2 = .0005D0
      II = 0
      DO I = NSET-4,NSET
       II = II+1
       DO J = 1,NN
        COMP(II,J) = XSTORE(I,J)
       END DO
      END DO
      DO IN = 1,NN
       A1 = COMP(1,IN)
       A2 = COMP(2,IN)
       A3 = COMP(3,IN)
       DEL1 = A2 - A1
       DEL2 = A3 - A2
       CALL THESAME(DEL1,0.D0,ISAME1)
       IF(ISAME1 .EQ. 0) THEN
        F = DEL2/DEL1
        CALL THESAME(F,1.D0,ISAMEF1)
        IF(ISAMEF1 .EQ. 0) PRED1 = A1 + DEL1/(1.D0 - F)
       ENDIF
       A1 = COMP(2,IN)
       A2 = COMP(3,IN)
       A3 = COMP(4,IN)
       DEL1 = A2 - A1
       DEL2 = A3 - A2
       CALL THESAME(DEL1,0.D0,ISAME2)
       IF(ISAME2 .EQ. 0) THEN
        F = DEL2/DEL1
        CALL THESAME(F,1.D0,ISAMEF2)
        IF(ISAMEF2 .EQ. 0) PRED2 = A1 + DEL1/(1.D0 - F)
       ENDIF
       A1 = COMP(3,IN)
       A2 = COMP(4,IN)
       A3 = COMP(5,IN)
       DEL1 = A2 - A1
       DEL2 = A3 - A2
       CALL THESAME(DEL1,0.D0,ISAME3)
       IF(ISAME3 .EQ. 0) THEN
        F = DEL2/DEL1
        CALL THESAME(F,1.D0,ISAMEF3)
        IF(ISAMEF3 .EQ. 0) PRED3 = A1 + DEL1/(1.D0 - F)
       ENDIF
       ISAMETOT = ISAME1 + ISAME2 + ISAME3
       ISAMEFTOT = ISAMEF1 + ISAMEF2 + ISAMEF3
       IF(ISAMETOT .EQ. 0 .AND. ISAMEFTOT .EQ. 0) THEN
        DEN = PRED1+PRED3-2.D0*PRED2
        CALL THESAME(DEN,0.D0,ISAMEDEN)
        IF(ISAMEDEN .EQ. 0)
     1   PREDNEG = (PRED1*PRED3 - PRED2*PRED2)/DEN
        ICONV = 1
        IF(DABS(PRED3/PRED2 - 1.D0) .GE. TOL1) ICONV = 0
        IF(ISAMEDEN .EQ. 0 .AND. DABS(PREDNEG/PRED3 - 1.D0) .GE. TOL2)
     1   ICONV = 0
        IF(ICONV .EQ. 1 .AND. ISAMEDEN .EQ. 1) XPRED(IN) = PRED3
        IF(ICONV .EQ. 1 .AND. ISAMEDEN .EQ. 0) XPRED(IN) = PREDNEG
       ENDIF
       IF(ISAMETOT .EQ. 3) THEN
        CALL THESAME(COMP(5,IN),COMP(1,IN),ISAME)
        IF(ISAME .EQ. 1) THEN
         ICONV = 1
         XPRED(IN) = COMP(1,IN)
        ENDIF
        IF(ISAME .EQ. 0) ICONV = 0
       ENDIF
       IF(ISAMETOT .EQ. 1 .OR. ISAMETOT .EQ. 2) ICONV = 0
       IF(ICONV .EQ. 0) RETURN
      END DO
      RETURN
      END
      SUBROUTINE NEWWORK1
      IMPLICIT REAL*8(A-H,O-Z)
	PARAMETER(MAXNUMEQ=7)
      DIMENSION SIG(5000),RS(5000,34),DELTAIV(7),ORDELT(7),
     1 RSS(5000,34),SIGG(5000),TIM(594),TIMM(594),YO(594,MAXNUMEQ),
     2 TIMDELAY(99),XVERIFY(900)
      CHARACTER READLINE*300,ERRFIL*20
      COMMON/ERROR/ERRFIL
 1717 FORMAT(A300)
   10 READ(31,1717) READLINE
      IF(READLINE(12:23) .NE. 'NO. OF DRUGS') GO TO 10
    3 FORMAT(T2,I5)
      BACKSPACE(31)
      READ(31,3) NDRUG
      READ(31,3) NADD
      READ(31,3) ND
	NI = 2*NDRUG + NADD
      IF(ND .EQ. 0) ICOPY = 1
      IF(ND .GE. 1) THEN
       READ(31,*)
       READ(31,*)
       ICOPY = 1
       DO I = 1,ND
        READ(31,*) SIG(I),(RS(I,J),J=1,NI)
        IF(SIG(I) .LT. 0.D0) ICOPY = 0
       END DO
      ENDIF
      IF(ICOPY .EQ. 1) THEN
 1720  BACKSPACE(31)
       BACKSPACE(31)
       READ(31,1717,IOSTAT=IEND) READLINE
	 IF(IEND .LT. 0) THEN
        WRITE(*,1721)
 1721   FORMAT(/' PATIENT DATA INFORMATION WAS NOT READ CORRECTLY'/
     1' FROM THE INSTRUCTION FILE - IN SUBROUTINE NEWWORK1.')
        OPEN(42,FILE=ERRFIL)
         WRITE(42,1721)
        CLOSE(42)
	  CALL PAUSE
	  STOP
	 ENDIF
       IF(READLINE(3:16) .NE. 'LAST AND FIRST') GO TO 1720
       WRITE(41,1717) READLINE
   30  READ(31,1717) READLINE
       WRITE(41,1717) READLINE
       IF(READLINE(12:23) .NE. 'NO. OF DOSE ') GO TO 30
       DO I = 1,2
        READ(31,1717) READLINE
        WRITE(41,1717) READLINE
       END DO
       IF(ND.EQ.0) GO TO 40
       DO I = 1,ND
        READ(31,*) SIG(I),(RS(I,J),J=1,NI)
        WRITE(41,*) SIG(I),(RS(I,J),J=1,NI)
       END DO
   40	 READ(31,1717) READLINE
       WRITE(41,1717) READLINE
       IF(READLINE(12:23) .NE. 'NO. OF TOTAL') GO TO 40
       BACKSPACE(31)
       READ(31,3) NUMEQT
       READ(31,3) M
       BACKSPACE(31)
       READ(31,1717) READLINE
       WRITE(41,1717) READLINE
       DO I = 1,M
        READ(31,*) TIM(I),(YO(I,J),J=1,NUMEQT)
        WRITE(41,*) TIM(I),(YO(I,J),J=1,NUMEQT)
       END DO
   50	 READ(31,1717,IOSTAT=IEND) READLINE
       IF(IEND .LT. 0) GO TO 100
   	 IF(READLINE(3:16) .EQ. 'LAST AND FIRST') GO TO 100
       WRITE(41,1717) READLINE
       GO TO 50
  100	 CLOSE(31)
      ENDIF
      IF(ICOPY .EQ. 0) THEN
      ILINE = 0
      DELDOSE = 0.D0
      NSECTION = 0
      DO ID = 1,ND
       IF(SIG(ID) .GE. 0.D0) THEN
        CALL THESAME(SIG(ID),0.D0,ISAME)
        IF(ISAME .EQ. 1) THEN
         DELDOSE = 0.D0
         NSECTION = NSECTION + 1
         TIMDELAY(NSECTION) = 0.0
        ENDIF
        ILINE = ILINE + 1
        SIGG(ILINE) = SIG(ID) + 100.D0*DELDOSE
        DO J = 1,NI
         RSS(ILINE,J) = RS(ID,J)
        END DO
       ENDIF
       IF(SIG(ID) .LT. 0.D0) THEN
        DO IDRUG = 1,NDRUG
         DELTAIV(IDRUG) = 0.D0
         IF(RS(ID,2*IDRUG) .GT. 0.D0 .AND. RS(ID,2*IDRUG-1) .GT. 0.D0)
     1    DELTAIV(IDRUG) = RS(ID,2*IDRUG)/RS(ID,2*IDRUG-1)
         IF(RS(ID,2*IDRUG) .LE. 0.D0 .AND. RS(ID,2*IDRUG-1) .GT. 0) THEN
          XVERIFY(1) = SIG(ID)
          XVERIFY(2) = RS(ID,2*IDRUG-1)
          XVERIFY(2) = RS(ID,2*IDRUG)
          CALL VERIFYVAL(3,XVERIFY)
          WRITE(*,101) ID,XVERIFY(1),IDRUG,XVERIFY(2),XVERIFY(3)
  101     FORMAT(//' THERE IS AN ERROR IN YOUR INSTRUCTION FILE, AS'/
     1' DETERMINED BY SUBROUTINE NEWWORK1.'//
     2' ONE OF THE SUBJECTS HAS A STEADY STATE DOSE SET WITH A '/
     3' POSITIVE IV RATE, BUT WITH A TOTAL DOSE AMOUNT .LE. 0.'//
     4' IN PARTICULAR, FOR DOSE EVENT ',I4,' AND TIME ',G19.9,/
     5' FOR DRUG ',I2,', THE IV VALUE IS ',G19.9,' WHILE THE TOTAL'/
     6' DOSE AMOUNT IS ',G19.9//
     7' THE PROGRAM STOPS. PLEASE CORRECT THE ERROR BEFORE RERUNNING.'/)
        OPEN(42,FILE=ERRFIL)
         WRITE(42,101) ID,XVERIFY(1),IDRUG,XVERIFY(2),XVERIFY(3)
        CLOSE(42)
          CALL PAUSE
          STOP
         ENDIF
        END DO
        CALL ORDERDELTA(NDRUG,DELTAIV,NDELTA,ORDELT)
        DELDOSE = -SIG(ID)
        NSECTION = NSECTION + 1
        TIMDELAY(NSECTION) = 100.D0*DELDOSE
        DO ISET = 1,101
         ILINE = ILINE + 1
         DO IDRUG = 1,NDRUG
          RSS(ILINE,2*IDRUG-1) = RS(ID,2*IDRUG-1)
          RSS(ILINE,2*IDRUG) = RS(ID,2*IDRUG)
          IF(RS(ID,2*IDRUG-1) .GT. 0.D0) RSS(ILINE,2*IDRUG) = 0.D0
         END DO
         DO IADD = 1,NADD
          RSS(ILINE,2*NDRUG+IADD) = RS(ID,2*NDRUG+IADD)
         END DO
         IF(ISET .EQ. 1) THEN
          SIGG(ILINE) = SIG(ID)
          DOSESTART = 0.D0
         ENDIF
         IF(ISET .GT. 1) THEN
          SIGG(ILINE) = (ISET-1)*DELDOSE
          DOSESTART = SIGG(ILINE)
         ENDIF
        IF(NDELTA .GT. 0) THEN
         DO INDEL = 1,NDELTA
          ILINE = ILINE + 1
          DO IDRUG = 1,NDRUG
           RSS(ILINE,2*IDRUG-1) = 0.D0
           IF(DELTAIV(IDRUG) .GT. ORDELT(INDEL))
     1      RSS(ILINE,2*IDRUG-1) = RS(ID,2*IDRUG-1)
           RSS(ILINE,2*IDRUG) = 0.D0
          END DO
          DO IADD = 1,NADD
           RSS(ILINE,2*NDRUG+IADD) = RS(ID,2*NDRUG+IADD)
          END DO
          SIGG(ILINE) = DOSESTART + ORDELT(INDEL)
         END DO
        ENDIF
        END DO
       ENDIF
      END DO
   20  READ(31,1717) READLINE
       IF(READLINE(12:23) .NE. 'NO. OF TOTAL') GO TO 20
       BACKSPACE(31)
       READ(31,3) NUMEQT
       READ(31,3) M
       NSECTION = 1
       DO I = 1,M
        READ(31,*) TIM(I),(YO(I,J),J=1,NUMEQT)
        CALL THESAME(TIM(I),0.D0,ISAME)
        IF(ISAME .EQ. 1 .AND. I .GT. 1) NSECTION = NSECTION + 1
        IF(ISAME .EQ. 1) TIMM(I) = 0.D0
        IF(ISAME .EQ. 0) TIMM(I) = TIM(I) + TIMDELAY(NSECTION)
       END DO
 1820  BACKSPACE(31)
       BACKSPACE(31)
       READ(31,1717,IOSTAT=IEND) READLINE
	 IF(IEND .LT. 0) THEN
        WRITE(*,1721)
        OPEN(42,FILE=ERRFIL)
         WRITE(42,1721)
        CLOSE(42)
	  CALL PAUSE
	  STOP
	 ENDIF
       IF(READLINE(3:16) .NE. 'LAST AND FIRST') GO TO 1820
       WRITE(41,1717) READLINE
   60  READ(31,1717) READLINE
       WRITE(41,1717) READLINE
       IF(READLINE(12:23) .NE. 'NO. OF ADDIT') GO TO 60
       READ(31,1717) READLINE
       WRITE(41,133) ILINE
  133  FORMAT(I6,' ... NO. OF DOSE EVENTS')
       DO I = 1,2
        READ(31,1717) READLINE
        WRITE(41,1717) READLINE
       END DO
       SIGLAST = -999999.D0
       DO I = 1,ILINE
        WRITE(41,*) SIGG(I),(RSS(I,J),J=1,NI)
        CALL THESAME(SIGLAST,SIGG(I),ISAME)
        IF(ISAME .EQ. 1) THEN
         XVERIFY(1) = SIGLAST
         CALL VERIFYVAL(1,XVERIFY)
         WRITE(*,4031) XVERIFY(1)
 4031    FORMAT(/' IN SUBROUTINE NEWWORK1, TWO CONSECUTIVE DOSE TIMES'/
     1' HAVE THE SAME VALUE IN WORKING COPY FORMAT, ',F20.8//
     2' THIS COULD CAUSE UNEXPECTED RESULTS IF THE PROGRAM WERE TO '/
     3' CONTINUE. SO THE PROGRAM NOW STOPS. PLEASE CHECK YOUR PATIENT '/
     4' INFORMATION AND CORRECT (NOTE THAT THIS CAN HAPPEN IF THE '/
     5' FIRST DOSE FOLLOWING A STEADY STATE DOSE SET HAS THE SAME'/
     6' STARTING TIME AS THE ENDING TIME OF THE LAST STEADY STATE '/
     7' DOSE SET.)'//)
        OPEN(42,FILE=ERRFIL)
         WRITE(42,4031) XVERIFY(1)
        CLOSE(42)
	  CALL PAUSE
	  STOP
	 ENDIF
       SIGLAST = SIGG(I)
       END DO
       DO I = 1,ND
        READ(31,*) SIG(I),(RS(I,J),J=1,NI)
       END DO
       DO I = 1,3
        READ(31,1717) READLINE
        WRITE(41,1717) READLINE
       END DO
      DO I = 1,M
       WRITE(41,*) TIMM(I),(YO(I,J),J=1,NUMEQT)
       READ(31,*) TIM(I),(YO(I,J),J=1,NUMEQT)
      END DO
   70	 READ(31,1717,IOSTAT=IEND) READLINE
       IF(IEND .LT. 0) GO TO 200
   	 IF(READLINE(3:16) .EQ. 'LAST AND FIRST') GO TO 200
       WRITE(41,1717) READLINE
       GO TO 70
  200	 CLOSE(31)
      ENDIF
      RETURN
      END
      SUBROUTINE ORDERDELTA(NDRUG,DELTAIV,NDELTA,ORDELT)
      IMPLICIT REAL*8(A-H,O-Z)
      DIMENSION DELTAIV(7),ORDELT(7),X(7)
      DO IDRUG = 1,NDRUG
       X(IDRUG) = DELTAIV(IDRUG)
      END DO
      DO IDRUG = 2, NDRUG
       IDRUGNEW = IDRUG
       ICOMP = IDRUG
  110  ICOMP = ICOMP - 1
       IF(X(IDRUGNEW) .LT. X(ICOMP)) THEN
        VALUE = X(IDRUGNEW)
        X(IDRUGNEW) = X(ICOMP)
        X(ICOMP) = VALUE
        IDRUGNEW = ICOMP
        IF(IDRUGNEW .EQ. 1) GO TO 150
        IF(IDRUGNEW .GT. 1) GO TO 110
       ENDIF
  150 END DO
      NDELTA = 0
      DO IDRUG = 1,NDRUG
       IF(IDRUG .EQ. 1 .AND. X(IDRUG) .GT. 0) THEN
        NDELTA = NDELTA + 1
        ORDELT(NDELTA) = X(IDRUG)
       ENDIF
       IF(IDRUG .GE. 2) THEN
        CALL THESAME(X(IDRUG),X(IDRUG-1),ISAME)
        IF(ISAME .EQ. 0) THEN
         NDELTA = NDELTA + 1
         ORDELT(NDELTA) = X(IDRUG)
        ENDIF
       ENDIF
      END DO
      RETURN
      END
	SUBROUTINE STOREOBSER
	IMPLICIT REAL*8(A-H,O-Z)
	PARAMETER(MAXNUMEQ=7)
      DIMENSION TIM(594),SIG(5000),RS(5000,34),YO(594,MAXNUMEQ),
     1 BS(5000,7)
	CHARACTER SEX*1,READLINE*300,ERRFIL*20
      COMMON/ERROR/ERRFIL
	COMMON/OBSER/ TIM,SIG,RS,YO,BS
	COMMON/CNST/ N,ND,NI,NUP,NUIC,NP
	COMMON/CNST2/ NPL,NUMEQT,NDRUG,NADD
	COMMON/SUM2/ M,NPNL
	COMMON/DESCR/AGE,HEIGHT,ISEX,IETHFLG
	DO I=1,7
	 READ(41,*)
	END DO
	READ(41,*) AGE
	READ(41,2) SEX
    2   FORMAT(A1)
	ISEX=1
	IF(SEX .EQ. 'F') ISEX=2
	READ(41,*) HEIGHT
	READ(41,*) IETHFLG
    1   FORMAT(A300)
   10	READ(41,1) READLINE
	IF(READLINE(12:23) .NE. 'NO. OF DRUGS') GO TO 10
	BACKSPACE(41)
    3   FORMAT(T2,I5)
        READ(41,3) NDRUG
	IF(NDRUG .GT. 7) THEN
	 WRITE(*,124)
  124  FORMAT(' YOUR PATIENT DATA FILES CANNOT HAVE MORE THAN 7'/
     1' DRUGS. THE PROGRAM IS NOW STOPPING. '/)
        OPEN(42,FILE=ERRFIL)
         WRITE(42,124)
        CLOSE(42)
       CALL PAUSE
	 STOP
	ENDIF
        READ(41,3) NADD
	NI = 2*NDRUG + NADD
	IF(NI .GT. 34) THEN
  	 WRITE(*,123)
  123    FORMAT(/' YOUR PATIENT DATA FILES HAVE TOO MANY COLUMNS IN '/
     1' THE DOSAGE REGIMEN BLOCK. THE NO. OF ADDITIONAL COVARIATES '/
     2' PLUS TWICE THE NO. OF DRUGS CANNOT EXCEED 34. THE PROGRAM IS'/
     3' NOW STOPPING. '/)
        OPEN(42,FILE=ERRFIL)
         WRITE(42,123)
        CLOSE(42)
	 CALL PAUSE
	 STOP
	ENDIF
        READ(41,3) ND
	IF(ND .GT. 5000) THEN
	 WRITE(*,125)
  125  FORMAT(' YOUR PATIENT DATA FILES CANNOT HAVE MORE THAN 5000'/
     1' DOSE EVENTS. THE PROGRAM IS NOW STOPPING. '/)
        OPEN(42,FILE=ERRFIL)
         WRITE(42,125)
        CLOSE(42)
       CALL PAUSE
	 STOP
	ENDIF
	READ(41,*)
	READ(41,*)
        IF(ND.EQ.0) GO TO 40
	DO I = 1,ND
         READ(41,*) SIG(I),(RS(I,J),J=1,NI)
	END DO
        DO I=1,ND
         DO J=1,NDRUG
          BS(I,J) = RS(I,2*J)
	 END DO
	END DO
   40	READ(41,1) READLINE
	IF(READLINE(12:23) .NE. 'NO. OF TOTAL') GO TO 40
	BACKSPACE(41)
        READ(41,3) NUMEQT
        READ(41,3) M
	IF(M .GT. 594) THEN
	 WRITE(*,*) 'NO. OF OBSERVATIONS MUST BE .LE. 594'
	 WRITE(*,*) 'ONLY THE 1ST 594 OBSERVATION TIMES ARE USED.'
	 M=594
	ENDIF
	IF(NUMEQT .GT. MAXNUMEQ) THEN
  	 WRITE(*,127) NUMEQT,MAXNUMEQ
  127    FORMAT(/' YOUR PATIENT DATA FILE HAS ',I3,' OUTPUT EQ.'/
     1' COLUMNS, WHICH IS MORE THAN ',I3,', THE MAX. ALLOWABLE NO. '/
     2' THE PROGRAM IS NOW STOPPING. '/)
        OPEN(42,FILE=ERRFIL)
         WRITE(42,127) NUMEQT,MAXNUMEQ
        CLOSE(42)
       CALL PAUSE
	 STOP
	ENDIF
      DO I=1,M
       READ(41,*) TIM(I),(YO(I,J),J=1,NUMEQT)
      END DO
      CLOSE(41)
	RETURN
	END
      SUBROUTINE WRITESTEADY(NCOVA,NDRUG,IDOSE,SIG,RS,BS,DOSESTRING,
     1 SUBID,IDEVENT)
      IMPLICIT REAL*8(A-H,O-Z)
      DIMENSION SIG(5000),RS(5000,34),BS(5000,7),XVERIFY(900)
      CHARACTER SUBID*11,DOSESTRING*12,BIGLINE*1000,SMALLLINE*1000,
     1  ERRFIL*20
      COMMON/ERROR/ERRFIL
      DO JDRUG = 1,NDRUG
       RIV = RS(IDOSE,2*JDRUG-1)
       RBOL = RS(IDOSE,2*JDRUG)
       IF(RIV .GT. 0.D0 .AND. RBOL .LE. 0.D0) THEN
        WRITE(*,1) SUBID,IDOSE,JDRUG
    1   FORMAT(/' ERROR IN SUBROUTINE WRITESTEADY.'//
     1' SUBJECT ',A11,' HAS AN ERROR IN ITS DOSAGE REGIMEN ...'/
     1' FOR DOSE NO. ',I5,' DRUG NO. ',I2,' HAS AN IV RATE WHICH MEANS'/
     2' IT IS SUPPOSED TO PARTICIPATE IN THE STEADY STATE DOSE SET,'/
     3' BUT THE ENTRY IN ITS "BOLUS" COLUMN, WHERE THE TOTAL DRUG AMT.'/
     4' FOR EACH IV OF THE STEADY STATE DOSE SET IS SUPPOSED TO BE '/
     5' IS .LE. 0.'//
     6' TO SEE THE PROBLEM, TAKE A LOOK AT THE WORKING COPY FILE THAT'/
     7' WAS SIMULATED. IF YOU DID NOT HAVE WORKING COPY FILES CREATED'/
     8' IN THIS RUN, RERUN THE PROGRAM, SELECT TO HAVE WORKING COPY '/
     9' FILES CREATED, AND THEN TAKE A LOOK AT THE PROBLEMATIC'/
     1' SUBJECT.'//
     2' THE PROGRAM STOPS.'//)
        OPEN(42,FILE=ERRFIL)
         WRITE(42,1) SUBID,IDOSE,JDRUG
        CLOSE(42)
        CALL PAUSE
        STOP
       ENDIF
       IF(RBOL .GT. 0.D0) THEN
        DURATION = 0.D0
        IF(RIV .GT. 0.D0) DURATION = RBOL/RIV
        OPEN(37)
        IF(NCOVA .GT. 0) THEN
         XVERIFY(1) = DURATION
         XVERIFY(2) = RBOL
         XVERIFY(3) = -SIG(IDOSE)
         DO K = 1,NCOVA
          XVERIFY(3+K) = RS(IDOSE,2*NDRUG+K)
         END DO
         CALL VERIFYVAL(3+NCOVA,XVERIFY)
         WRITE(37,16) SUBID,IDEVENT,'0.0',XVERIFY(1),
     1   XVERIFY(2),'-1',XVERIFY(3),JDRUG,DOSESTRING,
     2   (XVERIFY(3+K),K=1,NCOVA)
        ENDIF
   16   FORMAT(A11,',',I1,',',A3,',',G14.7,',',G14.7,',',A2,',',
     1   G14.7,',',I1,A12,26(',',G14.7))
        IF(NCOVA .EQ. 0) THEN
         XVERIFY(1) = DURATION
         XVERIFY(2) = RBOL
         XVERIFY(3) = -SIG(IDOSE)
         CALL VERIFYVAL(3,XVERIFY)
         WRITE(37,17) SUBID,IDEVENT,'0.0',XVERIFY(1),
     1   XVERIFY(2),'-1',XVERIFY(3),JDRUG,DOSESTRING
        ENDIF
   17   FORMAT(A11,',',I1,',',A3,',',G14.7,',',G14.7,',',A2,',',
     1   G14.7,',',I1,A12)
        BACKSPACE(37)
        READ(37,12) BIGLINE
   12   FORMAT(A1000)
        CLOSE(37)
        CALL REDUCE(BIGLINE,SMALLLINE)
        CALL CONDENSE(SMALLLINE)
        IDEVENT = 1
          ENDIF
         END DO
      RETURN
      END
      SUBROUTINE VERIFYVAL(N,X)
      IMPLICIT REAL*8(A-H,O-Z)
      DIMENSION X(200)
      DO I = 1,N
       IF(X(I) .GE. -1.D-99 .AND. X(I) .LE. 1.D-99) X(I) = 0.D0
      END DO
      RETURN
      END
      SUBROUTINE DGBTRF( M, N, KL, KU, AB, LDAB, IPIV, INFO )
*
*  -- LAPACK routine (version 1.1) --
*     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
*     Courant Institute, Argonne National Lab, and Rice University
*     February 29, 1992
*
*     .. Scalar Arguments ..
      INTEGER            INFO, KL, KU, LDAB, M, N
*     ..
*     .. Array Arguments ..
      INTEGER            IPIV( * )
      DOUBLE PRECISION   AB( LDAB, * )
*     ..
*
*  Purpose
*  =======
*
*  DGBTRF computes an LU factorization of a real m-by-n band matrix A
*  using partial pivoting with row interchanges.
*
*  This is the blocked version of the algorithm, calling Level 3 BLAS.
*
*  Arguments
*  =========
*
*  M       (input) INTEGER
*          The number of rows of the matrix A.  M >= 0.
*
*  N       (input) INTEGER
*          The number of columns of the matrix A.  N >= 0.
*
*  KL      (input) INTEGER
*          The number of subdiagonals within the band of A.  KL >= 0.
*
*  KU      (input) INTEGER
*          The number of superdiagonals within the band of A.  KU >= 0.
*
*  AB      (input/output) DOUBLE PRECISION array, dimension (LDAB,N)
*          On entry, the matrix A in band storage, in rows KL+1 to
*          2*KL+KU+1; rows 1 to KL of the array need not be set.
*          The j-th column of A is stored in the j-th column of the
*          array AB as follows:
*          AB(kl+ku+1+i-j,j) = A(i,j) for max(1,j-ku)<=i<=min(m,j+kl)
*
*          On exit, details of the factorization: U is stored as an
*          upper triangular band matrix with KL+KU superdiagonals in
*          rows 1 to KL+KU+1, and the multipliers used during the
*          factorization are stored in rows KL+KU+2 to 2*KL+KU+1.
*          See below for further details.
*
*  LDAB    (input) INTEGER
*          The leading dimension of the array AB.  LDAB >= 2*KL+KU+1.
*
*  IPIV    (output) INTEGER array, dimension (min(M,N))
*          The pivot indices; for 1 <= i <= min(M,N), row i of the
*          matrix was interchanged with row IPIV(i).
*
*  INFO    (output) INTEGER
*          = 0: successful exit
*          < 0: if INFO = -i, the i-th argument had an illegal value
*          > 0: if INFO = +i, U(i,i) is exactly zero. The factorization
*               has been completed, but the factor U is exactly
*               singular, and division by zero will occur if it is used
*               to solve a system of equations.
*
*  Further Details
*  ===============
*
*  The band storage scheme is illustrated by the following example, when
*  M = N = 6, KL = 2, KU = 1:
*
*  On entry:                       On exit:
*
*      *    *    *    +    +    +       *    *    *   u14  u25  u36
*      *    *    +    +    +    +       *    *   u13  u24  u35  u46
*      *   a12  a23  a34  a45  a56      *   u12  u23  u34  u45  u56
*     a11  a22  a33  a44  a55  a66     u11  u22  u33  u44  u55  u66
*     a21  a32  a43  a54  a65   *      m21  m32  m43  m54  m65   *
*     a31  a42  a53  a64   *    *      m31  m42  m53  m64   *    *
*
*  Array elements marked * are not used by the routine; elements marked
*  + need not be set on entry, but are required by the routine to store
*  elements of U because of fill-in resulting from the row interchanges.
*
*  =====================================================================
*
*     .. Parameters ..
      DOUBLE PRECISION   ONE, ZERO
      PARAMETER          ( ONE = 1.0D+0, ZERO = 0.0D+0 )
      INTEGER            NBMAX, LDWORK
      PARAMETER          ( NBMAX = 64, LDWORK = NBMAX+1 )
*     ..
*     .. Local Scalars ..
      INTEGER            I, I2, I3, II, IP, J, J2, J3, JB, JJ, JM, JP,
     $                   JU, K2, KM, KV, NB, NW
      DOUBLE PRECISION   TEMP
*     ..
*     .. Local Arrays ..
      DOUBLE PRECISION   WORK13( LDWORK, NBMAX ),
     $                   WORK31( LDWORK, NBMAX )
*     ..
*     .. External Functions ..
      INTEGER            IDAMAX, ILAENV
      EXTERNAL           IDAMAX, ILAENV
*     ..
*     .. External Subroutines ..
      EXTERNAL           DCOPY, DGBTF2, DGEMM, DGER, DLASWP, DSCAL,
     $                   DSWAP, DTRSM, XERBLA
*     ..
*     .. Intrinsic Functions ..
      INTRINSIC          MAX, MIN
*     ..
*     .. Executable Statements ..
*
*     KV is the number of superdiagonals in the factor U, allowing for
*     fill-in
*
      KV = KU + KL
*
*     Test the input parameters.
*
      INFO = 0
      IF( M.LT.0 ) THEN
         INFO = -1
      ELSE IF( N.LT.0 ) THEN
         INFO = -2
      ELSE IF( KL.LT.0 ) THEN
         INFO = -3
      ELSE IF( KU.LT.0 ) THEN
         INFO = -4
      ELSE IF( LDAB.LT.KL+KV+1 ) THEN
         INFO = -6
      END IF
      IF( INFO.NE.0 ) THEN
         CALL XERBLA( 'DGBTRF', -INFO )
         RETURN
      END IF
*
*     Quick return if possible
*
      IF( M.EQ.0 .OR. N.EQ.0 )
     $   RETURN
*
*     Determine the block size for this environment
*
      NB = ILAENV( 1, 'DGBTRF', ' ', M, N, KL, KU )
*
*     The block size must not exceed the limit set by the size of the
*     local arrays WORK13 and WORK31.
*
      NB = MIN( NB, NBMAX )
*
      IF( NB.LE.1 .OR. NB.GT.KL ) THEN
*
*        Use unblocked code
*
         CALL DGBTF2( M, N, KL, KU, AB, LDAB, IPIV, INFO )
      ELSE
*
*        Use blocked code
*
*        Zero the superdiagonal elements of the work array WORK13
*
         DO 20 J = 1, NB
            DO 10 I = 1, J - 1
               WORK13( I, J ) = ZERO
   10       CONTINUE
   20    CONTINUE
*
*        Zero the subdiagonal elements of the work array WORK31
*
         DO 40 J = 1, NB
            DO 30 I = J + 1, NB
               WORK31( I, J ) = ZERO
   30       CONTINUE
   40    CONTINUE
*
*        Gaussian elimination with partial pivoting
*
*        Set fill-in elements in columns KU+2 to KV to zero
*
         DO 60 J = KU + 2, MIN( KV, N )
            DO 50 I = KV - J + 2, KL
               AB( I, J ) = ZERO
   50       CONTINUE
   60    CONTINUE
*
*        JU is the index of the last column affected by the current
*        stage of the factorization
*
         JU = 1
*
         DO 180 J = 1, MIN( M, N ), NB
            JB = MIN( NB, MIN( M, N )-J+1 )
*
*           The active part of the matrix is partitioned
*
*              A11   A12   A13
*              A21   A22   A23
*              A31   A32   A33
*
*           Here A11, A21 and A31 denote the current block of JB columns
*           which is about to be factorized. The number of rows in the
*           partitioning are JB, I2, I3 respectively, and the numbers
*           of columns are JB, J2, J3. The superdiagonal elements of A13
*           and the subdiagonal elements of A31 lie outside the band.
*
            I2 = MIN( KL-JB, M-J-JB+1 )
            I3 = MIN( JB, M-J-KL+1 )
*
*           J2 and J3 are computed after JU has been updated.
*
*           Factorize the current block of JB columns
*
            DO 80 JJ = J, J + JB - 1
*
*              Set fill-in elements in column JJ+KV to zero
*
               IF( JJ+KV.LE.N ) THEN
                  DO 70 I = 1, KL
                     AB( I, JJ+KV ) = ZERO
   70             CONTINUE
               END IF
*
*              Find pivot and test for singularity. KM is the number of
*              subdiagonal elements in the current column.
*
               KM = MIN( KL, M-JJ )
               JP = IDAMAX( KM+1, AB( KV+1, JJ ), 1 )
               IPIV( JJ ) = JP + JJ - J
               IF( AB( KV+JP, JJ ).NE.ZERO ) THEN
                  JU = MAX( JU, MIN( JJ+KU+JP-1, N ) )
                  IF( JP.NE.1 ) THEN
*
*                    Apply interchange to columns J to J+JB-1
*
                     IF( JP+JJ-1.LT.J+KL ) THEN
*
                        CALL DSWAP( JB, AB( KV+1+JJ-J, J ), LDAB-1,
     $                              AB( KV+JP+JJ-J, J ), LDAB-1 )
                     ELSE
*
*                       The interchange affects columns J to JJ-1 of A31
*                       which are stored in the work array WORK31
*
                        CALL DSWAP( JJ-J, AB( KV+1+JJ-J, J ), LDAB-1,
     $                              WORK31( JP+JJ-J-KL, 1 ), LDWORK )
                        CALL DSWAP( J+JB-JJ, AB( KV+1, JJ ), LDAB-1,
     $                              AB( KV+JP, JJ ), LDAB-1 )
                     END IF
                  END IF
*
*                 Compute multipliers
*
                  CALL DSCAL( KM, ONE / AB( KV+1, JJ ), AB( KV+2, JJ ),
     $                        1 )
*
*                 Update trailing submatrix within the band and within
*                 the current block. JM is the index of the last column
*                 which needs to be updated.
*
                  JM = MIN( JU, J+JB-1 )
                  IF( JM.GT.JJ )
     $               CALL DGER( KM, JM-JJ, -ONE, AB( KV+2, JJ ), 1,
     $                          AB( KV, JJ+1 ), LDAB-1,
     $                          AB( KV+1, JJ+1 ), LDAB-1 )
               ELSE
*
*                 If pivot is zero, set INFO to the index of the pivot
*                 unless a zero pivot has already been found.
*
                  IF( INFO.EQ.0 )
     $               INFO = JJ
               END IF
*
*              Copy current column of A31 into the work array WORK31
*
               NW = MIN( JJ-J+1, I3 )
               IF( NW.GT.0 )
     $            CALL DCOPY( NW, AB( KV+KL+1-JJ+J, JJ ), 1,
     $                        WORK31( 1, JJ-J+1 ), 1 )
   80       CONTINUE
            IF( J+JB.LE.N ) THEN
*
*              Apply the row interchanges to the other blocks.
*
               J2 = MIN( JU-J+1, KV ) - JB
               J3 = MAX( 0, JU-J-KV+1 )
*
*              Use DLASWP to apply the row interchanges to A12, A22, and
*              A32.
*
               CALL DLASWP( J2, AB( KV+1-JB, J+JB ), LDAB-1, 1, JB,
     $                      IPIV( J ), 1 )
*
*              Adjust the pivot indices.
*
               DO 90 I = J, J + JB - 1
                  IPIV( I ) = IPIV( I ) + J - 1
   90          CONTINUE
*
*              Apply the row interchanges to A13, A23, and A33
*              columnwise.
*
               K2 = J - 1 + JB + J2
               DO 110 I = 1, J3
                  JJ = K2 + I
                  DO 100 II = J + I - 1, J + JB - 1
                     IP = IPIV( II )
                     IF( IP.NE.II ) THEN
                        TEMP = AB( KV+1+II-JJ, JJ )
                        AB( KV+1+II-JJ, JJ ) = AB( KV+1+IP-JJ, JJ )
                        AB( KV+1+IP-JJ, JJ ) = TEMP
                     END IF
  100             CONTINUE
  110          CONTINUE
*
*              Update the relevant part of the trailing submatrix
*
               IF( J2.GT.0 ) THEN
*
*                 Update A12
*
                  CALL DTRSM( 'Left', 'Lower', 'No transpose', 'Unit',
     $                        JB, J2, ONE, AB( KV+1, J ), LDAB-1,
     $                        AB( KV+1-JB, J+JB ), LDAB-1 )
*
                  IF( I2.GT.0 ) THEN
*
*                    Update A22
*
                     CALL DGEMM( 'No transpose', 'No transpose', I2, J2,
     $                           JB, -ONE, AB( KV+1+JB, J ), LDAB-1,
     $                           AB( KV+1-JB, J+JB ), LDAB-1, ONE,
     $                           AB( KV+1, J+JB ), LDAB-1 )
                  END IF
*
                  IF( I3.GT.0 ) THEN
*
*                    Update A32
*
                     CALL DGEMM( 'No transpose', 'No transpose', I3, J2,
     $                           JB, -ONE, WORK31, LDWORK,
     $                           AB( KV+1-JB, J+JB ), LDAB-1, ONE,
     $                           AB( KV+KL+1-JB, J+JB ), LDAB-1 )
                  END IF
               END IF
*
               IF( J3.GT.0 ) THEN
*
*                 Copy the lower triangle of A13 into the work array
*                 WORK13
*
                  DO 130 JJ = 1, J3
                     DO 120 II = JJ, JB
                        WORK13( II, JJ ) = AB( II-JJ+1, JJ+J+KV-1 )
  120                CONTINUE
  130             CONTINUE
*
*                 Update A13 in the work array
*
                  CALL DTRSM( 'Left', 'Lower', 'No transpose', 'Unit',
     $                        JB, J3, ONE, AB( KV+1, J ), LDAB-1,
     $                        WORK13, LDWORK )
*
                  IF( I2.GT.0 ) THEN
*
*                    Update A23
*
                     CALL DGEMM( 'No transpose', 'No transpose', I2, J3,
     $                           JB, -ONE, AB( KV+1+JB, J ), LDAB-1,
     $                           WORK13, LDWORK, ONE, AB( 1+JB, J+KV ),
     $                           LDAB-1 )
                  END IF
*
                  IF( I3.GT.0 ) THEN
*
*                    Update A33
*
                     CALL DGEMM( 'No transpose', 'No transpose', I3, J3,
     $                           JB, -ONE, WORK31, LDWORK, WORK13,
     $                           LDWORK, ONE, AB( 1+KL, J+KV ), LDAB-1 )
                  END IF
*
*                 Copy the lower triangle of A13 back into place
*
                  DO 150 JJ = 1, J3
                     DO 140 II = JJ, JB
                        AB( II-JJ+1, JJ+J+KV-1 ) = WORK13( II, JJ )
  140                CONTINUE
  150             CONTINUE
               END IF
            ELSE
*
*              Adjust the pivot indices.
*
               DO 160 I = J, J + JB - 1
                  IPIV( I ) = IPIV( I ) + J - 1
  160          CONTINUE
            END IF
*
*           Partially undo the interchanges in the current block to
*           restore the upper triangular form of A31 and copy the upper
*           triangle of A31 back into place
*
            DO 170 JJ = J + JB - 1, J, -1
               JP = IPIV( JJ ) - JJ + 1
               IF( JP.NE.1 ) THEN
*
*                 Apply interchange to columns J to JJ-1
*
                  IF( JP+JJ-1.LT.J+KL ) THEN
*
*                    The interchange does not affect A31
*
                     CALL DSWAP( JJ-J, AB( KV+1+JJ-J, J ), LDAB-1,
     $                           AB( KV+JP+JJ-J, J ), LDAB-1 )
                  ELSE
*
*                    The interchange does affect A31
*
                     CALL DSWAP( JJ-J, AB( KV+1+JJ-J, J ), LDAB-1,
     $                           WORK31( JP+JJ-J-KL, 1 ), LDWORK )
                  END IF
               END IF
*
*              Copy the current column of A31 back into place
*
               NW = MIN( I3, JJ-J+1 )
               IF( NW.GT.0 )
     $            CALL DCOPY( NW, WORK31( 1, JJ-J+1 ), 1,
     $                        AB( KV+KL+1-JJ+J, JJ ), 1 )
  170       CONTINUE
  180    CONTINUE
      END IF
*
      RETURN
*
*     End of DGBTRF
*
      END
      SUBROUTINE DGETRF( M, N, A, LDA, IPIV, INFO )
*
*  -- LAPACK routine (version 1.1) --
*     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
*     Courant Institute, Argonne National Lab, and Rice University
*     March 31, 1993
*
*     .. Scalar Arguments ..
      INTEGER            INFO, LDA, M, N
*     ..
*     .. Array Arguments ..
      INTEGER            IPIV( * )
      DOUBLE PRECISION   A( LDA, * )
*     ..
*
*  Purpose
*  =======
*
*  DGETRF computes an LU factorization of a general M-by-N matrix A
*  using partial pivoting with row interchanges.
*
*  The factorization has the form
*     A = P * L * U
*  where P is a permutation matrix, L is lower triangular with unit
*  diagonal elements (lower trapezoidal if m > n), and U is upper
*  triangular (upper trapezoidal if m < n).
*
*  This is the right-looking Level 3 BLAS version of the algorithm.
*
*  Arguments
*  =========
*
*  M       (input) INTEGER
*          The number of rows of the matrix A.  M >= 0.
*
*  N       (input) INTEGER
*          The number of columns of the matrix A.  N >= 0.
*
*  A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
*          On entry, the M-by-N matrix to be factored.
*          On exit, the factors L and U from the factorization
*          A = P*L*U; the unit diagonal elements of L are not stored.
*
*  LDA     (input) INTEGER
*          The leading dimension of the array A.  LDA >= max(1,M).
*
*  IPIV    (output) INTEGER array, dimension (min(M,N))
*          The pivot indices; for 1 <= i <= min(M,N), row i of the
*          matrix was interchanged with row IPIV(i).
*
*  INFO    (output) INTEGER
*          = 0:  successful exit
*          < 0:  if INFO = -i, the i-th argument had an illegal value
*          > 0:  if INFO = i, U(i,i) is exactly zero. The factorization
*                has been completed, but the factor U is exactly
*                singular, and division by zero will occur if it is used
*                to solve a system of equations.
*
*  =====================================================================
*
*     .. Parameters ..
      DOUBLE PRECISION   ONE
      PARAMETER          ( ONE = 1.0D+0 )
*     ..
*     .. Local Scalars ..
      INTEGER            I, IINFO, J, JB, NB
*     ..
*     .. External Subroutines ..
      EXTERNAL           DGEMM, DGETF2, DLASWP, DTRSM, XERBLA
*     ..
*     .. External Functions ..
      INTEGER            ILAENV
      EXTERNAL           ILAENV
*     ..
*     .. Intrinsic Functions ..
      INTRINSIC          MAX, MIN
*     ..
*     .. Executable Statements ..
*
*     Test the input parameters.
*
      INFO = 0
      IF( M.LT.0 ) THEN
         INFO = -1
      ELSE IF( N.LT.0 ) THEN
         INFO = -2
      ELSE IF( LDA.LT.MAX( 1, M ) ) THEN
         INFO = -4
      END IF
      IF( INFO.NE.0 ) THEN
         CALL XERBLA( 'DGETRF', -INFO )
         RETURN
      END IF
*
*     Quick return if possible
*
      IF( M.EQ.0 .OR. N.EQ.0 )
     $   RETURN
*
*     Determine the block size for this environment.
*
      NB = ILAENV( 1, 'DGETRF', ' ', M, N, -1, -1 )
      IF( NB.LE.1 .OR. NB.GE.MIN( M, N ) ) THEN
*
*        Use unblocked code.
*
         CALL DGETF2( M, N, A, LDA, IPIV, INFO )
      ELSE
*
*        Use blocked code.
*
         DO 20 J = 1, MIN( M, N ), NB
            JB = MIN( MIN( M, N )-J+1, NB )
*
*           Factor diagonal and subdiagonal blocks and test for exact
*           singularity.
*
            CALL DGETF2( M-J+1, JB, A( J, J ), LDA, IPIV( J ), IINFO )
*
*           Adjust INFO and the pivot indices.
*
            IF( INFO.EQ.0 .AND. IINFO.GT.0 )
     $         INFO = IINFO + J - 1
            DO 10 I = J, MIN( M, J+JB-1 )
               IPIV( I ) = J - 1 + IPIV( I )
   10       CONTINUE
*
*           Apply interchanges to columns 1:J-1.
*
            CALL DLASWP( J-1, A, LDA, J, J+JB-1, IPIV, 1 )
*
            IF( J+JB.LE.N ) THEN
*
*              Apply interchanges to columns J+JB:N.
*
               CALL DLASWP( N-J-JB+1, A( 1, J+JB ), LDA, J, J+JB-1,
     $                      IPIV, 1 )
*
*              Compute block row of U.
*
               CALL DTRSM( 'Left', 'Lower', 'No transpose', 'Unit', JB,
     $                     N-J-JB+1, ONE, A( J, J ), LDA, A( J, J+JB ),
     $                     LDA )
               IF( J+JB.LE.M ) THEN
*
*                 Update trailing submatrix.
*
                  CALL DGEMM( 'No transpose', 'No transpose', M-J-JB+1,
     $                        N-J-JB+1, JB, -ONE, A( J+JB, J ), LDA,
     $                        A( J, J+JB ), LDA, ONE, A( J+JB, J+JB ),
     $                        LDA )
               END IF
            END IF
   20    CONTINUE
      END IF
      RETURN
*
*     End of DGETRF
*
      END
      SUBROUTINE DGBTRS( TRANS, N, KL, KU, NRHS, AB, LDAB, IPIV, B, LDB,
     $                   INFO )
*
*  -- LAPACK routine (version 1.1) --
*     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
*     Courant Institute, Argonne National Lab, and Rice University
*     March 31, 1993
*
*     .. Scalar Arguments ..
      CHARACTER          TRANS
      INTEGER            INFO, KL, KU, LDAB, LDB, N, NRHS
*     ..
*     .. Array Arguments ..
      INTEGER            IPIV( * )
      DOUBLE PRECISION   AB( LDAB, * ), B( LDB, * )
*     ..
*
*  Purpose
*  =======
*
*  DGBTRS solves a system of linear equations
*     A * X = B  or  A' * X = B
*  with a general band matrix A using the LU factorization computed
*  by DGBTRF.
*
*  Arguments
*  =========
*
*  TRANS   (input) CHARACTER*1
*          Specifies the form of the system of equations.
*          = 'N':  A * X = B  (No transpose)
*          = 'T':  A'* X = B  (Transpose)
*          = 'C':  A'* X = B  (Conjugate transpose = Transpose)
*
*  N       (input) INTEGER
*          The order of the matrix A.  N >= 0.
*
*  KL      (input) INTEGER
*          The number of subdiagonals within the band of A.  KL >= 0.
*
*  KU      (input) INTEGER
*          The number of superdiagonals within the band of A.  KU >= 0.
*
*  NRHS    (input) INTEGER
*          The number of right hand sides, i.e., the number of columns
*          of the matrix B.  NRHS >= 0.
*
*  AB      (input) DOUBLE PRECISION array, dimension (LDAB,N)
*          Details of the LU factorization of the band matrix A, as
*          computed by DGBTRF.  U is stored as an upper triangular band
*          matrix with KL+KU superdiagonals in rows 1 to KL+KU+1, and
*          the multipliers used during the factorization are stored in
*          rows KL+KU+2 to 2*KL+KU+1.
*
*  LDAB    (input) INTEGER
*          The leading dimension of the array AB.  LDAB >= 2*KL+KU+1.
*
*  IPIV    (input) INTEGER array, dimension (N)
*          The pivot indices; for 1 <= i <= N, row i of the matrix was
*          interchanged with row IPIV(i).
*
*  B       (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS)
*          On entry, the right hand side matrix B.
*          On exit, the solution matrix X.
*
*  LDB     (input) INTEGER
*          The leading dimension of the array B.  LDB >= max(1,N).
*
*  INFO    (output) INTEGER
*          = 0:  successful exit
*          < 0: if INFO = -i, the i-th argument had an illegal value
*
*  =====================================================================
*
*     .. Parameters ..
      DOUBLE PRECISION   ONE
      PARAMETER          ( ONE = 1.0D+0 )
*     ..
*     .. Local Scalars ..
      LOGICAL            LNOTI, NOTRAN
      INTEGER            I, J, KD, L, LM
*     ..
*     .. External Functions ..
      LOGICAL            LSAME
      EXTERNAL           LSAME
*     ..
*     .. External Subroutines ..
      EXTERNAL           DGEMV, DGER, DSWAP, DTBSV, XERBLA
*     ..
*     .. Intrinsic Functions ..
      INTRINSIC          MAX, MIN
*     ..
*     .. Executable Statements ..
*
*     Test the input parameters.
*
      INFO = 0
      NOTRAN = LSAME( TRANS, 'N' )
      IF( .NOT.NOTRAN .AND. .NOT.LSAME( TRANS, 'T' ) .AND. .NOT.
     $    LSAME( TRANS, 'C' ) ) THEN
         INFO = -1
      ELSE IF( N.LT.0 ) THEN
         INFO = -2
      ELSE IF( KL.LT.0 ) THEN
         INFO = -3
      ELSE IF( KU.LT.0 ) THEN
         INFO = -4
      ELSE IF( NRHS.LT.0 ) THEN
         INFO = -5
      ELSE IF( LDAB.LT.( 2*KL+KU+1 ) ) THEN
         INFO = -7
      ELSE IF( LDB.LT.MAX( 1, N ) ) THEN
         INFO = -10
      END IF
      IF( INFO.NE.0 ) THEN
         CALL XERBLA( 'DGBTRS', -INFO )
         RETURN
      END IF
*
*     Quick return if possible
*
      IF( N.EQ.0 .OR. NRHS.EQ.0 )
     $   RETURN
*
      KD = KU + KL + 1
      LNOTI = KL.GT.0
*
      IF( NOTRAN ) THEN
*
*        Solve  A*X = B.
*
*        Solve L*X = B, overwriting B with X.
*
*        L is represented as a product of permutations and unit lower
*        triangular matrices L = P(1) * L(1) * ... * P(n-1) * L(n-1),
*        where each transformation L(i) is a rank-one modification of
*        the identity matrix.
*
         IF( LNOTI ) THEN
            DO 10 J = 1, N - 1
               LM = MIN( KL, N-J )
               L = IPIV( J )
               IF( L.NE.J )
     $            CALL DSWAP( NRHS, B( L, 1 ), LDB, B( J, 1 ), LDB )
               CALL DGER( LM, NRHS, -ONE, AB( KD+1, J ), 1, B( J, 1 ),
     $                    LDB, B( J+1, 1 ), LDB )
   10       CONTINUE
         END IF
*
         DO 20 I = 1, NRHS
*
*           Solve U*X = B, overwriting B with X.
*
            CALL DTBSV( 'Upper', 'No transpose', 'Non-unit', N, KL+KU,
     $                  AB, LDAB, B( 1, I ), 1 )
   20    CONTINUE
*
      ELSE
*
*        Solve A'*X = B.
*
         DO 30 I = 1, NRHS
*
*           Solve U'*X = B, overwriting B with X.
*
            CALL DTBSV( 'Upper', 'Transpose', 'Non-unit', N, KL+KU, AB,
     $                  LDAB, B( 1, I ), 1 )
   30    CONTINUE
*
*        Solve L'*X = B, overwriting B with X.
*
         IF( LNOTI ) THEN
            DO 40 J = N - 1, 1, -1
               LM = MIN( KL, N-J )
               CALL DGEMV( 'Transpose', LM, NRHS, -ONE, B( J+1, 1 ),
     $                     LDB, AB( KD+1, J ), 1, ONE, B( J, 1 ), LDB )
               L = IPIV( J )
               IF( L.NE.J )
     $            CALL DSWAP( NRHS, B( L, 1 ), LDB, B( J, 1 ), LDB )
   40       CONTINUE
         END IF
      END IF
      RETURN
*
*     End of DGBTRS
*
      END      
      SUBROUTINE DGETF2( M, N, A, LDA, IPIV, INFO )
*
*  -- LAPACK routine (version 1.1) --
*     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
*     Courant Institute, Argonne National Lab, and Rice University
*     June 30, 1992
*
*     .. Scalar Arguments ..
      INTEGER            INFO, LDA, M, N
*     ..
*     .. Array Arguments ..
      INTEGER            IPIV( * )
      DOUBLE PRECISION   A( LDA, * )
*     ..
*
*  Purpose
*  =======
*
*  DGETF2 computes an LU factorization of a general m-by-n matrix A
*  using partial pivoting with row interchanges.
*
*  The factorization has the form
*     A = P * L * U
*  where P is a permutation matrix, L is lower triangular with unit
*  diagonal elements (lower trapezoidal if m > n), and U is upper
*  triangular (upper trapezoidal if m < n).
*
*  This is the right-looking Level 2 BLAS version of the algorithm.
*
*  Arguments
*  =========
*
*  M       (input) INTEGER
*          The number of rows of the matrix A.  M >= 0.
*
*  N       (input) INTEGER
*          The number of columns of the matrix A.  N >= 0.
*
*  A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
*          On entry, the m by n matrix to be factored.
*          On exit, the factors L and U from the factorization
*          A = P*L*U; the unit diagonal elements of L are not stored.
*
*  LDA     (input) INTEGER
*          The leading dimension of the array A.  LDA >= max(1,M).
*
*  IPIV    (output) INTEGER array, dimension (min(M,N))
*          The pivot indices; for 1 <= i <= min(M,N), row i of the
*          matrix was interchanged with row IPIV(i).
*
*  INFO    (output) INTEGER
*          = 0: successful exit
*          < 0: if INFO = -k, the k-th argument had an illegal value
*          > 0: if INFO = k, U(k,k) is exactly zero. The factorization
*               has been completed, but the factor U is exactly
*               singular, and division by zero will occur if it is used
*               to solve a system of equations.
*
*  =====================================================================
*
*     .. Parameters ..
      DOUBLE PRECISION   ONE, ZERO
      PARAMETER          ( ONE = 1.0D+0, ZERO = 0.0D+0 )
*     ..
*     .. Local Scalars ..
      INTEGER            J, JP
*     ..
*     .. External Functions ..
      INTEGER            IDAMAX
      EXTERNAL           IDAMAX
*     ..
*     .. External Subroutines ..
      EXTERNAL           DGER, DSCAL, DSWAP, XERBLA
*     ..
*     .. Intrinsic Functions ..
      INTRINSIC          MAX, MIN
*     ..
*     .. Executable Statements ..
*
*     Test the input parameters.
*
      INFO = 0
      IF( M.LT.0 ) THEN
         INFO = -1
      ELSE IF( N.LT.0 ) THEN
         INFO = -2
      ELSE IF( LDA.LT.MAX( 1, M ) ) THEN
         INFO = -4
      END IF
      IF( INFO.NE.0 ) THEN
         CALL XERBLA( 'DGETF2', -INFO )
         RETURN
      END IF
*
*     Quick return if possible
*
      IF( M.EQ.0 .OR. N.EQ.0 )
     $   RETURN
*
      DO 10 J = 1, MIN( M, N )
*
*        Find pivot and test for singularity.
*
         JP = J - 1 + IDAMAX( M-J+1, A( J, J ), 1 )
         IPIV( J ) = JP
         IF( A( JP, J ).NE.ZERO ) THEN
*
*           Apply the interchange to columns 1:N.
*
            IF( JP.NE.J )
     $         CALL DSWAP( N, A( J, 1 ), LDA, A( JP, 1 ), LDA )
*
*           Compute elements J+1:M of J-th column.
*
            IF( J.LT.M )
     $         CALL DSCAL( M-J, ONE / A( J, J ), A( J+1, J ), 1 )
*
         ELSE IF( INFO.EQ.0 ) THEN
*
            INFO = J
         END IF
*
         IF( J.LT.MIN( M, N ) ) THEN
*
*           Update trailing submatrix.
*
            CALL DGER( M-J, N-J, -ONE, A( J+1, J ), 1, A( J, J+1 ), LDA,
     $                 A( J+1, J+1 ), LDA )
         END IF
   10 CONTINUE
      RETURN
*
*     End of DGETF2
*
      END
      SUBROUTINE DGBTF2( M, N, KL, KU, AB, LDAB, IPIV, INFO )
*
*  -- LAPACK routine (version 1.1) --
*     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
*     Courant Institute, Argonne National Lab, and Rice University
*     February 29, 1992
*
*     .. Scalar Arguments ..
      INTEGER            INFO, KL, KU, LDAB, M, N
*     ..
*     .. Array Arguments ..
      INTEGER            IPIV( * )
      DOUBLE PRECISION   AB( LDAB, * )
*     ..
*
*  Purpose
*  =======
*
*  DGBTF2 computes an LU factorization of a real m-by-n band matrix A
*  using partial pivoting with row interchanges.
*
*  This is the unblocked version of the algorithm, calling Level 2 BLAS.
*
*  Arguments
*  =========
*
*  M       (input) INTEGER
*          The number of rows of the matrix A.  M >= 0.
*
*  N       (input) INTEGER
*          The number of columns of the matrix A.  N >= 0.
*
*  KL      (input) INTEGER
*          The number of subdiagonals within the band of A.  KL >= 0.
*
*  KU      (input) INTEGER
*          The number of superdiagonals within the band of A.  KU >= 0.
*
*  AB      (input/output) DOUBLE PRECISION array, dimension (LDAB,N)
*          On entry, the matrix A in band storage, in rows KL+1 to
*          2*KL+KU+1; rows 1 to KL of the array need not be set.
*          The j-th column of A is stored in the j-th column of the
*          array AB as follows:
*          AB(kl+ku+1+i-j,j) = A(i,j) for max(1,j-ku)<=i<=min(m,j+kl)
*
*          On exit, details of the factorization: U is stored as an
*          upper triangular band matrix with KL+KU superdiagonals in
*          rows 1 to KL+KU+1, and the multipliers used during the
*          factorization are stored in rows KL+KU+2 to 2*KL+KU+1.
*          See below for further details.
*
*  LDAB    (input) INTEGER
*          The leading dimension of the array AB.  LDAB >= 2*KL+KU+1.
*
*  IPIV    (output) INTEGER array, dimension (min(M,N))
*          The pivot indices; for 1 <= i <= min(M,N), row i of the
*          matrix was interchanged with row IPIV(i).
*
*  INFO    (output) INTEGER
*          = 0: successful exit
*          < 0: if INFO = -i, the i-th argument had an illegal value
*          > 0: if INFO = +i, U(i,i) is exactly zero. The factorization
*               has been completed, but the factor U is exactly
*               singular, and division by zero will occur if it is used
*               to solve a system of equations.
*
*  Further Details
*  ===============
*
*  The band storage scheme is illustrated by the following example, when
*  M = N = 6, KL = 2, KU = 1:
*
*  On entry:                       On exit:
*
*      *    *    *    +    +    +       *    *    *   u14  u25  u36
*      *    *    +    +    +    +       *    *   u13  u24  u35  u46
*      *   a12  a23  a34  a45  a56      *   u12  u23  u34  u45  u56
*     a11  a22  a33  a44  a55  a66     u11  u22  u33  u44  u55  u66
*     a21  a32  a43  a54  a65   *      m21  m32  m43  m54  m65   *
*     a31  a42  a53  a64   *    *      m31  m42  m53  m64   *    *
*
*  Array elements marked * are not used by the routine; elements marked
*  + need not be set on entry, but are required by the routine to store
*  elements of U, because of fill-in resulting from the row
*  interchanges.
*
*  =====================================================================
*
*     .. Parameters ..
      DOUBLE PRECISION   ONE, ZERO
      PARAMETER          ( ONE = 1.0D+0, ZERO = 0.0D+0 )
*     ..
*     .. Local Scalars ..
      INTEGER            I, J, JP, JU, KM, KV
*     ..
*     .. External Functions ..
      INTEGER            IDAMAX
      EXTERNAL           IDAMAX
*     ..
*     .. External Subroutines ..
      EXTERNAL           DGER, DSCAL, DSWAP, XERBLA
*     ..
*     .. Intrinsic Functions ..
      INTRINSIC          MAX, MIN
*     ..
*     .. Executable Statements ..
*
*     KV is the number of superdiagonals in the factor U, allowing for
*     fill-in.
*
      KV = KU + KL
*
*     Test the input parameters.
*
      INFO = 0
      IF( M.LT.0 ) THEN
         INFO = -1
      ELSE IF( N.LT.0 ) THEN
         INFO = -2
      ELSE IF( KL.LT.0 ) THEN
         INFO = -3
      ELSE IF( KU.LT.0 ) THEN
         INFO = -4
      ELSE IF( LDAB.LT.KL+KV+1 ) THEN
         INFO = -6
      END IF
      IF( INFO.NE.0 ) THEN
         CALL XERBLA( 'DGBTF2', -INFO )
         RETURN
      END IF
*
*     Quick return if possible
*
      IF( M.EQ.0 .OR. N.EQ.0 )
     $   RETURN
*
*     Gaussian elimination with partial pivoting
*
*     Set fill-in elements in columns KU+2 to KV to zero.
*
      DO 20 J = KU + 2, MIN( KV, N )
         DO 10 I = KV - J + 2, KL
            AB( I, J ) = ZERO
   10    CONTINUE
   20 CONTINUE
*
*     JU is the index of the last column affected by the current stage
*     of the factorization.
*
      JU = 1
*
      DO 40 J = 1, MIN( M, N )
*
*        Set fill-in elements in column J+KV to zero.
*
         IF( J+KV.LE.N ) THEN
            DO 30 I = 1, KL
               AB( I, J+KV ) = ZERO
   30       CONTINUE
         END IF
*
*        Find pivot and test for singularity. KM is the number of
*        subdiagonal elements in the current column.
*
         KM = MIN( KL, M-J )
         JP = IDAMAX( KM+1, AB( KV+1, J ), 1 )
         IPIV( J ) = JP + J - 1
         IF( AB( KV+JP, J ).NE.ZERO ) THEN
            JU = MAX( JU, MIN( J+KU+JP-1, N ) )
*
*           Apply interchange to columns J to JU.
*
            IF( JP.NE.1 )
     $         CALL DSWAP( JU-J+1, AB( KV+JP, J ), LDAB-1,
     $                     AB( KV+1, J ), LDAB-1 )
*
            IF( KM.GT.0 ) THEN
*
*              Compute multipliers.
*
               CALL DSCAL( KM, ONE / AB( KV+1, J ), AB( KV+2, J ), 1 )
*
*              Update trailing submatrix within the band.
*
               IF( JU.GT.J )
     $            CALL DGER( KM, JU-J, -ONE, AB( KV+2, J ), 1,
     $                       AB( KV, J+1 ), LDAB-1, AB( KV+1, J+1 ),
     $                       LDAB-1 )
            END IF
         ELSE
*
*           If pivot is zero, set INFO to the index of the pivot
*           unless a zero pivot has already been found.
*
            IF( INFO.EQ.0 )
     $         INFO = J
         END IF
   40 CONTINUE
      RETURN
*
*     End of DGBTF2
*
      END
      SUBROUTINE DGETRS( TRANS, N, NRHS, A, LDA, IPIV, B, LDB, INFO )
*
*  -- LAPACK routine (version 1.1) --
*     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
*     Courant Institute, Argonne National Lab, and Rice University
*     March 31, 1993
*
*     .. Scalar Arguments ..
      CHARACTER          TRANS
      INTEGER            INFO, LDA, LDB, N, NRHS
*     ..
*     .. Array Arguments ..
      INTEGER            IPIV( * )
      DOUBLE PRECISION   A( LDA, * ), B( LDB, * )
*     ..
*
*  Purpose
*  =======
*
*  DGETRS solves a system of linear equations
*     A * X = B  or  A' * X = B
*  with a general N-by-N matrix A using the LU factorization computed
*  by DGETRF.
*
*  Arguments
*  =========
*
*  TRANS   (input) CHARACTER*1
*          Specifies the form of the system of equations:
*          = 'N':  A * X = B  (No transpose)
*          = 'T':  A'* X = B  (Transpose)
*          = 'C':  A'* X = B  (Conjugate transpose = Transpose)
*
*  N       (input) INTEGER
*          The order of the matrix A.  N >= 0.
*
*  NRHS    (input) INTEGER
*          The number of right hand sides, i.e., the number of columns
*          of the matrix B.  NRHS >= 0.
*
*  A       (input) DOUBLE PRECISION array, dimension (LDA,N)
*          The factors L and U from the factorization A = P*L*U
*          as computed by DGETRF.
*
*  LDA     (input) INTEGER
*          The leading dimension of the array A.  LDA >= max(1,N).
*
*  IPIV    (input) INTEGER array, dimension (N)
*          The pivot indices from DGETRF; for 1<=i<=N, row i of the
*          matrix was interchanged with row IPIV(i).
*
*  B       (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS)
*          On entry, the right hand side matrix B.
*          On exit, the solution matrix X.
*
*  LDB     (input) INTEGER
*          The leading dimension of the array B.  LDB >= max(1,N).
*
*  INFO    (output) INTEGER
*          = 0:  successful exit
*          < 0:  if INFO = -i, the i-th argument had an illegal value
*
*  =====================================================================
*
*     .. Parameters ..
      DOUBLE PRECISION   ONE
      PARAMETER          ( ONE = 1.0D+0 )
*     ..
*     .. Local Scalars ..
      LOGICAL            NOTRAN
*     ..
*     .. External Functions ..
      LOGICAL            LSAME
      EXTERNAL           LSAME
*     ..
*     .. External Subroutines ..
      EXTERNAL           DLASWP, DTRSM, XERBLA
*     ..
*     .. Intrinsic Functions ..
      INTRINSIC          MAX
*     ..
*     .. Executable Statements ..
*
*     Test the input parameters.
*
      INFO = 0
      NOTRAN = LSAME( TRANS, 'N' )
      IF( .NOT.NOTRAN .AND. .NOT.LSAME( TRANS, 'T' ) .AND. .NOT.
     $    LSAME( TRANS, 'C' ) ) THEN
         INFO = -1
      ELSE IF( N.LT.0 ) THEN
         INFO = -2
      ELSE IF( NRHS.LT.0 ) THEN
         INFO = -3
      ELSE IF( LDA.LT.MAX( 1, N ) ) THEN
         INFO = -5
      ELSE IF( LDB.LT.MAX( 1, N ) ) THEN
         INFO = -8
      END IF
      IF( INFO.NE.0 ) THEN
         CALL XERBLA( 'DGETRS', -INFO )
         RETURN
      END IF
*
*     Quick return if possible
*
      IF( N.EQ.0 .OR. NRHS.EQ.0 )
     $   RETURN
*
      IF( NOTRAN ) THEN
*
*        Solve A * X = B.
*
*        Apply row interchanges to the right hand sides.
*
         CALL DLASWP( NRHS, B, LDB, 1, N, IPIV, 1 )
*
*        Solve L*X = B, overwriting B with X.
*
         CALL DTRSM( 'Left', 'Lower', 'No transpose', 'Unit', N, NRHS,
     $               ONE, A, LDA, B, LDB )
*
*        Solve U*X = B, overwriting B with X.
*
         CALL DTRSM( 'Left', 'Upper', 'No transpose', 'Non-unit', N,
     $               NRHS, ONE, A, LDA, B, LDB )
      ELSE
*
*        Solve A' * X = B.
*
*        Solve U'*X = B, overwriting B with X.
*
         CALL DTRSM( 'Left', 'Upper', 'Transpose', 'Non-unit', N, NRHS,
     $               ONE, A, LDA, B, LDB )
*
*        Solve L'*X = B, overwriting B with X.
*
         CALL DTRSM( 'Left', 'Lower', 'Transpose', 'Unit', N, NRHS, ONE,
     $               A, LDA, B, LDB )
*
*        Apply row interchanges to the solution vectors.
*
         CALL DLASWP( NRHS, B, LDB, 1, N, IPIV, -1 )
      END IF
*
      RETURN
*
*     End of DGETRS
*
      END      
      DOUBLE PRECISION FUNCTION dnrm2(N,X,INCX)
*
*  -- Reference BLAS level1 routine (version 3.4.0) --
*  -- Reference BLAS is a software package provided by Univ. of Tennessee,    --
*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
*     November 2011
*
*     .. Scalar Arguments ..
      INTEGER INCX,N
*     ..
*     .. Array Arguments ..
      DOUBLE PRECISION X(*)
*     ..
*
*  =====================================================================
*
*     .. Parameters ..
      DOUBLE PRECISION ONE,ZERO
      parameter(one=1.0d+0,zero=0.0d+0)
*     ..
*     .. Local Scalars ..
      DOUBLE PRECISION ABSXI,NORM,SCALE,SSQ
      INTEGER IX
*     ..
*     .. Intrinsic Functions ..
      INTRINSIC abs,sqrt
*     ..
      IF (n.LT.1 .OR. incx.LT.1) THEN
          norm = zero
      ELSE IF (n.EQ.1) THEN
          norm = abs(x(1))
      ELSE
          scale = zero
          ssq = one
*        The following loop is equivalent to this call to the LAPACK
*        auxiliary routine:
*        CALL DLASSQ( N, X, INCX, SCALE, SSQ )
*
          DO 10 ix = 1,1 + (n-1)*incx,incx
              IF (x(ix).NE.zero) THEN
                  absxi = abs(x(ix))
                  IF (scale.LT.absxi) THEN
                      ssq = one + ssq* (scale/absxi)**2
                      scale = absxi
                  ELSE
                      ssq = ssq + (absxi/scale)**2
                  END IF
              END IF
   10     CONTINUE
          norm = scale*sqrt(ssq)
      END IF
*
      dnrm2 = norm
      RETURN
*
*     End of DNRM2.
*
      END      

*DECK IXSAV
      INTEGER FUNCTION IXSAV (IPAR, IVALUE, ISET)
C***BEGIN PROLOGUE  IXSAV
C***SUBSIDIARY
C***PURPOSE  Save and recall error message control parameters.
C***CATEGORY  R3C
C***TYPE      ALL (IXSAV-A)
C***AUTHOR  Hindmarsh, Alan C., (LLNL)
C***DESCRIPTION
C
C  IXSAV saves and recalls one of two error message parameters:
C    LUNIT, the logical unit number to which messages are printed, and
C    MESFLG, the message print flag.
C  This is a modification of the SLATEC library routine J4SAVE.
C
C  Saved local variables..
C   LUNIT  = Logical unit number for messages.  The default is obtained
C            by a call to IUMACH (may be machine-dependent).
C   MESFLG = Print control flag..
C            1 means print all messages (the default).
C            0 means no printing.
C
C  On input..
C    IPAR   = Parameter indicator (1 for LUNIT, 2 for MESFLG).
C    IVALUE = The value to be set for the parameter, if ISET = .TRUE.
C    ISET   = Logical flag to indicate whether to read or write.
C             If ISET = .TRUE., the parameter will be given
C             the value IVALUE.  If ISET = .FALSE., the parameter
C             will be unchanged, and IVALUE is a dummy argument.
C
C  On return..
C    IXSAV = The (old) value of the parameter.
C
C***SEE ALSO  XERRWD, XERRWV
C***ROUTINES CALLED  IUMACH
C***REVISION HISTORY  (YYMMDD)
C   921118  DATE WRITTEN
C   930329  Modified prologue to SLATEC format. (FNF)
C   930915  Added IUMACH call to get default output unit.  (ACH)
C   930922  Minor cosmetic changes. (FNF)
C   010425  Type declaration for IUMACH added. (ACH)
C***END PROLOGUE  IXSAV
C
C Subroutines called by IXSAV.. None
C Function routine called by IXSAV.. IUMACH
C-----------------------------------------------------------------------
C**End
      LOGICAL ISET
      INTEGER IPAR, IVALUE
C-----------------------------------------------------------------------
      INTEGER IUMACH, LUNIT, MESFLG
C-----------------------------------------------------------------------
C The following Fortran-77 declaration is to cause the values of the
C listed (local) variables to be saved between calls to this routine.
C-----------------------------------------------------------------------
      SAVE LUNIT, MESFLG
      DATA LUNIT/-1/, MESFLG/1/
C
C***FIRST EXECUTABLE STATEMENT  IXSAV
      IF (IPAR .EQ. 1) THEN
        IF (LUNIT .EQ. -1) LUNIT = IUMACH()
        IXSAV = LUNIT
        IF (ISET) LUNIT = IVALUE
        ENDIF
C
      IF (IPAR .EQ. 2) THEN
        IXSAV = MESFLG
        IF (ISET) MESFLG = IVALUE
        ENDIF
C
      RETURN
C----------------------- End of Function IXSAV -------------------------
      END
*DECK IUMACH
      INTEGER FUNCTION IUMACH()
C***BEGIN PROLOGUE  IUMACH
C***PURPOSE  Provide standard output unit number.
C***CATEGORY  R1
C***TYPE      INTEGER (IUMACH-I)
C***KEYWORDS  MACHINE CONSTANTS
C***AUTHOR  Hindmarsh, Alan C., (LLNL)
C***DESCRIPTION
C *Usage:
C        INTEGER  LOUT, IUMACH
C        LOUT = IUMACH()
C
C *Function Return Values:
C     LOUT : the standard logical unit for Fortran output.
C
C***REFERENCES  (NONE)
C***ROUTINES CALLED  (NONE)
C***REVISION HISTORY  (YYMMDD)
C   930915  DATE WRITTEN
C   930922  Made user-callable, and other cosmetic changes. (FNF)
C***END PROLOGUE  IUMACH
C
C*Internal Notes:
C  The built-in value of 6 is standard on a wide range of Fortran
C  systems.  This may be machine-dependent.
C**End
C***FIRST EXECUTABLE STATEMENT  IUMACH
      IUMACH = 6
C
      RETURN
C----------------------- End of Function IUMACH ------------------------
      END
      INTEGER FUNCTION ILAENV( ISPEC, NAME, OPTS, N1, N2, N3,
     $                 N4 )
*
*  -- LAPACK auxiliary routine (preliminary version) --
*     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
*     Courant Institute, Argonne National Lab, and Rice University
*     February 20, 1992
*
*     .. Scalar Arguments ..
      CHARACTER*( * )    NAME, OPTS
      INTEGER            ISPEC, N1, N2, N3, N4
*     ..
*
*  Purpose
*  =======
*
*  ILAENV is called from the LAPACK routines to choose problem-dependent
*  parameters for the local environment.  See ISPEC for a description of
*  the parameters.
*
*  This version provides a set of parameters which should give good,
*  but not optimal, performance on many of the currently available
*  computers.  Users are encouraged to modify this subroutine to set
*  the tuning parameters for their particular machine using the option
*  and problem size information in the arguments.
*
*  This routine will not function correctly if it is converted to all
*  lower case.  Converting it to all upper case is allowed.
*
*  Arguments
*  =========
*
*  ISPEC   (input) INTEGER
*          Specifies the parameter to be returned as the value of
*          ILAENV.
*          = 1: the optimal blocksize; if this value is 1, an unblocked
*               algorithm will give the best performance.
*          = 2: the minimum block size for which the block routine
*               should be used; if the usable block size is less than
*               this value, an unblocked routine should be used.
*          = 3: the crossover point (in a block routine, for N less
*               than this value, an unblocked routine should be used)
*          = 4: the number of shifts, used in the nonsymmetric
*               eigenvalue routines
*          = 5: the minimum column dimension for blocking to be used;
*               rectangular blocks must have dimension at least k by m,
*               where k is given by ILAENV(2,...) and m by ILAENV(5,...)
*          = 6: the crossover point for the SVD (when reducing an m by n
*               matrix to bidiagonal form, if max(m,n)/min(m,n) exceeds
*               this value, a QR factorization is used first to reduce
*               the matrix to a triangular form.)
*          = 7: the number of processors
*          = 8: the crossover point for the multishift QR and QZ methods
*               for nonsymmetric eigenvalue problems.
*
*  NAME    (input) CHARACTER*(*)
*          The name of the calling subroutine, in either upper case or
*          lower case.
*
*  OPTS    (input) CHARACTER*(*)
*          The character options to the subroutine NAME, concatenated
*          into a single character string.  For example, UPLO = 'U',
*          TRANS = 'T', and DIAG = 'N' for a triangular routine would
*          be specified as OPTS = 'UTN'.
*
*  N1      (input) INTEGER
*  N2      (input) INTEGER
*  N3      (input) INTEGER
*  N4      (input) INTEGER
*          Problem dimensions for the subroutine NAME; these may not all
*          be required.
*
* (ILAENV) (output) INTEGER
*          >= 0: the value of the parameter specified by ISPEC
*          < 0:  if ILAENV = -k, the k-th argument had an illegal value.
*
*  Further Details
*  ===============
*
*  The following conventions have been used when calling ILAENV from the
*  LAPACK routines:
*  1)  OPTS is a concatenation of all of the character options to
*      subroutine NAME, in the same order that they appear in the
*      argument list for NAME, even if they are not used in determining
*      the value of the parameter specified by ISPEC.
*  2)  The problem dimensions N1, N2, N3, N4 are specified in the order
*      that they appear in the argument list for NAME.  N1 is used
*      first, N2 second, and so on, and unused problem dimensions are
*      passed a value of -1.
*  3)  The parameter value returned by ILAENV is checked for validity in
*      the calling subroutine.  For example, ILAENV is used to retrieve
*      the optimal blocksize for STRTRI as follows:
*
*      NB = ILAENV( 1, 'STRTRI', UPLO // DIAG, N, -1, -1, -1 )
*      IF( NB.LE.1 ) NB = MAX( 1, N )
*
*  =====================================================================
*
*     .. Local Scalars ..
      LOGICAL            CNAME, SNAME
      CHARACTER*1        C1
      CHARACTER*2        C2, C4
      CHARACTER*3        C3
      CHARACTER*6        SUBNAM
      INTEGER            I, IC, IZ, NB, NBMIN, NX
*     ..
*     .. Intrinsic Functions ..
      INTRINSIC          CHAR, ICHAR, INT, MIN, REAL
*     ..
*     .. Executable Statements ..
*
      GO TO ( 100, 100, 100, 400, 500, 600, 700, 800 ) ISPEC
*
*     Invalid value for ISPEC
*
      ILAENV = -1
      RETURN
*
  100 CONTINUE
*
*     Convert NAME to upper case if the first character is lower case.
*
      ILAENV = 1
      SUBNAM = NAME
      IC = ICHAR( SUBNAM( 1:1 ) )
      IZ = ICHAR( 'Z' )
      IF( IZ.EQ.90 .OR. IZ.EQ.122 ) THEN
*
*        ASCII character set
*
         IF( IC.GE.97 .AND. IC.LE.122 ) THEN
            SUBNAM( 1:1 ) = CHAR( IC-32 )
            DO 10 I = 2, 6
               IC = ICHAR( SUBNAM( I:I ) )
               IF( IC.GE.97 .AND. IC.LE.122 )
     $            SUBNAM( I:I ) = CHAR( IC-32 )
   10       CONTINUE
         END IF
*
      ELSE IF( IZ.EQ.233 .OR. IZ.EQ.169 ) THEN
*
*        EBCDIC character set
*
         IF( ( IC.GE.129 .AND. IC.LE.137 ) .OR.
     $       ( IC.GE.145 .AND. IC.LE.153 ) .OR.
     $       ( IC.GE.162 .AND. IC.LE.169 ) ) THEN
            SUBNAM( 1:1 ) = CHAR( IC+64 )
            DO 20 I = 2, 6
               IC = ICHAR( SUBNAM( I:I ) )
               IF( ( IC.GE.129 .AND. IC.LE.137 ) .OR.
     $             ( IC.GE.145 .AND. IC.LE.153 ) .OR.
     $             ( IC.GE.162 .AND. IC.LE.169 ) )
     $            SUBNAM( I:I ) = CHAR( IC+64 )
   20       CONTINUE
         END IF
*
      ELSE IF( IZ.EQ.218 .OR. IZ.EQ.250 ) THEN
*
*        Prime machines:  ASCII+128
*
         IF( IC.GE.225 .AND. IC.LE.250 ) THEN
            SUBNAM( 1:1 ) = CHAR( IC-32 )
            DO 30 I = 2, 6
               IC = ICHAR( SUBNAM( I:I ) )
               IF( IC.GE.225 .AND. IC.LE.250 )
     $            SUBNAM( I:I ) = CHAR( IC-32 )
   30       CONTINUE
         END IF
      END IF
*
      C1 = SUBNAM( 1:1 )
      SNAME = C1.EQ.'S' .OR. C1.EQ.'D'
      CNAME = C1.EQ.'C' .OR. C1.EQ.'Z'
      IF( .NOT.( CNAME .OR. SNAME ) )
     $   RETURN
      C2 = SUBNAM( 2:3 )
      C3 = SUBNAM( 4:6 )
      C4 = C3( 2:3 )
*
      GO TO ( 110, 200, 300 ) ISPEC
*
  110 CONTINUE
*
*     ISPEC = 1:  block size
*
*     In these examples, separate code is provided for setting NB for
*     real and complex.  We assume that NB will take the same value in
*     single or double precision.
*
      NB = 1
*
      IF( C2.EQ.'GE' ) THEN
         IF( C3.EQ.'TRF' ) THEN
            IF( SNAME ) THEN
               NB = 64
            ELSE
               NB = 64
            END IF
         ELSE IF( C3.EQ.'QRF' .OR. C3.EQ.'RQF' .OR. C3.EQ.'LQF' .OR.
     $            C3.EQ.'QLF' ) THEN
            IF( SNAME ) THEN
               NB = 32
            ELSE
               NB = 32
            END IF
         ELSE IF( C3.EQ.'HRD' ) THEN
            IF( SNAME ) THEN
               NB = 32
            ELSE
               NB = 32
            END IF
         ELSE IF( C3.EQ.'BRD' ) THEN
            IF( SNAME ) THEN
               NB = 32
            ELSE
               NB = 32
            END IF
         ELSE IF( C3.EQ.'TRI' ) THEN
            IF( SNAME ) THEN
               NB = 64
            ELSE
               NB = 64
            END IF
         END IF
      ELSE IF( C2.EQ.'PO' ) THEN
         IF( C3.EQ.'TRF' ) THEN
            IF( SNAME ) THEN
               NB = 64
            ELSE
               NB = 64
            END IF
         END IF
      ELSE IF( C2.EQ.'SY' ) THEN
         IF( C3.EQ.'TRF' ) THEN
            IF( SNAME ) THEN
               NB = 64
            ELSE
               NB = 64
            END IF
         ELSE IF( SNAME .AND. C3.EQ.'TRD' ) THEN
            NB = 1
         ELSE IF( SNAME .AND. C3.EQ.'GST' ) THEN
            NB = 64
         END IF
      ELSE IF( CNAME .AND. C2.EQ.'HE' ) THEN
         IF( C3.EQ.'TRF' ) THEN
            NB = 64
         ELSE IF( C3.EQ.'TRD' ) THEN
            NB = 1
         ELSE IF( C3.EQ.'GST' ) THEN
            NB = 64
         END IF
      ELSE IF( SNAME .AND. C2.EQ.'OR' ) THEN
         IF( C3( 1:1 ).EQ.'G' ) THEN
            IF( C4.EQ.'QR' .OR. C4.EQ.'RQ' .OR. C4.EQ.'LQ' .OR.
     $          C4.EQ.'QL' .OR. C4.EQ.'HR' .OR. C4.EQ.'TR' .OR.
     $          C4.EQ.'BR' ) THEN
               NB = 32
            END IF
         ELSE IF( C3( 1:1 ).EQ.'M' ) THEN
            IF( C4.EQ.'QR' .OR. C4.EQ.'RQ' .OR. C4.EQ.'LQ' .OR.
     $          C4.EQ.'QL' .OR. C4.EQ.'HR' .OR. C4.EQ.'TR' .OR.
     $          C4.EQ.'BR' ) THEN
               NB = 32
            END IF
         END IF
      ELSE IF( CNAME .AND. C2.EQ.'UN' ) THEN
         IF( C3( 1:1 ).EQ.'G' ) THEN
            IF( C4.EQ.'QR' .OR. C4.EQ.'RQ' .OR. C4.EQ.'LQ' .OR.
     $          C4.EQ.'QL' .OR. C4.EQ.'HR' .OR. C4.EQ.'TR' .OR.
     $          C4.EQ.'BR' ) THEN
               NB = 32
            END IF
         ELSE IF( C3( 1:1 ).EQ.'M' ) THEN
            IF( C4.EQ.'QR' .OR. C4.EQ.'RQ' .OR. C4.EQ.'LQ' .OR.
     $          C4.EQ.'QL' .OR. C4.EQ.'HR' .OR. C4.EQ.'TR' .OR.
     $          C4.EQ.'BR' ) THEN
               NB = 32
            END IF
         END IF
      ELSE IF( C2.EQ.'GB' ) THEN
         IF( C3.EQ.'TRF' ) THEN
            IF( SNAME ) THEN
               IF( N4.LE.64 ) THEN
                  NB = 1
               ELSE
                  NB = 32
               END IF
            ELSE
               IF( N4.LE.64 ) THEN
                  NB = 1
               ELSE
                  NB = 32
               END IF
            END IF
         END IF
      ELSE IF( C2.EQ.'PB' ) THEN
         IF( C3.EQ.'TRF' ) THEN
            IF( SNAME ) THEN
               IF( N2.LE.64 ) THEN
                  NB = 1
               ELSE
                  NB = 32
               END IF
            ELSE
               IF( N2.LE.64 ) THEN
                  NB = 1
               ELSE
                  NB = 32
               END IF
            END IF
         END IF
      ELSE IF( C2.EQ.'TR' ) THEN
         IF( C3.EQ.'TRI' ) THEN
            IF( SNAME ) THEN
               NB = 64
            ELSE
               NB = 64
            END IF
         END IF
      ELSE IF( C2.EQ.'LA' ) THEN
         IF( C3.EQ.'UUM' ) THEN
            IF( SNAME ) THEN
               NB = 64
            ELSE
               NB = 64
            END IF
         END IF
      ELSE IF( SNAME .AND. C2.EQ.'ST' ) THEN
         IF( C3.EQ.'EBZ' ) THEN
            NB = 1
         END IF
      END IF
      ILAENV = NB
      RETURN
*
  200 CONTINUE
*
*     ISPEC = 2:  minimum block size
*
      NBMIN = 2
      IF( C2.EQ.'GE' ) THEN
         IF( C3.EQ.'QRF' .OR. C3.EQ.'RQF' .OR. C3.EQ.'LQF' .OR.
     $       C3.EQ.'QLF' ) THEN
            IF( SNAME ) THEN
               NBMIN = 2
            ELSE
               NBMIN = 2
            END IF
         ELSE IF( C3.EQ.'HRD' ) THEN
            IF( SNAME ) THEN
               NBMIN = 2
            ELSE
               NBMIN = 2
            END IF
         ELSE IF( C3.EQ.'BRD' ) THEN
            IF( SNAME ) THEN
               NBMIN = 2
            ELSE
               NBMIN = 2
            END IF
         ELSE IF( C3.EQ.'TRI' ) THEN
            IF( SNAME ) THEN
               NBMIN = 2
            ELSE
               NBMIN = 2
            END IF
         END IF
      ELSE IF( C2.EQ.'SY' ) THEN
         IF( C3.EQ.'TRF' ) THEN
            IF( SNAME ) THEN
               NBMIN = 2
            ELSE
               NBMIN = 2
            END IF
         ELSE IF( SNAME .AND. C3.EQ.'TRD' ) THEN
            NBMIN = 2
         END IF
      ELSE IF( CNAME .AND. C2.EQ.'HE' ) THEN
         IF( C3.EQ.'TRD' ) THEN
            NBMIN = 2
         END IF
      ELSE IF( SNAME .AND. C2.EQ.'OR' ) THEN
         IF( C3( 1:1 ).EQ.'G' ) THEN
            IF( C4.EQ.'QR' .OR. C4.EQ.'RQ' .OR. C4.EQ.'LQ' .OR.
     $          C4.EQ.'QL' .OR. C4.EQ.'HR' .OR. C4.EQ.'TR' .OR.
     $          C4.EQ.'BR' ) THEN
               NBMIN = 2
            END IF
         ELSE IF( C3( 1:1 ).EQ.'M' ) THEN
            IF( C4.EQ.'QR' .OR. C4.EQ.'RQ' .OR. C4.EQ.'LQ' .OR.
     $          C4.EQ.'QL' .OR. C4.EQ.'HR' .OR. C4.EQ.'TR' .OR.
     $          C4.EQ.'BR' ) THEN
               NBMIN = 2
            END IF
         END IF
      ELSE IF( CNAME .AND. C2.EQ.'UN' ) THEN
         IF( C3( 1:1 ).EQ.'G' ) THEN
            IF( C4.EQ.'QR' .OR. C4.EQ.'RQ' .OR. C4.EQ.'LQ' .OR.
     $          C4.EQ.'QL' .OR. C4.EQ.'HR' .OR. C4.EQ.'TR' .OR.
     $          C4.EQ.'BR' ) THEN
               NBMIN = 2
            END IF
         ELSE IF( C3( 1:1 ).EQ.'M' ) THEN
            IF( C4.EQ.'QR' .OR. C4.EQ.'RQ' .OR. C4.EQ.'LQ' .OR.
     $          C4.EQ.'QL' .OR. C4.EQ.'HR' .OR. C4.EQ.'TR' .OR.
     $          C4.EQ.'BR' ) THEN
               NBMIN = 2
            END IF
         END IF
      END IF
      ILAENV = NBMIN
      RETURN
*
  300 CONTINUE
*
*     ISPEC = 3:  crossover point
*
      NX = 0
      IF( C2.EQ.'GE' ) THEN
         IF( C3.EQ.'QRF' .OR. C3.EQ.'RQF' .OR. C3.EQ.'LQF' .OR.
     $       C3.EQ.'QLF' ) THEN
            IF( SNAME ) THEN
               NX = 128
            ELSE
               NX = 128
            END IF
         ELSE IF( C3.EQ.'HRD' ) THEN
            IF( SNAME ) THEN
               NX = 128
            ELSE
               NX = 128
            END IF
         ELSE IF( C3.EQ.'BRD' ) THEN
            IF( SNAME ) THEN
               NX = 128
            ELSE
               NX = 128
            END IF
         END IF
      ELSE IF( C2.EQ.'SY' ) THEN
         IF( SNAME .AND. C3.EQ.'TRD' ) THEN
            NX = 1
         END IF
      ELSE IF( CNAME .AND. C2.EQ.'HE' ) THEN
         IF( C3.EQ.'TRD' ) THEN
            NX = 1
         END IF
      ELSE IF( SNAME .AND. C2.EQ.'OR' ) THEN
         IF( C3( 1:1 ).EQ.'G' ) THEN
            IF( C4.EQ.'QR' .OR. C4.EQ.'RQ' .OR. C4.EQ.'LQ' .OR.
     $          C4.EQ.'QL' .OR. C4.EQ.'HR' .OR. C4.EQ.'TR' .OR.
     $          C4.EQ.'BR' ) THEN
               NX = 128
            END IF
         END IF
      ELSE IF( CNAME .AND. C2.EQ.'UN' ) THEN
         IF( C3( 1:1 ).EQ.'G' ) THEN
            IF( C4.EQ.'QR' .OR. C4.EQ.'RQ' .OR. C4.EQ.'LQ' .OR.
     $          C4.EQ.'QL' .OR. C4.EQ.'HR' .OR. C4.EQ.'TR' .OR.
     $          C4.EQ.'BR' ) THEN
               NX = 128
            END IF
         END IF
      END IF
      ILAENV = NX
      RETURN
*
  400 CONTINUE
*
*     ISPEC = 4:  number of shifts (used by xHSEQR)
*
      ILAENV = 6
      RETURN
*
  500 CONTINUE
*
*     ISPEC = 5:  minimum column dimension (not used)
*
      ILAENV = 2
      RETURN
*
  600 CONTINUE
*
*     ISPEC = 6:  crossover point for SVD (used by xGELSS and xGESVD)
*
      ILAENV = INT( REAL( MIN( N1, N2 ) )*1.6E0 )
      RETURN
*
  700 CONTINUE
*
*     ISPEC = 7:  number of processors (not used)
*
      ILAENV = 1
      RETURN
*
  800 CONTINUE
*
*     ISPEC = 8:  crossover point for multishift (used by xHSEQR)
*
      ILAENV = 50
      RETURN
*
*     End of ILAENV
*
      END
c      
      SUBROUTINE DGER  ( M, N, ALPHA, X, INCX, Y, INCY, A, LDA )
*     .. Scalar Arguments ..
      DOUBLE PRECISION   ALPHA
      INTEGER            INCX, INCY, LDA, M, N
*     .. Array Arguments ..
      DOUBLE PRECISION   A( LDA, * ), X( * ), Y( * )
*     ..
*
*  Purpose
*  =======
*
*  DGER   performs the rank 1 operation
*
*     A := alpha*x*y' + A,
*
*  where alpha is a scalar, x is an m element vector, y is an n element
*  vector and A is an m by n matrix.
*
*  Parameters
*  ==========
*
*  M      - INTEGER.
*           On entry, M specifies the number of rows of the matrix A.
*           M must be at least zero.
*           Unchanged on exit.
*
*  N      - INTEGER.
*           On entry, N specifies the number of columns of the matrix A.
*           N must be at least zero.
*           Unchanged on exit.
*
*  ALPHA  - DOUBLE PRECISION.
*           On entry, ALPHA specifies the scalar alpha.
*           Unchanged on exit.
*
*  X      - DOUBLE PRECISION array of dimension at least
*           ( 1 + ( m - 1 )*abs( INCX ) ).
*           Before entry, the incremented array X must contain the m
*           element vector x.
*           Unchanged on exit.
*
*  INCX   - INTEGER.
*           On entry, INCX specifies the increment for the elements of
*           X. INCX must not be zero.
*           Unchanged on exit.
*
*  Y      - DOUBLE PRECISION array of dimension at least
*           ( 1 + ( n - 1 )*abs( INCY ) ).
*           Before entry, the incremented array Y must contain the n
*           element vector y.
*           Unchanged on exit.
*
*  INCY   - INTEGER.
*           On entry, INCY specifies the increment for the elements of
*           Y. INCY must not be zero.
*           Unchanged on exit.
*
*  A      - DOUBLE PRECISION array of DIMENSION ( LDA, n ).
*           Before entry, the leading m by n part of the array A must
*           contain the matrix of coefficients. On exit, A is
*           overwritten by the updated matrix.
*
*  LDA    - INTEGER.
*           On entry, LDA specifies the first dimension of A as declared
*           in the calling (sub) program. LDA must be at least
*           max( 1, m ).
*           Unchanged on exit.
*
*
*  Level 2 Blas routine.
*
*  -- Written on 22-October-1986.
*     Jack Dongarra, Argonne National Lab.
*     Jeremy Du Croz, Nag Central Office.
*     Sven Hammarling, Nag Central Office.
*     Richard Hanson, Sandia National Labs.
*
*
*     .. Parameters ..
      DOUBLE PRECISION   ZERO
      PARAMETER        ( ZERO = 0.0D+0 )
*     .. Local Scalars ..
      DOUBLE PRECISION   TEMP
      INTEGER            I, INFO, IX, J, JY, KX
*     .. External Subroutines ..
      EXTERNAL           XERBLA
*     .. Intrinsic Functions ..
      INTRINSIC          MAX
*     ..
*     .. Executable Statements ..
*
*     Test the input parameters.
*
      INFO = 0
      IF     ( M.LT.0 )THEN
         INFO = 1
      ELSE IF( N.LT.0 )THEN
         INFO = 2
      ELSE IF( INCX.EQ.0 )THEN
         INFO = 5
      ELSE IF( INCY.EQ.0 )THEN
         INFO = 7
      ELSE IF( LDA.LT.MAX( 1, M ) )THEN
         INFO = 9
      END IF
      IF( INFO.NE.0 )THEN
         CALL XERBLA( 'DGER  ', INFO )
         RETURN
      END IF
*
*     Quick return if possible.
*
      IF( ( M.EQ.0 ).OR.( N.EQ.0 ).OR.( ALPHA.EQ.ZERO ) )
     $   RETURN
*
*     Start the operations. In this version the elements of A are
*     accessed sequentially with one pass through A.
*
      IF( INCY.GT.0 )THEN
         JY = 1
      ELSE
         JY = 1 - ( N - 1 )*INCY
      END IF
      IF( INCX.EQ.1 )THEN
         DO 20, J = 1, N
            IF( Y( JY ).NE.ZERO )THEN
               TEMP = ALPHA*Y( JY )
               DO 10, I = 1, M
                  A( I, J ) = A( I, J ) + X( I )*TEMP
   10          CONTINUE
            END IF
            JY = JY + INCY
   20    CONTINUE
      ELSE
         IF( INCX.GT.0 )THEN
            KX = 1
         ELSE
            KX = 1 - ( M - 1 )*INCX
         END IF
         DO 40, J = 1, N
            IF( Y( JY ).NE.ZERO )THEN
               TEMP = ALPHA*Y( JY )
               IX   = KX
               DO 30, I = 1, M
                  A( I, J ) = A( I, J ) + X( IX )*TEMP
                  IX        = IX        + INCX
   30          CONTINUE
            END IF
            JY = JY + INCY
   40    CONTINUE
      END IF
*
      RETURN
*
*     End of DGER  .
*
      END
      SUBROUTINE DLASWP( N, A, LDA, K1, K2, IPIV, INCX )
*
*  -- LAPACK auxiliary routine (version 1.1) --
*     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
*     Courant Institute, Argonne National Lab, and Rice University
*     October 31, 1992
*
*     .. Scalar Arguments ..
      INTEGER            INCX, K1, K2, LDA, N
*     ..
*     .. Array Arguments ..
      INTEGER            IPIV( * )
      DOUBLE PRECISION   A( LDA, * )
*     ..
*
*  Purpose
*  =======
*
*  DLASWP performs a series of row interchanges on the matrix A.
*  One row interchange is initiated for each of rows K1 through K2 of A.
*
*  Arguments
*  =========
*
*  N       (input) INTEGER
*          The number of columns of the matrix A.
*
*  A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
*          On entry, the matrix of column dimension N to which the row
*          interchanges will be applied.
*          On exit, the permuted matrix.
*
*  LDA     (input) INTEGER
*          The leading dimension of the array A.
*
*  K1      (input) INTEGER
*          The first element of IPIV for which a row interchange will
*          be done.
*
*  K2      (input) INTEGER
*          The last element of IPIV for which a row interchange will
*          be done.
*
*  IPIV    (input) INTEGER array, dimension (M*abs(INCX))
*          The vector of pivot indices.  Only the elements in positions
*          K1 through K2 of IPIV are accessed.
*          IPIV(K) = L implies rows K and L are to be interchanged.
*
*  INCX    (input) INTEGER
*          The increment between successive values of IPIV.  If IPIV
*          is negative, the pivots are applied in reverse order.
*
* =====================================================================
*
*     .. Local Scalars ..
      INTEGER            I, IP, IX
*     ..
*     .. External Subroutines ..
      EXTERNAL           DSWAP
*     ..
*     .. Executable Statements ..
*
*     Interchange row I with row IPIV(I) for each of rows K1 through K2.
*
      IF( INCX.EQ.0 )
     $   RETURN
      IF( INCX.GT.0 ) THEN
         IX = K1
      ELSE
         IX = 1 + ( 1-K2 )*INCX
      END IF
      IF( INCX.EQ.1 ) THEN
         DO 10 I = K1, K2
            IP = IPIV( I )
            IF( IP.NE.I )
     $         CALL DSWAP( N, A( I, 1 ), LDA, A( IP, 1 ), LDA )
   10    CONTINUE
      ELSE IF( INCX.GT.1 ) THEN
         DO 20 I = K1, K2
            IP = IPIV( IX )
            IF( IP.NE.I )
     $         CALL DSWAP( N, A( I, 1 ), LDA, A( IP, 1 ), LDA )
            IX = IX + INCX
   20    CONTINUE
      ELSE IF( INCX.LT.0 ) THEN
         DO 30 I = K2, K1, -1
            IP = IPIV( IX )
            IF( IP.NE.I )
     $         CALL DSWAP( N, A( I, 1 ), LDA, A( IP, 1 ), LDA )
            IX = IX + INCX
   30    CONTINUE
      END IF
*
      RETURN
*
*     End of DLASWP
*
      END
      SUBROUTINE DTBSV ( UPLO, TRANS, DIAG, N, K, A, LDA, X, INCX )
*     .. Scalar Arguments ..
      INTEGER            INCX, K, LDA, N
      CHARACTER*1        DIAG, TRANS, UPLO
*     .. Array Arguments ..
      DOUBLE PRECISION   A( LDA, * ), X( * )
*     ..
*
*  Purpose
*  =======
*
*  DTBSV  solves one of the systems of equations
*
*     A*x = b,   or   A'*x = b,
*
*  where b and x are n element vectors and A is an n by n unit, or
*  non-unit, upper or lower triangular band matrix, with ( k + 1 )
*  diagonals.
*
*  No test for singularity or near-singularity is included in this
*  routine. Such tests must be performed before calling this routine.
*
*  Parameters
*  ==========
*
*  UPLO   - CHARACTER*1.
*           On entry, UPLO specifies whether the matrix is an upper or
*           lower triangular matrix as follows:
*
*              UPLO = 'U' or 'u'   A is an upper triangular matrix.
*
*              UPLO = 'L' or 'l'   A is a lower triangular matrix.
*
*           Unchanged on exit.
*
*  TRANS  - CHARACTER*1.
*           On entry, TRANS specifies the equations to be solved as
*           follows:
*
*              TRANS = 'N' or 'n'   A*x = b.
*
*              TRANS = 'T' or 't'   A'*x = b.
*
*              TRANS = 'C' or 'c'   A'*x = b.
*
*           Unchanged on exit.
*
*  DIAG   - CHARACTER*1.
*           On entry, DIAG specifies whether or not A is unit
*           triangular as follows:
*
*              DIAG = 'U' or 'u'   A is assumed to be unit triangular.
*
*              DIAG = 'N' or 'n'   A is not assumed to be unit
*                                  triangular.
*
*           Unchanged on exit.
*
*  N      - INTEGER.
*           On entry, N specifies the order of the matrix A.
*           N must be at least zero.
*           Unchanged on exit.
*
*  K      - INTEGER.
*           On entry with UPLO = 'U' or 'u', K specifies the number of
*           super-diagonals of the matrix A.
*           On entry with UPLO = 'L' or 'l', K specifies the number of
*           sub-diagonals of the matrix A.
*           K must satisfy  0 .le. K.
*           Unchanged on exit.
*
*  A      - DOUBLE PRECISION array of DIMENSION ( LDA, n ).
*           Before entry with UPLO = 'U' or 'u', the leading ( k + 1 )
*           by n part of the array A must contain the upper triangular
*           band part of the matrix of coefficients, supplied column by
*           column, with the leading diagonal of the matrix in row
*           ( k + 1 ) of the array, the first super-diagonal starting at
*           position 2 in row k, and so on. The top left k by k triangle
*           of the array A is not referenced.
*           The following program segment will transfer an upper
*           triangular band matrix from conventional full matrix storage
*           to band storage:
*
*                 DO 20, J = 1, N
*                    M = K + 1 - J
*                    DO 10, I = MAX( 1, J - K ), J
*                       A( M + I, J ) = matrix( I, J )
*              10    CONTINUE
*              20 CONTINUE
*
*           Before entry with UPLO = 'L' or 'l', the leading ( k + 1 )
*           by n part of the array A must contain the lower triangular
*           band part of the matrix of coefficients, supplied column by
*           column, with the leading diagonal of the matrix in row 1 of
*           the array, the first sub-diagonal starting at position 1 in
*           row 2, and so on. The bottom right k by k triangle of the
*           array A is not referenced.
*           The following program segment will transfer a lower
*           triangular band matrix from conventional full matrix storage
*           to band storage:
*
*                 DO 20, J = 1, N
*                    M = 1 - J
*                    DO 10, I = J, MIN( N, J + K )
*                       A( M + I, J ) = matrix( I, J )
*              10    CONTINUE
*              20 CONTINUE
*
*           Note that when DIAG = 'U' or 'u' the elements of the array A
*           corresponding to the diagonal elements of the matrix are not
*           referenced, but are assumed to be unity.
*           Unchanged on exit.
*
*  LDA    - INTEGER.
*           On entry, LDA specifies the first dimension of A as declared
*           in the calling (sub) program. LDA must be at least
*           ( k + 1 ).
*           Unchanged on exit.
*
*  X      - DOUBLE PRECISION array of dimension at least
*           ( 1 + ( n - 1 )*abs( INCX ) ).
*           Before entry, the incremented array X must contain the n
*           element right-hand side vector b. On exit, X is overwritten
*           with the solution vector x.
*
*  INCX   - INTEGER.
*           On entry, INCX specifies the increment for the elements of
*           X. INCX must not be zero.
*           Unchanged on exit.
*
*
*  Level 2 Blas routine.
*
*  -- Written on 22-October-1986.
*     Jack Dongarra, Argonne National Lab.
*     Jeremy Du Croz, Nag Central Office.
*     Sven Hammarling, Nag Central Office.
*     Richard Hanson, Sandia National Labs.
*
*
*     .. Parameters ..
      DOUBLE PRECISION   ZERO
      PARAMETER        ( ZERO = 0.0D+0 )
*     .. Local Scalars ..
      DOUBLE PRECISION   TEMP
      INTEGER            I, INFO, IX, J, JX, KPLUS1, KX, L
      LOGICAL            NOUNIT
*     .. External Functions ..
      LOGICAL            LSAME
      EXTERNAL           LSAME
*     .. External Subroutines ..
      EXTERNAL           XERBLA
*     .. Intrinsic Functions ..
      INTRINSIC          MAX, MIN
*     ..
*     .. Executable Statements ..
*
*     Test the input parameters.
*
      INFO = 0
      IF     ( .NOT.LSAME( UPLO , 'U' ).AND.
     $         .NOT.LSAME( UPLO , 'L' )      )THEN
         INFO = 1
      ELSE IF( .NOT.LSAME( TRANS, 'N' ).AND.
     $         .NOT.LSAME( TRANS, 'T' ).AND.
     $         .NOT.LSAME( TRANS, 'C' )      )THEN
         INFO = 2
      ELSE IF( .NOT.LSAME( DIAG , 'U' ).AND.
     $         .NOT.LSAME( DIAG , 'N' )      )THEN
         INFO = 3
      ELSE IF( N.LT.0 )THEN
         INFO = 4
      ELSE IF( K.LT.0 )THEN
         INFO = 5
      ELSE IF( LDA.LT.( K + 1 ) )THEN
         INFO = 7
      ELSE IF( INCX.EQ.0 )THEN
         INFO = 9
      END IF
      IF( INFO.NE.0 )THEN
         CALL XERBLA( 'DTBSV ', INFO )
         RETURN
      END IF
*
*     Quick return if possible.
*
      IF( N.EQ.0 )
     $   RETURN
*
      NOUNIT = LSAME( DIAG, 'N' )
*
*     Set up the start point in X if the increment is not unity. This
*     will be  ( N - 1 )*INCX  too small for descending loops.
*
      IF( INCX.LE.0 )THEN
         KX = 1 - ( N - 1 )*INCX
      ELSE IF( INCX.NE.1 )THEN
         KX = 1
      END IF
*
*     Start the operations. In this version the elements of A are
*     accessed by sequentially with one pass through A.
*
      IF( LSAME( TRANS, 'N' ) )THEN
*
*        Form  x := inv( A )*x.
*
         IF( LSAME( UPLO, 'U' ) )THEN
            KPLUS1 = K + 1
            IF( INCX.EQ.1 )THEN
               DO 20, J = N, 1, -1
                  IF( X( J ).NE.ZERO )THEN
                     L = KPLUS1 - J
                     IF( NOUNIT )
     $                  X( J ) = X( J )/A( KPLUS1, J )
                     TEMP = X( J )
                     DO 10, I = J - 1, MAX( 1, J - K ), -1
                        X( I ) = X( I ) - TEMP*A( L + I, J )
   10                CONTINUE
                  END IF
   20          CONTINUE
            ELSE
               KX = KX + ( N - 1 )*INCX
               JX = KX
               DO 40, J = N, 1, -1
                  KX = KX - INCX
                  IF( X( JX ).NE.ZERO )THEN
                     IX = KX
                     L  = KPLUS1 - J
                     IF( NOUNIT )
     $                  X( JX ) = X( JX )/A( KPLUS1, J )
                     TEMP = X( JX )
                     DO 30, I = J - 1, MAX( 1, J - K ), -1
                        X( IX ) = X( IX ) - TEMP*A( L + I, J )
                        IX      = IX      - INCX
   30                CONTINUE
                  END IF
                  JX = JX - INCX
   40          CONTINUE
            END IF
         ELSE
            IF( INCX.EQ.1 )THEN
               DO 60, J = 1, N
                  IF( X( J ).NE.ZERO )THEN
                     L = 1 - J
                     IF( NOUNIT )
     $                  X( J ) = X( J )/A( 1, J )
                     TEMP = X( J )
                     DO 50, I = J + 1, MIN( N, J + K )
                        X( I ) = X( I ) - TEMP*A( L + I, J )
   50                CONTINUE
                  END IF
   60          CONTINUE
            ELSE
               JX = KX
               DO 80, J = 1, N
                  KX = KX + INCX
                  IF( X( JX ).NE.ZERO )THEN
                     IX = KX
                     L  = 1  - J
                     IF( NOUNIT )
     $                  X( JX ) = X( JX )/A( 1, J )
                     TEMP = X( JX )
                     DO 70, I = J + 1, MIN( N, J + K )
                        X( IX ) = X( IX ) - TEMP*A( L + I, J )
                        IX      = IX      + INCX
   70                CONTINUE
                  END IF
                  JX = JX + INCX
   80          CONTINUE
            END IF
         END IF
      ELSE
*
*        Form  x := inv( A')*x.
*
         IF( LSAME( UPLO, 'U' ) )THEN
            KPLUS1 = K + 1
            IF( INCX.EQ.1 )THEN
               DO 100, J = 1, N
                  TEMP = X( J )
                  L    = KPLUS1 - J
                  DO 90, I = MAX( 1, J - K ), J - 1
                     TEMP = TEMP - A( L + I, J )*X( I )
   90             CONTINUE
                  IF( NOUNIT )
     $               TEMP = TEMP/A( KPLUS1, J )
                  X( J ) = TEMP
  100          CONTINUE
            ELSE
               JX = KX
               DO 120, J = 1, N
                  TEMP = X( JX )
                  IX   = KX
                  L    = KPLUS1  - J
                  DO 110, I = MAX( 1, J - K ), J - 1
                     TEMP = TEMP - A( L + I, J )*X( IX )
                     IX   = IX   + INCX
  110             CONTINUE
                  IF( NOUNIT )
     $               TEMP = TEMP/A( KPLUS1, J )
                  X( JX ) = TEMP
                  JX      = JX   + INCX
                  IF( J.GT.K )
     $               KX = KX + INCX
  120          CONTINUE
            END IF
         ELSE
            IF( INCX.EQ.1 )THEN
               DO 140, J = N, 1, -1
                  TEMP = X( J )
                  L    = 1      - J
                  DO 130, I = MIN( N, J + K ), J + 1, -1
                     TEMP = TEMP - A( L + I, J )*X( I )
  130             CONTINUE
                  IF( NOUNIT )
     $               TEMP = TEMP/A( 1, J )
                  X( J ) = TEMP
  140          CONTINUE
            ELSE
               KX = KX + ( N - 1 )*INCX
               JX = KX
               DO 160, J = N, 1, -1
                  TEMP = X( JX )
                  IX   = KX
                  L    = 1       - J
                  DO 150, I = MIN( N, J + K ), J + 1, -1
                     TEMP = TEMP - A( L + I, J )*X( IX )
                     IX   = IX   - INCX
  150             CONTINUE
                  IF( NOUNIT )
     $               TEMP = TEMP/A( 1, J )
                  X( JX ) = TEMP
                  JX      = JX   - INCX
                  IF( ( N - J ).GE.K )
     $               KX = KX - INCX
  160          CONTINUE
            END IF
         END IF
      END IF
*
      RETURN
*
*     End of DTBSV .
*
      END
