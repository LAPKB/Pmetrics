#' Plot PMcov objects
#'
#' This method will plot any two columns, specified using a formula, of a PMcov object, which contains covariate and Bayesian posterior parameter information
#' for each subject.  Specifiying any two variables that do not include time will result in a scatter plot with optional regression and reference lines.  If
#' time is included as the x variable, the y variable will be plotted vs. time, aggregated by subject.  This can be useful to see time varying parameters,
#' although a formula within formula approach may be required, e.g. plot(cov.1,I(cl_0*wt**0.75)~time) in order to see the change in cl over time according to 
#' the change in wt over time, even though cl_0 is constant for a given subject.
#'
#' @title Plot Pmetrics Covariate objects
#' @method plot PMcov
#' @param x The name of an \emph{PMcov} data object generated by \code{\link{makeCov}}
#' @param formula This is a mandatory formula of the form \code{y ~ x}, where \code{y} and \code{x}
#' are the two \code{data} parameters to plot.
#' @param icen A character vector to summarize covariate and parameter values.  Default is \dQuote{median}, but can also be one of \dQuote{none},
#' \dQuote{mean}.  If \code{time} is a variable in \code{formula}, the value will be set to \dQuote{none} and the \code{y} values
#' will be aggregated by subject ID vs. time.
#' @param include A vector of subject IDs to include in the plot, e.g. c(1:3,5,15)
#' @param exclude A vector of subject IDs to exclude in the plot, e.g. c(4,6:14,16:20)
#' @param mult Multiplication factor for y axis, e.g. to convert mg/L to ng/mL
#' @param log Boolean operator to plot in log-log space; the default is \code{False}
#' @param square Boolean operator to force a square plot with equal x and y limits; the default is \code{True}
#' @param ref Boolean operator to draw a unity line; the default is \code{True} unless \dQuote{time} is the x value in \code{formula} in which case this is ignored
#' @param lowess Boolean operator to draw a lowess regression line; the default is \code{False} and this is ignored if \dQuote{time} is the x value in \code{formula}
#' @param reg Boolean operator to draw a linear regression line; the default is \code{True} unless \dQuote{time} is the x value in \code{formula} in which case this is ignored.
#' If this option is selected, regression statistics will be printed on the plot if at least 3 subjects are included.
#' @param ident Boolean operator to plot points as ID numbers; the default is \code{False}.
#' This option is useful to identify outliers.
#' @param grid Either a boolean operator to plot a reference grid, or a list with elements x and y,
#' each of which is a vector specifying the native coordinates to plot grid lines; the default is \code{False}.
#' For example, grid=list(x=seq(0,24,2),y=1:10).  Defaults for missing x or y will be calculated by \code{\link{axTicks}}.
#' @param ci The confidence interval for the linear regression parameter estimates; the default is 0.95.
#' @param cex Size of the plot symbols.
#' @param cex.lab Size of the plot labels.
#' @param x.stat Horizontal position to plot the linear regression statistics;
#' the units are relative to the origin, i.e. extreme left is 0 and extreme right is 1.
#' @param y.stat Vertical position to plot the linear regression statistics; 
#' the units are relative to the origin, i.e. extreme bottom is 0 and extreme top is 1.
#' @param col.stat Color of the text for the regression statistics.
#' @param cex.stat Size of the text for the regression statistics.
#' @param lwd Width of the various regression or reference lines (unity, linear regression, or
#' lowess regression)
#' @param col This parameter will be applied to the plotting symbol and is \dQuote{red} by default.
#' @param xlim Limits of the x-axis as a vector, e.g. \code{c(0,1)}.  It does not need to be specified, but can be.
#' @param ylim Analogous to \code{xlim}
#' @param xlab Label for the x-axis.  If missing, will default to the name of the x-variable.
#' @param ylab Label for the y-axis.  If missing, will default to the name of the y-variable.
#' @param out Direct output to a PDF, EPS or image file.  Format is a named list whose first argument, 
#' \code{type} is one of the following character vectors: \dQuote{pdf}, \dQuote{eps} (maps to \code{postscript}),
#' \dQuote{\code{png}}, \dQuote{\code{tiff}}, \dQuote{\code{jpeg}}, or \dQuote{\code{bmp}}.  Other named items in the list
#' are the arguments to each graphic device. PDF and EPS are vector images acceptable to most journals
#' in a very small file size, with scalable (i.e. infinite) resolution.  The others are raster images which may be very
#' large files at publication quality dots per inch (DPI), e.g. 800 or 1200. Default value is \code{NA} which means the 
#' output will go to the current graphic device (usually the monitor). For example, to output an eps file,
#' out=list(\dQuote{eps}) will generate a 7x7 inch (default) graphic.
#' @param \dots Other parameters as found in \code{\link{plot.default}}.
#' @return Plots the object.
#' @author Michael Neely
#' @seealso \code{\link{makeCov}}, \code{\link{plot}}, \code{\link{par}}, \code{\link{axis}}
#' @export
#' @examples
#' data(PMex1)
#' plot(cov.1,V~wt)


plot.PMcov <- function(x,formula,icen="median",include,exclude,mult=1,log=F,square=F,ref=F,lowess=F,grid=F,ident=F,reg=F,ci=0.95,cex=1,
                       cex.lab=1.2,x.stat=0.6,y.stat=0.1,col.stat="black",cex.stat=0.8,lwd=2,col="red",
                       xlim,ylim,xlab,ylab,out=NA,...){ 
  
  
  if(missing(formula)) stop("Please supply a formula of the form y ~ x")
  if(!missing(include)) x <- subset(x,as.character(x$id) %in% as.character(include))
  if(!missing(exclude)) x <- subset(x,!sub("[[:space:]]+","",as.character(x$id)) %in% as.character(exclude))
  
  #choose output
  if(inherits(out,"list")){
    if(out$type=="eps") {setEPS();out$type <- "postscript"}
    if(length(out)>1) {do.call(out$type,args=out[-1])} else {do.call(out$type,list())}
  }
  
  vars <- names(get_all_vars(formula=formula,data=x))
  if("time" %in% vars) {timearg <- T} else {timearg <- F}    
  choice <- function(x,icen){
    switch(icen,mean=mean(x),median=median(x),mode=as.numeric(names(sort(-table(x)))[1]),median(x))
  } 
  #use summary of covariate or not
  if("icen" %in% names(x)){
    data <- x[x$icen==icen,]
    data <- subset(data,select=-icen) 
  } else {
    data <- x
    cat("\nPlease use makeCov and PMsave to update your PMcov object.\n")
    flush.console()
    
  }

  temp3 <- NA
  if(icen!="none" & !timearg){ #if time is not part of the formula, or no summary
    id <- unique(data$id)
    for (i in id){
      temp <- data[data$id==i,-1]
      if(nrow(temp)>1){
        temp2 <- apply(temp,2,choice,icen=icen)
      } else {temp2 <- temp}
      temp3 <- rbind(temp3,temp2)
    }
    temp3 <- temp3[-1,]

    if(is.null(nrow(temp3))){
      data <- data.frame(id=as.character(id),t(temp3),row.names=1)
    } else {data <- data.frame(id=as.character(id),temp3,row.names=1:nrow(temp3))}
  }
  
  data2 <- model.frame(formula=formula,data=data)
  x <- data2[,2]
  y <- data2[,1]
  id <- data$id
  
  
  if(!is.factor(x)){ x<- mult*x}
  if(!is.factor(y)){ y<- mult*y}
  
  if (missing(xlab)) xlab <- as.character(attr(terms(formula),"variables")[3])
  if (missing(ylab)) ylab <- as.character(attr(terms(formula),"variables")[2])
  
  if (log){
    if(is.factor(y) & is.factor(x) & length(x)>2){
      op.r <- glm(y~x,family="binomial")
      logplot <- ""
      xaxt <-"s"
      yaxt <-"s"
    }
    if(is.factor(y) & !is.factor(x) & length(x)>2){
      op.r <- glm(y~log10(x),family="binomial")
      logplot <- "x"
      xaxt <-"n"
      yaxt <-"s"            
    }
    if(!is.factor(y) & is.factor(x) & length(x)>2){
      op.r <- lm(log10(y)~x)
      logplot <- "y"
      xaxt <-"s"
      yaxt <-"n"            
    }
    if(!is.factor(y) & !is.factor(x) & length(x)>2){
      op.r <- lm(log10(y)~log10(x))
      logplot <- "xy"
      xaxt <-"n"
      yaxt <-"n"
    }            
  } else {
    if(is.factor(y) & length(x)>2){op.r <- glm(y~x,family="binomial")}
    if(!is.factor(y) & length(x)>2){op.r <- lm(y~x)}
    logplot <- ""
    xaxt <-"s"
    yaxt <-"s"
  }
  if(!is.factor(y) & !is.factor(x) & length(x)>2){
    text <- paste("R-squared = ",round(summary(op.r)$r.squared,2),
                  "\nInter = ",round(coef(op.r)[1],2)," (",ci*100,"%CI ",round(confint(op.r,level=ci)[1,1],2)," to ",round(confint(op.r,level=ci)[1,2],2),")",
                  "\nSlope = ",round(coef(op.r)[2],2)," (",ci*100,"%CI ",round(confint(op.r,level=ci)[2,1],2)," to ",round(confint(op.r,level=ci)[2,2],2),")",sep="")          
  }
  if(!is.factor(y) & is.factor(x) & length(x)>2){
    text <- paste(xlab," mean effect: ",round(coef(op.r)[2],2)," (",ci*100,"%CI ",round(confint(op.r,level=ci)[2,1],2)," to ",round(confint(op.r,level=ci)[2,2],2),")",sep="")
  }
  if (missing(xlim)){
    if(!is.factor(x)){xlim <- range(x,na.rm=T)} else {xlim <- c(0.5,0.5+length(levels(x)))}
  }
  if (missing(ylim)){ylim <- range(y,na.rm=T)}
  if (square){
    xlim <- c(min(xlim,ylim),max(xlim,ylim))
    ylim <- xlim
  }
  if (log) {
    hpos.text <- 10**(log10(xlim[1])+x.stat*diff(log10(xlim)))
    vpos.text <- 10**(log10(ylim[1])+y.stat*diff(log10(ylim)))
  } else {
    hpos.text <- xlim[1]+x.stat*diff(xlim)
    vpos.text <- ylim[1]+y.stat*diff(ylim)
  }
  
  
  
  plot(y~x,type="n",xlab=xlab,ylab=ylab,cex.lab=cex.lab,log=logplot,xlim=xlim,ylim=ylim,xaxt=xaxt,yaxt=yaxt,...)
  if(missing(grid)){
    grid <- list(x=NA,y=NA)
  } else {
    if(inherits(grid,"logical")){
      if(grid){
        grid <- list(x=axTicks(1),y=axTicks(2))
      } else {
        grid <- list(x=NA,y=NA)
      }
    }
    if(inherits(grid,"list")){
      if(is.null(grid$x)) grid$x <- axTicks(1)
      if(is.null(grid$y)) grid$y <- axTicks(2)
    }
  }
  
  if(xaxt=="n") logAxis(1,grid=!all(is.na(grid$x)))
  if(yaxt=="n") logAxis(2,grid=!all(is.na(grid$y)))
  abline(v=grid$x,lty=1,col="lightgray")
  abline(h=grid$y,lty=1,col="lightgray")
  if(!ident){            
    points(x=x,y=y,col=col,cex=cex,...)
  } else {
    if(length(grep("SIM",id))>0) id <- as.numeric(gsub("[[:alpha:]]","",id))
    text(x=x,y=y,labels=id,col=col,cex=cex,...)} 
  if(timearg){  #there's a time argument, so aggregate by subject vs. time
    nsub <- length(unique(data$id))
    for(i in 1:nsub){
      lines(x=x[which(id==unique(id)[i])],y=y[which(id==unique(id)[i])],col=col,...)
    }
  }
  if(ref & !timearg) abline(a=0,b=1,lty="dashed")
  if(lowess & !timearg) lines(lowess(x=x,y=y),lty="dotted",lwd=lwd)
  
  if(reg & !timearg & length(x)>2){
    if(!is.factor(y) & !is.factor(x)){abline(op.r,col=col.stat,lwd=lwd)}
    text(x=hpos.text,y=vpos.text,text,pos=4,col=col.stat,cex=cex.stat)
  }
  
  #close device if necessary
  if(inherits(out,"list")) dev.off()
  
  return(invisible(1))
  
}

