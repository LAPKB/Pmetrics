c  dopteng6.f                                              3/07/16

c  dopteng6 has the following changes from dopteng5:

c  1. The minimum D-optimal time will now be the minimum observed value
c  time in the supplied patient data file, rather than hard-coded to 
c  be 0. This also required code changes in Subroutine FILRED, when 
c  NOBSER .LT. NVAR. Previously, the observed times were reset without
c  regard to TIM(1), which means it was possible that one or more of
c  the new TIM(.) values could be less than the original TIM(1), which
c  is no longer allowed. Now, the new TIM(.) values are equally spaced
c  between the original min and max obs. values.

c  2. For each of the NACTVE grid points in the NPAG density, ELDERY
c  will be called twice (once with STEP(.) = -.2*START(.), and once
c  with STEP(.) = -.1*START(.). Then the d-optimal design will be 
c  from the call with the highest |MALF|. See DOPT7.EXP for examples
c  which show that this can improve the performance of the program.

c  3. After the regular run, the user will be asked if he would like
c  to have the entire analysis redone after the last observation time
c  in increased by a factor of 1.0001. This is a stability check to
c  see if both runs give essentially the same results.

c  Note that the PC prep program for this engine is DOPT7.FOR.

c----------------------------------------------------------------------

c  dopteng5.f                                              12/02/15

c  dopteng5 has the following changes from dopteng4x.

c  It checks to see if NOBSER .LT. NVAR. If this is not true, then
c  NOBSER is arbitrarily set = NVAR. The reason (see DOPTIMAL3.EXP and
c  11/9/15 notes) is that if NOBSER is less than NVAR, in theory |MALF|
c  is always 0 --> i.e., there is no way to maximize |MALF|.

c  Note that dopteng5.f is the main "engine" module for the PC prep
c  program, DOPT5.FOR.

c-----------------------------------------------------------------------

c  dopteng4x.f                                            10/14/15

c  dopteng4x has the following changes to dopteng4. 

c  1. The initial search is over [0, MAXOBSTIM], rather than
c  [0, 2*MAXOBSTIM].

c. 2. In Subroutine DOPTTIM, any time candidate which is > 
c  MAXOBSTIM is disallowed.

c-----------------------------------------------------------------------


c  dopteng4.f                                              9/02/15

c  dopteng4 has the following changes from dopteng3:

c  1. The 5th and 7th arguments to ELDERY are returned to their
c  original values.

c  2. In the GETSTARTx routines, 1.D-16 is added to all the time 
c  candidates. The reason is that multiple observation times of 0's
c  look like time resets to Subroutine FUNC, and that screws up the
c  logic.

c  3. The results are written out in terms of |MALF|, rather than
c  -|MALF|.

c-----------------------------------------------------------------------

c  dopteng3.f                                              8/11/15

c  dopteng3 is an extension to dopteng2. It allows any no. of 
c  observation times, up to 10.

c-----------------------------------------------------------------------

c  dopteng2.f                                              8/4/15

c  This program is a variation to dopteng1. It adds a extra 
c  pre-processing feature to dopteng1. And it requires the no. of
c  observation times to be exactly 3.

c  The extra feature is to use a direct search over the 3 observation
c  times to find the best initial guesses for the times to be supplied
c  to ELDERY. See code below.

c-----------------------------------------------------------------------

c  dopteng1.f                                              7/31/15

C  THIS PROGRAM CALCULATES THE D-OPTIMAL DESIGN BASED ON THE
C  RESULTS OF AN NPAG RUN (I.E., IT CALCULATES THE D-OPTIMAL DESIGN
C  FOR EACH OF THE NACTIVE GRID PTS IN THE FINAL CYCLE JOINT DENSITY).

C  NOTE THAT A PC PREP PROGRAM, CURRENTLY DOPT2.FOR, PREPARED 4 FILES
C  FOR THIS PROGRAM:

C  1. MODELQZPX.FOR, WHICH IS THE MODEL FILE FROM THE NPAG RUN; THIS
C  FILE HAS BEEN COMPILED INTO THE PROGRAM.

C  2. DENQZPX.DAT, WHICH CONTAINS THE FINAL CYCLE JOINT DENSITY (I.E.,
C   NACTVE GRID PTS. AND ASSOCIATED PROBABILITIES) FROM AN NPAG RUN,
C   AS WELL AS THE FIXED PARAMETER VALUES, IF ANY. THIS FILE WILL BE
C   READ BELOW.

C  3. DATAQZPX.DAT, WHICH CONTAINS IERRMOD, GAMLAM, AND IRAN(.).


C  4. PATQZPX.001, WHICH IS THE FIRST PATIENT DATA FILE IN WORKING COPY
C   FORMAT FROM THE NPAG RUN. THIS WILL BE USED TO GET THE DOSAGE 
C   REGIMEN, THE OBSERVATION TIMES (WHICH WILL BE THE INITIAL GUESSES 
C   FOR THE D-OPTIMAL DESIGN), AND THE ASSAY COEFFICIENTS. THIS FILE
C   WILL BE OPENED BELOW. 

C  NOTE THAT BEFORE THIS PROGRAM IS COMPILED AND EXECTUTED, ANY OF THESE
C  4 FILES MAY BE EDITED BY THE USER IF HE WISHES, AS LONG AS THEY ARE 
C  STILL IN THE PROPER FORMAT, AND REMAIN CONSISTENT AMONG THEMSELVES.


C  THE D-OPTIMAL DESIGN IS THE ONE WHICH MINIMIZES - |MALF|, WHERE 
C  MALF = PMAT' * RINV * PMAT, WHERE 

C  ' INDICATES TRANSPOSE;

C  PMAT = NOB x NVAR MATRIX, WITH THE (I,J) ELEMENT = PARTIAL 
C  DERIVATIVE OF THE ITH OBS. IN THE Y MATRIX  W.R.T. THE JTH COORDINATE
C  OF THE PARAMETER VECTOR, AT THE TIME OF THAT OBSERVATION, ASSUMING
C  ALL THE PARAMETERS = THEIR GRID PT. COORDINATES. NOTE THAT THE ITH 
C  VALUE IN Y IS COUNTED "COLUMN-WISE". I.E., THE ORDERING OF THE 

C  NOB VALUES IN Y IS: (1,1),(2,1),...,(NOBSER,1), (1,2), (2,2),
C  ...,(NOBSER,2), ... (1,NUMEQT),(2,NUMEQT),...,(NOBSER,NUMEQT);

C  RINV = NOB x NOB DIAGONAL MATRIX WITH 1/S(I)**2 AS THE 
C  (I,I) ELEMENT, WHERE S(I) IS THE SIG(.,.) ELEMENT WHICH 

C  CORRESPONDS TO THE ITH VALUE IN Y (SEE ABOVE DEFN. OF PMAT). NOTE 
C  THAT EACH SIG() IS CALCULATED AS 
C  SIG(I,IEQ) = C0(IEQ)+C1(IEQ)*Y+C2(IEQ)*Y*Y+C3(IEQ)*Y**3, WHERE 
C  Y = Y(I,IEQ) IS THE PREDICTED VALUE AT TIME I FOR EQ. IEQ.

C  AFTER CALCULATING THE D-OPTIMAL DESIGN FOR EACH OF THE NACTVE GRID
C  PTS. IN THE FINAL CYCLE JOINT DENSITY, THIS PROGRAM WILL THEN GIVE 
C  THE WEIGHTED D-OPTIMAL DESIGN OVER ALL NACTVE GRID PTS, EACH WEIGHTED
C  BY TO ITS ASSOCIATED PROBABILITY.

C  NOTE THAT THERE IS NO REFERENCE TO MISSING VALUES SINCE RINV WILL BE 
C  BASED ON THE PREDICTED VALUES, NOT THE OBSERVED VALUES AND THERE IS 
C  NO REASON NOT TO PREDICT ALL VALUES FOR ALL OUTPUT EQS.

C  NOTE THAT SUBROUTINE NEWWORK1 WILL BE USED TO CONVERT THE 
C  PATIENT DATA FILE IN PATQZPX.001 TO THE PROPER FORMAT IF IT
C  HAS STEADY STATE DOSES ... BUT STEADY STATE DOSES THEMSELVES MAY
C  NOT BE COMPATIBLE WITH THIS PROGRAM.

C  NOTE THAT THIS PROGRAM WILL BE COMPILED WITH idm222x15.f,  
C  idm11x16.f, AND vodtot.f, SINCE SUBROUTINE DOPTTIM CALLS EVAL, 
C  WHICH CALLS FUNC1, WHICH CALLS USERANAL, WHICH CALLS DVODE ...
C  AND shift9.f.


C-----------------------------------------------------------------------

        IMPLICIT REAL*8(A-H,O-Z)


      PARAMETER(MAXNUMEQ=7,MAXGRD=1500)
      DIMENSION CORDEN(MAXGRD,31),TIM(594),START(594),STEP(594),
     1 YO(594,MAXNUMEQ),VALFIX(20),THETA(30),IRAN(32),ATOL(20),
     2 C0(MAXNUMEQ),C1(MAXNUMEQ),C2(MAXNUMEQ),C3(MAXNUMEQ),OPTTIM1(594),
     3 DOPTDES(594),TIMCAN(3),START1(594),OPTTIM2(594)

C  NOTE THAT ALL DIMENSIONS OF NUMEQT HAVE BEEN CHANGED TO MAXNUMEQ
C  IN THIS PROGRAM.

      CHARACTER NAME*4,ERRFIL*20,OUTFIL*20

      COMMON/CNST/ N,ND,NI,NUP,NUIC,NP
      COMMON/TOUSER/NDIM,MF,RTOL,ATOL
      COMMON/TODOPT/VALFIX,THETA,GAMLAM,C0,C1,C2,C3,
     1 IRAN,NOFIX,NUMEQT,NVAR,IERRMOD,OBSMAXTIM,OBSMINTIM


      COMMON/TOGETSTART/OBSMAXT,OBSMINT,PERCENT

      COMMON/ERR/ERRFIL 

      EXTERNAL DOPTTIM

C  COMMON/CNST/ IS USED TO OBTAIN N FROM THE CALL TO SUBROUTINE
C   SYMBOL BELOW. THEN NDIM WILL BE SET = N, AND SUPPLIED TO
C   SUBROUTINE USERANAL BY COMMON/TOUSER.
C  COMMON/TODOPT/ IS SUPPLIED TO SUBROUTINE DOPTIM.
C  COMMON/TOUSER IS SUPPLIED TO SUBROUTINE USERANAL.
C  COMMON/ERR/ IS SUPPLIED TO ALL THE ROUTINES WHICH COULD WRITE TO
C   ERRFIL.
C  COMMON/TOGETSTART IS PROVIDED TO THE GETSTART_ ROUTINES.

C-----------------------------------------------------------------------

C  READ IN THE VALUES FROM DENQZPX.DAT

      OPEN(21,FILE='DENQZPX.DAT')

       READ(21,*) NVAR
       READ(21,*) NACTVE
       DO I = 1,NACTVE
        READ(21,*) (CORDEN(I,J),J=1,NVAR+1)
       END DO


       READ(21,*) NOFIX

       IF(NOFIX .GT. 0) THEN
        DO I = 1,NOFIX
         READ(21,*) VALFIX(I)
        END DO
       ENDIF

       CLOSE(21)

C-----------------------------------------------------------------------


C  READ IN THE VALUES FROM DATAQZPX.DAT

      OPEN(21,FILE='DATAQZPX.DAT')
       READ(21,*) RTOL
       READ(21,*) IERRMOD,GAMLAM
       DO I = 1,NVAR+NOFIX
        READ(21,*) IRAN(I)
       END DO
      CLOSE(21)

C  SET ATOL(.) = RTOL. NOTE THAT NDIM IS NOT NECESSARY HERE; JUST
C  SET ALL 20 POSSIBLE ENTRIES OF ATOL TO RTOL. THEN SET MF = 22,
C  THE HARDCODED VALUE USED IN NPAG.
     
      DO I = 1,20
       ATOL(I) = RTOL
      END DO

      MF = 22

C-----------------------------------------------------------------------

C  OPEN FILE PATQZPX.001 AS FILE 23. THEN CALL SUBROUTINE NEWWORK1
C  WHICH WILL WRITE THIS SAME FILE TO FILE 27, BUT MODIFIED TO 
C  ACCOMODATE ANY STEADY STATE DOSE SETS.

C  NOTE THAT THIS PATIENT FILE IS (UNLESS CHANGED BY THE USER DURING
C  THE PC PREP PROGRAM (DOPT2.FOR OR A SUBSEQUENT PROGRAM), WAS
C  COPIED FROM THE OUTPUT FILE OF AN NPAG RUN, AND THEREFORE ALREADY

C  HAS HAD ITS BOLUS INPUTS MULTIPLIED BY THE APPLCIABLE ACTIVE
C  FRACTIONS (AF(I),I=1,NDRUG).


      OPEN(27)

      OPEN(23,FILE='PATQZPX.001')
       CALL NEWWORK1(1)
      CLOSE(23)

      REWIND(27)


c  Read 'extnum2' to get the 4 digit job number which will be used for
c  each of the files produced by this program. Read this integer now,
c  and replace the value by 1 greater (unless it is 9999, in which case
c  replace it by 1) and then close extnum.


C  OPEN FILE extnum2 AND READ THE NO. THERE.

	OPEN(25,FILE='extnum',STATUS='OLD')
	READ(25,*) INUM

C  OBTAIN THE CHARACTER*4 EQUIVALENT TO INUM.

	CALL EQUIV(INUM,NAME)

C  REPLACE THE NO. IN 'extnum2' BY INUM+1 (EXCEPT INUM=9999 IS
C  TO BE REPLACED BY 1).

	JNUM=INUM+1
	IF(JNUM .EQ. 10000) JNUM=1
	BACKSPACE(25)
	WRITE(25,*) JNUM
	CLOSE(25)


C  CREATE OUTPUT FILE WHICH HAS 'OUTDOPT' AS ITS 1ST 4 CHARACTERS AND
C  NAME AS ITS LAST 4. SIMILARLY CREATE ERRFIL.

	OUTFIL = 'OUTDOPT'//NAME
	OPEN(25,FILE=OUTFIL)


      ERRFIL = 'ERROR'//NAME

C  CALL SUBROUTINE SYMBOL TO GET N WHICH IS SUPPLIED IN COMMON/CNST.
C  THEN SET NDIM = N (NDIM IS NEEDED TO BE PASSED IN COMMON/TOUSER
C  TO SUBROUTINE USERANAL.

      CALL SYMBOL
      NDIM = N


C  CALL SUBROUTINE FILRED TO PUT THE SUBJECT'S INFO INTO THE ARRAYS
C  WHICH ARE PASSED TO THE ID MODULES, ETC.

	CALL FILRED(NVAR,NOBSER,NOBSERORIG,YO,C0,C1,C2,C3,NUMEQT,TIM)

      CLOSE(27)

C  NOTE THAT IN SUBROUTINE FILRED, IF NOBSER WAS .LT. NVAR, IT WAS
C  RESET TO BE = NVAR, AND IN THIS CASE NOBSERORIG WAS SET = THE
C  ORIGINAL VALUE OF NOBSER (SEE THE REASON AT THE TOP OF dopteng5.f
C  CODE). IN THIS CASE, A NOTE WILL BE ADDED TO THE TOP OF THE
C  OUTDOPTxxxx FILE (INDICATING THAT THE D-OPTIMAL DESIGN WAS BASED
C  ON NVAR OBS. TIMES, NOT NOBSER OBS. TIMES).


C  NOTE THAT THE PROBABILITIES IN CORDEN(.,NVAR+1), AS READ IN FROM
C  FILE DENQZPX.DAT, ARE NOT NORMALIZED. SO NORMALIZE THEM NOW SO THAT
C  THEY SUM TO 1.0

      SUM = 0.D0
      DO IACT = 1,NACTVE
       SUM = SUM + CORDEN(IACT,NVAR+1)
      END DO

      DO IACT = 1,NACTVE
       CORDEN(IACT,NVAR+1) = CORDEN(IACT,NVAR+1)/SUM
      END DO


C  THIS PROGRAM ALLOWS UP TO NOBSER = 10 OBS. TIMES. VERIFY THE INPUT
C  PATIENT DATA FILE, HAS NO MORE THAN THAT. 

      IF(NOBSER .GT. 10) THEN
       WRITE(*,106)
  106  FORMAT(/' THIS PROGRAM ALLOWS UP TO 10 OBS. TIMES. YOUR '/
     1' PATIENT FILE, PATQZPX.001, HAS ',I3,' OBS. TIMES. '//
     2' THE PROGRAM STOPS.'/)
       STOP
      ENDIF


C  OBTAIN THE INITIAL TIME GUESSES TO BE SUPPLIED TO ELDERY FROM
C  A DIRECT SEARCH AS FOLLOWS:

C  AS OF dopteng6.f, THE MAX VALUE IN THIS SEARCH IS TIM(NOBSER), AND
C  THE MIN VALUE IN THIS SEARCH IS TIM(1). SO DIVIDE THE INTERVAL
C  FROM TIM(1) TO TIM(NOBSER) INTO 10 GRID PTS., EVENLY SPACED. THEN DO
C  A DIRECT SEARCH OVER THE 10^NOBSER COMBINATIONS OF TIMES FOR 
C  [t1, t2, ..., tNOBSER], TO SEE WHICH ONE GIVES THE LARGEST |MALF| 
C  (SEE DEFN. BELOW). THIS SET WILL THEN BE THE INITIAL GUESSES FOR 
C  SUBROUTINE ELDERY. ACTUALLY, THERE WON'T BE 10^NOBSER CALCULATIONS 
C  SINCE THE RESTRICTION t1 .LE. t2 .LE. ... .LE. tNOBSER MEANS THE
C  NO. OF COMBINATIONS WILL BE ABOUT 10^NOBSER/(2 * (NOBSER-1)).

C  NOTE THAT FNTVAL RETURNING FROM DOPTTIM IS -|MALF|, SO -FNTVAL IS


C  THE VALUE FOR |MALF| FOR EACH CALL.

C  THE RANDOM VARIABLES TO BE USED IN GETTING THE INITIAL TIME GUESSES
C  FOR ELDERY WILL BE THE EXPECTED VALUES OVER ALL NACTVE GRID POINTS
C  READ IN ABOVE. STORE THESE RANDOM VARIABLE VALUES INTO THETA. THESE 
C  WILL BE PASSED TO SUBROUTINE DOPTIM BY COMMON/TODOPT.

       DO J = 1,NVAR
        THETA(J) = 0.D0
         DO IACT = 1,NACTVE
          THETA(J) = THETA(J) + CORDEN(IACT,NVAR+1)*CORDEN(IACT,J)
         END DO
       END DO


C  INITIALIZE PERCENT = 0.

      PERCENT = 0.D0


C  INITIALIZE BIGMALF = -1.D60; IT WILL BE THE RUNNING VALUE OF THE 
C  LARGEST |MALF| ACHIEVED DURING THE FOLLOWING LOOPS. AT THE END OF
C  THE FOLLOWING LOOPS, BIGMALF WILL BE THE BIGGEST VALUE OF |MALF| 
C  ACHIEVED, AND START(1:NOBSER) WILL CONTAIN THE NOBSER TIMES, 
C  [t1, t2, ..., tNOBSER] WHICH RESULTED IN THIS BIGMALF VALUE.

      BIGMALF = -1.D60
      DELTIM = (TIM(NOBSER) - TIM(1)) /10.D0

C  NOTE THAT IN SUBROUTINE DOPTTIM, CALLED BY ELDERY, ANY TIME 
C  CANDIDATE MUST BE INSIDE [TIM(1), TIM(NOBSER)]. SO, SET
C  OBSMAXTIM = TIM(NOBSER) AND OBSMINTIM = TIM(1); THESE VALUES
C  WILL BE PASSED IN COMMON TO DOPTTIM. THEY WILL ALSO BE PASSED
C  TO ALL GETSTART_ ROUTINES AS OBSMAXT AND OBSMINT, RESPECTIVELY.

      OBSMAXTIM = TIM(NOBSER)
      OBSMINTIM = TIM(1)
      OBSMAXT = OBSMAXTIM
      OBSMINT = OBSMINTIM

   

C  CHANGED THE DENOMINATOR ABOVE TO 10.D0 FROM 100.D0, AND THIS
C  THEN REQUIRES CHANGING ALL THE 101's IN THE GETSTARTx ROUTINES
C  BELOW TO 11'S.


      IF(NOBSER .EQ. 1) CALL GETSTART1(DELTIM,START,BIGMALF)
      IF(NOBSER .EQ. 2) CALL GETSTART2(DELTIM,START,BIGMALF)
      IF(NOBSER .EQ. 3) CALL GETSTART3(DELTIM,START,BIGMALF)
      IF(NOBSER .EQ. 4) CALL GETSTART4(DELTIM,START,BIGMALF)
      IF(NOBSER .EQ. 5) CALL GETSTART5(DELTIM,START,BIGMALF)
      IF(NOBSER .EQ. 6) CALL GETSTART6(DELTIM,START,BIGMALF)
      IF(NOBSER .EQ. 7) CALL GETSTART7(DELTIM,START,BIGMALF)
      IF(NOBSER .EQ. 8) CALL GETSTART8(DELTIM,START,BIGMALF)
      IF(NOBSER .EQ. 9) CALL GETSTART9(DELTIM,START,BIGMALF)
      IF(NOBSER .EQ. 10) CALL GETSTART10(DELTIM,START,BIGMALF)



C  THE STARTING GUESSES FOR THE D-OPTIMAL DESIGN ARE NOW IN 
C  START(IOBS),IOBS = 1,NOBSER. BUT NOTE THAT IF A START TIME = 0, 
C  SUBROUTINE ELDERY WILL NOT WORK PROPERY (SINCE THE STEP SIZE TO A 
C  NEW CANDIDATE IS A MULTIPLE OF START(.)). SO IN THIS CASE, SET 
C  START(.) = 1.D-8.


      DO IOBS = 1,NOBSER
       IF(START(IOBS) .LE. 0.D0) START(IOBS) = 1.D-8
      END DO

C  AS OF dopteng6.f, STORE THE START TIMES INTO START1(.); THEY WILL
C  BE NEEDED FOR TWO CALLS TO ELDERY. SEE BELOW.

       DO I = 1,NOBSER
        START1(I) = START(I) 
       END DO


C  IF NOBSER .GT. NOBSERORIG, IT MEANS THAT THE NO. OF OBSERVED VALUES
C  WAS ORIGINALLY .LT. NVAR, BUT WAS INCREASED TO BE NVAR (SEE THE
C  REASON AT THE TOP OF dopteng5.f CODE). IN THIS CASE WRITE A NOTE TO
C  THE OUTPUT FILE.

      IF(NOBSER .GT. NOBSERORIG)  WRITE(25,1011) NOBSERORIG,NOBSER
 1011  FORMAT(/' IN PATQZPX.001, THE NO. OF OBSERVED VALUES IS ',I2/
     1' WHICH IS LESS THAN THE NO. OF RANDOM VARIABLES IN THE MODEL'/
     2' FILE, MODELQZPX.FOR. IN THEORY, |MALF| WILL ALWAYS BE 0 IN '/
     3' THIS SITUATION. SO, THE NO. OF OBSERVED VALUES HAS BEEN RESET'/
     4' TO BE EQUAL TO THE NO. OF RANDOM VARIABLES = ',I2/)


      WRITE(25,439) BIGMALF 
  439 FORMAT(/' FROM THE DIRECT SEARCH PREPROCESSING, THE HIGHEST '/
     1' VALUE FOR |MALF| WAS ',G20.6//
     2' WHICH RESULTED FOR STARTING TIME GUESSES FOR THE D-OPTIMAL'/
     3' DESIGN OF (NOTE THAT ANY ZEROES HAVE BEEN CHANGED TO 1.D-8):')
      DO IOBS = 1,NOBSER
       WRITE(25,*) START(IOBS)
      END DO


C  ZERO OUT DOPTDES(.). IT WILL GIVE THE WEIGHTED D-OPTIMAL DESIGN
C  OVER ALL THE NACTVE GRID PTS. AT THE END OF THE DO IACT = 1,NACTVE
C  LOOP. SIMILARLY, ZERO OUT DVALMIN, WHICH WILL GIVE THE WEIGHTED
C  D-OPTIMAL DESIGN MINIMUM ACHIEVED OBJECTIVE FUNCTION, -|MALF|.

      DO IOBS = 1, NOBSER
       DOPTDES(IOBS) = 0.D0
      END DO

      DVALMIN = 0.D0


      DO IACT = 1,NACTVE

C  STORE THE RANDOM VARIABLE VALUES INTO THETA. THESE WILL BE PASSED
C  TO SUBROUTINE DOPTIM BY COMMON/TODOPT.

       DO J=1,NVAR
        THETA(J) = CORDEN(IACT,J)
       END DO

C  FOR THIS GRID PT., FIND THE D-OPTIMAL DESIGN. IT IS THE SET OF
C  TIMES WHICH MINIMIZE -|MALF|, WHERE MALF IS THE FISHER INFORMATION
C  MATRIX = PMAT'*RINV*PMAT, WHERE:

C	' INDICATES TRANSPOSE;

C     NOBACT BELOW = NOBSER x NUMEQT.

C	PMAT = NOBACT x NVAR MATRIX, WITH THE (I,J) ELEMENT = PARTIAL 
C	DERIVATIVE OF THE ITH VALUE IN THE YO MATRIX  W.R.T. 
C	THE JTH COORDINATE OF THE PARAMETER VECTOR, AT THE TIME OF THAT
C	OBSERVATION IN YO, ASSUMING ALL THE PARAMETERS = THEIR ESTIMATED 
C     VALUES IN THETA. NOTE THAT THE ITH VALUE IN YO IS COUNTED 
C     "COLUMN-WISE". I.E., THE ORDERING OF THE NOBACT VALUES IN YO IS:
C	(1,1),(2,1),...,(NOBSER,1), (1,2),(2,2),...,(NOBSER,2), ...
C	(1,NUMEQT),(2,NUMEQT),...,(NOBSER,NUMEQT);

C 	RINV = NOBACT x NOBACT DIAGONAL MATRIX WITH 1/S(I)**2 AS THE 
C	(I,I) ELEMENT, WHERE S(I) IS THE SIG(.,.) ELEMENT WHICH 
C	CORRESPONDS TO THE ITH VALUE IN YO (SEE ABOVE DEFN. 
C	OF PMAT). 


C  AS OF dopteng6.f, ELDERY WILL BE CALLED TWICE, ONCE WITH
C  STEP(I)= -.2D0*START(I), AND ONCE WITH STEP(I)= -.1D0*START(I),
C  AND THEN THE TIMES WITH THE HIGHEST |MALF| WILL BE DESIGNATED
C  THE D-OPTIMAL TIMES.



C  PREPARE TO CALL ELDERY, THE 1ST TIME WITH STEP(.) = -.2*START(.).

C  THE INITIAL ESTIMATES FOR OPTTIM(I), I=1,NOBSER, IS THE SET
C  OF OBSERVATION TIMES IN START, AS ESTABLISHED ABOVE. 

       DO I = 1,NOBSER 
        STEP(I)= -.2D0*START1(I)
       END DO

C???DEBUG. CHANGE THE 5TH ARGUMENT FROM 1.D-10 TO 1.D-30; AND THE
C  7TH ARGUMENT FROM 1000 TO 100,000.
C  NO! AS OF dopteng4.f, change these arguments back as they were.
	
      CALL ELDERY(NOBSER,START,OPTTIM1,VALMIN1,1.D-10,STEP,1000,DOPTTIM,
     1  0,ICONV1,NITER,ICNT)

C  OPTTIM1 = THE SET OF TIMES FOR THIS GRID PT. IT GIVES THE D-OPTIMAL
C            DESIGN (SEE ABOVE). 

C  VALMIN1 = MIN. VALUE OF FUNCTION ACHIEVED, I.E., THE MINIMUM VALUE
C           FOR -|MALF|.

C  ICONV1 = 1 IF MAX-LIK ESTIMATE CONVERGED; 0 OTHERWISE.


C  PREPARE TO CALL ELDERY, THE 2ND TIME WITH STEP(.) = -.1*START(.).

C  THE INITIAL ESTIMATES FOR OPTTIM(I), I=1,NOBSER, IS THE SET
C  OF OBSERVATION TIMES IN START, AS ESTABLISHED ABOVE. 

       DO I = 1,NOBSER 
        STEP(I)= -.1D0*START1(I)
       END DO

C???DEBUG. CHANGE THE 5TH ARGUMENT FROM 1.D-10 TO 1.D-30; AND THE
C  7TH ARGUMENT FROM 1000 TO 100,000.
C  NO! AS OF dopteng4.f, change these arguments back as they were.
	
      CALL ELDERY(NOBSER,START,OPTTIM2,VALMIN2,1.D-10,STEP,1000,DOPTTIM,
     1  0,ICONV2,NITER,ICNT)

C  OPTTIM2 = THE SET OF TIMES FOR THIS GRID PT. IT GIVES THE D-OPTIMAL
C            DESIGN (SEE ABOVE). 

C  VALMIN2 = MIN. VALUE OF FUNCTION ACHIEVED, I.E., THE MINIMUM VALUE
C           FOR -|MALF|.

C  ICONV2 = 1 IF MAX-LIK ESTIMATE CONVERGED; 0 OTHERWISE.

     
       IF(ICONV1 .EQ. 0 .AND. ICOVN2 .EQ. 0) WRITE(25,9011) IACT
 9011 FORMAT(//' NO D-OPTIMAL TIMES FOR GRID PT. ',I5)

C  IF ICONV1 = 0 AND ICONV2 .NE. 0, VERIFY THAT THE CALL WITH
C  ICONV2 DID BETTER IN TERMS OF VALMIN. IF NOT, WRITE A COMMENT
C  IN THE OUTPUT FILE. AND VICE-VERSA.

       IF(ICONV1 .EQ. 0 .AND. ICONV2 .NE. 0) THEN
        IF(-VALMIN1 .GT. -VALMIN2) WRITE(25,274) IACT
  274   FORMAT(//' FOR GRID PT. ',I5,' THE CALL TO THE NELDER MEAD'/
     1' ALGORITHM WITH STEP(.) = -.2*START(.) DID NOT CONVERGE, AND '/
     2' YET THE MAX |MALF| FROM THIS CALL WAS BETTER (LARGER) THAN'/
     3' THE MAX |MALF| FROM THE CALL WITH STEP(.) = -.1*START(.), '/
     4' WHICH DID CONVERGE. '//
     5' THIS IS ODD AND SUGGESTS THERE IS SOMETHING WRONG WITH THIS'/
     6' RUN. IT IS RECOMMENDED THAT YOU RE-EXAMINE ALL FILES.'/)
       ENDIF

       IF(ICONV2 .EQ. 0 .AND. ICONV1 .NE. 0) THEN
        IF(-VALMIN2 .GT. -VALMIN1) WRITE(25,276) IACT
  276   FORMAT(//' FOR GRID PT. ',I5,' THE CALL TO THE NELDER MEAD'/
     1' ALGORITHM WITH STEP(.) = -.1*START(.) DID NOT CONVERGE, AND '/
     2' YET THE MAX |MALF| FROM THIS CALL WAS BETTER (LARGER) THAN'/
     3' THE MAX |MALF| FROM THE CALL WITH STEP(.) = -.2*START(.), '/
     4' WHICH DID CONVERGE. '//
     5' THIS IS ODD AND SUGGESTS THERE IS SOMETHING WRONG WITH THIS'/
     6' RUN. IT IS RECOMMENDED THAT YOU RE-EXAMINE ALL FILES.'/)
       ENDIF



C  THE D-OPTIMAL TIMES WILL BE THE SET WITH THE HIGHEST |MALF|, 
C  I.E., THE HIGHEST VALUE OF -VALMIN.

      IF(-VALMIN1 .GE. -VALMIN2) THEN
        
       WRITE(25,272) IACT,CORDEN(IACT,NVAR+1),-VALMIN1,NOBSER
  272 FORMAT(//' FOR GRID PT. ',I5,', WITH WEIGHT ',G15.6,' THE MAX. '/
     1' VALUE FOR |MALF| IS ',G24.5,' AND THE ',I3,' D-OTPIMAL'/
     2' DESIGN TIMES ARE: ')

       DO IOBS = 1,NOBSER
        WRITE(25,*) OPTTIM1(IOBS)
        DOPTDES(IOBS) = DOPTDES(IOBS) +OPTTIM1(IOBS)*CORDEN(IACT,NVAR+1)
       END DO 

       DVALMIN = DVALMIN + VALMIN1*CORDEN(IACT,NVAR+1) 

      ENDIF

      IF(-VALMIN1 .LT. -VALMIN2) THEN
        
       WRITE(25,272) IACT,CORDEN(IACT,NVAR+1),-VALMIN2,NOBSER

       DO IOBS = 1,NOBSER
        WRITE(25,*) OPTTIM2(IOBS)
        DOPTDES(IOBS) = DOPTDES(IOBS) +OPTTIM2(IOBS)*CORDEN(IACT,NVAR+1)
       END DO 

       DVALMIN = DVALMIN + VALMIN2*CORDEN(IACT,NVAR+1) 

      ENDIF


      END DO
C  THE ABOVE END DO IS FOR THE  DO IACT = 1,NACTVE  LOOP.

      WRITE(25,273) -DVALMIN,NOBSER
  273 FORMAT(//' THE WEIGHTED MAX. VALUE FOR |MALF| IS ',G24.5//
     1' THE ',I3,' WEIGHTED D-OPTIMAL DESIGN TIMES ARE: ')

      DO IOBS = 1,NOBSER
       WRITE(25,*) DOPTDES(IOBS)
      END DO 

C  SAVE -DVALMIN AND DOPTDES(NOBSER) TO COMPARE WITH THE 2ND 
C  COMPLETE ANALYSIS BELOW, IN CASE THE USER CHOOSES TO RUN IT.

      DVALMINRUN1 = DVALMIN
      DOPTDESRUN1 = DOPTDES(NOBSER)


C //////////////////////////////////////////////////////////////////////

C  2ND COMPLETE ANALYSIS FOR STABILITY CHECK IF THE USER CHOOSES BELOW.


C  AS OF dopteng6.f, ALLOW THE USER TO REDO THE ABOVE ANALYSIS, BUT
C  WITH TIM(NOBSER) INCREASED BY A FACTOR OF 1.0001. THIS IS A TEST
C  OF STABILITY IN THE ANALYSIS. SEE DOPT7.EXP.EXTRA FOR AN EXAMPLE
C  TEST CASE WHERE CHANGING TIM(NOBSER) BY A FACTOR OF MUCH LESS THAN
C  1.0001 CHANGED THE D-OPTIMAL TIMES A LOT!!

   50 WRITE(*,17)
   17 FORMAT(//' ENTER 1 TO END THE ANALYSIS;'/
     2' ENTER 0 TO DO A NUMERICAL STABILITY TEST. THIS CONSISTS OF '/
     3'         REDOING THE ANALYSIS WITH THE LAST OBSERVATION TIME'/
     4'         INCREASED BY A FACTOR OF 1.0001. THEN YOU WILL BE ABLE'/
     5'         TO SEE IN THE OUTPUT FILE WHETHER OR NOT THIS MADE A'/
     6'         NOTICEABLE DIFFERENCE IN THE CALCULATED D-OPT. TIMES: ')
      READ(*,*,ERR=50) IAGAIN
      IF(IAGAIN .NE. 1 .AND. IAGAIN .NE. 0) GO TO 50

      IF(IAGAIN .EQ. 1) GO TO 100

      WRITE(*,*)
      WRITE(*,*)


C  WRITE A COMMENT TO THE OUTPUT FILE. THEN REDO THE ANALYSIS AFTER
C  INCREASING THE MAX. OBS. TIME BY A FACTOR OF 1.0001.

      WRITE(25,117)
  117 FORMAT(///'////////////////////////////////////////////////////'//
     1' THE RESULTS BELOW ARE THE SAME AS ABOVE, EXCEPT THAT THE '/
     2' MAXIMUM OBS. TIME HAS BEEN INCREASED BY A FACTOR OF 1.0001.'//)


      TIM(NOBSER) = TIM(NOBSER)*1.0001


C  THE RANDOM VARIABLES TO BE USED IN GETTING THE INITIAL TIME GUESSES
C  FOR ELDERY WILL BE THE EXPECTED VALUES OVER ALL NACTVE GRID POINTS
C  READ IN ABOVE. STORE THESE RANDOM VARIABLE VALUES INTO THETA. THESE 
C  WILL BE PASSED TO SUBROUTINE DOPTIM BY COMMON/TODOPT.

       DO J = 1,NVAR
        THETA(J) = 0.D0
         DO IACT = 1,NACTVE
          THETA(J) = THETA(J) + CORDEN(IACT,NVAR+1)*CORDEN(IACT,J)
         END DO
       END DO



C  INITIALIZE PERCENT = 0.

      PERCENT = 0.D0

C  INITIALIZE BIGMALF = -1.D60; IT WILL BE THE RUNNING VALUE OF THE 
C  LARGEST |MALF| ACHIEVED DURING THE FOLLOWING LOOPS. AT THE END OF
C  THE FOLLOWING LOOPS, BIGMALF WILL BE THE BIGGEST VALUE OF |MALF| 
C  ACHIEVED, AND START(1:NOBSER) WILL CONTAIN THE NOBSER TIMES, 
C  [t1, t2, ..., tNOBSER] WHICH RESULTED IN THIS BIGMALF VALUE.

      BIGMALF = -1.D60
      DELTIM = (TIM(NOBSER) - TIM(1)) /10.D0

C  NOTE THAT IN SUBROUTINE DOPTTIM, CALLED BY ELDERY, ANY TIME 
C  CANDIDATE MUST BE INSIDE [TIM(1), TIM(NOBSER)]. SO, SET
C  OBSMAXTIM = TIM(NOBSER) AND OBSMINTIM = TIM(1); THESE VALUES
C  WILL BE PASSED IN COMMON TO DOPTTIM. THEY WILL ALSO BE PASSED
C  TO ALL GETSTART_ ROUTINES AS OBSMAXT AND OBSMINT, RESPECTIVELY.

      OBSMAXTIM = TIM(NOBSER)
      OBSMINTIM = TIM(1)
      OBSMAXT = OBSMAXTIM
      OBSMINT = OBSMINTIM
   

C  CHANGED THE DENOMINATOR ABOVE TO 10.D0 FROM 100.D0, AND THIS
C  THEN REQUIRES CHANGING ALL THE 101's IN THE GETSTARTx ROUTINES
C  BELOW TO 11'S.


      IF(NOBSER .EQ. 1) CALL GETSTART1(DELTIM,START,BIGMALF)
      IF(NOBSER .EQ. 2) CALL GETSTART2(DELTIM,START,BIGMALF)
      IF(NOBSER .EQ. 3) CALL GETSTART3(DELTIM,START,BIGMALF)
      IF(NOBSER .EQ. 4) CALL GETSTART4(DELTIM,START,BIGMALF)
      IF(NOBSER .EQ. 5) CALL GETSTART5(DELTIM,START,BIGMALF)
      IF(NOBSER .EQ. 6) CALL GETSTART6(DELTIM,START,BIGMALF)
      IF(NOBSER .EQ. 7) CALL GETSTART7(DELTIM,START,BIGMALF)
      IF(NOBSER .EQ. 8) CALL GETSTART8(DELTIM,START,BIGMALF)
      IF(NOBSER .EQ. 9) CALL GETSTART9(DELTIM,START,BIGMALF)
      IF(NOBSER .EQ. 10) CALL GETSTART10(DELTIM,START,BIGMALF)



C  THE STARTING GUESSES FOR THE D-OPTIMAL DESIGN ARE NOW IN 
C  START(IOBS),IOBS = 1,NOBSER. BUT NOTE THAT IF A START TIME = 0, 
C  SUBROUTINE ELDERY WILL NOT WORK PROPERY (SINCE THE STEP SIZE TO A 
C  NEW CANDIDATE IS A MULTIPLE OF START(.)). SO IN THIS CASE, SET 
C  START(.) = 1.D-8.


      DO IOBS = 1,NOBSER
       IF(START(IOBS) .LE. 0.D0) START(IOBS) = 1.D-8
      END DO

C  AS OF dopteng6.f, STORE THE START TIMES INTO START1(.); THEY WILL
C  BE NEEDED FOR TWO CALLS TO ELDERY. SEE BELOW.

       DO I = 1,NOBSER
        START1(I) = START(I) 
       END DO


C  IF NOBSER .GT. NOBSERORIG, IT MEANS THAT THE NO. OF OBSERVED VALUES
C  WAS ORIGINALLY .LT. NVAR, BUT WAS INCREASED TO BE NVAR (SEE THE
C  REASON AT THE TOP OF dopteng5.f CODE). IN THIS CASE WRITE A NOTE TO
C  THE OUTPUT FILE.

      IF(NOBSER .GT. NOBSERORIG)  WRITE(25,1011) NOBSERORIG,NOBSER

      WRITE(25,439) BIGMALF 
      DO IOBS = 1,NOBSER
       WRITE(25,*) START(IOBS)
      END DO


C  ZERO OUT DOPTDES(.). IT WILL GIVE THE WEIGHTED D-OPTIMAL DESIGN
C  OVER ALL THE NACTVE GRID PTS. AT THE END OF THE DO IACT = 1,NACTVE
C  LOOP. SIMILARLY, ZERO OUT DVALMIN, WHICH WILL GIVE THE WEIGHTED
C  D-OPTIMAL DESIGN MINIMUM ACHIEVED OBJECTIVE FUNCTION, -|MALF|.

      DO IOBS = 1, NOBSER
       DOPTDES(IOBS) = 0.D0
      END DO

      DVALMIN = 0.D0


      DO IACT = 1,NACTVE

C  STORE THE RANDOM VARIABLE VALUES INTO THETA. THESE WILL BE PASSED
C  TO SUBROUTINE DOPTIM BY COMMON/TODOPT.

       DO J=1,NVAR
        THETA(J) = CORDEN(IACT,J)
       END DO

C  FOR THIS GRID PT., FIND THE D-OPTIMAL DESIGN. IT IS THE SET OF
C  TIMES WHICH MINIMIZE -|MALF|, WHERE MALF IS THE FISHER INFORMATION
C  MATRIX = PMAT'*RINV*PMAT, WHERE:

C	' INDICATES TRANSPOSE;

C     NOBACT BELOW = NOBSER x NUMEQT.

C	PMAT = NOBACT x NVAR MATRIX, WITH THE (I,J) ELEMENT = PARTIAL 
C	DERIVATIVE OF THE ITH VALUE IN THE YO MATRIX  W.R.T. 
C	THE JTH COORDINATE OF THE PARAMETER VECTOR, AT THE TIME OF THAT
C	OBSERVATION IN YO, ASSUMING ALL THE PARAMETERS = THEIR ESTIMATED 
C     VALUES IN THETA. NOTE THAT THE ITH VALUE IN YO IS COUNTED 
C     "COLUMN-WISE". I.E., THE ORDERING OF THE NOBACT VALUES IN YO IS:
C	(1,1),(2,1),...,(NOBSER,1), (1,2),(2,2),...,(NOBSER,2), ...
C	(1,NUMEQT),(2,NUMEQT),...,(NOBSER,NUMEQT);

C 	RINV = NOBACT x NOBACT DIAGONAL MATRIX WITH 1/S(I)**2 AS THE 
C	(I,I) ELEMENT, WHERE S(I) IS THE SIG(.,.) ELEMENT WHICH 
C	CORRESPONDS TO THE ITH VALUE IN YO (SEE ABOVE DEFN. 
C	OF PMAT). 


C  AS OF dopteng6.f, ELDERY WILL BE CALLED TWICE, ONCE WITH
C  STEP(I)= -.2D0*START(I), AND ONCE WITH STEP(I)= -.1D0*START(I),
C  AND THEN THE TIMES WITH THE HIGHEST |MALF| WILL BE DESIGNATED
C  THE D-OPTIMAL TIMES.



C  PREPARE TO CALL ELDERY, THE 1ST TIME WITH STEP(.) = -.2*START(.).

C  THE INITIAL ESTIMATES FOR OPTTIM(I), I=1,NOBSER, IS THE SET
C  OF OBSERVATION TIMES IN START, AS ESTABLISHED ABOVE. 

       DO I = 1,NOBSER 
        STEP(I)= -.2D0*START1(I)
       END DO

C???DEBUG. CHANGE THE 5TH ARGUMENT FROM 1.D-10 TO 1.D-30; AND THE
C  7TH ARGUMENT FROM 1000 TO 100,000.
C  NO! AS OF dopteng4.f, change these arguments back as they were.
	
      CALL ELDERY(NOBSER,START,OPTTIM1,VALMIN1,1.D-10,STEP,1000,DOPTTIM,
     1  0,ICONV1,NITER,ICNT)

C  OPTTIM1 = THE SET OF TIMES FOR THIS GRID PT. IT GIVES THE D-OPTIMAL
C            DESIGN (SEE ABOVE). 

C  VALMIN1 = MIN. VALUE OF FUNCTION ACHIEVED, I.E., THE MINIMUM VALUE
C           FOR -|MALF|.

C  ICONV1 = 1 IF MAX-LIK ESTIMATE CONVERGED; 0 OTHERWISE.


C  PREPARE TO CALL ELDERY, THE 2ND TIME WITH STEP(.) = -.1*START(.).

C  THE INITIAL ESTIMATES FOR OPTTIM(I), I=1,NOBSER, IS THE SET
C  OF OBSERVATION TIMES IN START, AS ESTABLISHED ABOVE. 

       DO I = 1,NOBSER 
        STEP(I)= -.1D0*START1(I)
       END DO

C???DEBUG. CHANGE THE 5TH ARGUMENT FROM 1.D-10 TO 1.D-30; AND THE
C  7TH ARGUMENT FROM 1000 TO 100,000.
C  NO! AS OF dopteng4.f, change these arguments back as they were.
	
      CALL ELDERY(NOBSER,START,OPTTIM2,VALMIN2,1.D-10,STEP,1000,DOPTTIM,
     1  0,ICONV2,NITER,ICNT)

C  OPTTIM2 = THE SET OF TIMES FOR THIS GRID PT. IT GIVES THE D-OPTIMAL
C            DESIGN (SEE ABOVE). 

C  VALMIN2 = MIN. VALUE OF FUNCTION ACHIEVED, I.E., THE MINIMUM VALUE
C           FOR -|MALF|.

C  ICONV2 = 1 IF MAX-LIK ESTIMATE CONVERGED; 0 OTHERWISE.

     
       IF(ICONV1 .EQ. 0 .AND. ICOVN2 .EQ. 0) WRITE(25,9011) IACT

C  IF ICONV1 = 0 AND ICONV2 .NE. 0, VERIFY THAT THE CALL WITH
C  ICONV2 DID BETTER IN TERMS OF VALMIN. IF NOT, WRITE A COMMENT
C  IN THE OUTPUT FILE. AND VICE-VERSA.

       IF(ICONV1 .EQ. 0 .AND. ICONV2 .NE. 0) THEN
        IF(-VALMIN1 .GT. -VALMIN2) WRITE(25,274) IACT
       ENDIF

       IF(ICONV2 .EQ. 0 .AND. ICONV1 .NE. 0) THEN
        IF(-VALMIN2 .GT. -VALMIN1) WRITE(25,276) IACT
       ENDIF



C  THE D-OPTIMAL TIMES WILL BE THE SET WITH THE HIGHEST |MALF|, 
C  I.E., THE HIGHEST VALUE OF -VALMIN.

      IF(-VALMIN1 .GE. -VALMIN2) THEN
        
       WRITE(25,272) IACT,CORDEN(IACT,NVAR+1),-VALMIN1,NOBSER

       DO IOBS = 1,NOBSER
        WRITE(25,*) OPTTIM1(IOBS)
        DOPTDES(IOBS) = DOPTDES(IOBS) +OPTTIM1(IOBS)*CORDEN(IACT,NVAR+1)
       END DO 

       DVALMIN = DVALMIN + VALMIN1*CORDEN(IACT,NVAR+1) 

      ENDIF

      IF(-VALMIN1 .LT. -VALMIN2) THEN
        
       WRITE(25,272) IACT,CORDEN(IACT,NVAR+1),-VALMIN2,NOBSER

       DO IOBS = 1,NOBSER
        WRITE(25,*) OPTTIM2(IOBS)
        DOPTDES(IOBS) = DOPTDES(IOBS) +OPTTIM2(IOBS)*CORDEN(IACT,NVAR+1)
       END DO 

       DVALMIN = DVALMIN + VALMIN2*CORDEN(IACT,NVAR+1) 

      ENDIF


      END DO
C  THE ABOVE END DO IS FOR THE  DO IACT = 1,NACTVE  LOOP.

      WRITE(25,273) -DVALMIN,NOBSER

      DO IOBS = 1,NOBSER
       WRITE(25,*) DOPTDES(IOBS)
      END DO 


C  2ND COMPLETE ANALYSIS FOR STABILITY CHECK IF THE USER CHOOSES ABOVE.


C  WRITE A COMMENT TO THE SCREEN AND THE OUTPUT FILE REGARDING A 
C  COMPARISON OF THE WEIGHTED MAX |MALF| AND THE LAST MAX D-OPTIMAL
C  TIME FOR THIS RUN VS. THE ORIGINAL RUN.

      WRITE(25,18) -DVALMINRUN1,-DVALMIN,DOPTDESRUN1,DOPTDES(NOBSER)
      WRITE(*,18) -DVALMINRUN1,-DVALMIN,DOPTDESRUN1,DOPTDES(NOBSER)
   18 FORMAT(///' THE WEIGHTED MAX |MALF| FOR RUN 1 WAS ',G24.10/
     1' THE WEIGHTED MAX |MALF| FOR RUN 2 WAS ',G24.10//
     2' THE LARGEST D-OPTIMAL TIME FOR RUN 1 WAS ',G24.10/
     3' THE LARGEST D-OPTIMAL TIME FOR RUN 2 WAS ',G24.10)

      RATDVAL = DVALMIN/DVALMINRUN1
      RATTIM = DOPTDES(NOBSER)/DOPTDESRUN1

      ICOMP = 1
      IF(RATDVAL .GT. 1.01 .OR. RATDVAL .LT. .99 .OR.
     1 RATTIM .GT. 1.01 .OR. RATTIM .LT. .99) ICOMP = 0

      IF(ICOMP .EQ. 1) WRITE(25,19) NOBSER-1
      IF(ICOMP .EQ. 1) WRITE(*,19) NOBSER-1
   19 FORMAT(//' THESE TWO VALUES IN THE TWO RUNS ARE WITHIN 1% OF  '/
     1' EACH OTHER AND INDICATE AT LEAST SOME STABILITY BETWEEN THE  '/
     2' RUNS. BUT THERE MAY STILL BE NOTICEABLE DIFFERENCES IN THE '/
     3' OTHER ',I2,' D-OPTIMAL TIMES. ')

      IF(ICOMP .EQ. 0) WRITE(25,21) 
      IF(ICOMP .EQ. 0) WRITE(*,21) 
    
   21 FORMAT(//' THERE IS MORE THAN A 1% DIFFERENCE IN AT LEAST ONE '/
     1' OF THESE PAIRS OF VALUES. THESE DIFFERENCES MAY INDICATE THAT'/
     2' THIS ANALYSIS HAS NUMERICAL INSTABILITY PROBLEMS AND/OR THAT '/
     4' THERE IS A WIDE RANGE OF D-OPTIMAL TIMES THAT ARE ESSENTIALLY'/
     5' EQUALLY GOOD.')



C //////////////////////////////////////////////////////////////////////





  100 CLOSE(25)

      WRITE(*,22) OUTFIL
   22 FORMAT(//' SEE THE RESULTS IN ',A20)



        STOP
        END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
        SUBROUTINE ELDERY(N,START,XMIN,YNEWLO,REQMIN,STEP,
     X  ITMAX,FUNC,IPRINT,ICONV,NITER,ICOUNT)

C  ELDERY DIFFERS FROM ELDERX ONLY IN THE DIMENSION STATEMENT. ALL 5'S
C  ARE CHANGED TO 25'S, AND ALL 6'S ARE CHANGED TO 26'S. THIS ALLOWS 25
C  PARAMETERS INSTEAD OF JUST 5. As of itbig9x.f, we allow as many as
C  30 parameters.

C  ELDERX DIFFERS FROM ELDER (DESCRIBED BELOW) ONLY IN THAT N, THE
C  DIMENSION OF START (THE NO. OF UNKNOWN PARAMETERS OVER WHICH THE
C  MINIMIZATION IS DONE) IS PASSED TO THE SUBROUTINE FUNC IN THE CALLING
C  STATEMENTS.
C
C  ELDER IS A PROGRAM TO MINIMIZE A FUNCTION USING THE NELDER-MEED
C  ALGORITM.
C    THE CODE WAS ADAPTED FROM A PROG. IN J. OF QUALITY TECHNOLOGY VOL. 
C    JAN. 1974. BY D.M. OLSSON.
C  CALLING ARGUMENTS:
C    N     -NUMBER OF UNKNOWN PARAMS. UP TO 99.
C    START -A VECTOR WITH THE INITIAL QUESSES OF THE SOLUTION PARAMS.
C    ITMAX -THE MAXIMUM NUMBER OF ITERATIONS.
C             (KCOUNT IS THE MAX NUM OF FUNC CALLS.SET AT 1000000)
C    STEP  -THE STEP SIZE VECTOR FOR DEFINING THE N ADDITIONAL 
C             VERTICIES.
C    REQMIN-THE STOP TOLERANCE.

C    XMIN   -THE SOLUTION VECTOR.
C    YNEWLO-THE FUCTION VALUE AT XMIN.
C    IPRINT-SWITCH WHICH DETERMINES IF INTERMEDIATE ITERATIONS
C              ARE TO BE PRINTED. (0=NO,1=YES).
C    ICONV -FLAG INDICATING WHETHER OR NOT CONVERGENCE HAS BEEN
C             ACHEIVED. (0=NO,1=YES).
C    NITER -THE NUMBER OF ITERATIONS PERFORMED.
C    ICOUNT-THE NUMBER OF FUNCTION EVALUATIONS.
C    FUNC  -THE NAME OF THE SUBROUTINE DEFINING THE FUNCTION.
C             THIS SUBROUTINE MUST EVALUATE THE FUNCTION GIVEN A
C             VALUE FOR THE PARAMETER VECTOR. THE ROUTINE IS OF
C             THE FOLLOWING FORM:
C               FUNC(P,FV), WHERE P IS THE PARAMETER VECTOR,
C                             AND FV IS THE FUNCTION VALUE.
C  A SUBROUTINE TO PRINT THE RESULTS OF ITERMEDIATE ITERATIONS
C    MUST ALSO BE SUPPLIED. ITS NAME AND CALLING SEQUENCE ARE 
C    DEFINED AS FOLLOWS:
C      PRNOUT(P,N,NITER,NFCALL,FV).
C  OTHER PROGRAM VARIABLES OF INTEREST ARE;
C    XSEC  -THE COORDINATES OF THE VETEX WITH THE 2ND SMALLEST FUNCTION
C             VALUE.
C    YSEC  - THE FUNCTION VALUE AT XSEC.
C
      IMPLICIT REAL*8(A-H,O-Z)
        DIMENSION START(N),STEP(N),XMIN(N),XSEC(30),
     X  P(30,31),PSTAR(30),P2STAR(30),PBAR(30),Y(31)

        EXTERNAL FUNC
        DATA RCOEFF/1.0D0/,ECOEFF/2.0D0/,CCOEFF/.5D0/

        KCOUNT=1000000
        ICOUNT=0
        NITER=0
        ICONV=0
C
C  CHECK INPUT DATA AND RETURN IF AN ERROR IS FOUND.
C
        IF(REQMIN.LE.0.0D0) ICOUNT=ICOUNT-1
        IF(N.LE.0) ICOUNT=ICOUNT-10
        IF(N.GT.99) ICOUNT=ICOUNT-10

       

        IF(ICOUNT.LT.0) RETURN
C
C  SET INITIAL CONSTANTS
C
        DABIT=2.04607D-35
        BIGNUM=1.0D+38
        KONVGE=5
        XN=FLOAT(N)
        DN=FLOAT(N)
        NN=N+1
C
C  CONSTRUCTION OF INITIAL SIMPLEX.
C
1001    DO 1 I=1,N
1       P(I,NN)=START(I)
        CALL FUNC(N,START,FN)
        Y(NN)=FN
        ICOUNT=ICOUNT+1
C       CALL PRNOUT(START,N,NITER,ICOUNT,FN)
        IF(ITMAX.NE.0) GO TO 40
        DO 45 I=1,N
45      XMIN(I)=START(I)
        YNEWLO=FN
        RETURN
40      DO 2 J=1,N
        DCHK=START(J)
        START(J)=DCHK+STEP(J)
        DO 3 I=1,N
3       P(I,J)=START(I)
        CALL FUNC(N,START,FN)
        Y(J)=FN
        ICOUNT=ICOUNT+1
2       START(J)=DCHK
C
C  SIMPLEX CONSTRUCTION COMPLETE.


C
C    FIND THE HIGHEST AND LOWEST VALUES. YNEWLO (Y(IHI)) INDICATES THE
C     VERTEX OF THE SIMPLEX TO BE REPLACED.
C
1000    YLO=Y(1)
        YNEWLO=YLO
        ILO=1
        IHI=1
        DO 5 I=2,NN
        IF(Y(I).GE.YLO) GO TO 4
        YLO=Y(I)
        ILO=I
4       IF(Y(I).LE.YNEWLO) GO TO 5
        YNEWLO=Y(I)
        IHI=I
5       CONTINUE
C
        IF(ICOUNT.LE.NN) YOLDLO=YLO
        IF(ICOUNT.LE.NN) GO TO 2002

        IF(YLO.GE.YOLDLO) GO TO 2002
        YOLDLO=YLO
        NITER=NITER+1
        IF(NITER.GE.ITMAX) GO TO 900
        IF(IPRINT.EQ.0) GO TO 2002
C       CALL PRNOUT(P(1,ILO),N,NITER,ICOUNT,YLO)
C
C  PERFORM CONVERGENCE CHECKS ON FUNCTIONS.
C

2002    DCHK=(YNEWLO+DABIT)/(YLO+DABIT)-1.0D0
        IF(DABS(DCHK).GT. REQMIN) GO TO 2001
        ICONV=1
        GO TO 900
C
2001    KONVGE=KONVGE-1
        IF(KONVGE.NE.0) GO TO 2020
        KONVGE=5
C
C  CHECK CONVERGENCE OF COORDINATES ONLY EVERY 5 SIMPLEXES.
C

        DO 2015 I=1,N
        COORD1=P(I,1)
        COORD2=COORD1
        DO 2010 J=2,NN
        IF(P(I,J).GE.COORD1) GO TO 2005
        COORD1=P(I,J)
2005    IF(P(I,J).LE.COORD2) GO TO 2010
        COORD2=P(I,J)
2010    CONTINUE
        DCHK=(COORD2+DABIT)/(COORD1+DABIT)-1.0D0
        IF(DABS(DCHK).GT.REQMIN) GO TO 2020
2015    CONTINUE
        ICONV=1
        GO TO 900
2020    IF(ICOUNT.GE.KCOUNT) GO TO 900
C
C  CALCULATE PBAR, THE CENTRIOD OF THE SIMPLEX VERTICES EXCEPTING THAT
C   WITH Y VALUE YNEWLO.
C

        DO 7 I=1,N
        Z=0.0D0
        DO 6 J=1,NN
6       Z=Z+P(I,J)
        Z=Z-P(I,IHI)
7       PBAR(I)=Z/DN
C
C  REFLECTION THROUGH THE CENTROID.
C
        DO 8 I=1,N
8       PSTAR(I)=(1.0D0+RCOEFF)*PBAR(I)-RCOEFF*P(I,IHI)
        CALL FUNC(N,PSTAR,FN)
        YSTAR=FN
        ICOUNT=ICOUNT+1
        IF(YSTAR.GE.YLO) GO TO 12
        IF(ICOUNT.GE.KCOUNT) GO TO 19
C
C  SUCESSFUL REFLECTION SO EXTENSION.
C

        DO 9 I=1,N
9       P2STAR(I)=ECOEFF*PSTAR(I)+(1.0D0-ECOEFF)*PBAR(I)
        CALL FUNC(N,P2STAR,FN)
        Y2STAR=FN
        ICOUNT=ICOUNT+1
C
C  RETAIN EXTENSION OR CONTRACTION.
C
        IF(Y2STAR.GE.YSTAR) GO TO 19
10      DO 11 I=1,N

11      P(I,IHI)=P2STAR(I)
        Y(IHI)=Y2STAR
        GO TO 1000
C
C  NO EXTENSION.
C
12      L=0
        DO 13 I=1,NN
        IF(Y(I).GT.YSTAR) L=L+1
13      CONTINUE
        IF(L.GT.1) GO TO 19
        IF(L.EQ.0) GO TO 15
C
C  CONTRACTION ON REFLECTION SIDE OF CENTROID.
C
        DO 14 I=1,N
14      P(I,IHI)=PSTAR(I)
        Y(IHI)=YSTAR
C
C  CONTRACTION ON THE Y(IHI) SIDE OF THE CENTROID.
C
15      IF(ICOUNT.GE.KCOUNT) GO TO 900
        DO 16 I=1,N
16      P2STAR(I)=CCOEFF*P(I,IHI)+(1.0D0-CCOEFF)*PBAR(I)
        CALL FUNC(N,P2STAR,FN)
        Y2STAR=FN
        ICOUNT=ICOUNT+1
        IF(Y2STAR.LT.Y(IHI)) GO TO 10
C
C  CONTRACT THE WHOLE SIMPLEX
C
        DO 18 J=1,NN
        DO 17 I=1,N
        P(I,J)=(P(I,J)+P(I,ILO))*0.5D0
17      XMIN(I)=P(I,J)
        CALL FUNC(N,XMIN,FN)
        Y(J)=FN
18      CONTINUE
        ICOUNT=ICOUNT+NN
        IF(ICOUNT.LT.KCOUNT) GO TO 1000
        GO TO 900
C
C  RETAIN REFLECTION.

C
19      CONTINUE
        DO 20 I=1,N
20      P(I,IHI)=PSTAR(I)
        Y(IHI)=YSTAR
        GO TO 1000
C
C  SELECT THE TWO BEST FUNCTION VALUES (YNEWLO AND YSEC) AND THEIR
C    COORDINATES (XMIN AND XSEC)>
C
900     DO 23 J=1,NN
        DO 22 I=1,N
22      XMIN(I)=P(I,J)
        CALL FUNC(N,XMIN,FN)
        Y(J)=FN
23      CONTINUE
        ICOUNT=ICOUNT+NN
        YNEWLO=BIGNUM
        DO 24 J=1,NN
        IF(Y(J).GE.YNEWLO) GO TO 24
        YNEWLO=Y(J)
        IBEST=J
24      CONTINUE
        Y(IBEST)=BIGNUM
        YSEC=BIGNUM
        DO 25 J=1,NN

        IF(Y(J).GE.YSEC) GO TO 25
        YSEC=Y(J)
        ISEC=J
25      CONTINUE
        DO 26 I=1,N
        XMIN(I)=P(I,IBEST)
        XSEC(I)=P(I,ISEC)
26      CONTINUE

        RETURN
        END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC                                   
C
      SUBROUTINE GETSTART1(DELTIM,START,BIGMALF)
      IMPLICIT REAL*8(A-H,O-Z)
      DIMENSION START(594),TIMCAN(10)
      DATA NUMCALL/0/
      COMMON/TOGETSTART/OBSMAXTIM,OBSMINTIM,PERCENT


      NOBSER = 1

C  NOTE THAT 1.D-16 IS ADDED TO ALL TIME CANDIDATES. THIS IS DONE SO
C  THAT THE FIRST TIME IS NOT 0 ... SINCE IF ALL OBSERVATION TIMES ARE
C  0, IT WILL CONFUSE SUBROUTINE FUNC (I.E., THE 2ND O OBSERVATION 
C  TIME LOOKS LIKE A TIME RESET TO FUNC).

C  SLIGHT CORRECTION AS OF dopteng6.f. NOTE THAT THE LARGEST TIME
C  IN PREVIOUS PROGRAMS WAS ALWAYS 1.D-16 MORE THAN OBSMAXTIM ...
C  SINCE DELTIM = (OBSMAXTIM - OBSMINTIM)/10 (I.E., FOR IT1 = 11
C  IN THE LOOP BELOW, TIMCAN(.) = OBSMAXTIM + 1.D-16). SO, IF ANY
C  TIMCAN(.) > OBSMAXTIM, SET IT BACK = OBSMAXTIM.

      DO IT1 = 1,11

       TIMCAN(1) = (IT1-1)*DELTIM + 1.D-16 + OBSMINTIM
       IF(TIMCAN(1) .GT. OBSMAXTIM) TIMCAN(1) = OBSMAXTIM

       CALL DOPTTIM(NOBSER,TIMCAN,FNTVAL)

C  SINCE TOTAL NO. OF CALLS IS 11, PRINT MESSAGE TO
C  THE SCREEN EACH 10% = 1 CALLS. 

        NUMCALL = NUMCALL + 1
	  PERCENT = NUMCALL*9
        WRITE(*,11) PERCENT
   11   FORMAT(' NOW DONE WITH ',F5.1'% OF THE STARTING GRID CALLS')

       IF(-FNTVAL .GT. BIGMALF) THEN
        DO IOBS = 1,NOBSER
         START(IOBS) = TIMCAN(IOBS)
        END DO
        BIGMALF = -FNTVAL
       ENDIF


      END DO

      RETURN
      END
C

CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC                                   
C
      SUBROUTINE GETSTART2(DELTIM,START,BIGMALF)
      IMPLICIT REAL*8(A-H,O-Z)
      DIMENSION START(594),TIMCAN(10)
      DATA NUMCALL/0/
      COMMON/TOGETSTART/OBSMAXTIM,OBSMINTIM,PERCENT 

      NOBSER = 2

C  NOTE THAT 1.D-16 IS ADDED TO ALL TIME CANDIDATES. THIS IS DONE SO
C  THAT THE FIRST TIME IS NOT 0 ... SINCE IF ALL OBSERVATION TIMES ARE
C  0, IT WILL CONFUSE SUBROUTINE FUNC (I.E., THE 2ND O OBSERVATION 
C  TIME LOOKS LIKE A TIME RESET TO FUNC).

C  SLIGHT CORRECTION AS OF dopteng6.f. NOTE THAT THE LARGEST TIME
C  IN PREVIOUS PROGRAMS WAS ALWAYS 1.D-16 MORE THAN OBSMAXTIM ...
C  SINCE DELTIM = (OBSMAXTIM - OBSMINTIM)/10 (I.E., FOR IT1 = 11
C  IN THE LOOP BELOW, TIMCAN(.) = OBSMAXTIM + 1.D-16). SO, IF ANY
C  TIMCAN(.) > OBSMAXTIM, SET IT BACK = OBSMAXTIM.


      DO IT1 = 1,11

       TIMCAN(1) = (IT1-1)*DELTIM + 1.D-16 + OBSMINTIM
       IF(TIMCAN(1) .GT. OBSMAXTIM) TIMCAN(1) = OBSMAXTIM

       DO IT2 = IT1,11

        TIMCAN(2) = (IT2-1)*DELTIM + 1.D-16 + OBSMINTIM
        IF(TIMCAN(2) .GT. OBSMAXTIM) TIMCAN(2) = OBSMAXTIM

        CALL DOPTTIM(NOBSER,TIMCAN,FNTVAL)

C  SINCE TOTAL NO. OF CALLS IS 66, PRINT MESSAGE TO
C  THE SCREEN EACH 10% = 7 CALLS. 

	 NUMCALL = NUMCALL + 1
	
    	 IF(NUMCALL .EQ. 7) THEN
        PERCENT = PERCENT + 10
        WRITE(*,11) PERCENT
   11   FORMAT(' NOW DONE WITH ',F5.1'% OF THE STARTING GRID CALLS')
        NUMCALL = 0
       ENDIF




        IF(-FNTVAL .GT. BIGMALF) THEN
         DO IOBS = 1,NOBSER
          START(IOBS) = TIMCAN(IOBS)
         END DO
         BIGMALF = -FNTVAL
        ENDIF

       END DO
      END DO

      RETURN
      END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC                                   
C
      SUBROUTINE GETSTART3(DELTIM,START,BIGMALF)
      IMPLICIT REAL*8(A-H,O-Z)
      DIMENSION START(594),TIMCAN(10)
      DATA NUMCALL/0/
      COMMON/TOGETSTART/OBSMAXTIM,OBSMINTIM,PERCENT 

      NOBSER = 3

C  NOTE THAT 1.D-16 IS ADDED TO ALL TIME CANDIDATES. THIS IS DONE SO
C  THAT THE FIRST TIME IS NOT 0 ... SINCE IF ALL OBSERVATION TIMES ARE
C  0, IT WILL CONFUSE SUBROUTINE FUNC (I.E., THE 2ND O OBSERVATION 
C  TIME LOOKS LIKE A TIME RESET TO FUNC).

C  SLIGHT CORRECTION AS OF dopteng6.f. NOTE THAT THE LARGEST TIME
C  IN PREVIOUS PROGRAMS WAS ALWAYS 1.D-16 MORE THAN OBSMAXTIM ...
C  SINCE DELTIM = (OBSMAXTIM - OBSMINTIM)/10 (I.E., FOR IT1 = 11
C  IN THE LOOP BELOW, TIMCAN(.) = OBSMAXTIM + 1.D-16). SO, IF ANY
C  TIMCAN(.) > OBSMAXTIM, SET IT BACK = OBSMAXTIM.


      DO IT1 = 1,11

       TIMCAN(1) = (IT1-1)*DELTIM + 1.D-16 + OBSMINTIM 
       IF(TIMCAN(1) .GT. OBSMAXTIM) TIMCAN(1) = OBSMAXTIM

       DO IT2 = IT1,11

        TIMCAN(2) = (IT2-1)*DELTIM + 1.D-16 + OBSMINTIM
        IF(TIMCAN(2) .GT. OBSMAXTIM) TIMCAN(2) = OBSMAXTIM

        DO IT3 = IT2,11

         TIMCAN(3) = (IT3-1)*DELTIM + 1.D-16 + OBSMINTIM
         IF(TIMCAN(3) .GT. OBSMAXTIM) TIMCAN(3) = OBSMAXTIM

         CALL DOPTTIM(NOBSER,TIMCAN,FNTVAL)


C  SINCE TOTAL NO. OF CALLS IS 286, PRINT MESSAGE TO
C  THE SCREEN EACH 10% = 29 CALLS. 

	NUMCALL = NUMCALL + 1
	
    	 IF(NUMCALL .EQ. 29) THEN
        PERCENT = PERCENT + 10
        WRITE(*,11) PERCENT
   11   FORMAT(' NOW DONE WITH ',F5.1'% OF THE STARTING GRID CALLS')
        NUMCALL = 0
       ENDIF

         IF(-FNTVAL .GT. BIGMALF) THEN
          DO IOBS = 1,NOBSER
           START(IOBS) = TIMCAN(IOBS)
          END DO
          BIGMALF = -FNTVAL
         ENDIF

        END DO
       END DO
      END DO

      RETURN
      END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC                                   
C
      SUBROUTINE GETSTART4(DELTIM,START,BIGMALF)
      IMPLICIT REAL*8(A-H,O-Z)
      DIMENSION START(594),TIMCAN(10)
      DATA NUMCALL/0/
      COMMON/TOGETSTART/OBSMAXTIM,OBSMINTIM,PERCENT 

      NOBSER = 4

C  NOTE THAT 1.D-16 IS ADDED TO ALL TIME CANDIDATES. THIS IS DONE SO
C  THAT THE FIRST TIME IS NOT 0 ... SINCE IF ALL OBSERVATION TIMES ARE
C  0, IT WILL CONFUSE SUBROUTINE FUNC (I.E., THE 2ND O OBSERVATION 
C  TIME LOOKS LIKE A TIME RESET TO FUNC).

C  SLIGHT CORRECTION AS OF dopteng6.f. NOTE THAT THE LARGEST TIME
C  IN PREVIOUS PROGRAMS WAS ALWAYS 1.D-16 MORE THAN OBSMAXTIM ...
C  SINCE DELTIM = (OBSMAXTIM - OBSMINTIM)/10 (I.E., FOR IT1 = 11
C  IN THE LOOP BELOW, TIMCAN(.) = OBSMAXTIM + 1.D-16). SO, IF ANY
C  TIMCAN(.) > OBSMAXTIM, SET IT BACK = OBSMAXTIM.


      DO IT1 = 1,11

       TIMCAN(1) = (IT1-1)*DELTIM + 1.D-16 + OBSMINTIM 
       IF(TIMCAN(1) .GT. OBSMAXTIM) TIMCAN(1) = OBSMAXTIM

       DO IT2 = IT1,11

        TIMCAN(2) = (IT2-1)*DELTIM + 1.D-16 + OBSMINTIM
        IF(TIMCAN(2) .GT. OBSMAXTIM) TIMCAN(2) = OBSMAXTIM

        DO IT3 = IT2,11

         TIMCAN(3) = (IT3-1)*DELTIM + 1.D-16 + OBSMINTIM
         IF(TIMCAN(3) .GT. OBSMAXTIM) TIMCAN(3) = OBSMAXTIM

         DO IT4 = IT3,11

          TIMCAN(4) = (IT4-1)*DELTIM + 1.D-16 + OBSMINTIM
          IF(TIMCAN(4) .GT. OBSMAXTIM) TIMCAN(4) = OBSMAXTIM

          CALL DOPTTIM(NOBSER,TIMCAN,FNTVAL)

C  SINCE TOTAL NO. OF CALLS IS 1001, PRINT MESSAGE TO
C  THE SCREEN EACH 10% = 801 CALLS. 


	NUMCALL = NUMCALL + 1
	
    	 IF(NUMCALL .EQ. 100) THEN
        PERCENT = PERCENT + 10
        WRITE(*,11) PERCENT
   11   FORMAT(' NOW DONE WITH ',F5.1'% OF THE STARTING GRID CALLS')
        NUMCALL = 0
       ENDIF

          IF(-FNTVAL .GT. BIGMALF) THEN
           DO IOBS = 1,NOBSER
            START(IOBS) = TIMCAN(IOBS)
           END DO
           BIGMALF = -FNTVAL
          ENDIF

         END DO
        END DO
       END DO
      END DO

      RETURN
      END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC                                   
C
      SUBROUTINE GETSTART5(DELTIM,START,BIGMALF)
      IMPLICIT REAL*8(A-H,O-Z)
      DIMENSION START(594),TIMCAN(10)
      DATA NUMCALL/0/
      COMMON/TOGETSTART/OBSMAXTIM,OBSMINTIM,PERCENT 


      NOBSER = 5

C  NOTE THAT 1.D-16 IS ADDED TO ALL TIME CANDIDATES. THIS IS DONE SO
C  THAT THE FIRST TIME IS NOT 0 ... SINCE IF ALL OBSERVATION TIMES ARE
C  0, IT WILL CONFUSE SUBROUTINE FUNC (I.E., THE 2ND O OBSERVATION 
C  TIME LOOKS LIKE A TIME RESET TO FUNC).

C  SLIGHT CORRECTION AS OF dopteng6.f. NOTE THAT THE LARGEST TIME
C  IN PREVIOUS PROGRAMS WAS ALWAYS 1.D-16 MORE THAN OBSMAXTIM ...
C  SINCE DELTIM = (OBSMAXTIM - OBSMINTIM)/10 (I.E., FOR IT1 = 11
C  IN THE LOOP BELOW, TIMCAN(.) = OBSMAXTIM + 1.D-16). SO, IF ANY
C  TIMCAN(.) > OBSMAXTIM, SET IT BACK = OBSMAXTIM.

      DO IT1 = 1,11

       TIMCAN(1) = (IT1-1)*DELTIM + 1.D-16 + OBSMINTIM
       IF(TIMCAN(1) .GT. OBSMAXTIM) TIMCAN(1) = OBSMAXTIM

       DO IT2 = IT1,11

        TIMCAN(2) = (IT2-1)*DELTIM + 1.D-16 + OBSMINTIM
        IF(TIMCAN(2) .GT. OBSMAXTIM) TIMCAN(2) = OBSMAXTIM

        DO IT3 = IT2,11

         TIMCAN(3) = (IT3-1)*DELTIM + 1.D-16 + OBSMINTIM
         IF(TIMCAN(3) .GT. OBSMAXTIM) TIMCAN(3) = OBSMAXTIM

         DO IT4 = IT3,11

          TIMCAN(4) = (IT4-1)*DELTIM + 1.D-16 + OBSMINTIM
          IF(TIMCAN(4) .GT. OBSMAXTIM) TIMCAN(4) = OBSMAXTIM

          DO IT5 = IT4,11

           TIMCAN(5) = (IT5-1)*DELTIM + 1.D-16 + OBSMINTIM
           IF(TIMCAN(5) .GT. OBSMAXTIM) TIMCAN(5) = OBSMAXTIM

           CALL DOPTTIM(NOBSER,TIMCAN,FNTVAL)

C  SINCE TOTAL NO. OF CALLS IS 3003, PRINT MESSAGE TO
C  THE SCREEN EACH 10% = 300 CALLS. 

	NUMCALL = NUMCALL + 1
		
    	 IF(NUMCALL .EQ. 300) THEN
        PERCENT = PERCENT + 10
        WRITE(*,11) PERCENT
   11   FORMAT(' NOW DONE WITH ',F5.1'% OF THE STARTING GRID CALLS')
        NUMCALL = 0
       ENDIF


           IF(-FNTVAL .GT. BIGMALF) THEN
            DO IOBS = 1,NOBSER
             START(IOBS) = TIMCAN(IOBS)
            END DO
            BIGMALF = -FNTVAL
           ENDIF

          END DO
         END DO
        END DO
       END DO
      END DO

      RETURN
      END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC                                   
C
      SUBROUTINE GETSTART6(DELTIM,START,BIGMALF)
      IMPLICIT REAL*8(A-H,O-Z)
      DIMENSION START(594),TIMCAN(10)
      DATA NUMCALL/0/
      COMMON/TOGETSTART/OBSMAXTIM,OBSMINTIM,PERCENT 

      NOBSER = 6

C  NOTE THAT 1.D-16 IS ADDED TO ALL TIME CANDIDATES. THIS IS DONE SO
C  THAT THE FIRST TIME IS NOT 0 ... SINCE IF ALL OBSERVATION TIMES ARE
C  0, IT WILL CONFUSE SUBROUTINE FUNC (I.E., THE 2ND O OBSERVATION 
C  TIME LOOKS LIKE A TIME RESET TO FUNC).

C  SLIGHT CORRECTION AS OF dopteng6.f. NOTE THAT THE LARGEST TIME
C  IN PREVIOUS PROGRAMS WAS ALWAYS 1.D-16 MORE THAN OBSMAXTIM ...
C  SINCE DELTIM = (OBSMAXTIM - OBSMINTIM)/10 (I.E., FOR IT1 = 11
C  IN THE LOOP BELOW, TIMCAN(.) = OBSMAXTIM + 1.D-16). SO, IF ANY
C  TIMCAN(.) > OBSMAXTIM, SET IT BACK = OBSMAXTIM.


      DO IT1 = 1,11

       TIMCAN(1) = (IT1-1)*DELTIM + 1.D-16 + OBSMINTIM
       IF(TIMCAN(1) .GT. OBSMAXTIM) TIMCAN(1) = OBSMAXTIM

       DO IT2 = IT1,11

        TIMCAN(2) = (IT2-1)*DELTIM + 1.D-16 + OBSMINTIM
        IF(TIMCAN(2) .GT. OBSMAXTIM) TIMCAN(2) = OBSMAXTIM

        DO IT3 = IT2,11

         TIMCAN(3) = (IT3-1)*DELTIM + 1.D-16 + OBSMINTIM
         IF(TIMCAN(3) .GT. OBSMAXTIM) TIMCAN(3) = OBSMAXTIM

         DO IT4 = IT3,11

          TIMCAN(4) = (IT4-1)*DELTIM + 1.D-16 + OBSMINTIM
          IF(TIMCAN(4) .GT. OBSMAXTIM) TIMCAN(4) = OBSMAXTIM

          DO IT5 = IT4,11

           TIMCAN(5) = (IT5-1)*DELTIM + 1.D-16 + OBSMINTIM
           IF(TIMCAN(5) .GT. OBSMAXTIM) TIMCAN(5) = OBSMAXTIM
  
           DO IT6 = IT5,11

            TIMCAN(6) = (IT6-1)*DELTIM + 1.D-16 + OBSMINTIM
            IF(TIMCAN(6) .GT. OBSMAXTIM) TIMCAN(6) = OBSMAXTIM



            CALL DOPTTIM(NOBSER,TIMCAN,FNTVAL)


C  SINCE TOTAL NO. OF CALLS IS 8008, PRINT MESSAGE TO
C  THE SCREEN EACH 10% = 801 CALLS. 

	NUMCALL = NUMCALL + 1
	
    	 IF(NUMCALL .EQ. 801) THEN
        PERCENT = PERCENT + 10
        WRITE(*,11) PERCENT
   11   FORMAT(' NOW DONE WITH ',F5.1'% OF THE STARTING GRID CALLS')
        NUMCALL = 0
       ENDIF

            IF(-FNTVAL .GT. BIGMALF) THEN
             DO IOBS = 1,NOBSER
              START(IOBS) = TIMCAN(IOBS)
             END DO
             BIGMALF = -FNTVAL


            ENDIF

           END DO
          END DO
         END DO
        END DO
       END DO
      END DO

      RETURN
      END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC                                   
C
      SUBROUTINE GETSTART7(DELTIM,START,BIGMALF)
      IMPLICIT REAL*8(A-H,O-Z)
      DIMENSION START(594),TIMCAN(10)
      DATA NUMCALL/0/
      COMMON/TOGETSTART/OBSMAXTIM,OBSMINTIM,PERCENT 

      NOBSER = 7

C  NOTE THAT 1.D-16 IS ADDED TO ALL TIME CANDIDATES. THIS IS DONE SO
C  THAT THE FIRST TIME IS NOT 0 ... SINCE IF ALL OBSERVATION TIMES ARE
C  0, IT WILL CONFUSE SUBROUTINE FUNC (I.E., THE 2ND O OBSERVATION 
C  TIME LOOKS LIKE A TIME RESET TO FUNC).

C  SLIGHT CORRECTION AS OF dopteng6.f. NOTE THAT THE LARGEST TIME
C  IN PREVIOUS PROGRAMS WAS ALWAYS 1.D-16 MORE THAN OBSMAXTIM ...
C  SINCE DELTIM = (OBSMAXTIM - OBSMINTIM)/10 (I.E., FOR IT1 = 11
C  IN THE LOOP BELOW, TIMCAN(.) = OBSMAXTIM + 1.D-16). SO, IF ANY
C  TIMCAN(.) > OBSMAXTIM, SET IT BACK = OBSMAXTIM.


      DO IT1 = 1,11

       TIMCAN(1) = (IT1-1)*DELTIM + 1.D-16 + OBSMINTIM
       IF(TIMCAN(1) .GT. OBSMAXTIM) TIMCAN(1) = OBSMAXTIM

       DO IT2 = IT1,11

        TIMCAN(2) = (IT2-1)*DELTIM + 1.D-16 + OBSMINTIM
        IF(TIMCAN(2) .GT. OBSMAXTIM) TIMCAN(2) = OBSMAXTIM

        DO IT3 = IT2,11

         TIMCAN(3) = (IT3-1)*DELTIM + 1.D-16 + OBSMINTIM
         IF(TIMCAN(3) .GT. OBSMAXTIM) TIMCAN(3) = OBSMAXTIM

         DO IT4 = IT3,11

          TIMCAN(4) = (IT4-1)*DELTIM + 1.D-16 + OBSMINTIM
          IF(TIMCAN(4) .GT. OBSMAXTIM) TIMCAN(4) = OBSMAXTIM

          DO IT5 = IT4,11

           TIMCAN(5) = (IT5-1)*DELTIM + 1.D-16 + OBSMINTIM
           IF(TIMCAN(5) .GT. OBSMAXTIM) TIMCAN(5) = OBSMAXTIM


           DO IT6 = IT5,11

            TIMCAN(6) = (IT6-1)*DELTIM + 1.D-16 + OBSMINTIM
            IF(TIMCAN(6) .GT. OBSMAXTIM) TIMCAN(6) = OBSMAXTIM

            DO IT7 = IT6,11

             TIMCAN(7) = (IT7-1)*DELTIM + 1.D-16 + OBSMINTIM
             IF(TIMCAN(7) .GT. OBSMAXTIM) TIMCAN(7) = OBSMAXTIM

             CALL DOPTTIM(NOBSER,TIMCAN,FNTVAL)


C  SINCE TOTAL NO. OF CALLS IS 19448, PRINT MESSAGE TO
C  THE SCREEN EACH 10% = 1945 CALLS. 

	NUMCALL = NUMCALL + 1
	
    	 IF(NUMCALL .EQ. 1945) THEN
        PERCENT = PERCENT + 10
        WRITE(*,11) PERCENT
   11   FORMAT(' NOW DONE WITH ',F5.1'% OF THE STARTING GRID CALLS')
        NUMCALL = 0
       ENDIF

             IF(-FNTVAL .GT. BIGMALF) THEN
              DO IOBS = 1,NOBSER
               START(IOBS) = TIMCAN(IOBS)
              END DO
              BIGMALF = -FNTVAL
             ENDIF

            END DO
           END DO
          END DO
         END DO
        END DO
       END DO
      END DO

      RETURN
      END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC                                   
C
      SUBROUTINE GETSTART8(DELTIM,START,BIGMALF)
      IMPLICIT REAL*8(A-H,O-Z)
      DIMENSION START(594),TIMCAN(10)
      DATA NUMCALL/0/
      COMMON/TOGETSTART/OBSMAXTIM,OBSMINTIM,PERCENT 

      NOBSER = 8

C  NOTE THAT 1.D-16 IS ADDED TO ALL TIME CANDIDATES. THIS IS DONE SO
C  THAT THE FIRST TIME IS NOT 0 ... SINCE IF ALL OBSERVATION TIMES ARE
C  0, IT WILL CONFUSE SUBROUTINE FUNC (I.E., THE 2ND O OBSERVATION 
C  TIME LOOKS LIKE A TIME RESET TO FUNC).

C  SLIGHT CORRECTION AS OF dopteng6.f. NOTE THAT THE LARGEST TIME
C  IN PREVIOUS PROGRAMS WAS ALWAYS 1.D-16 MORE THAN OBSMAXTIM ...
C  SINCE DELTIM = (OBSMAXTIM - OBSMINTIM)/10 (I.E., FOR IT1 = 11
C  IN THE LOOP BELOW, TIMCAN(.) = OBSMAXTIM + 1.D-16). SO, IF ANY
C  TIMCAN(.) > OBSMAXTIM, SET IT BACK = OBSMAXTIM.


      DO IT1 = 1,11

       TIMCAN(1) = (IT1-1)*DELTIM + 1.D-16 + OBSMINTIM
       IF(TIMCAN(1) .GT. OBSMAXTIM) TIMCAN(1) = OBSMAXTIM

       DO IT2 = IT1,11

        TIMCAN(2) = (IT2-1)*DELTIM + 1.D-16 + OBSMINTIM
        IF(TIMCAN(2) .GT. OBSMAXTIM) TIMCAN(2) = OBSMAXTIM

        DO IT3 = IT2,11

         TIMCAN(3) = (IT3-1)*DELTIM + 1.D-16 + OBSMINTIM
         IF(TIMCAN(3) .GT. OBSMAXTIM) TIMCAN(3) = OBSMAXTIM

         DO IT4 = IT3,11

          TIMCAN(4) = (IT4-1)*DELTIM + 1.D-16 + OBSMINTIM
          IF(TIMCAN(4) .GT. OBSMAXTIM) TIMCAN(4) = OBSMAXTIM

          DO IT5 = IT4,11

           TIMCAN(5) = (IT5-1)*DELTIM + 1.D-16 + OBSMINTIM
           IF(TIMCAN(5) .GT. OBSMAXTIM) TIMCAN(5) = OBSMAXTIM

           DO IT6 = IT5,11

            TIMCAN(6) = (IT6-1)*DELTIM + 1.D-16 + OBSMINTIM
            IF(TIMCAN(6) .GT. OBSMAXTIM) TIMCAN(6) = OBSMAXTIM

            DO IT7 = IT6,11


             TIMCAN(7) = (IT7-1)*DELTIM + 1.D-16 + OBSMINTIM
             IF(TIMCAN(7) .GT. OBSMAXTIM) TIMCAN(7) = OBSMAXTIM

             DO IT8 = IT7,11

              TIMCAN(8) = (IT8-1)*DELTIM + 1.D-16 + OBSMINTIM
              IF(TIMCAN(8) .GT. OBSMAXTIM) TIMCAN(8) = OBSMAXTIM

              CALL DOPTTIM(NOBSER,TIMCAN,FNTVAL)
   
C  SINCE TOTAL NO. OF CALLS IS 43758, PRINT MESSAGE TO
C  THE SCREEN EACH 10% = 4376 CALLS. 

	NUMCALL = NUMCALL + 1
	
    	IF(NUMCALL .EQ. 4376) THEN
       PERCENT = PERCENT + 10
       WRITE(*,11) PERCENT
   11  FORMAT(' NOW DONE WITH ',F5.1'% OF THE STARTING GRID CALLS')
       NUMCALL = 0
      ENDIF

              IF(-FNTVAL .GT. BIGMALF) THEN
               DO IOBS = 1,NOBSER
                START(IOBS) = TIMCAN(IOBS)
               END DO
               BIGMALF = -FNTVAL
              ENDIF

             END DO
            END DO
           END DO
          END DO
         END DO
        END DO
       END DO
      END DO

      RETURN
      END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC                                   
C
      SUBROUTINE GETSTART9(DELTIM,START,BIGMALF)
      IMPLICIT REAL*8(A-H,O-Z)
      DIMENSION START(594),TIMCAN(10)
      DATA NUMCALL/0/
      COMMON/TOGETSTART/OBSMAXTIM,OBSMINTIM,PERCENT 

      NOBSER = 9

C  NOTE THAT 1.D-16 IS ADDED TO ALL TIME CANDIDATES. THIS IS DONE SO
C  THAT THE FIRST TIME IS NOT 0 ... SINCE IF ALL OBSERVATION TIMES ARE
C  0, IT WILL CONFUSE SUBROUTINE FUNC (I.E., THE 2ND O OBSERVATION 
C  TIME LOOKS LIKE A TIME RESET TO FUNC).

C  SLIGHT CORRECTION AS OF dopteng6.f. NOTE THAT THE LARGEST TIME
C  IN PREVIOUS PROGRAMS WAS ALWAYS 1.D-16 MORE THAN OBSMAXTIM ...
C  SINCE DELTIM = (OBSMAXTIM - OBSMINTIM)/10 (I.E., FOR IT1 = 11
C  IN THE LOOP BELOW, TIMCAN(.) = OBSMAXTIM + 1.D-16). SO, IF ANY
C  TIMCAN(.) > OBSMAXTIM, SET IT BACK = OBSMAXTIM.


      DO IT1 = 1,11

       TIMCAN(1) = (IT1-1)*DELTIM + 1.D-16 + OBSMINTIM
       IF(TIMCAN(1) .GT. OBSMAXTIM) TIMCAN(1) = OBSMAXTIM

       DO IT2 = IT1,11

        TIMCAN(2) = (IT2-1)*DELTIM + 1.D-16 + OBSMINTIM
        IF(TIMCAN(2) .GT. OBSMAXTIM) TIMCAN(2) = OBSMAXTIM

        DO IT3 = IT2,11

         TIMCAN(3) = (IT3-1)*DELTIM + 1.D-16 + OBSMINTIM
         IF(TIMCAN(3) .GT. OBSMAXTIM) TIMCAN(3) = OBSMAXTIM

         DO IT4 = IT3,11

          TIMCAN(4) = (IT4-1)*DELTIM + 1.D-16 + OBSMINTIM
          IF(TIMCAN(4) .GT. OBSMAXTIM) TIMCAN(4) = OBSMAXTIM

          DO IT5 = IT4,11

           TIMCAN(5) = (IT5-1)*DELTIM + 1.D-16 + OBSMINTIM
           IF(TIMCAN(5) .GT. OBSMAXTIM) TIMCAN(5) = OBSMAXTIM

           DO IT6 = IT5,11

            TIMCAN(6) = (IT6-1)*DELTIM + 1.D-16 + OBSMINTIM
            IF(TIMCAN(6) .GT. OBSMAXTIM) TIMCAN(6) = OBSMAXTIM

            DO IT7 = IT6,11

             TIMCAN(7) = (IT7-1)*DELTIM + 1.D-16 + OBSMINTIM
             IF(TIMCAN(7) .GT. OBSMAXTIM) TIMCAN(7) = OBSMAXTIM

             DO IT8 = IT7,11

              TIMCAN(8) = (IT8-1)*DELTIM + 1.D-16 + OBSMINTIM
              IF(TIMCAN(8) .GT. OBSMAXTIM) TIMCAN(8) = OBSMAXTIM

              DO IT9 = IT8,11

               TIMCAN(9) = (IT9-1)*DELTIM + 1.D-16 + OBSMINTIM
               IF(TIMCAN(9) .GT. OBSMAXTIM) TIMCAN(9) = OBSMAXTIM

               CALL DOPTTIM(NOBSER,TIMCAN,FNTVAL)


C  SINCE TOTAL NO. OF CALLS IS 92378, PRINT MESSAGE TO
C  THE SCREEN EACH 10% = 9238 CALLS. 

	NUMCALL = NUMCALL + 1

    	IF(NUMCALL .EQ. 9238) THEN
       PERCENT = PERCENT + 10
       WRITE(*,11) PERCENT
   11  FORMAT(' NOW DONE WITH ',F5.1'% OF THE STARTING GRID CALLS')
       NUMCALL = 0
      ENDIF	
	
               IF(-FNTVAL .GT. BIGMALF) THEN
                DO IOBS = 1,NOBSER
                 START(IOBS) = TIMCAN(IOBS)
                END DO
                BIGMALF = -FNTVAL
               ENDIF

              END DO
             END DO
            END DO
           END DO
          END DO
         END DO
        END DO
       END DO
      END DO


      RETURN
      END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC                                   
C
      SUBROUTINE GETSTART10(DELTIM,START,BIGMALF)
      IMPLICIT REAL*8(A-H,O-Z)
      DIMENSION START(594),TIMCAN(10)
      DATA NUMCALL/0/
      COMMON/TOGETSTART/OBSMAXTIM,OBSMINTIM,PERCENT 

      NOBSER = 10

C  NOTE THAT 1.D-16 IS ADDED TO ALL TIME CANDIDATES. THIS IS DONE SO
C  THAT THE FIRST TIME IS NOT 0 ... SINCE IF ALL OBSERVATION TIMES ARE
C  0, IT WILL CONFUSE SUBROUTINE FUNC (I.E., THE 2ND O OBSERVATION 
C  TIME LOOKS LIKE A TIME RESET TO FUNC).

C  SLIGHT CORRECTION AS OF dopteng6.f. NOTE THAT THE LARGEST TIME
C  IN PREVIOUS PROGRAMS WAS ALWAYS 1.D-16 MORE THAN OBSMAXTIM ...
C  SINCE DELTIM = (OBSMAXTIM - OBSMINTIM)/10 (I.E., FOR IT1 = 11

C  IN THE LOOP BELOW, TIMCAN(.) = OBSMAXTIM + 1.D-16). SO, IF ANY
C  TIMCAN(.) > OBSMAXTIM, SET IT BACK = OBSMAXTIM.


      DO IT1 = 1,11

       TIMCAN(1) = (IT1-1)*DELTIM + 1.D-16 + OBSMINTIM
       IF(TIMCAN(1) .GT. OBSMAXTIM) TIMCAN(1) = OBSMAXTIM

       DO IT2 = IT1,11

        TIMCAN(2) = (IT2-1)*DELTIM + 1.D-16 + OBSMINTIM
        IF(TIMCAN(2) .GT. OBSMAXTIM) TIMCAN(2) = OBSMAXTIM

        DO IT3 = IT2,11

         TIMCAN(3) = (IT3-1)*DELTIM + 1.D-16 + OBSMINTIM
         IF(TIMCAN(3) .GT. OBSMAXTIM) TIMCAN(3) = OBSMAXTIM

         DO IT4 = IT3,11

          TIMCAN(4) = (IT4-1)*DELTIM + 1.D-16 + OBSMINTIM
          IF(TIMCAN(4) .GT. OBSMAXTIM) TIMCAN(4) = OBSMAXTIM

          DO IT5 = IT4,11

           TIMCAN(5) = (IT5-1)*DELTIM + 1.D-16 + OBSMINTIM
           IF(TIMCAN(5) .GT. OBSMAXTIM) TIMCAN(5) = OBSMAXTIM

           DO IT6 = IT5,11

            TIMCAN(6) = (IT6-1)*DELTIM + 1.D-16 + OBSMINTIM
            IF(TIMCAN(6) .GT. OBSMAXTIM) TIMCAN(6) = OBSMAXTIM

            DO IT7 = IT6,11

             TIMCAN(7) = (IT7-1)*DELTIM + 1.D-16 + OBSMINTIM
             IF(TIMCAN(7) .GT. OBSMAXTIM) TIMCAN(7) = OBSMAXTIM

             DO IT8 = IT7,11

              TIMCAN(8) = (IT8-1)*DELTIM + 1.D-16 + OBSMINTIM
              IF(TIMCAN(8) .GT. OBSMAXTIM) TIMCAN(8) = OBSMAXTIM

              DO IT9 = IT8,11

               TIMCAN(9) = (IT9-1)*DELTIM + 1.D-16 + OBSMINTIM
               IF(TIMCAN(9) .GT. OBSMAXTIM) TIMCAN(9) = OBSMAXTIM

               DO IT10 = IT9,11

                TIMCAN(10) = (IT10-1)*DELTIM + 1.D-16 + OBSMINTIM
                IF(TIMCAN(10) .GT. OBSMAXTIM) TIMCAN(10) = OBSMAXTIM

                CALL DOPTTIM(NOBSER,TIMCAN,FNTVAL)


C  SINCE TOTAL NO. OF CALLS IS 184756, PRINT MESSAGE TO
C  THE SCREEN EACH 10% = 18476 CALLS. 

	NUMCALL = NUMCALL + 1
	
    	IF(NUMCALL .EQ. 18476) THEN
       PERCENT = PERCENT + 10
       WRITE(*,11) PERCENT
   11  FORMAT(' NOW DONE WITH ',F5.1'% OF THE STARTING GRID CALLS')
       NUMCALL = 0
      ENDIF
	
                IF(-FNTVAL .GT. BIGMALF) THEN
                 DO IOBS = 1,NOBSER
                  START(IOBS) = TIMCAN(IOBS)
                 END DO
                 BIGMALF = -FNTVAL
                ENDIF

               END DO
              END DO
             END DO
            END DO
           END DO
          END DO
         END DO
        END DO
       END DO
      END DO

      RETURN
      END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
      SUBROUTINE DOPTTIM(NOBSER,VEC,FNTVAL)

      IMPLICIT REAL*8(A-H,O-Z)

      PARAMETER(MAXNUMEQ=7)


      DIMENSION VEC(NOBSER),IRAN(32),VALFIX(20),PX(32),THETA(30),
     1 PMAT(594,30),RINV(594,594),COVINV(30,30),B(30,1),YEST(594),
     2 Y(3564),P(32),TIM(594),SIG(5000),RS(5000,34),
     3 YO(594,MAXNUMEQ),BS(5000,7),C0(MAXNUMEQ),C1(MAXNUMEQ),
     4 C2(MAXNUMEQ),C3(MAXNUMEQ)

       CHARACTER ERRFIL*20

       COMMON/CNST/ N,ND,NI,NUP,NUIC,NP
       COMMON/PARAMD/ P
       COMMON/OBSER/ TIM,SIG,RS,YO,BS

      COMMON/TODOPT/VALFIX,THETA,GAMLAM,C0,C1,C2,C3,
     1 IRAN,NOFIX,NUMEQT,NVAR,IERRMOD,OBSMAXTIM,OBSMINTIM


       COMMON/ERR/ERRFIL 


C  THIS ROUTINE, CALLED BY ELDERY, FINDS THE FUNCTIONAL VALUE, FNTVAL
C  FOR THE SUPPLIED VARIABLE VECTOR, VEC.
C  FNTVAL = -|MALF|, WHERE MALF IS THE FISHER INFORMATION
C  MATRIX = PMAT'*RINV*PMAT, WHERE:

C	' INDICATES TRANSPOSE;

C     NOBACT BELOW = NOBSER x NUMEQT.

C	PMAT = NOBACT x NVAR MATRIX, WITH THE (I,J) ELEMENT = PARTIAL 
C	DERIVATIVE OF THE ITH VALUE IN THE YO MATRIX  W.R.T. 
C	THE JTH COORDINATE OF THE PARAMETER VECTOR, AT THE TIME OF THAT
C	OBSERVATION IN YO, ASSUMING ALL THE PARAMETERS = THEIR ESTIMATED 
C     VALUES IN THETA. NOTE THAT THE ITH VALUE IN YO IS COUNTED 
C     "COLUMN-WISE". I.E., THE ORDERING OF THE NOBACT VALUES IN YO IS:
C	(1,1),(2,1),...,(NOBSER,1), (1,2),(2,2),...,(NOBSER,2), ...
C	(1,NUMEQT),(2,NUMEQT),...,(NOBSER,NUMEQT);

C 	RINV = NOBACT x NOBACT DIAGONAL MATRIX WITH 1/S(I)**2 AS THE 
C	(I,I) ELEMENT, WHERE S(I) IS THE SIG(.,.) ELEMENT WHICH 
C	CORRESPONDS TO THE ITH VALUE IN YO (SEE ABOVE DEFN. 
C	OF PMAT). 


C  SINCE ELDERY MINIMIZES FNTVAL, IT FINDS THE VECTOR VEC WHICH 
C  MINIMIZES -|MALF|. THIS VECTOR IS THE SET OF TIMES WHICH IS THE
C  D-OPTIMAL DESIGN FOR THE GRID PT. OF PARAMETER VALUES PASSED IN
C  THETA ABOVE VIA COMMON/TODOPT (FOR THE SUBJECT WHOSE DATA VALUES 
C  HAVE BEEN READ IN BY SUBROUTINE FILRED (AND PUT INTO APPROPRIATE 
C  COMMON BLOCKS. NOTE THAT THESE COMMON BLOCKS ARE NOT NEEDED IN THIS 
C  ROUTINE. THEY ARE PASSED TO SUBROUTINE IDCALCP, WHICH USES THEM TO 
C  CALCULATE PMAT - SEE BELOW.


C  INPUT ARE:

C  NOBSER = NO. OF TIMES.
C  VEC = VECTOR OF CANDIDATES FOR THE NOBSER TIMES.
C  NOFIX = NO. OF FIXED PARAMATERS.
C  VALFIX(I) = VALUE OF FIXED PARAMETER I, I=1,NOFIX.
C  IRAN(I) = 1 IF PARAMATER I IS RANDOM AND CANNOT BE NEGATIVE;
C           -1 IF PARAMETER I IS RANDOM AND MAY BE NEGATIVE;


C            0 IF PARAMETER I IS FIXED; I = 1,NVAR+NOFIX.
C  NUMEQT = NO. OF OUTPUT EQUATIONS.


C  OUTPUT IS:

C  FNTVAL = -|MALF|, WHERE MALF IS THE FISHER INFORMATION
C  MATRIX = PMAT'*RINV*PMAT, WHERE:

C  CHECK THAT ALL TIME CANDIDATES ARE .GE. OBSMINTIM, AND MONOTONICALLY
C  INCREASING. OTHERWISE, RETURN A LARGE POSITIVE VALUE (AN 
C  UNATTRACTIVE VALUE) FOR FNTVAL.

      IF(VEC(1) .LT. OBSMINTIM) THEN
       FNTVAL = 1.D30
       RETURN
      ENDIF

      DO IOBS = 2,NOBSER
       IF(VEC(IOBS) .LT. VEC(IOBS-1)) THEN
        FNTVAL = 1.D30
        RETURN
       ENDIF
      END DO

C  VERIFY THAT THE LARGEST TIME IS STILL .LE. OBSMAXTIM. IF NOT,
C  RETURN A LARGE POSITIVE VALUE FOR FNTVAL.

      IF(VEC(NOBSER) .GT. OBSMAXTIM) THEN
       FNTVAL = 1.D30
       RETURN
      ENDIF
     



C  OBTAIN PMAT FROM THE CODE BELOW, WHICH IS BASED ON SUBROUTINE 
C  IDCALCP, A VERSION OF THE ID PROGRAM, MODIFIED TO CALCULATE THE 
C  DESIRED PARTIAL DERIVATIVES USING 'FORWARD' DIFFERENCES. NOTE THAT
C  THE CURRENT VERSION OF SUBROUTINE IDCALCP (AND THE ROUTINES IT CALLS)
C  IS IN idm222x15.f, AND THAT idm222x15.f IS STILL LINKED INTO THIS
C  PROGRAM, BECAUSE THE OTHER ROUTINES ARE NEEDED. I.E., SUBROUTINE
C  IDCALCP IN idm222x15.f IS NOT NEEDED SINCE A VERSION OF ITS CODE
C  IS INCLUDED BELOW ... THE DIFFERENCE HERE IS THAT THE CODE REGARDING
C  -99'S HAS BEEN REMOVED SINCE ALL PREDICTED VALUES WILL BE CALCULATED 
C  REGARDLESS OF WHETHER OR NOT THE SUBJECT HAD MISSING VALUES. AND
C  YEST(.), WHICH IS CALCULATED BELOW WILL BE AVAILABLE TO BE USED IN
C  THE SUBSEQUENT CALCULATION OF RINV. ALSO, NOTE THAT ESTML(.) IN 
C  THE CODE IN IDCALCP IS REPLACED BY PX(.).

C  MUST INTEGRATE FIXED AND RANDOM VALUES INTO PX, USING 
C  IRAN(I),I=1,NVAR+NOFIX. CALL MAKEVEC TO DO THIS.

C  SET TIM(.) = VEC(.), SO THAT IT WILL BE PASSED IN COMMON/OBSER, SO
C  THAT IT CAN BE USED BY SUBROUTINE FUNC1.

      DO IOBS = 1,NOBSER
       TIM(IOBS) = VEC(IOBS)
      END DO


	CALL MAKEVEC(NVAR,NOFIX,IRAN,THETA,VALFIX,PX)


C  BELOW IS THE MODIFIED CODE FROM SUBROUTINE IDCALCP.

C*****INITIALIZE PROGRAM*****

	CALL SYMBOL

C  THE ABOVE CALL TO SYMBOL GUARANTEES THAT COMMON/CNST AND
C  COMMON/BOLUSCOMP ARE ESTABLISHED.

C  NOTE THAT NP IS NEEDED IN SUBROUTINE IDPC; IT IS PASSED VIA
C  COMMON/CNST.

      NP = NVAR+NOFIX


C  MUST CALCULATE THE OUTPUT CONCENTRATION ARRAY, Y, FOR THE PARAMETER
C  VECTOR, PX, AS WELL AS FOR THE NVAR VARIATIONS OF PX (EACH
C  RANDOM COORDINATE INCREASED BY A DELTA-VALUE, WHILE THE OTHER 
C  COORDINATES ARE HELD FIXED TO THEIR VALUES IN PX) TO OBTAIN THE 
C  PIECES TO CALCULATE PMAT.

C  NOTE THAT PX INCLUDES BOTH RANDOM AND FIXED PARAMTER VALUES.

C  IN PARTICULAR, THE (NDEX,J) ELEMENT OF 

C  PMAT = (Y(NDEX;J) - Y(NDEX))/DELJ, WHERE DELJ IS AN INCREMENT IN THE 
C  JTH RANDOM PARAMETER DIRECTION, Y(NDEX) IS THE OUTPUT CONCENTRATION 
C  CORRESPONDING TO NDEX_TH NON-MISSING ENTRY IN YO (USING "COLUMN-WISE"
C  STACKING), ASSUMING THE PARAMETER VALUES ARE THE ONES IN PX, AND 
C  Y(NDEX;J) IS THE SAME AS Y(NDEX), EXCEPT THAT THE JTH RANDOM 
C  PARAMETER VALUE = PX(J)+DELJ.

C  NOTE, THEREFORE, THAT PMAT WILL BE NOBACT x NVAR, WHERE NOBACT = 
C  NOBSER*NUMEQT - MISTOT, WHERE MISTOT IS THE TOTAL NO. OF MISSING 
C  VALUES (-99'S) IN ARRAY YO. BUT IN THIS PROGRAM, THERE ARE NO MISSING
C  VALUES (I.E., ALL VALUES FOR ALL OUTPUT EQS. WILL BE PREDICTED,
C  EVEN IF SOME OF THE VALUES IN THE PATIENT'S DATA FILE ARE MISSING).


C  INITIALIZE JCOL = 0. IT IS THE RUNNING INDEX OF THE LAST COLUMN OF
C  PMAT WHICH HAS BEEN FILLED (COLUMN JCOL OF PMAT REFERS TO THE
C  JCOLth RANDOM VARIABLE).

      JCOL = 0

      DO 5000 JSIM = 0,NVAR+NOFIX

C  IF JSIM = 0, SIMULATE SYSTEM TO OBTAIN THE Y-ARRAY EVALUATED AT THE
C  PARAMETER VALUES IN PX. IF JSIM > 0, AND IRAN(JSIM) = 1 -- WHICH
C  MEANS THAN THE JSIMth ENTRY IN PX IS RANDOM -- SIMULATE THE SYSTEM 
C  TO OBTAIN THE Y-ARRAY AS ABOVE, EXCEPT WITH THE JSIMth ENTRY IN
C  PX INCREASED BY DELJ = PX(JSIM)*1.D-4.

C  1ST RESET ALL PARAMETER VALUES TO THEIR ORIGINAL PX VALUES. THEN
C  ADJUST IF JSIM > 0 AND IRAN(JSIM) = 1.

	DO I=1,NVAR+NOFIX
	 P(I)=PX(I)
	END DO


	IF(JSIM .GT. 0) THEN

C  IF IRAN(JSIM) = 0, THE JSIMth ENTRY IN PX IS A FIXED VALUE --> NO
C  SIMULATION NEEDED --> GO TO 5000.

	 IF(IRAN(JSIM) .EQ. 0) GO TO 5000

     	 DELJ=PX(JSIM)*1.D-4
	 P(JSIM)=PX(JSIM) + DELJ

	ENDIF 


C  CALL SUBROUTINE EVAL TO GET Y, EVALUATED AT P(I) AS DEFINED ABOVE.

	CALL EVAL(Y)

C  IF JSIM = 0, STORE Y-VALUES INTO YEST; IF JSIM > 0, CALCULATE COLUMN
C  JCOL OF PMAT (NOTE, IF JSIM > 0, IRAN(JSIM) MUST = 1; OTHERWISE 
C  CONTROL WOULD HAVE PASSED FROM ABOVE DIRECTLY TO LABEL 5000).

      NDEX = 0

      IF(JSIM .EQ. 0) THEN
       DO J = 1,NUMEQT
        DO I = 1,NOBSER
         NDEX = NDEX + 1
         YEST(NDEX) = Y((J-1)*NOBSER+I)
        END DO
       END DO
      ENDIF

      IF(JSIM .GT. 0) THEN
       JCOL = JCOL+1
       DO J = 1,NUMEQT
        DO I = 1,NOBSER
         NDEX = NDEX + 1
         PMAT(NDEX,JCOL) = (Y((J-1)*NOBSER+I) - YEST(NDEX))/DELJ
        END DO
       END DO
      ENDIF

 5000   CONTINUE



C  ESTABLISH RINV AS INDICATED ABOVE.

C  NOTE THAT YEST(.) CALCULATED ABOVE ARE THE NOMINAL VALUES OF
C  THE Y'S TO BE USED IN THE CALCULATION OF RINV BELOW.



      NDEX = 0

      DO IEQ = 1,NUMEQT
       DO I = 1,NOBSER

        NDEX = NDEX + 1
        YY = YEST(NDEX)


      SD1 = C0(IEQ)+C1(IEQ)*YY+C2(IEQ)*YY*YY+C3(IEQ)*YY**3
      IF(IERRMOD .EQ. 1) SIGIIEQ = SD1
      IF(IERRMOD .EQ. 2) SIGIIEQ = GAMLAM*SD1
      IF(IERRMOD .EQ. 3) SIGIIEQ = DSQRT(SD1**2 + GAMLAM**2)
      IF(IERRMOD .EQ. 4) SIGIIEQ = GAMLAM


C  NOTE: MUST ENSURE THAT ALL THE STD DEV'S ARE .GE. 0. OTHERWISE,
C  RETURN WITH A LARGE (UNATTRACTIVE) VALUE FOR FNTVAL ... SINCE THESE
C  CANDIDATES IN VEC(.) PRODUCED A YY WHICH IS INCOMPATIBLE WITH THE
C  C'S AND/OR IERRMOD/GAMLAM.

C  ACTUALLY, THERE IS A LIMIT TO HOW SMALL SIGIIEQ CAN BE SINCE IF IT
C  IS TOO SMALL, BUT STILL POSITIVE, THEN SIGIIEQ**2 CAN BE NUMERICALLY
C  EQUAL TO 0 --> RINV(.,.) BELOW WILL BE SET = INFINITY OR NaN. SO
C  ARBIRTRARILY LIMIT SIGIIEQ TO BE .GT. 1.D-100.

      IF(SIGIIEQ .LE. 1.D-100) THEN
       FNTVAL = 1.D30
       RETURN
      ENDIF
      
      RINV(NDEX,NDEX) = 1.D0/SIGIIEQ/SIGIIEQ


       END DO
C  THE ABOVE END DO IS FOR THE  DO I = 1,NOBSER LOOP.
      END DO
C  THE ABOVE END DO IS FOR THE  DO IEQ = 1,NUMEQT LOOP.



C  CALL CALCOV TO CALCULATE COVINV FROM THE ABOVE FORMULA. NOTE THAT
C  COVINV IS THE SAME AS MALF. FIRST, ESTABLISH NOBACT.

      NOBACT = NOBSER*NUMEQT

	CALL CALCOV(NVAR,NOBACT,PMAT,RINV,COVINV)

C  IF ANY DIAGONAL ENTRY OF COVINV IS .LE. 0, RETURN A LARGE POSITIVE 
C  VALUE (AN UNATTRACTIVE VALUE) FOR FNTVAL. 

      DO I=1,NVAR
       IF(COVINV(I,I) .LE. 0) THEN
        FNTVAL = 1.D30
        RETURN
       ENDIF
      END DO

C  CALCULATE THE DETERMINANT OF MALF = COVINV.
 
      CALL MATNV2(COVINV,NVAR,B,1,DET)

C  IF DET IS .LE. 0, RETURN A LARGE POSITIVE VALUE FOR FNTVAL. 
C  OTHERWISE, FNTVAL WILL BE -DET.

      FNTVAL = -DET

      IF(DET .LE. 0) THEN
       FNTVAL = 1.D30
      ENDIF


	RETURN
	END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
      SUBROUTINE FILRED(NVAR,NOBSER,NOBSERORIG,YO,C0,C1,C2,C3,NUMEQT,
     1 TIMM)


C  FILRED IS CALLED BY MAIN TO READ THE PORTION OF 
C  SCRATCH FILE 27 WHICH APPLIES TO THE SUBJECT UNDER CONSIDERATION. THE

C  'POINTER' FOR FILE 27 IS IN THE PROPER POSITION TO BEGIN READING THE
C  INFO FOR THE DESIRED SUBJECT.

        IMPLICIT REAL*8(A-H,O-Z)

        PARAMETER(MAXNUMEQ=7)

        DIMENSION TIM(594),SIG(5000),RS(5000,34),YO(594,MAXNUMEQ),
     1  BS(5000,7),C0(MAXNUMEQ),C1(MAXNUMEQ),C2(MAXNUMEQ),C3(MAXNUMEQ),
     2  YOO(594,MAXNUMEQ),TIMM(594)


c  AS OF it2beng15.f, THE FORMAT FOR THE WORKING COPY FILES IS:

C     COL 1 = TIME
C     COL 2 = IV FOR DRUG 1; COL 3 = PO FOR DRUG 1;
C     COL 4 = IV FOR DRUG 2; COL 5 = PO FOR DRUG 2;
C     ... EACH SUCCEEDING DRUG HAS AN IV FOLLOWED BY A PO COLUMN.
C     NEXT NADD COLUMNS = ONE FOR EACH ADDITIONAL COVARIATE (ADDITIONAL
C      REFERS TO ANY EXTRA COVARIATES BEYOND THE 4 PERMANENT ONES IN
C      COMMON DESCR (SEE BELOW).
 
        COMMON /OBSER/ TIM,SIG,RS,YOO,BS
        COMMON /CNST/ N,ND,NI,NUP,NUIC,NP
        COMMON /CNST2/ NPL,NUMEQTT,NDRUG,NADD
        COMMON /SUM2/ M,NPNL
        COMMON/DESCR/AGE,HEIGHT,ISEX,IETHFLG
        COMMON/ERR/ERRFIL

        CHARACTER SEX*1,READLINE*300,ERRFIL*20

 
C  INPUT IS: SCRATCH FILE 27, WHICH IS POSITIONED AT THE BEGINNING OF
C  THE INFO FOR THE SUBJECT DESIRED.
 
C  OUTPUT ARE:
 
C  NOBSER = THE NO. OF OBSERVATIONS FOR THIS SUBJECT.
C  YO(I,J),I=1,M; J=1,NUMEQT = NO. OF OUTPUT EQS; I=1,M, WHERE M = NO.
C	OF OBSERVATION TIMES.
C  [C0(J),C1(J),C2(J),C3(J)] = ASSAY NOISE COEFFICIENTS FOR OUTPUT EQ.
C	J; J=1,NUMEQT.
C  THE 4 DESCRIPTOR VALUES FOR THIS SUBJECT (AGE, SEX, HEIGHT,
C    ETHNICITY FLAG) VIA COMMON/DESCR TO SUBROUTINES DIFFEQ/OUTPUT.
C  VARIABLES/ARRAYS IN ABOVE COMMON STATEMENTS.
 
 
C  AGE, SEX, HEIGHT, AND ETHNICITY FLAG ARE ON LINES 8-11.
 
        DO I=1,7
         READ(27,*)
        END DO
	
        READ(27,*) AGE
        READ(27,2) SEX
    2   FORMAT(A1)
        ISEX=1

        IF(SEX .EQ. 'F') ISEX=2
        READ(27,*) HEIGHT
        READ(27,*) IETHFLG
 
C  READ THE NO. OF DRUGS FROM THE LINE WITH 'NO. OF DRUGS' AS ENTRIES
C  12:23. THEN READ NO. OF ADDITIONAL COVARIATES, AND THE NO. OF DOSE 
C  EVENTS, ETC.

    1   FORMAT(A300)
   10	  READ(27,1) READLINE
        IF(READLINE(12:23) .NE. 'NO. OF DRUGS') GO TO 10

        BACKSPACE(27)

    3   FORMAT(T2,I5)
        READ(27,3) NDRUG

        IF(NDRUG .GT. 7) THEN
         WRITE(*,124)
  124    FORMAT(' YOUR PATIENT DATA FILES CANNOT HAVE MORE THAN 7'/
     1' DRUGS. THE PROGRAM IS NOW STOPPING. '/)

C  SINCE THE PROGRAM IS TERMINATING ABNORMALLY, WRITE THE ERROR MESSAGE
C  TO ERRFIL ALSO.

        OPEN(42,FILE=ERRFIL)


         WRITE(42,124) 
        CLOSE(42)

         CALL PAUSE


         STOP
        ENDIF

        READ(27,3) NADD

C  NOTE THAT THE NO. OF "RATES" INCLUDES 2 FOR EACH DRUG (THE IV AND
C  THE PO COLUMNS) + NADD (1 COLUMN FOR EACH ADDITIONAL COVARIATE).

       NI = 2*NDRUG + NADD

        IF(NI .GT. 34) THEN
         WRITE(*,123)
  123    FORMAT(/' YOUR PATIENT DATA FILES HAVE TOO MANY COLUMNS IN '/
     1' THE DOSAGE REGIMEN BLOCK. THE NO. OF ADDITIONAL COVARIATES '/

     2' PLUS TWICE THE NO. OF DRUGS CANNOT EXCEED 34. THE PROGRAM IS'/
     3' NOW STOPPING. '/)

C  SINCE THE PROGRAM IS TERMINATING ABNORMALLY, WRITE THE ERROR MESSAGE
C  TO ERRFIL ALSO.

        OPEN(42,FILE=ERRFIL)
         WRITE(42,123) 
        CLOSE(42)


         CALL PAUSE
         STOP
        ENDIF

        READ(27,3) ND

        IF(ND .GT. 5000) THEN
         WRITE(*,125)
  125    FORMAT(' YOUR PATIENT DATA FILES CANNOT HAVE MORE THAN 5000'/
     1' DOSE EVENTS. THE PROGRAM IS NOW STOPPING. '/)

C  SINCE THE PROGRAM IS TERMINATING ABNORMALLY, WRITE THE ERROR MESSAGE
C  TO ERRFIL ALSO.

        OPEN(42,FILE=ERRFIL)
         WRITE(42,125) 
        CLOSE(42)

         CALL PAUSE
         STOP
        ENDIF

        READ(27,*)
        READ(27,*)

        IF(ND.EQ.0) GO TO 40

        DO I = 1,ND
         READ(27,*) SIG(I),(RS(I,J),J=1,NI)
        END DO	 

C  ASSIGN THE VALUES IN EACH DRUG'S PO COLUMN TO THE CORRESPONDING
C  COLUMN IN ARRAY BS.

        DO I=1,ND
         DO J=1,NDRUG
          BS(I,J)=RS(I,2*J)
         END DO
        END DO


C  READ THE NO. OF OUTPUT EQUATIONS FROM THE LINE WITH 'NO. OF TOTAL'
C  AS ENTRIES 12:23. THEN READ NO. OF OBSERVED VALUE TIMES, ETC.

   40	  READ(27,1) READLINE
        IF(READLINE(12:23) .NE. 'NO. OF TOTAL') GO TO 40
        BACKSPACE(27)

        READ(27,3) NUMEQT

C  SET NUMEQTT TO NUMEQT, SINCE A COMMON ARGUMENT CANNOT BE THE SAME
C  AS A CALLING ARGUMENT, AND NUMEQTT MUST BE ESTABLISHED SO IT CAN
C  BE PASSED IN COMMON/CNST2 ABOVE.

        NUMEQTT = NUMEQT

        READ(27,3) NOBSER

        MAXOBDIM = 150
        IF(NOBSER .GT. MAXOBDIM) THEN
         WRITE(*,126) MAXOBDIM
  126    FORMAT(/' AT LEAST ONE OF YOUR PATIENT DATA FILES HAS TOO'/
     1' MANY OBSERVED VALUE TIMES. THIS NO. CANNOT EXCEED ',I5,'.'/
     2' THE PROGRAM IS NOW STOPPING. '/)

C  SINCE THE PROGRAM IS TERMINATING ABNORMALLY, WRITE THE ERROR MESSAGE
C  TO ERRFIL ALSO.

        OPEN(42,FILE=ERRFIL)
         WRITE(42,126) MAXOBDIM
        CLOSE(42)

         CALL PAUSE
         STOP
        ENDIF


        DO I = 1,NOBSER
         READ(27,*) TIM(I),(YO(I,J),J=1,NUMEQT)
         TIMM(I) = TIM(I)
C  TIMM(.) IS SET = TIM(.), AS ONE IS PASSED IN COMMON, AND ONE IS

C  A CALLING ARGUMENT.
        END DO
 
C  PUT YO VALUES INTO YOO BECAUSE A DUMMY ARGUMENT CANNOT BE IN A
C  COMMON STATEMENT.
 
        DO I = 1,NOBSER
         DO J=1,NUMEQT
          YOO(I,J) = YO(I,J)
         END DO
        END DO

C  SAVE NOBSER TO NOBSERORIG. IT WILL BE NEEDED BACK IN MAIN TO SEE
C  IF NOBSER WAS INCREASED BELOW.

      NOBSERORIG = NOBSER

C  AS OF dopteng5.f, IF NOBSER .LT. NVAR, MUST ADD IN AN EXTRA 
C  NOBSER - NVAR OBS. TIMES (SEE NOTES AT THE TOP OF dopteng5.f FOR 
C  THE REASON), AND THEN RESET NOBSER = NVAR.

C  NOTE THAT THE ACTUAL ADDED TIMES ARE NOT IMPORTANT, AS LONG AS THEY
C  ARE IN ORDER AND .LT. THE ORIGINAL MAX. OBS. TIME. ALSO NOTE THAT 
C  THE OBSERVED VALUES THEMSELVES ARE NOT NEEDED IN THIS PROGRAM, SO 
C  YO() AND YOO() DO NOT NEED TO HAVE EXTRA VALUES ADDED TO THEM.

        IF(NOBSER .LT. NVAR) THEN

C  INSTEAD OF NOBSER OBS. TIMES, THERE WILL NOW BE NVAR OBS. TIMES.
C  SINCE THE ACTUAL TIMES DON'T MATTER IN THIS PROGRAM, EXCEPT FOR
C  THE MAX. OBS. TIME AND THE MIN OBS. TIME, SET THESE TIMES TO BE 
C  EQUALLY SPACED BETWEEN THE MIN. TIME OF TIM(1) AND THE MAX. TIME 
C  OF TIM(NOBSER).

         TIMMAX = TIM(NOBSER)
         TIMMIN = TIM(1)
         DELTA = (TIMMAX - TIMMIN)/(NVAR-1)

         DO I = 1,NVAR
          TIM(I) = TIMMIN + (I-1)*DELTA
          TIMM(I) = TIM(I)
         END DO

C  JUST IN CASE OF ROUNDTOP, RESET TIM(NVAR) = TIMMAX

         TIM(NVAR) = TIMMAX
         TIMM(NVAR) = TIM(NVAR)

         NOBSER = NVAR

        ENDIF 
C  THE ABOVE ENDIF IS FOR THE  IF(NOBSER .LT. NVAR)  CONDITION.
          
C  MUST ESTABLISH M SINCE IT IS USED IN COMMON/SUM2.

      M = NOBSER
 
C  AT THIS POINT, MUST SKIP THE COVARIATE INFO IN THE FILE, AND PROCEED
C  TO READ THE ASSAY NOISE COEFFICIENTS BELOW THAT.
 
C  READ THE NUMEQT SETS OF ASSAY COEFFICIENTS JUST BELOW THE LINE
C  WHICH HAS "ASSAY COEFFICIENTS FOLLOW" IN ENTRIES 1:25.

   50	  READ(27,1) READLINE
        IF(READLINE(1:25) .NE. 'ASSAY COEFFICIENTS FOLLOW') GO TO 50

        DO IEQ = 1,NUMEQT
         READ(27,*) C0(IEQ),C1(IEQ),C2(IEQ),C3(IEQ)
        END DO
 

        RETURN
        END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
	SUBROUTINE CALCOV(NVAR,NOBACT,PMAT,RINV,COVINV)
	IMPLICIT REAL*8(A-H,O-Z)
	DIMENSION PMAT(594,30),COVINV(30,30),RINV(594,594),
     1  PMATT(30,594),WORK(30,594)

C  THIS SUBROUTINE, CALLED BY MAIN, CALCULATES COVINV WHERE COVINV 
C  = INV(COVEST), AND COVEST = THE ESTIMATE OF THE COVARIANCE MATRIX OF 
C  THE PARAMETER ESTIMATES. 

C  COVEST = INV[PMAT'*RINV*PMAT]; SO COVINV = PMAT'*RINV*PMAT, 
C           WHERE PMAT' = PMAT TRANSPOSE.


C  INPUT ARE:


C  NVAR,NOBACT = DIMENSIONS.
C  PMAT = NOBACT x NVAR MATRIX DESCRIBED IN MAIN.
C  RINV = NOBACT x NOBACT MATRIX.

C  OUTPUT IS:

C  COVINV = NVAR x NVAR MATRIX DEFINED ABOVE.


C ESTABLISH PMATT = PMAT TRANSPOSE.

	DO I=1,NOBACT
	 DO J=1,NVAR
	  PMATT(J,I)=PMAT(I,J)
	 END DO
	END DO

C  CALL MULT1 TO OBTAIN WORK = PMATT*RINV.

	CALL MULT1(NVAR,NOBACT,NOBACT,PMATT,RINV,WORK)

C  CALL MULT2 TO OBTAIN WORK*PMAT = COVINV. 

	CALL MULT2(NVAR,NOBACT,NVAR,WORK,PMAT,COVINV) 

	RETURN
	END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
	SUBROUTINE MULT1(N1,N2,N3,A,B,C)
	IMPLICIT REAL*8(A-H,O-Z)
	DIMENSION A(30,594),B(594,594),C(30,594)

C  THIS SUBROUTINE, CALLED BY SUBROUTINE CALCOV, INPUTS MATRICES A,B,
C  AND C, AND RETURNS C=A*B, WHERE A IS N1 x N2, B IS N2 x N3, AND
C  C IS N1 x N3.

	DO I=1,N1
	 DO J=1,N3
	  SUM=0.D0
	   DO K=1,N2
            SUM=SUM+A(I,K)*B(K,J)
	   END DO
	  C(I,J)=SUM
	 END DO

	END DO

	RETURN
	END

C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C

	SUBROUTINE MULT2(N1,N2,N3,A,B,C)
	IMPLICIT REAL*8(A-H,O-Z)
	DIMENSION A(30,594),B(594,30),C(30,30)

C  THIS SUBROUTINE, CALLED BY SUBROUTINE CALCOV, INPUTS MATRICES A,B,
C  AND C, AND RETURNS C=A*B, WHERE A IS N1 x N2, B IS N2 x N3, AND

C  C IS N1 x N3.

	DO I=1,N1
	 DO J=1,N3
	  SUM=0.D0
	   DO K=1,N2
            SUM=SUM+A(I,K)*B(K,J)
	   END DO
	  C(I,J)=SUM
	 END DO
	END DO

	RETURN
	END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
      SUBROUTINE MATNV2(A,N,B,M,DETERM) 
      IMPLICIT REAL*8(A-H,O-Z)


C MATRIX INVERSION WITH ACCOMPANYING SOLUTION OF LINEAR EQUATIONS

C  THIS IS THE DOUBLE PRECISION VERSION OF MATINV; IT IS CALLED BY

C  SUBROUTINE DOPTTIM. 
C
      DIMENSION PIVOT(100),INDEX(100)
C
C  NOTE: A HAS RANK N (I.E., THE NON-ZERO PART OF A IS AN N x N MATRIX).
C        M WILL = 1    FOR CALLS FROM CALCOV.     
C   
C  THE DIMENSIONS OF A AND B BELOW HAVE BEEN CHANGED TO MAKE THIS
C  PROGRAM COMPATIBLE WITH THE CALLING PROGRAM. 

      DIMENSION A(30,30),B(30,1)
      DATA DETMAX,DETMIN/1.0D+30,1.0D-30/

C
C     INITIALIZE DETERMINANT AND PIVOT ELEMENT ARRAY
C
      DETERM=1.D0
      IDET=0
C
      DO 20 I=1,N
      PIVOT(I)=0.D0
   20 INDEX(I)=0.0
C
C     PERFORM SUCCESSIVE PIVOT OPERATIONS (GRAND LOOP)
C
      DO 550 I=1,N
C
C     SEARCH FOR PIVOT ELEMENT AND EXTEND DETERMINANT PARTIAL PRODUCT
C
      AMAX=0.D0
      DO 105 J=1,N
      IF (PIVOT(J).NE.0.D0) GO TO 105
      DO 100 K=1,N
      IF (PIVOT(K).NE.0.D0) GO TO 100
      TEMP=ABS(A(J,K))
      IF (TEMP.LT.AMAX) GO TO 100
      IROW=J
      ICOLUM=K
      AMAX=TEMP
  100 CONTINUE
  105 CONTINUE
      INDEX(I)=4096*IROW+ICOLUM
      J=IROW
      AMAX=A(J,ICOLUM)
      DETERM=AMAX*DETERM
      IF (ABS(DETERM).LT.DETMAX) GO TO 130
C
      DETERM=DETERM*DETMIN
C
      IDET=IDET+1
C
      GO TO 140
C 
  130 IF (ABS(DETERM).GT.DETMIN) GO TO 140
C
      DETERM=DETERM*DETMAX
C
      IDET=IDET-1
C
  140 CONTINUE
C
C

C     RETURN IF MATRIX IS SINGULAR (ZERO PIVOT) AFTER COLUMN INTERCHANGE
C
      IF (DETERM.EQ.0.D0) GO TO 600
C
      PIVOT(ICOLUM)=AMAX
C
C     INTERCHANGE ROWS TO PUT PIVOT ELEMENT ON DIAGONAL
C

      IF (IROW.EQ.ICOLUM) GO TO 260
      DETERM=-DETERM
      DO 200 K=1,N
      SWAP=A(J,K)
      A(J,K)=A(ICOLUM,K)
      A(ICOLUM,K)=SWAP
  200 CONTINUE
      IF (M.LE.0) GO TO 260
      DO 250 K=1,M

      SWAP=B(J,K)
      B(J,K)=B(ICOLUM,K)
      B(ICOLUM,K)=SWAP
  250 CONTINUE
C
C     DIVIDE PIVOT ROW BY PIVOT ELEMENT
C
  260 K=ICOLUM
      A(ICOLUM,K)=1.D0
      DO 350 K=1,N
      A(ICOLUM,K)=A(ICOLUM,K)/AMAX
  350 CONTINUE
      IF (M.LE.0) GO TO 380
      DO 370 K=1,M
      B(ICOLUM,K)=B(ICOLUM,K)/AMAX
  370 CONTINUE
C
C     REDUCE NON-PIVOT ROWS
C
  380 DO 550 J=1,N
      IF (J.EQ.ICOLUM) GO TO 550
      T=A( J,ICOLUM)
      A( J,ICOLUM)=0.D0
      DO 450 K=1,N
      A( J,K)=A( J,K)-A(ICOLUM,K)*T
  450 CONTINUE
      IF (M.LE.0) GO TO 550
      DO 500 K=1,M
      B( J,K)=B( J,K)-B(ICOLUM,K)*T
  500 CONTINUE
  550 CONTINUE

C

C     INTERCHANGE COLUMNS AFTER ALL PIVOT OPERATIONS HAVE BEEN PERFORMED
C
  600 DO 710 I=1,N
      I1=N+1-I
      K=INDEX(I1)/4096
      ICOLUM=INDEX(I1)-4096*K
      IF (K.EQ.ICOLUM) GO TO 710
      DO 705 J=1,N
      SWAP=A(J,K)
      A(J,K)=A(J,ICOLUM)
      A(J,ICOLUM)=SWAP
  705 CONTINUE
  710 CONTINUE
C
      PIVOT(1)=IDET

C 
      RETURN
      END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
	SUBROUTINE EQUIV(INUM,NAME)

	CHARACTER*1 A,B,C,D
	CHARACTER NAME*4

C  THIS SUBROUTINE, CALLED BY MAIN, INPUTS INTEGER INUM, AND RETURNS THE
C  4-CHARACTER EQUIVALENT IN NAME.

	I4 = INUM/1000
	ILEFT = INUM - I4*1000

	I3 = ILEFT/100
	ILEFT = ILEFT - I3*100
	I2 = ILEFT/10
 	ILEFT = ILEFT - I2*10
	I1 = ILEFT

C  CONVERT THIS TO THE CHARACTER EQUIVALENT. 

	IF(I4 .EQ. 1) A='1'
	IF(I4 .EQ. 2) A='2'
	IF(I4 .EQ. 3) A='3'
	IF(I4 .EQ. 4) A='4'
	IF(I4 .EQ. 5) A='5'
	IF(I4 .EQ. 6) A='6'
	IF(I4 .EQ. 7) A='7'
	IF(I4 .EQ. 8) A='8'
	IF(I4 .EQ. 9) A='9'
	IF(I4 .EQ. 0) A='0'


	IF(I3 .EQ. 1) B='1'
	IF(I3 .EQ. 2) B='2'
	IF(I3 .EQ. 3) B='3'

	IF(I3 .EQ. 4) B='4'
	IF(I3 .EQ. 5) B='5'
	IF(I3 .EQ. 6) B='6'
	IF(I3 .EQ. 7) B='7'
	IF(I3 .EQ. 8) B='8'
	IF(I3 .EQ. 9) B='9'
	IF(I3 .EQ. 0) B='0'

	IF(I2 .EQ. 1) C='1'
	IF(I2 .EQ. 2) C='2'
	IF(I2 .EQ. 3) C='3'
	IF(I2 .EQ. 4) C='4'
	IF(I2 .EQ. 5) C='5'
	IF(I2 .EQ. 6) C='6'
	IF(I2 .EQ. 7) C='7'
	IF(I2 .EQ. 8) C='8'
	IF(I2 .EQ. 9) C='9'
	IF(I2 .EQ. 0) C='0'

	IF(I1 .EQ. 1) D='1'
	IF(I1 .EQ. 2) D='2'
	IF(I1 .EQ. 3) D='3'
	IF(I1 .EQ. 4) D='4'
	IF(I1 .EQ. 5) D='5'
	IF(I1 .EQ. 6) D='6'
	IF(I1 .EQ. 7) D='7'
	IF(I1 .EQ. 8) D='8'
	IF(I1 .EQ. 9) D='9'
	IF(I1 .EQ. 0) D='0'

	NAME = A//B//C//D

	RETURN
	END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
	SUBROUTINE MAKEVEC(NVAR,NOFIX,IRAN,X,VALFIX,PX)
	IMPLICIT REAL*8(A-H,O-Z)
	DIMENSION IRAN(32),X(30),VALFIX(20),PX(32)

C  THIS ROUTINE, CALLED BY MAIN, INPUTS NVAR, NOFIX, IRAN, X, AND
C  VALFIX, AND RETURNS PX(I) = A COMBINATION OF THE VALUES IN X AND
C  VALFIX IN THE PROPER ORDER (AS DETERMINED BY IRAN).

	NNNVAR=0
	NNNFIX=0

	DO I=1,NVAR+NOFIX

	IF(IRAN(I) .EQ. 1 .OR. IRAN(I) .EQ. -1) THEN
	 NNNVAR=NNNVAR+1
	 PX(I) = X(NNNVAR)
	ENDIF

	IF(IRAN(I) .EQ. 0) THEN
	 NNNFIX=NNNFIX+1
	 PX(I) = VALFIX(NNNFIX)
	ENDIF

	END DO

	RETURN
	END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
        SUBROUTINE PAUSE

C  THIS ROUTINE IS USED TO REPLACE A PAUSE STATEMENT, WHICH CAUSES 
C  WARNINGS WHEN THIS PROGRAM IS COMPILED AND LINKED USING gfortran
C  (AND FORCES THE USER TO TYPE "go" INSTEAD OF SIMPLY HITTING THE
C  ENTER KEY).

        WRITE(*,1)
    1   FORMAT(' HIT ANY KEY TO CONTINUE: ')
        READ(*,*,ERR=10) IKEY
        IF(IKEY .EQ. 1) RETURN
   10   RETURN
        END

C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
      SUBROUTINE NEWWORK1(JSUB)

      IMPLICIT REAL*8(A-H,O-Z)
      PARAMETER(MAXNUMEQ=7)
      DIMENSION SIG(5000),RS(5000,34),DELTAIV(7),ORDELT(7),
     1 RSS(5000,34),SIGG(5000),TIM(594),TIMM(594),YO(594,MAXNUMEQ),

     2 TIMDELAY(99),OBSBLOCK(800,150,MAXNUMEQ+1),
     3 DOSEBLOCK(800,1000,35),NDORIG(800),XVERIFY(100)

      CHARACTER READLINE*300,ERRFIL*20

   	COMMON/DOSEOBS/DOSEBLOCK,OBSBLOCK,NDORIG
      COMMON/ERR/ERRFIL 

C  SUBROUTINE NEWWORK1 (BASED ON THE STAND-A-LONE VERSION OF THE SAME
C  NAME) READS IN A WORKING COPY PATIENT DATA FILE, AND OUTPUTS ANOTHER
C  FILE WHICH IS:

C  a. EXACTLY THE SAME IF THE ORIGINAL FILE HAS NO STEADY STATE DOSE
C     INDICATORS;

C  OR

C  b. ALTERED TO HAVE THE SAME INFO AS IN THE ORIGINAL FILE, BUT ALSO
C     CONTAINING AN EXTRA 101 DOSES FOR EACH STEADY STATE DOSE 
C     INDICATOR.




C  NOTES:

C  1. A STEADY STATE DOSE INDICATOR IS A NEGATIVE VALUE IN THE TIME
C  ENTRY FOR A DOSE. THIS IS ACCOMPANIED BY INFORMATION ON THE SET OF
C  DOSES IN THE IV AND BOLUS ENTRIES, AS THE FOLLOWING EXAMPLE SHOWS:

C   Time    IV     Bolus
C   -2.0   100.0   150.0 ...

C  THE ABOVE LINE WOULD TELL THE PROGRAM:

C  a. THAT THIS WAS INFO ON 101 STEADY STATE DOSES BECAUSE OF THE 
C     NEGATIVE TIME VALUE;
C  b. THE TIME BETWEEN CONSECUTIVE IV START TIMES = 2 HOURS, BECAUSE 
C     THIS IS THE ABS. VALUE OF THE TIME;
C  C. THE IV RATE = 100MG/HOUR;
C  D. THE TOTAL DRUG AMT. FOR EACH IV DOSE IS 150MG.


C  SO THE PROGRAM WOULD THEN ADD 101 DOSES TO THE PATIENT DATA FILE,
C  STARTING AT T = 0, EACH WITH AN IV RATE = 100, AND CONTINUING FOR
C  1.5 HOURS.

C  2. IT WILL BE ASSUMED THAT EACH STEADY STATE DOSE INDICATOR ALWAYS
C  WILL BE REPLACED BY 101 IV DOSES (NOT BOLUS DOSES).
C  AS OF it2beng19.f, STEADY STATE DOSES MAY BE BOLUS DOSES. IN THIS
C  CASE, THE IV RATE WILL BE 0.0 OF COURSE.

C  3. ALL OTHER TIMES IN THE PATIENT DATA FILE (UP TO THE NEXT TIME 
C  RESET IF THERE IS ONE) WILL BE ASSUMED TO BE TIMES FROM THE END OF 
C  THE 100TH DOSE INTERVAL (NOT THE 101ST). IN THE ABOVE EXAMPLE, THE
C  100TH DOSE INTERVAL WOULD END AT T = 200 (THE 101ST IV ITSELF WOULD
C  END AT T = 201.5, BUT THE 100TH DOSE INTERVAL WOULD END AT T = 200).
C  SO ALL OTHER TIMES IN THE DOSAGE AND OBSERVATION BLOCKS WOULD HAVE
C  200 ADDED TO THEIR VALUES.

C  4. THE ABOVE EXAMPLE IS FOR ONE DRUG ONLY, BUT ANY OR ALL OF THE
C  NDRUGS IN A PATIENT'S FILE CAN HAVE STEADY STATE DOSES. ANY DRUG
C  WHICH HAS A NON-0 VALUE IN THE BOLUS COLUMN OF A STEADY STATE DOSE
C  LINE (I.E., ONE WITH TIME < 0) WILL PARTICIPATE IN A STEADY STATE
C  DOSE SET, GETTING THAT AMOUNT OF DRUG IN EACH OF THE 101 DOSES. IF
C  THE IV COLUMN IS > 0, THEN THE DRUG WILL BE GIVEN AT THE RATE 

C  SHOWN IN THE IV COLUMN. IF THE IV COLUMN IS 0, THEN THE DRUG WILL
C  BE GIVEN AS A BOLUS.

C  5. THE 101 STEADY STATE DOSES CAN BE GIVEN AS THE FIRST SET OF DOSES
C  IN A PATIENT'S FILE, AS INDICATED ABOVE, OR AT ANY TIME RESET. IF
C  THEY ARE AT A TIME RESET, ALL THE SUBSEQUENT TIMES AFTER THAT TIME
C  RESET (UP TO THE NEXT TIME RESET IF THERE IS ONE) ARE ADJUSTED AS 
C  INDICATED ABOVE TO BE TIMES AFTER THE END OF THE 100TH DOSE SET.



C-----------------------------------------------------------------------

C  FILE 23 WAS OPENED IN MAIN AND THE POINTER IS AT THE TOP OF A PATIENT
C  WHOSE INFO IS TO BE PUT ONTO FILE 27. BUT IT WILL NOT BE PUT ON TO
C  FILE 27 UNTIL THE DOSE BLOCK OF FILE 23 HAS BEEN READ ... AND 
C  EXAMINED TO SEE IF IT HAS A STEADY STATE DOSE INDICATOR. IF IT DOES,
C  IT MEANS THAT THIS PART OF FILE 27 WILL HAVE AN EXTRA SET OF 101
C  DOSES FOR EACH DRUG.

 1717 FORMAT(A300)

   10 READ(23,1717) READLINE
      IF(READLINE(12:23) .NE. 'NO. OF DRUGS') GO TO 10


C  READLINE NOW CONTAINS THE NO. OF DRUGS, NDRUG. BACKSPACE AND READ
C  NDRUG; THEN READ THE NO. OF ADDITIONAL COVARIATES, AND THE NO. OF
C  DOSE EVENTS. 

    3 FORMAT(T2,I5)

      BACKSPACE(23)
      READ(23,3) NDRUG
      READ(23,3) NADD
      READ(23,3) ND
	NI = 2*NDRUG + NADD


C  IF THERE ARE NO DOSE EVENTS (ND = 0), THE INFO ON FILE 27 WILL BE THE
C  SAME AS ON FILE 23 (SINCE THERE CAN BE NO STEADY STATE DOSE EVENTS IF
C  THERE ARE NO DOSES). IN THIS CASE, SET ICOPY = 1 (SEE BELOW).


      IF(ND .EQ. 0) ICOPY = 1

C  IF ANY SIG(.) IS NEGATIVE, SET ICOPY = 0 SINCE A SIG(.) < 0 IS THE
C  INDICATOR FOR A STEADY STATE SET OF DOSES.


      IF(ND .GE. 1) THEN

       READ(23,*)
       READ(23,*)

       ICOPY = 1

C  As of it2beng20.f, STORE ND INTO NDORIG(JSUB); IT WILL BE PASSED
C  TO SUBROUTINE READOUT VIA COMMON/DOSEOBS.

       NDORIG(JSUB) = ND

       DO I = 1,ND

        READ(23,*) SIG(I),(RS(I,J),J=1,NI)

C  AS OF it2beng20.f, STORE THE VALUES IN THE DOSE BLOCK FOR PASSAGE
C  TO SUBROUTINE READOUT VIA COMMON/DOSEOBS.

C  AS OF it2beng21.f, RATHER THAN USING BACKSPACE(23), ESTABLISH
C  DOSEBLOCK BY STRAIGHTFORWARD ASSIGNMENTS. THE REASON IS THAT,
C  DEPENDING ON WHICH COMPILER IS USED TO MAKE THE PR PREP PROGRAM
C  (CURRENT ONE IS IT2B107.FOR), IT IS POSSIBLE FOR A DOSE EVENT
C  TO LOOK LIKE SEVERAL LINES RATHER THAN ONE LONG WORD-WRAPPED LINE.
C  IN THE FORMER CASE, BACKSPACING ONE LINE WILL NOT BACKSPACE TO THE
C  BEGINNING OF THE DOSE EVENT AS SHOULD BE DONE. SO TO BE SAFE, THE

C  LOGIC TO USE BACKSPACE(23) WILL BE COMMENTED OUT, AND 
C  DOSEBLOCK(.,.,.) WILL BE ESTABLISHED DIRECTLY.

        DOSEBLOCK(JSUB,I,1) = SIG(I)
        DO J = 2,1+NI
         DOSEBLOCK(JSUB,I,J) = RS(I,J-1)
        END DO
        
C        BACKSPACE(23)
C        READ(23,*) (DOSEBLOCK(JSUB,I,J),J=1,1+NI)

        IF(SIG(I) .LT. 0.D0) ICOPY = 0

       END DO

      ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(ND .GE. 1)  CONDITION.


C  AS OF it2beng20.f, STORE IN THE VALUES IN THE OBSERVATION BLOCK FOR
C  PASSAGE TO SUBROUTINE READOUT VIA COMMON DOSEOBS.

  140	 READ(23,1717) READLINE
       IF(READLINE(12:23) .NE. 'NO. OF TOTAL') GO TO 140

       BACKSPACE(23)

       READ(23,3) NUMEQT
       READ(23,3) M

       DO I = 1,M
        READ(23,*) (OBSBLOCK(JSUB,I,J),J=1,1+NUMEQT)

       END DO

  
C  IF ICOPY = 1, IT MEANS THAT THIS PATIENT DATA FILE DOES NOT HAVE
C  A STEADY STATE DOSE SET, WHICH MEANS THAT THIS PART OF FILE 23 WILL 
C  BE COPIED LINE FOR LINE TO FILE 27 BELOW.

      IF(ICOPY .EQ. 1) THEN

C  COPY FILE 23 TO FILE 27,LINE FOR LINE.

C  BACKSPACE FILE 23 TO THE FIRST LINE FOR THIS PATIENT.

 1720  BACKSPACE(23)
       BACKSPACE(23)
       READ(23,1717,IOSTAT=IEND) READLINE

	 IF(IEND .LT. 0) THEN


C  NOTE THAT IEND .LT. 0 --> END OF FILE REACHED, BUT IF IT'S REACHED
C  AT THIS POINT, NOT ALL "ACTIVE" NSUB SUBJECT DATA SETS WERE READ
C  AND WRITTEN CORRECTLY TO FILE 27. IN THIS CASE, WRITE A MESSAGE TO
C  THE USER AND STOP.

        WRITE(*,1721)
 1721   FORMAT(/' PATIENT DATA INFORMATION WAS NOT READ CORRECTLY'/
     1' FROM THE INSTRUCTION FILE, it2b101.inp. IF YOU EDITED THIS'/
     2' FILE MANUALLY, PLEASE RERUN THE PC PREP PROGRAM TO HAVE IT'/
     3' PREPARE it2b101.inp AGAIN AND THEN RERUN THIS PROGRAM.'//
     4' IF YOU DID NOT MANUALLY EDIT it2b101.inp, PLEASE SEND THE'/
     5' DETAILS OF THIS RUN (STARTING WITH THE PC PREP EXECUTION) TO'/
     5' THE LAPK. '//
     6' THANK YOU.'/)

C  SINCE THE PROGRAM IS TERMINATING ABNORMALLY, WRITE THE ERROR MESSAGE
C  TO ERRFIL ALSO.

        OPEN(42,FILE=ERRFIL)
         WRITE(42,1721) 
        CLOSE(42)

	  CALL PAUSE
	  STOP

	 ENDIF

       IF(READLINE(3:16) .NE. 'LAST AND FIRST') GO TO 1720

       WRITE(27,1717) READLINE
     
   30  READ(23,1717) READLINE
       WRITE(27,1717) READLINE
   
       IF(READLINE(12:23) .NE. 'NO. OF DOSE ') GO TO 30

C  THE LINE JUST WRITTEN TO FILE 27 IS THE NO. OF DOSE EVENTS LINE.
C  WRITE THE NEXT TWO LINES ALSO.

       DO I = 1,2
        READ(23,1717) READLINE
        WRITE(27,1717) READLINE
       END DO

C  IF ND = 0, SKIP TO THE OUTPUT SECTION. OTHERWISE, WRITE THE DOSAGE
C  REGIMEN TO FILE 27.

       IF(ND.EQ.0) GO TO 40

       DO I = 1,ND
        READ(23,*) SIG(I),(RS(I,J),J=1,NI)
        WRITE(27,*) SIG(I),(RS(I,J),J=1,NI)
       END DO

C  READ THE NO. OF OUTPUT EQUATIONS FROM THE LINE WITH 'NO. OF TOTAL'
C  AS ENTRIES 12:23. THEN READ NO. OF OBSERVED VALUE TIMES, ETC., AND
C  WRITE THE REST OF THE FILE 23 TO FILE 27.

   40	 READ(23,1717) READLINE
       WRITE(27,1717) READLINE

       IF(READLINE(12:23) .NE. 'NO. OF TOTAL') GO TO 40

       BACKSPACE(23)

C  SINCE NUMEQT IS READ IN ABOVE, IT DOES NOT HAVE TO BE READ IN HERE.
C  JUST READ(23,*) ON NEXT LINE. FOR THAT MATTER, COULD HAVE USED
C  ANOTHER READ(23,*) ON FOLLOWING LINE SINCE M WAS READ IN ABOVE TOO.
  
       READ(23,*)
       READ(23,3) M

C  BACKSPACE JUST ONCE TO THE LINE WITH M ON IT, SINCE THE LINE WITH

C  NUMEQT ON IT WAS ALREADY PUT INTO FILE 27. 

       BACKSPACE(23)
       READ(23,1717) READLINE
       WRITE(27,1717) READLINE

       DO I = 1,M
        READ(23,*) TIM(I),(YO(I,J),J=1,NUMEQT)
        WRITE(27,*) TIM(I),(YO(I,J),J=1,NUMEQT)
       END DO

C  NOW COPY LINE FOR LINE THE REST OF THIS PATIENT'S INFO TO FILE 27.
C  THIS PATIENT'S INFO WILL END WHEN THE END OF THE FILE IS REACHED
C  (IF THIS IS THE LAST PATIENT), OR WHEN THE START OF THE NEXT
C  PATIENT OCCURS.


   50	 READ(23,1717,IOSTAT=IEND) READLINE
       IF(IEND .LT. 0) GO TO 100
   	 IF(READLINE(3:16) .EQ. 'LAST AND FIRST') GO TO 100

       WRITE(27,1717) READLINE
       GO TO 50


  100	 BACKSPACE(23)

C  FILE 23 WAS BACKSPACED ONE LINE SO THE NEXT LINE TO BE READ IN IN
C  MAIN WILL BE THE FIRST LINE OF THE NEXT SUBJECT (UNLESS THIS SUBJECT
C  IS THE LAST SUBJECT, IN WHICH CASE THE BACKSPACE WON'T MATTER).

      ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(ICOPY .EQ. 1)  CONDITION.



      IF(ICOPY .EQ. 0) THEN


C  SINCE ICOPY = 0, IT MEANS THAT THERE IS AT LEAST ONE SET OF STEADY
C  STATE DOSES IN THE DOSAGE BLOCK. THE LOGIC FOR TRANSLATING THESE
C  STEADY STATE DOSES TO A REGULAR DOSAGE BLOCK (EXCEPT FOR THE NEGATIVE
C  DOSE TIME AT THE START OF EACH STEADY STATE DOSE SET) IS AS FOLLOWS:

C  EACH DOSAGE LINE WILL BE COPIED UNALTERED UNLESS IT IS PART OF A
C  STEADY STATE SET.

C  EACH STEADY STATE SET STARTS WITH A SIG(I) < 0. IN THIS CASE, 101
C  DOSES WILL BE APPLIED AT THIS POINT WITH THE STEADY STATE DOSE FOR
C  DRUG IDRUG = RS(I,2*IDRUG), WHICH WILL BE APPLIED AS A BOLUS IF
C  RS(I,2*IDRUG-1) = 0, AND AS AN IV WITH DURATION
C  RS(I,2*IDRUG)/RS(I,2*IDRUG-1) IF RS(I,2*IDRUG-1) > 0.
C  THE REST OF THE DOSE TIMES IN THIS BLOCK OF DOSES (I.E., UNTIL THE
C  NEXT TIME RESET OR STEADY STATE DOSE INDICATOR) WILL BE INCREASED
C  BY 100*DELDOSE, WHERE DELDOSE = -SIG(I) = INTERDOSE INTERVAL FOR
C  THIS SET.


C  ILINE WILL BE THE RUNNING INDEX OF THE NEXT DOSAGE LINE TO BE PUT

C  INTO THE ALTERED DOSAGE REGIMEN. SIGG(ILINE) AND RSS(ILINE,.) ARE
C  THE VALUES THAT GO INTO THIS LINE. DELDOSE IS THE CURRENT INTERDOSE
C  TIME INTERVAL FOR THE LAST STEADY STATE SET OF DOSES ALREADY PUT
C  INTO THE ALTERED DOSAGE REGIMEN (IT IS INITIALIZED TO BE 0 OF 
C  COURSE). 

C  AND NSECTION IS INITIALIZED TO BE 0. IT WILL BE THE RUNNING NO. OF

C  DOSAGE SECTIONS. EACH SECTION BEGINS WITH EITHER A 0.0 (BEGINNING
C  LINE OR TIME RESET) OR A NEGATIVE NO. (STEADY STATE DOSE SET 
C  INDICATOR). THE TIME DELAY ASSOCIATED WITH EACH DOSE SECTION (WHICH
C  WILL BE 0 IF THAT SECTION IS NOT A STEADY STATE DOSE SET), MUST BE 
C  STORED TO BE APPLIED TO THE CORRESPONDING SET OF OBSERVED VALUES
C  BELOW.

      ILINE = 0
      DELDOSE = 0.D0
      NSECTION = 0


      DO ID = 1,ND


       IF(SIG(ID) .GE. 0.D0) THEN

        CALL THESAME(SIG(ID),0.D0,ISAME)

        IF(ISAME .EQ. 1) THEN
         DELDOSE = 0.D0
         NSECTION = NSECTION + 1
         TIMDELAY(NSECTION) = 0.0
        ENDIF   

C  NOTE THAT IF SIG(ID) = 0, THIS LINE IS A TIME RESET LINE, OR THE
C  FIRST LINE IN THE DOSAGE REGIMEN. IF IT'S THE FIRST LINE IN THE
C  DOSAGE REGIMEN, THERE ARE OBVIOUSLY NO PREVIOUS STEADY STATE DOSE
C  SETS. IF ITS A TIME RESET LINE, A PREVIOUS SET OF 101 STEADY STATE
C  DOSES HAS NO EFFECT ON IT. THAT'S WHY DELDOSE IS SET = 0, WHICH 
C  MEANS, BELOW, THAT SIGG(ILINE) WILL = SIG(ID) = 0. ALSO, THE TIME
C  DELAY STORED IN TIMDELAY ABOVE IS 0 SINCE SIG(ID) .GE. 0 --> THIS
C  IS NOT A STEADY STATE DOSE SET.
        
        ILINE = ILINE + 1
        SIGG(ILINE) = SIG(ID) + 100.D0*DELDOSE

        DO J = 1,NI
         RSS(ILINE,J) = RS(ID,J)
        END DO
       
       ENDIF


       IF(SIG(ID) .LT. 0.D0) THEN

C  THIS LINE GIVES INFO ON A STEADY STATE SET OF 101 DOSES WHICH IS
C  TO APPLIED AT THIS POINT.

        DO IDRUG = 1,NDRUG

C  FOR DRUG, IDRUG, THE AMOUNT OF DRUG FOR DRUG NO. IDRUG IN EACH OF THE
C  101 DOSES WILL BE RS(ID,2*IDRUG). IF RS(ID,2*IDRUG) > 0, DRUG, IDRUG,
C  PARTICIPATES IN THE STEADY STATE DOSING. IF THIS VALUE = 0, DRUG,
C  IDRUG, DOES NOT PARTICIPATE. NOTE THAT IF A DRUG PARTICIPATES, THE
C  ROUTE WILL BE AS AN IV, WITH RATE RS(ID,2*IDRUG-1), IF 
C  RS(ID,2*IDRUG-1) > 0. BUT IF THIS VALUE IS 0, THE DRUG WILL BE GIVEN
C  AS A BOLUS. NOTE THAT THE INTERVAL BETWEEN DOSES IS -SIG(ID).

C  IF DRUG, IDRUG, PARTICIPATES IN THE 101 STEADY STATE DOSE SET, PUT 
C  THE DURATION OF IV INTO DELTAIV(IDRUG) IF RS(ID,2*IDRUG-1) > 0;
C  OTHERWISE PUT 0 INTO DELTAIV(IDRUG) SINCE IN THIS CASE, THE DRUG IS
C  GIVEN AS A BOLUS.

         DELTAIV(IDRUG) = 0.D0 
         IF(RS(ID,2*IDRUG) .GT. 0.D0 .AND. RS(ID,2*IDRUG-1) .GT. 0.D0) 
     1    DELTAIV(IDRUG) = RS(ID,2*IDRUG)/RS(ID,2*IDRUG-1) 

C  IT SHOULD NOT BE POSSIBLE FOR THE IV OF THIS DRUG TO BE > 0 AT THE
C  SAME TIME THAT THE BOLUS ENTRY = 0. THIS WOULD MEAN THAT AN IV
C  WAS TO BE GIVEN AT A SPECIFIED RATE, BUT WITH A TOTAL DOSE OF 0,
C  AND THIS MAKES NO SENSE. IF, SOMEHOW, THIS HAS OCCURRED, REPORT IT
C  TO THE USER AS AN ERROR, AND STOP.


C  REPLACE WRITING OF SIG(),RS() VALUES WITH XVERIFY (SEE LOGIC IN 
C  SUBROUTINE VERIFYVAL. SIMIARLY FOR ALL CALLS TO VERIFYVAL.

       XVERIFY(1) = SIG(ID)
       XVERIFY(2) = RS(ID,2*IDRUG-1)
       XVERIFY(3) = RS(ID,2*IDRUG)
       CALL VERIFYVAL(3,XVERIFY)
	

         IF(RS(ID,2*IDRUG) .LE. 0.D0 .AND. RS(ID,2*IDRUG-1) .GT. 0) THEN
C        WRITE(*,101) ID,SIG(ID),IDRUG,RS(ID,2*IDRUG-1),RS(ID,2*IDRUG)
         WRITE(*,101) ID,XVERIFY(1),IDRUG,XVERIFY(2),XVERIFY(3)
  101     FORMAT(//' THERE IS AN ERROR IN YOUR INSTRUCTION FILE, AS'/
     1' DETERMINED BY SUBROUTINE NEWWORK1.'//
     2' ONE OF THE SUBJECTS HAS A STEADY STATE DOSE SET WITH A '/
     3' POSITIVE IV RATE, BUT WITH A TOTAL DOSE AMOUNT .LE. 0.'//
     4' IN PARTICULAR, FOR DOSE EVENT ',I4,' AND TIME ',G19.9,/
     5' FOR DRUG ',I2,', THE IV VALUE IS ',G19.9,' WHILE THE TOTAL'/
     6' DOSE AMOUNT IS ',G19.9//
     7' THE PROGRAM STOPS. PLEASE CORRECT THE ERROR BEFORE RERUNNING.'/)

C  SINCE THE PROGRAM IS TERMINATING ABNORMALLY, WRITE THE ERROR MESSAGE
C  TO ERRFIL ALSO.

        OPEN(42,FILE=ERRFIL)
C        WRITE(42,101) ID,SIG(ID),IDRUG,RS(ID,2*IDRUG-1),RS(ID,2*IDRUG)
         WRITE(42,101) ID,XVERIFY(1),IDRUG,XVERIFY(2),XVERIFY(3)
        CLOSE(42)

          CALL PAUSE
          STOP
         ENDIF

 
        END DO

        
C  CALL SUBROUTINE ORDERDELTA TO OBTAIN NDELTA, THE NO. OF UNIQUE
C  NON-0 VALUES IN THE DELTAIV(.) ARRAY JUST ESTABLISHED ABOVE, AND TO
C  PUT THE ORDERED SET OF THESE NDELTA VALUES INTO ORDELT(.).

C  NOTE THAT IF DELTAIV(IDRUG) = 0, IT MEANS THAT DRUG, IDRUG, DOES NOT
C  PARTICIPATE IN THE STEADY STATE DOSE SET, OR IF IT DOES, IT IS GIVEN
C  AS A BOLUS RATHER THAN AN IV.

        CALL ORDERDELTA(NDRUG,DELTAIV,NDELTA,ORDELT)

C  NOW ESTABLISH THE LINES WITH SIGG(.) AND RSS(.,.) AS FOLLOWS:

C  1. THE NEXT 101*(NDELTA + 1) ROWS WILL BE FOR THE STEADY STATE
C  DOSE SET (I.E., EACH OF THE 101 REPEATED DOSES HAS A START TIME,
C  AND THEN NDELTA ENDING TIMES AMONG ALL NDRUG DRUGS). NOTE THAT
C  NDELTA WILL BE 0 IF ALL THE PARTICIPATING DRUGS ARE BOLUSES SINCE
C  THEY WOULDN'T NEED AN ENDING TIME THEN.


C  2. EVERY ROW OF THE ORIGINAL DOSAGE REGIMEN AFTER LINE ID
C  WILL HAVE THE SAME VALUES IN RSS(.,.) AS IN RS(.,.), BUT THE
C  TIMES IN SIGG(.) WILL ALL BE INCREASED BY 100*DELDOSE OVER THOSE
C  IN SIG(.) ... UP TO BUT NOT INCLUDING THE NEXT TIME RESET EVENT
C  OR NEXT STEADY STATE DOSE INDICATOR LINE, WHERE DELDOSE IS THE TIME
C  INCREMENT BETWEEN CONSECUTIVE DOSES IN THE 101 STEADY STATE DOSE SET.
C  NOTE THAT DELDOSE IS THE NEGATIVE OF SIG(ID).

        DELDOSE = -SIG(ID)        
        NSECTION = NSECTION + 1
        TIMDELAY(NSECTION) = 100.D0*DELDOSE

C  NOTE THAT THE TIME DELAY ASSOCIATED WITH THIS STEADY STATE SET IS
C  STORED INTO TIMDELAY ABOVE SO THAT IT CAN BE APPLIED TO THE 
C  CORRESPONDING SET OF OBSERVED VALUES BELOW.




        DO ISET = 1,101

C  FOR EACH SET, ESTABLISH NDELTA + 1 ROWS (DOSE EVENT LINES).

C  THE FIRST ROW IN THIS SET HAS EACH DRUG IV SET = RS(ID,2*IDRUG-1),
C  AND, FOR EACH DRUG IV WHICH IS 0, THE BOLUS VALUE WILL BE SET =
C  RS(ID,2*IDRUG). NOTE THAT IF A DRUG IV > 0, THE BOLUS VALUE WILL BE
C  SET = 0 SINCE IN THIS CASE, THE VALUE IN THE BOLUS COLUMN IS THE
C  TOTAL AMOUNT OF IV (NOT A BOLUS AMOUNT).

         ILINE = ILINE + 1

         DO IDRUG = 1,NDRUG
          RSS(ILINE,2*IDRUG-1) = RS(ID,2*IDRUG-1)
          RSS(ILINE,2*IDRUG) = RS(ID,2*IDRUG)
          IF(RS(ID,2*IDRUG-1) .GT. 0.D0) RSS(ILINE,2*IDRUG) = 0.D0
         END DO

C  SET ALL THE COVARIATE VALUES = TO THOSE IN LINE ID OF RS OF COURSE.

         DO IADD = 1,NADD
          RSS(ILINE,2*NDRUG+IADD) = RS(ID,2*NDRUG+IADD)
         END DO


C  THE TIME FOR THIS ROW IS (ISET-1)*DELDOSE, EXCEPT FOR THE FIRST
C  LINE, WHICH MUST HAVE THE SAME NEGATIVE VALUE AS IN SIG, SINCE
C  THE ID ROUTINES MUST READ THE NEGATIVE SIG VALUE TO KNOW THAT A
C  STEADY STATE DOSE SET IS STARTING.

         IF(ISET .EQ. 1) THEN
          SIGG(ILINE) = SIG(ID)
          DOSESTART = 0.D0
         ENDIF

         IF(ISET .GT. 1) THEN
          SIGG(ILINE) = (ISET-1)*DELDOSE
          DOSESTART = SIGG(ILINE)
         ENDIF

C  THE NEXT NDELTA ROWS ARE THE IV TURN OFF ROWS FOR THE VARIOUS DRUGS,
C  IF NDELTA > 0. NOTE THAT NDELTA COULD = 0 IF ALL PARTICIPATING DRUGS
C  ARE GIVEN VIA A BOLUS, SINCE THEN NONE WOULD NEED A TURN OFF ROW.

        IF(NDELTA .GT. 0) THEN

         DO INDEL = 1,NDELTA

          ILINE = ILINE + 1

C  THE NEXT TURN OFF TIME IS DOSESTART + ORDELT(INDEL). EACH IV WILL BE
C  OFF UNLESS ITS DELTAIV(.) IS .GT ORDELT(INDEL). AND EACH BOLUS VALUE
C  WILL BE 0 OF COURSE (I.E., EACH BOLUS IS GIVEN JUST ONE TIME AT THE
C  START OF EACH SET).

          DO IDRUG = 1,NDRUG
           RSS(ILINE,2*IDRUG-1) = 0.D0
           IF(DELTAIV(IDRUG) .GT. ORDELT(INDEL))
     1      RSS(ILINE,2*IDRUG-1) = RS(ID,2*IDRUG-1)        
           RSS(ILINE,2*IDRUG) = 0.D0
          END DO

C  SET ALL THE COVARIATE VALUES = TO THOSE IN LINE ID OF RS AGAIN.

          DO IADD = 1,NADD
           RSS(ILINE,2*NDRUG+IADD) = RS(ID,2*NDRUG+IADD)
          END DO

C  THE TIME FOR THIS ROW IS DOSESTART + ORDELT(INDEL)

          SIGG(ILINE) = DOSESTART + ORDELT(INDEL)

         END DO   

C  THE ABOVE END DO IS FOR THE  DO INDEL = 1,NDELTA  LOOP.  

        ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(NDELTA .GT. 0)  CONDITION.

 
        END DO

C  THE ABOVE END DO IS FOR  DO ISET = 1,101  LOOP.


       ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(SIG(ID) .LT. 0.D0)  CONDITION.



      END DO

C  THE ABOVE END DO IS FOR THE  DO ID = 1,ND  LOOP.


C  THIS COMPLETES THE ESTABLISHMENT OF RSS(.,.) AND SIGG(.) ABOVE.


C  NOW ALTER THE OBSERVED VALUE TIMES BY ADDING THE APPROPRIATE VALUE
C  IN TIMDELAY(.) TO EACH OBSERVED VALUE TIME BELOW. NOTE THAT
C  TIMDELAY(1) APPLIES TO ALL TIMES BEFORE THE FIRST TIME RESET,
C  TIMDELAY(2) APPLIES TO THE NEXT SET OF TIMES AFTER THE FIRST 
C  TIME RESET BUT BEFORE THE 2ND, ETC. IF THERE ARE NO TIME RESETS,
C  ALL TIMES WILL HAVE TIMDELAY(1) ADDED TO THEM, AND THIS VALUE WILL
C  BE 0.0 (SEE DOSAGE BLOCK CODE ABOVE - IF THERE ARE NO TIME RESETS
C  OR STEADY STATE DOSE SETS, TIMDELAY(1) IS SET = 0).

C  SINCE THE OBSERVATION BLOCK WAS READ THROUGH ABOVE, BACKSPACE TO
C  THE BEGINNING OF THE OBS. BLOCK, SO THIS PART OF THE PATIENT'S


C  DATA CAN BE ACCESSED AGAIN.

1920   BACKSPACE(23)
       BACKSPACE(23)
       READ(23,1717,IOSTAT=IEND) READLINE

	 IF(IEND .LT. 0) THEN

C  NOTE THAT IEND .LT. 0 --> END OF FILE REACHED, BUT IF IT'S REACHED
C  AT THIS POINT, NOT ALL "ACTIVE" NSUB SUBJECT DATA SETS WERE READ
C  AND WRITTEN CORRECTLY TO FILE 27. IN THIS CASE, WRITE A MESSAGE TO
C  THE USER AND STOP.

        WRITE(*,1721)

C  SINCE THE PROGRAM IS TERMINATING ABNORMALLY, WRITE THE ERROR MESSAGE
C  TO ERRFIL ALSO.

        OPEN(42,FILE=ERRFIL)
         WRITE(42,1721) 
        CLOSE(42)

	  CALL PAUSE
	  STOP

	 ENDIF

       IF(READLINE(12:23) .NE. 'NO. OF TOTAL') GO TO 1920

       BACKSPACE(23)


C  SINCE NUMEQT IS READ IN ABOVE, IT DOES NOT HAVE TO BE READ IN HERE.
C  JUST READ(23,*) ON NEXT LINE. FOR THAT MATTER, COULD HAVE USED
C  ANOTHER READ(23,*) ON FOLLOWING LINE SINCE M WAS READ IN ABOVE TOO.
  
       READ(23,*)
       READ(23,3) M

       NSECTION = 1

       DO I = 1,M
        READ(23,*) TIM(I),(YO(I,J),J=1,NUMEQT)
        CALL THESAME(TIM(I),0.D0,ISAME)
        IF(ISAME .EQ. 1 .AND. I .GT. 1) NSECTION = NSECTION + 1
        IF(ISAME .EQ. 1) TIMM(I) = 0.D0   
        IF(ISAME .EQ. 0) TIMM(I) = TIM(I) + TIMDELAY(NSECTION)
       END DO



C  NOW COPY THIS PART OF FILE 23 TO FILE 27 WITH THE FOLLOWING
C  EXCEPTIONS:
C   1. ND WILL BE REPLACED BY ILINE (THE TOTAL NO. OF DOSAGE LINES IN
C      THE ALTERED DOSAGE REGIMEN).
C   2. SIG(.) WILL BE REPLACED BY SIGG(.).
C   3. RS(.,.) WILL BE REPLACED BY RSS(.,.)
C   4. TIM(.) WILL BE REPLACED BY TIMM(.)
C   NOTE THAT YO(.,.) WILL BE UNCHANGED.

C  BACKSPACE FILE 23 TO THE FIRST LINE FOR THIS PATIENT.

 1820  BACKSPACE(23)
       BACKSPACE(23)
       READ(23,1717,IOSTAT=IEND) READLINE


	 IF(IEND .LT. 0) THEN

C  NOTE THAT IEND .LT. 0 --> END OF FILE REACHED, BUT IF IT'S REACHED
C  AT THIS POINT, NOT ALL "ACTIVE" NSUB SUBJECT DATA SETS WERE READ
C  AND WRITTEN CORRECTLY TO FILE 27. IN THIS CASE, WRITE A MESSAGE TO
C  THE USER AND STOP.

        WRITE(*,1721)

C  SINCE THE PROGRAM IS TERMINATING ABNORMALLY, WRITE THE ERROR MESSAGE
C  TO ERRFIL ALSO.

        OPEN(42,FILE=ERRFIL)
         WRITE(42,1721) 
        CLOSE(42)

	  CALL PAUSE
	  STOP

	 ENDIF

       IF(READLINE(3:16) .NE. 'LAST AND FIRST') GO TO 1820

       WRITE(27,1717) READLINE

   60  READ(23,1717) READLINE
       WRITE(27,1717) READLINE
   
       IF(READLINE(12:23) .NE. 'NO. OF ADDIT') GO TO 60

C  THE LINE JUST WRITTEN TO FILE 27 IS THE NO. OF ADDITIONAL COVARIATES
C  LINE. WRITE THE NEXT LINE BUT CHANGE FROM ND TO ILINE AS THE NO.
C  OF DOSE EVENTS.

       READ(23,1717) READLINE
       WRITE(27,133) ILINE
  133  FORMAT(I6,' ... NO. OF DOSE EVENTS')

C  WRITE THE NEXT TWO LINES TO FILE 27 (INCLUDING THE HEADER LINE FOR
C  THE DOSAGE BLOCK).

       DO I = 1,2
        READ(23,1717) READLINE
        WRITE(27,1717) READLINE
       END DO

C  WRITE THE NEW DOSAGE BLOCK.

       SIGLAST = -999999.D0

       DO I = 1,ILINE

        WRITE(27,*) SIGG(I),(RSS(I,J),J=1,NI)

C  AS OF it2beng26.f, MAKE SURE THAT NO TWO TIMES ARE THE SAME SINCE
C  IF THEY ARE, IT CAN CONFUSE SUBROUTINE SHIFT (CAUSING IT TO GO INTO
C  AN INFINITE LOOP - SEE NPAG115.EXP, TESTCASE 5).

        CALL THESAME(SIGLAST,SIGG(I),ISAME)


        IF(ISAME .EQ. 1) THEN


       XVERIFY(1) = SIGLAST
       CALL VERIFYVAL(1,XVERIFY)
C      WRITE(*,4031) SIGLAST
       WRITE(*,4031) XVERIFY(1)
 4031    FORMAT(/' IN SUBROUTINE NEWWORK1, TWO CONSECUTIVE DOSE TIMES'/
     1' HAVE THE SAME VALUE IN WORKING COPY FORMAT, ',F20.8//
     2' THIS COULD CAUSE UNEXPECTED RESULTS IF THE PROGRAM WERE TO '/
     3' CONTINUE. SO THE PROGRAM NOW STOPS. PLEASE CHECK YOUR PATIENT '/
     4' INFORMATION AND CORRECT (NOTE THAT THIS CAN HAPPEN IF THE '/

     5' FIRST DOSE FOLLOWING A STEADY STATE DOSE SET HAS THE SAME'/
     6' STARTING TIME AS THE ENDING TIME OF THE LAST STEADY STATE '/
     7' DOSE SET.)'//)

C  SINCE THE PROGRAM IS TERMINATING ABNORMALLY, WRITE THE ERROR MESSAGE
C  TO ERRFIL ALSO.


        OPEN(42,FILE=ERRFIL)
C        WRITE(42,4031) SIGLAST
         WRITE(42,4031) XVERIFY(1)

        CLOSE(42)

	  CALL PAUSE
	  STOP

	 ENDIF

       SIGLAST = SIGG(I)


       END DO



C  READ THROUGH FILE 23 DOWN TO THE END OF THE DOSAGE BLOCK

       DO I = 1,ND
        READ(23,*) SIG(I),(RS(I,J),J=1,NI)
       END DO
 
C  PUT THE BLANK LINE BETWEEN THE DOSAGE BLOCK AND THE OBSERVATION
C  BLOCK TO FILE 27, ALONG WITH THE TWO LINES WHICH GIVE THE NO. OF
C  OUTPUT EQS. AND THE NO. OF OBSERVED VALUE TIMES.

       DO I = 1,3
        READ(23,1717) READLINE
        WRITE(27,1717) READLINE
       END DO

C  WRITE THE OBSERVED BLOCK TO FILE 27, AND READ THROUGH IT IN FILE 23.

      DO I = 1,M
       WRITE(27,*) TIMM(I),(YO(I,J),J=1,NUMEQT)
       READ(23,*) TIM(I),(YO(I,J),J=1,NUMEQT)
      END DO
 
C  NOW COPY LINE FOR LINE THE REST OF THIS SUBJECT'S INFO TO FILE 27.
C  THIS PATIENT'S INFO WILL END WHEN THE END OF THE FILE IS REACHED
C  (IF THIS IS THE LAST PATIENT), OR WHEN THE START OF THE NEXT
C  PATIENT OCCURS.

   70	 READ(23,1717,IOSTAT=IEND) READLINE
       IF(IEND .LT. 0) GO TO 200
   	 IF(READLINE(3:16) .EQ. 'LAST AND FIRST') GO TO 200
       WRITE(27,1717) READLINE
       GO TO 70
  200	 BACKSPACE(23)

C  FILE 23 WAS BACKSPACED ONE LINE SO THE NEXT LINE TO BE READ IN IN
C  MAIN WILL BE THE FIRST LINE OF THE NEXT SUBJECT (UNLESS THIS SUBJECT
C  IS THE SUBJECT, IN WHICH CASE THE BACKSPACE WON'T MATTER).

      ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(ICOPY .EQ. 0)  CONDITION.


      RETURN
      END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
      SUBROUTINE ORDERDELTA(NDRUG,DELTAIV,NDELTA,ORDELT)

      IMPLICIT REAL*8(A-H,O-Z)
      DIMENSION DELTAIV(7),ORDELT(7),X(7)

C  SUBROUTINE ORDERDELTA IS CALLED BY NEWWORK TO OBTAIN NDELTA, THE NO.
C  OF UNIQUE NON-0 VALUES IN THE DELTAIV(.) ARRAY. THEN THE ORDERED SET
C  OF THESE NDELTA VALUES IS PUT INTO ORDELT(.). NOTE THAT
C  NDELTA WILL BE 0 IF ALL THE PARTICIPATING DRUGS ARE BOLUSES SINCE
C  THEY WOULDN'T NEED AN ENDING TIME THEN.


C  FIRST STORE ALL THE VALUES IN DELTAIV INTO X SO THAT DELTAIV WILL
C  NOT BE CHANGED.

      DO IDRUG = 1,NDRUG
       X(IDRUG) = DELTAIV(IDRUG)
      END DO


C  THE LOGIC OF THIS ROUTINE IS BASED ON \PERSONAL\FINANCE\ORDER.FOR.
C  TO DO THIS, EACH VALUE IN X(.) WILL BE COMPARED TO THE
C  PREVIOUS ONE. IF IT IS < THE PREVIOUS ONE, THE VALUE WILL EXCHANGE

C  PLACES WITH THE PREVIOUS ONE, AND THE TESTING WILL CONTINUE. THE
C  TESTING WILL STOP FOR A VALUE WHEN IT IS COMPARED TO A PREVIOUS
C  VALUE WHICH IS .LE. ITS VALUE.

      DO IDRUG = 2, NDRUG

C  COMPARE VALUE FOR IDRUG WITH EACH PREVIOUS VALUE, AND HAVE IT 
C  EXCHANGE PLACES WITH THAT VALUE, UNTIL IT REACHES ONE WHICH HAS A 
C  SMALLER VALUE. FIRST SET IDRUGNEW = IDRUG; AFTER THE FOLLOWING

C  CODE, IDRUGNEW WILL BE THE INDEX NO. FOR VALUE AT THE OLD IDRUG
C  POSITION.


       IDRUGNEW = IDRUG

       ICOMP = IDRUG 

  110  ICOMP = ICOMP - 1

C  NOW COMPARE VALUE IN LOCATION ICOMP WITH THE VALUE IN LOCATION

C  IDRUGNEW. IF THE LATTER IS .LT. THE FORMER, INTERCHANGE THE RECORDS.

       IF(X(IDRUGNEW) .LT. X(ICOMP)) THEN

        VALUE = X(IDRUGNEW)
        X(IDRUGNEW) = X(ICOMP)         
        X(ICOMP) = VALUE
        IDRUGNEW = ICOMP



C  IF IDRUGNEW = 1, IT HAS BEEN CHECKED AGAINST ALL RECORDS (AND IS
C  THE SMALLEST VALUE); IF IS IS > 1, CONTINUE THE PROCESS.

        IF(IDRUGNEW .EQ. 1) GO TO 150
        IF(IDRUGNEW .GT. 1) GO TO 110

       ENDIF

C  THE ABOVE ENDIF IS FOR THE 
C   IF(X(IDRUGNEW) .LT. X(ICOMP))  CONDITION.


  150 END DO

C  THE ABOVE END DO IS FOR THE  DO IDRUG = 2, NDRUG LOOP.


C  NOW THE NDRUG VALUES ARE ORDERED, FROM SMALL TO LARGE IN X.
C  REWRITE THEM INTO ORDELT, BUT PUT ONLY THE NON-0 AND
C  UNIQUE VALUES INTO ORDELT, AND KEEP TRACK OF NOW MANY OF THESE
C  UNIQUE NON O VALUES THERE ARE - IT WILL BE NDELTA AT THE END OF
C  THE FOLLOWING LOOP.

      NDELTA = 0 

      DO IDRUG = 1,NDRUG

C  FOR THIS VALUE TO BE COUNTED, IT CANNOT = THE PREVIOUS VALUE, AND
C  IT CANNOT = 0.

       IF(IDRUG .EQ. 1 .AND. X(IDRUG) .GT. 0) THEN
        NDELTA = NDELTA + 1
        ORDELT(NDELTA) = X(IDRUG)
       ENDIF


       IF(IDRUG .GE. 2) THEN

        CALL THESAME(X(IDRUG),X(IDRUG-1),ISAME)

        IF(ISAME .EQ. 0) THEN
         NDELTA = NDELTA + 1
         ORDELT(NDELTA) = X(IDRUG)
        ENDIF

       ENDIF


      END DO 

C  THE ABOVE END DO IS FOR THE  DO IDRUG = 1,NDRUG  LOOP.


      RETURN
      END

C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
	SUBROUTINE THESAME(X1,X2,ISAME)
	IMPLICIT REAL*8(A-H,O-Z)

C  THIS ROUTINE CHECKS TO SEE IF X1 AND X2 ARE VIRTUALLY THE SAME
C  VALUES (I.E., IF THEY ARE WITHIN 1.D-10 OF EACH OTHER). IF SO,
C  ISAME RETURNS AS 1; IF NOT ISAME RETURNS AS 0.

	ISAME = 0
	XDEL = DABS(X1-X2)
	IF(XDEL .LE. 1.D-10) ISAME = 1

	RETURN
	END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
      SUBROUTINE VERIFYVAL(N,X)
      IMPLICIT REAL*8(A-H,O-Z)
      DIMENSION X(100)


C  THIS ROUTINE INPUTS X(I),I=1,N.

C  ON OUTPUT, EACH X(.) WHICH IS INSIDE [-1.D-99, 1.D-99] IS REPLACED
C  BY 0. THIS PREVENTS THIS VALUE FROM BEING WRITTEN OUT IMPROPERLY,
C  E.G., AS .934-106, RATHER THAN .934E-106.
C  ANY X(.) VALUE NOT INSIDE THE ABOVE RANGE WILL BE UNCHANGED ON
C  OUTPUT.

      DO I = 1,N
       IF(X(I) .GE. -1.D-99 .AND. X(I) .LE. 1.D-99) X(I) = 0.D0
      END DO

      RETURN
      END




