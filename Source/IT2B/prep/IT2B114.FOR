C  IT2B114.FOR                                             4/19/16

C  IT2B114 HAS THE FOLLOWING CHANGES TO IT2B113:

C  IT IS BROUGHT UP TO THE LEVEL OF NPAG119.FOR, WHICH ALLOWS RANFIX
C  PARAMETERS. THE DETAILS ARE:

C  1. THIS PROGRAM, WITH it2branfix1.f AS THE MAIN "ENGINE" MODULE, HAS
C  THE ADDED CAPABILITY TO ESTIMATE THE VALUES OF PARAMETERS WHICH ARE  
C  UNKNOWN BUT THE SAME FOR ALL SUBJECTS.

C  THIS MEANS THAT THE USER NOW DESIGNATES EACH PARAMETER AS FIXED
C  (IRAN(.) = 0), RANDOM (IRAN(.) = 1), OR RANFIX (IRAN(.) = 2).

C  BECAUSE ADDITIONAL INFORMATION (THE NO. OF RANFIX PARAMETERS, ALONG
C  WITH THEIR PARAMETER NAMES, AND INITIAL ESTIMATES) IS PROVIDED 
C  TO THE "ENGINE" PROGRAM, THE INFORMATION FILE PROVIDED TO THAT
C  PROGRAM HAS BEEN CHANGED FROM it2b101.inp TO it2b102.inp.

C  FORMATS 1113 AND 1111 ARE CHANGED. THE EXAMPLE COMPILE, LINK, AND 
C  EXECUTION COMMANDS HAVE BEEN REMOVED FROM THESE FORMATS, AS THEY 
C  WERE UNNECCESSARY.

C  WITH THE NEW INFORMATION REGARDING THE RANFIX PARAMETERS, ADDITIONAL
C  INFO IS PUT INTO THE OUTFxxxx AND IT_RFxxxx.TXT FILES MADE BY THE 
C  "ENGINE". AS A CONSEQUENCE, THERE ARE NEW VERSION CODES AT THE TOP 
C  OF THESE FILES (THE DATE IS MAR_16 FOR THE OUTFxxxx FILE, AND
C  MAR 2016 FOR THE IT_RFxxxx.TXT FILE, WHICH IS NOW MADE BY readi11.f,
C  UPDATED FROM readi10.f). NEW CODE IS REQUIRED IN SUBROUTINE EXTRAOPT
C  TO READ THE NEW OUTFxxxx FILE.  

C  SIMILARLY, THE INSTRUCTION FILE FOR THIS PROGRAM WILL BE CHANGED
C  SINCE IT WILL CONTAIN THIS NEW INFORMATION. OF COURSE, THIS PROGRAM
C  WILL BE BACKWARDS COMPATIBLE TO ALLOW PREVIOUS INST. FILES (IN WHICH
C  CASE, THE NO. OF RANFIX PARAMETERS WILL BE SET = 0). THE SAVED 
C  INSTRUCTION FILE FROM THIS PROGRAM WILL BE SAVED IN THE NEW 
C  ALL-INCLUSIVE FORMAT, WITH A NEW CODE, REM_FRN MAR_16.

C  2. ALL 150's RELATED TO HOLDMAT IN SUBROUTINES CSVCHANGE AND 
C  ORDERCHANGE HAVE BEEN CHANGED TO BE 1000's ... SINCE OTHERWISE IT IS 
C  POSSIBLE FOR A PATIENT LINE WHICH HAS A LOT OF COVARIATE VALUES TO BE
C  CUT OFF. SEE EXAMPLE IN \ALAN3\VIRGINIA\VIRGINIA2.EXP.

C  AND SUBROUTINE CSVCHANGE NOW CALLS NEW SUBROUTINE CONDENSE2 TO WRITE 
C  EACH LINE INTO FILE 66 IN AS CONDENSED A FASHION AS POSSIBLE.

C  3. FORMAT 128 IN SUBROUTINE STACK HAS BEEN CHANGED TO TAKE OUT THE 
C  "BOXES" COMMENT, WHICH IS NO LONGER APPLICABLE (AND HASN'T BEEN FOR 
C  SOME TIME).

C  4. THE MAIN MODULE FOR THE "preliminary" PROGRAM IS CHANGED FROM
C  asseng16.f to assranfix1.f.

C-----------------------------------------------------------------------

C  IT2B113.FOR                                             3/28/15

C  IT2B113 HAS THE FOLLOWING CHANGES TO IT2B112.FOR.

C  1. THE MAIN MODULE FOR THE "engine" FOR THIS PROGRAM IS CHANGED FROM
C  it2beng26.f TO it2beng27.f; THIS IS REFLECTED IN FORMAT 1111.

C  2. THE MAIN MODULE FOR THE "preliminary" PROGRAM IS CHANGED FROM
C  asseng15.f TO asseng16.f.

C  3. FORMAT 1111 NOW REFERS TO it2beng27.f, RATHER THAN 
C  it2beng26.f; AND FORMAT 1113 REFERS TO asseng16.f, RATHER THAN
C  asseng15.f.

C-----------------------------------------------------------------------

C  IT2B112.FOR                                             9/5/14

C  IT2B112 HAS THE FOLLOWING CHANGES FROM IT2B111:

C  1. THE MAIN MODULE FOR THE "engine" FOR THIS PROGRAM IS CHANGED FROM
C  it2beng25.f TO it2beng26.f; THIS IS REFLECTED IN FORMAT 1111.

C  2. THE MAIN MODULE FOR THE "preliminary" PROGRAM IS CHANGED FROM
C  asseng14.f TO asseng15.f.

C  NOTE THAT THE MAIN CHANGE IN THESE TWO MODULES IS THAT NOW A 
C  STEADY STATE DOSE SET TRANSLATES TO 101 DOSE SETS, RATHER THAN 100
C  (SEE COMMENTS IN THE .f MODULES). 

C  3. FORMAT 1111 NOW REFERS TO it2beng26.f, RATHER THAN 
C  it2beng25.f; AND FORMAT 1113 REFERS TO asseng15.f, RATHER THAN
C  asseng14.f.

C-----------------------------------------------------------------------

C  IT2B111.FOR                                             7/24/14

C  IT2B111 HAS THE FOLLOWING CHANGES FROM IT2B110:

C  1. THE MAIN "engine" MODULE, it2beng24.f, WILL BE UPDATED TO BE
C  it2beng25.f. IT WILL HAVE A CHANGE IN THE WAY IT CALCULATES AIC.

C  2. THE ID MODULES LINKED WITH it2beng25.f WILL BE UPDATED:
C  idm11x14.f TO idm11x15.f; idm2x14.f TO idm2x15.f; and idm222x13.f
C  TO idm222x14.f.

C  3. THE MAIN "preliminary" MODULE, asseng13.f, WILL BE UPDATED TO
C  BE asseng14.f. THIS MODULE HAS NO FUNCTIONAL CHANGES FROM asseng13.f
C  BUT IT IS LINKED WITH NEW ID MODULES (idm11x15.f and idm222x14.f) -
C  SEE CHANGE 2.

C  4. FORMAT 1111 NOW REFERS TO it2beng25.f, RATHER THAN 
C  it2beng24.f; AND FORMAT 1113 REFERS TO asseng14.f, RATHER THAN
C  asseng13.f. And the other modules are updated also.

C-----------------------------------------------------------------------

C  IT2B110.FOR                                             4/9/14

C  1. A NEW FILE, "ERRORLOG" WILL BE WRITTEN IF THIS PROGRAM STOPS
C  WITHOUT COMPLETING. ESSENTIALLY AT EVERY PLACE THE PROGRAM HAS A
C  CALL PAUSE COMMAND BEFORE STOPPING, WHATEVER COMMENT IS WRITTEN TO
C  THE SCREEN WILL ALSO BE PLACED INTO "ERRORLOG". NOTE THAT
C  "ERRORLOG" IS PASSED TO SUBROUTINES VIA COMMON/ERROR/ERRFIL,
C  WHERE ERRFIL IS SET = 'ERRORLOG'.

C  2. THE MAXIMUM NO. OF OUTPUT EQUATIONS WILL BE CHANGED FROM 6 TO 7,
C  AND TO FACILITATE ANY FUTURE SUCH CHANGES, THIS NUMBER WILL BE SET
C  = MAXNUMEQ (SO ONLY THE PARAMETER STATEMENT WILL HAVE TO BE CHANGED
C  IN THE FUTURE). THIS MEANS THAT MAXNUMEQ WILL NOW BE PASSED TO ALL
C  THE SUBROUTINES THAT NEED IT; AND IN THOSE SUBROUTINES, ANY 6
C  REFERRING TO THE MAX. NO. OF OUTPUT EQUATIONS WILL BE CHANGED TO
C  MAXNUMEQ.

C  3. FORMAT 919 REFERS NOW TO TSTMULTM.FOR, RATHER THAN TSTMULTL.FOR.

C  4. FORMAT 1111 NOW REFERS TO it2beng24.f, RATHER THAN 
C  it2beng23.f; AND FORMAT 1113 REFERS TO asseng13.f, RATHER THAN
C  asseng12.f. And the other modules are updated also.

C  5. THE FILE NAME, QMZJPZQX.CSV, WAS MISSPELLED IN FORMAT 2717; NOW
C  IT HAS BEEN CORRECTED.

C  6. ALL OPEN(37) STATEMENTS (IN SUBROUTINE WRITECSV) ARE REPLACED BY
C  OPEN(37,STATUS='SCRATCH') STATEMENTS. THE REASON IS THE SAME AS FOR
C  THE OPEN(57) STATEMENTS THAT WERE CHANGED TO 
C  OPEN(57,STATUS='SCRATCH') STATEMENTS IN IT2B107.FOR, CHANGE NO. 1.
C  THIS IS THAT REPEATED OPENING AND CLOSING OF THE SAME FILE CAN CAUSE
C  A gfortran-COMPILED PROGRAM TO EVENTUALLY  HAVE A RUN-TIME ERROR AS
C  FOLLOWS:

C  At line xxxx of file XXXXXX.FOR (unit = 37, file = 'fort.37')
C  Fortran runtime error: Cannot write to file opened for READ.

C  SEE TSTWRITE.EXP FOR A SIMPLE EXAMPLE OF WHEN THIS HAPPENS, AND
C  THE FACT THAT IT HAPPENS RANDOMLY.

C  BY INCLUDING THE STATUS='SCRATCH' SPECIFIER, THE ABOVE ERROR NO 
C  LONGER OCCURS.

C ----------------------------------------------------------------------


C  IT2B109.FOR                                             7/21/13

C  IT2B109 HAS THE FOLLOWING CHANGES FROM IT2B108:

C  1. THE USER CAN NOW USE A NEW-STYLE, ALL-INCLUSIVED INSTRUCTION 
C  FILE. THE PREVIOUS INSTRUCTION FILE DID NOT INCLUDE THE FOLLOWING
C  INFORMATION, WHICH WILL BE INCLUDED IN THE NEW-STYLE FILE:
C  - THEN NAME OF THE THE FORTRAN MODEL FILE;
C  - THE NO. OF COMPARTMENTS;
C  - THE NO. OF PARAMETERS, INCLUDING WHICH ARE RANDOM, AND WHICH
C    ARE FIXED;
C  - NAMES OF THE COVARIATES AND DESIGNATION OF WHICH ARE PIECEWISE 
C    CONTINUOUS AND WHICH ARE INTERPOLATED.
C  THE SAVED INSTRUCTION FILE FROM THIS PROGRAM WILL BE SAVED IN THE 
C  NEW ALL-INCLUSIVE FORMAT, WITH A NEW CODE, REM_FRN JUL_13.

C  NOTE THAT THE SECOND ENTRY IN THIS NEW INSTRUCTION FILE WILL BE
C  IVERIFY. IF IVERIFY = 0, IT MEANS THAT ALL THE INSTRUCTIONS WILL BE
C  USED WITH NO VERIFICATION (I.E., SUBROUTINE VERIF1 WILL NOT BE 
C  CALLED), AND THIS MEANS THAT ONCE THE USER ENTERS THE NAME OF THIS
C  INSTRUCTION FILE, IF IVERIFY = 0, THE PROGRAM WILL DO THE REST OF THE
C  RUN WITH NO ADDITIONAL USER INTERACTION. NOTE THAT IALLIN AND IVERIFY
C  ARE NOW PROVIDED TO SUBROUTINE READBLOCK VIA COMMON/TOWRITE. IF
C  IALLIN = 1 AND IVERIFY = 0, READBLOCK WILL KNOW TO ACCEPT THE VALUES
C  IN ICOVTYPE(.), ESTABLISHED IN THE INSTRUCTION FILE, AND NOT ASK
C  THE USER TO ENTER THEM.

C  NOTE THAT IF A USER HAS AN INSTRUCTION FILE WITH IVERIFY = 0, AND
C  HE WANTS TO RUN IT WITH VALIDATION OF THE VALUES, HE CAN SIMPLY
C  EDIT THE 2ND LINE AND CHANGE THE 0 TO 1.

C  THERE ARE QUITE A FEW CHANGES IN MAIN AND SUBROUTINE VERIF1 TO
C  AFFECT THIS CHANGE.

C  NOTE THAT IF A NEW-STYLE INSTRUCTION FILE IS USED, THE PATH WILL
C  AUTOMATICALLY BE SET = ' ', WHICH MEANS THAT THE EXECUTABLE PROGRAM,
C  NPAG112.EXE, WILL HAVE TO RESIDE IN THE WORKING DIRECTORY.

C  2. A CORRECTION IS MADE WHEN THE USER ENTERS INFO VIA AN INSTRUCTION
C  FILE AND THEN SUBROUTINE VERIF1 VERIFIES THE INFORMATION. PREVIOUSLY,
C  THERE WAS NO INDICATION WHETHER EACH RANDOM VARIABLE HAD IRAN(.) = 1
C  OR -1. THIS MEANS THE USER HAD NO WAY TO SEE IF A R.V. HAD TO BE
C  ESTIMATED TO BE POSITIVE OR NOT. NOW EACH R.V. WILL BE DESCRIBED 
C  AS HAVING TO BE ESTIMATED POSITIVE OR NOT.

C  NOTE THAT THERE WILL BE A SIMILAR CHANGE IN THE NEW MAIN ENGINE
C  MODULE, it2beng23.f, WHERE WHETHER A R.V. HAS TO BE ESTIMATED 
C  POSITIVE OR NOT IS NOW WRITTEN TO THE OUTPUT FILE. AND A SIMILAR
C  CHANGE WILL BE MADE IN readi08.f (UPDATED FROM readi07.f) FOR
C  THE IT_RFxxxx.TXT FILE.

C  3. FORMAT 919 REFERS NOW TO TSTMULTL.FOR, RATHER THAN TSTMULTK.FOR.

C  4. FORMAT 401 IS ADDED TO LOOP 400 SINCE THIS LOOP CAN TAKE A LONG
C  TIME, AND WRITING SUBJECT NOS. TO THE SCREEN ASSURES USERS THE
C  PROGRAM HAS NOT HUNG.

C  5. IF THE USER ENTERS PATIENT DATA INFO IN A .csv FORMAT, THE PROGRAM
C  WILL CHECK TO SEE IF THERE ARE NSUBTOT WORKING COPY FILES,
C  XQZPJ001.ZMQ,... ALREADY IN THE WORKING DIRECTORY. IF SO, THE USER
C  WILL BE ASKED IF HE WANTS TO USE THESE FILES, AND AVOID CREATING 
C  THEM FROM THE .csv FILE. I.E., IF THE USER HAS ALREADY DONE AN NPAG
C  RUN WITH THE CURRENT .csv FILE, THE XQZPJ001.ZMQ,... FILES CAN BE
C  REUSED WITHOUT HAVING TO RECREATE THEM, AND THIS COULD SAVE A LOT OF
C  TIME IF THE .csv FILE IS LARGE. OF COURSE, IF THE USER USES THE SAME
C  WORKING DIRECTORY FOR MULTIPLE RUNS WITH DIFFERENT .csv FILES, HE
C  SHOULD MAKE SURE THE CURRENT XQZPJ001.ZMQ,... FILES ARE THE CORRECT
C  ONES BEFORE SELECTING THIS OPTION.

C  6. PREVIOUSLY, IF THE USER ENTERED INFO VIA THE KEYBOARD, AND THE
C  PATIENT DATA CAME IN VIA A .csv FILE, THIS FILE WOULD BE EXAMINED
C  TWICE BY SUBROUTINE READBLOCK, EACH TIME CALLING SUBROUTINE
C  GETMAXTIM TO FIND THE MAXIMUM TIME AMONG ALL THE SUBJECTS. BUT THE
C  CALLING OF GETMAXTIM DOES NOT NEED TO BE DONE WHEN READBLOCK IS
C  CALLED BY SUBROUTINE GETNUMEQ (I.E., WHEN ICALL = 2 IN THE ARG. LIST
C  TO READBLOCK). SO NOW, WHEN READBLOCK IS CALLED WITH ICALL = 2, THE
C  CALLING OF GETMAXTIM IS SKIPPED.

C  7. OPEN(27) IN SUBROUTINE PUTASS IS REPLACED BY 
C  OPEN(27,STATUS='SCRATCH'). THE REASON IS EXPLAINED IN CHANGE NO. 1
C  IN IT2B107.FOR (WHERE THE SAME CHANGE HAD TO BE MADE FOR FILE 57).

C  8. FORMAT 1111 NOW REFERS TO it2beng23.f, RATHER THAN 
C  it2beng22.f; AND FORMAT 1113 REFERS TO asseng12.f, RATHER THAN
C  asseng11.f.

C  9. A BUG IS CORRECTED IN SUBROUTINE CSVCHANGE. PREVIOUSLY, IF A .CSV
C  FILE HAD AN IDEVENT = 4 WITH IADDL > 0 (I.E., REPEATED DOSES STARTING
C  WITH A DOSE RESET EVENT), CSVCHANGE WOULD IMPROPERLY WRITE IADDL
C  REPEATED DOSE LINES TO FILE 66 ALL WITH IDEVENT = 4. IN FACT, THESE
C  REPEATED LINES MUST, OF COURSE, HAVE IDEVENT = 1 (SINCE THEY ARE
C  REGULAR DOSE LINES, NOT MORE DOSE RESET LINES).


C-----------------------------------------------------------------------

C  IT2B108.FOR                                             10/30/12

C  IT2B108 HAS THE FOLLOWING CHANGES TO IT2B107:

C  1. A NEW TEMPLATE MODEL FILE, TSTMULTK.FOR, UPDATED FROM 
C  TSTMULTI.FOR, WILL NOW BE USED. THE DIFFERENCE IS THAT THE FOLLOWING
C  TWO DECLARATION STATEMENTS ...
C        DOUBLE PRECISION KE,KA,KCP,KPC     AND
C        COMMON /RATESV/ KE,KA,KCP,KPC,V 
C  WILL BE ELIMINATED IN SUBROUTINE OUTPUT (NOTE THAT IN THE SHORT-
C  LIVED TSTMULTJ.FOR, THESE STATEMENTS WERE ALSO PUT INTO SUBROUTINES
C  DIFFEQ, GETFA, GETIX, AND GETTLAG). THE REASON, AS DETAILED IN
C  TSTMULTK.FOR, IS THAT HAVING THESE STATEMENTS IN THE OTHER ROUTINES
C  BESIDE ANAL3 AND THE CASEx ROUTINES IT CALLS, MISLEADS THE USER INTO
C  THINKING THAT THE PARAMETERS ARE GUARANTEED TO HAVE BEEN SET TO
C  CURRENT VALUES BEFORE THESE OTHER ROUTINES ARE CALLED, AND THIS IS

C  NOT SO.

C  SO FORMAT 919 NOW REFERS TO TSTMULTK.FOR, RATHER THAN TSTMULTI.FOR.

C  2. THE MAIN MODULE FOR THE "ENGINE" FOR THIS PROGRAM IS CHANGED FROM
C  it2beng21.f TO it2beng22.f

C  3 FORMATS 1111 AND 1113 NOW REFER TO idm11x13.f RATHER THAN 
C  idm11x12.f; idm2x13.f RATHER THAN idm2x11.f; AND idm222x12.f RATHER
C  THAN idm222x11.f (SEE it2beng22.f CODE FOR DETAILS ON THE CHANGES
C  IN THE id MODULES). Also FORMAT 1111 REFERS TO readi07.f RATHER THAN
C  readi06.f.

C  ALSO, FORMAT 1111 NOW REFERS TO it2beng22.f, RATHER THAN 
C  it2beng21.f; AND FORMAT 1113 REFERS TO asseng11.f, RATHER THAN
C  asseng10.f.

C  4. IN THE LOOP WHICH EXAMINES ALL WORKING COPY PATIENT DATA FILES
C  TO VERIFY THEY HAVE THE CORRECT ASSAY COEFFICIENTS (SEE FORMAT 2401),
C  A NEW STATEMENT (FORMAT 8889) IS WRITTEN TO THE SCREEN WITH THE

C  SUBJECT NO. CURRENTLY BEING EXAMINED ... SO THE USER WON'T THINK THE
C  PROGRAM HAS HUNG IF THERE ARE A LOT OF SUBJECTS.

C  5. IN SUBROUTINE CSVCHANGE, FORMAT 103 IS WRITTEN TO THE SCREEN IN
C  CASE A RUN HAS A LOT OF SUBJECTS WITH A LOT OF DATA. OTHERWISE, 
C  THERE COULD BE A LONG "DEAD" TIME ON THE SCREEN, MAKING THE USER
C  THINK THE PROGRAM HAS "HUNG".

C  BECAUSE OF THIS THE WRITE OF FORMAT 1234 IS TAKEN OUT OF MAIN AND
C  SUBROUTINE GETNUMEQ (SINCE "DEAD" TIME IS REPLACED BY WRITING WHICH
C  SUBJECTS ARE BEING WORKED ON BY SUBROUTINE CSVCHANGE).

C  SIMILARLY, IN SUBROUTINE GETMAXTIM, FORMATS 103 AND 104 FILL THE
C  "DEAD" SCREEN TIME WITH INFORMATION ON MAXIMUM TIME AMONG THE 
C  SUBJECTS IN CASE THERE ARE A LOT OF SUBJECTS WITH A LOT OF DATA.

C-----------------------------------------------------------------------

C  IT2B107.FOR                                             8/29/12

C  IT2B107 HAS THE FOLLOWING CHANGES TO IT2B106:

C  1. ALL OPEN(57) STATEMENTS ARE REPLACED BY OPEN(57,STATUS='SCRATCH') 
C  STATEMENTS. THE REASON IS THAT REPEATED OPENING AND CLOSING OF THE
C  SAME FILE CAN CAUSE A gfortran-COMPILED PROGRAM TO EVENTUALLY
C  HAVE A RUN-TIME ERROR AS FOLLOWS:

C  At line xxxx of file XXXXXX.FOR (unit = 57, file = 'fort.57')
C  Fortran runtime error: Cannot write to file opened for READ.

C  SEE TSTWRITE.EXP FOR A SIMPLE EXAMPLE OF WHEN THIS HAPPENS, AND
C  THE FACT THAT IT HAPPENS RANDOMLY.

C  BY INCLUDING THE STATUS='SCRATCH' SPECIFIER, THE ABOVE ERROR NO 
C  LONGER OCCURS.

C  ALSO, CLOSE(57) IS ADDED TWICE IN SUBROUTINE CSVCHANGE, BELOW WHERE
C  FILE 57 WAS OPENED, WRITTEN, AND THEN READ. THESE CLOSE STATEMENTS
C  SHOULD HAVE BEEN IN THE CODE BEFORE, BUT CAUSED NO PROBLEMS. 
C  NEVERTHELESS, THE CODE NOW IS CLEANER WITH THE ADDITION OF THESE
C  TWO CLOSE STATEMENTS.

C  2. A DIMENSION STMT. FOR C0P,..,C3P IS ADDED TO SUBROUTINE GETNUMEQ.
C  NOT HAVING IT THERE DID NOT CAUSE A PROBLEM, BUT IT SHOULD BE IN THE
C  ROUTINE SINCE THESE ARRAYS ARE ARGUMENTS IN A CALL TO SUBROUTINE
C  READBLOCK.

C  3. CLEARSCREEN*6 IS ADDED TO SUBROUTINE EXTRAOPT. NOT
C  HAVING THIS DID NOT CAUSE AN ERROR, BUT DID CAUSE A COMPILER 
C  WARNING SINCE CLEARSCREEN IS A CHARACTER*6 IN MAIN AND IS IN THE 
C  ARG. LIST OF A CALL TO EXTRAOPT, WHICH MEANS THAT IT LOOKED LIKE A
C  CHARACTER*6 VARIABLE IN MAIN WAS EQUIVALENT TO A REAL VARIABLE IN
C  EXTRAOPT.  

C  4. OSNAME*20 AND LISTDIR*10 ARE ADDED TO SUBROUTINE VERIF1. THEY DID
C  NOT CAUSE ERRORS, BUT DID CAUSE WARNINGS BECAUSE THEY LOOK LIKE 
C  REAL OR INTEGER VARIABLES IF NOT DECLARED AS CHARACTERS AS THEY
C  SHOULD BE. 

C  NOTE THAT A CHECK OF THE COMPILATION WARNINGS FOR THIS PROGRAM
C  (USING LF90 SINCE gfortran GIVES ALMOST NO MESSAGES (WHEN THE ONLY
C  SWITCH IS -o ANYWAY), SHOWS THAT THEY ARE ALL INNOCUOUS. THERE ARE
C  MANY REGARDING VARIABLES NOT USED, BUT THESE ARE HOLDOVERS FROM
C  PREVIOUS PROGRAMS. AND SOMETIMES VARIABLES WHICH ARE NO LONGER USED
C  ARE STILL READ FROM FILES SO THE FORMAT OF THE FILES DOES NOT HAVE
C  TO CHANGE. ALSO, THERE ARE A NUMBER OF WARNINGS FOR FLOATING-PT.
C  COMPARISONS FOR EQUALITY, ETC. BUT YEARS OF RUNNING THESE PROGRAMS
C  SHOW THAT THERE IS NO PROBLEM WITH THESE COMPARISONS.

C  5. THE MAIN MODULE FOR THE "ENGINE" FOR THIS PROGRAM IS CHANGED FROM
C  it2beng20.f TO it2beng21.f

C  6. FORMATS 1111 AND 1113 NOW REFER TO idm11x11.f RATHER THAN 
C  idm11x10.f; idm2x11.f RATHER THAN idm2x10.f; AND idm222x11.f RATHER
C  THAN idm222x10.f (SEE it2beng21.f CODE FOR DETAILS ON THE CHANGES
C  IN THE id MODULES). Also FORMAT 1111 REFERS TO readi06.f RATHER THAN
C  readi05.f.

C  ALSO, FORMAT 1113 NOW REFERS TO it2beng21.f, RATHER THAN 
C  it2beng20.f.

C-----------------------------------------------------------------------

C  IT2B106.FOR                                             7/8/12

C  IT2B106 HAS THE FOLLOWING CHANGES FROM IT2B105:

C  FORMATS 1111 AND 1113 NOW REFER TO idm11x11.f RATHER THAN idm11x10.f
C  - THIS CHANGE WAS EFFECTIVE WITH IT2B105.FOR, BUT WAS NOT CHANGED IN
C  THE FORMATS.

C  ALSO, FORMAT 1113 NOW REFERS TO it2beng20.f, RATHER THAN 
C  it2beng19.f.

C-----------------------------------------------------------------------

C  IT2B105.FOR                                             4/18/12

C  IT2B105 HAS THE FOLLOWING CHANGES TO IT2B104:

C  1. IT NO LONGER RESTRICTS STEADY STATE DOSES TO BE IVs. NOW THEY CAN
C  BE BOLUSES TOO. BUT, FOR EACH DRUG IN A STEADY STATE SET CAN HAVE 
C  EITHER AN IV OR A BOLUS, BUT NOT BOTH. THE REASON IS THAT THE DOSE 
C  COLUMN IN THE .CSV FILE IS USED FOR THE TOTAL AMOUNT OF DRUG GIVEN.
C  IF THE CORRESPONDING DURATION IS 0, THIS REPRESENTS A BOLUS; IF THE
C  CORRESPONDING DURATION > 0, THIS REPRESENTS THE TOTAL AMOUNT OF THE
C  IV (WITH THE INDICATED DURATION). IF THERE WERE TO BE BOTH AN IV AND
C  A BOLUS, THERE WOULD BE NO WAY TO IMPART THIS INFORMATION IN THE TWO
C  ENTRIES (DUR AND DOSE).

C  THE ONLY CHANGE REQUIRED IN THIS PROGRAM TO ALLOW STEADY STATE BOLUES
C  IS IN SUBROUTINE READBLOCK, WHERE THE IV RATE IS SET = 0 IF DUR = 0.

C  2. JUST BELOW THE START OF LOOP 1000 IN SUBROUTINE WRITEDOS, 
C  SUBROUTINE THESAME IS CALLED TO ESTABLISH THE VALUE FOR ISAMERESET.
C  THIS CALL HAD BEEN REMOVED IN IT2B103.FOR SINCE NRESET AND 
C  TIMERESET WERE SET IN THE  IF(TIME .GE. TIMADD*(NRESET+1))
C  BLOCK. BUT IT IS NECESSARY FOR ISAMERESET TO BE SET = 1 WHEN
C  TIME = TIMADD*(NRESET+1) ... SINCE IT IS USED BELOW TO PREVENT
C  INTERPOLATION OF COVARIATES ACROSS A TIME RESET.

C  3. THE G15.6 FORMAT IN FORMAT 1 IN SUBROUTINE WRITEDOS IS CHANGED
C  TO BE G19.9 (TO GIVE A LITTLE MORE PRECISION).

C  4. LOTS OF UNNEEDED ARRAYS AND VARIABLES HAVE BEEN REMOVED.

C  5. FORMATS 1111 AND 1113 ARE CHANGED TO REFER TO it2beng19.f AND
C  THE UPDATED id MODULES.

C-----------------------------------------------------------------------

C  IT2B104.FOR                                             2/16/12

C  IT2B104 HAS THE FOLLOWING CHANGES TO IT2B103:


C  1. IT ALLOWS THE USER TO SPECIFY, FOR EACH RANDOM VARIABLE, WHETHER
C  OR NOT THAT VARIABLE IS ALLOWED TO BE NEGATIVE. THIS IS DONE IN 
C  SUBROUTINE USERPREP. THERE, THE USER WILL ENTER R (OR r) IF A
C  VARIABLE WILL NOT BE ALLOWED TO BE NEGATIVE; -R (OR -r) IF A 
C  VARIABLE WILL BE ALLOWED TO BE NEGATIVE; AND F (OR f) AS USUAL IF
C  THE PARAMETER IS TO BE FIXED.

C  THEN THE INFORMATION WILL BE STORED IN THE VECTOR IRAN, WITH
C  IRAN(I) = 0 IF PARAMETER I IS FIXED; -1 IF PARAMETER I IS A 
C  VARIABLE AND IS ALLOWED TO BE NEGATIVE; 1 IF PARAMETER I IS A 
C  VARIABLE AND NOT ALLOWED TO BE NEGATIVE.
 
C  NOTE THAT THERE WILL BE NO CHANGES TO it2b101.inp PASSED TO THE
C  "ENGINE", BUT THE NEW "ENGINE" MAIN MODULE, it2beng18.f, WILL HAVE
C  CHANGES TO PROPERLY INTERPRET THE NEW IRAN(I) = -1 POSSIBILITY.
C  SIMILARY FOR THE NEW "ENGINE" PRELIMINARY PROGRAM MAIN MODULE,
C  asseng9.f.

C  2. A BUG IS FIXED IN SUBROUTINE CSVCHANGE. PREVIOUSLY, THE 
C  SUBROUTINE WAS BASED ON CSVCHANGE.FOR, WHICH WORKED ONLY FOR
C  .csv FILES WITH 1 SUBJECT. NOW IT IS BASED ON CSVCHANGE2.FOR
C  WHICH WORKS ON ALL .csv FILES.

C  3. REFERENCES TO THE "ENGINE" MODULES IN THE I/O ARE CHANGED TO BE
C  it2beng18.f and asseng9.f.

C-----------------------------------------------------------------------

C  IT2B103.FOR                                             1/27/12

C  IT2B103 HAS THE FOLLOWING CHANGES FROM IT2B102:

C  1. IT ALLOWS A NEW VERSION OF THE .csv FILE. THIS FILE WILL HAVE
C  THE CODE,"POPDATA DEC_11" AT THE TOP, RATHER THAN "POPDATA APR_11".
C  THIS NEW .csv FILE WILL HAVE TWO EXTRA COLUMNS, ADDL AND II, WHICH
C  ALLOW THE USER TO SPECIFY THAT THE CURRENT DOSE LINE IS TO BE

C  REPLICATED ADDL TIMES AT AN INTERDOSE INTERVAL OF II. IF ADDL IS

C  MISSING, IT IS ASSUMED TO BE 0 (WHICH MEANS THE LINE IS NOT TO BE
C  REPLICATED). IF ADDL = -1, IT INDICATES A STEADY STATE DOSE SET IS 
C  BEGINNING WITH THAT LINE.

C  TO HANDLE THE NEW .csv FILE, A NEW SUBROUTINE, CSVCHANGE, WILL BE
C  CALLED (AFTER SUBROUTINE NEWCSV IS CALLED AND BEFORE READBLOCK IS
C  CALLED) TO CHANGE THE NEW .csv FILE INTO THE CORRESPONDING ONE
C  WITH THE OLD FORMAT. THIS WILL MINIMIZE THE CHANGES TO SUBROUTINE
C  READBLOCK, WHICH WILL STILL NEED TO BE CHANGED TO DEAL WITH 
C  NEGATIVE DOSE TIMES (WHICH WILL NOW INDICATE THE BEGINNING OF A 
C  STEADY STATE DOSE SET) - SEE CODE IN READBLOCK.

C  ALSO NOTE THAT CSVCHANGE CONVERTS SCRATCH FILE 67 TO SCRATCH FILE
C  66, WHICH MEANS THAT ALL THE READ(67,..) STATEMENTS IN READBLOCK ARE
C  NOW CHANGED TO READ(66,...) STATEMENTS. SIMILARLY, THE READ(67,...)
C  IN SUBROUTINE GETMAXTIM IS CHANGED TO READ(66,...).

C  SOME NOTES REGARDING THE NEW .csv FORMAT:


C  a. THE COLUMNS WILL NOW BE:
C  ID,EVID,TIME,DUR,DOSE,ADDL,II,INPUT,OUT,OUTEQ,C0,C1,C2,C3,Covs if any



C  b. ADDL AND II ARE ONLY RELEVANT FOR EVID=1 AND EVID=4. FOR EVID=0,
C  (OBSERVATIONS) THEY ARE IGNORED.

C  c. ADDL CONTAINS THE NO. OF ADDITIONAL DOSES TO GIVE, AT THE 
C  INTERDOSE INTERVAL OF II.

C  d. If ADDL IS MISSING FOR AN EVID=1 OR EVID=4 EVENT, IT IS ASSUMED 
C  TO BE 0 --> NO ADDITIONAL DOSES ARE GIVE. IN THIS CASE, II IS
C  IRRELEVANT.

C  e. IF ADDL > 0, THEN ADDL ADDITIONAL DOSES ARE GIVEN (I.E., A TOTAL
C  OF ADDL + 1) AT INTERVAL II. A MISSING II IN THIS CASE WILL RESULT

C  IN THE PROGRAM STOPPING WITH AN ERROR MESSAGE TO THE USER.

C  f. ADDL > 0 CAN OCCUR ON ANY DOSE EVENT, BUT ADDL = -1 (A STEADY
C  STATE DOSE INDICATOR) CAN ONLY OCCUR AT T = 0 AT THE BEGINNING OF
C  A PATIENT'S FILE, OR AT A DOSE RESET TIME.

C  2. THE MAX. NO. OF DOSE EVENTS HAS BEEN CHANGED IN DIMENSIONS AND
C  CORRESPONDING CONDITIONAL STATEMENTS TO BE 5000 (500 IS NOW TOO LOW
C  WITH STEADY STATE DOSE SETS NOW ALLOWED) IN SUBROUTINES FILRED AND
C  STACK.

C  IN ADDITION, THE MAXIMUM NO. OF DOSE ROWS IN READBLOCK (AND ROUTINES
C  THAT IT CALLS) HAS BEEN CHANGED FROM 3000 TO 5000.

C  3. IN SUBROUTINE TIMESET, THE FIRST TIME IN THE DOSAGE BLOCK FOR EACH
C  SUBJECT IS NO LONGER TESTED TO MAKE SURE IT IS 0. THE REASON, OF
C  COURSE, IS THAT NOW THE FIRST TIME MAY BE NEGATIVE (WHICH SIGNIFIES
C  THAT THE DOSAGE REGIMEN BEGINS WITH A STEADY STATE OF DOSES).

C  4. A NEW SUBROUTINE CONVERTCSV IS CALLED BEFORE EACH CALL TO
C  SUBROUTINE NEWCSV TO CONVERT, IF NECESSARY, A "EUROPEAN" VERSION OF
C  A .CSV FILE TO THE FORM READBLOCK EXPECTS. IN THE "EURO" VERSION, THE
C  FIELD SEPARATORS ARE SEMICOLONS, RATHER THAN COMMAS, AND THE 
C  CHARACTER USED TO SEPARATE THE WHOLE PART OF A NUMBER FROM THE
C  FRACTIONAL PART IS A COMMA, RATHER THAN A PERIOD. TO DO THIS REQUIRES
C  READING THE SECONDS LINE OF THE .CSV FILE (THE FIRST LINE HAS THE
C  VERSION CODE) AND CHECKING FOR SEMICOLONS. IF THERE ARE ANY, THEN THE
C  FILE IS CHANGED SO THAT, IN ORDER, ALL COMMAS ARE CHANGED TO PERIODS,
C  AND THEN ALL SEMICOLONS ARE CHANGED TO COMMAS. NOTE THAT, EVEN IN THE
C  "EURO" VERSION, IT WILL STILL BE ASSUMED THAT A DOT REPRESENTS
C  A MISSING (OR UNNEEDED) VALUE.

C  NOTE THAT BLOCKPAT IS NOW OPENED AS SCRATCH FILE 87. THEN CONVERTCSV
C  WRITES THIS FILE AS THE CORRECTED VERSION TO SCRATCH FILE 77. THEN,
C  ROUTINE NEWCSV CONVERTS THIS FILE TO SCRATCH FILE 67. THEN ROUTINE
C  CSVCHANGE CONVERTS THIS FILE TO SCRATCH FILE 66, WHICH IS READ BY
C  ROUTINE READBLOCK.

C  5. THE MAIN "ENGINE" MODULE FOR THIS PROGRAM IS CHANGED FROM
C  it2beng16.f TO it2beng17.f. THE PRELIMINARY "ENGINE" MODULE IS
C  CHANGED FROM asseng7.f TO asseng8.f, AND THE id AND shift MODULES
C  ARE ALSO UPDATED (SEE it2beng17.f AND asseng8.f COMMENTS). THE id
C  MODULE CHANGES WERE REQUIRED TO CORRECT A BUG WHICH OCCURRED IN 
C  SUBROUTINES FUNC (OR FUNC1 OR FUNC2) FOR TIME RESETS NOT BEING
C  IDENTIFIED IF THE LAST DOSE TIME OCCURRED AFTER THE LAST 
C  OBSERVATION TIME IN A SECTION OF THE PATIENT'S FILE - SEE CODE AND
C  COMMENTS IN THOSE ROUTINES).

C  ALSO readi03.f IS CHANGED TO readi04.f (THE ONLY CHANGES ARE
C  DIMENSION CHANGES).

C  ALSO NOTE THAT IN it2beng17.f, THE SUBROUTINE BIGIT2B( ) STATEMENT
C  IS REPLACED BY A SUBROUTINE IT2B( ) STATEMENT. SO SUBROUTINE 
C  MAKEDRIV IN THIS PROGRAM NOW MAKES AN it2bdriv.f FILE WITH A 
C  CALL IT2B( ) STATEMENT, RATHER THAN A CALL BIGIT2B( ) STATEMENT.

C  6. BEFORE THE PROGRAM CALLS NEWCSV IN TWO PLACES, A NEW WRITE 
C  STATEMENT (FORMAT 1234) TELLS THE USER THAT THERE COULD BE A
C  SIGNIFICANT DELAY BEFORE HE SEES ANY MORE WRITING TO THE SCREEN.

C-----------------------------------------------------------------------

C  IT2B102.FOR                                             7/31/11

C  IT2B102 HAS THE FOLLOWING CHANGES TO IT2B101:

C  1. 'QMZJPZQX.CSV' IS NOW WRITTEN TO FILE 27 EXPLICITLY IN FORMAT
C  2112, RATHER THAN WITH THE A20 FORMAT IN FORMAT 2. THIS RESULTS IN 
C  THIS NAME BEING LEFT JUSTIFIED, RATHER THAN RIGHT JUSTIFIED, ON THE
C  LINE. AND THIS ENABLES IT TO BE READ CORRECTLY BY THE "ENGINE", AND
C  THEN WRITTEN CORRECTLY TO THE FROMxxxx FILE (IF THIS FILE IS NOT
C  LEFT JUSTIFIED, NPAG102.FOR DOES NOT READ IT CORRECTLY).

C  2. THE CALL GETNUMEQ STATEMENT IN SUBROUTINE VERIF1 IS CORRECTED.
C  PREVIOUSLY, THE LINE APPEARED (IN WORD) TO START IN COL. 7 AND END
C  IN COL. 68, BUT FUNNY CARRIAGE CONTROLS IN WORD --> IT ACTUALLY
C  STARTED IN COL. 2, WHICH MEANS THAT COL. 68 IS REALLY COL. 73 -->
C  IT IS AN IMPROPER FORTRAN STATEMENT. BUT gfortran DID NOT FLAG IT AS
C  SUCH, AND WHEN THIS LINE EXECUTED, IT CAUSED THE PROGRAM TO BOMB
C  WITH THE FOLLOWING REMARK:

C  "IT2B101.EXE has stopped working. A problem caused the program to 
C  stop working correctly. Windows will close the program and notify you
C  if a solution is available."

C  THE SOLUTION, OF COURSE, IS TO END LINE 1 WITH NUMEQT2, AND PUT
C  NDRUG2 ON THE 2ND LINE OF THE STATEMENT.

C  3. FORMAT 141 IN MAIN AND VERIF1 IS CHANGED SO THAT THE 2ND LINE FOR 
C  EACH OPTION IS INDENTED PROPERLY.

C-----------------------------------------------------------------------

C  IT2B101.FOR                                             7/20/11

C  IT2B101 HAS THE FOLLOWING CHANGES TO IT2B100:

C  1. THE ACTIVE (SALT) FRACTION, AF, WILL NOW BE A VECTOR. PREVIOUSLY,
C  IT WAS ASSUMED THAT ALL DRUGS HAD THE SAME AF; NOW EACH DRUG WILL
C  HAVE ITS OWN.

C  THE ABOVE CHANGE REQUIRES THE INSTRUCTION FILE TO BE CHANGED, AND
C  THIS REQUIRES A NEW CODE AT THE TOP (FROM 'REM_FRN JUL_10' TO
C  'REM_FRN JUL_11'). THIS REQUIRES CHANGES IN THE CODE WHERE THE
C  INSTRUCTION FILE IS WRITTEN, AS WELL AS WHERE IT IS READ. 

C  NOTE THAT INSTRUCTION FILES WITH THE CODE 'REM_FRN JUL_1O' WILL 

C  STILL BE READABLE, AND ALL AF(I), I=1,NDRUG, WILL BE SET TO THE 
C  SCALAR AF IN THOSE FILES.

C  IN ADDITION, SINCE AF IS PROVIDED TO THE "ENGINE" (THE FIRST MAIN
C  MODULE FOR THIS PROGRAM IS it2beng16.f), THE .inp FILE IS CHANGED
C  FROM it2bbig5.inp TO it2b101.inp.

C  ALSO, SINCE THE AF VALUES ARE WRITTEN TO THE OUTPUT FILE AND READ
C  IN BY SUBROUTINE EXTRAOPT, THE CODE FOR THE OUTPUT FILE WILL ALSO 
C  CHANGE FROM 'REM_FRN JUL_10' TO 'REM_FRN JUL_11'.

C  NOTE THAT SUBROUTINE GETNUMEQ HAS BEEN EXPANDED TO ALSO OBTAIN THE


C  NO. OF DRUGS, NDRUG, SINCE THIS VALUE IS NEEDED WHEN AF(I),I=1,NDRUG
C  ARE READ ... AND FOR THIS REASON, SUBROUTINE GETNUMEQ IS ALSO NOW
C  CALLED BEFORE AF(I) ARE READ (OR ESTABLISHED FROM THE OLD AF, NOW 
C  CALLED AFSCALAR) IN AN INSTRUCTION FILE. AND FOR THIS REASON, 
C  SUBROUTINE READBLOCK ALSO RETURNS NDRUG IN ADDITION TO NUMEQT WHEN
C  CALLED BY GETNUMEQ.

C  2. REFERENCE TO it2beng15 IS CHANGED TO it2beng16 IN Format 1111.
C  REFERENCE TO asseng6 IS CHANGED TO asseng7 in FORMAT 1113
C  (asseng7.f REPLACES asseng6.f ... BECAUSE IT MUST NOW READ
C  it2b101.inp RATHER THAN it2bbig5.inp).

C  3. CODE IN SUBROUTINE STACK IS CHANGED WHERE THE RS(.,.) VALUES ARE
C  MULTIPLIED (NOW) BY AF(.). 

C  4. PREVIOUSLY, THE LOCATION OF PATIENT INFORMATION WAS WRITTEN TO
C  THE .inp FILE AS A PREFIX AND AN EXTENSION (IF THIS INFO CAME INTO
C  THIS PROGRAM VIA A .CSV FILE, IT WOULD BE CONVERTED TO WORKING COPY
C  FORMAT WITH A PREFIX OF XQZPJ AND AN EXTENSION OF ZMQ), SO THIS INFO
C  COULD BE WRITTEN TO FROMFIL IN it2beng16.f, AND ACCESSED BY AN NPAG
C  RUN WHICH READ IN FROMFIL. 

C  NOW, THE LOCATION OF PATIENT INFORMATION WILL BE WRITTEN AS A .CSV
C  FILE (IN NEW FILE it2b101.inp), AND WILL THEREFORE BE WRITTEN BY
C  it2beng16.f TO THE FROMFIL IN THE SAME WAY.

C  NOTE THAT IF THE INFO COMES INTO THIS PROGRAM VIA WORKING COPY FILES,
C  IT WILL BE CONVERTED TO A .CSV FILE USING NEW SUBROUTINE WORKTOCSV,
C  WHICH IS BASED ON THE SAME ROUTINE IN MONT101C.FOR.

C-----------------------------------------------------------------------

C  IT2B100.FOR                                             4/29/11

C  IT2B100 (REVISED) IS THE SAME AS THE ORIGINAL IT2B100, EXCEPT THAT
C  A BUG HAS BEEN CORRECTED. NOW THE ARGUMENT LIST FOR THE TWO CALL 
C  READBLOCK STATEMENTS INCLUDE C0P,C1P,C2P,C3P.

C-----------------------------------------------------------------------

C  IT2B100.FOR                                             4/26/11

C  IT2B100 HAS THE FOLLOWING CHANGES TO ITBIG14:

C  1. A SMALL BUG IS REMOVED IN SUBROUTINE READBLOCK. IN FORMAT 11,
C  FILEIN IS NO LONGER REFERENCED - IT IS NOT PASSED TO THE ROUTINE,
C  AND SO WOULD BE PRINTED AS BLANKS IF FORMAT 11 WAS WRITTEN.

C  2. MANY CHANGES ARE MADE IN SUBROUTINES READBLOCK, WRITEDOS, ETC. 
C  SO THAT WT. AND CCR. ARE NO LONGER PUT IN AS DUMMY COVARIATES WHEN
C  THE WORKING COPY FILES ARE MADE FROM THE .CSV FILE. FROM NOW ON,
C  THE ONLY COVARIATES PUT INTO THE WORKING COPY FILES ARE THE ONES
C  SPECIFIED IN THE .CSV FILE. THIS WILL REQUIRE A NEW TEMPLATE MODEL
C  FILE (TSTMULTI.FOR, UPDATED FROM TSTMULTH.FOR) WHICH WILL NO LONGER
C  HAVE THE WARNINGS THAT THE USER SHOULDN'T REFER TO CV(1) AND CV(2)
C  IF THE PATIENT DATA INFO WAS INPUT VIA A .CSV FILE. ALSO THE DO 
C  LOOPS IN THAT FILE THAT WERE OVER I = 1,2+NADD WILL NOW BE OVER
C  I = 1,NADD (SINCE WT. AND CCR. WILL NOW BE INCLUDED AMONG THE NADD
C  ADDITIONAL COVARIATES). NOTE THAT FORMAT 919 IS CHANGED TO INDICATE
C  TSTMULTI.FOR RATHER THAN TSTMULTH.FOR.

C  ALSO NOTE THAT "NCOV" IN SUBROUTINES READBLOCK THROUGH THE REST OF
C  THE FILE (EXCEPT FOR SUBROUTINE GETCOVR2) HAS BEEN CHANGED TO 
C  "NCOVA". THIS STANDS FOR NO. OF ADDITIONAL COVARIATES - NOT 
C  INCLUDING THE 4 PERMANENT ONES AT THE TOP OF ALL WORKING COPY 
C  FILES (AGE, SEX, HEIGHT, ETHNICITY FLAG). 
C  THIS WAS DONE TO AVOID POTENTIAL CONFUSION TO "NCOV" IN THE 
C  EARLIER PART OF THIS FILE, WHERE NCOV = 4 + NADD (NADD AND
C  NCOVA ARE THE SAME). THIS SHOULD HAVE BEEN DONE IN EARLIER PROGRAMS.

C  3. THE FORMAT OF THE .CSV FILE READ BY READBLOCK IS CHANGED. THERE
C  WILL BE 4 ADDITIONAL COLUMNS (COL. NOS. 9 - 12) TO CONTAIN THE
C  ASSAY COEFFICIENTS FOR EACH PATIENT/OUTPUT EQ. SO NOW THE 12
C  PERMANENT COLUMNS WILL BE, IN ORDER, #ID, EVENT ID, TIME,
C  INFUSION DURATION, TOTAL DOSE, INPUT (DRUG) NO., OUTPUT VALUE,
C  OUTPUT EQUATION, C0, C1, C2, C3. ANY ADDITIONAL COVARIATES (BEYOND
C  THE 4 AT THE TOP OF EACH WORKING COPY FILE (AGE, SEX, HEIGHT, 
C  ETHNICITY FLAG) WILL HAVE THEIR COLUMNS AFTER THE PERMANENT 12
C  ABOVE.

C  NOTE THAT EACH PATIENT NEEDS ONE SET OF ASSAY COEFFICIENTS FOR EACH
C  OF THE NUMEQT OUTPUT EQUATIONS. IF ANY OF THESE NUMEQT SETS IS
C  MISSING, THE CORRESPONDING POPULATION SET OF ASSAY C'S FOR THAT
C  OUPUT EQUATION WILL BE ASSIGNED TO THAT PATIENT. FOR THIS REASON,
C  THE ARGUMENT LIST FOR READBLOCK WILL BE EXPANDED TO CONTAIN
C  C0P,C1P,C2P, AND C3P.

C  NOTE THAT EACH ROW IN THE .CSV FILE WHICH HAS EVENT ID = 0 (I.E., IS
C  AN OUPUT VALUE ROW) CAN HAVE ASSAY COEFFICIENT INFO. IF THIS INFO
C  IS SUPPLIED FOR THE SAME SUBJECT AND OUTPUT EQ. MORE THAN ONCE, THE
C  LAST SUCH ROW OF VALUES WILL BE USED. ALSO NOTE THAT IF ANY SET OF
C  ASSAY C'S IS INCOMPLETE (I.E., IT HAS AT LEAST ONE VALUE BUT NOT ALL
C  4), THE PROGRAM WILL STOP WITH A MESSAGE TO THE USER THAT THIS TYPE
C  OF INCOMPLETE ASSAY INFO LINE IS IMPERMISSABLE.

C  BECAUSE OF THE NEW .CSV FORMAT, THE CODE ON LINE 1 OF THE .CSV
C  FILE WILL CHANGE FROM BIGNPAG NOV_09 TO POPDATA APR_11. AND NOTE
C  THAT BECAUSE OF ALL THE CHANGES TO THIS FILE, AS WELL AS THE 
C  CORRESPONDING CHANGES REQUIRED IN THE TSTMULTI.FOR TEMPLATE MODEL
C  FILE (SEE ABOVE), THERE WILL BE NO BACKWARDS COMPATIBILITY TO
C  .CSV FILES WITH THE OLD BIGNPAG NOV_09 CODE ON LINE 1.

C  4. BECAUSE OF THE NEW WAY COVARIATES ARE TREATED IN THE TEMPLATE 
C  MODEL FILE (SEE TSTMULTI.FOR ABOVE), THE MAIN "ENGINE" MODULE FOR
C  THIS PROGRAM WILL BE CHANGED FROM itbig14.f TO it2beng15.f, AND THE
C  MAIN 'PRELIMINARY' "ENGINE" MODULE FOR THIS PROGRAM WILL BE CHANGED
C  FROM assbig5.f TO asseng6.f. SIMILARLY, FORMATS 1113 WILL BE 
C  CHANGED ACCORDINGLY.

C  5. THE INSTRUCTION FILE IS CHANGED TO HAVE A NEW CODE, REM_FRN APR_11
C  BECAUSE THE FILE WILL HAVE LOTS OF NEW TEXT TO DEFINE THE VALUES
C  WHICH IT CONTAINS, AND BECAUSE THE OPTION NOS. HAVE CHANGED FOR 
C  HOW PATIENT DATA INFO IS TO BE READ IN. NOW IFORMTT WILL BE READ IN
C  AND CONVERTED TO THE OLD IFORMT (SEE CODE), BOTH IN AN INSTRUCTION
C  FILE, AND VIA KEYBOARD.

C  6. FORMATS 1111 AND 1113 ARE CHANGED TO REFLECT THE NEW NAMES OF
C  THE "ENGINES" AND THAT shift5.f and readi01.f ARE CHANGED TO
C  shift6.f AND readi02.f, RESPECTIVELY.

C-----------------------------------------------------------------------

C  ITBIG14.FOR                                             3/2/11

C  ITBIG14 HAS THE FOLLOWING CHANGES TO ITBIG13:

C  1. FORMATS 1111 AND 1113 ARE CHANGED TO SHOW A BETTER WAY TO
C  COMPILE AND LINK THE "engine" USING gfortran (TO SPEED UP THE
C  EXECUTION). 

C  2. THE MAIN "engine" MODULE IS CHANGED FROM itbig13.f TO 
C  itbig14.f. AND A NEW MODULE, readi01.f, IS COMPILED AND LINKED
C  INTO THE "engine" (SEE itbig14.f CODE). THESE CHANGES ARE REFLECTED
C  IN FORMAT 1111.

C-----------------------------------------------------------------------

C  ITBIG13.FOR                                             2/8/11


C  ITBIG13 HAS A COUPLE OF SMALL BUG FIXES SO IT RUNS PROPERLY WHEN

C  THE PROGRAM IS BEING RUN UNDER UNIX. IN PARTICULAR, THE CODE TO
C  DELETE THE JUNKTRASH000_ FILES IF IOPT .EQ. 8 IN SUBROUTINE
C  EXTRAOPT ALLOWS FOR A UNIX RUN. SIMILARLY IN SUBROUTINE PRNCOVAR
C  FOR THE COMMAND TO CLEAR THE SCREEN.
	
C-----------------------------------------------------------------------

C  ITBIG12.FOR                                              1/19/11

C  ITBIG12 HAS TWO CHANGES FROM ITBIG11:

C  1. NEW CODE HAS BEEN ADDED/EDITED TO MAKE THIS PROGRAM USABLE ON A
C  MAC AS WELL AS A PC (SEE ALL CODE following 'Yamada'). NOTE THAT 
C  BECAUSE OF THE CALLS TO SUBROUTINES GET_COMMAND_ARGUMENT AND GETCWD, 
C  THIS PROGRAM CANNOT BE COMPILED BY LAHEY LF90. IT REQUIRES gfortran. 
C  SEE ITBIG12.EXP.

C  2. IT CORRECTS A SUBTLE BUG IN SUBROUTINE READBLOCK. PREVIOUSLY IF

C  AN IV STARTED AT EXACTLY THE ENDING TIME OF THE PREVIOUS IV, THIS
C  WOULD RESULT IN BOTH 0.0 AND THE NEW IV RATE BEING ASSIGNED TO THE
C  SAME TIME. THE RESULT, IN WRITEDOS, WOULD BE THAT 0.0 WOULD BE 
C  ASSIGNED TO THIS TIME (I.E., THE NEW IV RATE WOULD BE LOST). NOW, 
C  THIS BUG IS CORRECTED IN SUBROUTINE READBLOCK, WHERE THE BEGINNING 
C  TIME OF EACH IV IS TESTED AGAINST THE ENDING TIME OF THE PREVIOUS
C  (IF THERE IS A PREVIOUS ONE), AND IF THEY ARE THE SAME, THEN THE NEW
C  IV RATE OVERWRITES THE 0.0 WHICH WOULD HAVE BEEN THE NEW IV RATE IF
C  THERE HADN'T BEEN ANOTHER STARTING IV AT THAT TIME.

C  3. FORMAT 1111 IS CORRECTED TO SHOW itbig13 RATHER THAN itbig9z
C  AS THE NAME OF THE EXECUTABLE "ENGINE" PROGRAM.

C-----------------------------------------------------------------------

C  ITBIG11.FOR                                             12/29/10


C  ITBIG11 HAS THE FOLLOWING CHANGES FROM ITBIG10:

C  1. THE CALL TO SUBROUTINE DETECT IS COMMENTED OUT. THE REASON IS
C  THAT IT WILL NOW BE ASSUMED THAT THE USER CREATES HIS MODEL FILE
C  FROM THE TEMPLATE MODEL FILE (CURRENTLY TSTMULTH.FOR) AND SO IT
C  WILL AUTOMATICALLY HAVE THE CORRECT DECLARATION STATEMENTS AT THE
C  TOP OF EACH SUBROUTINE. PLUS, THIS WILL PREVENT THIS PROGRAM FROM
C  STRIPPING AWAY SPECIAL DECLARATION STATEMENTS THE USER MAY NEED TO
C  ADD TO THE ROUTINES FOR SPECIAL CASE ANALYSES.

C  NOTE THAT SUBROUTINE DETECT, AND THE ROUTINES IT CALLS, WILL BE LEFT
C  IN THE CODE FOR NOW (IN CASE THEY, OR MODIFIED VERSIONS OF THEM ARE
C  NEEDED IN A FUTURE VERSION OF THIS PROGRAM).

C  2. FORMAT 919 IS CHANGED TO EMPHASIZE THAT THE USER MUST CREATE
C  HIS FORTRAN MODEL FILE AS AN EDITED VERSION OF TSTMULTH.FOR. FORMAT
C  5001 IS ALSO CHANGED TO TAKE OUT THE "BOXES" COMMENT, WHICH IS NO

C  LONGER APPLICABLE (AND HASN'T BEEN FOR SOME TIME).

C  3. THE NEW MAIN "ENGINE" MODULE FOR THE IT2B ANALYSIS WILL BE
C  CHANGED FROM itbig9z.f TO itbig13.f. THIS MODULE WILL CALL
C  NEW id__ MODULES, WHICH WILL BE CONSISTENT WITH THE NEW TEMPLATE
C  MODEL FILE, TSTMULTH.FOR (WHICH ALLOWS ANALYTICAL SOLUTIONS OF THE
C  3-COMPARTMENT LINEAR MODEL). SIMILARLY, THE NEW MAIN "ENGINE" MODULE

C  FOR THE PRELIMINARY PROGRAM WHICH WILL BE USED TO OBTAIN OPTIMUM
C  ESTIMATES FOR THE ASSAY COEFFICIENTS WILL BE CHANGED FROM
C  assbig4z.f TO assbig5.f. BECAUSE OF THIS, FORMATS 1111 AND 1113
C  ARE CHANGED TO REFLECT NEW PROGRAM AND FILE NAMES.


C-----------------------------------------------------------------------



C  ITBIG10.FOR                                               12/02/10

C  ITBIG10 HAS THE FOLLOWING CHANGES FROM ITBIG9.

C  1. BEFORE THE TWO CALLS TO SUBROUTINE READBLOCK, NEW CODE IS PUT IN
C  TO CALL NEW SUBROUTINE NEWCSV (BASED ON THE STAND-A-LONG PROGRAM,
C  NEWCSV.FOR) WHICH CONVERTS THE .CSV FILE INTO A SCRATCH FILE WITH
C  EACH MISSING VALUE DOT REPLACED BY AN n. THIS IS NECESSARY SINCE,
C  WHEN THIS PROGRAM IS COMPILED/LINKED WITH gfortran, IT INTERPRETS
C  A DOT AS A 0 (I.E., A NUMBER RATHER THAN A NON-NUMBER). THE RESULT

C  IS THAT THE STATEMENT ...
C    READ(57,*,ERR=70) COVVAL
C  IS IMPROPERLY EVALUATED WHEN A DOT IS READ. I.E., RATHER THAN


C  BRANCHING TO LABEL 70, THE PROGRAM SETS COVVAL = 0 AND CONTINUES.

C  SINCE THERE ARE OTHER SIMILAR READ STATEMENTS, RATHER THAN TRY TO
C  ADDRESS EACH ONE INDIVIDUALLY, READBLOCK WILL READ THE SCRATCH FILE
C  INSTEAD OF THE ORIGINAL .CSV FILE. SINCE gfortran SEES AN n AS A
C  NON-NUMBER, THE CODE WILL NOW BE EXECUTED CORRECTLY.


C  NOTE THAT BLOCKPAT WILL NOW BE OPENED AS FILE 77, AND THE SCRATCH
C  FILE WILL BE FILE 67.

C  2. IN SUBROUTINE AFTERCOMMA, THE FREE FROMAT WRITE STATEMENT TO
C  FILE 57 IS REPLACED BY A SERIES OF FORMATTED WRITE STATEMENTS,
C  BASED ON THE NO. OF CHARACTERS TO BE WRITTEN (1 - 11). IF THE NO. OF
C  CHARACTERS IS > 11, A FREE FORMAT IS STILL USED. THE REASON IS THAT
C  WHEN THIS PROGRAM IS COMPILED AND LINKED UNDER gfortran, A FREE
C  FORMAT WRITE HAS AN EXTRA SPACE INSERTED AT THE BEGINNING OF THE
C  LINE. THIS MEANT THAT, WHEN A .CSV FILE HAD AN 11 CHARACTER
C  SUBJECT ID, ONLY THE 1ST 11 WOULD BE WRITTEN TO FILE 57. THEN, IN
C  READBLOCK, WHEN FILE 57 WAS READ, TWO OR MORE SUBJECTS WHOSE FIRST
C  10 CHARACTERS WERE THE SAME (I.E., THEY HAD DIFFERENCES ONLY IN THE
C  11TH CHARACTER) WOULD HAVE THEIR DATA COMBINED INTO THE SAME WORKING
C  COPY PATIENT DATA FILE. THIS PROBLEM DID NOT OCCUR WHEN THIS PROGRAM

C  WAS COMPILED UNDER LAHEY F90.

C  3. FORMATS 1111 AND 1113 ARE CHANGED TO REFLECT THE FACT THAT THE
C  MAIN "ENGINE" MODULES ARE itbig9z.f AND assbig4z.f (AND THE COMPILE
C  AND LINK COMMAND EXAMPLES ARE WRITTEN FOR THE gfortran COMPILER,
C  ALTHOUGH THE LAHEY LF90 COMPILER STILL WORKS, OF COURSE). NOTE THAT
C  THE MAIN CHANGES IN itbig9z.f AND assbig4z.f ARE THE SAME AS NO. 3.
C  BELOW.

C  4. A CALL TO NEW SUBROUTINE PAUSE REPLACES EACH PAUSE STATEMENT.
C  THIS IS BECAUSE A PAUSE STATEMENT CAUSES A WARNING WHEN THE PROGRAM
C  IS COMPILED AND LINKED USING gfortran (AND IT FORCES THE USER TO
C  TYPE "go" INSTEAD OF SIMPLY HITTING THE ENTER KEY). ALSO, SEVERAL
C  PAUSE STATEMENTS THAT WERE PREVIOUSLY COMMENTED OUT ARE NOW
C  "REINSTATED" WITH CALL PAUSE COMMANDS.

C  5. ONE OF THE MODULES LINKED WITH THIS PROGRAM, SCAT72X.FOR, IS
C  UPDATED TO BE SCAT72X1.FOR. THE CHANGE IN THAT PROGRAM IS THE SAME
C  AS NO. 3. ABOVE.

C  6. A COSTMETIC CHANGE IS MADE WHEN IRUNIT = 1. SINCE THIS PROGRAM CAN

C  NOW BE COMPILED AND LINKED WITH gfortran AS WELL AS LF90, INDPTS,
C  WHICH WAS NOT PREVIOUSLY SET IF IRUNIT = 1, WILL NOW BE SET = 0 IN
C  THIS CASE. THE REASON IS THAT gfortran SETS UNDEFINED VARIABLES TO
C  RANDOM NUMBERS RATHER THAN 0. SINCE INDPTS IS NOT USED IN THE

C  itbigxx.exe "engine", THIS CHANGE IS ONLY COSMETIC (IT MAKES THE
C  it2bbig5.inp FILES MADE BY LF90 AND gfortran LOOK ALIKE).

C  7. A BUG CORRECTION IS MADE IN SUBROUTINE VERIF1. SINCE ISUBALL IS
C  NOT SET BEFORE THE CALL TO THIS ROUTINE IF AN INSTRUCTION FILE IS
C  USED, THE CODE INVOLVING ISUBALL IS CHANGED TO INVOLVE A  DIRECT
C  COMPARISON OF NSUB TO NSUBTOT.

C  NOTE THAT BECAUSE THERE ARE NO CALLS TO SUBROUTINES
C  GET_COMMAND_ARGUMENT AND GETCWD (SEE YAMADA CODE IN NPBG15E3.FOR),

C  THIS PROGRAM CAN STILL BE COMPILED BY LAHEY LF90.


C-----------------------------------------------------------------------

C  ITBIG9.FOR                                                7/28/10

C  ITBIG9 HAS ALL THE CHANGES TO ITBIG8 REQUIRED TO BRING THIS PROGRAM
C  UP TO THE NPBG15E1.FOR LEVEL. THESE CHANGES ARE THOSE FROM
C  NPBIG15.FOR THROUGH NPBG15E1.FOR. THEY ARE AS FOLLOWS:

C  1. THIS PROGRAM ALLOWS MULTIPLE DRUGS. CODING CHANGES ARE REQUIRED
C  IN SUBROUTINES FILRED, STACK, GETCOVAL, PUTASS, GETNUMEQ, AND GETNUM
C  (MANY OF WHICH ARE THE SAME OR VIRTUALLY THE SAME AS THE SAME
C  ROUTINES IN NPBG15E1.FOR). ALSO, NEW ROUTINE GETCOVR2 IS COPIED FROM
C  NPBG15E1.FOR.

C  NOTE THAT EACH DRUG WILL HAVE ONE COLUMN FOR IV VALUES AND ONE
C  COLUMN FOR BOLUS VALUES. IN ADDITION THERE ARE OTHER CHANGES TO THE
C  FORMATTING (SEE 2DRUG001 FOR AN EXAMPLE OF A TYPICAL NEW WORKING
C  COPY PATIENT DATA FILE).

C  2. SUBROUTINE DETECT IS ESSENTIALLY THE SAME AS IN NPBG15E1.FOR, AND
C  THE ROUTINES WRITEDIF, WRITEOUT, WRITESYM, AND SKIPLINE ARE COPIED
C  FROM NPBG15E1.FOR.


C  3. PATIENT DATA FILES WILL NOW BE LIMITED TO JUST THE NEW WORKING
C  COPY FORMAT, OUTPUT BY ANDREAS' NEW BOXES PROGRAM. I.E., THE
C  IFORMT = 2 OPTION (USC*PACK FORMAT) HAS BEEN ELIMININATED. IFORMT
C  WILL STILL BE WRITTEN TO AND READ FROM THE INSTRUCTION FILE TO
C  MINIMIZE THE AMOUNT OF CODE WHICH MUST BE CHANGED.

C  NOTE THAT IN SEVERAL PLACES IN THE CODE, IFORMT IS NOW HARDCODED
C  TO 1, AND CODE RELATED TO EITHER IFORMT = 2 OR IDIRCT = 1 HAS BEEN
C  REMOVED.

C  NOTE THAT CALL CONVRT IS NO LONGER NEEDED (I.E., THE PATIENT DATA
C  FILES WILL NEVER BE CONVERTED FROM USC*PACK FORMAT) --> THIS
C  PROGRAM WILL NO LONGER BE LINKED WITH CONVRTLO.FOR.


C  NOTE THAT PRFIX2, EXT2, AND INFIL ARE REMOVED FROM THE PROGRAM AS
C  THEY ARE NO LONGER NEEDED.

C  4. NEW SUBROUTINE READBLOCK, ALONG WITH THE ROUTINES IT NEEDS
C  (WRITEDOS, AFTERCOMMA, GETCHAR, THESAME, GETID, TIMESET, PUTORDER,
C  FIXOUTIM AND GETMAXTIM) ARE COPIED FROM NPBG15E1.FOR TO READ THE
C  NEW PATIENT DATA BLOCK FORMAT, AND THEN PUT THIS INFO INTO WORKING
C  COPY PATIENT DATA FILES (MULTIPLE DRUG VERSION).


C  5. THE NEW MAIN "ENGINE" MODULE FOR THE IT2B ANALYSIS WILL BE
C  CHANGED FROM itbig991.f TO itbig9x.f. THIS MODULE WILL CALL
C  NEW id__ MODULES, WHICH WILL BE CONSISTENT WITH THE NEW TEMPLATE
C  MODEL FILE, TSTMULTG.FOR. SIMILARLY, THE NEW MAIN "ENGINE" MODULE

C  FOR THE PRELIMINARY PROGRAM WHICH WILL BE USED TO OBTAIN OPTIMUM
C  ESTIMATES FOR THE ASSAY COEFFICIENTS WILL BE CHANGED FROM
C  assbig33.f TO assbig4.f. ALSO, NOTE THAT THE SHIFT MODULE CALLED BY
C  THE NEW id__ ROUTINES IS NOW shift5.f, CHANGED FROM shift2.f.

C  6. THE INSTRUCTION FILE MADE BY THIS PROGRAM AND PASSED TO EITHER THE
C  itbig9x.f or assbig4.f PROGRAM WILL BE CHANGED FROM it2bbig3.inp TO
C  it2bbig5.inp. THIS NEW FILE WILL INCLUDE NEW INFO, NSUBTOT AND
C  IPATVEC, WHERE IPATVEC HOLDS THE INDICES OF THE PATIENTS WHICH ARE TO
C  BE USED IN A RUN. NOTE THAT THE DATA FROM ALL NSUBTOT PATIENTS (NOT
C  JUST THE NSUB "ACTIVE" SUBJECTS) WILL BE INCLUDED IN it2bbig5.inp.

C  7. PATH IS CHANGED FROM *61 TO *60 THROUGHOUT THE FILE TO BE THE
C  SAME AS IN NPBG15E1.FOR. SIMILARLY, TMPFILE IS CHANGED FROM *12 TO
C  *13. BECAUSE OF THIS, IN SUBROUTINE FULLNAME, FILE*12 IS CHANGED
C  TO FILE*13.

C  8. THE USER NOW SELECTS A PATIENT DATA SET TO BE INPUT, BUT THEN
C  CAN SELECT SUBSETS OF THIS DATA SET FOR ANY PARTICULAR RUN. THE
C  MAIN I/O FOR THIS IS DONE VIA THE NEW SUBROUTINES GETIPAT AND
C  GETIPATF. NOTE THAT THE NEW VARIABLE NSUBTOT = THE TOTAL NO. OF


C  SUBJECTS IN THE DATA SET (NSUB REMAINS AS THE NO. OF SUBJECTS TO
C  BE ANALYZED IN A GIVEN RUN).

C  9. BECAUSE NEW INFO (SEE ABOVE) IS REQUIRED FOR THE INSTRUCTIONS,
C  THE INSTRUCTION FILE WILL HAVE A NEW CODE AT THE TOP,
C  REM_FRN JUL_10. THIS IS THE ONLY CODE THAT WILL BE ACCEPTED FOR
C  THIS FIRST PROGRAM IN THIS NEW "BIG" IT2B SERIES.

C  10. SUBROUTINE EXTRAOPT HAS CHANGES SINCE IT WILL READ IN NSUBTOT
C  AND IPATVEC(I),I=1,NSUB TO TELL IT WHICH PATIENTS WERE USED IN THE
C  ANALYSIS. NOTE THAT ONLY THE DATA FROM THE NSUB "ACTIVE" SUBJECTS
C  ARE INCLUDED IN THE OUTPUT FILE OF A COMPLETED RUN. BECAUSE OF THE
C  NEW INFO., THE OUTPUT FILE WILL HAVE A DIFFERENT CODE.

C  11. NOTE THAT MAJOR CHANGES OCCUR IN THE I/O IN MAIN AND VERIF1, AS
C  WELL AS IN EXTRAOPT, AND 10 NEW ROUTINES ARE ADDED ... GETIPAT,
C  GETNUMS, GETSUB, GETNSUB, WRITEPAT, WRITEPT2, GETIPATF, GETIPATFF,
C  GETNUMSF, AND GETNSUB2.

C  12. IN ALL ROUTINES (EXCEPT TEMP IN SEEDIR), *72'S ARE CHANGED TO BE
C  *1000'S - TO BE CONSISTENT WITH NPBG15E1.FOR. AS A RESULT ALL
C  CORESPONDING A72'S ARE CHANGED TO A1000'S. THIS PREVENTS LONG LINES
C  IN OUTPUT FILES MADE BY SOME COMPUTERS FROM BEING TRUNCATED.
C  SIMILARLY IN SUBROUTINE PUTASS, THIS CHANGE IS NECESSARY TO PREVENT
C  COPIED LINES FROM BEING CUTOFF.

C  13. CALL TIME AND CALL DATE STATEMENTS ARE REPLACED BY THE
C  CALL DATE_AND_TIME(DATDAY,TIMDAY,ZONEDAY,IDTDAY) STATEMENT
C  IN SUBROUTINE EXTRAOPT. DATDAY, TIMDAY, AND ZONEDAY
C  ARE ALL DECLARED TO BE CHARACTER*10 VARIABLES. AND IDTDAY IS
C  INTEGER IDTDAY(10).

C  14. THE FEW CHANGES REQUIRED IN SUBROUTINE USERPREP ARE DONE BY USING

C  THE SAME SUBROUTINE AS IN NPBG15E1.FOR.

C  15. THE DIMENSIONS OF PAR, PARFIX, VALFIX, AND IRAN ARE
C  MADE CONSISTENT WITH THE MAXIMUM ALLOWED VALUES (A MAXIMUM OF 30
C  RANDOM PARAMETERS AND 20 FIXED PARAMETERS). IN PARTICULAR:


C  ALL ARRAYS RELATED TO THE NO. OF RANDOM VARIABLES ARE NOW DIMENSIONED
C  30; ALL ARRAYS RELATED TO THE NO. OF FIXED PARAMETERS ARE NOW
C  DIMENSIONED 20; AND IRAN IS NOW DIMENSIONED 32.

C  ALSO, ALL FORMATS RELATED TO THE NO. OF RANDOM VARIABLES ARE CHANGED

C  TO 30 FROM 25 OR 20; SIMILARLY THOSE RELATED TO THE NO. OF FIXED VARIABLES
C  ARE CHANGED FROM 12 TO 20.


C  16. FORMATS 1111 AND 1113 ARE CHANGED TO REFLECT NEW PROGRAM AND
C  FILE NAMES.

C  17. IVERS IS HARDCODED TO BE 0 IN SUBROUTINE DETECT. THE IVERS = 1
C  OPTION WAS NEVER USED ANYMORE.

C  18. MAXSUB IS CHANGED FROM 999 TO 800 TO BE CONSISTENT WITH THE BIG
C  NPAG PROGRAM, NPBG15E1.FOR (IN THAT PROGRAM, THE CHANGE WAS NECESSARY
C  FOR THE PROGRAM TO RUN WITHOUT CRASHING WHEN SUBROUTINE READBLOCK WAS
C  CALLED, WITH THE ERROR MESSAGE, "Insufficient RAM to continue" <--
C  ON AND OLD WINDOWS XP MACHINE).

C  19. ALL OF THE STOP COMMANDS IN THE PROGRAM ARE NOW PRECEEDED BY A

C  PAUSE COMMAND ... SO THAT THE USER CAN SEE THE MESSAGE INDICATING
C  WHY THE PROGRAM STOPPED BEFORE THE SCREEN CLOSES.


C  20. IN SUBROUTINE GETCOVAL, THE MEAN OF EACH COVARIATE IS
C  NOW READ IN WITH A FREE FORMAT TO MAKE SURE THAT IF THE VALUE

C  STARTS IN AN UNEXPECTED ENTRY IT STILL WILL BE READ CORRECTLY
C  (ASSUMING IT IS THE 3RD NUMBERIC VALUE ON THE LINE).

C  21. SUBROUTINE GETCOVR2 REPLACES GETCOVAR. THE DIFFERENCE IS THAT
C  GETCOVR2 READS CURRENT, MULTIPLE DRUG STYLE, WORKING COPY PATIENT
C  FILES.

C  22. AFTER THE PROGRAM MAKES it2bdriv.f or assdriv.f AND it2bbig5.inp,
C  IT WILL MAKE SURE THAT THERE ARE NO EXTRA LINES WITH SPURIOUS
C  CHARACTERS(E.G., LITTLE BOXES) AT THE END OF THESE FILES, BY COPYING

C  THESE FILES LINE BY LINE TO TEMP FILES, AND THEN COPYING THE TEMP
C  FILES BACK TO THE ORIGINAL FILES. SEE CODE AROUND LABELS 3100 AND
C  4100.

C  23. SUBROUTINE FILRED HAS BEEN COMPLETELY REPLACED BY THE FILRED OF
C  NPBG15E1.FOR. THE NEW FILRED IS COMPATIBLE WITH THE NEW MULTIPLE DRUG
C  FORMAT FILES (FOR WORKING COPY PATIENTS) THAT ARE NOW USED. NOTE THAT
C  I26 HAS BEEN REMOVED FROM THE ARGUMENT LIST. IT WASN'T NEEDED.

C  24. SUBROUTINE STACK HAS BEEN COMPLETELY REPLACED BY THE STACK OF
C  NPBG15E1.FOR. THE NEW STACK IS COMPATIBLE WITH THE NEW MULTIPLE DRUG
C  FORMAT FILES (FOR WORKING COPY PATIENTS) THAT ARE NOW USED. NOTE THAT
C  I26 HAS BEEN REMOVED FROM THE ARGUMENT LIST. IT WASN'T NEEDED.

C  25. SUBROUTINE PRNLAST HAS BEEN CHANGED TO BE LIKE THAT IN
C  NPBG15E1.FOR. THE DIFFERENCE IS THAT NOW THE USER CAN ABORT THE
C  PRINTING AFTER EACH SCREENFUL OF INFO.

C  26. IN THE WORKING DIRECTORY ...\BIGIT2B, LINKIT9X.BAT WILL MAKE
C  itbig9x.exe, AND LINKASS4.BAT WILL MAKE assbig4.exe.

C NOTE: THIS PROGRAM WILL CONSIST OF ITBIG9.FOR, DATABLK1.FOR (UNCHANGED),
C AND SCAT72X.FOR (UNCHANGED).

C-----------------------------------------------------------------------


C  ITBIG8.FOR							3-19-05

C  ITBIG8 HAS THE FOLLOWING CHANGES FROM ITBIG7:

C  1. IT IS A NON-GRAPHICS VERSION OF ITBIG7. IT WILL BE
C  COMPILED AND LINKED USING FORTRAN 90 (LF90) RATHER THAN FORTRAN 77

C  (F77L3) AND SO WILL NOT BE ABLE TO USE THE INTERACTOR GRAPHICS
C  ROUTINES.

C  THIS PROGRAM WILL CONSIST OF ITBIG8.FOR, CNVRTLO1.FOR,
C  DATABLK1.FOR (UNCHANGED), AND SCAT72X.FOR.

C  ALL THE GRAPHICS RELATED CODE HAS BEEN REMOVED. IN ADDITION, IN
C  SUBROUTINE MAKEDRIV, THE CALL SYSTEM COMMANDS ARE CHANGED. THE
C  REASON IS THAT THE WINDOWS XP PRO OPERATING SYSTEM APPENDS FILES
C  BY USING THE LOGIC: COPY FILE1 + FILE2 FILE3 <-- APPENDS FILE2 BELOW
C  FILE1 AND CALLS IT FILE3. THIS IS DIFFERENT THAN IN WINDOWS 98, WHERE
C  THE ABOVE IS DONE BY SIMPLY TYPING COPY FILE1+FILE2.
C  (SEE TEMP1.FOR FOR TEST PROGRAM).

C  NOTE THAT GRAPHICS-RELATED ROUTINES, GETOUT, PLOTSD, HISTOG,
C  THREED1, CONVERGE, PLTCON, MINMAX, AND EXTREME ARE ALL REMOVED.

C  NOTE THAT ALL CODE RELATED TO SHOWING THE USER PLOTS OF S.D.(I)
C  VS. OBS(I) HAS BEEN REMOVED.

C  CNVRTLO1.FOR IS CHANGED FROM CONVRLO.FOR. THE CHANGES WERE NEEDED
C  BECAUSE THE LF90 COMPILER CAUGHT BUGS THAT THE F77L3 COMPILER DID
C  NOT, NAMELY THAT MPERTU WAS DECLARED REAL IN TWO ROUTINES, BUT NOT
C  IN 3 OTHERS. THIS WAS FIXED IN CNVRTLO1.FOR

C  SCAT72X.FOR IS THE NON-GRAHPICS VERSION OF SCAT71.FOR. IT DOES NO
C  PLOTS, BUT DOES MANY CALCULATIONS (E.G., PREDICTED VALUES,
C  REGRESSION COEFFICIENT, ETC.) WHICH CAN BE WRITTEN TO FILES.
C  NOTE THAT TWO EXTRA ARGUMENTS ARE ADDED AT THE END OF THE ARGUMENT
C  LIST TO MAKE THESE CALL STATEMENTS COMPATBILE WITH SCAT72X'S
C  SCATPLOT ARGUMENT LIST (WHICH NEEDED THE EXTRA 2 ARGUMENTS FOR THE
C  BIG NPAG PROGRAM - THEY ARE IERRMOD AND GAMLAM WHICH ARE USED TO
C  ESTABLISH THE ASSAY S.D.'S. DEFAULT VALUES OF 1 AND 1.D0 ARE USED
C  IN THIS PROGRAM SO THE ASSAY S.D.'S ARE CALCULATED AS USUAL).


C  2. SUBROUTINE EXTRAOPT IS CHANGED TO ALLOW THE READING IN OF A
C  COMBINED OUTPUT FILE ... SINCE THE NEW BIG IT2B "ENGINE" (STARTING
C  WITH itbig8.f) NOW CONCATENATES ALL INFO INTO ONE COMBINED OUTPUT.

C  NEW SUBROUTINES SEPARATE AND GETNUM ARE ADDED TO HELP READING IN
C  THE COMBINED OUTPUT FILE.


C  3. SUBROUTINE WRITESYM IS CHANGED TO ADD A COMMON/FRABS/IFA TO
C  SUBROUTINE SYMBOL'S CODE. THIS WILL ENABLE THE "ENGINE" TO
C  PASS FA TO THE id MODULES SO FA CAN BE EITHER A FIXED OR RANDOM
C  PARAMETER. NOTE THAT THIS MEANS THAT NOW THE FORTRAN TEMPLATE TO


C  BE USED C  C  FOR THIS PROGRAM WILL BE INITCND2.FOR, RATHER THAN
C  INITCOND.FOR.

C  NOTE THAT THE "ENGINE" PROGRAM TO BE USED WITH THIS PROGRAM (I.E.,
C  TO HAVE A COMMON/FRABS/IFA STATEMENT) WILL BE
C  itbig9.f + idfxd51f.f + idcy_53f.f + idcp_3f.f + shift2.f + vodtot.f.

C  NOTE THAT itbig9.f IS AN UPDATE TO itbig8x.f - THE SIGNIFICANT

C  CHANGE IS THE PRODUCTION OF A COMBINED OUTPUT FILE.
C  NOTE THAT idfxd51f.f IS AN UPDATE FROM itfxd51d.f - i.e., THE NAME
C  idfxd51e.f WAS SKIPPED SINCE idfxd51f.f WILL BE AT THE SAME
C  "LEVEL" AS idfix5f.f, THE NPAG ROUTINE. NOTE THAT idcy_53f.f IS
C  ALREADY USED BY THE BIG NPAG PROGRAM AND IS AN UPDATE FROM
C  idcy_53e.f. NOTE THAT idcp_3f.f IS AN UPDATE FROM idcp_3d.f - i.e.,
C  THE NAEM idcp_3e.f WAS SKIPPED SINCE IT WILL BE AT THE SAME LEVEL AS
C  idfxd51f.f.


C  4. A SMALL BUG WAS FIXED IN SUBROUTINE EXTRAOPT. INFIL*20,PRFIX2*5,
C  EXT2*3 WERE ADDED IN THE CHARACTER STATEMENT. THESE SHOULD HAVE BEEN

C  PRESENT IN ITBIG7, BUT APPARENTLY THE F77L3 COMPILER DIDN'T CATCH
C  THEM, UNLIKE THE LF90 COMPILER/LINKER.

C-----------------------------------------------------------------------

C  ITBIG7.FOR							4-5-02

C  ITBIG7 HAS THE FOLLOWING CHANGES TO ITBIG6:

C  1. THE CALCULATION OF TRULOG, THE "TRUE" LOG-LIKELIHOOD, IS
C  CHANGED. RATHER THAN CALCULATE IT USING A GRID SIMILAR TO THAT
C  USED IN THE NPEM/NPAG PROGRAMS, IT WILL BE CALCULATED ASSUMING
C  A "GRID" OF THE FINAL NSUB PARAMETER ESTIMATES, EACH WITH AN
C  ASSOCIATED PROBABILITY OF 1/NSUB. THIS CHANGES THE VALUES OF
C  AIC AND BIC OF COURSE (SEE CODE). THE CALCULATIONS ARE DONE IN
C  itbig7.f, BUT IN THIS MODULE:

C   a. ILOG=0/1 WILL BE HARDCODED TO ILOG=0 SINCE THE NEW CODE WON'T
C      TAKE VERY LONG (AND NGRID WILL BE HARDCODED = 99999).

C   b. THE QUESTION ABOUT WHICH INDEX OF GRID POINTS IS TO BE USED IS
C      NOW N/A AND HAS BEEN REMOVED.


C   c. ARRAY SPXGYJ IS NO LONGER NEEDED, SINCE IT WAS ONLY NEEDED IN THE
C      CALCULATION OF THE SCALED INFORMATION AND ENTROPY OF THE
C      NPEM-LIKE DENSITY, BUT THESE VALUES ARE NO LONGER CALCULATED
C      SINCE THEY INVOLVE A DIVSION BY LOG(NGRID/NSUB) AND NGRID = NSUB
C      IN THE NEW FORMULATION OF THE NPEM-LIKE DENSITY (WHICH MEANS

C      THERE WOULD NOW BE A DIVSION BY 0). BUT IT WILL REMAIN
C      DIMENSIONED FOR NOW SO THE it2bdriv.f MODULE CREATED BY THIS


C      PROGRAM WILL REMAIN COMPATIBLE WITH THE MODULES CURRENTLY ON
C      THE MAINFRAMES. SIMILARLY, PXGEE, WHICH IS NO LONGER NEEDED,
C      WILL ALSO REMAIN DIMENSIONED FOR NOW.

C  2. THE IMEN/IMED CODE AND COMMENTS IN SUBROUTINE EXTRAOPT HAVE
C  NOW BEEN REMOVED. THEY SHOULD HAVE BEEN REMOVED IN ITBIG6.FOR
C  (WHEN THEY WERE NO LONGER RELEVANT).

C  3. FORMAT 6502 IS CHANGED SLIGHTLY IN SUBROUTINE EXTRAOPT, AND FORMAT
C  7133 IN SUBROUTINE PRNCOVAR IS CHANGED SLIGHTLY.


C  4. THIS PROGRAM WILL BE LINKED WITH SCAT71.FOR, RATHER THAN
C  SCAT6.FOR. SCAT71 HAS NEW WORDS REGARDING PRECISION AND
C  SCAT71 HAS A "BUG" CORRECTION TO SCAT7.

C-----------------------------------------------------------------------

C  ITBIG6.FOR							1-09-01


C  ITBIG6 HAS THE FOLLOWING CHANGES TO ITBIG5:

C  1. A NEW SUBROUTINE, DETECT, IS CALLED BY MAIN JUST BELOW THE CALL
C  TO USERPREP TO MAKE SURE THE USER'S FORTRAN MODEL FILE IS THE CORRECT
C  VERSION FOR THE LOCATION HE IS RUNNING IT (I.E., EITHER THE
C  PARALLELIZED VERSION AT SDSC AND USC/LAB, OR THE NON-PARALLELIZED
C  "BETA" VERSION ON THE USC sun). ADDITIONAL NEW SUBROUTINES ARE

C  CHECKLIN, WRITEDIF, WRITEOUT, WRITESYM, AND SKIPLINE.


C  NOTE ALSO THAT SUBROUTINE DETECT RETURNS TO MAIN IVERS WHICH WILL
C  = 1 (IF THE RUN IS TO BE DONE AT SDSC/USC LAB) OR 0 (IF THE RUN IS
C  TO BE DONE ON THE USC sun). THEN IVERS WILL DETERMINE WHETHER THE
C  INSTRUCTION FILE TO BE MADE WILL BE CALLED it2bbig2.inp (IVERS=1) OR
C  it2bbig3.inp (IVERS=0). NOTE THAT A NEW FORMAT 5381, AND ALTERED CODE
C  AROUND 5381 ARE REQUIRED TO INPLEMENT THIS CHANGE.


C  NOTE ALSO THAT A CLOSE(28) STATEMENT IS ADDED AFTER THE CALL TO
C  USERPREP IN MAIN. IT SHOULD HAVE BEEN THERE PREVIOUSLY BUT DID NO
C  HARM SINCE FILE 28 WAS NOT USED AGAIN. NOW IT MUST BE THERE SINCE
C  FILE 28 IS USED BY SUBROUTINE DETECT.

C  NOTE ALSO THAT FORMATS 1113 AND 1111 (WHICH ARE ALTERED SLIGHTLY) ARE
C  ONLY USED IF IVERS = 0. IF IVERS = 1, NEW FORMATS 1116 AND 1118 ARE
C  USED.

C  2. IN OPTIONS 5,6, AND 7 (IN SUBROUTINE EXTRAOPT), THE USER IS NOW
C  ASKED EACH TIME HE SELECTS ONE OF THESE OPTIONS WHETHER OR NOT HE

C  WISHES TO STORE INFO TO A FILE. THIS REPLACES THE IWR31/ISCATPLT
C  LOGIC IN OPTIONS 5 AND 6. IN OPTION 7, IPUT LOGIC IS ADDED SO THE
C  PROGRAM WILL KNOW WHETHER OR NOT TO STORE INFO TO A FILE. BECAUSE OF
C  THIS, SCAT4.FOR IS REPLACED BY SCAT5.FOR WITH AN ALTERED SUBROUTINE
C  SCATGRAM WHICH HAS THE ADDITIONAL ARGUMENT IPUT, BUT SCAT5 IS
C  UPGRADED TO SCAT6 (SEE CHANGE 6 BELOW).

C  3. FORMAT 9503 IS CHANGED IN SUBROUTINE EXTRAOPT (OPTIONS 1 AND 3 ARE
C  INTERCHANGED).

C  4. FORMAT 8503 IS CHANGED IN SUBROUTINE EXTRAOPT (OPTIONS
C  1 AND 3 ARE INTERCHANGED). IN ADDITION, A LOT OF RELATED CODE IS
C  CORRESPONDINGLY CHANGED.

C  5. FORMAT 4066 IN MAIN AND PREVRUN HAS AN "INVISIBLE" SPACE REMOVED.
C  PREVIOUSLY, USC*PACK WAS WRITTEN OUT AS USC*PAC K. TO REMOVE THIS
C  SPACE REQUIRED COPYING THE CODE TO ANOTHER FILE, EDITING IT WITH
C  THE DOS EDIT COMMAND AND THEN COPYING IT BACK INTO THIS FILE. WHY
C  THIS WORKS I DON'T KNOW.

C  6. IN OPTIONS 5 AND 6 IN SUBROUTINE EXTRAOPT, TWO NEW MEASURES OF
C  PRECISION, (BIAS-ADJUSTED) PRECISION AND (BIAS-ADJUSTED) WEIGHTED
C  PRECISION ARE CALCULATED AND DISPLAYED. THIS REQUIRES A CHANGE IN
C  SCAT5.FOR WHICH BECOMES SCAT6.FOR.

C  NOTE THAT A NEW itbig6.f WILL REPLACE itbig5. THE ONLY DIFFERENCES

C  BETWEEN THE TWO PROGRAM WILL BE THAT "MADE BY npbig6" WILL BE ADDED
C  TO THE FIRST LINES OF THE OUTPUT AND DENSITY FILES.

C-----------------------------------------------------------------------

C  ITBIG5.FOR							4-9-00

C  ITBIG5 HAS THE FOLLOWING CHANGES FROM ITBIG4:

C  1. IN SUBROUTINE CONVERGE, INORM IS HARDCODED TO 0 IF IPLOT = 1 OR
C  6 AND NUMEQT = 1 (SINCE NORMALIZED PLOTS ARE UNNECESSARY WITH JUST
C  ONE LINE ON THE GRAPH).

C  2. ALL REFERENCES TO USC*TOOLS FOR OUTPUT FILE OUTSINGL HAVE BEEN
C  REMOVED. THE OUTPUT FILE IS STILL CREATED, BUT IT WILL NOT BE
C  USED FOR USC*TOOLS.


C  3. SCAT3.FOR HAS BEEN REPLACED BY SCAT4.FOR, WHICH HAS AN UPDATED
C  SUBROUTINE SCATGRAM. THE 95% CONFIDENCE LINES FOR THE SCATGRAM PLOT

C  WILL NO LONGER ALWAYS BE FOR E(Y|X) AS IN SCAT3. INSTEAD, IT WILL BE
C  FOR E(Y|X) IF ICONF = 1 (ICONF IS ADDED TO THE ARGUMENT LIST FOR
C  SUBROUTINE SCATGRAM), AND FOR Y|X IF ICONF = 0. ICONF IS READ IN
C  FROM THE USER.

C  ALSO, IN SUBROUTINE SCATGRAM, ADDITIONAL STATISTICS WILL BE

C  OUTPUT ... 99%, 95%, AND 80% C.I. FOR E(Y|X) IF ICONF = 1, OR
C  Y|X IF ICONF = 0.

C  4. MAXOBDIM, IN THE PARAMETER STATEMENT, HAS BEEN CHANGED FROM
C  26 TO 150. THE 26 WAS THE LIMIT WITH MY OLD 386 COMPUTER WHEN RUN
C  UNDER WINDOWS FOR BIG NPEM, AND I SET THE LIMIT TO THE SAME VALUE
C  IN THESE BIG IT2B PROGRAMS. BUT AS OF NPBIG5.FOR, THE MAXOBDIM HAS
C  BEEN RESET = 150, AND SO IT WILL BE RESET IN THIS PROGRAM TO THE
C  SAME VALUE.

C  5. IN SUBROUTINE VERIF1, FORMATS 212, 218, 219, 217, ARE ALL
C  CHANGED.

C-----------------------------------------------------------------------

C  ITBIG4.FOR							2-28-00

C  ITBIG4 HAS THE FOLLOWING CHANGES FROM ITBIG3:

C  1. THERE IS ONE MAJOR IMPROVEMENT TO ITBIG3. AN ADDITIONAL OPTION
C  IS ADDED IN SUBROUTINE EXTRAOPT TO PLOT ANY OR ALL POSSIBLE
C  SCATTERPLOTS BETWEEN ANY TWO RANDOM VARIABLES AND/OR DESCRIPTORS IN
C  THE PATIENT DATA FILES. THIS OPTION IS NEW OPTION, IOPT = 7.

C  NOTE THAT FOR THE PURPOSES OF THE ABOVE PLOTS, FOR SUBJECT I, EACH
C  RANDOM VARIABLE WILL BE ASSIGNED THE VALUE EQUAL TO ITS MAP BAYESIAN
C  POSTERIOR ESTIMATE (GIVEN EITHER THE MEANS OR MEDIANS OF THE FINAL
C  CYCLE, AS SELECTED BY THE USER)

C  3 NEW SUBROUTINES ARE ADDED: GETCOVAL, GETCOVAR, AND PRNCOVAR.

C  THE ROUTINE WHICH DOES THE ABOVE PLOTS IS SCATGRAM, WHICH IS IN
C  MODULE SCAT3.FOR, WHICH REPLACES SCTPL12A.FOR (ALL THE ROUTINES FROM
C  SCTPL12A ARE IN SCAT3.FOR).

C  2. FORMAT 41 IN MAIN (CHANGED TO 141) AND 141 IN VERIF1, AND
C  SURROUNDING CODE ARE CHANGED SO THAT THE USER NOW ENTERS 1 FOR
C  USC*PACK FORMAT AND 2 FOR WORKING COPY FORMAT.

C-----------------------------------------------------------------------


C  ITBIG3.FOR							11-13-99

C  ITBIG3 IS THE SAME AS ITBIG2 EXCEPT THAT A BUG HAS BEEN FIXED.
C  PREVIOUSLY, IF THE USER SELECTED ILOG = 1  TO SKIP THE TRUE
C  (NUMERICAL) LOG-LIK CALCULATIONS AT THE END OF THE it2bdriv RUN,
C  THE it2bdriv PROGRAM WOULD BOMB SINCE WITH ILOG = 1, NGRID WAS
C  NEVER INITIALIZED AND SO SUBROUTINE MAKEDRIV WOULD MAKE THE
C  PARAMETER MAXGRD IN it2bdriv.f = 0 (WHICH WOULD RESULT IN ARRAYS
C  HAVING A NON-POSITIVE DIMENSIONS). NOW, IF ILOG = 1, NGRID IS SET

C  = 2129.

C  ITBIG3 HAS NO FUNCTIONAL CHANGES RELATED TO THE NEW mainframe
c  programs, itbig3.f (itbig9x.exe) and assbig2.f (assdriv_obs.exe)

c  WHICH ARE THE 1ST IN THE SERIES TO ALLOW TIME LAGS.

C-----------------------------------------------------------------------

C  ITBIG2.FOR							10-28-99

C  ITBIG2 HAS THE FOLLOWING CHANGES FROM ITBIG1:

C  1. SEVERAL COSMETIC CHANGES ARE MADE TO THE I/O IN REGARD TO
C  INPUTTING USER DESIRES FOR THE ASSAY COEFFICIENTS.


C  2. FORMAT 7 IN SUBROUTINE VERIF1 IS CORRECTED (PREVIOUSLY, THE 1ST
C  CHARACTER OF THE 1ST NAME WAS CUT OFF).

C  3. THIS PROGRAM IS NOW LINKED WITH CONVRTLO.FOR, UPDATED FROM
C  CONVRTLN.FOR (CONVRTLO CORRECTS A SUBTLE BUG IN THE CASE WHETHER
C  THERE IS NO BOLUS INPUT).

C-----------------------------------------------------------------------

C  ITBIG1.FOR 						  	10-5-99

C  ITBIG1 HAS THE FOLLOWING CHANGES FROM M1_6B:

C  1. THE CONVERGENCE CRITERION IS CHANGED TO BE BASED ON THE ABSOLUTE
C  VALUES OF AVGLOG - OLDAVG, INSTEAD OF JUST AVGLOG - OLDAVG.
C  PREVIOUSLY, IF THE LOG-LIKELIHOOD DECREASED FROM ONE CYCLE TO THE
C  NEXT, CONVERGENCE WAS ACHIEVED. NOW, CONVERGENCE WON'T BE ACHIEVED
C  UNLESS THE ABS. VALUE OF THE LOG-LIK'S OF 2 CONSECUTIVE CYCLES IS
C  WITHIN TOL. THE ONLY EFFECT IN THIS PROGRAM IS A SLIGHT CHANGE TO
C  FORMAT 26 IN MAIN.


C  2. IN SUBROUTINE VERIF1, WHEN THE USER IS CHANGING THE IGAMMA
C  SELECTION, HE NOW HAS THE OPTION TO LEAVE THE VALUES FOR
C  {C0P,C1P,C2P,C3P] UNCHANGED (I.E., HE WON'T HAVE TO RE-ENTER THEM).
C  SEE ICHCS CODE IN VERIF1.

C  3. IUNIQ IS CHANGED (0 <--> 1 ) IN BOTH MAIN AND VERIF1.

C  4. THE CALCULATION OF THE TRUE LOG-LIKELIHOOD (AT THE END OF THE RUN)
C  IS NOW ONLY DONE IF THE USER REQUESTS IT (THE DEFAULT IS NOT TO DO
C  IT). ILOG = 0 IF THE CALCULATIONS ARE TO BE DONE AND PRINTED; IT =
C  1 OTHERWISE. SINCE ILOG MUST BE PASSED TO THE MAINFRAME COMPUTER,
C  THIS MEANS THAT THE FILE UPLOADED TO THE MAINFRAME COMPUTER IS
C  CHANGED (FROM it2bbig2.inp TO it2bbig3.inp).

C  5. IBEEP IS HARDCODED TO = 1 (SO NO BEEPING WILL BE HEARD PLOTS GO TO
C  THE SCREEN.

C  6. SEVERAL I/O CHANGES ARE MADE.

C  7. USER NOW ENTERS THE LOCATION (PATH) OF HIS INSTRUCTION AND PATIENT
C  FILES (I.E., THEY NO LONGER HAVE TO BE IN THE WORKING DIRECTORY). ALL
C  OUTPUT FILES WILL BE PUT THERE ALSO. NEW SUBROUTINES GETPATH AND
C  FULLNAME ARE USED.



C  PATH AND NOB MUST NOW BE SUPPLIED TO SUBROUTINES EXTRAOPT, VERIF1,
C  MAKEDRIV, GETNUMEQ, AND SEEDIR. PATH MUST BE SUPPLIED TO SUBROUTINE
C  STACK.

C  SUBROUTINE PUTASS ALSO HAS LOTS OF CHANGES, BECAUSE PATHFILE (*73)
C  INSTEAD OF PATFIL (*20) IS PASSED TO IT.

C  CONVRTLM.FOR IS CHANGED TO CONVRTLN.FOR. THE DIFFERENCE IS THAT THE
C  FILENAMES INPUT TO CONVRTLN ARE *73 RATHER THAN *20.

C-----------------------------------------------------------------------

C  M1_6B.FOR							6-19-99


C  M1_6B HAS THE FOLLOWING CHANGES FROM M1_6A:

C  1. SUBROUTINE PUTASS NOW CALLS NEW SUBROUTINE USECS SEVERAL TIMES,
C  WHENEVER THE USER IS PROMPTED TO ENTER A NEW SET OF COEFFICIENTS.
C  USECS ALLOWS THE USER TO SEE UP TO 5 SETS OF PREVIOUSLY STORED
C  C'S FOR EACH OUTPUT EQUATION, AND TO STORE ADDITIONAL SETS (UP TO
C  THE LIMIT OF 5).

C  2. MAXOBDIM IS THE MAX. NO. OF OBSERVED VALUES (HARDCODED IN A
C  PARAMETER STATEMENT). RATHER THAN ASSUME THE USER WILL ONLY ANALYZE
C  SUBJECTS WITH .LE. MAXOBDIM OBSERVATION TIMES, THIS WILL BE TESTED
C  IN SUBROUTINE STACK (MAXOBDIM WILL BE PASSED TO STACK).

C-----------------------------------------------------------------------

C  M1_6A.FOR							5-20-99

C  M1_6A HAS ALL THE CHANGES M1_7 THRU M1_7C MADE TO M1_6, EXCEPT
C  THE ASSAY S.D.'S ARE STILL FUNCTIONS OF THE OBSERVED VALUES, RATHER
C  THAN THE PREDICTED VALUES.


C  THE CHANGES ARE:

C  1. IT IS NOW LINKED WITH CONVRTLM.FOR, RATHER THAN CONVRTL.FOR.
C  CONVRTLM ALLOWS 30 USER-SUPPLIED COVARIATES RATHER THAN JUST
C  10 AS IN CONVRTL (AND THIS LIMIT IS EXPLICITLY CHECKED FOR NOW).
C  ALSO, CONVRTL HAD A BUG WHICH CAUSED A DIVIDE BY 0 ERROR IF THERE WAS
C  JUST ONE DOSE TIME. THIS HAS BEEN CORRECTED.

C  2. THE MAXIMUM NO. OF CYCLES FOR THE PROGRAM HAS BEEN CHANGED TO
C  40999. PREVIOUSLY, THERE WAS NO EXPLICIT LIMIT WHEN THE PROGRAM
C  READ IN MAXIT (NOW THE LIMIT IS 40999), BUT THERE WAS AN IMPLICIT
C  LIMIT OF 10000 IN SUBROUTINES CONVERGE, PLTCON, AND MINMAX WHICH HAD
C  CORRESPONDING DIMENSIONS OF 10000. NOW, THESE DIMENSIONS HAVE BEEN
C  CHANGED TO 40999. THIS LIMIT WILL BE IMPOSED WHETHER THE USER USES
C  AN INPUT FILE OR THE KEYBOARD TO ENTER THE INSTRUCTIONS.

C  3. RS(500,14) DIMENSIONS ARE CHANGED TO RS(500,34), TO ALLOW THE
C  EXTRA 20 COVARIATES OF CHANGE 1 ABOVE.

C  4. THE CALLS TO SCATPLOT FOR THE ENTIRE POPULATION HAS THE ARGUMENT
C  JSUB CHANGED FROM 0 TO -NSUB. THIS WAY, SCATPLOT CAN WRITE OUT NSUB
C  = NO. OF SUBJECTS. THIS PROGRAM WILL NOW BE LINKED WITH SCTPL12A.FOR
C  (UPDATED FROM SCATPL10.FOR), WHICH WILL WRITE OUT NSUB AS INDICATED.



C  - MODULE SCATPL10.FOR IS CHANGED TO SCTPL12A.FOR.

C-----------------------------------------------------------------------

C  M1_6.FOR							8-7-98

C  M1_6.FOR HAS THE FOLLOWING CHANGES FROM M1_5.FOR:

C  1. IT ALLOWS MULTIPLE OUTPUTS. THERE WILL BE NUMEQT OUTPUT EQUATIONS,
C  AND FOR EACH OF THESE EQUATIONS, THE USER MUST ENTER NUMEQT SETS
C  OF POPULATION ASSAY COEFFICIENTS, ETC.

C  IN PARTICULAR, IUNIQ, IGAMMA, IASS, C0P,...,C3P, C0,...,C3, IALTER,
C  AND IQVAL ARE ALL DIMENSIONED 6 IN MAIN (6 IS THE MAXIMUM NO. OF
C  OUTPUT EQUATIONS).

C  2. THIS PROGRAM IS COMPILED WITH CONVRTL.FOR, RATHER THAN CONVRJ.FOR.
C  CONVRTL IS A "CORRECTION" TO CONVRTK.FOR. THE DIFFERENCE IS THAT
C  CONVRTL HARDCODES NUMEQT = 1, WHEREAS CONVRTK READS NUMEQT FROM THE
C  USC*PACK FILE. BUT, THE NEW XPAST... PROGRAM IS NOT YET AVAILABLE
C  WHICH WRITES NUMEQT TO USC*PACK FILES, SO, FOR NOW, NUMEQT MUST BE
C  HARDCODED. THE SHORT STORY IS THAT THE ONLY WAY FOR A USER TO USE
C  MULTIPLE OUTPUTS AT THIS POINT IS TO START WITH MANUALLY ALTERED

C  WORKING COPY PATIENT DATA FILES.


C  3. A NEW SUBROUTINE, GETNUMEQ, IS USED TO GET THE NO. OF OUTPUT
C  EQUATIONS (NUMEQT) FROM A PATIENT DATA FILE.

C  4. SUBROUTINE EXTRAOPT HAS LOTS OF CHANGES, PRIMARILY RELATED TO

C  THE INCREASED DIMENSION FOR YPREDPOP AND YPREDBAY (TO IDENTIFY THE
C  OUTPUT EQUATION NUMBER), AND THE FACT THAT THE USER MUST IDENTIFY
C  WHICH OUTPUT EQ. OBSERVATIONS ARE TO BE CONSIDERED IN OPTIONS 5/6.

C  5. SUBROUTINES CONVERGE AND PLTCON HAVE SEVERAL CHANGES SINCE NOW
C  PLOTTING GAMMA MEANS PLOTTING ALL NUMEQT GAMMA'S (ONE FOR EACH
C  OUTPUT EQUATION). NOTE THAT ALL NUMEQT GAMMA'S ARE PLOTTED, NOT JUST
C  THE GAMMA'S WHICH HAVE BEEN ESTIMATED DURING THE RUN (I.E., FOR ANY
C  OUTPUT EQUATION WHICH DID NOT HAVE ITS GAMMA ESTIMATED, THE PLOT
C  WILL BE A HORIZONTAL LINE AT 1.0).

C  6. A NEW PARAMETER, MAXOBDIM, IS SET IN THE PARAMETER STATEMENT IN
C  MAIN. IT, ALONG WITH VARIABLES WHOSE DIMENSIONS DEPEND ON IT ARE

C  PASSED TO SUBROUTINES FILRED, EXTRAOPT AND MAKEDRIV. MAXOBDIM IS THE
C  MAX. NO. OF OBSERVATION TIMES IN A PATIENT DATA FILE.

C  7. SUBROUTINE MAKEDRIV HAS CHANGES DUE MAINLY TO THE INCREASED
C  DIMENSIONS FOR YPREDPOP AND YPREDBAY.

C  8. THERE ARE MAJOR RELATED CHANGES TO OTHER ROUTINES, SUCH AS FILRED,
C  STACK, VERIF1, AND PUTASS.

C  9. ADDITIONALLY, IN SUBROUTINE PUTASS, THERE IS A SMALL "BUG" FIX:

C  PREVIOUSLY, JUST BELOW LABEL 10, A "2" WAS SEARCHED FOR IN COLUMN 1;
C  IT WAS SUPPOSED TO BE THE "2" WHICH SIGNIFIES THAT THE ASSAY COEFFS
C  ARE FOLLOWING. BUT THE ETHNICITY FLAG NEAR THE TOP OF THE FILE COULD
C  ALSO BE A "2" IN COLUMN 1. IN THIS CASE, THE FILE WOULD ONLY BE
C  COPIED DOWN TO THAT POINT (I.E., THE REST OF THE FILE WOULDN'T BE
C  COPIED). TO ELIMINATE THIS POSSIBILITY, THE "2" SIGNIFYING THAT ASSAY
C  COEFFICIENTS FOLLOW WILL BE REPLACED BY THE WORDS "ASSAY COEFFICIENTS
C  FOLLOW". IF NO ASSAY COEFFICIENTS ARE INCLUDED, THE LAST LINE OF THE
C  FILE WILL BE "ASSAY COEFFICIENTS ARE NOT INCLUDED".


C  10. A SLIGHT BUG HAS BEEN CORRECTED. IN M1_5.FOR, IUNIQ WASN'T PASSED
C  TO/FROM SUBROUTINE VERIF1 --> IF IT WAS CHANGED IN VERIF1, MAIN WOULD
C  NOT "KNOW" ABOUT IT --> THE CODE BELOW THE CALL TO VERIF1, WHICH
C  DEPENDS ON VERIF1, COULD BE ACCESSED INCORRECTLY. TO PREVENT THIS,
C  IUNIQ (WHICH IS NOW A VECTOR) IS NOW PASSED TO/FROM VERIF1 IN THE
C  ARGUMENT LIST.

C  11. THE FILE TO BE USED BY THE USC*TOOLS PROGRAM WILL NOW BE THE
C  OVERALL FILE OUTPUT BY OPTIONS 5/6 (OUTSINGL), AND NOT THE FILE

C  (OPT6FIL) CREATED IN OPTION 6 TO STORE THE MAP BAYESIAN ESTIMATES
C  OF THE SUBJECTS.

C  OPT6FIL WILL STILL BE CREATED, BUT NOW OUTSINGL WILL BE STORED INTO
C  THE INPUT FILE RATHER THAN OPT6FIL. COMMENTS TO THE USER WILL BE
C  CHANGED APPROPRIATELY.

C  12. IN SUBROUTINE PRNLAST, A POTENTIAL DISPLAY "BUG" IS REMOVED.
C  PREVIOUSLY, IF THE LAST CYCLE HAD CHARACTERS BEYOND 72 COLUMNS, THEY
C  WOULD NOT BE PRINTED. NOW THEY ARE.


C  13. THE INFORMATION FILE UPLOADED TO THE MAINFRAME PROGRAMS IS

C  CHANGED FROM it2bbig1.inp TO it2bbig2.inp.

C  14. INSTEAD OF WRITING IQVAL(IEQ),IEQ=1,NUMEQT TO FILE it2bbig2.inp.
C  (AS THE EXTENSION OF IQVAL, WHICH WAS WRITTEN TO it2bbig1.inp), THE
C  ACTUAL VALUE OF QVAL WILL BE CALCULATED AND WRITTEN. THIS VALUE IS,
C  OF COURSE, ONLY APPLICABLE IF it2bdriv.exe IS TO BE RUN (NOT
C  assdriv.exe). QVAL IS THE NO. OF NOISE PARAMETERS ALREADY, OR TO BE,
C  ESTIMATED IN THE it2bdriv.exe RUN; IT IS USED TO CALCULATE THE
C  AKAIKE AND SCHWARTZ MEASURES OF INFORMATION.

C  IQVAL(IEQ) WILL, HOWEVER, BE WRITTEN TO, AND READ FROM, SAVED

C  INSTRUCTION FILES.

C  15. MAXGRD IS TAKEN OUT OF THE PARAMETER STATEMENT. IT IS NOT
C  NEEDED IN MAIN.



C  16. A "BUG" IS CORRECTED IN SUBROUTINE GETNUMEQ. TO READ NUMEQT,

C  THE ROUTINE ASSUMED THAT EACH LINE IN THE DOSAGE INFO BLOCK
C  REPRESENTED ONE DOSE EVENT. BUT EACH DOSE EVENT CAN BE TWO OR MORE
C  LINES. TO MAKE SURE THIS INFO IS READ CORRECTLY, THE SAME CODE

C  USED IN SUBROUTINE FILRED IS NOW USED.

C  17. THE MAINFRAME PROGRAMS ARE CHANGED: assay_2.f --> assay_3.f,
C  AND m1_3calc.f --> m1_4calc.f (ALSO, SOME OF THE AUXIALLARY MODULES
C  ARE CHANGED - SEE NOTES IN assay_3.f AND m1_4calc.f).

C-----------------------------------------------------------------------

C  M1_5.FOR							5-18-98

C  M1_5 HAS ONE CHANGE FROM M1_4:

C  DUMMY FILE "RUNNPEM.NXT" WILL BE CREATED IF THIS EXAMINES OUTPUT
C  FILES FROM A PREVIOUS RUN (AS OPPOSED TO PREPARING A FILE TO BE RUN
C  BY A MAINFRAME PROGRAM).

C  THEN, POP.BAT, WHICH CALLS THIS PROGRAM (AND WHICH DELETED
C  "RUNNPEM.NXT" IF IT EXISTS) WILL KNOW TO CALL THE BIG NPEM
C  PROGRAM (M2_17.EXE IS THE CURRENT VERSION) IF "RUNNPEM.NXT" EXISTS,
C  AND TO END OTHERWISE.

C-----------------------------------------------------------------------

C  M1_4.FOR							4-19-98

C  M1_4 HAS MAJOR CHANGES FROM M1_3. THESE INCLUDE THE FOLLOWING.



C  1. THERE ARE MAJOR CHANGES RELATED TO THE NEW PASTRXII (XPAST.EXE)
C  USC*PACK FILES; IN PARTICULAR, THE FORMAT OF THE USC*PACK FILES
C  IS CHANGED (NEW COVARIATES ARE ALLOWED), AND THIS CHANGES
C  SUBSTANTIALLY THE FORMAT OF THE WORKING COPY FILES (PREVIOUSLY
C  CALLED "ADAPT-LIKE" FILES).

C  IN PARTICULAR, INSTEAD OF JUST 2 "COVARIATES" (WT AND CCR), THERE ARE
C  NOW UP TO 16 "COVARIATES" AVAILABLE (WT, CCR, 10 ADDITIONAL
C  COVARIATES ENTERED IN THE DOSAGE REGIMEN COLUMNS, ALONG WITH THE 4
C  DISCRETE DESCRIPTORS AGE, SEX, HEIGHT, AND ETHNICITY FLAG).

C  MAJOR CODE CHANGES INCLUDE:

C   a. CONVRTH.FOR HAS BEEN MODIFIED TO CONVRTJ.FOR TO READ THE NEW
C   USC*PACK FILES, AND CONVERT THEM TO THE NEW WORKING COPY FILES.

C   b. SUBROUTINES FILRED, STACK, PUTASS HAVE MAJOR CHANGES TO READ
C   THE NEW WORKING COPY FILES.

C  NOTE: THE USER MAY USE THIS PROGRAM WITH PATIENT FILES WHICH WERE
C	 CREATED EITHER BY THE OLD PASTRX PROGRAM OR THE NEW PASTRXII
C 	 PROGRAM (XPAST.EXE). BUT, IT IS NOT POSSIBLE TO USE THIS
C  	 PROGRAM WITH ADAPT-LIKE FILES WHICH WERE CONVERTED FROM A
C	 PREVIOUS VERSION OF CONVRTI.FOR (1ST USED IN M2_15.FOR).
C	 THIS IS BECAUSE PREVIOUS VERSION ADAPT-LIKE FILES DON'T HAVE
C	 ALL THE PRELIMINARY INFO (E.G., AGE, SEX, ETC.) THAT
C 	 THIS PROGRAM EXPECTS TO SEE.

C  NOTE THE ORDER OF PATIENT FILE MANIPULATION:

C --  SUBROUTINE CONVRT (CONVRTJ.FOR) READS IN THE USC*PACK FILES AND
C     CONVERTS THEM TO THE NEW ADAPT-LIKE FORMAT, INCLUDING NAME,
C     WARD NO., AGE, SEX, HEIGHT, AND ETHNICITY FLAG AT TOP. ALSO, THE

C     NAMES OF ANY ADDITIONAL COVARIATES SELECTED BY THE USER PRECEDE
C     THE DOSAGE INFO. FOLLOWING THE DOSAGE INFO, AND THE CONCENTRATION
C     INFO, IS THE LIST OF COVARIATE NAMES AND VALUES (1ST, LAST, AND

C     MEAN VALUES FOR THAT SUBJECT).

C --  SUBROUTINE PUTASS READS ABOVE ADAPT-LIKE FILES AND APPENDS THE
C     USER-DESIRED ASSAY NOISE COEFFICIENTS AT THE END. IF COEFFICIENTS
C     ARE ALREADY THERE, PUTASS MAKES SURE THEY ARE THE ONES THE USER
C     DESIRES FOR THE CURRENT RUN.

C --  SUBROUTINE STACK READS THE ADAPT-LIKE FILES, WHICH NOW HAVE ASSAY
C     NOISE COEFFICIENT AT THE END, AND STACKS THEM ONTO FILE 27. NOTE
C     THAT THE "2" ON THE LINE WHICH PRECEDES THE C'S IS TAKEN OUT.
C     ALSO, EACH IV RATE AND BOLUS INPUT IS MULTIPLIED BY AF.

C --  SUBROUTINE FILRED READS EACH PATIENT'S INFO FROM THE PORTION OF
C     FILE 27 ASSIGNED TO THAT PATIENT. THIS HAPPENS IN THE  m2_15cal.f
C     PROGRAM, OR IN THIS PROGRAM IN SUBROUTINE PREVRUN.


C  2. NOTE THAT THE PROGRAM WHICH CAN CREATE THE FORTRAN MODEL FILE
C  INPUT TO THIS PROGRAM, BOXESNEW.PAS, HAS BEEN CHANGED TO BOXNEW3.PAS.

C  THE CHANGE IS THAT  COMMON /DESCR/ AGE,ISEX,HEIGHT,IETHFLG  IS
C  PROVIDED TO SUBROUTINES DIFFEQ AND OUTPUT, SO THE USER CAN USE THESE
C  4 DESCRIPTORS IF HE CHOOSES, IN HIS D.E.'S AND OUTPUT EQ.
C  THE FORTAN MODEL FILE INCLUDES SUBROUTINES DIFFEQ,
C  OUTPUT, AND SYMBOL, AND THIS FILE IS CALLED FORFILE, AND IT IS

C  APPENDED TO THE END OF EITHER assdriv.f OR it2bdriv.f (SEE DETAILS

C  BELOW).

C  3. ALL F AND E FORMATS WILL BE CHANGED TO G FORMATS. SINCE THE G
C  FORMAT REQUIRES AT LEAST 6 SPACES IN ADDITION TO THE DECIMAL SPACES +
C  THE SPACE FOR THE DECIMAL POINT ITSELF (TO REPRESENT ALL POSSIBLE
C  NUMBERS, INCLUDING THE NEGATIVE SIGN IF THERE IS A NEGATIVE NO.),
C  THE FORMAT WILL BE Gw.d, WHERE w MUST BE AT LEAST 6 BIGGER THAN d.

C  THEREFORE, THE FOLLOWING LOGIC WILL BE USED TO CONVERT THE FORMATS.

C  GIVEN AN F OR E FORMAT w.d, THE REPLACING G FORMAT WILL BE ww.d,

C  WHERE ww = MAX(w,d+6). IF ANY ACCOMPANYING FORMATS ARE DEPENDENT ON
C  THE REPLACED FORMAT, IT WILL BE CHANGED ACCORDINGLY.

C  EXCEPTION: FORMAT 16 IN SUBROUTINE PUTASS HAS BEEN CHANGED FROM
C  F18.14 TO G16.10,2X (A G FORMAT WITHOUT X'S CAUSES THE C'S TO RUN
C  TOGETHER ON THE LINE (SOMETIMES), AND 10 DECIMAL PLACES IS PLENTY).

C  4. THERE IS A COSMETIC CHANGE TO FORMATS 7 AND 12 IN SUBROUTINE
C  USERPREP.

C  5. A NEW SUBROUTINE, MAKEDRIV, CREATES WHICHEVER DRIVER PROGRAM
C  IS NEEDED. IF IGAMMA .NE. 2, IT CREATES it2bdriv.f, WHICH WILL BE

C  THE "MAIN" OF THE WHOLE 'BIG IT2B'. IF IGAMMA .EQ. 2, IT CREATES
C  assdriv.f, WHICH WILL BE THE "MAIN" OF THE ASSAY CALCULATION PROGRAM.
C  EITHER WAY, FORFILE, THE MODEL FILE INPUT BY THE USER, WILL BE
C  APPENDED TO THE END OF THE APPLICABLE .f DRIVER PROGRAM, SO ONLY
C  ONE .f FILE WILL HAVE TO BE UPLOADED TO THE MAINFRAME.

C  EACH "MAIN" PROGRAM HAS A PARAMETER STATEMENT WHICH DEFINES THE
C  PARAMETERS WHICH ESTABLISH THE DIMENSIONS IN THE VARIABLY DIMENSIONED
C  ARRAYS, ALONG WITH A DIMENSION STATEMENT WITH ALL ARRAYS WHICH DEPEND
C  ON THESE VALUES. IT THEN HAS THE CALLING STATEMENT (CALL BIGIT2B(...)
C  OR CALL ASSCALC(...)) WHERE ALL VARIABLY DIMENSIONED ARRAYS (AND THE
C  VARIABLE PARAMETER DIMENSIONS) ARE PASSED. NOTE THAT BIGIT2B IS THE
C  MAIN MODULE IN m1_3calc.f, ASSCALC IS THE MAIN MODULE IN assay_2.f.

C  NOTE THAT THIS .f DRIVER CONCEPT IS DONE ONLY TO BE CONSISTENT WITH
C  THE BIG NPEM2 PROGRAM (M2_16.FOR/npemdriv.f/m2_16cal.f IS CURRENT).
C  IN ACTUALITY, THERE IS NO NEED TO DO IT, SINCE THE ARRAYS IN

C  m1_3calc.f/assay_2.f ARE NOT BIG ENOUGH TO NEED TO BE VARIABLY

C  DIMENSIONED (AS THEY NEED TO BE IN BIG NPEM2).

C  6. MAXSUB IS PUT INTO THE PARAMETER STATEMENT, AND THEN PASSED TO
C  SUBROUTINES WHICH NEED IT TO VARIABLY DIMENSION ARRAYS. THERE ARE
C  TWO ARRAYS WHICH SHOULD HAVE MAXSUB AS A DIMENSION WHICH WILL STILL
C  HAVE 999: COEFF(999,5), SINCE COEFF IS PASSED IN COMMON/TOSCAT,
C  AND LEAVING THE DIMENSION AS 999 --> NO CHANGE IN SCATPL10.FOR.;
C  AND NUMBER(999), SINCE NUMBER IS PASSED IN COMMON/TOBLK, AND LEAVING
C  THE DIMENSION AS 999 --> NO CHANGE IN DATABLK1.FOR.

C  7. IN SUBROUTINES CONVERGE, PLTCON, AND MINMAX, ARRAYS ARE CHANGED SO

C  THAT THE MAXIMUM NO. OF CYCLES IS 10000, RATHER THAN 999.

C  8. IN THE PARAMETER STATEMENT, MAXDIM IS CHANGED FROM 10 TO 20.

C  9. THE COMMENTS TO USER REGARDING THE UPLOADING AND DOWNLOADING OF
C  FILES ARE IMPROVED (EASIER TO UNDERSTAND).



C  10. IN SUBROUTINE EXTRAOPT, FOR THE IOPT=6 OPTION, A NEW FILE IS
C  CREATED, IF THE USER DESIRES, TO BE USED BY THE USC*TOOLS PROGRAM.
C  IT CONTAINS THE MAP BAYESIAN POSTERIOR PARAMETER ESTIMATES FOR
C  EACH SUBJECT (ALONG WITH THE ASSOCIATED PROBABILITY OF EACH
C  SUBJECT (1/NSUB)). THIS IS CONSISTENT WITH THE FILE CREATED IN
C  IOPT=7 IN SUBROUTINE PREVRUN OF PROGRAM M2_17.FOR.

C  11. A NEW VARIABLE, IQVAL IS INITIALIZED = 0 AT START OF THE
C  RUN. IF IT CHANGES TO 1, IT MEANS THAT C'S WERE READ IN FROM THE
C  MAINFRAME PROGRAM WHICH ESTIMATES C'S (assdriv.exe), AND
C  SO QVAL, USED TO CALCULATE THE AKAIKE AND SCHWARTZ INFO, MUST BE SET
C  = 4 (SINCE THE C'S WERE ESTIMATED). THIS LOGIC IS INCORPORATED INTO
C  THE CALCULATION OF THE ABOVE INFO'S.

C  12. RATHER THAN HAVE THE sun PROGRAM, it2bdriv.f CALCULATE A VALUE
C  FOR INDPTS, BASED SOLELY ON THE VALUE OF NVAR, M1_4 ALLOWS THE USER
C  TO SELECT A DESIRED VALUE FOR INDPTS, WHICH IS THEN PASSED TO
C  it2bdriv.f.

C  13. THERE IS A CHANGE TO THE FORMAT BELOW LABEL 7185 IN SUBROUTINE
C  EXTRAOPT, REGARDING THE BATCH FILE, POP.BAT.

C  14. THERE ARE COSMETIC CHANGES TO THE I/O, INCLUDING REPLACING
C  "Adapt-Like" WITH WORKING COPY.

C  15. FORMAT 161 REPLACES * FORMAT WHEN WRITING OUT THE C'S TO A FILE,
C  TO AVOID POSSIBILITY THAT PART OF LINE WRITTEN WILL BE TRUNCATED IF
C  IT EXTENDS PAST COLUMN 72. ALSO 161 REPLACES THE * FORMATS WHEN

C  WRITING TO THE SCREEN TO MAKE OUTPUT "CLEANER".


C  NOTES:

C  A. THIS PROGRAM WILL USE PAR_6.INP; IT WILL BE COMPILED WITH
C  CONVRTJ.FOR, DATABLK1.FOR, GHCSEL.FOR, AND SCATPL10.FOR.

C  B. THE sun COMPANION PROGRAMS ARE assay_2.f (CHANGED FROM assay_1.f),
C  WHICH NOW CONTAINS THE SUBROUTINE ASSCALC - CALLED BY assdriv.f,
C  AND m1_3calc.f (CHANGED FROM m1_2calc.f), WHICH NOW CONTAINS
C  SUBROUTINE BIGIT2B - CALLED BY it2bdriv.f. assdriv.f AND it2bdriv.f
C  ARE MADE BY SUBROUTINE MAKEDRIV IN THIS PROGRAM (SEE ABOVE).

C  C. THIS PROGRAM PREPARES AN INPUT FILE, AND A FORTRAN FILE TO BE
C  UPLOADED TO BE RUN BY it2bdriv.f/m1_3cal.f (WHICH INCLUDES THE
C  MODULES idfixed3.f, idcy_52.f, idcp_2.f, and vodtot.t (ONLY idcp_2.f

C  IS NEW)), OR assdriv.f/assay_2.f (WHICH INCLUDES MODULES idfixed3.f,
C  idcp_2.f, AND vodtot.f). THE INPUT FILE IS CHANGED FROM file01.inp
C  TO it2bbig1.inp; IT INCLUDES THE NEW VARIABLES IQVAL AND
C  INDPTS.


C-----------------------------------------------------------------------

C  M1_3.FOR							10-16-97


C  M1_3 IS THE SAME AS M1_2 EXCEPT:

C  1. THE sun COMPANION PROGRAMS ARE assay_1.f (UNCHANGED) AND
C     m1_2calc.f (CHANGED FROM m1_1calc.f).


C  2. THE FOLLOWING COSMETIC CHANGES ARE MADE:

C  THE COMMENT TO USER AS HE CHOOSES WHETHER TO RUN THIS PROGRAM IN
C  PREPARATION OR EXAMINATION MODE;

C  THE COMMENTS AS THE USER SEES THE PLOTS PRODUCED BY ROUTINE PLOTSD;

C  THE INSTRUCTIONS TO THE USER REGARDING UPLOADING/DOWNLOADING FILES
C  TO/FROM THE sun MAINFRAME;

C  THE COMMENTS IN SUBROUTINE EXTRAOPT IN OBTAINING THE NAMES OF FILES
C  TO BE INPUT FROM A PRIOR RUN.

C-----------------------------------------------------------------------

C  M1_2.FOR							10-8-97

C  M1_2 IS THE SAME AS M1_1 EXCEPT THAT

C  1. A "BUG" INPUTTING THE ASSAY COEFFICIENTS NEAR LABEL 1119 IS
C  CORRECTED. PREVIOUSLY THE C'S WERE READ IN ONLY FOR THE CASE
C  (IASS .EQ. 2 .AND. IGAMMA .NE. 2). FOR OTHER CASES, THE C'S WERE NOT
C  READ IN BY THE PROGRAM.

C  2. ATOL IS REDIMENSIONED FROM 3 TO 20, AS IT SHOULD HAVE BEEN
C  ALL ALONG.

C-----------------------------------------------------------------------

C  M1_1.FOR							10-4-97

C  M1_1.FOR + assay_1.f + m1_1calc.f  IS THE COMBINATION (PC/sun) OF
C  PROGRAMS WHICH DOES THE SAME TYPE ANALYSES AS MXEM1S55. THE MAJOR
C  DIFFERENCE IS THAT MXEM1S55 USES ANALYTIC SOLUTIONS OF THE BASIC
C  3-COMPARTMENT PHARMACOKINETIC MODEL, WHEREAS M1_1/assay_1/m1_1calc
C  SOLVES THE DIFFERENTIAL EQUATIONS WHICH THE USER CODES TO DEFINE
C  THE MODEL (ALONG WITH THE OUTPUT EQUATION).

C  THIS NEW COMBO PROGRAM IS, ESSENTIALLY, AT THE SAME 'LEVEL' AS
C  M2_13.FOR/m2_13cal.f FOR THE 'BACK-END'.


C  IN PARTICULAR:

C  MODULE IDPC6.FOR IS REPLACED BY idfixed2.f + vodtot.f + mod01.f,
C  WHERE mod01.f CONTAINS THE USER-SUPPLIED CODE (INCLUDING SUBROUTINES
C  DIFFEQ, OUTPUT, AND SYMBOL) TYPICALLY CREATED BY A BOXES-TYPE
C  PROGRAM. idfixed2.f and vodtot.f ARE ALREADY USED BY m2_13cal.f
C  ('BIG NPEM2').

C  MODULE IDCALCP5.FOR IS REPLACED BY idcp_1.f.

C  MODULE IDCALCY1.FOR IS REPLACED BY idcy_51.f. idcy_51.f IS ALREADY
C  USED BY m2_13cal.f ('BIG NPEM2').

C  FOR MORE DETAILS ON THE DEVELOPMENT OF THE ABOVE MODULES, SEE THE
C  CODE IN THE 'BIG NPEM2' SERIES (CURRENTLY M2_13.FOR + m2_13cal.f).

C  NOTE THAT THIS PC PROGRAM CAN NO LONGER CALCULATE VALUES RELATED
C  TO A PARTICULAR MODEL (E.G., P(YJ|X)) -- SINCE THIS MODULE CAN'T BE
C  LINKED WITH THE MODEL FILE WHICH CHANGES RUN-TO-RUN  --  SO ALL
C  VALUES DEPENDENT ON THESE VALUES MUST BE STORED TO A FILE BY THE sun
C  CALCULATION PROGRAM, m1_1calc.f, AND THEN READ IN BY THIS PROGRAM
C  IN SUBROUTINE EXTRAOPT (WHICH EXAMINES OUTPUTS FROM PREVIOUS RUNS).


C  NOTE THAT assay_1 IS THE PART OF THE PROGRAM WHICH DOES THE
C  CALCULATION OF THE BEST C'S - IF THE USER DESIRES. IF THE USER
C  SELECTS THIS OPTION, HE MUST UPLOAD INFO TO assay_1.f, RUN assay-1.f,
C  DOWNLOAD RESULTS, AND THEN RUN THIS PC PREPARATION PROGRAM AGAIN,
C  INPUTTING THOSE RESULTS (THE BEST C'S). THEN, ALL INPUT INFO
C  (INCLUDING THESE BEST C'S) ARE UPLOADED TO THE ANALYSIS PROGRAM,
C  m1_1calc.f.

C-----------------------------------------------------------------------

C	. SEE MXEM1S55.FOR CODE FOR COMMENTS ON PROGRAMS
C	. MXEM1ST28.FOR ... MXEM1S55.FOR.
C	. (EXCEPT FOR EXPLANATION OF THE GENERAL MODEL BELOW).

C	. SEE MXEM1S27.FOR CODE FOR COMMENTS ON PROGRAMS
C	. MXEM1ST8.FOR ... MXEM1S27.FOR.

C	. SEE CODE FOR MXEM1ST7.FOR FOR COMMENTS REGARDING
C	. PROGRAMS MXEM1ST7.FOR ... MAX2STAG.FOR


C************************************

C  THE ITS ALGORITHM IS AS FOLLOWS (See its1comp.m notes for details):

C General Model:

C Y(i) = hi(theta_i) + e(i); e(i) -- iid -- N(0,Ri).
C Y(i), i=1,nsub, are observed --> obtain estimates theta_i_hat
C theta_i_hat -- iid -- N(theta_i, Vi) <-- cond dist., given theta_i.
C theta_i -- iid -- N(mu,cov)
C theta_i_hat -- iid -- N(mu, cov+Vi)  <-- unconditional dist.
C -- SEE DERIVATION IN HOME NOTES, 8-19-98.

C Goal is to estimate mu and cov.


C Its Technique:

C Do iter = 1, niter

C Given the current estimates of (mu,cov) = (muk,covk):

C Do i = 1, nsub

C let yi = data vector;

C Find theta_i, called xik, to minimize (using ELDERY):


C -ln P(yi|xik) - ln P(xik|muk,covk), where
C  ln P(yi|xik) = C1 - .5*ln det(Ri) -
C  .5*(yi - hi(xik))*inv(Ri)*(yi - hi(xik))',
C  hi(xik) = E(yi|xik), and
C     	Ri = nobs x nobs diagonal matrix with sig(l)^2 in element
C     (l,l), where sig(l) = cubic function of yi(l)  (see assay
C     coefficients, C0,...,C3 below) <--- see model above.
C     AS OF MXEM1S40.FOR, THE ASSAY NOISE POLYNOMIAL IS MULTIPLIED BY
C     THE FACTOR GAMMA (WHICH IS CONSTANT OVER THE ENTIRE POPULATION).
C     THE UPDATED ESTIMATE OF GAMMA IS FOUND AT THE END OF EACH CYCLE
C     (IF REQUESTED BY THE USER; OTHERWISE, IT REMAINS FIXED AT 1.0).

C  ln P(xik|muk,covk) = C2 - .5*ln det(covk) -
C	   .5*(xik - muk)*inv(covk)*(xik - muk)',
C     muk is the current estimate of the population mean, and
C     covk is the current estimate of the population covariance

C     matrix (see above).

C Note that xik is the 'MAP BAYESIAN' estimate of theta_i.


C For each xik, Find vi = inv(Pi'*inv(Ri)*Pi), where

C Ri is defined above, and
C Pi is the nobs x nvar matrix with Pi(l,m) = partial derivative of
C yi(tim(l)) w.r.t. parameter m, assuming the parameters = their
C values in xik.

C Calculate Pik = inv(inv(vi) + inv(covk))

C End of Do i = 1, nsub loop


C Update:
C  muk = sum(xik)/nsub
C  covk = sum[Pik + (xik-muk)*(xik-muk)']/nsub <--- use updated muk.

C         ... both of the above sums over all nsub subjects.

C End of Do iter = 1, niter loop.

C************************************

      IMPLICIT REAL*8(A-H,O-Z)

CCCCCCCCCCCCC

C  NOTE THAT MAXOBDIM = MAXIMUM NO. OF OBSERVATION TIMES IN A PATIENT
C  DATA FILE. SINCE THERE ARE AT MOST 6 OUTPUT EQUATIONS, AND EACH COULD
C  HAVE 99 OBSERVATIONS AT DIFFERENT TIMES, THERE COULD BE AS MANY AS
C  6*99 = 594 OBSERVATION TIMES.

C  NOTE THAT MAXSUB AND MAXOBDIM ARE LIMITED BELOW FOR SPACE REASONS.

	PARAMETER(MAXDIM=30, MAXSUB=800, MAXOBDIM=150, MAXNUMEQ=7)



CCCCCCCCCCCCC

      DIMENSION YO(MAXOBDIM,MAXNUMEQ),AB(30,2),VALFIX(20),IRAN(32),
     1 ATOL(20),PAREST(MAXSUB,30),SERNUM(MAXSUB),
     2 YPREDPOP(MAXSUB,MAXNUMEQ,MAXOBDIM,2),C4P(MAXNUMEQ),C5P(MAXNUMEQ),
     2 YPREDBAY(MAXSUB,MAXNUMEQ,MAXOBDIM,2),PARBAY(MAXSUB,2,30),
     3 IUNIQ(MAXNUMEQ),IGAMMA(MAXNUMEQ),IASS(MAXNUMEQ),C0P(MAXNUMEQ),
     4 C1P(MAXNUMEQ),C2P(MAXNUMEQ),C3P(MAXNUMEQ),IQVAL(MAXNUMEQ),
     5 NCSTORE(MAXNUMEQ),GENCOEF(MAXNUMEQ,5,4),IPATVEC(MAXSUB),AF(7),
     6 ICOVTYPE(26),RANFIXEST(20)

      CHARACTER NUMBER(999)*3,PATFIL*20,PREFIX*5,PAR(30)*11,
     1  FILNFO*20,EXT*3,SAVFIL*20,
     2  PARFIX(20)*11,READLINE*1000,CODE*14,FILASS*20,FORFILE*20,
     3  PATH*60,TMPFILE*13,PATHFILE*73,PATHFIL2*73,INSTFILE*12,
     4  INSTBAK*12,BLOCKPAT*20,CODEPAT*15,ALLINSTRUCT*20,COVNAME(26)*11,
     5  ERRFIL*20,PARRANFIX(20)*11

C
C Yamada 9/14/2010
C NOTE length of char array should be at least max expected + 1
C
      CHARACTER(LEN=20) :: OSName
      CHARACTER(LEN=5) :: CopyFile
      CHARACTER(LEN=4) :: DeleteFile
      CHARACTER(LEN=6) :: ClearScreen
      CHARACTER(LEN=10) :: ListDir
C
C end Yamada 9/14/2010 ... The above are used for distinguishing
C    the Operating System and creating appropriate system calls.
C
	COMMON/TOBLK/NUMBER
C  COMMON/TOBLK/ RETRIEVES FROM DATABLK1.FOR THE ARRAY, NUMBER(999).

      COMMON/TOWRITE/IALLIN,IVERIFY,NCOVA,ICOVTYPE,COVNAME
C  COMMON /TOWRITE IS PASSED TO SUBROUTINE READBLOCK.

      COMMON/ERROR/ERRFIL
C  COMMON/ERROR/ IS SUPPLIED TO ALL THE ROUTINES WHICH COULD WRITE TO
C  ERRFIL. NOTE THAT ERRFIL IS SET = 'ERRORLOG' BELOW.

      ERRFIL = 'ERRORLOG'



CCCCCCCCCCCCCCCCCCCCCCCCCCCCC



	WRITE(*,3214) MAXSUB,MAXOBDIM,MAXDIM,MAXNUMEQ
 3214   FORMAT(//' IN THIS "PC" PROGRAM, BECAUSE OF SPACE LIMITATIONS,'/
     1' THE NUMBER OF SUBJECTS IS LIMITED TO ',I4,','//
     2' THE NUMBER OF OBSERVATION TIMES PER SUBJECT IS LIMITED TO ',I4,'
     3,'//
     2' THE NUMBER OF RANDOM PARAMETERS IS LIMITED TO ',I2,','//
     4' THE NUMBER OF OUTPUT EQUATIONS IS LIMITED TO ',I2,'.'//)
C ------------------------------------------------------------
C Yamada 5/5/2010
C
C Initialize system calls here, e.g.:
C 1. CopyFile = COPY or cp
C 2. DeleteFile = DEL or rm
C
C NOTE the use of INDEX; be careful what substrings are allowed
C    for the ID of an operating system
C NOTE the extra space after each command; this makes it easier
C    to concatenate arguments to the system command.
C
       CALL GET_COMMAND_ARGUMENT(1,OSName)
       IF ((INDEX(OSName,"MacOSX",.TRUE.).EQ.1)
     $ .OR.(INDEX(OSName,"Darwin",.TRUE.).EQ.1)
     $ .OR.(INDEX(OSName,"BSD",.TRUE.).EQ.1)) THEN
          PRINT *,"Requested OS is ", OSName
          OSName="UNIX"
          PRINT *,"Setting OS to ", OSName
          PRINT *,""
          CopyFile="cp "
          DeleteFile="rm "
          ClearScreen="clear "
          ListDir="ls -tp "
       ELSE IF ((INDEX(OSName,"DOS",.TRUE.).EQ.1)
     $ .OR.(INDEX(OSName,"WinXP",.TRUE.).EQ.1)
     $ .OR.(INDEX(OSName,"XP",.TRUE.).EQ.1)
     $ .OR.(INDEX(OSName,"WinXP",.TRUE.).EQ.1)
     $ .OR.(INDEX(OSName,"Vista",.TRUE.).EQ.1)

     $ .OR.(INDEX(OSName,"Win7",.TRUE.).EQ.1)) THEN
          PRINT *,"Requested OS is ", OSName
          OSName="DOS"
          PRINT *,"Setting OS to ", OSName
          CopyFile="COPY "
          DeleteFile="DEL "
          ClearScreen="CLS "
          ListDir="DIR /OD "
       ELSE
          PRINT *,"WARNING: Operating system not identified."
          PRINT *,"WARNING: Can not initialize system calls."
          PRINT *,""
          PRINT *,"Possible command line error, try:"
          PRINT *,"C:\> npbig.exe <DOS,Win,XP,Vista,or Win7>"
          PRINT *,"unix$ npbig <MacOSX,Darwin,BSD>"
          PRINT *,""
          PRINT *,"NPAG Exiting with status 2"
          PRINT *,""
          CALL EXIT(2)
       END IF
C ------------------------------------------------------------

C  ESTABLISH INSTFILE AND INSTBAK AT THIS POINT, AS OF IT2B109.FOR.
C  IF THESE STATEMENTS WERE LEFT WHERE THEY WERE, IF IALLIN = 1, THEY
C  WOULD BE SKIPPED.

        INSTFILE = 'it2b102.inp'
        INSTBAK = INSTFILE(1:8)//'.bak'


C  SET IVERIFY = 1. IF IALLIN = 1 BELOW, THE USER WILL SUPPLY AN
C  INSTRUCTION FILE FROM WHICH IVERIFY WILL BE READ. BUT IF IALLIN = 0,
C  SETTING IVERIFY = 1 HERE MEANS THAT, WHETHER THE USER ENTERS INFO
C  FROM A PREVIOUS INSTRUCTION FILE FROM AN IT2B108.FOR OR EARLIER
C  PROGRAM, OR FROM THE KEYBOARD, HE WILL BE ASKED IF HE WANTS TO SAVE
C  THE INFO INTO AN INSTRUCTION FILE AT THE END (THIS INSTRUCTION FILE
C  WILL BE A NEW-STYLE ALL-INCLUSIVE VERSION).

      IVERIFY = 1

C  AS OF IT2B109.FOR, THE FIRST QUESTION WILL BE WHETHER OR NOT THE
C  USER HAS AN ALL-INCLUSIVE INSTRUCTION FILE WHICH CONTAINS ALL THE
C  INFORMATION FOR THE RUN, INCLUDING VALUES THAT USED TO HAVE TO BE
C  ENTERED VIA THE KEYBOARD, EVEN WHEN AN INSTRUCTION FILE WAS USED.
C  THIS FILE MUST BE IN THE CURRENT DIRECTORY, WHICH MEANS THAT IN THIS
C  CASE, GETPATH WILL NOT BE CALLED BELOW.

9880  WRITE(*,9876)
 9876 FORMAT(//' ENTER 1 IF YOU HAVE AN INSTRUCTION FILE IN THE '/
     1'         CURRENT DIRECTORY WHICH HAS ALL THE INSTRUCTIONS FOR'/
     2'         AN IT2B ANALYSIS (THIS FILE MUST HAVE "REM_FRN JUL_13"'/
     3'         OR A LATER DATE ON THE FIRST LINE). AND NOTE THAT IF'/
     4'         YOU USE THIS OPTION, AND THE ENTRY ON THE SECOND LINE'/
     5'         IS 0, THE PROGRAM WILL RUN WITH NO FURTHER USER INPUT.'/
     6'         BUT IF THE ENTRY ON THE 2ND LINE IS 1, YOU WILL HAVE'/
     7'         THE CHANCE TO EDIT YOUR INSTRUCTIONS BELOW.'//
     8' ENTER 0 OTHERWISE (THIS INCLUDES THE OPTION OF USING AN '/
     9'         OLDER INSTRUCTION FILE): ')
      READ(*,*,ERR=9880) IALLIN
      IF(IALLIN .NE. 1 .AND. IALLIN .NE. 0) GO TO 9880


	IF(IALLIN .EQ. 1) THEN



C  SINCE IALLIN = 1, IT MEANS THE CURRENT DIRECTORY IS THE WORKING 
C  DIRECTORY. SO SET PATH AND NOB AS THEY WOULD HAVE BEEN SET IN GETPATH
C  WHICH WILL NOT BE CALLED NOW.

       PATH = ' '
       NOB = 0


       WRITE(*,*)
       WRITE(*,*)' ENTER THE NAME OF THE INSTRUCTION FILE; '
       WRITE(*,*)' ENTER -99 TO SEE ALL OR A PART OF YOUR DIRECTORY: '
       READ(*,2) ALLINSTRUCT
       IF(ALLINSTRUCT(1:3) .EQ. '-99') 
     1  CALL SEEDIR(PATH,NOB,ALLINSTRUCT,OSName,ListDir)

C  CALL FULLNAME WHICH CONVERTS THE FILENAME TO PATHFILE, THE COMPLETE
C  NAME OF THE FILE, WHICH INCLUDES THE PATH (IF THE PATH IS NOT THE
C  CURRENT DIRECTORY).

     	 TMPFILE = ' '
       TMPFILE = ALLINSTRUCT
       CALL FULLNAME(PATH,TMPFILE,PATHFILE)
       OPEN(25,FILE=PATHFILE,ERR=9810,STATUS='OLD')
       GO TO 9820
 9810  WRITE(*,5316) PATHFILE
       GO TO 9880

 9820   CONTINUE


C  READ ALL INPUT DATA FROM FILE ALLINSTRUCT, WHICH WAS FILLED FROM A
C  PREVIOUS RUNNING OF THIS PROGRAM. 

C  THE 1ST LINE IN ALLINSTRUCT IS THE CODE WHICH
C  GIVES THE VERSION NO. OF THE PROGRAM. IF THE VERSION IS NOT CORRECT,
C  TELL THE USER AND HAVE HIM TRY AGAIN.

       READ(25,7123) CODE

C  CHECK FOR PREVIOUS VERSIONS. IF A PREVIOUS VERSION INPUT FILE IS
C  USED, PUT IN DEFAULT VALUES FOR UNINPUT INFO.
C  ALLOWABLE VERSIONS ARE:

C  IT2B114.FOR                'REM_FRN MAR_16' 
C  IT2B109.FOR                'REM_FRN JUL_13'

C  IF A TOO-OLD VERSION IS USED, PRINT A MESSAGE TO USER, AND HAVE HIM
C  TRY AGAIN.

	 ICODE1 = 0
       IF(CODE .EQ. 'REM_FRN JUL_13') ICODE1 = 1
       IF(CODE .EQ. 'REM_FRN MAR_16') ICODE1 = 2

       IF(ICODE1 .EQ. 0) THEN
        WRITE(*,9821)
 9821   FORMAT(//' YOUR INSTRUCTION FILE IS NOT FROM THE ALLOWABLE '/
     1' SET OF INSTRUCTION FILES.'//
     2' FOR THIS OPTION, YOU MUST USE A FILE WITH REM_FRN XXX_XX IN '/
     3' COLUMNS 1 THROUGH 14 ON LINE 1, WHERE  XXX_XX  IS JUL_13 OR'/
     4' A MORE RECENT DATE.'//)
        GO TO 9880
       ENDIF

C  SKIP THIS LINE. IT CONTAINS 'IVERIFY: 1 --> YES; 0 --> NO'.
      READ(25,*) 
      READ(25,*) IVERIFY

C  IF IVERIFY = 1, THE USER WILL GET THE CHANCE TO MODIFY THESE 
C  INSTRUCTIONS AS THE PROGRAM WILL CALL SUBROUTINE VERIF1.

C  NOTE THAT IF IVERIFY = 0, VERIF1 WILL NEVER BE CALLED, AND THE 
C  QUESTION OF SAVING INFO TO ANOTHER INSTRUCTION FILE WILL NOT COME UP,
C  SINCE THE INSTRUCTIONS IN THIS FILE WILL NOT BE CHANGED.
  
C  SKIP THIS LINE. IT CONTAINS 'FORTRAN MODEL FILE'
      READ(25,*)
      READ(25,2) FORFILE


C  SKIP THIS LINE. IT CONTAINS 'NDIM'.
      READ(25,*) 
      READ(25,*) NDIM

C  SKIP THIS LINE. IT CONTAINS 'NP'.
      READ(25,*)
      READ(25,*) NP

C  SKIP THIS LINE. IT CONTAINS 'IRAN INDICES'.
      READ(25,*)
      READ(25,*) (IRAN(I),I=1,NP)

C  SKIP THIS LINE. IT CONTAINS 'NVAR'.
      READ(25,*)
      READ(25,*) NVAR

C  NVAR COULD BE > MAXDIM IF THE USER HAS MANUALLY EDITED THE
C  INSTRUCTION FILE. IF SO, WRITE MESSAGE TO THE USER AND STOP.

      IF(NVAR .GT. MAXDIM) THEN


	 WRITE(*,111) NVAR,MAXDIM
  111    FORMAT(//' YOUR INSTRUCTION FILE, SHOWS ',I2,' PARAMETERS TO'/
     1' BE RANDOM VARIABLES. THE LIMIT IS CURRENTLY ',I2,'. PLEASE'/
     2' RERUN THIS PROGRAM AFTER EDITING YOUR INSTRUCTION FILE AND'/
     3' MAKING THE CORRECTION. '//)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,111) NVAR,MAXDIM 
        CLOSE(42)


       CALL PAUSE
       STOP


      ENDIF

C  SKIP THIS LINE. IT CONTAINS 'PAR(I),I=1,NVAR'
      READ(25,*)

      DO I = 1,NVAR
       READ(25,1717) PAR(I)
      END DO

C  SKIP THIS LINE. IT CONTAINS 'AB ARRAY'
         READ(25,*)
     
      DO I=1,NVAR
       READ(25,*) (AB(I,J),J=1,2)
      END DO


C  SKIP THIS LINE. IT CONTAINS 'NOFIX'.
      READ(25,*)
      READ(25,*) NOFIX

      IF(NOFIX .GT. 20) THEN

       WRITE(*,112) NOFIX
  112  FORMAT(//' YOUR INSTRUCTION FILE SHOWS ',I2,' PARAMETERS TO BE'/
     1' FIXED PARAMETERS. THE LIMIT IS CURRENTLY 20. PLEASE RERUN'/
     2' THIS PROGRAM AFTER EDITING YOUR INSTRUCTION FILE AND MAKING'/
     3' THE CORRECTION. '//)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,112) NOFIX
        CLOSE(42)

       CALL PAUSE
       STOP

      ENDIF



     
C  SKIP THIS LINE. IT CONTAINS 'PARFIX(I),I=1,NOFIX, IF NOFIX > 0'.
      READ(25,*)

      IF(NOFIX .GT. 0) THEN
       DO I = 1,NOFIX

        
       READ(25,1717) PARFIX(I)
       END DO
      ENDIF

C  SKIP THIS LINE. IT CONTAINS 'VALFIX ARRAY IF NOFIX > 0'.
         READ(25,*)
         IF(NOFIX .GT. 0) READ(25,*) (VALFIX(I),I=1,NOFIX)


C  IF ICODE1 = 1, SET NRANFIX = 0.
      IF(ICODE1 .EQ. 1) NRANFIX = 0

      IF(ICODE1 .EQ. 2) THEN

C  SKIP THIS LINE. IT CONTAINS 'NRANFIX'.
       READ(25,*)
       READ(25,*) NRANFIX

      IF(NRANFIX .GT. 20) THEN

        WRITE(*,3112) NRANFIX
 3112  FORMAT(//' YOUR INSTRUCTION FILE SHOWS ',I2,' PARAMETERS TO BE'/
     1' RANFIX PARAMETERS. THE LIMIT IS CURRENTLY 20. PLEASE RERUN'/
     2' THIS PROGRAM AFTER EDITING YOUR INSTRUCTION FILE AND MAKING'/
     3' THE CORRECTION. '//)

         OPEN(42,FILE=ERRFIL)
          WRITE(42,3112) NRANFIX
         CLOSE(42)

        CALL PAUSE
        STOP

       ENDIF

C  SKIP THIS LINE. IT CONTAINS 'PARRANFIX(I),I=1,NOFIX, IF 
C  NRANFIX > 0'.
      READ(25,*)

      IF(NRANFIX .GT. 0) THEN
       DO I = 1,NRANFIX
        READ(25,1717) PARRANFIX(I)
       END DO
      ENDIF

C  SKIP THIS LINE. IT CONTAINS 'RANFIXEST ARRAY IF NRANFIX > 0'.
       READ(25,*)
       IF(NRANFIX .GT. 0) READ(25,*) (RANFIXEST(I),I=1,NRANFIX)


      ENDIF
C  ABOVE ENDIF IS FOR THE  IF(ICODE1 .EQ. 2)  CONDITION.



	IF(NVAR + NOFIX + NRANFIX .GT. 32) THEN

	 WRITE(*,113) NVAR + NOFIX + NRANFIX
  113    FORMAT(//' YOUR INSTRUCTION FILE SHOWS A TOTAL OF ',I2/
     1' PARAMETERS. THE LIMIT IS CURRENTLY 32. PLEASE RERUN THIS '/
     2' PROGRAM AFTER EDITING YOUR INSTRUCTION FILE (AND MODEL FILE IF'/
     3' NECESSARY) AND MAKING THE CORRECTION. '//)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,113) NVAR+NOFIX+NRANFIX 
        CLOSE(42)

       CALL PAUSE
       STOP

      ENDIF



C  SKIP THIS LINE. IT CONTAINS 'O.D.E. TOLERANCE'.
      READ(25,*)
      READ(25,*) TOLER

      RTOL = TOLER
      DO I = 1,NDIM
       ATOL(I) = TOLER
      END DO

C  MF IS HARDCODED TO BE 22.

      MF = 22


C  SKIP THIS LINE. IT CONTAINS 'IFORMT'.
         READ(25,*)
         READ(25,*) IFORMTT

C  IFORMTT MUST BE CHANGED TO BE THE SAME AS THE
C  OLD IFORMT AS FOLLOWS:
C  IFORMTT = 1 --> IFORMT = 3 --> PATIENT INFO IS INPUT VIA BLOCK FORMAT
C                                 (.CSV FILES);
C  IFORMTT = 2 --> IFORMT = 1 --> PATIENT INFO IS INPUT VIA WORKING COPY
C                                 FILES.

         IF(IFORMTT .EQ. 1) IFORMT = 3
         IF(IFORMTT .EQ. 2) IFORMT = 1
    
         IF(IFORMT .EQ. 2) THEN


          WRITE(*,1231)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,1231)  
        CLOSE(42)


          CALL PAUSE
          STOP


         ENDIF

         IF(IFORMT .EQ. 1) THEN

C  SKIP THIS LINE. IT CONTAINS 'PREFIX'.
          READ(25,*)
          READ(25,2222) PREFIX

C  SKIP THIS LINE. IT CONTAINS 'EXT'.
          READ(25,*)
          READ(25,222) EXT

         ENDIF


         IF(IFORMT .EQ. 3) THEN

C  SKIP THIS LINE. IT CONTAINS 'BLOCKPAT', THE .CSV FILENAME.
          READ(25,*)
          READ(25,2) BLOCKPAT
          TMPFILE = ' '
          TMPFILE = BLOCKPAT
          CALL FULLNAME(PATH,TMPFILE,PATHFILE)
          OPEN(67,FILE=PATHFILE,STATUS='OLD')

          ICODE1PAT = 0
          READ(67,7126) CODEPAT

          IF(CODEPAT .EQ. '"POPDATA APR_11') ICODE1PAT = 1
          IF(CODEPAT(1:14) .EQ. 'POPDATA APR_11') ICODE1PAT = 1

          IF(CODEPAT .EQ. '"POPDATA DEC_11') ICODE1PAT = 1

          IF(CODEPAT(1:14) .EQ. 'POPDATA DEC_11') ICODE1PAT = 1

          IF(ICODE1PAT .EQ. 0) THEN


           WRITE(*,3131)
           WRITE(*,*)' THE PROGRAM STOPS.'
           CLOSE(67)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,3131)
         WRITE(42,*)' THE PROGRAM STOPS.'
        CLOSE(42)


           CALL PAUSE
           STOP


          ENDIF

          CLOSE(67)

C  SKIP THIS LINE. IT CONTAINS 'NCOVA', THE NO. OF COVARIATES.
          READ(25,*)
          READ(25,*) NCOVA
  
C  SKIP THIS LINE. IT CONTAINS 'COVNAME(I),I=1,NCOVA, IF NCOVA > 0'.
      READ(25,*)

      IF(NCOVA .GT. 0) THEN
       DO I = 1,NCOVA
        READ(25,1717) COVNAME(I)
       END DO
      ENDIF

C  SKIP THIS LINE. IT CONTAINS 'ICOVTYPE ARRAY IF NCOVA > 0'.
         READ(25,*)
         IF(NCOVA .GT. 0) READ(25,*) (ICOVTYPE(I),I=1,NCOVA)

         ENDIF
C  ABOVE ENDIF IS FOR THE  IF(IFORMT .EQ. 3)  CONDITION.


C  READ IN BOTH NSUBTOT AND NSUB AND THEN CALL
C  ROUTINE GETIPATF WHICH READS THIS PORTION OF FILE 25 TO OBTAIN
C  IPATVEC. NOTE THE 1ST ARGUMENT TELLS GETIPATF TO READ FILE 25.

C  NOTE THAT IF IERRR RETURNS AS -1, THERE IS A PROBLEM WITH THE
C  PATIENT NO. INFO IN THE FILE. IN THIS CASE, THE USER HAS ALREADY
C  BEEN INFORMED OF THE PROBLEM IN GETIPATF, SO JUST WRITE A MESSAGE
C  AND STOP.

C  SKIP THIS LINE. IT CONTAINS 'NSUBTOT'.
         READ(25,*)
         READ(25,*) NSUBTOT

C  SKIP THIS LINE. IT CONTAINS 'NSUB'.

         READ(25,*)
         READ(25,*) NSUB

C  SKIP THIS LINE. IT CONTAINS "ACTIVE PATIENT NUMBERS, FOLLOWED BY
C  A LINE WITH '0'"

         READ(25,*)       
         CALL GETIPATF(25,NSUBTOT,NSUB,MAXSUB,IPATVEC,IERRR)

         IF(IERRR .EQ. -1) THEN


          WRITE(*,2127)
 2127     FORMAT(/' ... OR EDIT THE INSTRUCTION FILE USED IN THIS'/
     1'     RUN, AND MAKE THE INDICATED CORRECTION.'/)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,2128)
 2128   FORMAT(//' THERE WAS AN ERROR IN THE READING OF PATIENT NOS.'/
     1' TO BE USED FOR THIS ANALYSIS. PLEASE ENTER DATA VIA THE '/
     2' KEYBOARD OR USING ANOTHER INSTRUCTION FILE.'/)
         WRITE(42,2127)
         CLOSE(42)


          CALL PAUSE
          STOP
         ENDIF

C  SKIP THIS LINE. IT CONTAINS 'XSIG'.
         READ(25,*)         
         READ(25,*) XSIG

C  SKIP THIS LINE. IT CONTAINS 'NUMEQT'.

         READ(25,*)
         READ(25,*) NUMEQT

C  SKIP THIS LINE. IT CONTAINS 'NUMEQT SETS OF IGAMMA,Cs,IASS,IQVAL'.
         READ(25,*)

C wmy2018.01.16 Added c4p and c5p to read
         DO IEQ=1,NUMEQT
          READ(25,*) IGAMMA(IEQ)
          READ(25,*) C0P(IEQ),C1P(IEQ),C2P(IEQ),C3P(IEQ)
     1     ,C4P(IEQ),C5P(IEQ)
          READ(25,*) IASS(IEQ)
          READ(25,*) IQVAL(IEQ)
         END DO

C  SKIP THIS LINE. IT CONTAINS 'NDRUG'.
         READ(25,*)
         READ(25,*) NDRUG

C  SKIP THIS LINE. IT CONTAINS 'AF(I),I=1,NDRUG'.
         READ(25,*)
         READ(25,*) (AF(I),I=1,NDRUG)
         IAF = 1

C  SKIP THIS LINE. IT CONTAINS 'TOL'.
         READ(25,*)
         READ(25,*) TOL

C  SKIP THIS LINE. IT CONTAINS 'MAXIT'.
         READ(25,*)
         READ(25,*) MAXIT

C  MAXIT MUST BE .LE. 40999. IF NOT, RESET IT.

         IF(MAXIT .GT. 40999) MAXIT = 40999

C  SKIP THIS LINE. IT CONTAINS 'XDEV'.
         READ(25,*)
         READ(25,*) XDEV


       CLOSE(25)


C  GO TO LABEL 1230 TO SKIP ALL THE CODE WHICH ENTERS INFO VIA A 

C  PREVIOUS INSTRUCTION FILE, WHICH WAS NOT ALL-INCLUSIVE (I.E., WITH
C  A DATE OF JUL_10 TO JUL_11 ON LINE 1); OR THE KEYBOARD.

       GO TO 1230 

      ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(IALLIN .EQ. 1)  CONDITION.
    

C  TO GET HERE MEANS THE USER IS NOT USING THE NEW-STYLE ALL-INCLUSIVE
C  INSTRUCTION FILE. 


C  CALL GETPATH TO GET FROM THE USER THE PATH WHERE THE INPUT FILES ARE
C  LOCATED (AND WHERE THE OUTPUT FILES WILL GO). NOTE THAT PATH IS THE
C  PATH WITH A TRAILING BACKSLASH, AND NOB IS THE NO. OF THE ENTRY WITH
C  THE LAST NON-BLANK ENTRY.

     	CALL GETPATH(PATH,NOB,OSName)

 6280    WRITE(*,6278)
 6278    FORMAT(//' ENTER 1 TO DO AN IT2B ANALYSIS; '/
     1/' ENTER 2 TO EXAMINE THE RESULTS FROM A PREVIOUS RUN: ')
	READ(*,*,ERR=6280) IANAL
	IF(IANAL .LT. 1 .OR. IANAL .GT. 2) GO TO 6280


	IF(IANAL .EQ. 2) THEN

C  IF IANAL .EQ. 2, CALL SUBROUTINE EXTRAOPT TO INPUT OUTPUT FILES
C  FROM A PREVIOUS RUN, AND THEN ALLOW ALL 6 OPTIONS INDICATED BELOW
C  LABEL 7185 FOR THAT RUN. 

C  AS OF IT2B105.FOR, IBEEP IS REMOVED.


     	 CALL EXTRAOPT(PATH,NOB,MAXSUB,PAREST,SERNUM,YPREDPOP,
     1   YPREDBAY,PARBAY,YO,MAXOBDIM,OSName,ListDir,DeleteFile,
     2   ClearScreen,MAXNUMEQ)

   	 STOP

	ENDIF


C  EVERYTHING BELOW IS THE IANAL = 1 OPTION.


C  QVAL, WRITTEN TO INSTFILE, WILL BE THE NO. OF NOISE PARAMETERS
C  ALREADY ESTIMATED (BY assbigxx.exe) OR TO BE ESTIMATED
C  (BY itbig9x.exe). IT IS ONLY USED IF itbig9x.exe IS TO BE
C  RUN; NOT IF assbigxx.exe IS TO BE RUN.


C  TO CALCULATE QVAL, MUST INITIALIZE ALL IQVAL(IEQ) = 0 NOW (IF AN
C  INPUT FILE IS USED, IQVAL WILL BE READ IN AND THE FOLLOWING LOGIC
C  WILL BE N/A). THEN:

C  FOR EACH IEQ=1,NUMEQT (NUMEQT = NO. OF OUTPUT EQUATIONS IN PATIENT
C  DATA FILES):

C  IQVAL(IEQ) = 0 IF OUTPUT EQ. IEQ HAS ITS C'S ENTERED BY USER (NOT
C		  ESTIMATED BY assbigxx.exe) AND IGAMMA(IEQ) = 1
C		  (WHICH MEANS THAT GAMMA = 1.0 FOR THAT EQ.).
C	      = 1 IF OUTPUT EQ. IEQ HAS ITS C'S ENTERED BY USER (NOT
C		  ESTIMATED BY assbigxx.exe) AND IGAMMA(IEQ) = 0
C		  (WHICH MEANS THAT GAMMA IS TO BE ESTIMATED DURING
C		  THE PROGRAM, itbig9x.exe).
C	       = 4 IF OUTPUT EQ. IEQ HAD ITS C'S ESTIMATED PREVIOUSLY
C		  BY assbigxx.exe.



C  THE MAXIMUM POSSIBLE VALUE OF NUMEQT = MAXNUMEQ. SINCE NUMEQT IS
C  UNKNOWN NOW, USE MAXNUMEQ IN LOOP BELOW.

      DO IEQ = 1,MAXNUMEQ
       IQVAL(IEQ) = 0
      END DO

        WRITE(*,919)
  919   FORMAT(//' ***************** VERY IMPORTANT *****************'//
     1' YOUR FORTRAN MODEL FILE MUST BE AN EDITED VERSION OF TSTMULTL.FO
     2R.'//
     3' IF THIS IS NOT SO, PLEASE STOP THE PROGRAM NOW. THEN CREATE '/
     4' YOUR MODEL FILE BY EDITING TSTMULTM.FOR AND PLACING YOUR CODE'/
     5' AS INSTRUCTED BY THE COMMENTS IN THAT FILE. AT THAT POINT, YOU'/
     6' WILL BE READY TO RERUN THIS PROGRAM.'//
     7' ***************** VERY IMPORTANT *****************'//)

        CALL PAUSE

C  INPUT THE NAME OF THE FORTRAN FILE WHICH IDENTIFIES THE MODEL AND 
C  THE PARAMETERS FOR THE USER'S ANALYSIS. THEN CALL SUBROUTINE USERPREP
C  TO INPUT VALUES FROM THIS FILE.

        WRITE(*,5001)
5001    FORMAT(/' ENTER THE NAME OF YOUR FORTRAN MODEL FILE: ')
        READ(*,2) FORFILE

C  CALL FULLNAME WHICH CONVERTS THE FILENAME TO PATHFILE, THE COMPLETE
C  NAME OF THE FILE, WHICH INCLUDES THE PATH (IF THE PATH IS NOT THE
C  CURRENT DIRECTORY).


 5010	TMPFILE = ' '
	TMPFILE = FORFILE
	CALL FULLNAME(PATH,TMPFILE,PATHFILE)
      OPEN(28,FILE=PATHFILE,ERR=50,STATUS='OLD',POSITION='APPEND')
	GO TO 30
   50   WRITE(*,4406) PATHFILE
4406    FORMAT(//' THE FOLLOWING FILE DOES NOT EXIST ... '/
     1'    ',A73/
     2' ENTER THE CORRECT FILENAME OR ... '/
     2' ENTER -99 TO SEE ALL OR A PART OF YOUR DIRECTORY: ')

	READ(*,2) FORFILE
	IF(FORFILE(1:3) .EQ. '-99') THEN
           CALL SEEDIR(PATH,NOB,FORFILE,OSName,ListDir)
	endif
        GO TO 5010


   30	CALL USERPREP(NDIM,NP,NVAR,MAXDIM,PAR,NOFIX,PARFIX,NRANFIX,
     1 PARRANFIX,IRAN)


C  THE ABOVE CALL OBTAINS THE FOLLOWING VALUES:

C  NDIM = NO. OF STATES FOR THE O.D.E.

C  NP = TOTAL NO. OF PARAMETERS = NVAR + NOFIX + NRANFIX.
C  NVAR = NO. OF R.V.'S (1 .LE. NVAR .LE. MAXDIM).
C  PAR(I),I=1,NVAR = NAMES OF THE RANDOM VARIABLES FOR THIS RUN.
C  NOFIX = NO. OF NON-RANDOM (FIXED) PARAMETERS WHOSE FIXED VALUES ARE
C          TO BE SET BY THE USER.

C  PARFIX(I),I=1,NOFIX = NAMES OF FIXED PARAMETERS FOR THIS RUN.
C  NRANFIX = NO. OF PARAMETERS WHICH ARE THE SAME FOR ALL SUBJECTS,
C          BUT UNKNOWN (AND ARE TO BE ESTIMATED).
C  PARRANFIX(I),I=1,NRANFIX = NAMES OF THE RANFIX PARAMETERS FOR THIS 
C          RUN.
C  IRAN(I) = 1 IF PARAMATER I IS RANDOM;
C           -1 IF PARAMETER I IS RANDOM AND ALLOWED TO BE < 0;
C            0 IF PARAMETER I IS FIXED AND KNOWN;
C            2 IF PARAMETER I FIXED AND UNKNOWN (TO BE ESTIMATED);
C            I = 1,NVAR+NOFIX+NRANFIX.


C  CALL SUBROUTINE DETECT WHICH MAKES SURE THAT THE USER'S FORTRAN FILE
C  IS THE CORRECT VERSION FOR THE LOCATION WHERE IT IS TO BE RUN. NOTE
C  THAT IVERS = 0 IS HARDCODED, AS OF ITBIG9.FOR, IN DETECT.

C  N0! AS OF ITBIG10.FOR, DETECT IS NO LONGER CALLED. THE REASON IS
C  THAT IT WILL NOW BE ASSUMED THAT THE USER CREATES HIS MODEL FILE
C  FROM THE TEMPLATE MODEL FILE (CURRENTLY TSTMULTH.FOR) AND SO IT
C  WILL AUTOMATICALLY HAVE THE CORRECT DECLARATION STATEMENTS AT THE
C  TOP OF EACH SUBROUTINE. PLUS, THIS WILL PREVENT THIS PROGRAM FROM
C  STRIPPING AWAY SPECIAL DECLARATION STATEMENTS THE USER MAY NEED TO
C  ADD TO THE ROUTINES FOR SPECIAL CASE ANALYSES.

C     CALL DETECT(NOB,PATH,FORFILE,IVERS,CopyFile,
C      1     DeleteFile,ClearScreen)


C  READ IN VALUES FOR MF, RTOL, AND ATOL, WHICH ARE NEEDED FOR THE
C  O.D.E. SOLVER USED BY ROUTINE USERANAL (IN MODULE IDUSER__.FOR).


C MF     = Method flag.  Standard values are..
C          10 for nonstiff (Adams) method, no Jacobian used.
C          21 for stiff (BDF) method, user-supplied full Jacobian.
C          22 for stiff method, internally generated full Jacobian.


C	   FOR NOW MF = 22 WILL BE HARDCODED (SINCE THERE IS NO
C	   JACOBIAN SUBROUTINE (JACOB HAS BEEN TAKEN OUT FOR NOW).

C          24 for stiff method, user-supplied banded Jacobian.
C          25 for stiff method, internally generated banded Jacobian.
C RTOL   = Relative tolerance parameter (scalar).
C ATOL   = Absolute tolerance parameter.
C          The estimated local error in X(i) will be controlled so as
C          to be roughly less (in magnitude) than

C             EWT(i) = RTOL*abs(X(i)) + ATOL(i)  SINCE ITOL = 2.
C          Thus the local error test passes if, in each component,
C          either the absolute error is less than ATOL (or ATOL(i)),
C          or the relative error is less than RTOL.
C          Use RTOL = 0.0 for pure absolute error control, and
C          use ATOL = 0.0 (or ATOL(i) = 0.0) for pure relative error
C          control.  Caution.. Actual (global) errors may exceed these

C          local tolerances, so choose them conservatively.


  915   WRITE(*,913)

  913   FORMAT(/' ENTER 1 TO SET ALL TOLERANCES (FOR THE O.D.E. '/
     1'         SOLVER) TO THE DEFAULT VALUE ... 1.D-4.'/
     2' ENTER 0 TO SELECT A DIFFERENT VALUE FOR THE TOLERANCES: ')
	READ(*,*,ERR=915) ITOL

	IF(ITOL .NE. 0 .AND. ITOL .NE. 1) GO TO 915

	TOLER=1.D-4

	IF(ITOL .EQ. 0) THEN

  910	WRITE(*,914)
  914  FORMAT(/' ENTER A POSITIVE VALUE FOR THE TOLERANCE PARAMETERS: ')
	READ(*,*,ERR=910) TOLER
	IF(TOLER .LE. 0.D0) GO TO 910


	ENDIF

	RTOL = TOLER
	DO I=1,NDIM
	 ATOL(I) = TOLER

	END DO

C 930	WRITE(*,917)
C 917   FORMAT(/' ENTER 10 IF THE PROBLEM IS NON-STIFF (NO JACOBIAN'/
C    1' 	WILL BE NEEDED;'/
C    2' ENTER 21 FOR A STIFF PROBLEM, IN WHICH YOU WILL SUPPLY'/
C    3'		THE FULL JACOBIAN IN SUBROUTINE JACOB (IN MODULE'/
C    4'		USER.FOR;'/
C    5' ENTER 22 FOR A STIFF PROBLEM, IN WHICH YOU WANT THE PROGRAM'/

C    6'		TO CALCULATE THE JACOBIAN INTERNALLY: ')

C	READ(*,*,ERR=930) MF
C	IF(MF .NE. 10 .AND. MF .NE. 21 .AND. MF .NE. 22) GO TO 930

	MF = 22


C#######################################################################
C#######################################################################


C  INPUT DATA FROM THE USER DIRECTLY, OR FROM AN INPUT FILE. THE
C  FOLLOWING WILL BE ENTERED:

C  IFORMTT (FOR FILES WITH CODES NEWER THAN 'REM_FRN APR_11') OR
C  IFORMT (FOR FILES WITH CODE = 'REM_FRN JUL_10'), WHERE


C  IFORMTT = 2 AND IFORMT = 1 IF PATIENT DATA FILES ARE IN 
C            WORKING COPY FORMAT.
C  IFORMTT = 1 AND IFORMT = 3 IF THE NEW BLOCK MATRIX FORMAT IS 
C            USED.


C  IF IFORMTT = 2/IFORMT = 1, IT WILL BE ASSUMED THAT THE PATIENT
C   DATA FILES ALL HAVE THE SAME PREFIX AND EXTENSION). IDIRCT IS 
C   NO LONGER USED.

C  IF IFORMTT = 2/IFORMT = 1,
C	PREFIX = 5-CHARACTER PREFIX FOR ALL SUBJECT FILENAMES. THEN
C           001, 002,... UP TO MAXSUB WILL COMPLETE THE 1ST NAMES OF THE
C           INDIVIDUAL FILENAMES WHICH ARE READ IN.
C
C	EXT = AN OPTIONAL 3-CHARACTER EXTENSION (AFTER DECIMAL POINT)
C	      FOR THE INPUT FILENAMES.

C  NSUB = NO. OF SUBJECTS WHOSE DATA ARE TO USED FOR THE ANALYSIS (MAX
C	    NO. = MAXSUB).

C  NSUBTOT = TOTAL NO. OF SUBJECTS IN THE PATIENT DATA POPULATION (NSUB
C            IDENTIFIES THET SUBSET OF THIS POPULATION TO BE USED FOR
C            THIS RUN).


C  VALFIX(I) = VALUE OF FIXED PARAMETER I, I=1,NOFIX.


C  BOUNDARIES FOR RANDOM VARIABLES I, I=1,NVAR.
C    THESE WILL BE USED ONLY TO ESTABLISH THE INITIAL ESTIMATES FOR THE
C    POPULATION MEAN VECTOR (MIDRANGE OF BOUNDARY VALUES) AND COVARIANCE
C    MATRIX (DIAGONAL WITH EACH STD. DEV. SET = XSIG*RANGE FOR THAT
C    PARAMETER ... SEE XSIG BELOW). ALSO, THE POPULATION MEAN VECTOR
C    WILL BE THE INITIAL START VECTOR FOR THE NELDER MEAD ALGORITHM FOR
C    EACH SUBJECT IN ITERATION 1.
C           AB(I,1) = LOWEST VALUE FOR VARIABLE I ON ITS GRID, I=1,NVAR.
C           AB(I,2) = HIGHEST VALUE FOR VARIABLE I ON ITS GRID,I=1,NVAR.

C  XSIG, WHERE THE INITIAL POPULATION STD. DEV. ESTIMATE FOR EACH
C        PARAMETER WILL BE XSIG*(AB(I,2) - AB(I,1)). THE DEFAULT VALUE
C 	 FOR XSIG IS .5.

C  NUMEQT = NO. OF OUTPUT EQUATIONS.

C  IGAMMA(IEQ) = FOLLOWING FOR IEQ = 1,NUMEQT:
C         1 IF GAMMA(IEQ) IS TO REMAIN 1.0 THROUGHOUT THE ANALYSIS;
C	    0 IF THE UPDATED ESTIMATE OF GAMMA(IEQ) IS TO BE ESTIMATED
C	      EACH CYCLE.
C	    2 IF A PRELIMINARY MAINFRAME PROGRAM WILL BE USED TO
C	      OBTAIN OPTIMUM ESTIMATES FOR THE C0(IEQ),...C3(IEQ).

C  C0P(IEQ),...,C3P(IEQ) = FOLLOWING FOR IEQ=1,NUMEQT:
C            THE POPULATION COEFFICIENTS FOR THE ASSAY STANDARD
C		 DEVIATION OF THE OBSERVED VALUES.

C  IASS(IEQ) = FOLLOWING FOR IEQ=1,NUMEQT:
C		 0 IF C0P(IEQ),...,C3P(IEQ) ENTERED PATIENT x PATIENT;
C		 2 IF ONE SET OF ABOVE C'S USED FOR ALL PATIENTS;
C	 	 1 IF C'S ALREADY IN PATIENT FILES WILL BE USED; IF A
C		   PATIENT HAS NO C'S, THEN POPULATION C'S WILL BE USED.

C  AF(I), I = 1,NDRUG, WHERE AF(I) IS THE ACTIVE (SALT) FRACTION FOR
C         DRUG I.

C  TOL = TOLERANCE WHICH DETERMINES WHEN THE "ITS" ALGORITHM STOPS.
C	 IN PARTICULAR, IF THE AVERAGE LOG-LIKIHOOD OF THE PARAMETER
C	 VECTOR ESTIMATES, GIVEN THE DATA AND THE CURRENT ESTIMATES FOR
C	 (MU, COV), DIFFERS BY LESS THAN TOL FROM THE PREVIOUS
C	 ITERATION, THE PROGRAM STOPS.

C  MAXIT = MAXIMUM NO. OF ITERATIONS (STOPS THE PROGRAM IF TOL ABOVE
C	   IS NEVER REACHED).

C  XDEV, WHERE THE PARAMETER BOUNDARIES WHICH WILL BE SUPPLIED TO THE
C  2ND PART (NPAG) OF THIS TWO-PART BATCH PROGRAM ARE, FOR EACH
C  VARIABLE, [a, M+XDEV*S], WHERE M AND S ARE THE FINAL POPULATION MEAN
C  AND STD DEV FOR THAT VARIABLE, RESPECTIVELY, AND
C  a = max(aa, M - XDEV*S), WHERE aa = 0, 1.D-8, 1.D-3, OR 1.D-1
C  DEPENDING ON THE PARAMETER INVOLVED. THE ONE EXCEPTION TO THE ABOVE

C  IS THAT, IF FA IS A VARIABLE, ITS UPPER BOUNDARY IS .LE. 1.0.



C-----------------------------------------------------------------------

C  GIVE THE USER THE OPTION TO INPUT INFO VIA KEYBOARD OR FILE.

C  NRANFIX WAS OBTAINED BY SUBROUTINE USERPREP ABOVE. IF THE USER
C  SPECIFIED NRANFIX > 0, THEN INSTRUCTIONS MUST NOW COME VIA THE
C  KEYBOARD SINCE PREVIOUS VERSIONS OF THIS PROGRAM DID NOT ALLOW
C  PARAMETERS WHICH ARE UNKNOWN BUT THE SAME FOR ALL SUBJECTS. IN THIS
C  CASE GO TO LABEL 9700 AFTER SETTING INOPT = 0 (WHICH INDICATES 
C  KEYBOARD ENTRY).

      IF(NRANFIX .GT. 0) THEN
       WRITE(*,9197)
 9197  FORMAT(//' BECAUSE YOU SELECTED SOME PARAMETERS TO BE RANFIX,'/
     1' YOU MUST NOW ENTER INSTRUCTIONS VIA THE KEYBOARD (SINCE '/
     2' PREVIOUS VERSIONS OF NON-ALL-INCLUSIVE INSTRUCTION FILES FOR'/
     3' THIS PROGRAM DID NOT ALLOW PARAMETERS WHICH ARE UNKNOWN BUT'/
     4' THE SAME FOR ALL SUBJECTS.'/)
       CALL PAUSE
       INOPT = 0
       GO TO 9700
      ENDIF


  138   FORMAT(/' PLEASE ENTER ONE OF THE REQUESTED VALUES: ')
  145	WRITE(*,38)
   38   FORMAT(//' ENTER 0 TO ENTER INSTRUCTIONS FROM THE KEYBOARD;'/
     1' ENTER 1 TO ENTER INSTRUCTIONS FROM A FILE CREATED BY A '/
     2'         PREVIOUS RUNNING OF THIS PROGRAM; THIS FILE MUST'/
     3'         HAVE A DATE ON LINE 1 WHICH IS BETWEEN JUL_10 AND'/
     4'         JUL_11: ')

	READ(*,*,ERR=145) INOPT
	IF (INOPT .NE. 0 .AND. INOPT .NE. 1) GO TO 145

	IF(INOPT .EQ. 1) THEN

	 WRITE(*,39)
   39  FORMAT(/' ENTER THE NAME OF THE INSTRUCTION FILE; ')
	 WRITE(*,*)' ENTER -99 TO SEE ALL OR A PART OF YOUR DIRECTORY: '
       READ(*,2) FILNFO
	 IF(FILNFO(1:3) .EQ. '-99') THEN
            CALL SEEDIR(PATH,NOB,FILNFO,OSName,ListDir)
         ENDIF

C  CALL FULLNAME WHICH CONVERTS THE FILENAME TO PATHFILE, THE COMPLETE
C  NAME OF THE FILE, WHICH INCLUDES THE PATH (IF THE PATH IS NOT THE

C  CURRENT DIRECTORY).

     	TMPFILE = ' '
	TMPFILE = FILNFO
	CALL FULLNAME(PATH,TMPFILE,PATHFILE)

	OPEN(25,FILE=PATHFILE,ERR=4705,STATUS='OLD')
	GO TO 4710
 4705	WRITE(*,5316) PATHFILE
 5316   FORMAT(//' THE FOLLOWING FILE DOES NOT EXIST ... '/
     1'    ',A73)
	GO TO 145

C  THE 1ST LINE IN THE INPUT FILE IS THE CHARACTER*14 CODE IDENTIFYING
C  WHICH VERSION OF THE PROGRAM WROTE THE INPUT FILE.

 4710	 READ(25,7123) CODE
 7123    FORMAT(A14)

C  NOTE THAT THE 1ST PROGRAM IN THIS "BIG" IT2B SERIES IS ITBIG9.FOR,
C  AND THE 1ST CODE = 'REM_FRN JUL_10'.

C  IF A TOO-OLD VERSION IS USED, PRINT A MESSAGE TO USER, AND HAVE HIM
C  TRY AGAIN.

	 ICODE = 0
	 IF(CODE .EQ. 'REM_FRN JUL_10') ICODE = 1007
	 IF(CODE .EQ. 'REM_FRN APR_11') ICODE = 1104
	 IF(CODE .EQ. 'REM_FRN JUL_11') ICODE = 1107

	 IF(ICODE .EQ. 0) THEN

	  WRITE(*,7321)
 7321   FORMAT(//' YOUR INSTRUCTION FILE IS NOT FROM THE ALLOWABLE '/
     1' SET OF INSTRUCTION FILES.'//
     2' EITHER ENTER INSTRUCTIONS FROM THE KEYBOARD, OR USE A FILE '/
     3' WITH   REM_FRN XXX_XX   IN COLUMNS 1 THROUGH 14 ON LINE 1,'/
     4' WHERE  XXX_XX  IS JUL_10 UP TO JUL_11.'//)

	  CALL PAUSE
	  GO TO 145
	 ENDIF


C  READ AN INSTRUCTION FILE WITH ICODE .GE. 1104 SEPARATELY, SINCE THE 
C  CHANGES ARE SO EXTENSIVE.
  
        IF(ICODE .GE. 1104) THEN

C  SKIP THIS LINE. IT CONTAINS 'IFORMTT'.
         READ(25,*)
	   READ(25,*) IFORMTT

C  IFORMTT MUST BE CHANGED TO BE THE SAME AS THE OLD IFORMT AS FOLLOWS:
C  IFORMTT = 1 --> IFORMT = 3 --> PATIENT INFO IS INPUT VIA BLOCK FORMAT
C                                 (.CSV FILES);
C  IFORMTT = 2 --> IFORMT = 1 --> PATIENT INFO IS INPUT VIA WORKING COPY
C                                 FILES.

         IF(IFORMTT .EQ. 1) IFORMT = 3
         IF(IFORMTT .EQ. 2) IFORMT = 1

C  AS OF ITBIG9.FOR, IFORMT=2 IS NOT ALLOWED. I.E., ALL PATIENT DATA
C  FILES WILL BE IN THE NEW WORKING COPY FORMAT (IFORMT = 1) OR ANDREAS'
C  NEW MATRIX STYLE BLOCK FORMAT (IFORMT = 3) - THIS NEW IFORMT = 3

C  OPTION IS AS OF NPBIG15.FOR.
C  IF ICODE = 1007 OR 1104, IT IS IMPOSSIBLE FOR IFORMT TO NOW BE
C  2, UNLESS THE USER HAS EDITED HIS INSTRUCTION FILE MANUALLY.

         IF(IFORMT .EQ. 2) THEN


          WRITE(*,1231)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,1231) 
        CLOSE(42)


          CALL PAUSE
          STOP


         ENDIF



         IF(IFORMT .EQ. 1) THEN

C  SKIP THIS LINE. IT CONTAINS 'PREFIX'.
          READ(25,*)

          READ(25,2222) PREFIX

C  SKIP THIS LINE. IT CONTAINS 'EXT'.

          READ(25,*)
          READ(25,222) EXT

         ENDIF


         IF(IFORMT .EQ. 3) THEN

C  SKIP THIS LINE. IT CONTAINS 'BLOCKPAT', THE .CSV FILENAME.
          READ(25,*)

          READ(25,2) BLOCKPAT
          TMPFILE = ' '
          TMPFILE = BLOCKPAT
          CALL FULLNAME(PATH,TMPFILE,PATHFILE)
          OPEN(67,FILE=PATHFILE,STATUS='OLD')

          ICODEPAT = 0
          READ(67,7126) CODEPAT

          IF(CODEPAT .EQ. '"POPDATA APR_11') ICODEPAT = 1
          IF(CODEPAT(1:14) .EQ. 'POPDATA APR_11') ICODEPAT = 1

          IF(CODEPAT .EQ. '"POPDATA DEC_11') ICODEPAT = 1
          IF(CODEPAT(1:14) .EQ. 'POPDATA DEC_11') ICODEPAT = 1



          IF(ICODEPAT .EQ. 0) THEN


           WRITE(*,3131)
           WRITE(*,*)' THE PROGRAM STOPS.'
           CLOSE(67)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,3131)
         WRITE(42,*)' THE PROGRAM STOPS.' 
        CLOSE(42)


           CALL PAUSE
           STOP


          ENDIF

          CLOSE(67)

         ENDIF

C  ABOVE ENDIF IS FOR THE  IF(IFORMT .EQ. 3)  CONDITION.


C  READ IN BOTH NSUBTOT AND NSUB AND THEN CALL
C  ROUTINE GETIPATF WHICH READS THIS PORTION OF FILE 25 TO OBTAIN
C  IPATVEC. NOTE THE 1ST ARGUMENT TELLS GETIPATF TO READ FILE 25.

C  NOTE THAT IF IERRR RETURNS AS -1, THERE IS A PROBLEM WITH THE
C  PATIENT NO. INFO IN THE FILE. IN THIS CASE, THE USER HAS ALREADY
C  BEEN INFORMED OF THE PROBLEM IN GETIPATF, SO JUST TRANSFER
C  CONTROL TO LABEL 145 ABOVE.

C  SKIP THIS LINE. IT CONTAINS 'NSUBTOT'.
         READ(25,*)
         READ(25,*) NSUBTOT

C  SKIP THIS LINE. IT CONTAINS 'NSUB'.
         READ(25,*)
         READ(25,*) NSUB

C  SKIP THIS LINE. IT CONTAINS "ACTIVE PATIENT NUMBERS, FOLLOWED BY

C  A LINE WITH '0'"
         READ(25,*)
        
         CALL GETIPATF(25,NSUBTOT,NSUB,MAXSUB,IPATVEC,IERRR)
         IF(IERRR .EQ. -1) GO TO 145

C  SKIP THREE LINES; THE FIRST CONTAINS 'NOFIX'; THE SECOND CONTAINS
C  THE VALUE OF NOFIX. THE THIRD CONTAINS 'VALFIX ARRAY IF NOFIX > 0'.
         READ(25,*)
         READ(25,*)
         READ(25,*)
         IF(NOFIX .GT. 0) READ(25,*) (VALFIX(I),I=1,NOFIX)

C  SKIP THREE LINES; THE FIRST CONTAINS 'NVAR'; THE SECOND CONTAINS
C  THE VALUE OF NVAR. THE THIRD CONTAINS 'AB ARRAY'
         READ(25,*)
         READ(25,*)
         READ(25,*)
       
         DO I=1,NVAR
          READ(25,*) (AB(I,J),J=1,2)
         END DO

C  SKIP THIS LINE. IT CONTAINS 'XSIG'.
         READ(25,*)         
         READ(25,*) XSIG

C  SKIP THIS LINE. IT CONTAINS 'NUMEQT'.

         READ(25,*)
         READ(25,*) NUMEQT

C  SKIP THIS LINE. IT CONTAINS 'NUMEQT SETS OF IGAMMA,Cs,IASS,IQVAL'.
         READ(25,*)

         DO IEQ=1,NUMEQT
          READ(25,*) IGAMMA(IEQ)
          READ(25,*) C0P(IEQ),C1P(IEQ),C2P(IEQ),C3P(IEQ)
     1     ,C4P(IEQ),C5P(IEQ)


          READ(25,*) IASS(IEQ)
          READ(25,*) IQVAL(IEQ)
         END DO

        IF(ICODE .EQ. 1104) THEN

C  SKIP THIS LINE. IT CONTAINS 'AF'.
         READ(25,*)

         READ(25,*) AFSCALAR
         IAF = 0

C  NOTE THAT AF(I), I=1,NDRUG, WILL BE SET = AFSCALAR BELOW LABEL 35
C  AFTER NDRUG IS ESTABLISHED (SINCE IAF = 0).
        
        ENDIF

        IF(ICODE .GE. 1107) THEN

C  SKIP THIS LINE. IT CONTAINS 'NDRUG'.
         READ(25,*)
         READ(25,*) NDRUG

C  SKIP THIS LINE. IT CONTAINS 'AF(I),I=1,NDRUG'.
         READ(25,*)
         READ(25,*) (AF(I),I=1,NDRUG)
         IAF = 1

        ENDIF

C  SKIP THIS LINE. IT CONTAINS 'TOL'.
         READ(25,*)
         READ(25,*) TOL

C  SKIP THIS LINE. IT CONTAINS 'MAXIT'.
         READ(25,*)
         READ(25,*) MAXIT

C  MAXIT MUST BE .LE. 40999. IF NOT, RESET IT.

         IF(MAXIT .GT. 40999) MAXIT = 40999

C  SKIP THIS LINE. IT CONTAINS 'XDEV'.
         READ(25,*)
         READ(25,*) XDEV

         CLOSE(25)

         GO TO 35


        ENDIF

C  THE ABOVE ENDIF IS FOR THE   IF(ICODE .GE. 1104)  CONDITION.


        IF(ICODE .EQ. 1007) THEN  

	   READ(25,*) IFORMTT
         IFORMT = IFORMTT

C  AS OF ITBIG9.FOR, IFORMT=2 IS NOT ALLOWED. I.E., ALL PATIENT DATA
C  FILES WILL BE IN THE NEW WORKING COPY FORMAT (IFORMT = 1) OR ANDREAS'
C  NEW MATRIX STYLE BLOCK FORMAT (IFORMT = 3) - THIS NEW IFORMT = 3
C  OPTION IS AS OF NPBIG15.FOR.
C  IF ICODE = 1007 OR 1104, IT IS IMPOSSIBLE FOR IFORMT TO NOW BE
C  2, UNLESS THE USER HAS EDITED HIS INSTRUCTION FILE MANUALLY.


	IF(IFORMT .EQ. 2) THEN


	 WRITE(*,1231)
 1231    FORMAT(/' YOUR INSTRUCTION FILE INDICATES THAT YOUR PATIENT'/
     1' DATA FILES ARE IN USC*PACK FORMAT, WHICH IS NO LONGER ALLOWED'/
     2' BY THIS PROGRAM. '//
     3' PLEASE RERUN THE PROGRAM AND ENTER PATIENT DATA INFO EITHER'/
     4' IN THE NEW-STYLE WORKING COPY FORMAT FOR MULTIPLE DRUGS'/
     5' (IFORMTT = 2), OR IN THE NEW MATRIX STYLE BLOCK FORMAT'/
     6' (IFORMTT = 1).'//)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,1231) 
        CLOSE(42)


	 CALL PAUSE
	 STOP
	ENDIF

        IF(IFORMT .EQ. 1) THEN
         READ(25,2222) PREFIX
         READ(25,222) EXT
        ENDIF

	IF(IFORMT .EQ. 3) THEN
      READ(25,2) BLOCKPAT
     	TMPFILE = ' '
	TMPFILE = BLOCKPAT
	CALL FULLNAME(PATH,TMPFILE,PATHFILE)
	OPEN(67,FILE=PATHFILE,STATUS='OLD')
	ICODEPAT = 0

 7126  FORMAT(A15)
	 READ(67,7126) CODEPAT

	 IF(CODEPAT .EQ. '"POPDATA APR_11') ICODEPAT = 1
	 IF(CODEPAT(1:14) .EQ. 'POPDATA APR_11') ICODEPAT = 1

       IF(CODEPAT .EQ. '"POPDATA DEC_11') ICODEPAT = 1
       IF(CODEPAT(1:14) .EQ. 'POPDATA DEC_11') ICODEPAT = 1


	IF(ICODEPAT .EQ. 0) THEN


	 WRITE(*,3131)
	 WRITE(*,*)' THE PROGRAM STOPS.'
	 CLOSE(67)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,3131)
         WRITE(42,*)' THE PROGRAM STOPS.' 
        CLOSE(42)


	 CALL PAUSE
	 STOP


	ENDIF

	CLOSE(67)

	ENDIF

C  ABOVE ENDIF IS FOR THE  IF(IFORMT .EQ. 3)  CONDITION.


C  READ IN BOTH NSUBTOT AND NSUB AND THEN CALL
C  ROUTINE GETIPATF WHICH READS THIS PORTION OF FILE 25 TO OBTAIN
C  IPATVEC. NOTE THE 1ST ARGUMENT TELLS GETIPATF TO READ FILE 25.

C  NOTE THAT IF IERRR RETURNS AS -1, THERE IS A PROBLEM WITH THE

C  PATIENT NO. INFO IN THE FILE. IN THIS CASE, THE USER HAS ALREADY
C  BEEN INFORMED OF THE PROBLEM IN GETIPATF, SO JUST TRANSFER
C  CONTROL TO LABEL 145 ABOVE.

	 READ(25,*) NSUBTOT
	 READ(25,*) NSUB
	 CALL GETIPATF(25,NSUBTOT,NSUB,MAXSUB,IPATVEC,IERRR)
	 IF(IERRR .EQ. -1) GO TO 145


	IF(NOFIX .GT. 0) READ(25,*) (VALFIX(I),I=1,NOFIX)

	DO I=1,NVAR
	 READ(25,*) (AB(I,J),J=1,2)
	END DO

C  THE DIFFERENCES BETWEEN THE DIFFERENT ALLOWABLE VERSIONS OF THE
C  SAVED INPUT FILES (SEE ICODE ABOVE) IS ENTIRELY IN THE FOLLOWING

C  BLOCK OF READ(25, ... STMTS.
C  ACTUALLY, FOR ITBIG9.FOR, WHICH IS THE FIRST IN THE NEW SERIES
C  OF BIG IT2B PROGRAMS, ICODE WILL ALWAYS BE 1007, SO THERE ARE NO
C  DIFFERENT VERSIONS YET.

	 READ(25,*) XSIG
	 READ(25,*) NUMEQT

	 DO IEQ=1,NUMEQT
	  READ(25,*) IGAMMA(IEQ)
	  READ(25,*) C0P(IEQ),C1P(IEQ),C2P(IEQ),C3P(IEQ)
     1     ,C4P(IEQ),C5P(IEQ)
	  READ(25,*) IASS(IEQ)
	  READ(25,*) IQVAL(IEQ)
	 END DO

        READ(25,*) AFSCALAR
        IAF = 0

C  NOTE THAT AF(I), I=1,NDRUG, WILL BE SET = AFSCALAR BELOW LABEL 35
C  AFTER NDRUG IS ESTABLISHED (SINCE IAF = 0).


	 READ(25,*) TOL
	 READ(25,*) MAXIT

C  MAXIT MUST BE .LE. 40999. IF NOT, RESET IT.

	 IF(MAXIT .GT. 40999) MAXIT = 40999


	 READ(25,*) XDEV


 	 CLOSE(25)

	 GO TO 35


        ENDIF

C  THE ABOVE ENDIF IS FOR THE   IF(ICODE .EQ. 1007)  CONDITION.



	ENDIF


C  THE ENDIF ABOVE IS FOR THE  IF(INOPT .EQ. 1)  CONDITION.

 9700 CONTINUE


  444 FORMAT(A1000)
    2 FORMAT(A20)
  222 FORMAT(A3)
 2222 FORMAT(A5)

4005	WRITE(*,141)
  141   FORMAT(/' ENTER 1 IF THE PATIENT DATA INFO WILL BE SUPPLIED'/
     1'         IN A MATRIX BLOCK FORMAT; '/
     2' ENTER 2 IF THE PATIENT DATA INFO WILL BE INPUT USING A'/
     3'         WORKING COPY FORMAT: ')
	READ(*,*,ERR=4005) IFORMTT
	IF(IFORMTT .NE. 1 .AND. IFORMTT .NE. 2) GO TO 4005

C  IFORMTT MUST BE CHANGED TO BE THE SAME AS THE
C  OLD IFORMT AS FOLLOWS:
C  IFORMTT = 1 --> IFORMT = 3 --> PATIENT INFO IS INPUT VIA BLOCK FORMAT
C                                 (.CSV FILES);
C  IFORMTT = 2 --> IFORMT = 1 --> PATIENT INFO IS INPUT VIA WORKING COPY
C                                 FILES.

         IF(IFORMTT .EQ. 1) IFORMT = 3

         IF(IFORMTT .EQ. 2) IFORMT = 1



	IF(IFORMT .EQ. 3) THEN

         WRITE(*,3111)
 3111    FORMAT(/' ENTER THE NAME OF THE FILE WHICH CONTAINS ALL THE'/
     1' PATIENT DATA INFO IN BLOCK FORMAT (ENTER -99 TO SEE ALL OR A '/
     2' PART OF YOUR DIRECTORY: ')
        READ(*,2) BLOCKPAT

	IF(BLOCKPAT(1:3) .EQ. '-99') THEN
           CALL SEEDIR(PATH,NOB,BLOCKPAT,OSName,ListDir)
        ENDIF

C  CALL FULLNAME WHICH CONVERTS THE FILENAME TO PATHFILE, THE COMPLETE
C  NAME OF THE FILE, WHICH INCLUDES THE PATH (IF THE PATH IS NOT THE
C  CURRENT DIRECTORY).



     	TMPFILE = ' '
	TMPFILE = BLOCKPAT
	CALL FULLNAME(PATH,TMPFILE,PATHFILE)
	OPEN(67,FILE=PATHFILE,ERR=3120,STATUS='OLD')
	GO TO 3130

 3120   WRITE(*,5316) PATHFILE
	GO TO 4005
 3130   CONTINUE

	 ICODEPAT = 0
	 READ(67,7126) CODEPAT
	 IF(CODEPAT .EQ. '"POPDATA APR_11') ICODEPAT = 1
	 IF(CODEPAT(1:14) .EQ. 'POPDATA APR_11') ICODEPAT = 1
       IF(CODEPAT .EQ. '"POPDATA DEC_11') ICODEPAT = 1
       IF(CODEPAT(1:14) .EQ. 'POPDATA DEC_11') ICODEPAT = 1

	IF(ICODEPAT .EQ. 0) THEN
	 WRITE(*,3131)
 3131    FORMAT(//' YOUR PATIENT DATA BLOCK FORMAT FILE IS NOT FROM '/
     1' THE ALLOWABLE SET OF SUCH FILES.'//
     2' A PATIENT DATA BLOCK FORMAT FILE MUST HAVE "POPDATA XXX_XX IN'/
     3' COLUMNS 1 THROUGH 15 ON LINE 1, WHERE  XXX_XX  IS APR_11 OR A '/
     4' MORE RECENT DATE.'//)
	  CLOSE(67)
	  GO TO 4005
	ENDIF


	CLOSE(67)

	ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(IFORMT .EQ. 3)  CONDITION.


	IF(IFORMT .EQ. 1) THEN

 7505	  WRITE(*,4041)
 4041     FORMAT(/' ENTER THE 5-CHAR PREFIX FOR PATIENT FILENAMES: ')
	  READ(*,2222) PREFIX
	  WRITE(*,4043)
 4043     FORMAT(/' IF THERE IS A 3-CHAR EXTENSION FOR THE PATIENT '/
     1' FILENAMES, ENTER IT NOW; OTHERWISE, HIT CARRIAGE RETURN: ')
	  READ(*,222) EXT

C  VERIFY THAT THE USER ENTERED AT LEAST 5 CHARACTERS FOR THE PREFIX. IF
C  NOT, VERIFY THAT THIS IS NOT A MISTAKE ... BUT ALLOW SUCH A PREFIX
C  IF THE USER INSISTS -- THE RUN WILL STILL WORK PROPERLY.

	  IF(PREFIX(1:1) .EQ. ' ' .OR. PREFIX(2:2) .EQ. ' ' .OR.
     1       PREFIX(3:3) .EQ. ' ' .OR. PREFIX(4:4) .EQ. ' ' .OR.
     2       PREFIX(5:5) .EQ. ' ') THEN

      PATFIL = PREFIX//'001.'//EXT
 7500   WRITE(*,7501) PATFIL(1:12)
 7501   FORMAT(/' ARE YOUR SUBJECT FILES REALLY CALLED ',A12,' ... ?'//
     1' ENTER 1 TO REENTER YOUR SUBJECT FILENAMES; '/
     2' ENTER 0 IF THESE NAMES ARE ACCURATE: ')
	READ(*,*,ERR=7500) IOK
	IF(IOK .NE. 0 .AND. IOK .NE. 1) GO TO 7500

	IF(IOK .EQ. 1) GO TO 7505

	   ENDIF

	ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(IFORMT .EQ. 1) THEN  CONDITION.


C  CALL SUBROUTINE GETIPAT TO OBTAIN THE NO. OF SUBJECTS IN THE
C  ENTIRE DATA SET, NSUBTOT, THE NO. OF THESE SUBJECTS TO BE USED
C  IN THE CURRENT ANALYSIS, NSUB, AND THE INDICES OF THESE "ACTIVE"
C  SUBJECTS, IPATVEC(I),I=1,NSUB. NOTE THAT ISUBALL = 1 IF ALL
C  SUBJECTS ARE USED (I.E., NSUB = NSUBTOT) AND 0 OTHERWISE.


	CALL GETIPAT(NSUBTOT,NSUB,ISUBALL,MAXSUB,IPATVEC)

C  CALL SUBROUTINE GETNUMEQ, WHICH READS ONE PATIENT DATA FILE, OR THE
C  PATIENT INFO IN BLOCKPAT, TO GET THE NO. OF OUTPUT EQUATIONS
C  (NUMEQT), AND THE NO. OF DRUGS (NDRUG). THE 3RD ARGUMENT TO GETNUMEQ
C  IS 1 --> THE CALL IS FROM MAIN.

	CALL GETNUMEQ(PATH,NOB,1,IFORMT,PREFIX,EXT,BLOCKPAT,NUMEQT,NDRUG,
     1   MAXSUB,MAXNUMEQ)

C/////////////   ENTER RANDOM AND FIXED PARAMETER INFO.  ///////////////
C///////////////////////////  BELOW  ///////////////////////////////////


C  THIS CODE IS SIMILAR IN MAIN AND VERIF1 -- SEE PAR_6.INP.


        WRITE(*,1117)

 1117   FORMAT(/' ENTER THE BOUNDS OF THE RANGE FOR EACH PARAMETER.'//
     1' CAUTION: IF ANY OF YOUR PARAMETERS CANNOT = 0, BE SURE TO MAKE'/
     2'		 ITS LOWER BOUNDARY A POSITIVE NUMBER, RATHER THAN 0.'/
     3' 	 (ONE SUCH EXAMPLE IS FOR VOL WHICH SHOWS UP IN THE'/
     4'		 DENOMINATOR OF THE OUTPUT EQUATION IN THE MODEL'/
     5'		 FILE.)'//)

	DO 6060 I=1,NVAR

	WRITE(*,34) PAR(I)

   34   FORMAT(/' ',A11,' : ')

 7110   READ(*,*,ERR=7115) (AB(I,J),J=1,2)
	GO TO 6060
 7115   WRITE(*,7116)
 7116   FORMAT(/' SEE ABOVE; PLEASE ENTER TWO REAL NUMBERS: ')

	GO TO 7110

 6060   CONTINUE


C  ENTER THE FIXED VALUES FOR THE PARAMETERS.

	IF(NOFIX .GT. 0) THEN

     	  WRITE(*,4836)

 4836     FORMAT(/' ENTER THE VALUE FOR EACH FIXED PARAMETER: ')

	 DO 4855 I=1,NOFIX
	  WRITE(*,34) PARFIX(I)
 4840     READ(*,*,ERR=4845) VALFIX(I)
	  GO TO 4855
 4845     WRITE(*,4841)
 4841     FORMAT(/' SEE ABOVE; ENTER A POSITIVE VALUE: ')
	  GO TO 4840
 4855    CONTINUE

	ENDIF


C  ENTER THE RANFIX VALUES FOR THE PARAMETERS.

      IF(NRANFIX .GT. 0) THEN

     	  WRITE(*,5836)
 5836   FORMAT(/' ENTER THE INITIAL EST. FOR EACH RANFIX PARAMETER: ')
        DO 5855 I=1,NRANFIX
        WRITE(*,34) PARRANFIX(I)
 5840   READ(*,*,ERR=5845) RANFIXEST(I)
        GO TO 5855
 5845   WRITE(*,4841)
        GO TO 5840
 5855   CONTINUE

      ENDIF



C  IN PAR_6.INP, THE IVER STUFF IS NOT USED. THE USER CODES EXPLICITLY

C  INTO SUBROUTINE SYMBOL WHICH DESCRIPTOR(S) IS (ARE) TO BE

C  USED WITH THE RANDOM VARIABLES.




C/////////////   ENTER RANDOM AND FIXED PARAMETER INFO.  ///////////////
C///////////////////////////  ABOVE  ///////////////////////////////////



 4990	WRITE(*,4991)
 4991   FORMAT(//' THE DEFAULT S.D. FOR EACH PARAMETER IS HALF ITS'/
     1' RANGE (.5 x RANGE).'//
     2' ENTER 1 IF THIS IS O.K.;'/
     3' ENTER 0 TO CHANGE THE VALUE FROM .5 TO SOMETHING ELSE: ')

	READ(*,*,ERR=4990) ICH
	IF(ICH .NE. 0 .AND. ICH .NE. 1) GO TO 4990

	IF(ICH .EQ. 1) XSIG = .5D0


	IF(ICH .EQ. 0) THEN

 4995	WRITE(*,*)' ENTER THE NEW VALUE (TYPICALLY BETWEEN .1 AND 10): '
	READ(*,*,ERR=4995) XSIG

	IF(XSIG .LE. 0.D0) THEN
	  WRITE(*,*) 'THIS NUMBER MUST BE POSITIVE.'
	  GO TO 4995
	ENDIF

	ENDIF


        WRITE(*,19) NUMEQT
   19 FORMAT(//' THE ASSAY ERROR FUNCTION FOR EACH OF THE ',I2,' OUTPUT'
     1/
     2' EQUATION(S) IS MODELED AS FOLLOWS:'//
     2' ASSAY S.D. = GAMMA*(C0 + C1*Y + C2*Y**2 + C3*Y**3).'//
     3' FOR EACH OF THE OUTPUT EQUATIONS, YOU MAY ENTER EITHER: '//
     6'     ONE SET TO BE USED FOR ALL PATIENTS, OR'//
     4'     A UNIQUE SET OF COEFFICIENTS, [C0,C1,C2,C3] FOR EACH PATIENT
     5.'//
     6' IN THE FORMER CASE, YOU MAY ALSO HAVE A PRELIMINARY'/
     7' PROGRAM FIND AN OPTIMUM SET OF COEFFICIENTS, BASED ON YOUR '/
     8' INITIAL ESTIMATES, THE PATIENT DATA FILES, AND YOUR INPUT'/
     9' INSTRUCTIONS.'//
     9' IN EITHER CASE, YOU MAY CHOOSE WHETHER OR NOT TO HAVE THE MAIN'/
     1' PROGRAM GIVE AN UPDATED ESTIMATE FOR GAMMA.'//
     3' MAKE YOUR SELECTIONS FOR EACH OUTPUT EQUATION, IN TURN: '/)
	CALL PAUSE

C  FOR EACH OUTPUT, INPUT IUNIQ, IGAMMA, IASS AND [C0P,...,C3P].

	DO 2120 IEQ = 1,NUMEQT

        WRITE(*,311) IEQ
  311   FORMAT(//' FOR OUTPUT EQUATION ',I1,': '//)

  310   WRITE(*,312)
  312 FORMAT(/' ENTER 1 TO USE ONE SET OF COEFFICIENTS FOR ALL PATIENTS;
     1'/

     4' ENTER 0 IF EACH PATIENT WILL HAVE A UNIQUE SET OF COEFFICIENTS:
     5 ')
	READ(*,*,ERR=310) IUNIQ(IEQ)
	IF(IUNIQ(IEQ) .NE. 0 .AND. IUNIQ(IEQ) .NE. 1) GO TO 310

	IF(IUNIQ(IEQ) .EQ. 1) THEN

 5015   WRITE(*,1124)
 1124   FORMAT(/' ENTER 1 IF THE ASSAY COEFFICIENTS ARE NOT TO BE ESTIMA
     1TED, AND'/

     1'         GAMMA IS TO REMAIN FIXED AT 1.0;'//
     6' ENTER 2 IF THE ASSAY COEFFICIENTS ARE NOT TO BE ESTIMATED, BUT'/
     7'		GAMMA IS TO BE ESTIMATED;'//
     2' ENTER 3 IF YOU HAVE NO IDEA ABOUT YOUR ASSAY ERROR AND WOULD'/
     3'         LIKE A PRELIMINARY PROGRAM FIRST TO FIND ESTIMATES FOR'/
     4'         [C0,C1,C2,C3], GIVEN YOUR INITIAL ESTIMATES, PATIENT DAT
     5A FILES, AND'/
     6'         INPUT INSTRUCTIONS: ')


	READ(*,*,ERR=5015) IGAM
	IF(IGAM .LT. 1 .OR. IGAM .GT. 3) GO TO 5015

C  CHANGE IGAM TO IGAMMA, AND UPDATE IQVAL IF NECESSARY.


	IF(IGAM .EQ. 1) IGAMMA(IEQ) = 1
	IF(IGAM .EQ. 3) IGAMMA(IEQ) = 2

	IF(IGAM .EQ. 2) THEN
	 IGAMMA(IEQ) = 0
	 IQVAL(IEQ) = 1
	ENDIF

C  IN THIS CASE (IUNIQ(IEQ)=1), THE USER MUST ENTER ONE SET OF C'S
C  BELOW TO BE USED FOR ALL PATIENTS (IF IGAMMA(IEQ)=2, THESE WILL BE
C  INITIAL ESTIMATES ONLY). SO SET IASS(IEQ) = 2.

	IASS(IEQ) = 2

	ENDIF



	IF(IUNIQ(IEQ) .EQ. 0) THEN

 7015   WRITE(*,1126)
 1126   FORMAT(/' ENTER 1 IF GAMMA IS TO REMAIN FIXED AT 1.0;'/
     6' ENTER 2 IF AN UPDATED ESTIMATE OF GAMMA IS TO BE FOUND: ')
	READ(*,*,ERR=7015) IGAM
	IF(IGAM .LT. 1 .OR. IGAM .GT. 2) GO TO 7015


C  CHANGE IGAM TO IGAMMA, AND UPDATE IQVAL IF NECESSARY.

	IF(IGAM .EQ. 1) IGAMMA(IEQ) = 1

	IF(IGAM .EQ. 2) THEN
	 IGAMMA(IEQ) = 0
	 IQVAL(IEQ) = 1

	ENDIF

 1120	WRITE(*,119)
  119 FORMAT(//' SELECT ONE OF THE FOLLOWING OPTIONS FOR THE ASSAY '/
     1'		COEFFICIENTS [C0,C1,C2,C3]: '//
     4' ENTER 1 FOR THE DEFAULT OPTION ...'/
     5'         FOR EACH PATIENT, IF THE DATA FILE ALREADY INCLUDES '/
     6'	    ASSAY COEFFICIENTS, THOSE COEFFICIENTS WILL BE USED. '/
     7'	    OTHERWISE THE COEFFICIENTS YOU ENTER BELOW WILL BE '/
     8'         USED;'/
     7' ENTER 0 IF YOU WOULD LIKE TO BE PROMPTED SO YOU MAY CHOOSE THE'/
     8'	    ASSAY COEFFICIENTS ON A PATIENT - BY - PATIENT BASIS.'/
     9'         YOU MAY CHOOSE GENERAL VALUES (WHICH YOU WILL ENTER '/
     1'	    BELOW), COEFFICIENTS ALREADY IN THE PATIENT DATA FILE,'/
     2'	    IF ANY, OR ANY OTHER INDIVIDUAL COEFFICIENTS: ')
	READ(*,*,ERR=1120) IASS(IEQ)
	IF(IASS(IEQ) .NE. 0 .AND. IASS(IEQ) .NE. 1) GO TO 1120

	ENDIF


 1140	WRITE(*,1119)
 1119   FORMAT(/' ENTER THE GENERAL VALUES FOR [C0,C1,C2,C3]. THESE ')
	IF(IASS(IEQ) .EQ. 1) WRITE(*,1121)
	IF(IASS(IEQ) .EQ. 2 .AND. IGAMMA(IEQ) .NE. 2) WRITE(*,1122)
	IF(IASS(IEQ) .EQ. 2 .AND. IGAMMA(IEQ) .EQ. 2) WRITE(*,1127)
	IF(IASS(IEQ) .EQ. 0) WRITE(*,1123)
 1121   FORMAT(' WILL BE USED FOR ALL PATIENTS WHOSE DATA FILES DO '/
     1' NOT ALREADY INCLUDE ASSAY COEFFICIENTS: ')
 1122   FORMAT(' WILL BE USED FOR ALL PATIENTS.'//
     1' NOTE: IF YOU WANT TO ENTER THESE VALUES VIA AN OUTPUT FILE FROM
     2A'/
     2' PREVIOUS RUNNING OF THE PROGRAM assbigxx.exe, '/
     3' ENTER THE WORD "FILE": ')

 1123   FORMAT(' WILL BE USED FOR THOSE PATIENTS YOU SELECT BELOW: ')
 1127   FORMAT(' WILL BE INITIAL ESTIMATES ONLY. AN OPTIMUM SET WILL '/
     1' BE CALCULATED BY A PRELIMINARY PROGRAM, '/
     2' assbigxx.exe, FROM THESE ESTIMATES. A TYPICAL INITIAL GUESS'/
     3' IS [.1,.1,.05,.001]:  ')


	IF(IASS(IEQ) .NE. 2 .OR. IGAMMA(IEQ) .EQ. 2) THEN
	 READ(*,*,ERR=1140) C0P(IEQ),C1P(IEQ),C2P(IEQ),C3P(IEQ)
     1     ,C4P(IEQ),C5P(IEQ)
	ENDIF

	IF(IASS(IEQ) .EQ. 2 .AND. IGAMMA(IEQ) .NE. 2) THEN

	 READ(*,*,ERR=1145) C0P(IEQ),C1P(IEQ),C2P(IEQ),C3P(IEQ)
     1     ,C4P(IEQ),C5P(IEQ)
	 GO TO 2120

 1145    WRITE(*,1131)
 1131    FORMAT(/' ENTER THE NAME OF THE OUTPUT FILE (FROM '/

     1' assbigxx.exe); IT WILL BE   ASSxxxx   WHERE xxxx IS THE'/
     2' 4-DIGIT NUMBER ASSIGNED TO THAT RUN;'/
     1'   ENTER -99 TO SEE ALL OR A PART OF YOUR DIRECTORY: ' )

          READ(*,2) FILASS
	  IF(FILASS(1:3) .EQ. '-99') THEN
             CALL SEEDIR(PATH,NOB,FILASS,OSName,ListDir)
          ENDIF

C  CALL FULLNAME WHICH CONVERTS THE FILENAME TO PATHFILE, THE COMPLETE
C  NAME OF THE FILE, WHICH INCLUDES THE PATH (IF THE PATH IS NOT THE
C  CURRENT DIRECTORY).

     	  TMPFILE = ' '
	  TMPFILE = FILASS
	  CALL FULLNAME(PATH,TMPFILE,PATHFILE)
     	  OPEN(26,FILE=PATHFILE,ERR=1155,STATUS='OLD',POSITION='APPEND')
	  GO TO 1150
 1155     WRITE(*,5316) PATHFILE
	  GO TO 1140

C  FILASS HAS BEEN OPENED AT THE END OF THE FILE. BACKSPACE AND READ IN
C  THE C'S FOR OUTPUT EQUATION IEQ. ALSO, UPDATE IQVAL(IEQ).

 1150	  BACKSPACE(26)
	  BACKSPACE(26)
	  READ(26,444) READLINE
	  IF(READLINE(2:18) .NE. 'ESTIMATES FOR [C0') GO TO 1150
	  IF(IEQ .EQ. 1) GO TO 2155

	  DO I=1,IEQ-1
	   READ(26,*)
	  END DO

 2155	  READ(26,*) C0P(IEQ),C1P(IEQ),C2P(IEQ),C3P(IEQ)
     1     ,C4P(IEQ),C5P(IEQ)
	  CLOSE(26)

	  IQVAL(IEQ) = 4


	ENDIF

C THE ABOVE ENDIF IS FOR THE
C   IF(IASS(IEQ) .EQ. 2 .AND. IGAMMA(IEQ) .NE. 2)  CONDITION.

 2120   CONTINUE

 2119 FORMAT(//' NOTE: DURING THIS PREPARATION PROGRAM, EACH SUBJECT'/
     1'       WILL HAVE HIS/HER ASSAY COEFFICIENTS WRITTEN TO THE END'/
     2'       OF HIS/HER WORKING COPY PATIENT FILE. IF COEFFICIENTS '/
     3'       ARE ALREADY THERE FROM A PREVIOUS RUN, THEY WILL BE '/
     4'       OVERWRITTEN.'//)


        CALL PAUSE

4150   WRITE(*,129)
  129   FORMAT(//' ENTER THE ACTIVE (SALT) FRACTION OF EACH DRUG. AS '/
     1' AN EXAMPLE, THE A.F. OF THEOPHYLLINE IS 1.0, WHILE THAT OF'/
     2' AMINOPHYLLINE IS TYPICALLY BETWEEN .79 AND .85, DEPENDING ON'/
     3' THE PREPARATION. '//
     4' EACH AF MUST BE A POSITIVE NUMBER LESS THAN OR EQUAL TO 1.0.'/)
       
        DO I = 1,NDRUG
         WRITE(*,1129) I
 1129    FORMAT(' AF FOR DRUG ',I1,': ')
         READ(*,*,ERR=4150) AF(I)
         IF(AF(I) .LE. 0.0 .OR. AF(I) .GT. 1.0) GO TO 4150
        END DO

        IAF = 1


C  IF THERE IS AT LEAST ONE OUTPUT EQUATION, IEQ, WITH IGAMMA(IEQ) = 2,
C  THEN THE PRELIMINARY PROGRAM, assbigxx.exe, WILL BE RUN
C  (IRUNIT = 0 BELOW). NOTE THAT assbigxx.exe HAS NOT BEEN UPDATED
C  YET TO BE AT THE LEVEL OF itbig9x.exe (SEE BELOW).


C  IF NO IGAMMA(IEQ) = 2, THEN THE ANALYSIS PROGRAM,
C  itbig9x.exe WILL BE RUN (IRUNIT = 1 BELOW). NOTE THAT THE NAME
C  OF THE "ENGINE" PROGRAM IS itbig9x.exe ON A PC (CURRENTLY - FOR THE
C  PC PREP PROGRAM, ITBIG9.FOR).

	IRUNIT = 1
	DO IEQ=1,NUMEQT
	 IF(IGAMMA(IEQ) .EQ. 2) IRUNIT = 0

	END DO

	IF(IRUNIT .EQ. 1) THEN

        WRITE(*,26)
   26   FORMAT(/' ENTER THE CONVERGENCE CRITERION (USUALLY  .001).'/
     1' THE PROGRAM WILL STOP THE ITERATIONS WHEN THE AVERAGE'/
     2' LOG-LIKELIHOOD OF THE PARAMETER ESTIMATES, GIVEN THE DATA AND '/
     3' THE CURRENT ESTIMATES OF THE POPULATION MEAN VECTOR AND '/
     4' COVARIANCE MATRIX, DIFFERS BY LESS THAN THIS VALUE FROM THE'/
     5' PREVIOUS ITERATION: ')

 4185   READ(*,*,ERR=4190) TOL
        GO TO 4195
 4190   WRITE(*,*) ' SEE ABOVE; PLEASE ENTER A REAL NUMBER: '
        GO TO 4185

 4195   MMAXIT = 40999
        WRITE(*,123) MMAXIT+1
  123   FORMAT(/' ENTER THE MAX NO. OF ITERATIONS DESIRED (LESS THAN ',I
     15,'): ')
        READ(*,*,ERR=4195) MAXIT
        IF(MAXIT .LE. 0 .OR. MAXIT .GT. 40999) GO TO 4195

 4215   WRITE(*,4986)


 4986   FORMAT(//' THE RANGES, OF THE PARAMETERS TO BE SUPPLIED '/
     1' TO THE 2ND PART (NPEM2) OF THIS PROGRAM, WILL BE SOME NUMBER'/
     2' OF S.D. (5 IS A TYPICAL CHOICE)  ABOVE AND BELOW EACH '/
     3' POPULATION MEAN (BUT THE LOWER RANGE VALUE MAY NOT BE LESS'/
     4' THAN .00000001). HOW MANY S.D. ABOVE AND BELOW THE MEANS DO '/
     5' YOU WANT THE PARAMETER RANGES TO BE ?'/
     5' ENTER THE NUMBER: ')

	READ(*,*,ERR=4215) XDEV

	IF(XDEV .LE. 0.D0) THEN
	  WRITE(*,*)' THIS NUMBER MUST BE POSITIVE.'
	  GO TO 4215
	ENDIF

	ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(IRUNIT .EQ. 1)  CONDITION.

C  IF IRUNIT = 0, PUT IN DEFAULT VALUES FOR TOL, MAXIT, AND XDEV IN
C  CASE THE USER SAVES INSTRUCTION INFO TO A FILE (SO IF THE USER USES
C  THAT INSTRUCTION FILE, TOL, MAXIT, AND XDEV WILL NOT BE 0).

	IF(IRUNIT .EQ. 0) THEN
	 TOL = 1.D-3
	 MAXIT = 10
	 XDEV = 5.D0
	ENDIF


   35   CONTINUE

C  IF INOPT .EQ. 1, AND ICODE .LT. 1107, IT MEANS THAT AFSCALAR WAS READ
C  IN, BUT ALL THE AF(I), I=1,NDRUG, HAVE NOT YET BEEN SET = AFSCALAR,
C  SINCE NDRUG WAS NOT AVAILABLE AT THE TIME. IN THIS CASE, IAF WAS SET
C  = 0 ABOVE ... SO GETNUMEQ WOULD NOW BE CALLED TO ESTABLISH NDRUG,
C  AND THEN ALL AF(I) WOULD BE SET = AFSCALAR.

C  NOTE THAT SUBROUTINE GETNUMEQ READS ONE PATIENT DATA FILE, OR THE
C  PATIENT INFO IN BLOCKPAT, TO GET THE NO. OF OUTPUT EQUATIONS

C  (NUMEQT), AND THE NO. OF DRUGS (NDRUG). THE 3RD ARGUMENT TO GETNUMEQ
C  IS 1 --> THE CALL IS FROM MAIN.

        IF(IAF .EQ. 0) THEN

         CALL GETNUMEQ(PATH,NOB,1,IFORMT,PREFIX,EXT,BLOCKPAT,NUMEQT,
     1    NDRUG,MAXSUB,MAXNUMEQ)

          DO I = 1,NDRUG
           AF(I) = AFSCALAR
          END DO         

         ENDIF

 1230   CONTINUE
C  1230 IS THE LABEL TO WHICH CONTROL IS TRANSFERRED IF THE USER
C  ENTERED INFO USING THE IALLIN = 1 OPTION ABOVE.


C  PRINT TO THE SCREEN ALL INPUT INFO FOR VERIFICATION IF IVERIFY = 1.

      IF(IVERIFY .EQ. 1)

     1 CALL VERIF1(PREFIX,EXT,IFORMT,NSUB,NSUBTOT,
     1  PAR,NVAR,AB,C0P,C1P,C2P,C3P,C4P,C5P,IASS,AF,NOFIX,VALFIX,PARFIX,
     2  TOL,MAXIT,XDEV,XSIG,IGAMMA,IQVAL,NUMEQT,IUNIQ,PATH,NOB,BLOCKPAT,
     3  ISUBALL,MAXSUB,IPATVEC,NDRUG,TOLER,NDIM,RTOL,ATOL,
     4  OSName,ListDir,IRAN,MAXNUMEQ,NRANFIX,PARRANFIX,
     6  RANFIXEST)


C  IF IFORMT = 1, THE PATIENT DATA FILES ARE READY TO
C  BE READ IN BY THE PROGRAM (THEY ARE ALREADY IN WORKING COPY FORMAT).
C  IF IFORMT = 3, THE PATIENT DATA INFO IS IN FILE BLOCKPAT, IN
C  BLOCK FORMAT, AND MUST NOW BE CONVERTED INTO WORKING COPY PATIENT
C  FORMAT.

	IF(IFORMT .EQ. 3) THEN


C  AS OF IT2B109.FOR:
C  CHECK TO SEE IF THERE ARE NSUBTOT FILES, XQZPJ001.ZMQ,... IN THE
C  WORKING DIRECTORY. IF NOT, CONTINUE AS ALWAYS. BUT IF SO, THESE
C  MAY BE WORKING COPY FILES ALREADY CREATED FROM THE .csv FILE INPUT
C  ABOVE INTO BLOCKPAT. AND IN THIS CASE, CHECK WITH THE USER TO SEE IF
C  THE PROGRAM CAN SIMPLY USE THESE FILES, RATHER THAN CREATING THEM
C  AGAIN FROM THE .csv FILE (WHICH CAN TAKE A LOT OF TIME IF THERE IS A
C  LARGE PATIENT POPULATION).

      DO ISUB = 1,NSUBTOT

       PATFIL="XQZPJ"//NUMBER(ISUB)//'.ZMQ'

C  CALL FULLNAME WHICH CONVERTS THE FILENAME TO PATHFILE, THE COMPLETE
C  NAME OF THE FILE, WHICH INCLUDES THE PATH (IF THE PATH IS NOT THE
C  CURRENT DIRECTORY).

       TMPFILE = ' '
       TMPFILE = PATFIL
       CALL FULLNAME(PATH,TMPFILE,PATHFILE)
       OPEN(81,FILE=PATHFILE,ERR=7770,STATUS='OLD')
       CLOSE(81)


      END DO

C  THE ABOVE END DO IS FOR THE  DO ISUB = 1,NSUBTOT  LOOP.

C  TO GET TO THIS POINT MEANS THAT NSUBTOT WORKING COPY FILES,
C  XQZPJ001.ZMQ,... EXIST IN THE WORKING DIRECTORY. SO ASK THE USER IF
C  THESE ARE, INDEED, WORKING COPY FILES CREATED FROM HIS .csv FILE. IF
C  SO, THE PROGRAM CAN USE THEM RATHER THAN RECREATE THEM FROM THE .csv
C  FILE.

C  BUT DON'T DO THIS IF IALLIN = 1 AND IVERIFY = 0, BECAUSE IN THIS
C  CASE THE PROGRAM IS TO RUN WITHOUT ANY MORE USER INTERACTION. IN THIS
C  CASE, MUST TAKE THE SAFE ROUTE AND PROCEED AS IF ILONG = 1.

      IF(IALLIN .EQ. 1 .AND. IVERIFY .EQ. 0) GO TO 7770

 7780 WRITE(*,7771) NSUBTOT,BLOCKPAT,BLOCKPAT,BLOCKPAT,BLOCKPAT
 7771 FORMAT(//' THERE ARE ALREADY ',I6,' WORKING COPY FILES BY THE '/
     1' NAMES OF XQZPJ001.ZMQ,... IN THE CURRENT WORKING DIRECTORY.'//
     2' IF THESE WERE THE ONES CREATED BY THE PROGRAM FROM A PREVIOUS'/
     3' RUN WITH YOUR .csv FILE, ',A20,' YOU CAN SIMPLY USE THEM '/
     4' AGAIN, RATHER THAN RECREATE THEM FROM ',A20//
     5' THIS COULD SAVE A LOT OF TIME IF YOU HAVE A LARGE PATIENT '/
     6' POPULATION. OF COURSE IF THESE WORKING COPY FILES DID NOT COME'/
     7' FROM ',A20,' ENTER 1 BELOW.'//
     8' ENTER 1 TO CREATE ANOTHER SET OF WORKING COPY FILES FROM YOUR'/
     9'         .csv FILE, ',A20/
     1' ENTER 0 TO SAVE TIME BY USING THE XQZPJ001.ZMQ,... FILES WHICH'/
     2'         ALREADY EXIST IN YOUR WORKING DIRECTORY: ')
      READ(*,*,ERR=7780) ILONG
      IF(ILONG .NE. 1 .AND. ILONG .NE. 0) GO TO 7780

C  IF ILONG = 1, SIMPLY CONTINUE, AND RECREATE THE XQZPJ001.ZMQ FILES
C  AGAIN. IF ILONG = 0, GO TO 7790, WHICH SKIPS THE REST OF THIS
C  IF(IFORMT .EQ. 3)  SECTION, SINCE THE XQZPJ001.ZMQ FILES WHICH
C  ALREADY EXIST ARE GOING TO BE USED.

      IF(ILONG .EQ. 0) GO TO 7790
          

 7770  CONTINUE

C  TO GET TO THIS POINT MEANS THAT AT LEAST ONE OF THE NSUBTOT WORKING 
C  COPY FILES, XQZPJ001.ZMQ,..., DOES NOT EXIST, OR IALLIN = 1 AND
C  IVERIFY = 0 (WHICH MEANS THAT THE XQZPJ001.ZMQ FILES ARE BEING
C  RECREATED JUST TO BE SAFE), OR USER CHOSE ILONG = 1 ABOVE, AGAIN
C  TO BE SAFE. IN THIS CASE, SIMPLY CONTINUE, LEAVING IFORMT = 3.


C  CALL SUBROUTINE READBLOCK TO READ ALL PATIENT DATA INFO FROM FILE,
C  BLOCKPAT, AND CONVERT IT INTO NSUBTOT WORKING COPY PATIENT DATA
C  FILES. FIRST OPEN BLOCKPAT AS FILE 87. NOTE THAT THE 1ST ARGUMENT
C  TO READBLOCK --> CALL IS FROM MAIN.

        TMPFILE = ' '
        TMPFILE = BLOCKPAT

        CALL FULLNAME(PATH,TMPFILE,PATHFILE)
        OPEN(87,FILE=PATHFILE,STATUS='OLD')

C  AS OF IT2B103.FOR, BEFORE CALLING NEWCSV, MUST CALL CONVERTCSV,
C  WHICH CONVERTS A "EUROPEAN" .CSV FILE TO THE TYPICAL "AMERICAN"
C  VERSION. IF THE .CSV FILE IS ALREADY IN THE "AMERICAN" FORMAT,
C  CONVERTCSV SIMPLY REWRITES FILE 87 TO SCRATCH FILE 77. NOTE THAT
C  NEWCSV CONVERTS FILE 77 TO FILE 67.

        CALL CONVERTCSV

C  CALL SUBROUTINE NEWCSV WHICH CONVERTS THE .CSV FILE IN FILE 77 TO
C  A NEW .CSV FILE IN FILE 67, WITH ALL MISSING VALUE DOTS CHANGED TO
C  n's. THEN CALL CSVCHANGE WHICH CHANGES .csv FILES WITH CODE OF
C  POPDATA DEC_11 (I.E., THOSE WITH 2 EXTRA COLUMNS FOR ADDL AND II)
C  TO EQUIVALENT .csv FILES WITH CODE OF POPDATA APR_11 (THOSE WITHOUT
C  THE TWO EXTRA COLUMNS). CSVCHANGE READS FILE 67, AND WRITES THE 
C  INFORMATION TO SCRATCH FILE 66. NOTE THAT IF THE .csv FILE READ IN
C  ALREADY IS THE OLDER VERSION (WITH CODE POPDATA APR_11), CSVCHANGE
C  SIMPLY REWRITES IT TO FILE 66, WHICH IS THEN READ BY SUBROUTINE
C  READBLOCK.


        OPEN(67)

C        WRITE(*,1234)
C1234   FORMAT(/' IF YOU HAVE A LARGE DATA SET, THERE COULD BE A LONG'/
C    1' DELAY (SEVERAL SECONDS TO A MINUTE OR MORE) BEFORE YOU SEE AN'/
C    2' INDICATION THAT THE PROGRAM IS EXAMINING YOUR PATIENT DATA. '//

C    3' THE PROGRAM HAS NOT "HUNG". THIS MIGHT BE A GOOD TIME FOR SOME'/
C    4' QUIET INTROSPECTION ... ')



        CALL NEWCSV
        CALL CSVCHANGE
        REWIND(66)
        CALL READBLOCK(1,NSUBR,MAXSUB,NOUT,NDRUG,PATH,C0P,C1P,C2P,C3P,
     1   C4P,C5P,MAXNUMEQ)

        CLOSE(66)

C  READBLOCK HAS NOW CONVERTED THE BLOCKPAT FILE INFO INTO NSUBR
C  WORKING COPY PATIENT DATA FILES, WITH THE NAMES,
C  XQZPJ001.ZMQ, XQZPJ002.ZMQ.


C  NOTE THAT NSUBTOT AND NSUB HAVE ALREADY BEEN READ IN ABOVE, SO THERE
C  MUST BE COMPATIBILITY WITH THOSE VALUES AND THE NO. OF PATIENTS IN

C  THE BLOCK FORMAT - I.E., NSUBTOT SHOULD BE THE SAME AS THE NO. OF
C  PATIENTS IN THE BLOCK FORMAT, NSUBR. IF THIS IS NOT TRUE, INFORM

C  THE USER AND STOP.


        IF(NSUBTOT .NE. NSUBR) THEN


         WRITE(*,1011) NSUBTOT,BLOCKPAT,NSUBR
 1011    FORMAT(/' THE NO. OF TOTAL SUBJECTS IN YOUR PATIENT DATA'/
     1' SET WAS READ IN AS ',I4,' BUT THE NO. OF SUBJECTS IN YOUR'/
     2' BLOCK PATIENT DATA FILE, ',A20,' IS ',I4,'. THESE NUMBERS'/
     3' MUST BE THE SAME. PLEASE CHECK YOUR PATIENT DATA AND RERUN'/
     4' THIS PROGRAM.'/)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,1011) NSUBTOT,BLOCKPAT,NSUBR 
        CLOSE(42)


         CALL PAUSE
         STOP
        ENDIF


	ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(IFORMT .EQ. 3)  CONDITION.

 7790 CONTINUE


C  GO THROUGH ALL NSUB SUBJECTS AND MAKE SURE ALL FILES HAVE THE DESIRED
C  ASSAY COEFFICENTS AT THE END OF THEIR WORKING COPY FILES. IF THEY
C  DON'T, PUT THEM THERE.

	WRITE(*,2401)
 2401   FORMAT(//' EXAMINING ALL WORKING COPY PATIENT DATA FILES TO'/
     1' MAKE SURE THEY ALL HAVE THE APPROPRIATE ASSAY COEFFICIENTS '/
     2' WRITTEN TO THEIR FILES ... '/)

C  INITIALIZE NCSTORE(IEQ) = 0. DURING THE DO LOOP, NCSTORE(IEQ) IS
C  THE RUNNING NO. OF EXTRA SETS OF GENERAL COEFFICIENTS THAT THE USER
C  HAS CHOSEN TO SAVE IN GENCOEF(IEQ,.,.) FOR ASSIGNMENT TO SUBSEQUENT
C  PATIENT DATA FILES, FOR OUTPUT EQ. IEQ.

	DO I=1,NUMEQT
	 NCSTORE(IEQ) = 0
	END DO

	DO ISUB=1,NSUBTOT

       WRITE(*,8889) ISUB
 8889  FORMAT(' SUBJECT NO. ',I6)

C  CALL SUBROUTINE PUTASS TO MAKE SURE THAT ALL THE WORKING COPY PATIENT
C  FILES HAVE ASSAY COEFFICIENTS WRITTEN AT THE END OF THEM.

        IF(IFORMT .EQ. 1) PATFIL=PREFIX//NUMBER(ISUB)//'.'//EXT
        IF(IFORMT .EQ. 3) PATFIL="XQZPJ"//NUMBER(ISUB)//'.ZMQ'

C  CALL FULLNAME WHICH CONVERTS THE FILENAME TO PATHFILE, THE COMPLETE
C  NAME OF THE FILE, WHICH INCLUDES THE PATH (IF THE PATH IS NOT THE
C  CURRENT DIRECTORY).

      TMPFILE = ' '
	TMPFILE = PATFIL
	CALL FULLNAME(PATH,TMPFILE,PATHFILE)
      CALL PUTASS(PATHFILE,IASS,C0P,C1P,C2P,C3P,C4P,C5P,NUMEQT,GENCOEF,
     1  NCSTORE,MAXNUMEQ)

	END DO


      IF(IVERIFY .EQ. 1) THEN 

C  GIVE USER OPTION TO SAVE INPUT DATA TO AN INPUT FILE (FOR ANOTHER
C  RUNNING OF THE PROGRAM).


	  WRITE(*,4601)
 4601   FORMAT(//' ENTER 1 TO SAVE THE INSTRUCTIONS FOR THIS RUN INTO'/
     1'		A FILE;'/
     1' ENTER 0 OTHERWISE: ')
 4605   READ(*,*,ERR=4610) ISAVFL
	  GO TO 4615
 4610   WRITE(*,4035)
 4035   FORMAT(/' SEE ABOVE; PLEASE ENTER 0 OR 1: ')


	  GO TO 4605

 4615	  IF (ISAVFL .NE. 0 .AND. ISAVFL .NE. 1) THEN
	   WRITE(*,138)
	   GO TO 4605
	  ENDIF


        IF(ISAVFL .EQ. 1) THEN

 1960	  WRITE(*,4616)
 4616	  FORMAT(/' ENTER THE DESIRED FILENAME: ')
	  READ(*,2) SAVFIL

C  CALL FULLNAME WHICH CONVERTS THE FILENAME TO PATHFILE, THE COMPLETE
C  NAME OF THE FILE, WHICH INCLUDES THE PATH (IF THE PATH IS NOT THE
C  CURRENT DIRECTORY).

     	  TMPFILE = ' '
	  TMPFILE = SAVFIL
	  CALL FULLNAME(PATH,TMPFILE,PATHFILE)
        OPEN(24,FILE=PATHFILE,ERR=1970,STATUS='NEW')
	  GO TO 1975
 1970   WRITE(*,9826) PATHFILE
 9826   FORMAT(/' THE FOLLOWING FILE ALREADY EXISTS ....'/
     1'    ',A73/
     1' ENTER 0 TO ENTER A NEW FILENAME;'/
     2' ENTER 1 TO OVERWRITE THIS FILE: ')
	READ(*,*,ERR=1970) IFILE
	IF(IFILE .NE. 0 .AND. IFILE .NE. 1) GO TO 1970
	IF(IFILE .EQ. 0) GO TO 1960
	IF(IFILE .EQ. 1) OPEN(24,FILE=PATHFILE)
 1975   CONTINUE


        WRITE(24,7123) 'REM_FRN MAR_16'

C  THE FIRST ENTRY IS IVERIFY. IF IVERIFY = 0, THIS CODE WOULD BE
C  IRRELEVANT SINCE THE INSTRUCTION FILE WILL BE USED WITHOUT CHANGE.
C  SO WRITE FILE AS IF IVERIFY = 1, BECAUSE THAT'S THE ONLY CONDITION
C  IN WHICH THIS FILE WILL BE USED.

        IVERIFY = 1
        WRITE(24,9111)
 9111   FORMAT(' IVERIFY: 1 --> YES; 0 --> NO')
        WRITE(24,*) IVERIFY

        WRITE(24,9112)
 9112   FORMAT(' FORTRAN MODEL FILE')
        WRITE(24,2) FORFILE

        WRITE(24,9113)
 9113   FORMAT(' NDIM')
        WRITE(24,*) NDIM

        WRITE(24,9114)
 9114   FORMAT(' NP')
        WRITE(24,*) NP

        WRITE(24,9116)
 9116   FORMAT(' IRAN INDICES')
        WRITE(24,*) (IRAN(I),I=1,NP)

        WRITE(24,9117) 
 9117   FORMAT(' NVAR')
        WRITE(24,*) NVAR

        WRITE(24,9118)
 9118   FORMAT(' PAR(I),I=1,NVAR')
        DO I = 1,NVAR
         WRITE(24,1717) PAR(I)
        END DO
 1717   FORMAT(A11)
    
        WRITE(24,9119)
 9119   FORMAT(' AB ARRAY')
        DO I = 1,NVAR
         WRITE(24,*) (AB(I,J),J=1,2)
        END DO    

        WRITE(24,9121)
 9121   FORMAT(' NOFIX')
        WRITE(24,*) NOFIX

        WRITE(24,9122)
 9122   FORMAT(' PARFIX(I),I=1,NOFIX, IF NOFIX > 0')
        IF(NOFIX .GT. 0) THEN
         DO I = 1,NOFIX
          WRITE(24,1717) PARFIX(I)
         END DO
        ENDIF

        WRITE(24,9123)
 9123   FORMAT(' VALFIX ARRAY IF NOFIX > 0')
        IF(NOFIX .GT. 0) WRITE(24,*) (VALFIX(I),I=1,NOFIX)

        WRITE(24,9137)
 9137   FORMAT(' NRANFIX')
        WRITE(24,*) NRANFIX

        WRITE(24,9138)
 9138   FORMAT(' PARRANFIX(I),I=1,NRANFIX, IF NRANFIX > 0')
        IF(NRANFIX .GT. 0) THEN
         DO I = 1,NRANFIX
          WRITE(24,1717) PARRANFIX(I)
         END DO
        ENDIF

        WRITE(24,9139)
 9139   FORMAT(' RANFIXEST ARRAY IF NRANFIX > 0')
        IF(NRANFIX .GT. 0) WRITE(24,*) (RANFIXEST(I),I=1,NRANFIX)


        WRITE(24,9124)
 9124   FORMAT(' O.D.E. TOLERANCE')
        WRITE(24,*) TOLER

        WRITE(24,8111)
 8111   FORMAT(' IFORMT ')

        IF(IFORMT .EQ. 3) IFORMTT = 1
        IF(IFORMT .EQ. 1) IFORMTT = 2
        WRITE(24,*) IFORMTT

        IF(IFORMT .EQ. 1) THEN
         WRITE(24,8112)
 8112    FORMAT(' PREFIX')
         WRITE(24,2222) PREFIX
         WRITE(24,8113)
 8113    FORMAT(' EXT')
         WRITE(24,222) EXT
        ENDIF


        IF(IFORMT .EQ. 3) THEN

         WRITE(24,8114)
 8114    FORMAT(' BLOCKPAT')
         WRITE(24,2) BLOCKPAT

         WRITE(24,9141)
 9141    FORMAT(' NCOVA')
         WRITE(24,*) NCOVA  

         WRITE(24,9142)
 9142    FORMAT(' COVNAME(I),I=1,NCOVA, IF NCOVA > 0')
         IF(NCOVA .GT. 0) THEN
         DO I = 1,NCOVA
          WRITE(24,1717) COVNAME(I)
         END DO
        ENDIF

        WRITE(24,9143)
 9143   FORMAT(' ICOVTYPE ARRAY IF NCOVA > 0')
        IF(NCOVA .GT. 0) WRITE(24,*) (ICOVTYPE(I),I=1,NCOVA)
 
        ENDIF
C  ABOVE ENDIF IS FOR THE  IF(IFORMT .EQ. 3)  CONDITION.

        WRITE(24,8116)
 8116   FORMAT(' NSUBTOT')
        WRITE(24,*) NSUBTOT

        WRITE(24,8117)
 8117   FORMAT(' NSUB')
        WRITE(24,*) NSUB

        WRITE(24,8118)
 8118   FORMAT(' ACTIVE PATIENT NUMBERS, FOLLOWED BY A LINE WITH 0')


C  CALL SUBROUTINE WRITEPT2 TO WRITE THE PATIENT NOS. TO BE USED IN
C  THE ANALYSIS TO FILE 29 ... IN AN "EFFICIENT" WAY, AS OPPOSED TO
C  ONE INDEX PER LINE. NOTE THAT THE FIRST ARGUMENT TELLS WRITEPT2
C  TO WRITE TO FILE 29. NOTE THAT THE '    0' AFTER THE CALL TO
C  WRITEPT2 TELLS THE PROGRAM READING THIS FILE THAT THE PATIENT
C  NOS. HAVE ENDED.

        CALL WRITEPT2(24,NSUB,MAXSUB,IPATVEC)
        WRITE(24,*) '    0'

        WRITE(24,8147)
 8147   FORMAT(' XSIG')
        WRITE(24,*) XSIG

        WRITE(24,8124)
 8124   FORMAT(' NUMEQT')
        WRITE(24,*) NUMEQT

        WRITE(24,8126)
 8126   FORMAT(' NUMEQT SETS OF IGAMMA,Cs,IASS,IQVAL')

        DO IEQ=1,NUMEQT
         WRITE(24,*) IGAMMA(IEQ)
         WRITE(24,161) C0P(IEQ),C1P(IEQ),C2P(IEQ),C3P(IEQ)
     1     ,C4P(IEQ),C5P(IEQ)
         WRITE(24,*) IASS(IEQ)
         WRITE(24,*) IQVAL(IEQ)
        END DO

  161   FORMAT(4(G16.10,2X))

        WRITE(24,8136)
 8136   FORMAT(' NDRUG')
        WRITE(24,*) NDRUG

        WRITE(24,8131)
 8131   FORMAT(' AF(I),I=1,NDRUG')
        WRITE(24,*) (AF(I),I=1,NDRUG)

        WRITE(24,8134)
 8134   FORMAT(' TOL')
        WRITE(24,*) TOL

        WRITE(24,8133)
 8133   FORMAT(' MAXIT')
        WRITE(24,*) MAXIT 

        WRITE(24,8138)
 8138   FORMAT(' XDEV')
        WRITE(24,*) XDEV

        CLOSE(24)

	ENDIF
C  THE ABOVE ENDIF IS FOR THE  IF(ISAVFL .EQ. 1)  CONDITION.

      ENDIF
C  THE ABOVE ENDIF IS FOR THE  IF(IVERIFY .EQ. 1) CONDITION.



C  DETERMINE WHETHER OR NOT TO OFFER PLOTS OF S.D.(I) VS. OBS(I)
C  OVER THE ENTIRE POPULATION (FOR A GIVEN OUTPUT EQUATION). IF THERE IS
C  ANY OUTPUT EQ., IEQ, WHERE IUNIQ(IEQ) = 1, AND IGAMMA(IEQ) .NE. 2,
C  THEN PLOTS WILL BE OFFERED. THIS WILL ALSO GIVE THE USER THE
C  CHANCE TO CHANGE HIS MIND AND ESTIMATE THE C'S FOR THAT EQUATION
C  (USING THE PROGRAM, assbigxx.exe).

C  AFTER THE LOOP BELOW, ISHOW WILL BE THE NO. OF OUTPUT EQS WITH
C  IUNIQ = 1, AND IGAMMA .NE. 2. ALSO, INITIALIZE IALTER = 0 IN
C  ALL ITS NUMEQT LOCATIONS. IF ANY OF THESE ENTRIES CHANGE IN
C  THE  IF(ISHOW .GE. 1)  BLOCK OF CODE BELOW, SUBROUTINE PUTASS WILL
C  BE RECALLED TO MAKE SURE THE CORRECT ASSAY COEFFICIENTS ARE PLACED
C  INTO THE PATIENT DATA FILES.

C	ISHOW = 0
C	DO IEQ=1,NUMEQT
C	 IF(IUNIQ(IEQ) .EQ. 1 .AND. IGAMMA(IEQ) .NE. 2) ISHOW=ISHOW+1
C	 IALTER(IEQ) = 0

C	END DO

C  FOR ITBIG9.FOR, WHICH IS A NON-GRAPHICS VERSION, ALL CODE RELATED
C  TO SHOWING THE USER PLOTS OF S.D.(I) VS. OBS(I) HAS BEEN REMOVED.

C  AS OF IT2B105.FOR, THE ABOVE CODE IS COMMENTED OUT SINCE IT IS
C  NOT USED.


C  STORE ALL VALUES INTO THE INPUT FILE, INSTFILE (FILE 27), FOR THE
C  "ENGINE" (REGULAR IT2B PROGRAM OR ASSDRIV PROGRAM).

C  IF THERE IS AT LEAST ONE OUTPUT EQUATION, IEQ, WITH IGAMMA(IEQ) = 2,
C  THEN THE PRELIMINARY PROGRAM, assbigxx.exe, WILL BE RUN

C  (IRUNIT = 0 BELOW).
C  assbigxx.exe WILL GIVE "OPTIMUM" ESTIMATES FOR EACH SET OF C'S
C  WHOSE OUTPUT EQUATION HAS IGAMMA ENTRY = 2.

C  IF NO IGAMMA(IEQ) = 2, THEN THE ANALYSIS PROGRAM,
C  itbig9x.exe WILL BE RUN (IRUNIT = 1 BELOW).



C  MUST NOW GET ADDITIONAL NEEDED INFO, AND ESTABLISH DUMMY VALUES FOR
C  UNNEEDED VALUES, DEPENDING ON WHICH PROGRAM IS TO BE RUN.

	IRUNIT = 1
	DO IEQ=1,NUMEQT
	 IF(IGAMMA(IEQ) .EQ. 2) IRUNIT = 0
	END DO

	IF(IRUNIT .EQ. 0) THEN

 7070	WRITE(*,9027)


 9027 FORMAT(//' THE PROGRAM, assbigxx.exe, WILL FIND THE'/
     1' "OPTIMUM" ASSAY NOISE COEFFICIENTS FOR THE FOLLOWING:'//
     2' OUTPUT EQUATION STARTING GUESS FOR [C0,C1,C2,C3]'/)

	DO IEQ=1,NUMEQT
	 IF(IGAMMA(IEQ) .EQ. 2)
     1  WRITE(*,2403) IEQ,C0P(IEQ),C1P(IEQ),C2P(IEQ),C3P(IEQ)
     1     ,C4P(IEQ),C5P(IEQ)
 2403   FORMAT('   ',I1,3X,4(G16.10,2X))
	END DO


C  AS OF IT2B109.FOR, SKIP THE READING IN OF ITOLCS, AND DEFAULT
C  TO DOING A QUICK SEARCH, IF IVERIFY = 0.

      IF(IVERIFY .EQ. 0) THEN
       TOLCS = 1.D-2
       GO TO 2410
      ENDIF
       
  	WRITE(*,2408)
 2408   FORMAT(/' THIS WILL BE DONE USING AN ITERATIVE SEARCH.'//
     2' ENTER 1 TO DO A MEDIUM LEVEL SEARCH (TOL = .00001); '/
     1' ENTER 0 TO DO A QUICK, CURSORY, SEARCH (TOL = .01);'/
     2' ENTER 2 TO DO A MORE EXTENSIVE SEARCH (TOL = .0000000001): ')
	READ(*,*,ERR=7070) ITOLCS
	IF(ITOLCS .LT. 0 .OR. ITOLCS .GT. 2) GO TO 7070

	IF(ITOLCS .EQ. 0) TOLCS = 1.D-2
	IF(ITOLCS .EQ. 1) TOLCS = 1.D-5
	IF(ITOLCS .EQ. 2) TOLCS = 1.D-10

 2410	 TOL = 1.D-3
	 MAXIT = 1
	 XDEV = 1.D0
	 INDPTS = 1
	 ILOG = 1
	 WRITE(*,*)


	ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(IRUNIT .EQ. 0)  CONDITION.


	IF(IRUNIT .EQ. 1) THEN

	 TOLCS = .1D0

C  NO. AS OF ITBIG7, THE NO. OF GRID POINTS TO BE USED IS A MOOT
C  POINT SINCE THERE WILL BE NO GRID IN THE CALCULATION OF THE "TRUE"
C  LOG-LIKELIHOOD (IT WILL BE DONE IN A SIMPLER WAY). SO ALL CODE
C  RELATED TO NGRID WILL BE REMOVED BELOW. AND ILOG WILL BE HARDCODED TO
C  0, WHICH MEANS THE TRUE (NUMERICAL) LOG-LIKELIHOOD CALCULATIONS WILL
C  BE DONE (THERE IS NO REASON NOT TO DO THEM SINCE THEY WON'T TAKE VERY
C  LONG ANYMORE). ALSO HARDCODE NGRID TO 99999 SINCE IT IS USED AS A
C  DIMENSION IN SUBROUTINE MAKEDRIV (SINCE NGRID WILL BE RESET = NSUB
C  IN itbig7.f, 99999 IS PLENTY BIG ENOUGH, SINCE THERE WILL BE FEWER
C  THAN 99999 SUBJECTS).

	 ILOG = 0
	 NGRID = 99999

C  AS OF ITBIG10.FOR, SET INDPTS = 0. THIS IS FOR COSMETIC REASONS ONLY
C  SINCE INDPTS IS NOT USED IN the itbigxx.exe "engine". BUT SINCE
C  ITBIG10.FOR CAN BE COMPILED BY EITHER LF90 OR gfortran, AND SINCE THE
C  LATTER DOES NOT AUTOMATICALLY DEFAULT UNSET VARIABLES TO 0 (THEY CAN
C  BE SET EQUAL TO RANDOM NUMBERS), BY SETTING INDPTS = 0 --> THE VALUE
C  IN THE FILE, it2bbig5.inp (NOW CALLED it2b102.inp AS OF IT2B114.FOR)
C  WILL BE THE SAME WHETHER THIS PROGRAM IS COMPILED AND LINKED WITH
C  LF90 OR gfortran.

        INDPTS = 0



	ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(IRUNIT .EQ. 1)  CONDITION.


C  CREATE THE DRIVER PROGRAM FOR BIGIT2B (it2bdriv.f) OR
C  ASSCALC (assdriv.f), DEPENDING ON THE VALUE OF IRUNIT

        CALL MAKEDRIV(PATH,NOB,IRUNIT,FORFILE,NSUB,NVAR,NGRID,NUMEQT,
     1   MAXOBDIM,OSName,CopyFile,DeleteFile,IVERIFY)



C  STORE THE INPUT VALUES INTO THE FILE INSTFILE, WHICH WILL BE
C  UPLOADED TO THE COMPUTER TO BE RUN BY THE APPLICABLE PROGRAM
C  (THE MAIN ANALYSIS PROGRAM OR THE ASSAY ESTIMATION PROGRAM).

C  CALL FULLNAME WHICH CONVERTS THE FILENAME TO PATHFILE, THE COMPLETE
C  NAME OF THE FILE, WHICH INCLUDES THE PATH (IF THE PATH IS NOT THE

C  CURRENT DIRECTORY).

        TMPFILE = ' '
        TMPFILE = INSTFILE
        CALL FULLNAME(PATH,TMPFILE,PATHFILE)
        OPEN(27,FILE=PATHFILE,ERR=5375,STATUS='NEW')
        GO TO 5380

 5375   WRITE(*,5381) INSTFILE,INSTFILE,INSTBAK,INSTFILE
 5381   FORMAT(/' FILE ',A12,' WHICH WILL STORE THE INSTRUCTIONS AND'/
     1' THE PATIENT DATA FILES TO BE USED BY THE "ENGINE"'/
     2' ALREADY EXISTS. ',A12,' WILL BE COPIED TO ',A12,'. THEN THE '/
     3' VALUES FOR THIS RUN WILL BE WRITTEN INTO ',A12)

	IF(IVERIFY .EQ. 1) CALL PAUSE

        CALL SYSTEM(CopyFile//PATH(1:NOB)//INSTFILE//' '//PATH(1:NOB)//I
     1NSTBAK)

	OPEN(27,FILE=PATHFILE)

 5380   CONTINUE

C  WRITE ALL INPUT DATA INTO FILE INSTFILE.


		WRITE(27,*) NDIM
		WRITE(27,*) MF
		WRITE(27,*) RTOL
		WRITE(27,*) (ATOL(I),I=1,NDIM)

        IF(IFORMT .EQ. 3) THEN
         WRITE(27,2222) "XQZPJ"
         WRITE(27,222) "ZMQ"
         WRITE(27,2) BLOCKPAT
        ENDIF


        IF(IFORMT .EQ. 1) THEN
       
         WRITE(27,2222) PREFIX

         WRITE(27,222) EXT

C  CALL WORKTOCSV TO CONVERT THE NSUBTOT WORKING COPY FILES WITH PREFIX
C  AND EXT TO THE CSV FILE, 'QMZJPZQX.CSV'.

         WRITE(*,2717) NSUB,PREFIX,EXT
 2717    FORMAT(/' THE INFORMATION FROM YOUR ',I5,' WORKING COPY FILES'/
     1' WITH PREFIX ',A5,' AND EXTENSION ',A3,' ARE ABOUT TO BE'/
     2' CONVERTED TO CSV FORMAT AND WRITTEN TO THE FILE QMZJPZQX.CSV.'//
     3' IF YOU ALREADY HAVE A FILE BY THIS NAME IN YOUR DIRECTORY, '/
     4' AND WANT TO SAVE THE INFO IN THIS FILE, YOU MUST COPY THE FILE'/
     5' TO ANOTHER FILE BEFORE CONTINUING.'//)
        IF(IVERIFY .EQ. 1) CALL PAUSE

        CALL WORKTOCSV(NSUBTOT,PATH,PREFIX,EXT,'QMZJPZQX.CSV',
     1 MAXNUMEQ)

        WRITE(27,2112) 'QMZJPZQX.CSV'
 2112   FORMAT(A12)

        ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(IFORMT .EQ. 1)  CONDITION.

		WRITE(27,*) NVAR
		WRITE(27,1717) (PAR(I),I=1,NVAR)
		WRITE(27,*) NOFIX
		WRITE(27,1717) (PARFIX(I),I=1,NOFIX)

            WRITE(27,*) NRANFIX
            WRITE(27,1717) (PARRANFIX(I),I=1,NRANFIX)

		WRITE(27,*) (IRAN(I),I=1,NP)
            WRITE(27,*) NSUBTOT
		WRITE(27,*) NSUB

C  CALL SUBROUTINE WRITEPT2 TO WRITE THE PATIENT NOS. TO BE USED IN
C  THE ANALYSIS TO FILE 27 ... IN AN "EFFICIENT" WAY, AS OPPOSED TO
C  ONE INDEX PER LINE. NOTE THAT THE FIRST ARGUMENT TELLS WRITEPT2
C  TO WRITE TO FILE 27. NOTE THAT THE '    0' AFTER THE CALL TO
C  WRITEPT2 TELLS THE PROGRAM READING THIS FILE THAT THE PATIENT
C  NOS. HAVE ENDED.


		CALL WRITEPT2(27,NSUB,MAXSUB,IPATVEC)
		WRITE(27,*) '    0'

		IF(NOFIX .GT. 0) WRITE(27,*) (VALFIX(I),I=1,NOFIX)
            IF(NRANFIX .GT. 0) WRITE(27,*) (RANFIXEST(I),I=1,NRANFIX)

	      DO I=1,NVAR
	       WRITE(27,*) (AB(I,J),J=1,2)
	      END DO

		WRITE(27,*) NUMEQT

		DO I=1,NUMEQT
	 	 WRITE(27,162) IGAMMA(I),C0P(I),C1P(I),C2P(I),C3P(I)
     1     ,C4P(IEQ),C5P(IEQ)
		END DO
  162    	FORMAT(I1,2X,4(G16.10,1X))

		WRITE(27,*) XSIG

C  ESTABLISH QVAL = SUM OF IQVAL(IEQ)'S. SEE LOGIC ABOVE.

		QVAL = 0.D0
		DO I=1,NUMEQT
		 QVAL = QVAL + IQVAL(I)
		END DO

		WRITE(27,*) QVAL
            WRITE(27,*) NDRUG
		WRITE(27,*) (AF(I),I=1,NDRUG)
		WRITE(27,*) TOL
		WRITE(27,*) MAXIT
		WRITE(27,*) XDEV
		WRITE(27,*) TOLCS
		WRITE(27,*) INDPTS
		WRITE(27,*) ILOG

C  PUT ALL PATIENT DATA FILES, CONCATENATED, INTO INSTFILE.

C  NOTE THAT ALL SUBJECTS IN THE SERIES (ISUB = 1,NSUBTOT) HAVE THEIR
C  INFO PUT INTO THE FILE, INSTFILE. OF THESE SUBJECTS, ONLY
C  SUBJECTS IPATVEC(I),I=1,NSUB, WILL BE USED IN THIS RUN. THIS
C  ENABLES THE USER TO EDIT INSTFILE AND HAVE THE "engine" RERUN
c  A DIFFERENT SUBJECT SUBSET WITHOUT RERUNNING THIS PC PREP PROGRAM.


	DO 400 ISUB=1,NSUBTOT

C  CALL SUBROUTINE STACK TO OPEN THIS SUBJECT'S DATA FILE AND ADD THE
C  INFO INTO FILE 27. NOTE THAT EACH SUBJECT WILL BE TESTED TO VERIFY
C  THAT THE NO. OF OBSERVATION TIMES IS .LE. MAXOBDIM.


      WRITE(*,401) ISUB,INSTFILE
  401 FORMAT(' WRITING SUBJECT ',I6,' TO ',A12)

	IF(IFORMT .EQ. 1) PATFIL=PREFIX//NUMBER(ISUB)//'.'//EXT
	IF(IFORMT .EQ. 3) PATFIL="XQZPJ"//NUMBER(ISUB)//'.ZMQ'

	CALL STACK(PATH,MAXOBDIM,MAXNUMEQ,PATFIL,AF)

  400   CONTINUE

	   CLOSE(27)

C  COPY it2b102.inp LINE BY LINE TO it2b102.bk, AND THEN COPY
C  it2b102.bk BACK TO it2b102.inp. THIS SHOULD STRIP AWAY ANY
C  SPURIOUS CHARACTERS (WHICH LOOK LIKE LITTLE BOXES IN WORD, BUT ARE
C  INVISIBLE IN WORDSTAR) FROM THE END OF THE FILE (THESE CHARACTERS CAN
C  RESULT FROM EDITING OF THE FILE BY SOME WORD PROCESSORS. IF THEY ARE

C  NOT REMOVED NOW, THEY CAN SHOW UP IN THE FINAL OUTPUT FILE, AND THEN
C  CAUSE THE PC PREP PROGRAM (ITBIG9.EXE CURRENTLY) TO BOMB WHEN
C  READING THE OUTPUT FILE SINCE IT CAN'T "SEE" ANY LINES BEYOND A LINE
C  WITH SPURIOUS CHARACTERS IN IT. ACTUALLY, THIS ONLY SEEMS TO HAPPEN
C  WHEN THE "ENGINE" IS COMPILED AND LINKED WITH g95 (I.E., IT DOESN'T
C  HAPPEN WHEN THE "ENGINE" IS COMPILED BY LAHEY LF90).

C  THEN DO THE SAME LOGIC TO REMOVE SPURIOUS CHARACTERS FROM it2bdriv.f
C  OR assdriv.f FOR THE SAME REASON.

     	TMPFILE = ' '
	TMPFILE = 'it2b102.inp'
	CALL FULLNAME(PATH,TMPFILE,PATHFILE)
	OPEN(21,FILE=PATHFILE)

     	TMPFILE = ' '
	TMPFILE = 'it2b102.bk'
	CALL FULLNAME(PATH,TMPFILE,PATHFIL2)
	OPEN(22,FILE=PATHFIL2)

 3010 READ(21,444,IOSTAT=IEND) READLINE
	IF(IEND .LT. 0) GO TO 3100
	WRITE(22,444) READLINE

	GO TO 3010

 3100 CLOSE(21)
	CLOSE(22)

      CALL SYSTEM(CopyFile//PATH(1:NOB)//'it2b102.bk '//
     1PATH(1:NOB)//'it2b102.inp')


     	TMPFILE = ' '
      IF(IRUNIT .EQ. 1) TMPFILE = 'it2bdriv.f'
      IF(IRUNIT .EQ. 0) TMPFILE = 'assdriv.f'



	CALL FULLNAME(PATH,TMPFILE,PATHFILE)
	OPEN(21,FILE=PATHFILE)

     	TMPFILE = ' '
	TMPFILE = 'itasdriv.bak'
	CALL FULLNAME(PATH,TMPFILE,PATHFIL2)
	OPEN(22,FILE=PATHFIL2)

 4010 READ(21,444,IOSTAT=IEND) READLINE
	IF(IEND .LT. 0) GO TO 4100
	WRITE(22,444) READLINE
	GO TO 4010

 4100 CLOSE(21)
      CLOSE(22)

      IF(IRUNIT .EQ. 1)
     1 CALL SYSTEM(CopyFile//PATH(1:NOB)//'itasdriv.bak '//
     2 PATH(1:NOB)//'it2bdriv.f')

      IF(IRUNIT .EQ. 2)
     1 CALL SYSTEM(CopyFile//PATH(1:NOB)//'itasdriv.bak '//
     2 PATH(1:NOB)//'assdriv.f')


       IF(IRUNIT .EQ. 0) THEN
        WRITE(*,1113) INSTFILE
1113    FORMAT(//' YOU HAVE COMPLETED THE PREPARATION PHASE FOR THIS'/
     1' PROGRAM. PLEASE DO THE FOLLOWING:'//
     2' 1. PLACE THE FOLLOWING TWO FILES INTO THE "WORKING" DIRECTORY'/
     3'    (WHICH MUST CONTAIN THE PERMANENT MODULES FOR THE ASSDRIV'/
     4'    "ENGINE") OF THE COMPUTER WHICH WILL DO THE ANALYSIS:'/
     5'    ',A12,'  <-- INPUT INSTRUCTIONS + PATIENT DATA;'/
     6'    assdriv.f <-- DRIVER MODULE + MODEL CODE;'//
     7' 2. COMPILE AND LINK THE PROGRAM IN THE WORKING DIRECTORY ... '/ 
     9' 3. EXECUTE THE PROGRAM ... '//
     2' 5. AFTER THE RUN HAS FINISHED, YOUR OUTPUT FILE WILL BE'/
     3'     ASSxxxx, WHERE xxxx IS THE 4-DIGIT JOB NUMBER ASSIGNED TO'/
     4'     YOUR RUN.'/)
        IF(IVERIFY .EQ. 1) CALL PAUSE
       ENDIF

       IF(IRUNIT .EQ. 1) THEN
        WRITE(*,1111) INSTFILE
1111    FORMAT(//' YOU HAVE COMPLETED THE PREPARATION PHASE FOR THIS'/
     1' PROGRAM. PLEASE DO THE FOLLOWING:'//
     2' 1. PLACE THE FOLLOWING TWO FILES INTO THE "WORKING" DIRECTORY'/
     3'    (WHICH MUST CONTAIN THE PERMANENT MODULES FOR THE BIG IT2B'/
     4'    "ENGINE") OF THE COMPUTER WHICH WILL DO THE ANALYSIS:'/
     5'    ',A12,'  <-- INPUT INSTRUCTIONS + PATIENT DATA;'/
     6'    it2bdriv.f <-- DRIVER MODULE + MODEL CODE;'//
     7' 2. COMPILE AND LINK THE PROGRAM IN THE WORKING DIRECTORY ... '/
     2' 3. EXECUTE THE PROGRAM ... '/
     2' 4. AFTER THE RUN HAS FINISHED, YOUR OUTPUT FILES WILL BE'/
     3'     OUTFxxxx and RFILExxxx.IT, AND YOU WILL SEE A FILE WHICH'/
     4'     CAN BE USED AS AN INSTRUCTION FILE FOR THE BIG NPAG'/
     5'     PROGRAM, FROMxxxx, WHERE xxxx IS THE 4-DIGIT JOB NUMBER'/
     6'     ASSIGNED TO YOUR RUN.'/)
        IF(IVERIFY .EQ. 1) CALL PAUSE
       ENDIF



	STOP

	END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
      SUBROUTINE FILRED(NOBSER,YO,C0,C1,C2,C3,C4,C5,MAXOBDIM,MAXNUMEQ)


C  FILRED IS CALLED BY SUBROUTINE PREVRUN TO READ THE PORTION OF
C  SCRATCH FILE 27 WHICH APPLIES TO THE SUBJECT UNDER CONSIDERATION. THE
C  'POINTER' FOR FILE 27 IS IN THE PROPER POSITION TO BEGIN READING THE
C  INFO FOR THE DESIRED SUBJECT.

        IMPLICIT REAL*8(A-H,O-Z)
        DIMENSION SIG(5000),RS(5000,34),YO(MAXOBDIM,MAXNUMEQ),
     1  BS(5000,7),C0(MAXNUMEQ),C1(MAXNUMEQ),C2(MAXNUMEQ),C3(MAXNUMEQ)
     2  , C4(MAXNUMEQ), C5(MAXNUMEQ)

C  AS OF NPBIG11, THE NO. OF BOLUS COLUMNS HAS BEEN INCREASED TO 7, SO
C  BS(500,3) HAS BECOME BS(500,7).

        CHARACTER ERRFIL*20

      COMMON/ERROR/ERRFIL
C  COMMON/ERROR/ IS SUPPLIED TO ALL THE ROUTINES WHICH COULD WRITE TO
C  ERRFIL. 


C  THE MAJOR CHANGE AS OF NPBIG11.FOR (WHICH ALLOWS MULTIPLE DRUGS)
C  OCCURS IN THE DOSAGE REGIMEN BLOCK WHICH WILL NOW HAVE THE FOLLOWING
C  COLUMNS, IN ORDER:

C     COL 1 = TIME
C     COL 2 = IV FOR DRUG 1; COL 3 = PO FOR DRUG 1;
C     COL 4 = IV FOR DRUG 2; COL 5 = PO FOR DRUG 2;
C     ... EACH SUCCEEDING DRUG HAS AN IV FOLLOWED BY A PO COLUMN.
C     NEXT NADD COLUMNS = ONE FOR EACH ADDITIONAL COVARIATE.

	CHARACTER SEX*1,READLINE*1000



C  INPUT IS: SCRATCH FILE 27, WHICH IS POSITIONED AT THE BEGINNING OF
C  THE INFO FOR THE SUBJECT DESIRED.

C  OUTPUT ARE:

C  NOBSER = THE NO. OF OBSERVATIONS FOR THIS SUBJECT.
C  YO(I,J),I=1,M; J=1,NUMEQT = NO. OF OUTPUT EQS; I=1,M, WHERE M = NO.
C	OF OBSERVATION TIMES.
C  [C0(J),C1(J),C2(J),C3(J)] = ASSAY NOISE COEFFICIENTS FOR OUTPUT EQ.
C	J; J=1,NUMEQT.

C  AGE, SEX, HEIGHT, AND ETHNICITY FLAG ARE ON LINES 8-11.

	DO I=1,7
	 READ(27,*)
	END DO


	READ(27,*) AGE
	READ(27,2) SEX
    2 FORMAT(A1)
	ISEX=1
	IF(SEX .EQ. 'F') ISEX=2
	READ(27,*) HEIGHT
	READ(27,*) IETHFLG

C  READ THE NO. OF DRUGS FROM THE LINE WITH 'NO. OF DRUGS' AS ENTRIES
C  12:23. THEN READ NO. OF ADDITIONAL COVARIATES, AND THE NO. OF DOSE
C  EVENTS, ETC.

    1   FORMAT(A1000)
   10	READ(27,1) READLINE
	IF(READLINE(12:23) .NE. 'NO. OF DRUGS') GO TO 10
	BACKSPACE(27)

    3   FORMAT(T2,I5)
        READ(27,3) NDRUG


	IF(NDRUG .GT. 7) THEN



	 WRITE(*,124)
  124    FORMAT(' YOUR PATIENT DATA FILES CANNOT HAVE MORE THAN 7'/
     1' DRUGS. THE PROGRAM IS NOW STOPPING. '/)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,124) 
        CLOSE(42)



	 CALL PAUSE
	 STOP



	ENDIF

        READ(27,3) NADD

C  NOTE THAT THE NO. OF "RATES" INCLUDES 2 FOR EACH DRUG (THE IV AND
C  THE PO COLUMNS) + NADD (1 COLUMN FOR EACH ADDITIONAL COVARIATE 
C  BEYOND THE FIRST 4 ABOVE, AGE, SEX, HEIGHT, AND ETHNICITY FLAG).

	NI = 2*NDRUG + NADD


	IF(NI .GT. 34) THEN



  	 WRITE(*,123)
  123    FORMAT(/' YOUR PATIENT DATA FILES HAVE TOO MANY COLUMNS IN '/
     1' THE DOSAGE REGIMEN BLOCK. THE NO. OF ADDITIONAL COVARIATES '/
     2' PLUS TWICE THE NO. OF DRUGS CANNOT EXCEED 34. THE PROGRAM IS'/
     3' NOW STOPPING. '/)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,123) 
        CLOSE(42)



	 CALL PAUSE
	 STOP



	ENDIF


        READ(27,3) ND



	IF(ND .GT. 5000) THEN



	 WRITE(*,125)
  125    FORMAT(' YOUR PATIENT DATA FILES CANNOT HAVE MORE THAN 5000'/
     1' DOSE EVENTS. THE PROGRAM IS NOW STOPPING. '/)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,125) 
        CLOSE(42)



	 CALL PAUSE
	 STOP



	ENDIF

	READ(27,*)
	READ(27,*)


        IF(ND.EQ.0) GO TO 40

	DO I = 1,ND
         READ(27,*) SIG(I),(RS(I,J),J=1,NI)
	END DO



C  ASSIGN THE VALUES IN EACH DRUG'S PO COLUMN TO THE CORRESPONDING
C  COLUMN IN ARRAY BS.

        DO I=1,ND
         DO J=1,NDRUG
          BS(I,J)=RS(I,2*J)
	 END DO
	END DO

C  READ THE NO. OF OUTPUT EQUATIONS FROM THE LINE WITH 'NO. OF TOTAL'
C  AS ENTRIES 12:23. THEN READ NO. OF OBSERVED VALUE TIMES, ETC.

   40	READ(27,1) READLINE
	IF(READLINE(12:23) .NE. 'NO. OF TOTAL') GO TO 40


	BACKSPACE(27)

        READ(27,3) NUMEQT
        READ(27,3) M

	IF(M .GT. MAXOBDIM) THEN



  	 WRITE(*,126) MAXOBDIM
  126    FORMAT(/' AT LEAST ONE OF YOUR PATIENT DATA FILES HAS TOO'/
     1' MANY OBSERVED VALUE TIMES. THIS NO. CANNOT EXCEED ',I5,'.'/
     2' THE PROGRAM IS NOW STOPPING. '/)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,126) MAXOBDIM
        CLOSE(42)




	 CALL PAUSE
	 STOP



	ENDIF



	IF(NUMEQT .GT. MAXNUMEQ) THEN

        WRITE(*,127) MAXNUMEQ
  127    FORMAT(/' AT LEAST ONE OF YOUR PATIENT DATA FILES HAS TOO'/
     1' MANY OUTPUT EQUATION COLUMNS. THIS NO. CANNOT EXCEED ',I2,'.'/
     2' THE PROGRAM IS NOW STOPPING. '/)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,127) MAXNUMEQ 
        CLOSE(42)



	 CALL PAUSE
	 STOP



	ENDIF


	DO I=1,M
         READ(27,*) T,(YO(I,J),J=1,NUMEQT)
	END DO


	NOBSER = M


C  AT THIS POINT, MUST SKIP THE COVARIATE INFO IN THE FILE, AND PROCEED
C  TO READ THE ASSAY NOISE COEFFICIENTS BELOW THAT.

C  READ THE NUMEQT SETS OF ASSAY COEFFICIENTS JUST BELOW THE LINE
C  WHICH HAS "ASSAY COEFFICIENTS FOLLOW" IN ENTRIES 1:25.


   50	READ(27,1) READLINE
	IF(READLINE(1:25) .NE. 'ASSAY COEFFICIENTS FOLLOW') GO TO 50

	DO IEQ = 1,NUMEQT
	 READ(27,*) C0(IEQ),C1(IEQ),C2(IEQ),C3(IEQ)
C     1     ,C4(IEQ),C5(IEQ)
         C4(IEQ) = 0
         C5(IEQ) = 0
	END DO

	RETURN
	END

C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
	SUBROUTINE STACK(PATH,MAXOBDIM,MAXNUMEQ,PATFIL,AF)

C  THIS ROUTINE, CALLED BY MAIN, READS THE INFO IN FILE PATFIL, AND
C  APPENDS IT ONTO THE END OF FILE 27.


        IMPLICIT REAL*8(A-H,O-Z)
        DIMENSION SIG(5000),RS(5000,34),AF(7)
        CHARACTER PATFIL*20,READLINE*1000,PATH*60,TMPFILE*13,PATHFILE*73
        CHARACTER ERRFIL*20

      COMMON/ERROR/ERRFIL
C  COMMON/ERROR/ IS SUPPLIED TO ALL THE ROUTINES WHICH COULD WRITE TO
C  ERRFIL. 



C  SEE SUBROUTINE FILRED FOR SOME DETAILS ON THE MAJOR CHANGES AS
C  OF NPBIG11.FOR.

C  INPUT IS:

C  PATH = LOCATION (DIRECTORY) OF PATIENT DATA FILES.
C  PATFIL = PATIENT DATA FILE.
C  AF(I),I=1,NDRUG = ACTIVE FRACTION OF THE DRUG I. EACH IV RATE AND 
C        BOLUS VALUE FOR DRUG I MUST BE MULTIPLIED BY AF(I).

C  OUTPUT IS:

C  FILE 27 WHICH NOW HAS PATFIL APPENDED ONTO ITS END.

C  COPY LINE-BY-LINE PATFIL TO FILE 27 EXCEPT FOR THE DOSAGE REGIMEN
C  (BECAUSE EACH IV RATE AND BOLUS INPUT MUST BE MULTIPLIED BY AF(I)
C  BEFORE BEING WRITTEN TO FILE 27).

    1   FORMAT(A1000)


C  CALL FULLNAME WHICH CONVERTS THE FILENAME TO PATHFILE, THE COMPLETE
C  NAME OF THE FILE, WHICH INCLUDES THE PATH (IF THE PATH IS NOT THE
C  CURRENT DIRECTORY).

     	TMPFILE = ' '
	TMPFILE = PATFIL
	CALL FULLNAME(PATH,TMPFILE,PATHFILE)
        OPEN(21,FILE=PATHFILE)
   10	READ(21,1,IOSTAT=IEND) READLINE


C  NOTE THAT IEND .LT. 0 --> END OF FILE REACHED.

	IF(IEND .LT. 0) THEN

       WRITE(*,128) PATFIL
128    FORMAT(/' PATIENT DATA FILE ',A20,' HAS AN OLD-STYLE WORKING'/
     1' COPY FORMAT.'//
     2' FOR THIS PROGRAM, A PATIENT DATA FILE MUST HAVE "NO OF DRUGS"'/
     3' IN ENTRIES 12 THROUGH 23 ON OR NEAR LINE 18.'//
     5' THE PROGRAM STOPS. '/)
  
        OPEN(42,FILE=ERRFIL)
         WRITE(42,128) PATFIL 
        CLOSE(42)

	 CALL PAUSE
	 STOP



	ENDIF

	WRITE(27,1) READLINE
	IF(READLINE(12:23) .NE. 'NO. OF DRUGS') GO TO 10

C  READLINE NOW CONTAINS THE NO. OF DRUGS, NDRUG. BACKSPACE AND READ
C  NDRUG; THEN READ THE NO. OF ADDITIONAL COVARIATES, AND THE NO. OF
C  DOSE EVENTS.

	BACKSPACE(21)

    3   FORMAT(T2,I5)

	READ(21,3) NDRUG

	IF(NDRUG .GT. 7) THEN



	 WRITE(*,124) PATFIL
  124    FORMAT(' PATIENT DATA FILE ',A20,' HAS TOO MANY DRUGS'/
     1' (I.E, MORE THAN 7). THE PROGRAM IS NOW STOPPING. '/)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,124) PATFIL 
        CLOSE(42)

	 CALL PAUSE
	 STOP

	ENDIF

        READ(21,3) NADD

C  NOTE THAT THE NO. OF "RATES" INCLUDES 2 FOR EACH DRUG (THE IV AND
C  THE PO COLUMNS) + NADD (1 COLUMN FOR EACH ADDITIONAL COVARIATE).

	NI = 2*NDRUG + NADD


	IF(NI .GT. 34) THEN



  	 WRITE(*,123) PATFIL
  123    FORMAT(/' YOUR PATIENT DATA FILES HAVE TOO MANY COLUMNS IN '/
     1' THE DOSAGE REGIMEN BLOCK. THE NO. OF ADDITIONAL COVARIATES '/
     2' PLUS TWICE THE NO. OF DRUGS CANNOT EXCEED 34. THE PROGRAM IS'/
     3' NOW STOPPING. '/)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,123) PATFIL 
        CLOSE(42)



	 CALL PAUSE
	 STOP



	ENDIF


        READ(21,3) ND

	IF(ND .GT. 5000) THEN

	 WRITE(*,125) PATFIL
  125    FORMAT(' PATIENT DATA FILE ',A20,' HAS TOO MANY DOSE EVENTS'/

     1' (I.E., MORE THAN 5000). THE PROGRAM IS NOW STOPPING. '/)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,125) PATFIL 
        CLOSE(42)



	 CALL PAUSE
	 STOP



	ENDIF

C  BACKSPACE TWICE AND PUT THE LAST TWO LINES, AND THE NEXT TWO LINES
C  ONTO FILE 27 (THE NEXT LINE AFTER THAT STARTS THE DOSAGE REGIMEN).

	BACKSPACE(21)
	BACKSPACE(21)

	DO I=1,4
	 READ(21,1) READLINE
	 WRITE(27,1) READLINE
	END DO

        IF(ND.EQ.0) GO TO 40


C  THE FIRST NDRUG*2 COLUMNS OF R HAVE THE IV AND BOLUS VALUES FOR
C  THE NDRUG DRUGS IN THE FILE. THESE VALUES MUST BE MULTIPLIED BY 
C  AF(I), WHERE I IS THE DRUG NO.

        DO I = 1,ND

         READ(21,*) SIG(I),(RS(I,J),J=1,NI)

         DO J = 1,2*NDRUG

C  THE DRUG NO., IDRUG, IS THE INTEGER VALUE OF (J+1)/2. EX: (J+1)/2
C  WILL BE 1 IF J = 1 OR 2 SINCE INTEGER ARITHMETIC TRUNCATES.

          IDRUG = (J+1)/2
          RS(I,J) = RS(I,J)*AF(IDRUG)

         END DO
        
         WRITE(27,*) SIG(I),(RS(I,J),J=1,NI)


        END DO

C  READ THE NO. OF OUTPUT EQUATIONS FROM THE LINE WITH 'NO. OF TOTAL'
C  AS ENTRIES 12:23. THEN READ NO. OF OBSERVED VALUE TIMES, ETC. CHECK
C  THAT THESE ENTRIES ARE NOT TOO BIG. IF NOT, WRITE THE REST OF THE
C  FILE 21 TO FILE 27.

   40	READ(21,1) READLINE
	WRITE(27,1) READLINE

	IF(READLINE(12:23) .NE. 'NO. OF TOTAL') GO TO 40
	BACKSPACE(21)

        READ(21,3) NUMEQT
        READ(21,3) M

	IF(M .GT. MAXOBDIM) THEN



	 WRITE(*,126) PATFIL,M,MAXOBDIM,MAXOBDIM
  126    FORMAT(/' PATIENT ',A20,' HAS ',I3,' OBSERVATION TIMES. THIS '/
     1' IS MORE THAN THE ALLOWABLE MAXIMUM OF ',I3,'. PLEASE RERUN THE'/
     2' PROGRAM AFTER ENSURING THAT ALL YOUR PATIENTS HAVE NO MORE '/
     3' THAN ',I3,' OBSERVATION TIMES. '/)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,126) PATFIL,M,MAXOBDIM,MAXOBDIM  
        CLOSE(42)



	 CALL PAUSE
	 STOP



	ENDIF




	IF(NUMEQT .GT. MAXNUMEQ) THEN



	 WRITE(*,127) PATFIL,NUMEQT,MAXNUMEQ,MAXNUMEQ
  127    FORMAT(/' PATIENT ',A20,' HAS ',I3,' OUTPUT EQUATION COLUMNS,'/
     1' WHICH IS MORE THAN THE MAXIMUM ALLOWABLE NO. OF ',I2,'.'/
     2' PLEASE RERUN THE PROGRAM AFTER ENSURING THAT ALL YOUR PATIENTS'/
     3' HAVE NO MORE THAN ',I2,' OUTPUT EQUATION COLUMNS. '/)


        OPEN(42,FILE=ERRFIL)
         WRITE(42,127) PATFIL,NUMEQT,MAXNUMEQ,MAXNUMEQ
 

       CLOSE(42)



	 CALL PAUSE
	 STOP



	ENDIF

C  BACKSPACE JUST ONCE TO THE LINE WITH M ON IT, SINCE THE LINE WITH
C  NUMEQT ON IT WAS ALREADY PUT INTO FILE 27. THEN COPY LINE FOR LINE
C  THE REST OF THE FILE TO FILE 27. NOTE THAT IEND .LT. 0 --> END OF
C  FILE REACHED.

	BACKSPACE(21)

   20	READ(21,1,IOSTAT=IEND) READLINE
	IF(IEND .LT. 0) GO TO 100
	WRITE(27,1) READLINE
	GO TO 20
  100	CLOSE(21)

	RETURN
	END

C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
        SUBROUTINE VERIF1(PREFIX,EXT,IFORMT,NSUB,NSUBTOT,
     1  PAR,NVAR,AB,C0P,C1P,C2P,C3P,C4P,C5P,IASS,AF,NOFIX,VALFIX,PARFIX,
     2  TOL,MAXIT,XDEV,XSIG,IGAMMA,IQVAL,NUMEQT,IUNIQ,PATH,NOB,BLOCKPAT,
     3  ISUBALL,MAXSUB,IPATVEC,NDRUG,TOLER,NDIM,RTOL,ATOL,
     4  OSName,ListDir,IRAN,MAXNUMEQ,NRANFIX,PARRANFIX,
     6  RANFIXEST)


	IMPLICIT REAL*8(A-H,O-Z)

	DIMENSION AB(30,2),VALFIX(20),IGAMMA(MAXNUMEQ),IASS(MAXNUMEQ),
     1 C0P(MAXNUMEQ),C1P(MAXNUMEQ),C2P(MAXNUMEQ),C3P(MAXNUMEQ),
     2 IUNIQ(MAXNUMEQ),IQVAL(MAXNUMEQ),IPATVEC(MAXSUB),AF(7),
     3 ATOL(20),IRAN(32),RANFIXEST(20),C4P(MAXNUMEQ),C5P(MAXNUMEQ)


      COMMON/ERROR/ERRFIL
C  COMMON/ERROR/ IS SUPPLIED TO ALL THE ROUTINES WHICH COULD WRITE TO
C  ERRFIL. 

	CHARACTER PREFIX*5,EXT*3,PAR(30)*11,OSName*20,LISTDIR*10,
     1  PARFIX(20)*11,PATFIL*20,FILASS*20,READLINE*1000,PATH*60,
     2  TMPFILE*13,PATHFILE*73,BLOCKPAT*20,CODEPAT*15,ANS*3,ERRFIL*20,
     3  PARRANFIX(20)*11

C  SUBROUTINE VERIF1 IS CALLED BY MAIN TO PRINT TO THE SCREEN THE INPUT
C  INFO, SO THE USER CAN VERIFY THAT THE VALUES WERE ENTERED CORRECTLY.
C  IF NOT, THE USER MAY CHANGE THESE VALUES.

C  NOTE: SUBROUTINE CHANGE BELOW IS CALLED SEVERAL TIMES. ITS ARGUMENT,
C        ICHANG, RETURNS AS 1 IF THE PREVIOUS INFORMATION PRINTED TO THE
C	   SCREEN IS VALIDATED BY THE USER; IT RETURNS AS 0 IF THE USER
C	   WANTS TO CHANGE SOMETHING.

  102   FORMAT(A20)
  103   FORMAT(A3)
  104   FORMAT(A5)

 5020   WRITE(*,1)
    1   FORMAT(///' THE FOLLOWING INFO WAS READ IN; IF ANY OF IT IS '/
     1' INCORRECT, MAKE THE DESIRED CHANGES.')

      WRITE(*,919) TOLER
 919  FORMAT(/' THE TOLERANCES FOR THE O.D.E. SOLVER ARE ALL ',G16.8)

	CALL CHANGE(ICHANG)
	IF(ICHANG .EQ. 0) THEN

 915   WRITE(*,913)
 913   FORMAT(/' ENTER 1 TO SET ALL TOLERANCES (FOR THE O.D.E. '/
     1'         SOLVER) TO THE DEFAULT VALUE ... 1.D-4.'/
     2' ENTER 0 TO SELECT A DIFFERENT VALUE FOR THE TOLERANCES: ')
       READ(*,*,ERR=915) ITOL
       IF(ITOL .NE. 0 .AND. ITOL .NE. 1) GO TO 915

       TOLER=1.D-4

      IF(ITOL .EQ. 0) THEN
  910	 WRITE(*,914)
  914  FORMAT(/' ENTER A POSITIVE VALUE FOR THE TOLERANCE PARAMETERS: ')
       READ(*,*,ERR=910) TOLER
       IF(TOLER .LE. 0.D0) GO TO 910
      ENDIF

      RTOL = TOLER
      DO I=1,NDIM
       ATOL(I) = TOLER
      END DO

      ENDIF
C  ABOVE ENDIF IS FOR THE  IF(ICHANG .EQ. 0)  CONDITION.


	IF(IFORMT .EQ. 1) THEN
	 WRITE (*,2) PREFIX,EXT
    2    FORMAT(/' THE PATIENT DATA FILES ARE CALLED: ',A5,'001.',A3,' .
     1..')
	 WRITE(*,3)
    3    FORMAT(/' THESE FILES ARE IN WORKING COPY FORMAT.')
	ENDIF

	IF(IFORMT .EQ. 3) WRITE(*,22) BLOCKPAT
   22   FORMAT(/' THE PATIENT DATA INFORMATION WILL BE INPUT IN '/
     1' BLOCK FORMAT FROM FILE ',A20)
C
C
C
	CALL CHANGE(ICHANG)
	IF(ICHANG .EQ. 0) THEN
C
C
C

4005	WRITE(*,141)
  141   FORMAT(/' ENTER 1 IF THE PATIENT DATA INFO WILL BE SUPPLIED'/
     1'         IN A MATRIX BLOCK FORMAT; '/
     2' ENTER 2 IF THE PATIENT DATA INFO WILL BE INPUT USING A'/
     3'         WORKING COPY FORMAT: ')
	READ(*,*,ERR=4005) IFORMTT
	IF(IFORMTT .NE. 1 .AND. IFORMTT .NE. 2) GO TO 4005

C  IFORMTT MUST BE CHANGED TO BE THE SAME AS THE
C  OLD IFORMT AS FOLLOWS:
C  IFORMTT = 1 --> IFORMT = 3 --> PATIENT INFO IS INPUT VIA BLOCK FORMAT
C                                 (.CSV FILES);
C  IFORMTT = 2 --> IFORMT = 1 --> PATIENT INFO IS INPUT VIA WORKING COPY
C                                 FILES.

         IF(IFORMTT .EQ. 1) IFORMT = 3
         IF(IFORMTT .EQ. 2) IFORMT = 1

	IF(IFORMT .EQ. 3) THEN

         WRITE(*,3111)
 3111    FORMAT(/' ENTER THE NAME OF THE FILE WHICH CONTAINS ALL THE'/
     1' PATIENT DATA INFO IN BLOCK FORMAT (ENTER -99 TO SEE ALL OR A '/
     2' PART OF YOUR DIRECTORY: ')
        READ(*,102) BLOCKPAT
	IF(BLOCKPAT(1:3) .EQ. '-99') THEN
           CALL SEEDIR(PATH,NOB,BLOCKPAT,OSName,ListDir)
        ENDIF

C  CALL FULLNAME WHICH CONVERTS THE FILENAME TO PATHFILE, THE COMPLETE
C  NAME OF THE FILE, WHICH INCLUDES THE PATH (IF THE PATH IS NOT THE

C  CURRENT DIRECTORY).

     	TMPFILE = ' '
	TMPFILE = BLOCKPAT
	CALL FULLNAME(PATH,TMPFILE,PATHFILE)
	OPEN(67,FILE=PATHFILE,ERR=3120,STATUS='OLD')
	GO TO 3130
 3120   WRITE(*,5316) PATHFILE
 5316   FORMAT(//' THE FOLLOWING FILE DOES NOT EXIST ... '/
     1'    ',A73)
	GO TO 4005
 3130   CONTINUE

	 ICODEPAT = 0
	 READ(67,7126) CODEPAT
 7126    FORMAT(A15)
	 IF(CODEPAT .EQ. '"POPDATA APR_11') ICODEPAT = 1
	 IF(CODEPAT(1:14) .EQ. 'POPDATA APR_11') ICODEPAT = 1
       IF(CODEPAT .EQ. '"POPDATA DEC_11') ICODEPAT = 1
       IF(CODEPAT(1:14) .EQ. 'POPDATA DEC_11') ICODEPAT = 1

	IF(ICODEPAT .EQ. 0) THEN
	 WRITE(*,3131)

 3131    FORMAT(//' YOUR PATIENT DATA BLOCK FORMAT FILE IS NOT FROM '/
     1' THE ALLOWABLE SET OF SUCH FILES.'//
     2' A PATIENT DATA BLOCK FORMAT FILE MUST HAVE "POPDATA XXX_XX IN'/

     3' COLUMNS 1 THROUGH 15 ON LINE 1, WHERE  XXX_XX  IS APR_11 OR A '/
     4' MORE RECENT DATE.'//)

	  CLOSE(67)
	  GO TO 4005
	ENDIF

	CLOSE(67)

	ENDIF


C  THE ABOVE ENDIF IS FOR THE  IF(IFORMT .EQ. 3)  CONDITION.


	IF(IFORMT .EQ. 1) THEN

 7505	  WRITE(*,4041)
 4041     FORMAT(/' ENTER THE 5-CHAR PREFIX FOR PATIENT FILENAMES: ')
	  READ(*,104) PREFIX
	  WRITE(*,4043)
 4043     FORMAT(/' IF THERE IS A 3-CHAR EXTENSION FOR THE PATIENT '/
     1' FILENAMES, ENTER IT NOW; OTHERWISE, HIT CARRIAGE RETURN: ')
	  READ(*,103) EXT


C  VERIFY THAT THE USER ENTERED AT LEAST 5 CHARACTERS FOR THE PREFIX. IF
C  NOT, VERIFY THAT THIS IS NOT A MISTAKE ... BUT ALLOW SUCH A PREFIX
C  IF THE USER INSISTS -- THE RUN WILL STILL WORK PROPERLY.



	  IF(PREFIX(1:1) .EQ. ' ' .OR. PREFIX(2:2) .EQ. ' ' .OR.
     1       PREFIX(3:3) .EQ. ' ' .OR. PREFIX(4:4) .EQ. ' ' .OR.
     2       PREFIX(5:5) .EQ. ' ') THEN

     	PATFIL = PREFIX//'001.'//EXT
 7500   WRITE(*,7501) PATFIL(1:12)
 7501   FORMAT(/' ARE YOUR SUBJECT FILES REALLY CALLED ',A12,' ... ?'//
     1' ENTER 1 TO REENTER YOUR SUBJECT FILENAMES; '/
     2' ENTER 0 IF THESE NAMES ARE ACCURATE: ')
	READ(*,*,ERR=7500) IOK
	IF(IOK .NE. 0 .AND. IOK .NE. 1) GO TO 7500

	IF(IOK .EQ. 1) GO TO 7505

	   ENDIF

	ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(IFORMT .EQ. 1) THEN  CONDITION.


C  CHECK THAT NUMEQT FOR THESE NEW PATIENTS IS THE SAME AS NUMEQT
C  FOR THE OLD FILES. IF NOT CHANGE NUMEQT AND TELL THE USER.
C  SUBROUTINE GETNUMEQ READS THE NO. OF OUTPUT EQUATIONS (NUMEQT2).
C  THE 3RD ARGUMENT TO GETNUMEQ IS 0 --> THE CALL IS NOT FROM MAIN.
C  SIMILARLY FOR NDRUG2, COMPARED TO NDRUG FOR THE ORIGINAL PATIENTS.

        CALL GETNUMEQ(PATH,NOB,0,IFORMT,PREFIX,EXT,BLOCKPAT,NUMEQT2,
     1   NDRUG2,MAXSUB,MAXNUMEQ)


C  CHECK THAT NUMEQT IS .LE. MAXNUMEQ.

      IF(NUMEQT .GT. MAXNUMEQ) THEN

       WRITE(*,8317) NUMEQT,MAXNUMEQ
 8317  FORMAT(/' YOUR PATIENT FILES HAVE ',I3,' OUTPUT EQUATIONS. '/
     1' THIS IS MORE THAN THE MAXIMUM ALLOWED NO. OF ',I2,'.'//
     2' PLEASE CORRECT YOUR PATIENT FILES AND THEN RERUN THE PROGRAM.'/) 

       OPEN(42,FILE=ERRFIL)
        WRITE(42,8317) NUMEQT,MAXNUMEQ 
       CLOSE(42)

       CALL PAUSE
       STOP

      ENDIF



	IF(NUMEQT .NE. NUMEQT2) THEN

	 WRITE(*,7512) NUMEQT2,NUMEQT
 7512    FORMAT(//' YOUR NEW PATIENT DATA FILES HAVE ',I4,' OUTPUT'/

     1' EQUATION(S), RATHER THAN THE ',I4,' OUTPUT EQUATION(S) THAT '/
     2' YOUR ORIGINAL PATIENT FILES HAD. BE SURE TO CHANGE THE ASSAY'/
     3' COEFFICIENT INFORMATION BELOW, IF NEEDED.')

C  IF NUMEQT (OLD) < NUMEQT2 (NEW), PUT 1'S IN ALL NEW ENTRIES OF
C  IASS AND C0P,...,C3P. THEY CAN BE CHANGED BY USER BELOW.

	 IF(NUMEQT .LT. NUMEQT2) THEN
	  DO IEQ = NUMEQT+1,NUMEQT2
	   IASS(IEQ) = 1
	   C0P(IEQ) = 1
	   C1P(IEQ) = 1
	   C2P(IEQ) = 1
	   C3P(IEQ) = 1
	   C4P(IEQ) = 0
	   C5P(IEQ) = 0
	  END DO
	 ENDIF

	NUMEQT = NUMEQT2


	ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(NUMEQT .NE. NUMEQT2)  CONDITION.


	IF(NDRUG .NE. NDRUG2) THEN

	 WRITE(*,7513) NDRUG2,NDRUG
 7513    FORMAT(//' YOUR NEW PATIENT DATA FILES HAVE ',I4,' DRUGS,'/
     1' RATHER THAN THE ',I4,' DRUGS THAT YOUR ORIGINAL PATIENT FILES'/
     2' HAD. BE SURE TO CHANGE THE AF VALUES BELOW, IF NEEDED.')

C  IF NDRUG (OLD) < NDRUG2 (NEW), PUT 1'S IN ALL NEW ENTRIES OF
C  AF. THEY CAN BE CHANGED BY USER BELOW.

	 IF(NDRUG .LT. NDRUG2) THEN
	  DO ID = NDRUG+1,NDRUG2
         AF(ID) = 1.D0
	  END DO
	 ENDIF

	NDRUG = NDRUG2

	ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(NDRUG .NE. NDRUG2)  CONDITION.

C
C
C
	ENDIF
C
C
C
C??? BUG CORRECTION IN ITBIG10.FOR. ISUBALL IS NOT SET BEFORE THE CALL
C  TO THIS ROUTINE IF AN INSTRUCTION FILE IS USED. SO USED A DIRECT
C  COMPARISON OF NSUB TO NSUBTOT IN CODE BELOW.

      IF(NSUB .EQ. NSUBTOT) WRITE(*,6) NSUBTOT,NSUB
C	IF(ISUBALL .EQ. 1) WRITE(*,6) NSUBTOT,NSUB
    6   FORMAT(/' YOU HAVE ',I5,' SUBJECTS IN YOUR ENTIRE DATA SET. '/
     1' OF THESE, ALL ',I5,' WILL BE USED IN THIS ANALYSIS. ')

      IF(NSUB .LT. NSUBTOT) THEN
C	IF(ISUBALL .EQ. 0) THEN
	 WRITE(*,16) NSUBTOT,NSUB
   16    FORMAT(/' YOU HAVE ',I5,' SUBJECTS IN YOUR ENTIRE DATA SET. '/
     1' OF THESE, ',I5,' WILL BE USED IN THIS ANALYSIS. THE INDICES'/
     2' OF THE PATIENTS TO BE USED ARE AS FOLLOWS: ')

	 CALL WRITEPAT(NSUB,MAXSUB,IPATVEC)

	ENDIF
C
C
	CALL CHANGE(ICHANG)
	IF(ICHANG .EQ. 0) THEN
C
C
C  CALL SUBROUTINE GETIPAT TO OBTAIN THE NO. OF SUBJECTS IN THE
C  ENTIRE DATA SET, NSUBTOT, THE NO. OF THESE SUBJECTS TO BE USED
C  IN THE CURRENT ANALYSIS, NSUB, AND THE INDICES OF THESE "ACTIVE"
C  SUBJECTS, IPATVEC(I),I=1,NSUB. NOTE THAT ISUBALL = 1 IF ALL
C  SUBJECTS ARE USED (I.E., NSUB = NSUBTOT) AND 0 OTHERWISE.

	CALL GETIPAT(NSUBTOT,NSUB,ISUBALL,MAXSUB,IPATVEC)
C
C
C


        ENDIF
C
C
C
	WRITE(*,7) (PAR(I),I=1,NVAR)
    7   FORMAT(/' THE PARAMETERS TO BE ESTIMATED ARE: '/
     1' ',30A11)

      WRITE(*,9)
    9 FORMAT(//' THEIR RANGES, AND WHETHER THEIR ESTIMATES MUST BE'/
     1' GREATER THAN OR EQUAL TO 0 ARE: ')

C  NORAN IN THE LOOP BELOW IS THE RUNNING INDEX (OUT OF THE NP TOTAL
C  PARAMETERS) OF THE NEXT PARAMETER WHICH IS RANDOM.

      NORAN = 0
      NP = NVAR + NOFIX + NRANFIX
      DO I = 1,NP
       IF(IRAN(I) .EQ. 0 .OR. IRAN(I) .EQ. 2) GO TO 100
       NORAN = NORAN + 1
       IF(IRAN(I) .EQ. 1) ANS = 'YES'
       IF(IRAN(I) .EQ. -1) ANS = 'NO '        
       WRITE(*,11) PAR(NORAN),AB(NORAN,1),AB(NORAN,2),ANS
  100  CONTINUE
      END DO

   11  FORMAT(/' ',A11,': ',G17.10,'  TO  ',G17.10,5X,3A)

	WRITE(*,201)
  201   FORMAT(/' THE USER-ENTERED FIXED PARAMETER VALUE(S) IS (ARE):')

	IF(NOFIX .EQ. 0) WRITE(*,*)' ... NONE SELECTED.'

      IF(NOFIX .GT. 0) THEN
       DO 210 I=1,NOFIX
  210   WRITE(*,211) PARFIX(I),VALFIX(I)
      ENDIF

  211   FORMAT(/' ',A11,': ',G17.10)

      WRITE(*,1201)
 1201 FORMAT(/' THE USER-ENTERED RANFIX PARAMETER VALUE(S) IS (ARE):')

      IF(NRANFIX .EQ. 0) WRITE(*,*)' ... NONE SELECTED.'

      IF(NRANFIX .GT. 0) THEN
       DO I=1,NRANFIX
        WRITE(*,211) PARRANFIX(I),RANFIXEST(I)
       END DO
	ENDIF


C
C
	CALL CHANGE(ICHANG)
	IF(ICHANG .EQ. 0) THEN
C
C
C  IN THIS PROGRAM, THE USER CAN ONLY CHANGE THE RANGES, AND WHETHER
C  OR NOT A VARIBLE ESTIMATE MUST BE POSITIVE OR NOT, SINCE THE
C  NAMES OF THE FIXED AND RANDOM VARIABLES ARE HARDCODED INTO
C  THE MODEL FILE READ BY SUBROUTINE USERPREP. SO HARDCODE IPB=1.

	IPB=1


C  IF IPB = 1, GO TO LABEL 4970 AND SIMPLY CHANGE THE BOUNDARIES,

C              AND OR THE IRAN(.) VALUES. THEN GO TO LABEL 7220 (WHICH
C              SKIPS THE DESCRIPTOR STUFF).
C  IF IPB = 2, GO TO LABEL 7210 AND SIMPLY CHANGE THE DESCRIPTORS.
C  IF IPB = 3, GO TO LABEL 4970 AND CHANGE THE BOUNDARIES; THEN PROCEED
C	       TO LABEL 7210 AND CHANGE THE DESCRIPTORS.
C  IF IPB = 0, START IMMEDIATELY BELOW WITH NEW PARAMETERS.

	GO TO 4970

C/////////////   ENTER RANDOM AND FIXED PARAMETER INFO.  ///////////////
C///////////////////////////  BELOW  ///////////////////////////////////


 4970 WRITE(*,5971)
 5971 FORMAT(/' ENTER 0 TO CHANGE THE RANGES OF THE RANDOM VARIABLES;'/
     1' ENTER 1 TO LEAVE THE RANGES UNCHANGED: ')
      READ(*,*,ERR=4970) IRANGE
      IF(IRANGE .NE. 1 .AND. IRANGE .NE. 0) GO TO 4970
      IF(IRANGE .EQ. 1) GO TO 5975

      WRITE(*,1117)
 1117   FORMAT(/' ENTER THE BOUNDS OF THE RANGE FOR EACH PARAMETER.'//
     1' CAUTION: IF ANY OF YOUR PARAMETERS CANNOT = 0, BE SURE TO MAKE'/
     2'          ITS LOWER BOUNDARY A POSITIVE NUMBER, RATHER THAN 0.'/
     3'          (ONE SUCH EXAMPLE IS FOR VOL WHICH SHOWS UP IN THE'/
     4'          DENOMINATOR OF THE OUTPUT EQUATION IN THE MODEL'/
     5'          FILE.)'//)

	DO 6060 I=1,NVAR

	WRITE(*,34) PAR(I)

   34   FORMAT(/' ',A11,' : ')

 7110   READ(*,*,ERR=7115) (AB(I,J),J=1,2)
	GO TO 6060
 7115   WRITE(*,7116)
 7116   FORMAT(/' SEE ABOVE; PLEASE ENTER TWO REAL NUMBERS: ')
	GO TO 7110

 6060 CONTINUE

 5975 WRITE(*,5976)
 5976 FORMAT(/' ENTER 0 TO CHANGE WHETHER OR NOT ONE OR MORE RANDOM'/
     1'         VARIABLES MUST HAVE AN ESTIMATE WHICH IS .GE. 0; '/
     2' ENTER 1 TO LEAVE THESE SPECIFICATIONS UNCHANGED: ')
      READ(*,*,ERR=5975) ISPEC
      IF(ISPEC .NE. 1 .AND. ISPEC .NE. 0) GO TO 5975
      IF(ISPEC .EQ. 1) GO TO 5980

      WRITE(*,5972)
 5972 FORMAT(/' FOR EACH RANDOM VARIABLE BELOW,'/
     1' ENTER 1 IF ITS ESTIMATE MUST BE .GE. 0;'/
     2' ENTER -1 IF ITS ESTIMATE MAY BE NEGATIVE.'/)

C  NORAN IN THE LOOP BELOW IS THE RUNNING INDEX (OUT OF THE NP TOTAL
C  PARAMETERS) OF THE NEXT PARAMETER WHICH IS RANDOM.

      NORAN = 0
      DO I = 1,NP
       IF(IRAN(I) .EQ. 0 .OR. IRAN(I) .EQ. 2) GO TO 110
       NORAN = NORAN + 1
  115  WRITE(*,111) PAR(NORAN)
  111  FORMAT(/' ',A11,': ')
       READ(*,*,ERR=115) IRAN(I)
       IF(IRAN(I) .NE. 1 .AND. IRAN(I) .NE. -1) GO TO 115
  110  CONTINUE
      END DO


C  ENTER THE FIXED VALUES FOR THE PARAMETERS.

 5980	IF(NOFIX .GT. 0) THEN

     	  WRITE(*,4836)

 4836     FORMAT(/' ENTER THE VALUE FOR EACH FIXED PARAMETER: ')

      DO 4855 I=1,NOFIX
       WRITE(*,34) PARFIX(I)
 4840  READ(*,*,ERR=4845) VALFIX(I)
       GO TO 4855
 4845  WRITE(*,4841)
 4841  FORMAT(/' SEE ABOVE; ENTER A POSITIVE VALUE: ')
       GO TO 4840
 4855  CONTINUE

	ENDIF


C  ENTER THE RANFIX VALUES FOR THE PARAMETERS.

      IF(NRANFIX .GT. 0) THEN

     	  WRITE(*,5836)
 5836   FORMAT(/' ENTER THE INITIAL EST. FOR EACH RANFIX PARAMETER: ')
        DO 5855 I=1,NRANFIX
        WRITE(*,34) PARRANFIX(I)
 5840   READ(*,*,ERR=5845) RANFIXEST(I)
        GO TO 5855
 5845   WRITE(*,4841)
        GO TO 5840
 5855   CONTINUE

      ENDIF



	IF(IPB .EQ. 1) GO TO 7220

 7210   CONTINUE


C  IN PAR_6.INP, THE IVER STUFF IS NOT USED. THE USER CODES EXPLICITLY
C  INTO SUBROUTINE SYMBOL WHICH DESCRIPTOR(S) IS (ARE) TO BE
C  USED WITH THE RANDOM VARIABLES.


 7220   CONTINUE



C/////////////   ENTER RANDOM AND FIXED PARAMETER INFO.  ///////////////
C///////////////////////////  ABOVE  ///////////////////////////////////



	ENDIF
C
C

 4990	WRITE(*,4991) XSIG
 4991   FORMAT(//' THE INITIAL POPULATION STD. DEV. FOR EACH PARAMETER'/
     1' WILL BE    ',F10.4,'    TIMES THE RANGE OF THAT PARAMETER.')

	CALL CHANGE(ICHANG)
	IF(ICHANG .EQ. 0) THEN
C
C
 4995	WRITE(*,*)' ENTER THE CORRECT MULTIPLE OF THE RANGE: '

	READ(*,*,ERR=4995) XSIG


	IF(XSIG .LE. 0.D0) THEN
	  WRITE(*,*) 'THE NUMBER MUST BE POSITIVE.'
	  GO TO 4995
	ENDIF
C
C

	ENDIF
C
C
	WRITE(*,12) NUMEQT
   12   FORMAT(/' THE ASSAY S.D. FOR EACH OF THE ',I2,' OUTPUT '/

     1' EQUATION(S) IS MODELLED AS A CUBIC FUNCTION OF THE OBSERVED'/
     2' LEVELS. THAT IS, EACH ASSAY S.D. IS '/
     3' SD = GAMMA*(C0+C1*Y+C2*Y**2+C3*Y**3).')


	DO IEQ = 1,NUMEQT

        WRITE(*,311) IEQ

	IF(IASS(IEQ) .EQ. 1) WRITE(*,419)
	IF(IASS(IEQ) .EQ. 2) WRITE(*,519)
	IF(IASS(IEQ) .EQ. 0) WRITE(*,619)

  419   FORMAT(/' EACH PATIENT WILL BE ASSIGNED THE ASSAY COEFFICIENTS'/
     1' IN HIS/HER DATA FILE; IF THERE ARE NO COEFFICIENTS IN THE DATA'/
     2' FILE, THE PATIENT WILL BE ASSIGNED THE GENERAL VALUES SHOWN '/
     3' BELOW.')


  519   FORMAT(/' EVERY PATIENT WILL BE ASSIGNED THE SAME GENERAL '/
     1' ASSAY COEFFICIENTS. THIS MEANS THAT ANY WORKING COPY PATIENT'/
     2' DATA FILE WHICH ALREADY HAS INDIVIDUAL ASSAY COEFFICIENTS WILL'/
     3' BE OVERWRITTEN BY THE VALUES SHOWN BELOW.')

  619   FORMAT(/' YOU WILL BE PROMPTED TO ENTER ASSAY COEFFICIENTS '/
     1' ON A PATIENT - BY - PATIENT BASIS. YOU MAY CHOOSE THE GENERAL'/
     2' VALUES SHOWN BELOW, COEFFICIENTS ALREADY IN THE PATIENT DATA'/
     3' FILE, IF ANY, OR ANY OTHER INDIVIDUAL COEFFICIENTS. ')

	IF(IGAMMA(IEQ) .EQ. 0 .AND. IASS(IEQ) .NE. 2) WRITE(*,212)
	IF(IGAMMA(IEQ) .EQ. 1 .AND. IASS(IEQ) .NE. 2) WRITE(*,213)
	IF(IGAMMA(IEQ) .EQ. 0 .AND. IASS(IEQ) .EQ. 2) WRITE(*,218)
	IF(IGAMMA(IEQ) .EQ. 1 .AND. IASS(IEQ) .EQ. 2) WRITE(*,219)

	IF(IGAMMA(IEQ) .EQ. 2) WRITE(*,217)

  212   FORMAT(/' GAMMA WILL BE ESTIMATED.')
  213   FORMAT(/' GAMMA WILL BE FIXED = 1.0. ')

  218   FORMAT(/' THE ASSAY COEFFICIENTS SHOWN BELOW WILL REMAIN FIXED.'
     1//
     2' GAMMA WILL BE ESTIMATED. '/)
  219   FORMAT(/' BOTH THE ASSAY COEFFICIENTS SHOWN BELOW AND GAMMA'/
     1' (EQUAL TO 1.0) WILL REMAIN FIXED. ')
  217   FORMAT(/' THE ASSAY COEFFICIENTS SHOWN BELOW WILL BE INITIAL'/
     1' ESTIMATES ONLY. A PRELIMINARY PROGRAM WILL CALCULATE'/
     2' AN OPTIMUM SET OF COEFFICIENTS TO BE USED FOR ALL PATIENTS. '/

     3' THIS PREPARATION PROGRAM CAN THEN BE RERUN WITH THIS OPTIMUM '/
     4' SET ENTERED AND USED FOR THE ANALYSIS PROGRAM.')

	WRITE(*,221)

  221   FORMAT(/' THE GENERAL VALUES FOR [C0,C1,C2,C3] WILL BE: ')
	WRITE(*,161) C0P(IEQ),C1P(IEQ),C2P(IEQ),C3P(IEQ)
     1      ,C4P(IEQ),C5P(IEQ)
  161   FORMAT(4(G16.10,2X))

	CALL PAUSE

	END DO

C  THE ABOVE END DO IS FOR THE  DO IEQ = 1,NUMEQT  LOOP.

C
C
	CALL CHANGE(ICHANG)

	IF(ICHANG .EQ. 0) THEN
C
C
C  SEE LOGIC FOR ESTABLISHING OF QVAL IN MAIN.

      DO IEQ = 1,NUMEQT
       IQVAL(IEQ) = 0
      END DO

        WRITE(*,19) NUMEQT
   19 FORMAT(//' THE ASSAY ERROR FUNCTION FOR EACH OF THE ',I2,' OUTPUT'
     1/
     2' EQUATION(S) IS MODELED AS FOLLOWS:'//
     2' ASSAY S.D. = GAMMA*(C0+C1*Y+C2*Y**2+C3*Y**3).'//
     3' FOR EACH OF THE OUTPUT EQUATIONS, YOU MAY ENTER EITHER: '//
     6'     ONE SET TO BE USED FOR ALL PATIENTS, OR'//
     4'     A UNIQUE SET OF COEFFICIENTS, [C0,C1,C2,C3] FOR EACH PATIENT
     5.'//
     6' IN THE FORMER CASE, YOU MAY ALSO HAVE A PRELIMINARY'/
     7' PROGRAM FIND AN OPTIMUM SET OF COEFFICIENTS, BASED ON YOUR '/
     8' INITIAL ESTIMATES, THE PATIENT DATA FILES, AND YOUR INPUT'/

     9' INSTRUCTIONS.'//
     9' IN EITHER CASE, YOU MAY CHOOSE WHETHER OR NOT TO HAVE THE MAIN'/
     1' PROGRAM GIVE AN UPDATED ESTIMATE FOR GAMMA. '//
     3' MAKE YOUR SELECTIONS FOR EACH OUTPUT EQUATION, IN TURN: '/)
	CALL PAUSE

C  FOR EACH OUTPUT, INPUT IUNIQ, IGAMMA, IASS AND [C0P,...,C3P].

	DO 2120 IEQ = 1,NUMEQT

        WRITE(*,311) IEQ
  311   FORMAT(//' FOR OUTPUT EQUATION ',I1,': '//)

  310   WRITE(*,312)
  312 FORMAT(/' ENTER 1 TO USE ONE SET OF COEFFICIENTS FOR ALL PATIENTS;
     1'/
     4' ENTER 0 IF EACH PATIENT WILL HAVE A UNIQUE SET OF COEFFICIENTS:
     5 ')
	READ(*,*,ERR=310) IUNIQ(IEQ)
	IF(IUNIQ(IEQ) .NE. 0 .AND. IUNIQ(IEQ) .NE. 1) GO TO 310


	IF(IUNIQ(IEQ) .EQ. 1) THEN

 5015   WRITE(*,1124)
 1124   FORMAT(/' ENTER 1 IF THE ASSAY COEFFICIENTS ARE NOT TO BE ESTIMA
     1TED, AND'/
     1'         GAMMA IS TO REMAIN FIXED AT 1.0;'//

     6' ENTER 2 IF THE ASSAY COEFFICIENTS ARE NOT TO BE ESTIMATED, BUT'/
     7'		GAMMA IS TO BE ESTIMATED;'//
     2' ENTER 3 IF YOU HAVE NO IDEA ABOUT YOUR ASSAY ERROR AND WOULD'/
     3'         LIKE A PRELIMINARY PROGRAM FIRST TO FIND ESTIMATES FOR'/
     4'         [C0,C1,C2,C3], GIVEN YOUR INITIAL ESTIMATES, PATIENT DAT
     5A FILES, AND'/
     6'         INPUT INSTRUCTIONS: ')
	READ(*,*,ERR=5015) IGAM
	IF(IGAM .LT. 1 .OR. IGAM .GT. 3) GO TO 5015

C  CHANGE IGAM TO IGAMMA, AND UPDATE IQVAL IF NECESSARY.

	IF(IGAM .EQ. 1) IGAMMA(IEQ) = 1
	IF(IGAM .EQ. 3) IGAMMA(IEQ) = 2

	IF(IGAM .EQ. 2) THEN
	 IGAMMA(IEQ) = 0

	 IQVAL(IEQ) = 1
	ENDIF

C  IN THIS CASE (IUNIQ(IEQ)=1), THE USER MUST ENTER ONE SET OF C'S
C  BELOW TO BE USED FOR ALL PATIENTS (IF IGAMMA(IEQ)=2, THESE WILL BE

C  INITIAL ESTIMATES ONLY). SO SET IASS(IEQ) = 2.


	IASS(IEQ) = 2

	ENDIF



	IF(IUNIQ(IEQ) .EQ. 0) THEN

 7015   WRITE(*,1126)
 1126   FORMAT(/' ENTER 1 IF GAMMA IS TO REMAIN FIXED AT 1.0;'/
     6' ENTER 2 IF AN UPDATED ESTIMATE OF GAMMA IS TO BE FOUND: ')
	READ(*,*,ERR=7015) IGAM
	IF(IGAM .LT. 1 .OR. IGAM .GT. 2) GO TO 7015

C  CHANGE IGAM TO IGAMMA, AND UPDATE IQVAL IF NECESSARY.

	IF(IGAM .EQ. 1) IGAMMA(IEQ) = 1

	IF(IGAM .EQ. 2) THEN

	 IGAMMA(IEQ) = 0
	 IQVAL(IEQ) = 1

	ENDIF

 1120	WRITE(*,119)
  119 FORMAT(//' SELECT ONE OF THE FOLLOWING OPTIONS FOR THE ASSAY '/
     1'		COEFFICIENTS [C0,C1,C2,C3]: '//

     4' ENTER 1 FOR THE DEFAULT OPTION ...'/

     5'         FOR EACH PATIENT, IF THE DATA FILE ALREADY INCLUDES '/
     6'		ASSAY COEFFICIENTS, THOSE COEFFICIENTS WILL BE USED. '/
     7'		OTHERWISE THE COEFFICIENTS YOU ENTER BELOW WILL BE '/
     8'		USED;'/
     7' ENTER 0 IF YOU WOULD LIKE TO BE PROMPTED SO YOU MAY CHOOSE THE'/
     8'		ASSAY COEFFICIENTS ON A PATIENT - BY - PATIENT BASIS.'/
     9'         YOU MAY CHOOSE GENERAL VALUES (WHICH YOU WILL ENTER '/
     1'		BELOW), COEFFICIENTS ALREADY IN THE PATIENT DATA FILE,'/
     2'		IF ANY, OR ANY OTHER INDIVIDUAL COEFFICIENTS: ')
	READ(*,*,ERR=1120) IASS(IEQ)
	IF(IASS(IEQ) .NE. 0 .AND. IASS(IEQ) .NE. 1) GO TO 1120

	ENDIF


 2140   WRITE(*,2141) C0P(IEQ),C1P(IEQ),C2P(IEQ),C3P(IEQ)
     1     ,C4P(IEQ),C5P(IEQ)
 2141   FORMAT(/' ENTER 1 TO LEAVE THE GENERAL VALUES FOR [C0,C1,C2,C3]
     1UNCHANGED; '/
     2' THEY ARE CURRENTLY: ',4(G12.6,1X)//
     2' ENTER 0 TO CHANGE THESE GENERAL VALUES: ')
	READ(*,*,ERR=2140) ICHCS
	IF(ICHCS .NE. 0 .AND. ICHCS .NE. 1) GO TO 2140

	IF(ICHCS .EQ. 1) GO TO 2120

 1140	WRITE(*,1119)
 1119   FORMAT(/' ENTER THE GENERAL VALUES FOR [C0,C1,C2,C3]. THESE ')
	IF(IASS(IEQ) .EQ. 1) WRITE(*,1121)
	IF(IASS(IEQ) .EQ. 2 .AND. IGAMMA(IEQ) .NE. 2) WRITE(*,1122)
	IF(IASS(IEQ) .EQ. 2 .AND. IGAMMA(IEQ) .EQ. 2) WRITE(*,1127)
	IF(IASS(IEQ) .EQ. 0) WRITE(*,1123)
 1121   FORMAT(' WILL BE USED FOR ALL PATIENTS WHOSE DATA FILES DO '/
     1' NOT ALREADY INCLUDE ASSAY COEFFICIENTS: ')

 1122   FORMAT(' WILL BE USED FOR ALL PATIENTS.'//
     1' NOTE: IF YOU WANT TO ENTER THESE VALUES VIA AN OUTPUT FILE FROM
     2A'/
     2' PREVIOUS RUNNING OF THE PROGRAM assbigxx.exe, '/
     3' ENTER THE WORD "FILE": ')
 1123   FORMAT(' WILL BE USED FOR THOSE PATIENTS YOU SELECT BELOW: ')
 1127   FORMAT(' WILL BE INITIAL ESTIMATES ONLY. AN OPTIMUM SET WILL '/
     1' BE CALCULATED BY A PRELIMINARY PROGRAM, '/

     2' assbigxx.exe, FROM THESE ESTIMATES. A TYPICAL INITIAL GUESS'/
     3' IS [.1,.1,.05,.001]:  ')

	IF(IASS(IEQ) .NE. 2 .OR. IGAMMA(IEQ) .EQ. 2) THEN
	 READ(*,*,ERR=1140) C0P(IEQ),C1P(IEQ),C2P(IEQ),C3P(IEQ)
     1      ,C4P(IEQ),C5P(IEQ)
	ENDIF


	IF(IASS(IEQ) .EQ. 2 .AND. IGAMMA(IEQ) .NE. 2) THEN

	 READ(*,*,ERR=1145) C0P(IEQ),C1P(IEQ),C2P(IEQ),C3P(IEQ)
     1      ,C4P(IEQ),C5P(IEQ)
	 GO TO 2120

 1145    WRITE(*,1131)
 1131    FORMAT(/' ENTER THE NAME OF THE OUTPUT FILE (FROM '/
     1' assbigxx.exe); IT WILL BE   ASSxxxx   WHERE xxxx IS THE '/
     2' 4-DIGIT NUMBER ASSIGNED TO THAT RUN;'/
     1'   ENTER -99 TO SEE ALL OR A PART OF YOUR DIRECTORY: ' )
          READ(*,102) FILASS

	  IF(FILASS(1:3) .EQ. '-99') THEN
             CALL SEEDIR(PATH,NOB,FILASS,OSName,ListDir)
          ENDIF

C  CALL FULLNAME WHICH CONVERTS THE FILENAME TO PATHFILE, THE COMPLETE
C  NAME OF THE FILE, WHICH INCLUDES THE PATH (IF THE PATH IS NOT THE
C  CURRENT DIRECTORY).

	  TMPFILE = ' '
	  TMPFILE = FILASS
	  CALL FULLNAME(PATH,TMPFILE,PATHFILE)
     	  OPEN(26,FILE=PATHFILE,ERR=1155,STATUS='OLD',POSITION='APPEND')
	  GO TO 1150
 1155     WRITE(*,5316) PATHFILE
	  GO TO 1140

C  FILASS HAS BEEN OPENED AT THE END OF THE FILE. BACKSPACE AND READ IN
C  THE C'S FOR OUTPUT EQUATION IEQ. ALSO, UPDATE IQVAL(IEQ).

 1150	  BACKSPACE(26)

	  BACKSPACE(26)
	  READ(26,444) READLINE
  444     FORMAT(A1000)
	  IF(READLINE(2:18) .NE. 'ESTIMATES FOR [C0') GO TO 1150
	  IF(IEQ .EQ. 1) GO TO 2155

	  DO I=1,IEQ-1
	   READ(26,*)
	  END DO

 2155	  READ(26,*) C0P(IEQ),C1P(IEQ),C2P(IEQ),C3P(IEQ)
     1      ,C4P(IEQ),C5P(IEQ)
	  CLOSE(26)


	  IQVAL(IEQ) = 4

	ENDIF

C THE ABOVE ENDIF IS FOR THE
C   IF(IASS(IEQ) .EQ. 2 .AND. IGAMMA(IEQ) .NE. 2)  CONDITION.

 2120   CONTINUE


 1160	WRITE(*,2119)
 2119   FORMAT(//' NOTE: DURING THIS PREPARATION PROGRAM, EACH SUBJECT'/
     1'       WILL HAVE HIS/HER ASSAY COEFFICIENTS WRITTEN TO THE END'/
     2'       OF HIS/HER WORKING COPY PATIENT FILE. IF COEFFICIENTS '/
     3'       ARE ALREADY THERE FROM A PREVIOUS RUN, THEY WILL BE '/
     4'       OVERWRITTEN.'//)



	CALL PAUSE

C
C
	ENDIF
C
C

        WRITE(*,112) NDRUG
  112   FORMAT(/' THE ACTIVE (SALT) FRACTION OF EACH OF THE ',I1,' DRUG(
     1S) FOLLOWS.')
        
        DO I = 1,NDRUG
         WRITE(*,113) I,AF(I)
  113    FORMAT(' AF FOR DRUG ',I1,' IS ',G12.6)
        END DO


	CALL CHANGE(ICHANG)

	IF(ICHANG .EQ. 0) THEN

 5150   WRITE(*,129)
  129   FORMAT(//' ENTER THE ACTIVE (SALT) FRACTION OF EACH DRUG. AS '/
     1' AN EXAMPLE, THE A.F. OF THEOPHYLLINE IS 1.0, WHILE THAT OF'/
     2' AMINOPHYLLINE IS TYPICALLY BETWEEN .79 AND .85, DEPENDING ON'/
     3' THE PREPARATION. '//
     4' EACH AF MUST BE A POSITIVE NUMBER LESS THAN OR EQUAL TO 1.0.'/)
       
        DO I = 1,NDRUG
         WRITE(*,1129) I
 1129    FORMAT(' AF FOR DRUG ',I1,': ')
         READ(*,*,ERR=5150) AF(I)
         IF(AF(I) .LE. 0.0 .OR. AF(I) .GT. 1.0) GO TO 5150
        END DO

	ENDIF


C  IF THERE IS AT LEAST ONE OUTPUT EQUATION, IEQ, WITH IGAMMA(IEQ) = 2,
C  THEN THE PRELIMINARY PROGRAM, assbigxx.exe, WILL BE RUN
C  (IRUNIT = 0 BELOW).

C  IF NO IGAMMA(IEQ) = 2, THEN THE ANALYSIS PROGRAM,
C  itbig9x.exe WILL BE RUN (IRUNIT = 1 BELOW). NOTE THAT THE NAME
C  OF THE "ENGINE" PROGRAM IS itbig9x.exe ON A PC (CURRENTLY - FOR THE
C  PC PREP PROGRAM, ITBIG9.FOR).

	IRUNIT = 1
	DO IEQ=1,NUMEQT
	 IF(IGAMMA(IEQ) .EQ. 2) IRUNIT = 0
	END DO

	IF(IRUNIT .EQ. 1) THEN

	IF(TOL .GE. 1.D-7) WRITE(*,6101) TOL,MAXIT
	IF(TOL .LT. 1.D-7) WRITE(*,6102) TOL,MAXIT
 6101   FORMAT(/' THE STOPPING TOLERANCE FOR THE ITERATIONS IS ',G13.7,/
     1' THE MAXIMUM NO. OF ITERATIONS IS ',I9,/)

 6102   FORMAT(/' THE STOPPING TOLERANCE FOR THE ITERATIONS IS ',G13.7,/
     1' THE MAXIMUM NO. OF ITERATIONS IS ',I9,/)
C
C
	CALL CHANGE(ICHANG)
	IF(ICHANG .EQ. 0) THEN
C
C
	WRITE(*,*)' ENTER THE STOPPING TOLERANCE FOR THE ITERATIONS: '
 6100   READ(*,*,ERR=6105) TOL
	GO TO 4195
 6105   WRITE(*,*)' SEE ABOVE; PLEASE ENTER A REAL NUMBER: '
	GO TO 6100
C
C
 4195   MMAXIT = 40999
      	WRITE(*,123) MMAXIT+1
  123   FORMAT(/' ENTER THE MAX NO. OF ITERATIONS DESIRED (LESS THAN ',I
     15,'): ')
        READ(*,*,ERR=4195) MAXIT
	IF(MAXIT .LE. 0 .OR. MAXIT .GT. 40999) GO TO 4195
C
C
	ENDIF
C
C
        WRITE(*,4986) XDEV
 4986   FORMAT(//' THE PARAMETER RANGES WHICH WILL BE SUPPLIED '/
     1' TO THE 2ND PART (NPEM) OF THIS TWO-PART PROGRAM WILL '/
     2' BE    ',F10.3,'    STANDARD DEVIATIONS BELOW AND ABOVE EACH'/
     3' POPULATION PARAMETER MEAN. ')
C
C
	CALL CHANGE(ICHANG)
	IF(ICHANG .EQ. 0) THEN
C
C
 4215	WRITE(*,4988)
 4988   FORMAT(//' THE RANGES, OF THE PARAMETERS TO BE SUPPLIED '/
     1' TO THE 2ND PART (NPEM) OF THIS PROGRAM, WILL BE SOME NUMBER'/
     2' OF S.D. (5 IS A TYPICAL CHOICE) ABOVE AND BELOW EACH '/
     3' POPULATION MEAN (BUT NOT BELOW .00000001). HOW MANY S.D. ABOVE'/

     4' AND BELOW THE MEANS DO YOU WANT THE PARAMETER RANGES TO BE ?'/
     5' ENTER THE NUMBER: ')


	READ(*,*,ERR=4215) XDEV
	IF(XDEV .LE. 0.D0) THEN
	  WRITE(*,*)' THIS NUMBER MUST BE POSITIVE.'
	  GO TO 4215

	ENDIF
C
C
	ENDIF


	ENDIF


C  THE ABOVE END DO IS FOR THE  IF(IRUNIT .EQ. 1)  CONDITION.


C  IF IRUNIT = 0, PUT IN DEFAULT VALUES FOR TOL, MAXIT, AND XDEV IN

C  CASE THE USER SAVES INSTRUCTION INFO TO A FILE (SO IF THE USER USES
C  THAT INSTRUCTION FILE, TOL, MAXIT, AND XDEV WILL NOT BE 0).

	IF(IRUNIT .EQ. 0) THEN
	 TOL = 1.D-3
	 MAXIT = 10
	 XDEV = 5.D0
	ENDIF
C
C

 5005	WRITE(*,5001)
 5001   FORMAT(///' ENTER 1 IF ALL INSTRUCTIONS ARE NOW CORRECT;'/
     2' ENTER 0 OTHERWISE: ')
        READ(*,*,ERR=5005) ICHANG


	IF(ICHANG .NE. 0 .AND. ICHANG .NE. 1) GO TO 5005
        IF(ICHANG .EQ. 0) GO TO 5020


	RETURN
	END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
	SUBROUTINE CHANGE(ICHANG)
C
C  THIS SUBROUTINE IS CALLED BY SUBROUTINE VERIF1 TO HAVE THE USER CHECK
C  WHETHER HIS INPUT INFO IS CORRECT OR NEEDS TO BE CHANGED.
C
C  INPUT: NOTHING
C
C  OUTPUT:
C
C  ICHANG = 1 IF INFO PRINTED PREVIOUSLY TO THE SCREEN IS CORRECT.
C	  = 0 IF INFO PRINTED PREVIOUSLY TO THE SCREEN SHOULD BE
C	      CHANGED.

C
   10 	WRITE(*,1)
    1   FORMAT(//' ENTER 1 IF THE ABOVE INFORMATION IS CORRECT;'/
     1' ENTER 0 IF IT SHOULD BE CHANGED: ')
        READ(*,*,ERR=10) ICHANG
	IF(ICHANG .NE. 0 .AND. ICHANG .NE. 1) GO TO 10
        RETURN
	END

C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
	SUBROUTINE EXTRAOPT(PATH,NOB,MAXSUB,PAREST,SERNUM,
     1  YPREDPOP,YPREDBAY,PARBAY,YO,MAXOBDIM,OSName,ListDir,
     2  DeleteFile,ClearScreen,MAXNUMEQ)

C  THIS ROUTINE, CALLED BY MAIN, EXAMINES THE RESULTS FROM A PREVIOUS
C  RUN. IN PARTICULAR, IT READS IN INFO FROM LAST CYCLE PARAMETER FILE
C  AND THE OUTPUT FILE FROM A PREVIOUS RUN. IT ALSO CONCATENATES PATIENT
C  DATA FILES HAVING NAMES INDICATED IN THE OUTPUT FILE.

C  NOTE BELOW THAT MANY COMMENTS HAVE BEEN SUPPRESSED. TO SEE
C  DETAILS, EXAMINE SIMILAR CODE IN THE PC VERSION.

	IMPLICIT REAL*8(A-H,O-Z)

     	DIMENSION YO(MAXOBDIM,MAXNUMEQ),PAREST(MAXSUB,30),
     1 SERNUM(MAXSUB),COEFF(999,5),VALFIX(20),
     2 YPREDPOP(MAXSUB,MAXNUMEQ,MAXOBDIM,2),
     3 YPREDBAY(MAXSUB,MAXNUMEQ,MAXOBDIM,2),
     3 PARBAY(MAXSUB,2,30),C0(MAXNUMEQ),C1(MAXNUMEQ),
     4 C2(MAXNUMEQ),C3(MAXNUMEQ),GAMMA(MAXNUMEQ),
     4 COVAL(999,26),IPATVEC(MAXSUB),AF(7),RANFIXEST(20) 

C??? NOTE THAT COEFF HAS 1ST DIMENSION = 999, RATHER THAN MAXSUB ...
C    BECAUSE IT IS PASSED IN COMMON/TOSCAT, AND THIS ELIMINATES
C    HAVING TO PASS MAXSUB TO SCATPL10.FOR. IF MAXSUB EVER IS
C    INCREASED BEYOND 999, MUST INCREASE DIMENSION OF COEFF.
C    SIMILARLY FOR NUMBER(MAXSUB) --> NUMBER(999), SO DATABLK1.FOR
C    WON'T HAVE TO BE CHANGED.
C???

	REAL YYPRED(150000),YYJ(150000),AMIN,AMAX,XCOV(999),YCOV(999)

	CHARACTER READLINE*1000,OUTFIL*20,NUMBER(999)*3,PATFIL*20,EXT*3,
     1  PREFIX*5,PAR(30)*11,OUTSINGL*20,
     2  OPT6FIL*20,MNAME*7,PARFIX(20)*11,PATH*60,TMPFILE*13,PATHFILE*73,
     3  XLABEL*20,YLABEL*20,XLABEL2*10,YLABEL2*10,OUTOPT7*20,
     4  DESCR(26)*20,READLIN1*1000,OSName*20,ListDir*10,DeleteFile*3,
     5  CSVFILE*20,ClearScreen*6,PARRANFIX(20)*11

        CHARACTER*10 DATDAY,TIMDAY,ZONEDAY,ERRFIL*20


	  INTEGER IDTDAY(10)

	COMMON/TOBLK/NUMBER
	COMMON/TOSCAT/MAXSER,MINSER,SERMEN,SERSD,COEFF

      COMMON/ERROR/ERRFIL
C  COMMON/ERROR/ IS SUPPLIED TO ALL THE ROUTINES WHICH COULD WRITE TO
C  ERRFIL. 



    1   FORMAT(A20)
    2   FORMAT(A1000)


 5320	WRITE(*,5321)
 5321   FORMAT(//' ENTER THE NAME OF THE OUTPUT FILE FROM A PREVIOUS'/
     1' RUN.'//
     4' IT WILL BE OF THE FORM OUTFxxxx, WHERE xxxx IS THE JOB NUMBER'/
     5' ASSIGNED TO THE RUN.'//)
	WRITE(*,*)' ENTER -99 TO SEE ALL OR A PART OF YOUR DIRECTORY: '
        READ(*,1) OUTFIL
	IF(OUTFIL(1:3) .EQ. '-99') THEN
           CALL SEEDIR(PATH,NOB,OUTFIL,OSName,ListDir)
        ENDIF

C  CALL FULLNAME WHICH CONVERTS THE FILENAME TO PATHFILE, THE COMPLETE
C  NAME OF THE FILE, WHICH INCLUDES THE PATH (IF THE PATH IS NOT THE
C  CURRENT DIRECTORY).

      TMPFILE = ' '
	TMPFILE = OUTFIL
	CALL FULLNAME(PATH,TMPFILE,PATHFILE)
      OPEN(45,FILE=PATHFILE,ERR=5335,STATUS='OLD')
	GO TO 5340
5335  WRITE(*,5316) PATHFILE
5316   FORMAT(//' THE FOLLOWING FILE DOES NOT EXIST ... '/
     1'    ',A73)

	GO TO 5320

 5340 CONTINUE

C  NOTE THAT BECAUSE LOTS OF NEW INFO (NSUBTOT, IPATVEC) IS INCLUDED IN
C  THE OUTPUT FILE, IN ORDER FOR THIS TO BE A LEGITIMATE OUTPUT FILE, IT
C  MUST HAVE 'REM_FRN JUL_10, OR A LATER DATE ON LINE 3. IF NOT, HAVE
C  THE USER TRY AGAIN. 'REM_FRN JUL_10' IS THE FIRST CODE IN THE NEW
C  MULTIPLE DRUG SERIES OF IT2B PROGRAM.

	IICODE = -1
	READ(45,*)
	READ(45,*)
      READ(45,2) READLIN1
      IF(READLIN1(1:16) .EQ. '  REM_FRN JUL_10') IICODE = 2
      IF(READLIN1(1:16) .EQ. '  REM_FRN JUL_11') IICODE = 3
      IF(READLIN1(1:16) .EQ. '  REM_FRN MAR_16') IICODE = 4


	IF(IICODE .EQ. -1) THEN
        WRITE(*,5313) OUTFIL
 5313   FORMAT(//' FILE ',A20,' IS NOT AN OUTPUT FILE'/
     1' FROM A RECENT VERSION OF THE PROGRAM. IT MUST HAVE --'/
     2' REM_FRN JUL_10, OR A LATER DATE, ON LINE 3, STARTING AT COLUMN 3
     3.'/)
        GO TO 5320
	ENDIF

C  1ST PRINT TO THE SCREEN A SUMMARY OF THE INPUT INFO FOR THE RUN, SO
C  THE USER CAN VERIFY THAT THIS RUN IS THE ONE HE WANTS.

  110	WRITE(*,*)
	WRITE(*,*)
      WRITE(*,*)' THE FOLLOWING INFO SUMMARIZES THE INPUT INSTRUCTIONS'
	WRITE(*,*)' FOR THE RUN WHOSE OUTPUT FILE YOU JUST ENTERED: '
	WRITE(*,*)

	ILINES=3

C  ILINES IS THE RUNNING TOTAL OF LINES PRINTED TO THE SCREEN SINCE THE
C  LAST PAUSE. EVERYTIME IT GETS TO 20, PAUSE THE OUTPUT.

  150	READ(45,2) READLINE
      ILINES=ILINES+1


      WRITE(*,11) READLINE(1:72)

   11 FORMAT(' ',A72)


	IF(ILINES .EQ. 20) THEN
	  CALL PAUSE
	  ILINES=0
	ENDIF

	IF(READLINE(2:12) .NE. 'THE FOLLOWI') GO TO 150

  160	WRITE(*,12)
   12 FORMAT(//' ENTER 1 IF THE OUTPUT FILE DESCRIBED ABOVE IS THE'/
     1'         ONE FROM THE RUN YOU WISH TO EXAMINE IN DETAIL;'/
     2' ENTER 0 IF YOU WISH TO ENTER ANOTHER OUTPUT FILE: ')
	READ(*,*,ERR=160) IANOT
	IF(IANOT .NE. 0 .AND. IANOT .NE. 1) GO TO 160


	IF(IANOT .EQ. 0) THEN
	  CLOSE(45)
	  GO TO 5320
	ENDIF

	REWIND(45)

C  IF THIS IS A COMBINED OUTPUT FILE, IICODE .GE. 2; IF IT'S A SIMPLE
C  OUTPUT FILE, IICODE=1 (SEE ABOVE). NOTE THAT IICODE = 1 IS NOT
C  ALLOWED AS OF ITBIG9.FOR

C  SEPARATE OUTFIL INTO 4 FILES, FILE 25 (WHICH
C  WILL BE THE SAME AS THE OLD OUTPUT FILE), FILE 28 (WHICH WILL BE THE
C  SAME AS THE OLD LAST CYCLE PARAMETER FILE), FILE 27 (WHICH WILL BE
C  THE CONCATENATED PATIENT DATA FILE), AND FILE 47 (WHICH WILL BE THE
C  it2bdriv.f file). CALL ROUTINE SEPARATE TO DO THIS.

C  THEN CALL GETNUM TO READ DOWN IN FILE 27 TO GET THE VALUE, NUMEQT
C  (NO. OF OUTPUT EQUATIONS).

	 CALL SEPARATE
	 CALL GETNUM(NUMEQT)

C READ IN REQUIRED INFO BELOW.

   50    READ(25,2) READLINE
         IF(READLINE(2:15) .NE. 'THE SUBJ. FILE') GO TO 50
         READ(25,2) READLINE
	   PREFIX = READLINE(9:13)
	   EXT    = READLINE(24:26)

        IF(IICODE .GE. 3) THEN

   55    READ(25,2) READLINE
         IF(READLINE(2:29) .NE. 'THE SUBJECT INFORMATION IS S') GO TO 55
         READ(25,1) CSVFILE
        ENDIF

C  READ IN BOTH NSUBTOT AND NSUB AND THEN CALL ROUTINE GETIPATFF WHICH
C  READS THIS PORTION OF FILE 25 TO OBTAIN IPATVEC. NOTE THE 1ST
C  ARGUMENT TELLS GETIPATFF TO READ FILE 25.

C  NOTE THAT IF IERRR RETURNS AS -1, THERE IS A PROBLEM WITH THE
C  PATIENT NO. INFO ON THE FILE. IN THIS CASE, THE PROBLEM HAS ALREADY
C  BEEN WRITTEN TO THE SCREEN. SO STOP.

	   CALL GETNSUB2(NSUBTOT)
	   CALL GETNSUB(NSUB)
	   CALL GETIPATFF(25,NSUBTOT,NSUB,MAXSUB,IPATVEC,IERRR)


	   IF(IERRR .EQ. -1) STOP

        IF(IICODE .EQ. 2) THEN

  210    READ(25,2) READLINE
         IF(READLINE(2:10) .EQ. 'ACTIVE (S') THEN
          BACKSPACE(25)
          READ(25,164) AFSCALAR
  164     FORMAT(T27,G12.6)
          GO TO 165
         ENDIF

         GO TO 210

        ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(IICODE .EQ. 2)  CONDTITION.

        IF(IICODE .GE. 3) THEN


 1210   READ(25,2) READLINE
        IF(READLINE(2:17) .EQ. 'THE NO. OF DRUGS') THEN
         READ(25,*) NDRUG


         READ(25,*) 
         READ(25,*)
         READ(25,*)
         READ(25,*) (AF(I),I=1,NDRUG)
         GO TO 165

        ENDIF

        GO TO 1210

        ENDIF


C  THE ABOVE ENDIF IS FOR THE  IF(IICODE .GE. 3)  CONDTITION.



  165	CLOSE(25)


C  IF IICODE .EQ. 2, WHICH IT ALWAYS IS AS OF ITBIG9.FOR, CONCATENTATED
C  PATIENT FILE 27 WAS ESTABLISHED ABOVE (BY SUBROUTINE SEPARATE),

C  NUMEQT WAS OBTAINED ABOVE (BY SUBROUTINE GETNUM), AND FILE 28 WAS
C  ESTABLISHED ABOVE AND OPENED AT THE END OF THE FILE (BY SUBROUTINE
C  SEPARATE). IN THIS CASE, GO TO LABEL 6320

C  NOTE THAT FILE 28 IS AT THE END OF ITS FILE.

   90	BACKSPACE(28)
	BACKSPACE(28)
	READ(28,2) READLINE
	IF(READLINE(2:13) .NE. 'SUMMARY INFO') GO TO 90
	READ(28,*)
	READ(28,*)

	READ(28,5301) NSUB
 5301 FORMAT(T28,I3)
	READ(28,*)
	READ(28,5302) NVAR
 5302 FORMAT(T30,I2)
	READ(28,*)
	READ(28,*)
	READ(28,5303) (PAR(I),I=1,NVAR)
 5303 FORMAT(30(A11,1X))


C  READ NOFIX AND VALFIX, WHICH ARE NEEDED IF THE USER SELECTS OPTION
C  6 BELOW AND THEN WANTS TO STORE INFO INTO FILE 33. ALSO READ IN
C  NRANFIX AND RANFIXEST IF IICODE .GE. 4.


  190	READ(28,2) READLINE
	IF(READLINE(2:22) .NE. 'THE NUMBER OF FIXED V') GO TO 190
	BACKSPACE(28)
	READ(28,191) NOFIX
  191 FORMAT(T41,I2)

	IF(NOFIX .GT. 0) THEN
	 READ(28,*)
	 READ(28,*)
	 DO I=1,NOFIX
	  READ(28,192) PARFIX(I),VALFIX(I)
	 END DO
  192  FORMAT(T2,A11,3X,G17.10)
	ENDIF


C  READ IN NRANFXI, ETC. IF IICODE .GE. 4.

      NRANFIX = 0

      IF(IICODE .GE. 4) THEN

  195	READ(28,2) READLINE
	IF(READLINE(2:22) .NE. 'THE NUMBER OF RANFIX ') GO TO 195
	BACKSPACE(28)
	READ(28,193) NRANFIX
  193 FORMAT(T37,I2)

	IF(NRANFIX .GT. 0) THEN
	 READ(28,*)
	 READ(28,*)
       READ(28,*)
	 DO I=1,NRANFIX
	  READ(28,192) PARRANFIX(I),RANFIXEST(I)
	 END DO
	ENDIF

      ENDIF
C  THE ABOVE ENDIF IS FOR THE  IF(IICODE .GE. 4)  CONDITION.



C  REWIND FILE 28 TO GET PAREST INFO.

	REWIND(28)

	DO 40 ISUB=1,NSUB

   30   READ(28,2) READLINE

	IF(READLINE(2:11) .NE. 'SUBJECT NO') GO TO 30

	  READ(28,*)
	  READ(28,*)
	  READ(28,*)
	  READ(28,*)
	  READ(28,*) (PAREST(ISUB,J),J=1,NVAR)

   40     CONTINUE



C  THE NEXT INFO TO BE READ IN FROM FILE 28 IS GAMMA(IEQ),IEQ=1,NUMEQT.
C  IF IICODE .GE. 2, NUMEQT WAS OBTAINED ABOVE BY ROUTINE GETNUM.
C  IF IICODE .EQ. 1, NUMEQT MUST BE OBTAINED FIRST (FROM SUBROUTINE
C  GETNUMEQ).

  505   READ(28,2) READLINE
        IF(READLINE(2:15) .NE. 'A UNIQUE GAMMA') GO TO 505


        READ(28,*)
        READ(28,*)
        DO I=1,NUMEQT
         READ(28,*) GAMMA(I)
        END DO

C  NOTE THAT FILE 28 WILL BE CLOSED BELOW AFTER ADDITIONAL INFO IS READ.
C  IF IICODE = 2, PATIENT DATA INFO IS ALREADY IN FILE 27; IF
C  IICODE = 1, THIS INFO CAN'T BE READ UNTIL PATIENT DATA INFO IS
C  STACKED INTO FILE 27 SINCE NOBSER IS NEEDED FOR EACH PATIENT.

C  NOW THAT FILE 27 HAS BEEN ESTABLISHED, CAN READ IN REST OF FILE 28.


C   YPREDPOP(JSUB,IEQ,IOBS,ICEN) = THE PREDICTED VALUE FOR Y FOR SUBJECT

C     JSUB, FOR OUTPUT EQUATION IEQ, FOR OBSERVATION IOBS, FOR ICEN =
C     1 (MEANS) OR 2 (MEDIANS), WHERE THE MEANS AND MEDIANS ARE FROM THE
C     FINAL CYCLE POPULATION ESTIMATES.

C   YPREDBAY(JSUB,IEQ,IOBS,ICEN) = THE PREDICTED VALUE FOR Y FOR SUBJECT
C     JSUB, FOR OUTPUT EQUATION IEQ, FOR OBSERVATION IOBS, FOR ICEN =
C     1 (MEANS) OR 2 (MEDIANS), WHERE THE MEANS AND MEDIANS ARE SUBJECT
C     JSUB'S MAP BAYESIAN POSTERIOR PARAMETER ESTIMATES.

C   PARBAY(JSUB,ICEN,J) = THE MAP BAYESIAN PARAMETER ESTIMATE, USING
C     THE POPULATION ESTIMATES FROM THE FINAL CYCLE
C     (ICEN=1 --> MEANS; ICEN=2 --> MEDIANS) FOR
C     SUBJECT JSUB FOR PARAMETER J.



	REWIND(27)

  510  READ(28,2) READLINE

	 IF(READLINE(2:25) .NE. 'CYCLE POPULATION MEDIANS') GO TO 510
	 READ(28,*)

	 DO JSUB=1,NSUB
	  CALL FILRED(NOBSER,YO,C0,C1,C2,C3,C4,C5,MAXOBDIM,MAXNUMEQ)




	  DO IEQ=1,NUMEQT
	   DO IOBS=1,NOBSER
	    READ(28,*) (YPREDPOP(JSUB,IEQ,IOBS,ICEN),ICEN=1,2)
	   END DO
	  END DO
	 END DO


	REWIND(27)

  515    READ(28,2) READLINE


	 IF(READLINE(2:17) .NE. 'MEDIANS), FOLLOW') GO TO 515
	 READ(28,*)

	 DO JSUB=1,NSUB
	  CALL FILRED(NOBSER,YO,C0,C1,C2,C3,C4,C5,MAXOBDIM,MAXNUMEQ)
	  DO IEQ=1,NUMEQT
	   DO IOBS=1,NOBSER
	    READ(28,*) (YPREDBAY(JSUB,IEQ,IOBS,ICEN),ICEN=1,2)
	   END DO
	  END DO
	 END DO

  520    READ(28,2) READLINE
	 IF(READLINE(2:28) .NE. 'AND THEN ON THE FINAL CYCLE') GO TO 520
	 READ(28,*)

	 DO JSUB=1,NSUB
	  DO J=1,NVAR
	   READ(28,*) (PARBAY(JSUB,ICEN,J),ICEN=1,2)
	  END DO
	 END DO


	CLOSE(28)


C  SET ICOVHAVE = 0, WHICH MEANS THAT THE COVARIATE VALUES
C  FOR EACH SUBJECT HAVE NOT YET BEEN STORED INTO ARRAY COVAL.

	ICOVHAVE = 0

 7185   WRITE(*,7186)
 7186   FORMAT(/' ENTER 1 TO SEE THE LAST CYCLE VALUES AGAIN;'/
     6' ENTER 5 TO USE THE FINAL CYCLE POPULATION ESTIMATES TO PREDICT'/
     7'         CONCENTRATION VALUES FOR EACH SUBJECT;'/
     1' ENTER 6 TO GET FINAL MAP BAYESIAN POSTERIOR PARAMETER ESTIMATES'
     1/
     2'         FITTED FOR EACH SUBJECT, USING THE POPULATION ESTIMATES'
     3/
     4'         FROM THE FINAL CYCLE;'/
     8' ENTER 7 TO SEE REGRESSION STATISTICS OF ANY DESCRIPTOR OR'/

     9'         RANDOM VARIABLE VS. ANY OTHER DESCRIPTOR OR RANDOM'/
     1'         VARIABLE (ACROSS ALL SUBJECTS);'/
     7' ENTER 8 TO END THIS PROGRAM AND (IF DESIRED) CONTINUE WITH THE'/
     8'         NPAG PROGRAM: ')

	READ(*,*,ERR=7185) IOPT
	IF(IOPT .NE. 1 .AND. IOPT .NE. 5 .AND. IOPT .NE. 6 .AND. IOPT
     1   .NE. 7 .AND. IOPT .NE. 8) GO TO 7185


	IF(IOPT .EQ. 8) THEN

C  IF IICODE .GE. 2, FILES 25,27,28 AND 47 WERE OPENED AND GIVEN

C  NAMES (JUNKTRASH000_) IN SUBROUTINE SEPARATE. IN THIS CASE, CLOSE
C  THESE FILES AND DELETE THESE FILENAMES FROM THE USER'S DIRECTORY.


	 IF(IICODE .GE. 2) THEN
	  CLOSE(28)
	  CLOSE(27)
	  CLOSE(47)
	  CALL SYSTEM(DeleteFile//' JUNKTRASH0001')

	  CALL SYSTEM(DeleteFile//' JUNKTRASH0002')
	  CALL SYSTEM(DeleteFile//' JUNKTRASH0003')
	  CALL SYSTEM(DeleteFile//' JUNKTRASH0004')

	 ENDIF

 	 RETURN

	ENDIF





C  IF IOPT = 1 CALL PRNLAST TO PRINT THE LAST CYCLE OF THE OUTPUT
C  FILE. THIS IS NOT THE COMBINED OUTPUT FILE, JUST THE "CLASSICAL"
C  OUPUT FILE. IF IICODE = 1, IT IS OUTFIL, WHICH RESIDES IN
C  THE PATH INPUT BY THE USER ABOVE. IF IICODE = 2, IT IS THE
C  FILE JUNKTRASH0001, WHICH WAS ESTABLISHED IN CALL SEPARATE ABOVE.

C  EITHER WAY, OPEN THE OUTPUT FILE AND POSITION THE POINTER AT LAST
C  RECORD.


	IF(IOPT .EQ. 1) THEN

	 IF(IICODE .EQ. 1) THEN


C  CALL FULLNAME WHICH CONVERTS THE FILENAME TO PATHFILE, THE COMPLETE
C  NAME OF THE FILE, WHICH INCLUDES THE PATH (IF THE PATH IS NOT THE
C  CURRENT DIRECTORY).

     	  TMPFILE = ' '
	  TMPFILE = OUTFIL
	  CALL FULLNAME(PATH,TMPFILE,PATHFILE)
	  OPEN(25,FILE=PATHFILE,STATUS='OLD',POSITION='APPEND')

	 ENDIF

	 IF(IICODE .GE. 2) THEN

	  OPEN(25,FILE='JUNKTRASH0001',STATUS='OLD',POSITION='APPEND')
	 ENDIF

    	 CALL PRNLAST
	 CLOSE(25)

	 GO TO 7185

	ENDIF



	IF(IOPT .EQ. 5) THEN


 6550	WRITE(*,6546)
 6546   FORMAT(/' ENTER 0 IF YOU WOULD LIKE TO WRITE ALL THE NUMERICAL'/
     1'         RESULTS FROM THIS OPTION TO A FILE; '/
     2' ENTER 1 IF YOU DO NOT WANT TO WRITE THE RESULTS TO A FILE: ')
	READ(*,*,ERR=6550) ISAVFIL
	IF(ISAVFIL .NE. 0 .AND. ISAVFIL .NE. 1) GO TO 6550

C  IF THE USER DOES NOT WANT TO WRITE NUMERICAL RESULTS TO A FILE,
C  SET IPUT = 0.

	IF(ISAVFIL .EQ. 1) IPUT = 0


	IF(ISAVFIL .EQ. 0) THEN


C  SET IPUT = 1 WHICH MEANS THAT ALL NUMERICAL RESULTS WILL BE WRITTEN
C  TO THE FILE THE USER SELECTS BELOW.

	IPUT = 1

 5980   WRITE(*,5981)
 5981   FORMAT(/' ENTER THE NAME OF THE OUTPUT FILE TO SAVE ALL THE'/


     1' SCATTERPLOT AND RELATED RESULTS: ')
	READ(*,1) OUTSINGL


C  CALL FULLNAME WHICH CONVERTS THE FILENAME TO PATHFILE, THE COMPLETE
C  NAME OF THE FILE, WHICH INCLUDES THE PATH (IF THE PATH IS NOT THE
C  CURRENT DIRECTORY).

     	TMPFILE = ' '
	TMPFILE = OUTSINGL
	CALL FULLNAME(PATH,TMPFILE,PATHFILE)
	OPEN(31,FILE=PATHFILE,ERR=5970,STATUS='NEW')
	GO TO 5975
 5970   WRITE(*,9826) PATHFILE
 9826   FORMAT(/' THE FOLLOWING FILE ALREADY EXISTS ....'/
     1'    ',A73/

     1' ENTER 0 TO ENTER A NEW FILENAME;'/
     2' ENTER 1 TO OVERWRITE THIS FILE: ')
	READ(*,*,ERR=5970) IFILE
	IF(IFILE .NE. 0 .AND. IFILE .NE. 1) GO TO 5970
	IF(IFILE .EQ. 0) GO TO 5980
	IF(IFILE .EQ. 1) OPEN(31,FILE=PATHFILE)
 5975   CONTINUE


C  PUT THE TIME AND DATE AT THE TOP OF THIS FILE.

C??? FOR ITBIG9.FOR, TIME AND DATE ROUTINES REPLACED BY DATE_AND_TIME.

 	CALL DATE_AND_TIME(DATDAY,TIMDAY,ZONEDAY,IDTDAY)

	WRITE(31,*)
	WRITE(31,*)' TODAY IS ',DATDAY,'; THE TIME IS ',TIMDAY
	WRITE(31,*)
	WRITE(31,*)

	ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(ISAVFIL .EQ. 0)  CONDITION.



 9500   WRITE(*,9501) NUMEQT
 9501   FORMAT(//' YOUR PATIENT DATA FILES HAVE ',I2,' OUTPUT '/
     1' EQUATION(S). FOR EACH OUTPUT EQUATION, YOU MAY PREDICT LEVELS '/
     2' FOR EACH SUBJECT ASSUMING THAT SUBJECT HAS PARAMETER VALUES '/
     3' EQUAL TO EITHER THE POPULATION MEANS OR THE POPULATION MEDIANS'/
     4' FROM THE FINAL CYCLE. '//
     5' ENTER THE NO. OF THE OUTPUT EQUATION WHOSE LEVELS ARE TO BE'/
     6' PREDICTED: ')
	READ(*,*,ERR=9500) IOUTEQ
	IF(IOUTEQ .LT. 1 .OR. IOUTEQ .GT. NUMEQT) GO TO 9500

 9510   WRITE(*,9502)
 9502   FORMAT(/' ENTER 1 TO USE THE POPULATION MEANS; '/
     1' ENTER 2 TO USE THE POPULATION MEDIANS: ')

	READ(*,*,ERR=9510) ICENTER
	IF(ICENTER .NE. 1 .AND. ICENTER .NE. 2) GO TO 9510

 9505   CONTINUE

C??? FOR ITBIG8.FOR, THE OPTION BREAK STATEMENTS HAVE BEEN REMOVED
C    SINCE THEY'RE NOT RECOGNIZED BY FORTRAN 90.

C  NOW, ALLOW THE USER TO SPECIFY WHICH VALUES WILL BE CALCULATED.


        WRITE(*,9503)

 9503   FORMAT(//' ENTER 1 TO CALCULATE THE PREDICTED CONCENTRATION '/
     1'         LEVELS FOR THE ENTIRE POPULATION OF SUBJECTS AS A WHOLE;
     2'/

     2' ENTER 2 TO CALCULATE THE PREDICTED LEVELS FOR A SELECTED'/
     3'         SUBSET OF SUBJECTS;'/

     4' ENTER 3 TO CALCULATE THE PREDICTED LEVELS FOR EACH SUBJECT, IN'/
     5'         TURN;'/
     6' ENTER 0 TO RETURN TO THE PREVIOUS MENU:  ')
	READ(*,*,ERR=9505) ISCT
	IF(ISCT .LT. 0 .OR. ISCT .GT. 3) GO TO 9505

	IF(ISCT .EQ. 0) THEN
	 IF(ISAVFIL .EQ. 0) CLOSE(31)
	 GO TO 7185
	ENDIF

	IF(ISCT .EQ. 1) ISCAT = 3
	IF(ISCT .EQ. 3) ISCAT = 1
	IF(ISCT .EQ. 2) ISCAT = 2


C  REWIND SUBJECT FILE (27). SUBJECT INFO WILL BE READ IN THE

C  APPROPRIATE ORDER DEPENDING ON THE VALUE OF ISCAT.

	REWIND(27)



	IF(ISCAT .EQ. 1) THEN


C??? FOR ITBIG8.FOR, THE OPTION BREAK STATEMENTS HAVE BEEN REMOVED
C    SINCE THEY'RE NOT RECOGNIZED BY FORTRAN 90.

C??? ALSO, SUBROUTINE GETOUT AND ALL GRAPHICS RELATED CODE HAS BEEN
C    REMOVED AS OF ITBIG8.FOR.

C  FOR EACH SUBJECT, IN TURN, READ THE OBSERVED VALUES, ESTABLISH THE
C  PREDICTED VALUES (VIA YPREDPOP READ IN ABOVE), CALCULATE THE
C  LEAST SQUARES LINE  OBS = A + B*PRED, ALONG WITH ASSOCIATED

C  STATISTICS.

	DO 6000 JSUB=1,NSUB

	CALL FILRED(NOBSER,YO,C0,C1,C2,C3,C4,C5,MAXOBDIM,MAXNUMEQ)

C  STORE PREDICTED AND ACTUAL OBSERVATIONS INTO REAL VECTORS YYPRED AND
C  YYJ. THEY WILL BE SUPPLIED TO SUBROUTINE SCATPLOT (WHICH CALCULATES
C  THE STATISTICS).

C  IT IS POSSIBLE THAT YO MAY HAVE -99'S IN SOME OF ITS NOBSER ENTRIES.
C  -99 --> AN OBSERVATION WAS NOT TAKEN FOR THAT OUTPUT EQUATION AT
C  A PARTICULAR TIME. WHEN STORING THE VALUES IN YO INTO YYJ, IGNORE
C  ANY -99'S. HAVE YYPRED IGNORE THE CORRESPONDING ENTRY FROM
C  YPREDPOP.

	NACTUAL = 0

	DO I=1,NOBSER
	 IF(YO(I,IOUTEQ) .NE. -99.) THEN
	  NACTUAL = NACTUAL + 1
	  YYPRED(NACTUAL) = YPREDPOP(JSUB,IOUTEQ,I,ICENTER)
	  YYJ(NACTUAL) = YO(I,IOUTEQ)
	 ENDIF
	END DO

C  STORE THE C'S FOR THE SELECTED OUTPUT EQUATION INTO C0I,...,C3I,
C  SCALAR VALUES TO BE PASSED TO SUBROUTINE SCATPLOT.

	C0I = C0(IOUTEQ)
	C1I = C1(IOUTEQ)
	C2I = C2(IOUTEQ)
	C3I = C3(IOUTEQ)

	IF(IPUT .EQ. 1) WRITE(31,8518) IOUTEQ
 8518 	FORMAT(//' ... FOR OUTPUT EQUATION ',I2,' ...'/)



C  AS OF MXEM1S40, S.D. = GAMMA*(C0 + C1*Y + C2*Y^2 + C3*Y^3), BUT
C  SUBROUTINE SCATPLOT DOES NOT USE GAMMA --> MULTIPLY EACH C BY GAMMA
C  TO GET THE 'CORRECTED' C'S TO PASS TO SCATPLOT. NOTE THAT AS OF

C  M1_6.FOR, GAMMA IS A VECTOR (GAMMA(IOUTEQ) IS GAMMA VALUE FOR OUTPUT
C  EQUATION IOUTEQ).


	G=GAMMA(IOUTEQ)


 	CALL SCATPLOT(1,ICENTER,IIOUT,IQUAL,JSUB,IPUT,NACTUAL,YYPRED,YYJ,
     1  G*C0I,G*C1I,G*C2I,G*C3I,AMIN,AMAX,0,1,1.D0)

C  NOTE THAT THE LAST TWO ARGUMENTS ARE DEFAULT VALUE FOR IERRMOD AND
C  GAMLAM WHICH ARE USED TO MAKE THIS PROGRAM COMPATIBLE WITH
C  SCAT72X.FOR (WHICH USES IERRMOD AND GAMLAM TO ESTABLISH THE ASSAY
C  S.D.'S).

C  NOTE THAT AMIN AND AMAX ARE RETURNED FROM SCATPLOT. THEY ARE THE MIN
C  AND MAX VALUES (RESPECTIVELY) FOR THE SCALES OF THE PLOT JUST DONE.
C  AS OF ITBIG8.FOR, NO SCATTERPLOTS ARE DONE, SO THE MIN AND
C  MAX VALUES ARE NOT USED.


 6000   CONTINUE


C  GO TO THE MAIN SCATPLOT MENU.

	GO TO 9505


	ENDIF

C  THE ABOVE ENDIF IS FOR THE   IF(ISCAT .EQ. 1)  CONDITION.


	IF(ISCAT .EQ. 2) THEN

 9520	WRITE(*,8504)
 8504   FORMAT(//' ENTER THE SUBJECT NO. WHOSE CALCULATIONS ARE DESIRED;
     1'/
     1' ENTER 0 TO RETURN TO THE PREVIOUS MENU: ')

	READ(*,*,ERR=9520) JSUB
	IF(JSUB .LT. 0 .OR. JSUB .GT. NSUB) GO TO 9520

	IF(JSUB .EQ. 0) GO TO 9505

C  REWIND SUBJECT FILE (27); THEN READ THROUGH JSUB-1
C  SUBJECTS TO REACH THE DESIRED SUBJECT.


	REWIND(27)


	IF(JSUB .GT. 1) THEN
	 DO J=1,JSUB-1
	  CALL FILRED(NOBSER,YO,C0,C1,C2,C3,C4,C5,MAXOBDIM,MAXNUMEQ)
	 END DO
	ENDIF

	CALL FILRED(NOBSER,YO,C0,C1,C2,C3,C4,C5,MAXOBDIM,MAXNUMEQ)

C  STORE PREDICTED AND ACTUAL OBSERVATIONS INTO REAL VECTORS YYPRED AND
C  YYJ. THEY WILL BE SUPPLIED TO SUBROUTINE SCATPLOT (WHICH CALCULATES
C  THE STATISTICS INDICATED ABOVE).


C  IT IS POSSIBLE THAT YO MAY HAVE -99'S IN SOME OF ITS NOBSER ENTRIES.
C  -99 --> AN OBSERVATION WAS NOT TAKEN FOR THAT OUTPUT EQUATION AT
C  A PARTICULAR TIME. WHEN STORING THE VALUES IN YO INTO YYJ, IGNORE
C  ANY -99'S. HAVE YYPRED IGNORE THE CORRESPONDING ENTRY FROM
C  YPREDPOP.

	NACTUAL = 0
	DO I=1,NOBSER
	 IF(YO(I,IOUTEQ) .NE. -99.) THEN
	  NACTUAL = NACTUAL + 1
	  YYPRED(NACTUAL) = YPREDPOP(JSUB,IOUTEQ,I,ICENTER)
	  YYJ(NACTUAL) = YO(I,IOUTEQ)
	 ENDIF
	END DO

C  STORE THE C'S FOR THE SELECTED OUTPUT EQUATION INTO C0I,...,C3I,
C  SCALAR VALUES TO BE PASSED TO SUBROUTINE SCATPLOT.

	C0I = C0(IOUTEQ)
	C1I = C1(IOUTEQ)
	C2I = C2(IOUTEQ)
	C3I = C3(IOUTEQ)


	IF(IPUT .EQ. 1) WRITE(31,8518) IOUTEQ

C  IF IICODE .GE. 2, AND NSUB .LT. NSUBTOT, THEN THE NSUB SUBJECTS USED
C  IN THE ANALYSIS WERE A SUBSET OF THE TOTAL OF NSUBTOT. TELL THE
C  USER WHICH SUBJECT JSUB IS OUT OF THE ENTIRE POPULATION.

        IF(IICODE .GE. 2 .AND. NSUB .LT. NSUBTOT) THEN
	   WRITE(*,8516) JSUB,NSUB,IPATVEC(JSUB),NSUBTOT
 8516    FORMAT(/' SUBJECT NO. ',I4,' AMONG THE ',I4,' "ACTIVE" '/
     1' SUBJECTS ANALYZED IN YOUR RUN, IS SUBJECT NO. ',I4,' IN THE'/
     2' ENTIRE POPULATION OF ',I4,' SUBJECTS.')
        ENDIF



C  AS OF MXEM1S40, S.D. = GAMMA*(C0 + C1*Y + C2*Y^2 + C3*Y^3), BUT
C  SUBROUTINE SCATPLOT DOES NOT USE GAMMA --> MULTIPLY EACH C BY GAMMA
C  TO GET THE 'CORRECTED' C'S TO PASS TO SCATPLOT. NOTE THAT AS OF
C  M1_6.FOR, GAMMA IS A VECTOR (GAMMA(IOUTEQ) IS GAMMA VALUE FOR OUTPUT
C  EQUATION IOUTEQ).

	G=GAMMA(IOUTEQ)

       CALL SCATPLOT(1,ICENTER,IIOUT,IQUAL,JSUB,IPUT,NACTUAL,YYPRED,YYJ,
     1  G*C0I,G*C1I,G*C2I,G*C3I,AMIN,AMAX,0,1,1.D0)

C  NOTE THAT THE LAST TWO ARGUMENTS ARE DEFAULT VALUE FOR IERRMOD AND
C  GAMLAM WHICH ARE USED TO MAKE THIS PROGRAM COMPATIBLE WITH
C  SCAT72X.FOR (WHICH USES IERRMOD AND GAMLAM TO ESTABLISH THE ASSAY
C  S.D.'S).



C  NOTE: AMIN AND AMAX ARE NOT USED UNLESS ISCAT = 1.


C  GO TO THE ISCAT=2 MENU.

	GO TO 9520


	ENDIF


C  THE ABOVE ENDIF IS FOR THE  IF(ISCAT .EQ. 2)  CONDITION


	IF(ISCAT .EQ. 3) THEN


C  STORE THE OBSERVED AND PREDICTED CONCENTRATION VALUES FOR ALL
C  SUBJECTS, AND THEN CALL SCATPLOT.

C  ALSO STORE INTO MATRIX COEFF THE ASSAY NOISE COEFFICIENTS FOR EACH
C  SUBJECT. THEY'LL BE NEEDED IN SUBROUTINE SCATPLOT (COEFF IS PASSED
C  TO SCATPLOT VIA COMMON/TOSCAT). NOTE THAT EACH COEFFICIENT MUST BE
C  MULTIPLIED BY GAMMA(IOUTEQ).

C  JSUBST = RUNNING INDEX OF THE NO. OF CONCENTRATION VALUES ALREADY
C  IN VECTORS YYPRED AND YYJ.



	JSUBST = 0

	DO 7000 JSUB=1,NSUB

	CALL FILRED(NOBSER,YO,C0,C1,C2,C3,C4,C5,MAXOBDIM,MAXNUMEQ)

C  STORE VALUES IN YPREDPOP AND YO INTO THE NEXT NACTUAL LOCATIONS OF
C  REAL VECTORS YYPRED AND YYJ, WHICH WILL BE SUPPLIED TO SUBROUTINE
C  SCATPLOT (WHICH CALCULATES THE STATISTICS INDICATED ABOVE) AFTER
C  LOOP 7000.

C  IT IS POSSIBLE THAT YO MAY HAVE -99'S IN SOME OF ITS NOBSER ENTRIES.
C  -99 --> AN OBSERVATION WAS NOT TAKEN FOR THAT OUTPUT EQUATION AT

C  A PARTICULAR TIME. WHEN STORING THE VALUES IN YO INTO YYJ, IGNORE
C  ANY -99'S. HAVE YYPRED IGNORE THE CORRESPONDING ENTRY FROM
C  YPREDPOP.

	NACTUAL = 0
	DO I=1,NOBSER
	 IF(YO(I,IOUTEQ) .NE. -99.) THEN
	  NACTUAL = NACTUAL + 1
	  YYPRED(JSUBST+NACTUAL) = YPREDPOP(JSUB,IOUTEQ,I,ICENTER)
	  YYJ(JSUBST+NACTUAL) = YO(I,IOUTEQ)
	 ENDIF
	END DO

C  NOTE THAT COEFF(JSUB,1) = NO. OF VALUES FOR THIS OUTPUT EQUATION.

	COEFF(JSUB,1) = NACTUAL
	COEFF(JSUB,2) = C0(IOUTEQ)*GAMMA(IOUTEQ)
	COEFF(JSUB,3) = C1(IOUTEQ)*GAMMA(IOUTEQ)
	COEFF(JSUB,4) = C2(IOUTEQ)*GAMMA(IOUTEQ)
	COEFF(JSUB,5) = C3(IOUTEQ)*GAMMA(IOUTEQ)

	JSUBST = JSUBST + NACTUAL

C  STORE NACTUAL INTO SERNUM(JSUB). BELOW, STATISTICS WILL BE CALCULATED
C  FOR THE NO. OF SERUM LEVELS OVER ALL SUBJECTS.

	SERNUM(JSUB)=NACTUAL


 7000   CONTINUE

C  CALL SUBROUTINE CALCSER TO FIND THE MAX,MIN,MEAN, AND STD. DEV. FOR
C  THE NO. OF OBSERVATIONS (SERUM LEVELS) OVER ALL THE SUBJECTS. THIS
C  INFO IS PASSED IN COMMON/TOSCAT TO SUBROUTINE SCATPLOT (ONLY IN THIS
C  CASE -- ISCAT=3 [ALL SUBJECTS ANALYZED]).

	CALL CALCSER(MAXSUB,NSUB,SERNUM,MAXSER,MINSER,SERMEN,SERSD)


C  JSUBST IS NOW THE TOTAL NO. OF VALUES IN EACH OF YYPRED AND YYJ.
C  NOTE IN THE CALL TO SCATPLOT BELOW, THE 5TH ARGUMENT, -NSUB, MEANS
C  THAT THIS CALL IS FOR ALL THE SUBJECTS TOGETHER.

	IF(IPUT .EQ. 1) WRITE(31,8518) IOUTEQ

C  AS OF MXEM1S40, S.D. = GAMMA*(C0 + C1*Y + C2*Y^2 + C3*Y^3), BUT
C  SUBROUTINE SCATPLOT DOES NOT USE GAMMA --> MULTIPLY EACH C BY GAMMA
C  TO GET THE 'CORRECTED' C'S TO PASS TO SCATPLOT. NOTE THAT AS OF
C  M1_6.FOR, GAMMA IS A VECTOR (GAMMA(IOUTEQ) IS GAMMA VALUE FOR OUTPUT
C  EQUATION IOUTEQ).
C  NO ! AS OF MXEM1S50.FOR, FOR THIS CASE, THE ENTIRE POPULATION, THE
C       THE INDIVIDUAL C'S ARE PASSED TO SCATPLOT VIA MATRIX COEFF -
C 	SEE ABOVE.

	G=GAMMA(IOUTEQ)

 	CALL SCATPLOT(1,ICENTER,IIOUT,IQUAL,-NSUB,IPUT,JSUBST,YYPRED,

     1  YYJ,G*C0I,G*C1I,G*C2I,G*C3I,AMIN,AMAX,0,1,1.D0)

C  NOTE THAT THE LAST TWO ARGUMENTS ARE DEFAULT VALUE FOR IERRMOD AND
C  GAMLAM WHICH ARE USED TO MAKE THIS PROGRAM COMPATIBLE WITH
C  SCAT72X.FOR (WHICH USES IERRMOD AND GAMLAM TO ESTABLISH THE ASSAY
C  S.D.'S).


C  NOTE: AMIN AND AMAX ARE NOT USED UNLESS ISCAT = 1.


C  GO TO THE MAIN SCATPLOT MENU, 9505.

	GO TO 9505


	ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(ISCAT .EQ. 3)  CONDITION



	ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(IOPT .EQ. 5) CONDITION.


	IF(IOPT .EQ. 6) THEN


 6560	WRITE(*,6546)
	READ(*,*,ERR=6560) ISAVFIL
	IF(ISAVFIL .NE. 0 .AND. ISAVFIL .NE. 1) GO TO 6560

C  IF THE USER DOES NOT WANT TO WRITE NUMERICAL RESULTS TO A FILE,
C  SET IPUT = 0.

	IF(ISAVFIL .EQ. 1) IPUT = 0


	IF(ISAVFIL .EQ. 0) THEN

C  SET IPUT = 1 WHICH MEANS THAT ALL NUMERICAL RESULTS WILL BE WRITTEN
C  TO THE FILE THE USER SELECTS BELOW.

	IPUT = 1


 4980   WRITE(*,5981)

	READ(*,1) OUTSINGL


C  CALL FULLNAME WHICH CONVERTS THE FILENAME TO PATHFILE, THE COMPLETE
C  NAME OF THE FILE, WHICH INCLUDES THE PATH (IF THE PATH IS NOT THE
C  CURRENT DIRECTORY).



     	TMPFILE = ' '
	TMPFILE = OUTSINGL
	CALL FULLNAME(PATH,TMPFILE,PATHFILE)
	OPEN(31,FILE=PATHFILE,ERR=4970,STATUS='NEW')
	GO TO 4975
 4970   WRITE(*,9826) PATHFILE
	READ(*,*,ERR=4970) IFILE
	IF(IFILE .NE. 0 .AND. IFILE .NE. 1) GO TO 4970
	IF(IFILE .EQ. 0) GO TO 4980
	IF(IFILE .EQ. 1) OPEN(31,FILE=PATHFILE)
 4975   CONTINUE



C  PUT THE TIME AND DATE AT THE TOP OF THIS FILE.

C??? FOR ITBIG9.FOR, TIME AND DATE ROUTINES REPLACED BY DATE_AND_TIME.

 	CALL DATE_AND_TIME(DATDAY,TIMDAY,ZONEDAY,IDTDAY)

	WRITE(31,*)
	WRITE(31,*)' TODAY IS ',DATDAY,'; THE TIME IS ',TIMDAY

	WRITE(31,*)
	WRITE(31,*)

	ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(ISAVFIL .EQ. 0)  CONDITION.


 8500   WRITE(*,8501) NUMEQT
 8501   FORMAT(//' YOUR PATIENT DATA FILES HAVE ',I2,' OUTPUT '/
     1' EQUATION(S). FOR EACH OUTPUT EQUATION, YOU MAY PREDICT LEVELS'/
     2' FOR EACH SUBJECT ASSUMING THAT SUBJECT HAS PARAMETER VALUES '/
     3' EQUAL TO THE MAP BAYESIAN POSTERIOR PARAMETER ESTIMATES, USING'/
     4' EITHER THE MEANS OR THE MEDIANS OF THE FINAL CYCLE AS THE '/
     5' POPULATION PRIOR PARAMETER ESTIMATES. '//
     6' ENTER THE NO. OF THE OUTPUT EQUATION WHOSE LEVELS ARE TO BE '/
     7' PREDICTED: ')
	READ(*,*,ERR=8500) IOUTEQ
	IF(IOUTEQ .LT. 1 .OR. IOUTEQ .GT. NUMEQT) GO TO 8500

 8515   WRITE(*,8507)
 8507   FORMAT(/' ENTER 1 TO USE THE MEANS OF THE FINAL CYCLE AS THE'/
     1'         PRIOR ESTIMATES; '/
     2' ENTER 2 TO USE THE MEDIANS OF THE FINAL CYCLE AS THE '/
     3'         PRIOR ESTIMATES: ')
	READ(*,*,ERR=8515) ICENTER
	IF(ICENTER .NE. 1 .AND. ICENTER .NE. 2) GO TO 8515


	IF(ICENTER .EQ. 1) MNAME = 'MEANS'
	IF(ICENTER .EQ. 2) MNAME = 'MEDIANS'

 8510 	WRITE(*,8517)
 8517	FORMAT(//' YOU MAY STORE THESE MAP BAYESIAN ESTIMATES INTO A'/
     7' FILE.'//
     8' ENTER 1 TO STORE THE ESTIMATES INTO A FILE; '/
     9' ENTER 0 OTHERWISE:  ')

	READ(*,*,ERR=8510) IFILSTR
	IF(IFILSTR .NE. 0 .AND. IFILSTR .NE. 1) GO TO 8510


	IF(IFILSTR .EQ. 1) THEN


 8780 WRITE(*,*)
	WRITE(*,*)' ENTER THE NAME OF THE OUTPUT FILE WHICH WILL STORE'
	WRITE(*,*)' THESE MAP BAYESIAN ESTIMATES FOR EACH SUBJECT: '


	READ(*,1) OPT6FIL


C  CALL FULLNAME WHICH CONVERTS THE FILENAME TO PATHFILE, THE COMPLETE
C  NAME OF THE FILE, WHICH INCLUDES THE PATH (IF THE PATH IS NOT THE
C  CURRENT DIRECTORY).

      TMPFILE = ' '
	TMPFILE = OPT6FIL
	CALL FULLNAME(PATH,TMPFILE,PATHFILE)
	OPEN(33,FILE=PATHFILE,ERR=8770,STATUS='NEW')
	GO TO 8775
 8770   WRITE(*,9826) PATHFILE
	READ(*,*,ERR=8770) IFILE
	IF(IFILE .NE. 0 .AND. IFILE .NE. 1) GO TO 8770
	IF(IFILE .EQ. 0) GO TO 8780
	IF(IFILE .EQ. 1) OPEN(33,FILE=PATHFILE)
 8775   CONTINUE


C  SUBROUTINE TOPFIL WRITES TO FILE 33 EVERYTHING EXCEPT
C  THE "PROBABILITIES" AND MAP BAYESIAN ESTIMATES FOR EACH SUBJECT.
C  THESE VALUES WILL BE PUT INTO FILE 33 BELOW.

C  NOTE THAT IF IICODE = 2, NDRUG IS UNKNOWN, BUT THE AF FOR ALL THE
C   NDRUG DRUGS WAS THE SAME (AFSCALAR). IN THIS CASE, SET NDRUG = -1
C   AND AF(1) = AFSCALAR SO TOPFIL WILL BE ABLE TO WRITE ACCURATE INFO.

C  NOTE THAT IF IICODE .GE. 3, NDRUG WAS READ IN FROM THE OUTPUT FILE.

      IF(IICODE .EQ. 2) THEN

       NDRUG = -1
       AF(1) = AFSCALAR
      ENDIF


	CALL TOPFIL(NDRUG,AF,NSUB,NVAR,PAR,NOFIX,PARFIX,NRANFIX,
     1 PARRANFIX)

	ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(IFILSTR .EQ. 1)  CONDITION.

	IF(IPUT .EQ. 1) THEN


	 IF(ICENTER .EQ. 1) WRITE(31,8512)
 8512   FORMAT(//' ***************************************************'/
     1' ***************************************************'//
     1' THE FOLLOWING PARAMETER ESTIMATES FOR EACH SUBJECT ARE  '/
     1' POSTERIOR ESTIMATES BASED ON THE POPULATION'//
     2' --------------- MEAN ---------------'//
     2' VECTOR AND COVARIANCE MATRIX FROM THE FINAL REGULAR CYCLE.'//)


	 IF(ICENTER .EQ. 2) WRITE(31,8513)
 8513   FORMAT(//' ***************************************************'/
     1' ***************************************************'//
     1' THE FOLLOWING PARAMETER ESTIMATES FOR EACH SUBJECT ARE  '/
     1' POSTERIOR ESTIMATES BASED ON THE POPULATION'//
     2' --------------- MEDIAN ---------------'//

     2' VECTOR AND COVARIANCE MATRIX FROM THE FINAL REGULAR CYCLE.'//)
	ENDIF


C  NOW WRITE THE PARAMETER ESTIMATES TO THE SCREEN (AND TO THE OUTPUT
C  FILE IF IPUT=1).


	WRITE(*,8502) MNAME
 8502   FORMAT(' ',' FOLLOWING ARE THE MAP BAYESIAN POSTERIOR'/
     1' PARAMETER ESTIMATES FOR EACH SUBJECT, USING THE ',A7,' OF'/
     2' THE FINAL CYCLE POPULATION ANALYSIS AS THE PRIOR: '/)
	WRITE(*,8523) 'SUBJECT','   PROB.      ', (PAR(I),I=1,NVAR)
 8523   FORMAT(1X,A7,2X,A15,2X,30(A11,6X))
 8522   FORMAT(2X,I4,2X,G12.6,5X,30(G12.6,5X))

	ILINES=4

C  ILINES IS THE RUNNING TOTAL OF LINES PRINTED TO THE SCREEN SINCE THE
C  LAST PAUSE. EVERYTIME IT GETS TO 20, PAUSE THE OUTPUT.

	DO JSUB=1,NSUB
	 ILINES=ILINES+1
	 WRITE(*,8522) JSUB,1.D0/NSUB,(PARBAY(JSUB,ICENTER,J),J=1,NVAR)
	 IF(ILINES .EQ. 20) THEN
	  CALL PAUSE
	  ILINES=0
	 ENDIF
	END DO

	CALL PAUSE

	IF(IPUT .EQ. 1) THEN
	 WRITE(31,8523) 'SUBJECT','   PROB.      ', (PAR(I),I=1,NVAR)
	 DO J=1,NSUB
	  WRITE(31,8522) J,1.D0/NSUB,(PARBAY(J,ICENTER,K),K=1,NVAR)
	 END DO
	ENDIF


	IF(IFILSTR .EQ. 1) THEN
	 DO J=1,NSUB
	  WRITE(33,6113) 1.D0/NSUB,(PARBAY(J,ICENTER,K),K=1,NVAR),
     1   (VALFIX(K),K=1,NOFIX),(RANFIXEST(K),K=1,NRANFIX)
	 END DO
	 CLOSE(33)
	ENDIF

 6113   FORMAT(1X,G13.7,3X,32(G12.6,1X))


 8505   CONTINUE

C??? FOR ITBIG8.FOR, THE OPTION BREAK STATEMENTS HAVE BEEN REMOVED
C    SINCE THEY'RE NOT RECOGNIZED BY FORTRAN 90.

        WRITE(*,8503) MNAME


 8503   FORMAT(//' ENTER 1 TO CALCULATE THE PREDICTED CONCENTRATION'/


     1'         LEVELS FOR THE ENTIRE POPULATION OF SUBJECTS AS A WHOLE;
     3'/
     5' ENTER 2 TO CALCULATE THE PREDICTED LEVELS FOR A SELECTED'/
     6'         SUBSET OF SUBJECTS;'/

     8' ENTER 3 TO CALCULATE THE PREDICTED LEVELS FOR EACH SUBJECT, IN'/
     4'         TURN;'/
     6' ENTER 4 TO SEE THE MAP BAYESIAN POSTERIOR PARAMETER ESTIMATES'/
     7'         FOR EACH SUBJECT, USING THE ',A7,' OF THE FINAL CYCLE'/
     8'         POPULATION ANALYSIS AS THE PRIOR;'/
     6' ENTER 0 TO RETURN TO THE PREVIOUS MENU:  ')


	READ(*,*,ERR=8505) ISCT
	IF(ISCT .LT. 0 .OR. ISCT .GT. 4) GO TO 8505

	IF(ISCT .EQ. 0) THEN

	 IF(ISAVFIL .EQ. 0) CLOSE(31)
	 GO TO 7185
	ENDIF

	IF(ISCT .EQ. 1) ISCAT = 3
	IF(ISCT .EQ. 3) ISCAT = 1
	IF(ISCT .EQ. 2) ISCAT = 2
	IF(ISCT .EQ. 4) ISCAT = 4


	IF(ISCAT .EQ. 4) THEN

C  WRITE EACH SUBJECT'S MAP BAYESIAN POSTERIOR PARAMETER ESTIMATES TO
C  THE SCREEN.

	WRITE(*,8502) MNAME
	WRITE(*,8523) 'SUBJECT','   PROB.      ', (PAR(I),I=1,NVAR)

	ILINES=5

C  ILINES IS THE RUNNING TOTAL OF LINES PRINTED TO THE SCREEN SINCE THE
C  LAST PAUSE. EVERYTIME IT GETS TO 20, PAUSE THE OUTPUT.

	DO JSUB=1,NSUB
	 ILINES=ILINES+1
	 WRITE(*,8522) JSUB,1.D0/NSUB,(PARBAY(JSUB,ICENTER,J),J=1,NVAR)

	 IF(ILINES .EQ. 20) THEN
	  CALL PAUSE
	  ILINES=0
	 ENDIF
	END DO

	CALL PAUSE

	GO TO 8505

	ENDIF

C  THE ABOVE ENDIF IS FOR THE IF(ISCAT .EQ. 4) OPTION


C  REWIND SUBJECT FILE (27). SUBJECT INFO WILL BE READ IN THE
C  APPROPRIATE ORDER DEPENDING ON THE VALUE OF ISCAT.


	REWIND(27)


	IF(ISCAT .EQ. 1) THEN


C  FOR EACH SUBJECT, IN TURN, READ THE OBSERVED VALUES, ESTABLISH
C  THE PREDICTED VALUES (VIA MATRIX YPREDBAY), CALCULATE THE
C  LEAST SQUARES LINE  OBS = A + B*PRED, ALONG WITH ASSOCIATED
C  STATISTICS.



	DO 4000 JSUB=1,NSUB

	CALL FILRED(NOBSER,YO,C0,C1,C2,C3,C4,C5,MAXOBDIM,MAXNUMEQ)

C  STORE PREDICTED AND ACTUAL OBSERVATIONS INTO REAL VECTORS YYPRED AND
C  YYJ. THEY WILL BE SUPPLIED TO SUBROUTINE SCATPLOT (WHICH CALCULATES
C  THE STATISTICS INDICATED ABOVE).

C  IT IS POSSIBLE THAT YO MAY HAVE -99'S IN SOME OF ITS NOBSER ENTRIES.
C  -99 --> AN OBSERVATION WAS NOT TAKEN FOR THAT OUTPUT EQUATION AT
C  A PARTICULAR TIME. WHEN STORING THE VALUES IN YO INTO YYJ, IGNORE
C  ANY -99'S. HAVE YYPRED IGNORE THE CORRESPONDING ENTRY FROM
C  YPREDBAY.

	NACTUAL = 0
	DO I=1,NOBSER
	 IF(YO(I,IOUTEQ) .NE. -99.) THEN


	  NACTUAL = NACTUAL + 1
	  YYPRED(NACTUAL) = YPREDBAY(JSUB,IOUTEQ,I,ICENTER)
	  YYJ(NACTUAL) = YO(I,IOUTEQ)
	 ENDIF
	END DO

C  STORE THE C'S FOR THE SELECTED OUTPUT EQUATION INTO C0I,...,C3I,
C  SCALAR VALUES TO BE PASSED TO SUBROUTINE SCATPLOT.

	C0I = C0(IOUTEQ)
	C1I = C1(IOUTEQ)
	C2I = C2(IOUTEQ)
	C3I = C3(IOUTEQ)


	IF(IPUT .EQ. 1) WRITE(31,8518) IOUTEQ

C  AS OF MXEM1S40, S.D. = GAMMA*(C0 + C1*Y + C2*Y^2 + C3*Y^3), BUT

C  SUBROUTINE SCATPLOT DOES NOT USE GAMMA --> MULTIPLY EACH C BY GAMMA
C  TO GET THE 'CORRECTED' C'S TO PASS TO SCATPLOT. NOTE THAT AS OF
C  M1_6.FOR, GAMMA IS A VECTOR (GAMMA(IOUTEQ) IS GAMMA VALUE FOR OUTPUT
C  EQUATION IOUTEQ).

	G=GAMMA(IOUTEQ)


       CALL SCATPLOT(2,ICENTER,IIOUT,IQUAL,JSUB,IPUT,NACTUAL,YYPRED,YYJ,

     1  G*C0I,G*C1I,G*C2I,G*C3I,AMIN,AMAX,0,1,1.D0)

C  NOTE THAT THE LAST TWO ARGUMENTS ARE DEFAULT VALUE FOR IERRMOD AND
C  GAMLAM WHICH ARE USED TO MAKE THIS PROGRAM COMPATIBLE WITH
C  SCAT72X.FOR (WHICH USES IERRMOD AND GAMLAM TO ESTABLISH THE ASSAY
C  S.D.'S).


 4000   CONTINUE


C  GO TO THE MAIN SCATPLOT MENU.

	GO TO 8505


	ENDIF

C  THE ABOVE ENDIF IS FOR THE   IF(ISCAT .EQ. 1)  CONDITION.


	IF(ISCAT .EQ. 2) THEN


 8520	WRITE(*,8504)
	READ(*,*,ERR=8520) JSUB
	IF(JSUB .LT. 0 .OR. JSUB .GT. NSUB) GO TO 8520

	IF(JSUB .EQ. 0) GO TO 8505



C  REWIND SUBJECT FILE (27); THEN READ THROUGH JSUB-1
C  SUBJECTS TO REACH THE DESIRED SUBJECT.

	REWIND(27)

	IF(JSUB .GT. 1) THEN
	 DO J=1,JSUB-1
	  CALL FILRED(NOBSER,YO,C0,C1,C2,C3,C4,C5,MAXOBDIM,MAXNUMEQ)
	 END DO

	ENDIF


	CALL FILRED(NOBSER,YO,C0,C1,C2,C3,C4,C5,MAXOBDIM,MAXNUMEQ)

C  STORE PREDICTED AND ACUTAL CONCENTRATIONS INTO REAL VECTORS YYPRED

C  AND YYJ. THEY WILL BE SUPPLIED TO SUBROUTINE SCATPLOT (WHICH
C  CALCULATES THE STATISTICS INDICATED ABOVE).

C  IT IS POSSIBLE THAT YO MAY HAVE -99'S IN SOME OF ITS NOBSER ENTRIES.
C  -99 --> AN OBSERVATION WAS NOT TAKEN FOR THAT OUTPUT EQUATION AT
C  A PARTICULAR TIME. WHEN STORING THE VALUES IN YO INTO YYJ, IGNORE

C  ANY -99'S. HAVE YYPRED IGNORE THE CORRESPONDING ENTRY FROM
C  YPREDBAY.

	NACTUAL = 0

	DO I=1,NOBSER
	 IF(YO(I,IOUTEQ) .NE. -99.) THEN
	  NACTUAL = NACTUAL + 1
	  YYPRED(NACTUAL) = YPREDBAY(JSUB,IOUTEQ,I,ICENTER)
	  YYJ(NACTUAL) = YO(I,IOUTEQ)
	 ENDIF
	END DO

C  STORE THE C'S FOR THE SELECTED OUTPUT EQUATION INTO C0I,...,C3I,
C  SCALAR VALUES TO BE PASSED TO SUBROUTINE SCATPLOT.

	C0I = C0(IOUTEQ)
	C1I = C1(IOUTEQ)
	C2I = C2(IOUTEQ)
	C3I = C3(IOUTEQ)

	IF(IPUT .EQ. 1) WRITE(31,8518) IOUTEQ

C  AS OF MXEM1S40, S.D. = GAMMA*(C0 + C1*Y + C2*Y^2 + C3*Y^3), BUT
C  SUBROUTINE SCATPLOT DOES NOT USE GAMMA --> MULTIPLY EACH C BY GAMMA
C  TO GET THE 'CORRECTED' C'S TO PASS TO SCATPLOT. NOTE THAT AS OF
C  M1_6.FOR, GAMMA IS A VECTOR (GAMMA(IOUTEQ) IS GAMMA VALUE FOR OUTPUT
C  EQUATION IOUTEQ).

	G=GAMMA(IOUTEQ)

       CALL SCATPLOT(2,ICENTER,IIOUT,IQUAL,JSUB,IPUT,NACTUAL,YYPRED,YYJ,
     1  G*C0I,G*C1I,G*C2I,G*C3I,AMIN,AMAX,0,1,1.D0)

C  NOTE THAT THE LAST TWO ARGUMENTS ARE DEFAULT VALUE FOR IERRMOD AND
C  GAMLAM WHICH ARE USED TO MAKE THIS PROGRAM COMPATIBLE WITH

C  SCAT72X.FOR (WHICH USES IERRMOD AND GAMLAM TO ESTABLISH THE ASSAY
C  S.D.'S).

C  NOTE: AMIN AND AMAX ARE NOT USED UNLESS ISCAT = 1.


C  GO TO THE ISCAT=2 MENU.

	GO TO 8520



	ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(ISCAT .EQ. 2)  CONDITION


	IF(ISCAT .EQ. 3) THEN


C  STORE THE OBSERVED AND PREDICTED CONCENTRATION VALUES FOR ALL
C  SUBJECTS, AND THEN CALL SCATPLOT.


C  ALSO STORE INTO MATRIX COEFF THE ASSAY NOISE COEFFICIENTS FOR EACH
C  SUBJECT. THEY'LL BE NEEDED IN SUBROUTINE SCATPLOT (COEFF IS PASSED

C  TO SCATPLOT VIA COMMON/TOSCAT). NOTE THAT EACH COEFFICIENT MUST BE
C  MULTIPLIED BY GAMMA(IOUTEQ).

C  JSUBST = RUNNING INDEX OF THE NO. OF CONCENTRATION VALUES ALREADY
C  IN VECTORS YYPRED AND YYJ.

	JSUBST = 0


	DO 5000 JSUB=1,NSUB

	CALL FILRED(NOBSER,YO,C0,C1,C2,C3,C4,C5,MAXOBDIM,MAXNUMEQ)

C  STORE VALUES IN YPREDBAY AND YO INTO THE NEXT NACTUAL LOCATIONS OF
C  REAL VECTORS YYPRED AND YYJ, WHICH WILL BE SUPPLIED TO SUBROUTINE
C  SCATPLOT (WHICH CALCULATES THE STATISTICS INDICATED ABOVE) AFTER LOOP
C  5000.

C  IT IS POSSIBLE THAT YO MAY HAVE -99'S IN SOME OF ITS NOBSER ENTRIES.
C  -99 --> AN OBSERVATION WAS NOT TAKEN FOR THAT OUTPUT EQUATION AT
C  A PARTICULAR TIME. WHEN STORING THE VALUES IN YO INTO YYJ, IGNORE
C  ANY -99'S. HAVE YYPRED IGNORE THE CORRESPONDING ENTRY FROM
C  YPREDPOP.

	NACTUAL = 0

	DO I=1,NOBSER
	 IF(YO(I,IOUTEQ) .NE. -99.) THEN
	  NACTUAL = NACTUAL + 1
	  YYPRED(JSUBST+NACTUAL) = YPREDBAY(JSUB,IOUTEQ,I,ICENTER)
	  YYJ(JSUBST+NACTUAL) = YO(I,IOUTEQ)
	 ENDIF
	END DO

C  NOTE THAT COEFF(JSUB,1) = NO. OF VALUES FOR THIS OUTPUT EQUATION.

	COEFF(JSUB,1) = NACTUAL
	COEFF(JSUB,2) = C0(IOUTEQ)*GAMMA(IOUTEQ)
	COEFF(JSUB,3) = C1(IOUTEQ)*GAMMA(IOUTEQ)
	COEFF(JSUB,4) = C2(IOUTEQ)*GAMMA(IOUTEQ)
	COEFF(JSUB,5) = C3(IOUTEQ)*GAMMA(IOUTEQ)

	JSUBST = JSUBST + NACTUAL

C  STORE NACTUAL INTO SERNUM(JSUB). BELOW, STATISTICS WILL BE CALCULATED
C  FOR THE NO. OF SERUM LEVELS OVER ALL SUBJECTS.


	SERNUM(JSUB)=NACTUAL

 5000   CONTINUE


C  CALL SUBROUTINE CALCSER TO FIND THE MAX,MIN,MEAN, AND STD. DEV. FOR
C  THE NO. OF OBSERVATIONS (SERUM LEVELS) OVER ALL THE SUBJECTS. THIS

C  INFO IS PASSED IN COMMON/TOSCAT TO SUBROUTINE SCATPLOT (ONLY IN THIS
C  CASE -- ISCAT=3 [ALL SUBJECTS ANALYZED]).

	CALL CALCSER(MAXSUB,NSUB,SERNUM,MAXSER,MINSER,SERMEN,SERSD)

C  JSUBST IS NOW THE TOTAL NO. OF VALUES IN EACH OF YYPRED AND YYJ.
C  NOTE IN THE CALL TO SCATPLOT BELOW, THE 5TH ARGUMENT, -NSUB, MEANS
C  THAT THIS CALL IS FOR ALL THE SUBJECTS TOGETHER.

	IF(IPUT .EQ. 1) WRITE(31,8518) IOUTEQ

C  AS OF MXEM1S40, S.D. = GAMMA*(C0 + C1*Y + C2*Y^2 + C3*Y^3), BUT
C  SUBROUTINE SCATPLOT DOES NOT USE GAMMA --> MULTIPLY EACH C BY GAMMA
C  TO GET THE 'CORRECTED' C'S TO PASS TO SCATPLOT. NOTE THAT AS OF
C  M1_6.FOR, GAMMA IS A VECTOR (GAMMA(IOUTEQ) IS GAMMA VALUE FOR OUTPUT
C  EQUATION IOUTEQ).
C  NO ! AS OF MXEM1S50.FOR, FOR THIS CASE, THE ENTIRE POPULATION, THE
C       THE INDIVIDUAL C'S ARE PASSED TO SCATPLOT VIA MATRIX COEFF -
C 	SEE ABOVE.

C  NOTE THAT C0I,...,C3I ARE NOT USED IN THIS CASE, SO THEIR VALUES
C  HAVE NO MEANING FOR THIS CALL TO SCATPLOT.

	G=GAMMA(IOUTEQ)


 	CALL SCATPLOT(2,ICENTER,IIOUT,IQUAL,-NSUB,IPUT,JSUBST,YYPRED,

     1  YYJ,G*C0I,G*C1I,G*C2I,G*C3I,AMIN,AMAX,0,1,1.D0)

C  NOTE THAT THE LAST TWO ARGUMENTS ARE DEFAULT VALUE FOR IERRMOD AND
C  GAMLAM WHICH ARE USED TO MAKE THIS PROGRAM COMPATIBLE WITH
C  SCAT72X.FOR (WHICH USES IERRMOD AND GAMLAM TO ESTABLISH THE ASSAY

C  S.D.'S).

C  NOTE: AMIN AND AMAX ARE NOT USED UNLESS ISCAT = 1.


C  GO TO THE MAIN SCATPLOT MENU, 8505.

	GO TO 8505


	ENDIF


C  THE ABOVE ENDIF IS FOR THE  IF(ISCAT .EQ. 3)  CONDITION


	ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(IOPT .EQ. 6) CONDITION.


	IF(IOPT .EQ. 7) THEN


 6570	WRITE(*,6546)
	READ(*,*,ERR=6570) ISAVFIL
	IF(ISAVFIL .NE. 0 .AND. ISAVFIL .NE. 1) GO TO 6570

C  IF THE USER DOES NOT WANT TO WRITE NUMERICAL RESULTS TO A FILE,
C  SET IPUT = 0.

	IF(ISAVFIL .EQ. 1) IPUT = 0


	IF(ISAVFIL .EQ. 0) THEN

C  SET IPUT = 1 WHICH MEANS THAT ALL NUMERICAL RESULTS WILL BE WRITTEN
C  TO THE FILE THE USER SELECTS BELOW.

	IPUT = 1

 7980   WRITE(*,7981)
 7981   FORMAT(/' ENTER THE NAME OF THE OUTPUT FILE TO SAVE ALL THE'/
     1' STATISTICS CALCULATIONS YOU CHOOSE BELOW: ')

	READ(*,1) OUTOPT7

C  CALL FULLNAME WHICH CONVERTS THE FILENAME TO PATHFILE, THE COMPLETE
C  NAME OF THE FILE, WHICH INCLUDES THE PATH (IF THE PATH IS NOT THE
C  CURRENT DIRECTORY).

     	TMPFILE = ' '
	TMPFILE = OUTOPT7
	CALL FULLNAME(PATH,TMPFILE,PATHFILE)
	OPEN(35,FILE=PATHFILE,ERR=7970,STATUS='NEW')
	GO TO 7975
 7970   WRITE(*,9826) PATHFILE
	READ(*,*,ERR=7970) IFILE
	IF(IFILE .NE. 0 .AND. IFILE .NE. 1) GO TO 7970
	IF(IFILE .EQ. 0) GO TO 7980
	IF(IFILE .EQ. 1) OPEN(35,FILE=PATHFILE)
 7975   CONTINUE

C  PUT THE TIME AND DATE AT THE TOP OF THIS FILE.

C??? FOR NPBIG15, TIME AND DATE ROUTINES REPLACED BY DATE_AND_TIME.

 	CALL DATE_AND_TIME(DATDAY,TIMDAY,ZONEDAY,IDTDAY)


	WRITE(35,*)
	WRITE(35,*)' TODAY IS ',DATDAY,'; THE TIME IS ',TIMDAY
	WRITE(35,*)

	WRITE(35,*)


	ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(ISAVFIL .EQ. 0)  CONDITION.


 7700   WRITE(*,7676)
 7676   FORMAT(//' FROM THE FOLLOWING LIST OF COVARIATES AND RANDOM'/
     1' VARIABLE NAMES, CHOOSE THE TWO WHOSE STATISTICS ACROSS ALL'/
     2' SUBJECTS YOU WOULD LIKE TO VIEW. ')
	CALL PAUSE


C  CALL GETCOVR2 TO GET THE NO. OF COVARIATES (DESCRIPTORS), NCOV,
C  AND THEIR NAMES, DESCR(I),I=1,NCOV.


C??? AS OF IT2B105.FOR, PATFIL IS REMOVED SINCE IT WASN'T NEEDED.

        CALL GETCOVR2(NCOV,DESCR)

C  FROM CALL TO GETCOVR2, NCOV = NO. OF COVARIATES AND
C  DESCR = NAMES OF THESE COVARIATES, AS FOLLOWS:
C  IF NCOV = 4, DESCR(1:4) = 'AGE', 'SEX','HEIGHT', 'ETHNICITY FLAG'.
C  IF NCOV > 4, DESCR(1:NCOV-4) = OTHER COVARIATE(S);
C		    DESCR(NCOV-3:NCOV) = 'AGE', 'SEX','HEIGHT',
C              'ETHNICITY FLAG'.
C  I.E., THE LAST 4 COVARIATES ARE ALWAYS 'AGE','SEX','HEIGHT',
C					  'ETHNICITY FLAG'.

C  CALL PRNCOVAR TO PRINT A MENU OF DESCRIPTORS AND PARAMTER NAMES.

 7680	CALL PRNCOVAR(NCOV,DESCR,NVAR,PAR,ClearScreen)

 7685	WRITE(*,7679)


 7679   FORMAT(//' FROM THE ABOVE LIST OF COVARIATES AND RANDOM'/
     1' VARIABLE NAMES, CHOOSE THE TWO WHOSE STATISTICS (ACROSS ALL'/
     2' SUBJECTS) YOU WOULD LIKE TO VIEW. '//
     3' ENTER THE TWO INDICES NOW (OR "AGAIN" TO SEE THE ABOVE LIST OF'/
     4' COVARIATES AND RANDOM VARIABLES AGAIN): ')

 	READ(*,*,ERR=7680) IND1,IND2


C  NOTE THAT IF THE USER INPUTS "AGAIN", OR ANY NON-NUMERIC ENTRY, HE
C  WILL BE TRANSFERRED BACK TO LABEL 7680. ALSO TRANSFER HIM BACK IF
C  HE INPUTS ANY NUMBER < 1 OR > NCOV+NVAR.


	NCV = NCOV + NVAR
	IF(IND1 .LT. 1 .OR. IND2 .LT. 1 .OR. IND1 .GT. NCV .OR. IND2


     1     .GT. NCV) GO TO 7680


C  IF EITHER IND1 OR IND2 IS .LE. NCOV, IT MEANS THAT THE USER HAS
C  CHOSEN TO PLOT A COVARIATE. IF ICOVHAVE = 0, IT MEANS THAT THE
C  COVARIATE VALUES HAVE NOT ALREADY BEEN STORED INTO ARRAY COVAL

C  (FROM A PREVIOUS IOPT = 7 CALLING). IN THIS CASE, GO THROUGH ALL
C  THE SUBJECTS AND STORE COV. VALUES INTO COVAL.

	IF(IND1 .LE. NCOV .OR. IND2 .LE. NCOV) THEN

	 IF(ICOVHAVE .EQ. 0) THEN

	  WRITE(*,6502)
 6502     FORMAT(//' STORING MEAN COVARIATE VALUES FOR EACH SUBJECT ...
     1')

	  REWIND(27)

	  DO JSUB = 1,NSUB
	   CALL GETCOVAL(NUMEQT,JSUB,COVAL,NCOV)
	  END DO

	  ICOVHAVE = 1

C  NOTE THAT ANY MEANS UNAVAILABLE HAVE VALUE = -99.

	 ENDIF

	ENDIF



C  IF EITHER IND1 OR IND2 IS > NCOV, IT MEANS THAT THE USER HAS CHOSEN
C  TO USE A RANDOM VARIABLE. IN THIS CASE, THE VALUES USED WILL BE
C  THE MAP BAYESIAN ESTIMATES BASED ON EITHER THE MEANS OR THE MEDIANS
C  OF THE FINAL CYCLE POPULATION ESTIMATE. THESE VALUES WERE READ INTO
C  PARBAY FROM THE LAST CYCLE PARAMETER FILE.

	IF(IND1 .GT. NCOV .OR. IND2 .GT. NCOV) THEN

 8550   WRITE(*,8551)
 8551   FORMAT(//' THE PARAMETER VALUE FOR EACH SUBJECT WILL BE THE'/
     1' FINAL MAP BAYESIAN ESTIMATE, GIVEN EITHER THE MEAN OR THE '/
     2' MEDIAN OF THE FINAL CYCLE AS THE POPULATION PRIOR ESTIMATE.'//
     4' ENTER 1 TO USE THE MEAN; '/
     5' ENTER 2 TO USE THE MEDIAN: ')
	READ(*,*,ERR=8550) ICENTER
	IF(ICENTER .NE. 1 .AND. ICENTER .NE. 2) GO TO 8550

	IF(ICENTER .EQ. 1) MNAME = 'MEANS'
	IF(ICENTER .EQ. 2) MNAME = 'MEDIANS'

	ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(IND1 .GT. NCOV .OR. IND2 .GT. NCOV)
C  CONDITION.


 6510	WRITE(*,6503)
 6503   FORMAT(//' THE STATISTICS WILL INCLUDE 95% CONFIDENCE LINES.'//
     1' ENTER 1 TO MAKE THESE STATISTICS FOR THE EXPECTED VALUE OF Y GIV
     2EN X;'/

     3' ENTER 0 TO MAKE THESE STATISTICS FOR AN ADDITIONAL VALUE OF Y GI
     4VEN X: ')

	READ(*,*,ERR= 6510) ICONF

	IF(ICONF .NE. 0 .AND. ICONF .NE. 1) GO TO 6510



C  STORE INTO XCOV THE NSUB VALUES FOR R.V./COVARIATE WITH INDEX
C  IND1; SIMILARLY, STORE INTO YCOV THE NSUB VALUES FOR R.V./COVARIATE
C  WITH INDEX IND2. RECALL THAT IF IND1 .LE. NCOV, THE VALUES

C  ARE FOR COVARIATE WITH INDEX IND1, AND IF IND1 .GT. NCOV, THE VALUES
C  ARE FOR R.V. WITH INDEX IND1-NCOV (SEE SUBROUTINE PRNCOVAR).
C  SIMILARLY, FOR INDEX IND2. ALSO, STORE INTO XLABEL AND YLABEL THE
C  R.V. OR DESCRIPTOR NAMES. ALSO, BLANK OUT XLABEL2 AND YLABEL2. THEY
C  WILL BE RESET = 'MEANS OF', 'MEDIANS OF', OR 'MODES OF' IF A R.V. IS
C  ONE OF THE PARAMETERS.

	XLABEL2 = '          '
	YLABEL2 = '          '

	IF(IND1 .LE. NCOV) THEN
	 DO JSUB = 1,NSUB
	  XCOV(JSUB) = COVAL(JSUB,IND1)
	  XLABEL = DESCR(IND1)
	 END DO
	ENDIF

	IF(IND1 .GT. NCOV) THEN
	 DO JSUB = 1,NSUB
	  XCOV(JSUB) = PARBAY(JSUB,ICENTER,IND1-NCOV)
	  XLABEL = PAR(IND1-NCOV)

	  XLABEL2 = MNAME//' OF'

	 END DO
	ENDIF

	IF(IND2 .LE. NCOV) THEN
	 DO JSUB = 1,NSUB
	  YCOV(JSUB) = COVAL(JSUB,IND2)
	  YLABEL = DESCR(IND2)
	 END DO

	ENDIF

	IF(IND2 .GT. NCOV) THEN
	 DO JSUB = 1,NSUB

	  YCOV(JSUB) = PARBAY(JSUB,ICENTER,IND2-NCOV)
	  YLABEL = PAR(IND2-NCOV)
	  YLABEL2 = MNAME//' OF'
	 END DO
	ENDIF


C  CALL SCATGRAM TO PRINT THE STATISTICS OF THE NSUB PAIR OF VALUES IN
C  XCOV AND YCOV.

C  DEFAULT ILOWER = 1 --> BOUNDARIES ARE CALCULATED AUTOMATICALLY FROM
C  THE DATA POINTS. BELOW, USER WILL HAVE CHANCE TO RERUN WITH
C  ILOWER = 0 --> (0,0) INCLUDED IN THE PLOT FOR SURE.
C  ILOWER IS N/A FOR ITBIG8.FOR.

	ILOWER = 1

 7990	CALL SCATGRAM(IIOUT,IQUAL,NSUB,XLABEL,YLABEL,XLABEL2,YLABEL2,
     1  XCOV,YCOV,ILOWER,ICONF,IPUT)


 7785	WRITE(*,7891)
 7891   FORMAT(/' ENTER 1 TO SEE THE STATISTICS OF ONE DESCRIPTOR'/
     2'         OR RANDOM VARIABLE VS. ANY OTHER;'/
     3' ENTER 0 OTHERWISE: ')
	READ(*,*,ERR=7785) IAGAIN

	IF(IAGAIN .NE. 0 .AND. IAGAIN .NE. 1) GO TO 7785

	IF(IAGAIN .EQ. 1) GO TO 7700


	IF(IAGAIN .EQ. 0) THEN
	 IF(ISAVFIL .EQ. 0) CLOSE(35)
	 GO TO 7185
	ENDIF


	ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(IOPT .EQ. 7) CONDITION.


	RETURN
	END

C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
	SUBROUTINE PRNLAST
	CHARACTER READLINE*144

C  THIS ROUTINE, CALLED BY PREVRUN, PRINTS THE LAST CYCLE OF FILE 25

C  TO THE SCREEN, ONE SCREENFUL AT A TIME. FILE 25 IS ALREADY OPENED,
C  AND POSITIONED AT THE LAST RECORD. AS OF M2_7.FOR, EACH SUBJECT'S
C  BAYESIAN POSTERIOR DENSITY RESULTS ARE AT THE END OF FILE 25, SO

C  THESE RESULTS ARE ALSO OUTPUT TO THE SCREEN.


C  BACKSPACE UNTIL THE BEGINNING OF THE LAST CYCLE.

    2   FORMAT(A144)
   90	BACKSPACE(25)
	BACKSPACE(25)
	READ(25,2) READLINE
	IF(READLINE(2:17) .NE. 'ITERATION NUMBER') GO TO 90
	BACKSPACE(25)

	ILINES=0

C  ILINES IS THE RUNNING TOTAL OF LINES PRINTED TO THE SCREEN SINCE

C  THE LAST PAUSE. WHEN IT GETS TO 20, PAUSE THE SCREEN AND RESET IT
C  TO 0.


   80   READ(25,2,IOSTAT=IEND) READLINE
	IF(IEND .LT. 0) GO TO 100

C  NOTE THAT IEND .LT. 0 --> END OF FILE REACHED.

C  IF READLINE HAS ANY NON-BLANK CHARACTERS IN LOCATIONS 73:144, USE
C  FORMAT 111 TO WRITE READLINE TO SCREEN; OTHERWISE, USE FORMAT 11.

	IEXT = 0
	DO I=73,144
	 IF(READLINE(I:I) .NE. ' ') IEXT = 1
	END DO


	IF(IEXT .EQ. 0) WRITE(*,11) READLINE(1:72)
	IF(IEXT .EQ. 1) WRITE(*,111) READLINE
   11   FORMAT(' ',A72)
  111   FORMAT(' ',A144)
	ILINES=ILINES+1


	IF(ILINES .EQ. 20) THEN


	 ILINES=0
  110	 WRITE(*,101)
  101    FORMAT(' ENTER 1 TO CONTINUE PRINTING THE LAST CYCLE INFO; '/
     1' ENTER 0 TO RETURN TO THE PREVIOUS MENU: ')
 	 READ(*,*,ERR=110) ICONT
	 IF(ICONT .NE. 0 .AND. ICONT .NE. 1) GO TO 110
	 IF(ICONT .EQ. 0) RETURN
	ENDIF

	GO TO 80

  100   CONTINUE



	RETURN

	END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
	SUBROUTINE SEEDIR(PATH,NOB,FILENAME,OSName,ListDir)
	CHARACTER FILENAME*20,PATH*60,PRTDIR*47,TEMP*72,PRTDIR2*47,
     1  OSName*20,ListDir*10
C  NOTE THAT PATH(1:NOB) IS THE CONDENSED (WITHOUT BLANKS) PATH.

   10	PRTDIR = ' '
        IF (INDEX(OSName,"UNIX",.TRUE.).eq.1) THEN

          WRITE(*,7)
        ELSE IF (INDEX(OSName,"DOS",.TRUE.).eq.1) THEN
          WRITE(*,6)
        END IF

    7   FORMAT(/' Press the ENTER key to call system(ls -t). '//
     1' Or type a partial filename (use the * wildcard) to call '/

     2'       system(ls -t arg_1), '/
     3'       e.g., type "to*.f ENTER" to see a list of all files '/
     4'       that begin with "to" and have a .f suffix. '//
     5' ENTER YOUR CHOICE NOW: ')
    6   FORMAT(/' PRESS THE ENTER KEY TO SEE YOUR ENTIRE DIRECTORY;'//
     1' ENTER A PARTIAL FILENAME (WITH THE * WILDCARD) TO SEE A '/
     2'       PARTICULAR SUBSET OF FILENAMES IN YOUR DIRECTORY. '/
     3'       e.g., ENTER  "TO*.INS TO SEE A LIST OF ALL FILES WHICH'/
     4'       BEGIN WITH "TO" AND HAVE A .INS SUFFIX '//
     5' NOTE THAT THE FILES WILL AUTOMATICALLY BE TIME-ORDERED FROM '/
     6' OLDEST TO NEWEST.'//
     7' ENTER YOUR CHOICE NOW: ')
	READ(*,1) PRTDIR

    1   FORMAT(A47)

C  REMOVE ANY BLANKS FROM PRTDIR SINCE THERE CAN BE NO BLANKS BETWEEN
C  THE END OF THE PATH AND THE BEGINNING OF THE "OBJECT" OF THE

C  DIR COMMAND FOR SUBDIRECTORIES. PRTDIR, WITHOUT BLANKS, WILL BE
C  PRTDIR2.

C This Block,

C
        IF (INDEX(OSName,"UNIX",.TRUE.).eq.1) THEN
           IF (PRTDIR .EQ. ' ') THEN

             TEMP = ListDir//PATH(1:NOB)
           ENDIF
        ELSE IF (INDEX(OSName,"DOS",.TRUE.).eq.1) THEN
           IF (PRTDIR .EQ. ' ') THEN
             TEMP = ListDir//PATH(1:NOB)//' |MORE'
           ENDIF
        ENDIF
C
C replaces the following single line of code,
C
C       IF (PRTDIR .EQ. ' ') TEMP = 'DIR/OD '//PATH(1:NOB)//' |MORE'
C

	IF (PRTDIR .NE. ' ') THEN
	 PRTDIR2 = ' '
	 J = 0
	 DO I=1,47
	  IF (PRTDIR(I:I) .NE. ' ') THEN
	   J = J+1

	   PRTDIR2(J:J) = PRTDIR(I:I)
	  ENDIF
	 END DO

C Following line,
C        TEMP = 'DIR/OD '//PATH(1:NOB)//PRTDIR2(1:J)//' |MORE'
C is replaced by the following block:
C
         IF (INDEX(OSName,"UNIX",.TRUE.).eq.1) THEN

           TEMP = ListDir//PATH(1:NOB)//PRTDIR2(1:J)
         ELSE IF (INDEX(OSName,"DOS",.TRUE.).eq.1) THEN
           TEMP = ListDir//PATH(1:NOB)//PRTDIR2(1:J)//' |MORE'

         ENDIF
C
C End of the block

	ENDIF

        CALL SYSTEM(TEMP)


     	WRITE(*,3)
    3   FORMAT(/' ENTER THE NAME OF THE DESIRED FILE (WITHOUT THE PATH);
     1'/
     2' ENTER -99 TO ENTER A DIFFERENT FILE SPECIFICATION: ')
	READ(*,2) FILENAME
    2   FORMAT(A20)
	IF(FILENAME(1:3) .EQ. '-99') GO TO 10

	RETURN
	END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
       SUBROUTINE CALCSER(MAXSUB,NSUB,SERNUM,MAXSER,MINSER,SERMEN,SERSD)

C  THIS ROUTINE, CALLED BY MAIN AND EXTRAOPT, FINDS THE MAX,MIN,MEAN,
C  AND STD. DEV. FOR THE NSUB NOS. IN VECTOR SERNUM. THE VALUES ARE
C  RETURNED IN MAXSER,MINSER,SERMEN, AND SERSD, RESPECTIVELY.

	IMPLICIT REAL*8(A-H,O-Z)

	DIMENSION SERNUM(MAXSUB)

	SUM=0.D0
	SUMSQ=0.D0
	MINSER = SERNUM(1)

	MAXSER = SERNUM(1)

	  DO J=1,NSUB
	    SUM = SUM + SERNUM(J)
	    SUMSQ = SUMSQ + SERNUM(J)*SERNUM(J)
	    IF(SERNUM(J) .GT. MAXSER) MAXSER=SERNUM(J)
	    IF(SERNUM(J) .LT. MINSER) MINSER=SERNUM(J)
	  END DO

	SERMEN = SUM/NSUB

	IF(NSUB .EQ. 1) THEN
	  WRITE(*,*)' THE NO. OF OBSER = 1; NO S.D. CAN BE FOUND.'
	  SERSD=-999.
	  RETURN
	ENDIF

	VAR = (SUMSQ - NSUB*SERMEN*SERMEN)/(NSUB-1.D0)
	SERSD = DSQRT(VAR)

	RETURN
	END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
        SUBROUTINE PUTASS(PATHFILE,IASS,C0P,C1P,C2P,C3P,C4P,C5P
     1    ,NUMEQT,GENCOEF,NCSTORE,MAXNUMEQ)

C  THIS ROUTINE, CALLED BY MAIN, READS THE INFO IN FILE PATHFILE,
C  AND MAKES SURE THE CORRECT ASSAY ERROR COEFFICIENTS ARE AT THE


C  END OF THE FILE, AS FOLLOWS:

C  IASS(I) = 1 --> IF A FILE ALREADY HAS C'S, THEY REMAIN FOR OUTPUT
C		EQUATION I; IF A FILE DOESN'T HAVE C'S,
C		[C0P(I),C1P(I),C2P(I),C3P(I)] ARE PUT INTO THE FILE
C		FOR OUTPUT EQUATION I; I=1,NUMEQT.

C  IASS(I) = 2 --> [C0P(I),C1P(I),C2P(I),C3P(I)] ARE PUT INTO EACH FILE
C		FOR OUTPUT EQUATION I, OVERWRITING C'S IF THEY'RE
C		ALREADY THERE; I=1,NUMEQT.


C  IASS(I) = 0 --> USER GETS PROMPTED AND ENTERS C'S OF HIS CHOICE FOR
C		EACH FILE, FOR OUTPUT EQUATION I; I=1,NUMEQT.

C  NOTE THAT IASS(I) CANNOT = -1 IN THIS PROGRAM SINCE, UNLIKE IN THE
C  SERIES MEM1__.FOR, THERE IS NO SUBROUTINE NEWPAT.

      IMPLICIT REAL*8(A-H,O-Z)

      DIMENSION IASS(MAXNUMEQ),C0P(MAXNUMEQ),C1P(MAXNUMEQ),
     1 C2P(MAXNUMEQ),C3P(MAXNUMEQ),GENCOEF(MAXNUMEQ,5,4),
     2 NCSTORE(MAXNUMEQ),C4P(MAXNUMEQ),C5P(MAXNUMEQ)

        CHARACTER PATHFILE*73,READLINE*1000,ERRFIL*20


      COMMON/ERROR/ERRFIL
C  COMMON/ERROR/ IS SUPPLIED TO ALL THE ROUTINES WHICH COULD WRITE TO
C  ERRFIL. 


C  FIRST, DETERMINE IF FILE 21 HAS ASSAY COEFFICIENTS AT THE END. OPEN
C  THE FILE AND READ UNTIL THE LINE STARTING WITH
C  "ASSAY COEFFICIENTS ..." IS ENCOUNTERED. IF THE NEXT WORD IS
C  "FOLLOWS", THE LAST NUMEQT LINES CONTAIN ASSAY COEFFICIENTS.

    3   FORMAT(A1000)
	OPEN(21,FILE=PATHFILE,STATUS='OLD')
    5	READ(21,3,IOSTAT=IEND) READLINE

C  IF THERE IS NO LINE WITH "ASSAY COE" ON IT, THIS IS NOT AN
C  ACCEPTABLE WORKING COPY FILE.

	IF(IEND .LT. 0) THEN



	 WRITE(*,56) PATHFILE
   56    FORMAT(//' PATIENT FILE '/
     1'    ',A73/
     2' IS NOT AN ACCEPTABLE WORKING COPY FILE. SUCH A FILE MUST HAVE '/
     2' "ASSAY COEFFICIENTS ... " NEAR THE BOTTOM OF THE FILE.'//
     3' THE PROGRAM STOPS. '//)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,56) PATHFILE 

        CLOSE(42)



       CALL PAUSE
	 STOP



	ENDIF


	IF(READLINE(1:9) .NE. 'ASSAY COE') GO TO 5
	IF(READLINE(20:25) .EQ. 'FOLLOW' ) ICOFF = 1
	IF(READLINE(20:25) .NE. 'FOLLOW' ) ICOFF = 0

C  NOTE THAT ICOFF = 1 IF ASSAY COEFFS. ARE AT THE END OF FILE 21;
C	             0 IF ASSAY COEFFS. ARE NOT AT END OF THE FILE.

C  IF ICOFF=0, WRITE ALL OF FILE 21 TO FILE 27;
C  IF ICOFF=1, WRITE ALL OF FILE 21, EXCEPT FOR ASSAY COEFFICIENT INFO,
C	       TO FILE 27.

	OPEN(27,STATUS='SCRATCH')
	REWIND(21)

   10	READ(21,3,IOSTAT=IEND) READLINE
	IF(IEND .LT. 0 .OR. READLINE(1:5) .EQ. 'ASSAY' ) GO TO 25
	WRITE(27,3) READLINE
	GO TO 10


   25 READLINE = 'ASSAY COEFFICIENTS FOLLOW, ONE SET FOR EACH OUTPUT EQU
     1ATION:'
        WRITE(27,3) READLINE

C  NOW PUT IN THE APPROPRIATE C'S, DEPENDING ON THE VALUE OF ICOFF.



C********** PUT C'S IN FILE CURRENTLY HAVING NO C'S (BELOW) ************

	IF(ICOFF .EQ. 0) THEN

	DO IEQ = 1,NUMEQT

	IF(IASS(IEQ) .EQ. 1 .OR. IASS(IEQ) .EQ. 2) WRITE(27,16)
     1  C0P(IEQ),C1P(IEQ),C2P(IEQ),C3P(IEQ),C4P(IEQ),C5P(IEQ)
   16    FORMAT(4(F16.8,2X))

	IF(IASS(IEQ) .EQ. 0) THEN

   20	WRITE(*,18) PATHFILE,IEQ
   18   FORMAT(///' ****************************************************
     1********************'/
     1' PATIENT FILE ',A73/
     2' CURRENTLY HAS NO ASSAY COEFFICIENTS. FOR OUTPUT EQUATION ',I2,/
     3' THE GENERAL ASSAY COEFFICIENTS ARE: ')
	WRITE(*,16) C0P(IEQ),C1P(IEQ),C2P(IEQ),C3P(IEQ)
     1     ,C4P(IEQ),C5P(IEQ)
	WRITE(*,19)
   19   FORMAT(/' ENTER 1 TO USE THESE GENERAL COEFFICIENTS;'/
     1' ENTER 0 TO USE A DIFFERENT SET OF VALUES:  ')

	READ(*,*,ERR=20) IUSE
	IF(IUSE .NE. 0 .AND. IUSE .NE. 1) GO TO 20

	IF(IUSE .EQ. 1) WRITE(27,16) C0P(IEQ),C1P(IEQ),C2P(IEQ),C3P(IEQ)
     1    ,C4P(IEQ),C5P(IEQ)
	IF(IUSE .EQ. 0) THEN

C  CALL USECS TO GET [C0,C1,C2,C3] TO WRITE INTO THIS PATIENT'S FILE.
C  ALSO NOTE THAT NCSTORE AND GENCOEF WILL GET UPDATED IF THE USER
C  WANTS TO STORE THESE C'S (IF NCSTORE IS NOT ALREADY = 5).

	 CALL USECS(IEQ,NCSTORE,GENCOEF,C0,C1,C2,C3,MAXNUMEQ)

	 WRITE(27,16) C0,C1,C2,C3

	ENDIF

	ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(IASS(IEQ) .EQ. 0) CONDITION.


	END DO

C  THE ABOVE END DO IS FOR THE  DO IEQ = 1,NUMEQT  LOOP.


	ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(ICOFF .EQ. 0) CONDITION.

C********** PUT C'S IN FILE CURRENTLY HAVING NO C'S (ABOVE) ************





C********** PUT C'S IN FILE CURRENTLY HAVING C'S (BELOW) ***************


	IF(ICOFF .EQ. 1) THEN


	 DO IEQ = 1,NUMEQT

C  THIS FILE HAS C'S ON THE NEXT LINE.


	READ(21,*) C0,C1,C2,C3

	IF(IASS(IEQ) .EQ. 1) WRITE(27,16) C0,C1,C2,C3
	IF(IASS(IEQ) .EQ. 2) WRITE(27,16) C0P(IEQ),C1P(IEQ),C2P(IEQ),
     1  C3P(IEQ),C4P(IEQ),C5P(IEQ)

	IF(IASS(IEQ) .EQ. 0) THEN

   40	 WRITE(*,28) PATHFILE,IEQ

   28   FORMAT(///' ****************************************************
     1********************'/
     1' FOR PATIENT FILE ',A73/
     2' AND OUTPUT EQUATION ',I2,' THE CURRENT COEFFICIENTS ARE: ')

	 WRITE(*,16) C0,C1,C2,C3
	 WRITE(*,29)
   29    FORMAT(/' ... AND THE GENERAL COEFFICIENTS ARE: ')
	 WRITE(*,16) C0P(IEQ),C1P(IEQ),C2P(IEQ),C3P(IEQ)
     1     ,C4P(IEQ),C5P(IEQ)
	 WRITE(*,31)
   31    FORMAT(/' ENTER 1 TO CONTINUE USING THE CURRENT COEFFICIENTS;'/
     2' ENTER 2 TO USE THE GENERAL COEFFICIENTS;'/
     3' ENTER 0 TO USE A DIFFERENT SET OF VALUES:  ')

	READ(*,*,ERR=40) IUSE
	IF(IUSE .NE. 0 .AND. IUSE .NE. 1 .AND. IUSE .NE. 2) GO TO 40

	IF(IUSE .EQ. 1) WRITE(27,16) C0,C1,C2,C3
	IF(IUSE .EQ. 2) WRITE(27,16) C0P(IEQ),C1P(IEQ),C2P(IEQ),C3P(IEQ)
     1     ,C4P(IEQ),C5P(IEQ)

	IF(IUSE .EQ. 0) THEN

C  CALL USECS TO GET [C0,C1,C2,C3] TO WRITE INTO THIS PATIENT'S FILE.
C  ALSO NOTE THAT NCSTORE AND GENCOEF WILL GET UPDATED IF THE USER
C  WANTS TO STORE THESE C'S (IF NCSTORE(IEQ) IS NOT ALREADY = 5).

	 CALL USECS(IEQ,NCSTORE,GENCOEF,C0,C1,C2,C3,MAXNUMEQ)

	 WRITE(27,16) C0,C1,C2,C3

	ENDIF

	ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(IASS(IEQ) .EQ. 0) CONDITION.

	END DO

C  THE ABOVE END DO IS FOR THE  DO IEQ = 1,NUMEQT  LOOP.


	ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(ICOFF .EQ. 1) CONDITION.

C********** PUT C'S IN FILE CURRENTLY HAVING C'S (ABOVE) ***************

C  NOW COPY FILE 27 BACK INTO FILE 21.

	CLOSE(21)
        OPEN(21,FILE=PATHFILE)
	REWIND(27)


   60	READ(27,3,IOSTAT=IEND) READLINE


	IF(IEND .LT. 0) THEN
	 CLOSE(27)
         CLOSE(21)
	 RETURN
	ENDIF

	WRITE(21,3) READLINE
	GO TO 60


	END
C

CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
        SUBROUTINE USERPREP(NDIM,NP,NVAR,MAXDIM,PAR,NOFIX,PARFIX,
     1   NRANFIX,PARRANFIX,IRAN)



C  THIS SUBROUTINE, CALLED BY MAIN, READS THE FORTRAN FILE, FORFILE,
C  OPENED IN MAIN (FILE 28), AND RETURNS THE VALUES IN THE ABOVE 
C  ARGUMENT LIST.

C ???
C  NOTE: WHEN THIS PROGRAM STARTS READING THE NEW BOXES PROGRAM, MAKE
C      SURE THAT THE MICHAELIS-MENTIN EQUATION IS CORRECT - IT SHOULD
C	 BE  (SEE PAGE *1 OF M2_7/m2_7calc.f NOTES OR NOTES FROM PG. 5.
C  	 OF PHARMACOKINETICS AND PHARMACODYNAMICS, VOL 2).

C	 dX/dT = (VM x X) / (KM x V1 + X), WHERE VM = V1 * Vmax, AND
C	  THE UNITS ARE: X --> grams; T --> hours; VM --> grams/hour;
C			 V1 --> liters; KM --> grams/liter;
C			 Vmax --> grams/(liter * hour)

C  NOTE: THE ABOVE EQUATION IS EXACTLY THE SAME AS
C	 dC/dT = (Vmax * C)/(KM + C), WHERE C = X/V1, WHICH IS
C	  EQUATION 3 ON PG. 5 OF PHARMACOKINETICS AND PHARMACODYNAMICS,
C         VOL 2, WHERE:
C	  Vmax = dC/dT AS C--> infinity;

C	  KM = C WHEN dC/dT = Vmax/2.

C	  ABOVE COMMENTS WERE IMPROVED 7/27/99 AFTER
C         CONVERSATION WITH ROGER AND DARRYL CLARDY.
C ???

      IMPLICIT REAL*8(A-H,O-Z)
      DIMENSION IRAN(32)
      CHARACTER PAR(30)*11,PARFIX(20)*11,READLINE*1000,
     1 PSYM(32)*11,RR*2,TEMP*11,C*1,ERRFIL*20,PARRANFIX(20)*11

      COMMON/ERROR/ERRFIL
C  COMMON/ERROR/ IS SUPPLIED TO ALL THE ROUTINES WHICH COULD WRITE TO
C  ERRFIL. 


C  FILE 28 WAS OPENED (IN MAIN) AT THE END OF THE FILE. BACKSPACE AND
C  THEN READ IN NDIM, NP AND PSYM(I),I=1,NP.

    2   FORMAT(A1000)

   30	BACKSPACE(28)
	BACKSPACE(28)
	READ(28,2) READLINE
	IF(READLINE(8:9) .NE. 'N=') GO TO 30
	BACKSPACE(28)
	READ(28,3) NDIM
    3 FORMAT(T10,I3)

   40	READ(28,2) READLINE
	IF(READLINE(8:9) .NE. 'NP') GO TO 40
	BACKSPACE(28)
	READ(28,4) NP
    4   FORMAT(T11,I3)

   50	READ(28,2) READLINE
	IF(READLINE(8:11) .NE. 'PSYM') GO TO 50
	BACKSPACE(28)

	DO 70 I=1,NP

	IF(I .LE. 9) READ(28,14) TEMP
	IF(I .GE. 10 .AND. I .LE. 99) READ(28,6) TEMP

C  WRITE TEMP INTO PSYM, STRIPPING OFF THE ENDING QUOTE MARK, IF ONE
C  IS THERE.

	C = ''''
	PSYM(I) = TEMP

	DO J=1,11

	 IF(TEMP(J:J) .EQ. C) THEN
	  PSYM(I) = TEMP(1:J-1)
	  GO TO 70
	 ENDIF

	END DO


   70   CONTINUE

   14   FORMAT(T17,A11)
    6   FORMAT(T18,A11)

C  NOW QUIZ THE USER TO SEE WHICH PARAMETERS ARE FIXED, WHICH ARE
C  RANFIX, AND WHICH ARE RANDOM (AND IF RANDOM, WHICH ARE ALLOWED TO 
C  BE NEGATIVE).

C  SET IRAN(I) = 1 IF PSYM(I) = RANDOM AND NOT ALLOWED TO BE NEGATIVE;
C               -1 IF PSYM(I) = RANDOM AND ALLOWED TO BE NEGATIVE;
C                0 IF PSYM(I) = FIXED.
C                2 IF PSYM(I) = RANFIX.

   80	WRITE(*,7) NP
    7   FORMAT(/' FOR EACH OF THE ',I2,' PARAMETERS, '//
     1' ENTER "R" (OR "r") IF IT IS TO BE A RANDOM VARIABLE WHICH'/
     2'           WILL NOT BE ALLOWED TO BE NEGATIVE;'/
     3'       "-R" (OR "-r") IF IT IS TO BE A RANDOM VARIABLE WHICH'/
     4'           WILL BE ALLOWED TO BE NEGATIVE;'/
     5' ENTER "F" IF IT IS TO BE A FIXED PARAMETER;'/
     6' ENTER "U" IF IT IS TO BE A FIXED BUT UNKNOWN PARAMETER'/
     7'           TO BE ESTIMATED.'//)

      NVAR = 0
      NOFIX = 0
      NRANFIX = 0

	DO I=1,NP

   8   FORMAT(1X,A11,':  ')
   60	 WRITE(*,8) PSYM(I)
       READ(*,9) RR
    9  FORMAT(A2)
       IF(RR(1:1) .NE. 'R' .AND. RR(1:1) .NE. 'r' .AND. 
     1  RR .NE. '-R' .AND. RR .NE. '-r' .AND.
     2  RR(1:1) .NE. 'F' .AND. RR(1:1) .NE. 'f' .AND. 
     3  RR(1:1) .NE. 'U' .AND. RR(1:1) .NE. 'u') GO TO 60


      IF(RR(1:1) .EQ. 'R' .OR. RR(1:1) .EQ. 'r'
     1 .OR. RR .EQ. '-R' .OR. RR .EQ. '-r') THEN

       NVAR = NVAR+1

C  NOTE THAT THIS PROGRAM RESETS NP TO A VERY LARGE VALUE
C  IF NVAR > THE DIMENSION LIMIT OF PAR. THIS IS BIZARRE. IT DOESN'T
C  HAPPEN IF NOFIX > THE DIMENSION LIMIT OF PARFIX, AND IT DOESN'T
C  HAPPEN IN MONTBIG8.FOR WHICH HAS THE SAME CODE AS HERE.
C  BUT SINCE IT HAPPENS HERE, CHECK TO SEE IF NVAR > MAXDIM, AND IF
C  SO TRANSFER CONTROL TO LABEL 110 WITHOUT SETTING PAR(MAXDIM+1) TO
C  PSYM(I).

       IF(NVAR .GT. MAXDIM) GO TO 110
       PAR(NVAR) = PSYM(I)
       IF(RR(1:1) .EQ. 'R' .OR. RR(1:1) .EQ. 'r') IRAN(I) = 1
       IF(RR .EQ. '-R' .OR. RR .EQ. '-r') IRAN(I) = -1

      ENDIF
C  THE ABOVE ENDIF IS FOR THE  IF(RR(1:1) .EQ. 'R' ...) CONDITION.


      IF(RR(1:1) .EQ. 'F' .OR. RR(1:1) .EQ. 'f') THEN
       NOFIX = NOFIX+1
       PARFIX(NOFIX) = PSYM(I)
       IRAN(I) = 0
      ENDIF

      IF(RR(1:1) .EQ. 'U' .OR. RR(1:1) .EQ. 'u') THEN
       NRANFIX = NRANFIX+1
       PARRANFIX(NRANFIX) = PSYM(I)
       IRAN(I) = 2
      ENDIF


	END DO
C  THE ABOVE END DO IS FOR THE  DO I=1,NP  LOOP.


C  IF NVAR .GT. MAXDIM, PRINT MESSAGE TO USER AND HAVE HIM TRY AGAIN.
C  SIMILARLY IF NOFIX .GT. 20 OR NRANFIX .GT. 20. BUT IF 
C  NVAR + NOFIX + NRANFIX .GT. 32, PRINT A MESSAGE AND STOP.

  110	IF(NVAR .GT. MAXDIM) THEN
	 WRITE(*,111) NVAR,MAXDIM
  111    FORMAT(//' YOU HAVE SELECTED ',I2,' PARAMETERS TO BE RANDOM'/
     1' VARIABLES. THE LIMIT IS CURRENTLY ',I2,'. PLEASE RESELECT YOUR'/
     2' RANDOM VARIABLES WITH THIS LIMIT IN MIND.'//)
	 GO TO 80
	ENDIF


	IF(NOFIX .GT. 20) THEN
	 WRITE(*,112) NOFIX
  112    FORMAT(//' YOU HAVE SELECTED ',I2,' PARAMETERS TO BE FIXED'/
     1' PARAMETERS. THE LIMIT IS CURRENTLY 20. PLEASE RESELECT YOUR'/
     2' RANDOM VARIABLES WITH THIS LIMIT IN MIND.'//)
	 GO TO 80
	ENDIF

      IF(NRANFIX .GT. 20) THEN
       WRITE(*,114) NRANFIX
  114  FORMAT(//' YOU HAVE SELECTED ',I2,' PARAMETERS TO BE FIXED'/
     1' BUT UNKNOWN PARAMETERS. THE LIMIT IS CURRENTLY 20. PLEASE'/
     2' RESPECIFY YOUR PARAMETERS WITH THIS LIMIT IN MIND.'//)
       GO TO 80
	ENDIF


	IF(NVAR + NOFIX + NRANFIX .GT. 32) THEN

	 WRITE(*,113) NVAR + NOFIX + NRANFIX
  113    FORMAT(//' YOUR MODEL FILE HAS A TOTAL OF ',I2,' PARAMETERS.'/
     1' THE LIMIT IS CURRENTLY 32. PLEASE EDIT YOUR MODEL FILE SO '/
     2' THAT IT HAS .LE. 32 PARAMETERS. '//)
        OPEN(42,FILE=ERRFIL)
         WRITE(42,113) NVAR + NOFIX 
        CLOSE(42)

	 CALL PAUSE
	 STOP

	ENDIF


	RETURN
	END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
	SUBROUTINE MAKEDRIV(PATH,NOB,IRUNIT,FORFILE,MAXSUB,MAXDIM,
     1  MAXGRD,NUMEQT,MAXOBDIM,OSName,CopyFile,DeleteFile,IVERIFY)

	IMPLICIT REAL*8(A-H,O-Z)
	CHARACTER FORFILE*20,PATH*60,TMPFILE*13,PATHFILE*73,
     1  OSName*20,CopyFile*5,DeleteFile*4

C  THIS ROUTINE, CALLED BY MAIN, CREATES THE DESIRED DRIVER PROGRAM,
C  EITHER it2bdriv.f OR assdriv.f (SEE BELOW). THIS IS BEING DONE
C  TO ESTABLISH CONSISTENCY WITH THE NPAG PROGRAM (CURRENTLY
C  NPAG104.FOR/npageng16.f), WHICH USES THIS CONCEPT. IN
C  ACTUALITY, IN THESE PROGRAMS, THERE ARE NO HUGE ARRAYS
C  WHICH ABSOLUTELY HAVE TO BE VARIABLY DIMENSIONED.

C  IF IRUNIT = 1: it2bdriv.f, WHICH WILL BE
C  THE "MAIN" OF THE WHOLE 'IT2B'. FORFILE, ENTERED BY USER IN
C  MAIN, WILL BE APPENDED TO THE END OF it2bdriv.f, SO ONLY ONE .f
C  FILE WILL HAVE TO BE UPLOADED.

C  THIS "MAIN" INCLUDES A PARAMETER STATEMENT WHICH DEFINES
C  MAXSUB (=NSUB), MAXGRD (=NGRID), MAXDIM (=NVAR), NUMEQT, AND
C  MAXOBDIM, AND A DIMENSION STATEMENT
C  WITH ALL ARRAYS WHICH DEPEND OF THESE VALUES. IT THEN HAS THE
C  STATEMENT:  CALL IT2B(MAXSUB,MAXGRD,MAXDIM,NUMEQT,MAXOBDIM... ),
C  WHERE ALL VARIABLY DIMENSIONED ARRAYS ARE PASSED TO IT2B, WHICH IS
C  NOW THE MAIN MODULE IN it2bdriv.f.


C  IF IRUNIT = 0: assdriv.f, WHICH WILL BE
C  THE "MAIN" OF THE ASSAY CALCULATION PROGRAM. FORFILE (SEE ABOVE)
C  WILL BE APPENDED TO THE END OF assdriv.f, SO ONLY ONE .f
C  FILE WILL HAVE TO BE UPLOADED.

C  THIS "MAIN" INCLUDES A PARAMETER STATEMENT WHICH DEFINES

C  MAXSUB (=NSUB) AND MAXDIM (=NVAR), AND A DIMENSION STATEMENT
C  WITH ALL ARRAYS WHICH DEPEND OF THIS VALUE. IT THEN HAS THE
C  STATEMENT:  CALL ASSCALC(MAXSUB,MAXDIM,NUMEQT,... ),
C  WHERE ALL VARIABLY DIMENSIONED ARRAYS ARE PASSED TO ASSCALC, WHICH IS
C  NOW THE MAIN MODULE IN asseng_.f.


	IF(IRUNIT .EQ. 1) THEN


C  CALL FULLNAME WHICH CONVERTS THE FILENAME TO PATHFILE, THE COMPLETE
C  NAME OF THE FILE, WHICH INCLUDES THE PATH (IF THE PATH IS NOT THE
C  CURRENT DIRECTORY).

      TMPFILE = ' '
	TMPFILE = 'it2bdriv.f'
	CALL FULLNAME(PATH,TMPFILE,PATHFILE)
	OPEN(31,FILE=PATHFILE,ERR=5475,STATUS='NEW')
	GO TO 5480
 5475   WRITE(*,*)' FILE   it2bdriv.f ALREADY EXISTS. IT WILL BE'
	WRITE(*,*)' COPIED TO   it2bdriv.bak.   THEN THE it2bdriv.f'
  	WRITE(*,*)' FOR THIS RUN WILL BE CREATED; IT MUST BE '
	WRITE(*,*)' UPLOADED -- SEE BELOW.'
      IF(IVERIFY .EQ. 1) CALL PAUSE



        CALL SYSTEM(CopyFile//PATH(1:NOB)//'it2bdriv.f '//PATH(1:NOB)//'
     1it2bdriv.bak')

	OPEN(31,FILE=PATHFILE)

 5480   WRITE(31,5)
    5   FORMAT(/'      IMPLICIT REAL*8(A-H,O-Z)')

        WRITE(31,1) MAXSUB,MAXDIM,MAXGRD,NUMEQT,MAXOBDIM
    1   FORMAT(/'      PARAMETER(MAXSUB = ',I4,', MAXDIM = ',I2,','/
     1'     1  MAXGRD = ',I9,',NUMEQT = ',I2,', MAXOBDIM = ',I5,')')


	WRITE(31,2)
    2   FORMAT(/'      DIMENSION PAREST(MAXSUB,MAXDIM),'/
     1'     1  IESTIJ(MAXSUB,MAXDIM),IREPRT(MAXSUB),WORK(MAXGRD),'/
     2'     2  CORDEN(MAXGRD,MAXDIM+1),VEC(MAXSUB),PXGEE(MAXGRD),'/
     2'     2  SPXGYJ(MAXGRD),YPREDPOP(MAXSUB,NUMEQT,MAXOBDIM,2),'/
     3'     3  YPREDBAY(MAXSUB,NUMEQT,MAXOBDIM,2),'/
     4'     4  PARBAY(MAXSUB,2,MAXDIM)')

	WRITE(31,3)
    3   FORMAT(/'      CALL IT2B(MAXSUB,MAXDIM,MAXGRD,NUMEQT,'/
     1'     1  MAXOBDIM,PAREST,IESTIJ,IREPRT,WORK,CORDEN,PXGEE,SPXGYJ,'/
     2'     2  YPREDPOP,YPREDBAY,PARBAY,VEC)')


	WRITE(31,4)
    4   FORMAT(/'      STOP'/
     1'      END'/
     2'C'/
     3'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'/
     4'C'/)


	CLOSE(31)


C  APPEND FORFILE TO THE END OF it2bdriv.f.

CCCCCCCCCCC
C
C This Block,
C
CC  USE SYSTEM COPY COMMAND TO DO THE APPENDING IN THE DIRECTORY WHERE
CC  THIS ITBIG PROGRAM RESIDES;
C
C        CALL SYSTEM('COPY '//PATH(1:NOB)//'it2bdriv.f + '//PATH(1:NOB)//
C     1   FORFILE//'  '//PATH(1:NOB)//'JUNKTRASH' )
C
C        CALL SYSTEM('COPY '//PATH(1:NOB)//'JUNKTRASH  '
C     1   //PATH(1:NOB)//'it2bdriv.f' )
C
C
C       CALL SYSTEM(' DEL ' //PATH(1:NOB)//'JUNKTRASH')
C

C Will be replaced by the following block,
C

C  IF NOB = 0, THE DIRECTORY OF THIS NPBIG PROGRAM IS THE SAME AS THE
C  DIRECTORY WHERE THE FILES FOR THIS RUN ARE LOCATED. IF NOB > 0,
C  THESE TWO DIRECTORIES ARE DIFFERENT.
C  IF NOB = 0, DO THE 1ST STEP BELOW ONLY; IF NOB > 0, DO ALL 3 STEPS:

C------------------------------------------------------
C
C  1. USE SYSTEM COPY COMMAND TO DO THE APPENDING IN THE DIRECTORY WHERE
C     THIS IT2B PROGRAM RESIDES;
C  2. COPY THE NEW it2bdriv.f BACK INTO THE DESIRED DIRECTORY;
C  3. DELETE it2bdriv.f FROM THIS IT2B PROGRAM DIRECTORY.

C (1)
C        CALL SYSTEM('COPY '//PATH(1:NOB)//'it2bdriv.f + '//PATH(1:NOB)//
C     1   FORFILE//'  '//PATH(1:NOB)//'JUNKTRASH' )

        IF (INDEX(OSName,"UNIX",.TRUE.).eq.1) THEN
          CALL SYSTEM('cat '//PATH(1:NOB)//'it2bdriv.f  '//
     1       PATH(1:NOB)//FORFILE//' >it2b.tmp;mv it2b.tmp it2bdriv.f')
        ELSE IF (INDEX(OSName,"DOS",.TRUE.).eq.1) THEN
          CALL SYSTEM(CopyFile//PATH(1:NOB)//'it2bdriv.f + '
     1      //PATH(1:NOB)//FORFILE//'  '//PATH(1:NOB)//'JUNKTRASH')
        CALL SYSTEM(CopyFile//PATH(1:NOB)//'JUNKTRASH  '
     1        //PATH(1:NOB)//'it2bdriv.f' )
        CALL SYSTEM(' DEL ' //PATH(1:NOB)//'JUNKTRASH')


        ENDIF

C------------------------------------------------
C *** This is the end of the replacement block *** C


	ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(IRUNIT .EQ. 1)  CONDITION.


	IF(IRUNIT .EQ. 0) THEN


C  CALL FULLNAME WHICH CONVERTS THE FILENAME TO PATHFILE, THE COMPLETE
C  NAME OF THE FILE, WHICH INCLUDES THE PATH (IF THE PATH IS NOT THE
C  CURRENT DIRECTORY).

      TMPFILE = ' '
	TMPFILE = 'assdriv.f'
	CALL FULLNAME(PATH,TMPFILE,PATHFILE)
	OPEN(31,FILE=PATHFILE,ERR=6475,STATUS='NEW')
	GO TO 6480
 6475   WRITE(*,*)' FILE   assdriv.f ALREADY EXISTS. IT WILL BE'
	WRITE(*,*)' COPIED TO   assdriv.bak.   THEN THE assdriv.f'
  	WRITE(*,*)' FOR THIS RUN WILL BE CREATED; IT MUST BE '
	WRITE(*,*)' UPLOADED -- SEE BELOW.'
	IF(IVERIFY .EQ. 1) CALL PAUSE

        CALL SYSTEM(CopyFile//PATH(1:NOB)//'assdriv.f '//PATH(1:NOB)//'a
     1ssdriv.bak')
	OPEN(31,FILE=PATHFILE)


 6480   WRITE(31,15)
   15   FORMAT(/'      IMPLICIT REAL*8(A-H,O-Z)')

        WRITE(31,11) MAXSUB,MAXDIM,NUMEQT
   11   FORMAT(/'      PARAMETER(MAXSUB = ',I4,', MAXDIM = ',I2,','/
     1'     1  NUMEQT = ',I2,')')


	WRITE(31,12)
   12   FORMAT(/'      DIMENSION PAREST(MAXSUB,MAXDIM),IESTIJ(MAXSUB,MAX
     1DIM)')

	WRITE(31,13)

   13  FORMAT(/'      CALL ASSCALC(MAXSUB,MAXDIM,NUMEQT,PAREST,IESTIJ)')


	WRITE(31,14)
   14   FORMAT(/'      STOP'/
     1'      END'/
     2'C'/
     3'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'/
     4'C'/)

	CLOSE(31)



C  APPEND FORFILE TO THE END OF assdriv.f.

C   USE SYSTEM COPY COMMAND TO DO THE APPENDING IN THE DIRECTORY WHERE
C   THIS ITBIG PROGRAM RESIDES;


C
C This block,
C
C        CALL SYSTEM('COPY '//PATH(1:NOB)//'assdriv.f + '//PATH(1:NOB)//F
C     1ORFILE//'  '//PATH(1:NOB)//'JUNKTRASH' )
C
C
C        CALL SYSTEM('COPY '//PATH(1:NOB)//'JUNKTRASH  '
C     1   //PATH(1:NOB)//'assdriv.f' )
C
C       CALL SYSTEM(' DEL ' //PATH(1:NOB)//'JUNKTRASH')
C
C Will be replaced by the following block,
C

C 1.

C        CALL SYSTEM('COPY '//PATH(1:NOB)//'assdriv.f + '//PATH(1:NOB)//F
C     1ORFILE//'  '//PATH(1:NOB)//'JUNKTRASH' )
C 2.
C        CALL SYSTEM('COPY '//PATH(1:NOB)//'JUNKTRASH  '
C     1   //PATH(1:NOB)//'assdriv.f' )
C 3.
C       CALL SYSTEM(' DEL ' //PATH(1:NOB)//'JUNKTRASH')
C
        IF (INDEX(OSName,"UNIX",.TRUE.).eq.1) THEN
          CALL SYSTEM('cat '//PATH(1:NOB)//'assdriv.f  '//


     1       PATH(1:NOB)//FORFILE//' >ass.tmp;mv ass.tmp assdriv.f')
        ELSE IF (INDEX(OSName,"DOS",.TRUE.).eq.1) THEN
          CALL SYSTEM(CopyFile//PATH(1:NOB)//'assdriv.f + '//
     1       PATH(1:NOB)//FORFILE//'  '//PATH(1:NOB)//'JUNKTRASH')
          CALL SYSTEM(CopyFile//PATH(1:NOB)//'JUNKTRASH  '
     1        //PATH(1:NOB)//'assdriv.f' )
        CALL SYSTEM(' DEL ' //PATH(1:NOB)//'JUNKTRASH')


        ENDIF

C------------------------------------------------
C *** This is the end of the replacement block *** C


        ENDIF


C  THE ABOVE ENDIF IS FOR THE  IF(IRUNIT .EQ. 0)  CONDITION.

	RETURN
	END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
	SUBROUTINE TOPFIL(NDRUG,AF,NSUB,NVAR,PAR,NOFIX,PARFIX,NRANFIX,
     1 PARRANFIX)

	IMPLICIT REAL*8(A-H,O-Z)
      DIMENSION AF(7)
	CHARACTER PAR(30)*11,PARFIX(20)*11,PARRANFIX(20)*11

C  THIS ROUTINE PRINTS THE TOP PART OF A FILE. IT IS CALLED BY
C  SUBROUTINE EXTRAOPT, IN THE OPTION 6 PART OF THE CODE.

C  INPUT ARE:

C  NSUB = NO. OF SUBJECTS.
C  NVAR = NO. OF RANDOM VARIABLES.
C  PAR(I) = NAME OF VARIABLE I, I=1,NVAR.
C  NOFIX = NO. OF PARAMETERS WHOSE FIXED VALUES WERE SET BY THE USER.
C  PARFIX(I) = NAME OF FIXED PARAMETER I, I=1,NOFIX.
C  NRANFIX = NO. OF RANFIX PARAMETERS.
C  PARRANFIX(I) = NAME OF RANFIX PARAMETER I, I=1,NRANFIX.

C  NDRUG = NO. OF DRUGS. NOTE THAT IF NDRUG = -1, IT MEANS THAT THE
C   NO. OF DRUGS IS UNKNOWN, BUT THAT ALL AF VALUES ARE THE SAME, AND
C   EQUAL TO AF(1) (SEE CODE IN SUBROUTINE EXTRAOPT).
C  IF NDRUG .NE. -1, THEN
C   AF(I), I=1,NDRUG = ACTIVE (SALT) FRACTION FOR THE DRUG FOR DRUG I.

C  OUTPUT ARE:


C  TOP OF AN OUTPUT FILE.

C  SEE THE CALLING ROUTINE FOR WHAT ELSE IS INCLUDED IN THIS FILE.

C  WRITE TO THIS FILE: AF, RANDOM VARIABLE NAMES, THE FIXED
C  PARAMETER NAMES, AND THE RANFIX PARAMETER NAMES.

        IF(NDRUG .EQ. -1) WRITE(33,1) AF(1)
    1   FORMAT(/' ALL DRUGS IN THE ANALYSIS HAD THE SAME AF, ',G12.6)

        IF(NDRUG .NE. -1) THEN
         WRITE(33,6) NDRUG
    6    FORMAT(/' THE AF VALUES FOR THE ',I2,' DRUG(S) FOLLOW, ONE TO'/
     1' A LINE: ')
         DO I = 1,NDRUG
          WRITE(33,*) AF(I)
         END DO
        ENDIF

        WRITE(33,7) NVAR
    7   FORMAT(/' THERE ARE ',I2,' RANDOM VARIABLES. THEIR NAMES ARE: ')

        DO I=1,NVAR
         WRITE(33,2) PAR(I)
        END DO
    2   FORMAT(3X,A11)


	WRITE(33,3) NOFIX
    3   FORMAT(/' THE NUMBER OF FIXED PARAMETER(S) IS ',I2,/
     1' ITS (THEIR) NAME(S) IS (ARE): ')

	DO I=1,NOFIX
	 WRITE(33,2) PARFIX(I)
	END DO

	WRITE(33,8) NRANFIX
    8 FORMAT(/' THE NUMBER OF RANFIX PARAMETER(S) IS ',I2,/
     1' ITS (THEIR) NAME(S) IS (ARE): ')

	DO I=1,NRANFIX
	 WRITE(33,2) PARRANFIX(I)
	END DO


	WRITE(33,4) NSUB

    4   FORMAT(/' EACH OF THE FOLLOWING ',I4,' LINES GIVES THE VALUES'/
     1' FOR ONE SUBJECT ... PROB., RANDOM VALUES, FIXED VALUES, AND '/
     2' RANFIX ESTIMATES, IN ORDER: ')

	RETURN

	END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
	SUBROUTINE GETNUMEQ(PATH,NOB,ICALL,IFORMT,PREFIX,EXT,BLOCKPAT,
     1   NUMEQT,NDRUG,MAXSUB,MAXNUMEQ)

	IMPLICIT REAL*8(A-H,O-Z)

	DIMENSION C0P(MAXNUMEQ),C1P(MAXNUMEQ),C2P(MAXNUMEQ),C3P(MAXNUMEQ)
     1     ,C4P(MAXNUMEQ),C5P(MAXNUMEQ)

	CHARACTER PREFIX*5,EXT*3,READLINE*1000,PATNEW*20,PATH*60,
     1   TMPFILE*13,PATHFIL2*73,BLOCKPAT*20,CODEPAT*15,ERRFIL*20

      COMMON/ERROR/ERRFIL
C  COMMON/ERROR/ IS SUPPLIED TO ALL THE ROUTINES WHICH COULD WRITE TO
C  ERRFIL. 


C  NOTE THAT IF ICALL = 1, THIS CALL IS FROM MAIN;
C                       0, THIS CALL IS FROM EXTRAOPT OR VERIF1.
C  THE ONLY DIFFERENCE IS THAT IF ICALL = 0, WRITE(*,4) IS NOT
C  EXECUTED BELOW.


C  THIS SUBROUTINE READS THE 1ST PATIENT DATA FILE (IF IFORMT = 1) OR
C  THE BLOCK FORMAT FILE BLOCKPAT (IF IFORMT = 3) TO FIND THE NO. OF
C  OUTPUT EQUATIONS (NUMEQT), AND THE NO. OF DRUGS (NDRUG).

    2   FORMAT(A20)


C  PRINT MESSAGE TO THE USER THAT IF HE CHANGES HIS PATIENT FILENAMES
C  IN SUBROUTINE VERIF1, HE MUST MAKE SURE THAT THE NEW PATIENT FILES
C  HAVE THE SAME NO. OF OUTPUT EQUATIONS AS THE ORIGINAL PATIENT FILES.
C  THIS IS N/A IF THE CALL IS FROM PREVRUN (ICALL=0).

	IF(ICALL .EQ. 1) THEN

        IF(IFORMT .EQ. 1) WRITE(*,4)
    4   FORMAT(//' ONE OF YOUR PATIENT FILES WILL NOW BE OPENED TO'/
     1' READ THE NUMBER OF OUTPUT EQUATIONS, AND THE NUMBER OF DRUGS.'/
     2' LATER, YOU WILL HAVE THE OPTION TO CHANGE YOUR PATIENT '/
     3' FILENAMES. IF YOU DO THIS, MAKE SURE THAT THE NEW SET OF FILES'/

     4' HAVE THE SAME NUMBER OF OUTPUT EQUATIONS AND THE SAME NUMBER'/
     5' OF DRUGS.'//)

	 IF(IFORMT .EQ. 3) WRITE(*,14) BLOCKPAT
   14    FORMAT(//' YOUR BLOCK FORMAT PATIENT FILE, ',A20,' WILL NOW'/
     1' BE OPENED TO READ THE NUMBER OF OUTPUT EQUATIONS, AND THE '/
     2' NUMBER OF DRUGS. LATER YOU WILL HAVE THE OPTION TO CHANGE THE'/
     3' PATIENT INFORMATION. IF YOU DO THIS, MAKE SURE THAT THE NEW'/
     4' PATIENT INFORMATION HAS THE SAME NUMBER OF OUTPUT EQUATIONS'/
     5' AND THE SAME NUMBER OF DRUGS.'//)

	ENDIF


	IF(IFORMT .EQ. 1) THEN


	 PATNEW=PREFIX//'001'//'.'//EXT

C  CALL FULLNAME WHICH CONVERTS THE FILENAME TO PATHFIL2, THE COMPLETE
C  NAME OF THE FILE, WHICH INCLUDES THE PATH (IF THE PATH IS NOT THE
C  CURRENT DIRECTORY).

       TMPFILE = ' '
	 TMPFILE = PATNEW
	 CALL FULLNAME(PATH,TMPFILE,PATHFIL2)

C  AT THIS POINT, THE FIRST PATIENT FILENAME, IN WORKING COPY FORMAT,
C  IS PATHFIL2. OPEN THIS FILE AND READ NUMEQT.

	 OPEN(21,FILE=PATHFIL2)

C  NOTE THAT NUMEQT IS ON THE LINE WITH "NO. OF TOTAL OUTPUT EQUATIONS"
C  IN COLUMNS 12:40. IF NO LINE HAS THESE WORDS, THIS PATIENT DATA
C  FILE IS NOT A NEW-STYLE WORKING COPY FILE FROM ANDREAS' NEW
C  BOXES PROGRAM.

    3    FORMAT(A1000)
   35	 READ(21,3,IOSTAT=IEND) READLINE

        IF(IEND .LT. 0) THEN



         WRITE(*,58) PATHFIL2
   58    FORMAT(//' PATIENT FILE '/
     1'    ',A73/
     2' IS NOT AN ACCEPTABLE WORKING COPY FILE. SUCH A FILE MUST HAVE '/
     2' A LINE WITH "NO. OF DRUGS" IN COLUMNS 12:23.'//
     3' THE PROGRAM STOPS. '//)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,58) PATHFIL2 
        CLOSE(42)



         CALL PAUSE
         STOP



        ENDIF

        IF(READLINE(12:23) .NE. 'NO. OF DRUGS') GO TO 35
        BACKSPACE(21)
   13   FORMAT(T2,I5)
        READ(21,13) NDRUG


   45	  READ(21,3,IOSTAT=IEND) READLINE


        IF(IEND .LT. 0) THEN



         WRITE(*,57) PATHFIL2
   57    FORMAT(//' PATIENT FILE '/
     1'    ',A73/
     2' IS NOT AN ACCEPTABLE WORKING COPY FILE. SUCH A FILE MUST HAVE '/
     2' A LINE WITH "NO. OF TOTAL OUTPUT EQUATIONS" IN COLUMNS 12:40.'//
     3' THE PROGRAM STOPS. '//)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,57) PATHFIL2 
        CLOSE(42)



         CALL PAUSE
         STOP



        ENDIF

        IF(READLINE(12:40) .NE. 'NO. OF TOTAL OUTPUT EQUATIONS') 
     1   GO TO 45
        BACKSPACE(21)
        READ(21,13) NUMEQT
        CLOSE(21)

       
        ENDIF

C  THE ABOVE ENDIF IS FOR THE   IF(IFORMT .EQ. 1)  CONDITION.


	IF(IFORMT .EQ. 3) THEN

C  CALL FULLNAME WHICH CONVERTS "BLOCKPAT" TO PATHFIL2, THE COMPLETE
C  NAME OF THE FILE, WHICH INCLUDES THE PATH (IF THE PATH IS NOT THE
C  CURRENT DIRECTORY).

       TMPFILE = ' '
	 TMPFILE = BLOCKPAT
	 CALL FULLNAME(PATH,TMPFILE,PATHFIL2)
	 OPEN(87,FILE=PATHFIL2,STATUS='OLD')

C  AS OF IT2B103.FOR, BEFORE CALLING NEWCSV, MUST CALL CONVERTCSV,
C  WHICH CONVERTS A "EUROPEAN" .CSV FILE TO THE TYPICAL "AMERICAN"
C  VERSION. IF THE .CSV FILE IS ALREADY IN THE "AMERICAN" FORMAT,
C  CONVERTCSV SIMPLY REWRITES FILE 87 TO SCRATCH FILE 77. NOTE THAT
C  NEWCSV CONVERTS FILE 77 TO FILE 67.

       CALL CONVERTCSV

	 ICODEPAT = 0

 7126  FORMAT(A15)
	 READ(77,7126) CODEPAT
	 IF(CODEPAT .EQ. '"POPDATA APR_11') ICODEPAT = 1
	 IF(CODEPAT(1:14) .EQ. 'POPDATA APR_11') ICODEPAT = 1
       IF(CODEPAT .EQ. '"POPDATA DEC_11') ICODEPAT = 1
       IF(CODEPAT(1:14) .EQ. 'POPDATA DEC_11') ICODEPAT = 1



	 IF(ICODEPAT .EQ. 0) THEN



	  WRITE(*,3131)
 3131     FORMAT(//' YOUR PATIENT DATA BLOCK FORMAT FILE IS NOT FROM '/
     1' THE ALLOWABLE SET OF SUCH FILES.'//
     2' A PATIENT DATA BLOCK FORMAT FILE MUST HAVE "POPDATA XXX_XX IN'/
     3' COLUMNS 1 THROUGH 15 ON LINE 1, WHERE  XXX_XX  IS APR_11 OR A '/
     4' MORE RECENT DATE.'//)
	  WRITE(*,*)' THE PROGRAM STOPS.'

        OPEN(42,FILE=ERRFIL)
         WRITE(42,3131) 
         WRITE(42,*)' THE PROGRAM STOPS.'
        CLOSE(42)



	  CALL PAUSE


	  STOP



 	 ENDIF

C  CALL SUBROUTINE READBLOCK TO RETURN NUMEQT, THE NO. OF OUTPUT EQS,
C  AND NDRUG, THE NO. OF DRUGS, IN THE BLOCK PATIENT DATA SET. NOTE THAT
C  THE 1ST ARGUMENT TO READBLOCK --> CALL IS FROM GETNUMEQ.


C  CALL SUBROUTINE NEWCSV WHICH CONVERTS THE .CSV FILE IN FILE 77 TO
C  A NEW .CSV FILE IN FILE 67, WITH ALL MISSING VALUE DOTS CHANGED TO

C  n's. THEN CALL CSVCHANGE WHICH CHANGES .csv FILES WITH CODE OF
C  POPDATA DEC_11 (I.E., THOSE WITH 2 EXTRA COLUMNS FOR ADDL AND II)
C  TO EQUIVALENT .csv FILES WITH CODE OF POPDATA APR_11 (THOSE WITHOUT

C  THE TWO EXTRA COLUMNS). CSVCHANGE READS FILE 67, AND WRITES THE 
C  INFORMATION TO SCRATCH FILE 66. NOTE THAT IF THE .csv FILE READ IN
C  ALREADY IS THE OLDER VERSION (WITH CODE POPDATA APR_11), CSVCHANGE
C  SIMPLY REWRITES IT TO FILE 66, WHICH IS THEN READ BY SUBROUTINE
C  READBLOCK.

       OPEN(67)
       REWIND(77)


C       WRITE(*,1234)
C1234   FORMAT(/' IF YOU HAVE A LARGE DATA SET, THERE COULD BE A LONG'/
C    1' DELAY (SEVERAL SECONDS TO A MINUTE OR MORE) BEFORE YOU SEE AN'/
C    2' INDICATION THAT THE PROGRAM IS EXAMINING YOUR PATIENT DATA. '//
C    3' THE PROGRAM HAS NOT "HUNG". THIS MIGHT BE A GOOD TIME FOR SOME'/
C    4' QUIET INTROSPECTION ... ')

       CALL NEWCSV
       CALL CSVCHANGE
       REWIND(66)
       CALL READBLOCK(2,NSUBR,MAXSUB,NUMEQT,NDRUG,PATH,C0P,C1P,C2P,C3P,
     1  C4P,C5P,MAXNUMEQ)


	 CLOSE(66)

	ENDIF

C  THE ABOVE ENDIF IS FOR THE   IF(IFORMT .EQ. 3)  CONDITION.

	RETURN
	END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
	SUBROUTINE USECS(IEQ,NCSTORE,GENCOEF,C0,C1,C2,C3,MAXNUMEQ)

	IMPLICIT REAL*8(A-H,O-Z)
	DIMENSION GENCOEF(MAXNUMEQ,5,6),NCSTORE(MAXNUMEQ)


C  THIS ROUTINE, CALLED BY PUTASS, OBTAINS ASSAY COEFFICIENTS,
C  [C0,C1,C2,C3] FROM THE USER TO PUT INTO THE CURRENT PATIENT'S
C  DATA FILE, FOR OUTPUT EQ. IEQ. NCSTORE(IEQ) IS THE CURRENT NO. OF
C  ROWS OF GENCOEF(IEQ,.,.) WHICH HAVE PREVIOUS STORED SETS OF C'S. THE
C  USER CAN PICK FROM THESE STORED SETS OR SELECT A NEW SET. THE USER
C  CAN STORE A NEW SET INTO GENCOEF, UP TO A LIMIT OF NCSTORE(IEQ) =
C  5 SETS.



C  IF NCSTORE(IEQ) = 0 --> NO EXTRA SETS OF ASSAY COEFFICIENTS HAVE BEEN
C  SAVED FROM PREVIOUS SUBJECTS. IN THIS CASE, SET IOLD = 0, WHICH MEANS
C  THE USER WILL HAVE TO ENTER 4 ASSAY COEFFS. BELOW.


	IF(NCSTORE(IEQ) .EQ. 0) IOLD = 0

	IF(NCSTORE(IEQ) .GT. 0) THEN

   35	 WRITE(*,24)
   24    FORMAT(' YOU MAY USE A PREVIOUSLY STORED SET OF COEFFICIENTS'/
     1' OR YOU MAY ENTER ANOTHER SET NOW.'/)


	  DO I=1,NCSTORE(IEQ)
	   WRITE(*,23) I, (GENCOEF(IEQ,I,J),J=1,4)
	  END DO
   23    FORMAT(' ','ENTER ',I1,' TO USE: ',4(G12.6,1X))

	 WRITE(*,26)
   26    FORMAT(/' ENTER 0 TO ENTER A NEW SET OF COEFFICIENTS: ')

	 READ(*,*,ERR=35) IOLD
	 IF(IOLD .LT. 0 .OR. IOLD .GT. NCSTORE(IEQ)) GO TO 35

	ENDIF

C  ABOVE ENDIF IS FOR THE  IF(NCSTORE9IEQ) .GT. 0)  CONDITION.

	IF(IOLD .GT. 0) THEN

	 C0 = GENCOEF(IEQ,IOLD,1)
	 C1 = GENCOEF(IEQ,IOLD,2)
	 C2 = GENCOEF(IEQ,IOLD,3)
	 C3 = GENCOEF(IEQ,IOLD,4)
         C4 = 0.0
         C5 = 0.0
	ENDIF

	IF(IOLD .EQ. 0) THEN


   30	 WRITE(*,21)
   21    FORMAT(' ENTER THE DESIRED ASSAY COEFFICIENTS, [C0,C1,C2,C3]'/
     1' FOR THIS FILE (RECALL ASSAY SD = C0+C1*Y+C2*Y**2+C3*Y**3): ')
	 READ(*,*,ERR=30) C0,C1,C2,C3

	 IF(NCSTORE(IEQ) .EQ. 5) WRITE(*,27) IEQ
   27    FORMAT(/' FOR OUTPUT EQUATION ',I1,' YOU HAVE ALREADY STORED'/
     1' 5 SETS OF ADDITIONAL COEFFICIENTS FOR POSSIBLE USE WITH '/

     2' SUBSEQUENT PATIENT DATA FILES. THESE COEFFICIENTS CANNOT BE '/
     3' STORED.'/)
	 IF(NCSTORE(IEQ) .EQ. 5) CALL PAUSE

	 IF(NCSTORE(IEQ) .LT. 5) THEN

   45	  WRITE(*,28) IEQ
   28     FORMAT(/' ENTER 1 TO STORE THESE COEFFS. FOR POSSIBLE USE'/
     1' 	WITH SUBSEQUENT PATIENT DATA FILES (FOR EQ. ',I1,'); '/
     2' ENTER 0 IF YOU DO NOT WANT TO SAVE THESE COEFFICIENTS: ')
	  READ(*,*,ERR=45) ISTORE
	  IF(ISTORE .NE. 0 .AND. ISTORE .NE. 1) GO TO 45
	  IF(ISTORE .EQ. 1) THEN
	   NCSTORE(IEQ) = NCSTORE(IEQ) + 1
	   GENCOEF(IEQ,NCSTORE(IEQ),1) = C0
	   GENCOEF(IEQ,NCSTORE(IEQ),2) = C1
	   GENCOEF(IEQ,NCSTORE(IEQ),3) = C2
	   GENCOEF(IEQ,NCSTORE(IEQ),4) = C3
	   GENCOEF(IEQ,NCSTORE(IEQ),4) = 0.0
	   GENCOEF(IEQ,NCSTORE(IEQ),4) = 0.0
	  ENDIF



	 ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(NCSTORE(IEQ) .LT. 5)  CONDITION.


	ENDIF

C  ABOVE ENDIF IS FOR THE  IF(IOLD .EQ. 0)  CONDITION.



	RETURN
	END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C

C Yamada // FOLLOWING GETPATH ROUTINE IS COPIED FROM NPBG15E6.FOR.

	SUBROUTINE GETPATH(PATH,NOB,OSName)

C  THIS ROUTINE OBTAINS FROM THE USER THE PATH WHERE THE INPUT FILES
C  ARE LOCATED (AND WHERE THE OUTPUT FILES WILL BE SENT). NOTE THAT
C  PATH RETURNS AS THE PATH WITH A TRAILING BACKSLASH.

C  NOB RETURNS AS THE NO. OF THE LAST NON-BLANK ENTRY IN PATH.

	CHARACTER PATH*60,OSName*20,DIRIN*62,cwd*255
        INTEGER path_len
        LOGICAL dir_exists
        LOGICAL dup_dir

   10	WRITE(*,1)
    1   FORMAT(/' ENTER 1 IF THE FILES FOR THIS RUN ARE IN THE CURRENT D
     1IRECTORY; '/
     1' ENTER 0 OTHERWISE: ')
	READ(*,*,ERR=10) IPATH
	IF(IPATH .NE. 0 .AND. IPATH .NE. 1) GO TO 10

	IF(IPATH .EQ. 1) PATH = ' '
	NOB = 0

C  IF THE USER ENTERS A NON-NULL PATH BELOW, NOB WILL BE THE NO. OF
C  CHARACTERS IN THE PATH. IF HE ENTERS NOTHING, NOB STAYS 0, WHICH IS
C  THE CORRECT NO. OF CHARACTERS IN A NULL PATH.

	IF(IPATH .EQ. 0) THEN
          CALL getcwd(cwd)
          IF (INDEX(OSName,"UNIX",.TRUE.).eq.1) THEN
             WRITE(*,"(A14,A72)") "Your pwd is:",TRIM(cwd)
C             CALL SYSTEM('pwd')
             WRITE(*,4)
          ELSE IF (INDEX(OSName,"DOS",.TRUE.).eq.1) THEN
             WRITE(*,3)
          ENDIF
    4    FORMAT(/' Enter the PATH, begining from root, e.g. /Users/UserN
     1ame/DirName,'/
     1' of your input files. Note that strlen(PATH) must be < 60 char.'/
     2' ENTER THE PATH NOW: ')
    3    FORMAT(/' ENTER THE LOCATION (PATH) OF YOUR INPUT FILES. NOTE'/
     1' THAT THE PATH IS LIMITED TO 60 CHARACTERS AND THAT EACH SUB-DIRE
     2CTORY'/
     3' CAN HAVE AT MOST 8 CHARACTERS (E.G, INSTEAD OF " \DIRECTORY ", U
     4SE '/
     5' THE DOS-EQUIVALENT NAME, WHICH MIGHT BE " \DIRECT~1 "). '//
     6' ENTER THE PATH NOW: ')

   20	 READ(*,2) PATH
    2    FORMAT(A60)


C  IF THE USER DIDN'T END HIS PATH WITH A '\', PUT ONE IN FOR PATH.

C  NOTE THAT IF THE USER ENTERED A BLANK PATH, IT WILL BE ASSUMED THAT

C  HE WANTS THE CURRENT (WORKING) DIRECTORY.

C This block is the original code for Win7 machines
C	 DO I=1,60
C	  J = 60 + 1 - I
C	  IF(PATH(J:J) .NE. ' ') THEN
C	   NOB = J
C	   IF(PATH(J:J) .NE. '\') THEN
C	    PATH(J+1:J+1) = '\'
C	    NOB = J+1
C	   ENDIF
C	   RETURN
C	  ENDIF
C	 END DO

C
C Following code replaces the Win 7 block directly above.
C
C Yamada 5/5/2010 ... add UNIX forwardslash instead of DOS backslash
C                     according to OSName commadn argument.
C Yamada 5/10/2010 ... replace RETURN w/EXIT; and then check for dir
C                     existance
C Yamada 5/12/2010 ... set DO I=1,59 ... instead of 60
         DO I=1,59
          J = 59 + 1 - I
          IF(PATH(J:J) .NE. ' ') THEN
            NOB = J

            IF (INDEX(OSName,"UNIX",.TRUE.).eq.1) THEN
              IF(PATH(J:J) .NE. '/') THEN

                PATH(J+1:J+1) = '/'
                NOB = J+1
              ENDIF
            ELSE IF (INDEX(OSName,"DOS",.TRUE.).eq.1) THEN
              IF(PATH(J:J) .NE. '\') THEN
                PATH(J+1:J+1) = '\'
                NOB = J+1
              ENDIF
            ENDIF
C           RETURN
            EXIT
          ENDIF
         END DO

C
C Yamada 11/5/2010 ... I am including the following UNIX specific code
C w/in the current IF block.

C
C Following ENDIF ends IF(PATH .EQ. 0 ) THEN
C
C        ENDIF

        IF (INDEX(OSName,"UNIX",.TRUE.).eq.1) THEN
          DIRIN=PATH(1:NOB)//'.'
          INQUIRE(FILE=DIRIN,EXIST=dir_exists)
C          WRITE(*,"(A75)") "Checking for FILE: "//DIRIN
          IF (dir_exists.eqv..FALSE.) THEN
             WRITE(*,"(A72)") "Requested PATH does not exist: "//PATH
             WRITE(*,"(A17)") "Enter PATH again:"
             PATH = ' '
             GO TO 20
          ENDIF
C       Now check if entered PATH == cwd
          dup_dir=.TRUE.
          path_len = LEN_TRIM(PATH)-1
          DO I=1,path_len
            IF (PATH(I:I) .NE. cwd(I:I)) THEN
              dup_dir=.FALSE.
              EXIT
            ENDIF
          END DO
          IF (dup_dir .eqv. .TRUE.) THEN
            write(*,*) "You have input the current working directory"
            DO I=1,60
              PATH(I:I)=' '
            END DO
            NOB=0

          ENDIF
        ENDIF
C
C END of Yamada 5/12/2010 edit to GETPATH()
C

C
C Yamada 11/5/2010
C  This ENDIF was moved here from above so that the MacOSX correction
C  can be included w/in the PATH declaration.
C
C Following ENDIF ends IF(PATH .EQ. 0 ) THEN
C
        ENDIF
	RETURN
	END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
	SUBROUTINE FULLNAME(PATH,FILE,FILE2)

C  FULLNAME CONVERTS FILE TO FILE2, THE COMPLETE NAME OF
C  THE FILE, WHICH INCLUDES THE PATH (IF THE PATH IS NOT THE CURRENT
C  DIRECTORY).

	CHARACTER PATH*60,FILE2*73,FILE*13,FILE1*73


C  INITIALIZE FILE1 AND FILE2 AS ALL BLANKS, IN CASE THE USER IS
C  RE-ENTERING HIS FILENAME (SO THERE WON'T BE SOMETHING ALREADY IN
C  THESE FILENAMES).

	FILE2 = ' '
	FILE1 = ' '
	FILE1 = PATH//FILE

C  ESTABLISH FILE2 AS FILE1 WITHOUT ANY BLANKS.

	J = 0
        DO I=1,73
	 IF(FILE1(I:I) .NE. ' ') THEN

	  J= J+1
	  FILE2(J:J) = FILE1(I:I)
	 ENDIF
	END DO

	RETURN
	END

C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C
	SUBROUTINE PRNCOVAR(NCOV,DESCR,NVAR,PAR,ClearScreen)
	CHARACTER DESCR(26)*20,PAR(30)*11,ClearScreen*6

C THIS SUBROUTINE IS CALLED BY PREVRUN TO PRINT OUT THE
C COVARIATES AVAILABLE IN THE USER'S PATIENT DATA FILES, ALONG WITH THE
C RANDOM VARIABLES USED IN THE CURRENT RUN.

C ILINES IS THE RUNNING NO. OF LINES PRINTED TO THE SCREEN. PAUSE
C EVERY 18 LINES (ILINES IS THE RUNNING CURRENT TOTAL OF LINES WHICH
C HAVE GONE TO THE SCREEN SINCE THE LAST PAUSE).

C CLEAR THE SCREEN BEFORE EACH PRINTOUT, FOR CLARITY.

	CALL SYSTEM(ClearScreen)

	WRITE(*,7133)
 7133   FORMAT(/' THE COVARIATES AVAILABLE IN YOUR PATIENT DATA FILES'/
     1' ARE THE FOLLOWING:'//
     2'   NO.   COVARIATE'/)

	ILINES = 4

        IF(NCOV .GT. 4) THEN
         DO I=1,NCOV-4
          WRITE(*,7134) I,DESCR(I)
          ILINES = ILINES + 1
          IF( ILINES/18 .EQ. 1.0*ILINES/18) CALL PAUSE
         END DO
        ENDIF


7134   FORMAT('   ',I2,'   ',A20)

C  NOTE THAT THE LAST 4 ENTRIES IN DESCR() ARE , AGE, SEX,
C  HEIGHT, AND ETHNICITY FLAG. THEY'RE PRINTED BELOW WITH EXTRA INFO.

C  FOR SEX AND ETHNICITY FLAG.

	WRITE(*,7136) NCOV-3
 7136   FORMAT('   ',I2,'   AGE')
	ILINES = ILINES + 1

	IF( ILINES/18 .EQ. 1.0*ILINES/18) CALL PAUSE
	WRITE(*,7137) NCOV-2
 7137   FORMAT('   ',I2,'   SEX -- 1 (MALE) OR 2 (FEMALE)')
	ILINES = ILINES + 1
	IF( ILINES/18 .EQ. 1.0*ILINES/18) CALL PAUSE
	WRITE(*,7138) NCOV-1

 7138   FORMAT('   ',I2,'   HEIGHT')
	ILINES = ILINES + 1
	IF( ILINES/18 .EQ. 1.0*ILINES/18) CALL PAUSE
	WRITE(*,7139) NCOV
 7139   FORMAT('   ',I2,'   ETHNICITY FLAG -- 1,...,9 FOR, RESPECTIVELY
     1,'/
     4'           NOT KNOWN, CAUCASIAN, BLACK, HISPANIC, NATIVE AMER.'/
     5'           INDIAN, ASIAN, MIDDLE EASTERN, OTHER.')

	CALL PAUSE

	WRITE(*,6133)
 6133   FORMAT(/' THE AVAILABLE RANDOM VARIABLES ARE THE FOLLOWING:'//
     2'   NO.   R.V.'/)

	ILINES = 4

	DO I=1,NVAR
   	 WRITE(*,6134) NCOV+I,PAR(I)
	 ILINES = ILINES + 1
	 IF( ILINES/18 .EQ. 1.0*ILINES/18) CALL PAUSE
	END DO
 6134   FORMAT('   ',I2,'   ',A11)




	RETURN
	END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
	SUBROUTINE GETCOVAL(NUMEQT,JSUB,COVAL,NCOV)


C  GETCOVAL IS CALLED BY MAIN TO READ THE PORTION OF FILE 27 WHICH
C  APPLIES TO THE SUBJECT UNDER CONSIDERATION. THE 'POINTER' FOR FILE 27

C  IS IN THE PROPER POSITION TO BEGIN READING THE INFO FOR THE DESIRED
C  SUBJECT.

        IMPLICIT REAL*8(A-H,O-Z)
        DIMENSION COVAL(999,26)
	CHARACTER SEX*1,READLINE*1000

C  INPUT IS: FILE 27, WHICH IS POSITIONED AT THE BEGINNING OF
C  THE INFO FOR THE SUBJECT DESIRED.

C  OUTPUT ARE:

C  COVAL(JSUB,J),J=1,NCOV = THE VALUES ASSOCIATED WITH EACH OF THE
C    NCOV COVARIATES. NOTE THAT THE LAST 4 ARE ALWAYS AGE, ISEX, HEIGHT,
C    AND ETHNICITY FLAG, WHICH HAVE FIXED VALUES AT THE TOP OF THE FILE.
C    ALSO NOTE THAT FOR ANY OF THE 1ST NCOV-4 COVARIATES, A VALUE OF
C    -99 MEANS THAT VALUE WAS UNAVAILABLE.

C  AGE, SEX, HEIGHT, AND ETHNICITY FLAG ARE ON LINES 8-11.

	DO I=1,7
	 READ(27,*)
	END DO

	READ(27,*) COVAL(JSUB,NCOV-3)
	READ(27,2) SEX
    2   FORMAT(A1)
	COVAL(JSUB,NCOV-2) = 1
	IF(SEX .EQ. 'F') COVAL(JSUB,NCOV-2) = 2
	READ(27,*) COVAL(JSUB,NCOV-1)
	READ(27,*) COVAL(JSUB,NCOV)

C  SKIP TO THE COVARIATE (1ST, LAST, AND MEAN) INFO NEAR BOTTOM OF FILE.

    1   FORMAT(A1000)
   20	READ(27,1) READLINE
	IF(READLINE(2:27) .NE. 'COVARIATE NAMES AND VALUES') GO TO 20


        IF(NCOV .GT. 4) THEN
         
         DO J = 1,NCOV-4

          READ(27,1) READLINE

C  FOR THIS COVARIATE, WRITE THE PORTION OF THE CURRENT LINE WHICH IS

C  PAST THE COVARIATE NAME INTO SCRATCH FILE 53. THEN REWIND FILE 53
C  AND READ IN THE 3RD VALUE AS THE COV. VALUE. NOTE THAT IT IS
C  ASSUMED THAT ANY ENTRY WHICH IS A SPACE AT OR AFTER ENTRY 10 IS
C  PAST THE COVARIATE NAME.

          OPEN(53)


          DO I = 10,300
           IF(READLINE(I:I) .EQ. ' ') GO TO 10
          END DO

   10     WRITE(53,1) READLINE(I:300)
          REWIND(53)
          READ(53,*) XJUNK1,XJUNK2,COVAL(JSUB,J)
          CLOSE(53)

         END DO

        ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(NCOV .GT. 4) CONDITION.


C  READ TO THE END OF THE FILE SO THE NEXT CALL TO THIS ROUTINE WILL
C  START WITH THE BEGINNING LINE OF THE NEXT PATIENT'S INFO.
C  THERE ARE JUST 2 + NUMEQT MORE LINES: ONE BLANK LINE; ONE HAS
C  "ASSAY COEFFICIENTS FOLLOW:"; AND THE LAST NUMEQT HAVE THE ASSAY
C  COEFFICIENTS FOR EACH OUTPUT EQ.

	READ(27,*)
	READ(27,*)
	DO I=1,NUMEQT
	 READ(27,*)
	END DO

	RETURN
	END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C  ??? AS OF IT2B105.FOR, SUBROUTINE DETECT IS REMOVED. IT WASN'T
C  USED ANYMORE.
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

C
	SUBROUTINE CHECKLIN(READLINE,TARGET,IYES)
	CHARACTER TARGET*17,READLINE*1000



C  THIS ROUTINE, CALLED BY SUBROUTINE DETECT, CHECKS READLINE TO SEE IF
C  ANYWHERE IN IT (STARTING WITH COLUMN 7) IS THE 17-CHARACTER PHRASE,
C  TARGET. IF SO, IYES RETURNS AS 1; OTHERWISE IYES RETURNS AS 0.

	IYES = 0
	DO I=7,67

	 IF(READLINE(I:I+16) .EQ. TARGET) THEN
	  IYES = 1
	  GO TO 10
	 ENDIF
	END DO

   10   RETURN
	END

C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
	SUBROUTINE WRITEDIF(IVERS)
	CHARACTER READLINE*1000


C  THIS ROUTINE, CALLED BY DETECT, WRITES TO FILE 52 THE "TOP" OF
C  SUBROUTINE DIFFEQ (OF THE FORTRAN MODEL FILE). THE CORRECT VERSION
C  OF THIS "TOP" IS DETERMINED BY IVERS.

C  IF IVERS = 1 --> PARALLELIZED VERSION AT SDSC OR USC LABORATORY;
C             0 --> UNPARALLELIZED (BETA) VERSION ON USC sun.


C  THE TOP 5 LINES ARE THE SAME REGARDLESS OF THE VERSION.

    1   FORMAT(A1000)
	READLINE = '      SUBROUTINE DIFFEQ(NDIM,T,X,XP,RPAR,IPAR)'
	WRITE(52,1) READLINE
	READLINE = '      IMPLICIT REAL*8(A-H,O-Z)'
	WRITE(52,1) READLINE
	READLINE = '      COMMON /PARAMD/ P'
	WRITE(52,1) READLINE



      READLINE = '      COMMON /INPUT/ R,B'
	WRITE(52,1) READLINE
	READLINE = '      COMMON /DESCR/ AGE,HEIGHT,ISEX,IETHFLG'
	WRITE(52,1) READLINE

	IF(IVERS .EQ. 0) THEN
	 READLINE = '      COMMON /CNST2/ NPL,NUMEQT,NDRUG,NADD'
	 WRITE(52,1) READLINE
	ENDIF

	IF(IVERS .EQ. 1)
     1  READLINE = '      DIMENSION X(NDIM),XP(NDIM),P(25),R(37),B(20)'
	IF(IVERS .EQ. 0)
     1  READLINE = '      DIMENSION X(NDIM),XP(NDIM),P(32),R(37),B(20)'
	WRITE(52,1) READLINE

	IF(IVERS .EQ. 0) THEN
         READLINE = '      DIMENSION CV(26),RATEIV(7)'
	 WRITE(52,1) READLINE
	ENDIF

	WRITE(52,*)

	END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
	SUBROUTINE WRITEOUT(IVERS)
	CHARACTER READLINE*1000

C  THIS ROUTINE, CALLED BY DETECT, WRITES TO FILE 52 THE "TOP" OF
C  SUBROUTINE OUTPUT (OF THE FORTRAN MODEL FILE). THE CORRECT VERSION
C  OF THIS "TOP" IS DETERMINED BY IVERS.



C  IF IVERS = 1 --> PARALLELIZED VERSION AT SDSC OR USC LABORATORY;
C             0 --> UNPARALLELIZED (BETA) VERSION ON USC sun.

C  LINES 2 - 6 ARE THE SAME REGARDLESS OF THE VERSION.

    1   FORMAT(A1000)


	IF(IVERS .EQ. 1)
     1  READLINE = '      SUBROUTINE OUTPUT(Y)'
	IF(IVERS .EQ. 0)
     1  READLINE = '      SUBROUTINE OUTPUT(T,Y)'
	WRITE(52,1) READLINE


	READLINE = '      IMPLICIT REAL*8(A-H,O-Z)'
	WRITE(52,1) READLINE
	READLINE = '      COMMON /PARAMD/ P'
	WRITE(52,1) READLINE
	READLINE = '      COMMON /STATE/ X'
	WRITE(52,1) READLINE

	READLINE = '      COMMON /INPUT/ R,B'
	WRITE(52,1) READLINE
	READLINE = '      COMMON /DESCR/ AGE,HEIGHT,ISEX,IETHFLG'
	WRITE(52,1) READLINE

	IF(IVERS .EQ. 0) THEN
	 READLINE = '      COMMON /CNST2/ NPL,NUMEQT,NDRUG,NADD'

	 WRITE(52,1) READLINE
	ENDIF

	IF(IVERS .EQ. 1)
     1  READLINE = '      DIMENSION X(20),P(25),Y(6),R(37),B(20)'
	IF(IVERS .EQ. 0)
     1  READLINE = '      DIMENSION X(20),P(32),Y(6),R(37),B(20)'
	WRITE(52,1) READLINE


	IF(IVERS .EQ. 0) THEN
         READLINE = '      DIMENSION CV(26)'
	 WRITE(52,1) READLINE
	ENDIF

	WRITE(52,*)


	RETURN
	END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
	SUBROUTINE WRITESYM(IVERS)
	CHARACTER READLINE*1000

C  THIS ROUTINE, CALLED BY DETECT, WRITES TO FILE 52 THE "TOP" OF
C  SUBROUTINE SYMBOL (OF THE FORTRAN MODEL FILE). THE CORRECT VERSION
C  OF THIS "TOP" IS DETERMINED BY IVERS.

C  IF IVERS = 1 --> PARALLELIZED VERSION AT SDSC OR USC LABORATORY;
C             0 --> UNPARALLELIZED (BETA) VERSION ON USC sun.

C  THE 1ST 3 LINES ARE THE SAME REGARDLESS OF THE VERSION. THE NEXT
C  LINES DEPEND ON THE VERSION.

    1   FORMAT(A1000)
	READLINE = '      SUBROUTINE SYMBOL'
	WRITE(52,1) READLINE
        READLINE = '      IMPLICIT REAL*8(A-H,O-Z)'

	WRITE(52,1) READLINE
	READLINE = '      CHARACTER PSYM(32)*11'

	WRITE(52,1) READLINE

	IF(IVERS .EQ. 1) THEN
	 READLINE = '      COMMON /CNST/ N,ND,NI,NUP,NUIC,NP'
	 WRITE(52,1) READLINE
	ENDIF

	IF(IVERS .EQ. 0) THEN
	 READLINE = '      COMMON /CNST/ N,ND,NI,NUP,NUIC,NP'

	 WRITE(52,1) READLINE
	 READLINE = '      COMMON/BOLUSCOMP/NBCOMP'
	 WRITE(52,1) READLINE
	 READLINE = '      DIMENSION NBCOMP(7)'
	 WRITE(52,1) READLINE
	ENDIF

	RETURN
	END
C

CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
	SUBROUTINE SKIPLINE(READLINE,IYES)
	CHARACTER READLINE*1000

C  SUBROUTINE SKIPLINE IS CALLED BY DETECT TO SEE IF READLINEN HAS ANY
C  OF THE KEY WORDS, 'COMMON', 'DIMENSION', OR 'CHARACTER'. IF SO, IYES

C  RETURNS AS 1. OTHERWISE, IYES RETURNS AS 0.

	IYES = 1
	DO I=7,64
	 IF(READLINE(I:I+5) .EQ. 'COMMON') RETURN
	 IF(READLINE(I:I+8) .EQ. 'DIMENSION') RETURN
	 IF(READLINE(I:I+8) .EQ. 'CHARACTER') RETURN
	END DO

C  TO GET HERE MEANS THAT READLINE CONTAINED NONE OF THE KEY WORDS, SO
C  SET IYES = 0 AND RETURN.

	IYES = 0
	RETURN
	END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
	SUBROUTINE SEPARATE
	CHARACTER READLINE*1000

C  THIS ROUTINE, CALLED BY SUBROUTINE EXTRAOPT, SEPARATES THE INFO IN
C  FILE 45 INTO 4 NEW FILES:



C  FILE 25 WILL CONTAIN THE 1ST PART OF FILE 45(THE OLD "OUTPUT" INFO).
C  FILE 28 WILL CONTAIN THE 2ND PART OF FILE 45(THE OLD "LAST CYCLE
C   PARAMETER" FILE).
C
C  FILE 27 WILL CONTAIN THE 3RD PART OF FILE 45(THE PATIENT DATA INFO).
C  FILE 47 WILL CONTAIN THE 4TH PART OF FILE 45(THE it2bdriv.f INFO).

    1   FORMAT(A1000)

	OPEN(25,FILE='JUNKTRASH0001')
	OPEN(28,FILE='JUNKTRASH0002')
	OPEN(27,FILE='JUNKTRASH0003')
	OPEN(47,FILE='JUNKTRASH0004')


	REWIND(45)


   10	READ(45,1) READLINE

	IF(READLINE(17:42) .EQ. '* END OF THE OUTPUT FILE *') GO TO 20

	WRITE(25,1) READLINE
	GO TO 10

   20	READ(45,1) READLINE
	IF(READLINE(1:8) .NE. ' REM_FRN') GO TO 20
   	WRITE(28,1) READLINE
   30   READ(45,1) READLINE
	IF(READLINE(11:27) .EQ. 'END OF LAST CYCLE') GO TO 40

	WRITE(28,1) READLINE
	GO TO 30


   40   READ(45,1) READLINE
	IF(READLINE(3:16) .NE. 'LAST AND FIRST') GO TO 40
   	WRITE(27,1) READLINE
   50   READ(45,1) READLINE


	IF(READLINE(17:43) .EQ. '* END OF THE PATIENT DATA I') GO TO 60
	WRITE(27,1) READLINE
	GO TO 50

   60   READ(45,1) READLINE

	IF(READLINE(17:43) .NE. '* START OF THE it2bdriv.f F') GO TO 60
   	WRITE(47,1) READLINE
   70   READ(45,1) READLINE

	IF(READLINE(17:43) .EQ. '* END OF THE it2bdriv.f FIL') GO TO 80
	WRITE(47,1) READLINE
	GO TO 70

C  CURRENTLY, FILE 47, WHICH HAS THE it2bdriv.f CODE, IS NOT USED,
C  UNLIKE IN THE BIG NPAG PC PREP PROGRAM, WHICH WRITES THIS FILE

C  TO AN OUTPUT FILE IF THE USER SELECTS THE OPTION TO CALL
C  SUBROUTINE FORMLC.


   80   WRITE(47,1) READLINE

	REWIND(25)
	REWIND(27)
	REWIND(47)
	CLOSE(45)

C  CLOSE AND REOPEN FILE 28 WITH THE 'APPEND' SPECIFIER SO THE FILE
C  WILL BE POSITIONED AT THE LAST RECORD, SO FINAL CYCLE PARAMETER

C  ESTIMATES CAN BE READ IN IN SUBROUTINE EXTRAOPT.

	CLOSE(28)
	OPEN(28,FILE='JUNKTRASH0002',STATUS='OLD',POSITION='APPEND')


	RETURN
	END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
	SUBROUTINE GETNUM(NUMEQT)
	IMPLICIT REAL*8(A-H,O-Z)
	CHARACTER READLINE*1000,ERRFIL*20

      COMMON/ERROR/ERRFIL
C  COMMON/ERROR/ IS SUPPLIED TO ALL THE ROUTINES WHICH COULD WRITE TO
C  ERRFIL. 


C  THIS SUBROUTINE, CALLED BY EXTRAOPT, READS DOWN IN FILE 27, WHICH IS
C  ALREADY REWOUND TO OBTAIN THE NO. OF OUTPUT EQUATIONS (NUMEQT).

    2   FORMAT(A1000)

C  NOTE THAT NUMEQT IS ON THE LINE WITH "NO. OF TOTAL OUTPUT EQUATIONS"

C  IN COLUMNS 12:40. IF NO LINE HAS THESE WORDS, THIS PATIENT DATA
C  FILE IS NOT A NEW-STYLE WORKING COPY FILE FROM ANDREAS' NEW
C  BOXES PROGRAM.

   35	READ(27,2,IOSTAT=IEND) READLINE

	IF(IEND .LT. 0) THEN



	 WRITE(*,57)
   57    FORMAT(//' THE COMBINATION OUTPUT FILE YOU HAVE ENTERED TO'/
     1' THIS PROGRAM WAS NOT MADE BY A RECENT BIG IT2B PROGRAM.'//
     2' SUCH A FILE MUST HAVE CONCATENATED PATIENT DATA FILES HAVING'/
     3' A LINE WITH "NO. OF TOTAL OUTPUT EQUATIONS" IN COLUMNS 12:40.'//
     3' THE PROGRAM STOPS. '//)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,57) 
        CLOSE(42)




	 CALL PAUSE
	 STOP



	ENDIF

	IF(READLINE(12:40) .NE. 'NO. OF TOTAL OUTPUT EQUATIONS')GO TO 35
	BACKSPACE(27)
   13   FORMAT(T2,I5)
        READ(27,13) NUMEQT

	RETURN
	END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
	SUBROUTINE GETIPAT(NSUBTOT,NSUB,ISUBALL,MAXSUB,IPATVEC)
	DIMENSION IPATVEC(MAXSUB),IPATVECC(9999)
	CHARACTER READLINE*1000

C  SUBROUTINE GETIPAT IS CALLED TO OBTAIN THE NO. OF SUBJECTS IN THE
C  ENTIRE DATA SET, NSUBTOT, THE NO. OF THESE SUBJECTS TO BE USED
C  IN THE CURRENT ANALYSIS, NSUB, AND THE INDICES OF THESE "ACTIVE"
C  SUBJECTS, IPATVEC(I),I=1,NSUB. NOTE ALSO THAT ISUBALL = 1 IF ALL
C  SUBJECTS ARE USED (I.E., NSUB = NSUBTOT) AND 0 OTHERWISE.




    3   FORMAT(A1000)
 4070	WRITE(*,121)
  121   FORMAT(/' ENTER THE NO. OF SUBJECTS IN YOUR ENTIRE DATA SET.'/
     1' THIS MAY BE DIFFERENT THAN THE NO. OF SUBJECTS TO BE TO BE '/


     2' ANALYZED IN THIS PARTICULAR RUN (SEE BELOW): ')
 	READ(*,*,ERR=4070) NSUBTOT
	IF(NSUBTOT .LE. 0) GO TO 4070

 4170	WRITE(*,2121) NSUBTOT
 2121   FORMAT(/' ENTER 1 IF ALL ',I4,' SUBJECTS IN YOUR DATA SET ARE'/
     1' 	TO BE ANALYZED IN THIS RUN; '/
     2'		ENTER 0 IF YOU WANT TO ANALYZE A SUBSET OF THIS SET: ')
	READ(*,*,ERR=4170) ISUBALL
	IF(ISUBALL .NE. 1 .AND. ISUBALL .NE. 0) GO TO 4170

	IF(ISUBALL .EQ. 1) THEN


	 NSUB = NSUBTOT

C  PUT ALL SUBJECT NOS. INTO THE VECTOR, IPATVEC.

	 DO I=1,NSUB
	  IPATVEC(I) = I
	 END DO

	ENDIF


     	IF(ISUBALL .EQ. 0) THEN

 4180	 WRITE(*,2122)
 2122    FORMAT(/' ENTER 1 IF YOU WANT TO SELECT WHICH PATIENTS ARE TO'/
     1' 	BE INCLUDED IN THE ANALYSIS; '/
     2' ENTER 2 IF YOU WANT TO SELECT WHICH PATIENTS ARE NOT TO BE'/
     3'		INCLUDED IN THE ANALYSIS: ')
	 READ(*,*,ERR= 4180) IINCLUDE
	 IF(IINCLUDE .NE. 1 .AND. IINCLUDE .NE. 2) GO TO 4180


C  IF IINCLUDE = 1, THE NOS. THE USERS ENTERS BELOW WILL BE THE INDICES
C  OF THE SUBJECTS TO BE INCLUDED IN THE ANALYSIS. IF IINCLUDE = 2, THE
C  NOS. ENTERED WILL BE THE INDICES OF THE SUBJECTS TO BE EXCLUDED IN
C  THE ANALYSIS.


	  NSUBB = 0
	  NUMCUR = 0

C  NSUBB WILL BE THE NO. OF SUBJECTS SELECTED BY THE USER. IT IS
C  INITIALIZED AS 0, AND WILL GROW AS THE USER ENTERS THE PATIENT NOS.
C  TO BE INCLUDED (IF IINCLUDE = 1) OR EXCLUDED (IF IINCLUDE = 2) IN THE
C  ANALYSIS.

C  NUMCUR IS THE INDEX OF THE HIGHEST PATIENT NO. ENTERED SO FAR.


 4200	   IF(IINCLUDE .EQ. 1) WRITE(*,2124)
 2124      FORMAT(/' ON EACH LINE, ENTER A SUBJECT OR A RANGE OF '/
     1' SUBJECTS TO BE INCLUDED IN THE ANALYSIS. YOU MAY ENTER '/
     2' MULTIPLE SUBJECTS USING HYPHENS, COMMAS, AND SPACES. FOR'/
     3' EXAMPLE, 17 - 28 INDICATES SUBJECTS 17 THROUGH 28; '/
     4'          17,28 INDICATES SUBJECTS 17 AND 28;'/
     5'          17 28 INDICATES SUBJECTS 17 AND 28. '//
     6' RESTRICTIONS: 1. ON EACH LINE, USE NO MORE THAN 70 CHARACTERS.'/
     7'		      2. PATIENT NOS., OR RANGES OF PATIENT NOS.,'/
     8'		         MUST BE LISTED IN ASCENDING ORDER.'//
     9' ENTER 0 WHEN YOU ARE FINISHED ENTERING PATIENT NOS.'//)

	IF(IINCLUDE .EQ. 2) WRITE(*,2123)
 2123      FORMAT(/' ON EACH LINE, ENTER A SUBJECT OR A RANGE OF '/

     1' SUBJECTS TO BE EXCLUDED IN THE ANALYSIS. YOU MAY ENTER '/
     2' MULTIPLE SUBJECTS USING HYPHENS, COMMAS, AND SPACES. FOR'/
     3' EXAMPLE, 17 - 28 INDICATES SUBJECTS 17 THROUGH 28; '/
     4'          17,28 INDICATES SUBJECTS 17 AND 28;'/
     5'          17 28 INDICATES SUBJECTS 17 AND 28. '//
     6' RESTRICTIONS: 1. ON EACH LINE, USE NO MORE THAN 70 CHARACTERS.'/
     7'		      2. PATIENT NOS., OR RANGES OF PATIENT NOS.,'/
     8'		         MUST BE LISTED IN ASCENDING ORDER.'//
     9' ENTER 0 WHEN YOU ARE FINISHED ENTERING PATIENT NOS.'//)


 4210	   READ(*,3,ERR=4200) READLINE

C  CALL SUBROUTINE GETNUMS TO UPDATE NSUBB AND IPATVECC, WHERE IPATVECC
C  IS THE VECTOR WHICH CONTAINS THE PATIENT NOS. TO BE INCLUDED IN THE
C  ANALYSIS IF IINCLUDE = 1, AND THE PATIENT NOS. TO BE EXCLUDED IF
C  IINCLUDE = 2.

C  NOTE THAT ISTOP RETURNS AS 0 IF THE USER IS FINISHED ENTERING

C  PATIENT NOS; IT RETURNS AS -1 IF THE USER HAS ENTERED A CONFLICTING
C  SET OF PATIENT NOS. (SEE RESTRICTION ABOVE) OR A PATIENT NO. LARGER
C  THAN NSUBTOT (THE MAXIMUM ALLOWABLE NO. OF SUBJECTS); AND IT RETURNS
C  AS 1 IF THE USER HAS CORRECTLY ENTERED PATIENT DATA AND WANTS TO
C  CONTINUE ENTERING OTHER NOS.

	   CALL GETNUMS(IINCLUDE,READLINE,NSUBB,NSUBTOT,NUMCUR,ISTOP,
     1                  MAXSUB,IPATVECC)
	   IF(ISTOP .EQ. -1) GO TO 4200
	   IF(ISTOP .EQ. 1) GO TO 4210

C  TO GET TO THIS POINT, ISTOP = 0 --> USER HAS STOPPED ENTERING
C  PATIENT NOS.

C  IF IINCLUDE = 1, SET NSUB = NSUBB, THE NO. OF PATIENTS TO BE INCLUDED
C  IN THE ANALYSIS, AND SET IPATVEC = IPATVECC (WHICH IS THE VECTOR OF
C  INDICES OF THESE PATIENTS).


C  IF IINCLUDE = 2, SET NSUB = NSUBTOT - NSUBB (SINCE NSUBB IS THE NO.
C  OF PATIENTS TO BE EXCLUDED), AND SET IPATVEC TO CONTAIN THE INDICES

C  WHICH ARE NOT IN IPATVECC.

	IF(IINCLUDE .EQ. 1) THEN
	 NSUB = NSUBB
	  DO I = 1,NSUB
	   IPATVEC(I) = IPATVECC(I)

	  END DO
	ENDIF


	IF(IINCLUDE .EQ. 2) THEN

	 NSUB = NSUBTOT - NSUBB
	 INDPAT = 1
	 NEXT = 0

	 DO I = 1,NSUBTOT

	  IF(I .NE. IPATVECC(INDPAT)) THEN
	   NEXT = NEXT + 1
	   IPATVEC(NEXT) = I
	  ENDIF

	  IF(I .EQ. IPATVECC(INDPAT)) INDPAT = INDPAT + 1

	 END DO

	ENDIF


	ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(ISUBALL .EQ. 0)  CONDITION.


C  NOW THE SUBJECT INDICES FOR THOSE PATIENTS TO BE ANALYZED IN
C  THIS RUN ARE IN IPATVEC(I),I=1,NSUB.

	RETURN
	END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
	SUBROUTINE GETNUMS(IINCLUDE,READLINE,NSUBB,NSUBTOT,NUMCUR,ISTOP,
     1                  MAXSUB,IPATVECC)

	DIMENSION IPATVECC(MAXSUB)
	CHARACTER READLINE*1000


C  SUBROUTINE GETNUMS IS CALLED BY GETIPAT AND GETIPATF (OVER AND OVER)
C  TO ESTABLISH NSUBB AND IPATVECC, WHERE NSUBB IS THE NO. OF SUBJECTS
C  TO BE INCLUDED (IF IINCLUDE = 1) OR EXCLUDED (IF IINCLUDE = 2) IN THE
C  ANALYSIS, AND IPATVECC IS THE VECTOR WHICH CONTAINS THE CORRESPONDING
C  PATIENT NOS. EACH CALL TO GETNUMS EITHER ADDS TO THE VALUES IN
C  IPATVECC (AND INCREASES NSUBB) OR STOPS THE PROCESS.

C  NOTE THAT ISTOP RETURNS AS 0 IF THE USER IS FINISHED ENTERING

C  PATIENT NOS; IT RETURNS AS -1 IF THE USER HAS ENTERED A CONFLICTING
C  SET OF PATIENT NOS. (EACH PATIENT NO. OR RANGE OF NUMBERS MUST BE
C  GREATER THAN ANY PATIENT NO. ALREADY ENTERED ... THE LARGEST PATIENT
C  NO. ENTERED SO FAR IS NUMCUR) OR A PATIENT NO. LARGER THAN NSUBTOT
C  (THE MAXIMUM ALLOWABLE NO. OF SUBJECTS); AND IT RETURNS AS 1 IF THE
C  USER HAS CORRECTLY ENTERED PATIENT DATA AND WANTS TO CONTINUE
C  ENTERING OTHER NOS.

	ISTOP = 1

C  CHECK TO SEE IF THIS IS A BLANK LINE. IF SO, RETURN ISTOP = -1

C  WITH A MESSAGE TO THE USER.

	DO J = 1,70
	 IF(READLINE(J:J) .NE. ' ') GO TO 10
	END DO

C  TO GET HERE --> READLINE IS COMPLETELY BLANK.

	IF(NSUBB .EQ. 0) WRITE(*,1)
    1   FORMAT(/' YOU HAVE ENTERED A BLANK LINE. PLEASE ENTER SUBJECT'/
     1' NOS. AS INDICATED BELOW.' /)
	IF(NSUBB .GT. 0) WRITE(*,2) NSUBB,NUMCUR

    2   FORMAT(/' YOU HAVE ENTERED A BLANK LINE. THE LAST ACCEPTED '/
     1' SUBJECT NO. IS ',I4//
     3' PLEASE ENTER SUBJECT NOS. AS INDICATED BELOW. ')
	ISTOP = -1
	RETURN


   10   CONTINUE

C  CHECK TO SEE IF THIS LINE HAS JUST A 0 ON IT. IF SO, RETURN ISTOP
C  = 0, UNLESS NSUBB = 0 AND IINCLUDE = 1, IN WHICH CASE THIS IS AN
C  ERROR. SIMPLY CHECK THE FIRST NON-BLANK CHARACTER (THERE MUST BE ONE
C  SINCE IF THE LINE IS COMPLETELY BLANK, THE CODE ABOVE ABOVE WOULD
C  HAVE DETECTED IT AND RETURNED CONTROL TO THE CALLING ROUTINE) AND
C  SEE IF a. IT IS A 0, AND b. EVERY OTHER CHARACTER IS A BLANK. IF

C  a. AND b. ARE TRUE, THE LINE JUST HAS A 0 IN IT. OTHERWISE NOT.

	DO J = 1,70
	 IF(READLINE(J:J) .NE. ' ') GO TO 20
	END DO


   20   ISTART = J
	IF(READLINE(ISTART:ISTART) .NE. '0') GO TO 30

	DO I = ISTART+1,70
	 IF(READLINE(I:I) .NE. ' ') GO TO 30
	END DO

C  TO GET HERE --> READLINE HAS JUST A 0 ON IT AND NOTHING ELSE.

C  IF THE USER HAS ENTERED A 0 WITH NSUBB = 0 (I.E., HE HAS NOT
C  ENTERED PREVIOUS SUBJECT NOS.), THIS IS OK IF IINCLUDE = 2 (SINCE
C  IT IS OK TO EXCLUDE 0 PATIENTS), BUT IT IS NOT OK IF IINCLUDE = 1
C  (SINCE THIS WOULD MEAN THE ANALYSIS WOULD BE ON 0 SUBJECTS).

	IF(IINCLUDE .EQ. 1 .AND. NSUBB .EQ. 0) THEN
	 WRITE(*,3)
    3    FORMAT(/' YOU MUST ENTER AT LEAST ONE SUBJECT NO. TO BE'/
     1' ANALYZED. ')
	 ISTOP = -1

	 RETURN
	ENDIF

	IF(IINCLUDE .EQ. 2 .OR. NSUBB .GT. 0) THEN
	 ISTOP = 0
	 RETURN
	ENDIF


   30   CONTINUE


C  TO GET TO THIS POINT MEANS READLINE HAS A POTENTIAL NO. BEGINNING
C  AT ENTRY ISTART. IF THIS IS A LEGITIMATE NO., IT ENDS THE ENTRY
C  BEFORE THE NEXT SPACE, COMMA, DASH, WHICHEVER COMES FIRST.

     	DO I = ISTART+1,70
	 IF(READLINE(I:I) .EQ. ' ' .OR. READLINE(I:I) .EQ. ',' .OR.
     1      READLINE(I:I) .EQ. '-') GO TO 40

	END DO

   40   IEND = I-1

C  CALL ROUTINE GETSUB WHICH OBTAINS THE SUBJECT NO. FROM THE
C  CHARACTERS IN READLINE(ISTART:IEND).


	CALL GETSUB(READLINE,ISTART,IEND,ISUB,IERROR)

C  IF IERROR RETURNS AS -1, IT MEANS THE USER HAS ENTERED A NON-NUMERIC
C  CHARACTER. IN THIS CASE, PRINT AN ERROR MESSAGE AND RETURN.

	IF(IERROR .EQ. -1) THEN
	 WRITE(*,7) NUMCUR
    7    FORMAT(/' YOU HAVE ENTERED AN INVALID CHARACTER; THE LAST'/
     1' ACCEPTED PATIENT NUMBER IS ',I4//
     2' PLEASE ENTER SUBJECT NOS. AS INDICATED BELOW. ')
	 ISTOP = -1
	 RETURN
	ENDIF

C  IF ISUB IS .LE. NUMCUR, THE LAST (AND HIGHEST PATIENT NO. ENTERED
C  PREVIOUSLY), WRITE AN ERROR MESSAGE TO THE USER AND RETURN.
C  SIMILARLY, IF ISUB .GE. NSUBTOT.

	IF(ISUB .LE. NUMCUR) THEN
	 WRITE(*,4) ISUB,NUMCUR
    4    FORMAT(/' YOU MAY NOT ENTER A SUBJECT NO. (',I4,' ) WHICH IS '/
     1' LESS THAN OR EQUAL TO A PREVIOUSLY ENTERED SUBJECT NO.,'/
     2' IN PARTICULAR ',I4,' WHICH IS THE LAST ACCEPTED SUBJECT NO.'//
     3' PLEASE ENTER SUBJECT NOS. AS INDICATED BELOW. ')
	 ISTOP = -1
	 RETURN
	ENDIF


	IF(ISUB .GT. NSUBTOT) THEN
	 WRITE(*,6) ISUB,NSUBTOT,NUMCUR

    6    FORMAT(/' YOU MAY NOT ENTER A SUBJECT NO. (',I4,' ) WHICH'/
     1' IS GREATER THAN THE NO. OF SUBJECTS IN YOUR DATA FILE = ',I4/

     2' THE LAST ACCEPTED SUBJECT NO. IS ',I4//
     3' PLEASE ENTER SUBJECT NOS. AS INDICATED BELOW. ')
	 ISTOP = -1
	 RETURN
	ENDIF

C  TO GET TO THIS POINT, THE PATIENT NO., ISUB, IS LEGITIMATE. I.E.,
C  IT IS .GT. NUMCUR AND .LE. NSUBTOT. THERE ARE 4 POSSIBILITIES:


C  1. IF THERE ARE NO OTHER ENTRIES IN READLINE PAST THIS POINT,
C  ISUB IS A SINGLE PATIENT NO.
C  2. IF THE NEXT NON-BLANK ENTRY IN READLINE IS A COMMA OR ANOTHER
C  NUMBER, ISUB IS A SINGLE PATIENT NO.
C  3. IF THE NEXT NON-BLANK ENTRY IN READLINE IS A DASH, ISUB IS THE
C  START OF A PATIENT RANGE.
C  4. IF THE NEXT NON-BLANK ENTRY IN READLINE IS ANOTHER CHARACTER
C  (I.E., NOT A NUMBER, DASH, OR COMMA), THE LINE HAS BEEN ENTERED
C  INCORRECTLY BY THE USER.


C  CHECK FOR NO. 1. ABOVE ...

	DO I = IEND+1,70
	 IF(READLINE(I:I) .NE. ' ') GO TO 50
	END DO

C  TO GET TO THIS POINT, ISUB IS AN INDIVIDUAL SUBJECT NO., AND THE
C  LAST NO. ON THE LINE. INCREASE NSUBB, NUMCUR, AND PUT THIS SUBJECT
C  NO. INTO IPATVECC BEFORE RETURNING.

	NUMCUR = ISUB
	NSUBB = NSUBB + 1
	IPATVECC(NSUBB) = ISUB
	RETURN


   50   CONTINUE

C  CHECK FOR NOS. 2,3, OR 4 (SEE ABOVE).

C  TO GET TO THIS POINT, THERE IS AT LEAST ONE CHARACTER ENTRY AFTER
C  ISUB, AND THE FIRST OCCURS AT LOCATION I. IF THIS CHARACTER IS A
C  COMMA THEN ISUB IS AN INDIVIDUAL SUBJECT NO.

	IF(READLINE(I:I) .EQ. ',') THEN

	 NUMCUR = ISUB
 	 NSUBB = NSUBB + 1
	 IPATVECC(NSUBB) = ISUB


C  CHECK TO SEE IF THERE IS ANOTHER ENTRY ON THIS LINE. IF SO,
C  RETURN CONTROL TO LABEL 30 AND CONTINUE CHECKING FOR OTHER NOS. IF
C  NOT, IT MEANS THE USER HAS ENDED THE LINE WITH A COMMA ... WHICH
C  IS ASSUMED TO BE SUPERFLOUS.

	 DO J = I+1,70
	  IF(READLINE(J:J) .NE. ' ') GO TO 60
	 END DO

	 RETURN


   60    ISTART = J

	 GO TO 30

	ENDIF


C  TO GET TO THIS POINT, THERE IS AT LEAST ONE CHARACTER ENTRY AFTER
C  ISUB, AND THE FIRST OCCURS AT LOCATION I ... AND THIS ENTRY IS NOT
C  A COMMA. CHECK TO SEE IF IT IS ANOTHER NUMBER. IN THIS CASE, ISUB
C  IS AN INDIVIDUAL SUBJECT NO.


	INUM = 0
	IF(READLINE(I:I) .EQ. '0') INUM = 1
	IF(READLINE(I:I) .EQ. '1') INUM = 1
	IF(READLINE(I:I) .EQ. '2') INUM = 1
	IF(READLINE(I:I) .EQ. '3') INUM = 1
	IF(READLINE(I:I) .EQ. '4') INUM = 1

	IF(READLINE(I:I) .EQ. '5') INUM = 1
	IF(READLINE(I:I) .EQ. '6') INUM = 1
	IF(READLINE(I:I) .EQ. '7') INUM = 1
	IF(READLINE(I:I) .EQ. '8') INUM = 1
	IF(READLINE(I:I) .EQ. '9') INUM = 1

	IF(INUM .EQ. 1) THEN
	 NUMCUR = ISUB

 	 NSUBB = NSUBB + 1

	 IPATVECC(NSUBB) = ISUB

C  RETURN CONTROL TO LABEL 30 AND CONTINUE CHECKING FOR OTHER NOS.
C  STARTING WITH LOCATION I.

         ISTART = I
	 GO TO 30


	ENDIF


C  TO GET TO THIS POINT, THERE IS AT LEAST ONE CHARACTER ENTRY AFTER
C  ISUB, AND THE FIRST OCCURS AT LOCATION I ... AND THIS ENTRY IS NOT


C  A COMMA OR A NUMBER. CHECK TO SEE IF IT IS A DASH. IN THIS CASE,
C  ISUB IS THE FIRST NO. IN A RANGE OF PATIENT NUMBERS.

	IF(READLINE(I:I) .EQ. '-') THEN

C  STORE ISUB INTO NUMCUR1, BUT NOT NUMCUR. IN CASE THE USER
C  HAS NOT ENTERED A LEGITIMATE NO. AFTER THE DASH, KEEP THE PREVIOUS
C  VALUE OF NUMCUR (THE LAST PATIENT INDEX PUT INTO IPATVECC) INTACT.

	 NUMCUR1 = ISUB

C  READ UNTIL THE NEXT NON-BLANK CHARACTER, WHICH SHOULD BE THE
C  BEGINNING OF THE NUMBER WHICH ENDS THE RANGE.

	 DO J = I+1,70
	  IF(READLINE(J:J) .NE. ' ') GO TO 70

	 END DO

C  TO GET TO THIS POINT MEANS THE USER ENDED A LINE WITH A DASH, WHICH
C  IS NOT ALLOWED. WRITE AN ERROR MESSAGE AND RETURN.


	 WRITE(*,8) NUMCUR
    8    FORMAT(/' YOU MAY NOT END A LINE WITH A DASH. THE LAST '/
     1' PATIENT NO. ASSUMED TO BE ENTERED IS ',I4//
     3' PLEASE ENTER SUBJECT NOS. AS INDICATED BELOW. ')
	 ISTOP = -1
	 RETURN

   70   ISTART = J

C  TO GET TO THIS POINT, THERE IS AN ENTRY IN LOCATION ISTART, WHICH



C  SHOULD BE THE BEGINNING OF THE ENDING PATIENT NO. OF A RANGE OF
C  PATIENT NOS. THIS NUMBER ENDS THE ENTRY BEFORE A SPACE OR A
C  COMMA.

     	DO K = ISTART+1,70
	 IF(READLINE(K:K) .EQ. ' ' .OR. READLINE(K:K) .EQ. ',')
     1    GO TO 80
	END DO

   80   IEND = K-1

C  CALL ROUTINE GETSUB WHICH OBTAINS THE SUBJECT NO. FROM THE
C  CHARACTERS IN READLINE(ISTART:IEND).

	CALL GETSUB(READLINE,ISTART,IEND,ISUB,IERROR)

C  IF IERROR RETURNS AS -1, IT MEANS THE USER HAS ENTERED A NON-NUMERIC
C  CHARACTER. IN THIS CASE, PRINT AN ERROR MESSAGE AND RETURN.

	IF(IERROR .EQ. -1) THEN
	 WRITE(*,7) NUMCUR
	 ISTOP = -1
	 RETURN

	ENDIF

C  IF ISUB IS .LE. NUMCUR1 (THE BEGINNING NO. IN THIS RANGE), WRITE AN
C  ERROR MESSAGE TO THE USER AND RETURN. SIMILARLY, IF ISUB .GE.

C  NSUBTOT

	IF(ISUB .LE. NUMCUR1) THEN
	 WRITE(*,9) NUMCUR
    9    FORMAT(/' YOU MAY NOT ENTER A RANGE OF SUBJECT NOS. WITH THE'/
     1' ENDING NO. LESS THAN OR EQUAL TO THE BEGINNING NO. THE LAST'/
     2' ACCEPTED SUBJECT NO. IS ',I4//
     3' PLEASE ENTER SUBJECT NOS. AS INDICATED BELOW. ')
	 ISTOP = -1
	 RETURN
	ENDIF

	IF(ISUB .GT. NSUBTOT) THEN
	 WRITE(*,6) ISUB,NSUBTOT,NUMCUR
	 ISTOP = -1


	 RETURN
	ENDIF


C  TO GET TO THIS POINT MEANS THE USER HAS CORRECTLY ENTERED A RANGE
C  OF PATIENT NOS. FROM NUMCUR1 TO ISUB. UPDATE NSUBB, NUMCUR, AND
C  IPATVECC.

	 NUMCUR = ISUB
	 NN = NSUBB
 	 NSUBB = NSUBB + (NUMCUR - NUMCUR1) + 1

	 NONEW = 0
	 DO K = NN+1,NSUBB
	  NONEW = NONEW + 1
	  IPATVECC(K) = NUMCUR1 - 1 + NONEW
	 END DO


C  CHECK TO SEE IF THERE IS ANOTHER CHARACTER ON THE LINE AFTER
C  LOCATION IEND (IGNORE A COMMA AT THIS POINT, SINCE IT IS POSSIBLE
C  THAT THE USER HAS PUT IN A COMMA AT THE END OF HIS SUBJECT RANGE).
C  IF SO, RETURN CONTROL TO LABEL 30 AND CONTINUE CHECKING FOR OTHER
C  NOS. IF NOT, RETURN.

	 DO J = IEND+1,70
	  IF(READLINE(J:J) .NE. ' ' .AND. READLINE(J:J) .NE. ',' )
     1    GO TO 90
	 END DO

	 RETURN

   90    ISTART = J
	 GO TO 30

	ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(READLINE(I:I) .EQ. '-')  CONDITION.


C  TO GET TO THIS POINT, THERE IS AT LEAST ONE CHARACTER ENTRY AFTER
C  ISUB, AND THE FIRST OCCURS AT LOCATION I ... AND THIS ENTRY IS NOT

C  A COMMA, A NUMBER, OR A DASH, WHICH MEANS IT IS AN ERRONEOUS ENTRY.
C  WRITE AN ERROR MESSAGE TO THE USER AND RETURN.

	WRITE(*,7) NUMCUR
	ISTOP = -1


	RETURN
	END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
	SUBROUTINE GETSUB(READLINE,ISTART,IEND,ISUB,IERROR)
	CHARACTER READLINE*1000

C  THIS ROUTINE, CALLED BY GETNUMS, OBTAINS THE SUBJECT NO., ISUB,
C  FROM THE CHARACTERS IN READLINE(ISTART:IEND).


    3   FORMAT(A1000)


	IERROR = 0
  	ISIZE = IEND-ISTART

	ISUB = 0
	 DO K=ISTART,IEND
	  IVAL = -9
	  IF(READLINE(K:K) .EQ. '0') IVAL = 0
	  IF(READLINE(K:K) .EQ. '1') IVAL = 1
	  IF(READLINE(K:K) .EQ. '2') IVAL = 2
	  IF(READLINE(K:K) .EQ. '3') IVAL = 3
	  IF(READLINE(K:K) .EQ. '4') IVAL = 4
	  IF(READLINE(K:K) .EQ. '5') IVAL = 5
	  IF(READLINE(K:K) .EQ. '6') IVAL = 6
	  IF(READLINE(K:K) .EQ. '7') IVAL = 7
	  IF(READLINE(K:K) .EQ. '8') IVAL = 8
	  IF(READLINE(K:K) .EQ. '9') IVAL = 9

	  IF(IVAL .EQ. -9) THEN
	   IERROR = -1
	   RETURN
	  ENDIF

	  ISUB = ISUB + IVAL*10**ISIZE
	  ISIZE = ISIZE-1
	 END DO

	RETURN
	END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
	SUBROUTINE WRITEPAT(NSUB,MAXSUB,IPATVEC)
	DIMENSION IPATVEC(MAXSUB)

C  THIS ROUTINE WRITES THE PATIENT NOS. TO THE SCREEN.


	WRITE(*,*)
	ILINES = 1

C  ILINES IS THE RUNNING TOTAL OF LINES PRINTED TO THE SCREEN SINCE THE
C  LAST PAUSE. EVERYTIME IT GETS TO 15, PAUSE THE OUTPUT.


C  INSTEAD OF WRITING OUT THE PATIENT NOS. ONE TO A LINE, WRITE OUT
C  CONTINUOUS SETS ON EACH LINE. E.G., IF SUBJECTS 1,4,5,6,9,10,12 ARE
C  TO BE WRITTEN OUT, WRITE 1 ON THE 1ST LINE, 4 - 6 ON THE 2ND LINE,
C  9 - 10 OR THE 3RD LINE, AND 12 ON THE 4TH.

C  NEXTIND IS THE INDEX OF THE NEXT SUBJECT NO. TO BE WRITTEN.

	NEXTIND = 0


   50   NEXTIND = NEXTIND + 1

C  IF NEXTIND .GT. NSUB, THE NOS. HAVE ALL BEEN WRITTEN OUT, SO STOP
C  THE WRITING.

	IF(NEXTIND .GT. NSUB) GO TO 100

C  ESTABLISH THE NOS. TO BE WRITTEN ON THE NEXT LINE. THE FIRST NO.
C  WILL BE IPATVEC(NEXTIND)

	IFIRST = IPATVEC(NEXTIND)

C  IF NEXTIND = NSUB, THIS IS THE LAST PATIENT NO. TO BE WRITTEN OUT.

	IF(NEXTIND .EQ. NSUB) THEN
	 WRITE(*,222) IFIRST
	 ILINES=ILINES+1
	  IF(ILINES .EQ. 20) THEN

	   ILINES=0
	  ENDIF
  222    FORMAT(1X,I5)
	 GO TO 100
	ENDIF

C  IF THE NEXT PATIENT NO. IN IPATVEC = IFIRST + 1, THEN IFIRST IS THE
C  FIRST OF A STRING OF CONSECUTIVE NUMBERS (FIND THE LAST NO. IN THIS
C  STRING AND WRITE THE STRING OUT). OTHERWISE, IFIRST WILL BE WRITTEN

C  OUT BY ITSELF.

	IF(IPATVEC(NEXTIND+1) .NE. IFIRST + 1) THEN

	 WRITE(*,222) IFIRST
	 ILINES=ILINES+1
	  IF(ILINES .EQ. 20) THEN

	   ILINES=0
	  ENDIF
	 GO TO 50
	ENDIF

C  SET ILAST = THE LAST NO. IN THE STRING USING THE FOLLOWING DO LOOP.



	ILAST = IPATVEC(NEXTIND+1)
	NEXT = NEXTIND+1

	DO I = NEXTIND+2,NSUB
	 IF(IPATVEC(I) .NE. ILAST + 1) GO TO 80
	 ILAST = IPATVEC(I)
	 NEXT = I
	END DO


   80	WRITE(*,221) IFIRST,ILAST
  221   FORMAT(1X,I5,'   - ',I5)

	ILINES=ILINES+1
	 IF(ILINES .EQ. 20) THEN

	  ILINES=0
	 ENDIF

C  THE INDEX OF THE LAST NO. WRITTEN OUT IS NEXT.

	NEXTIND = NEXT


	GO TO 50

  100   RETURN
	END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
	SUBROUTINE WRITEPT2(IFILE,NSUB,MAXSUB,IPATVEC)
	DIMENSION IPATVEC(MAXSUB)

C  THIS ROUTINE WRITES THE PATIENT NOS. TO FILE IFILE.


C  INSTEAD OF WRITING OUT THE PATIENT NOS. ONE TO A LINE, WRITE OUT
C  CONTINUOUS SETS ON EACH LINE. E.G., IF SUBJECTS 1,4,5,6,9,10,12 ARE
C  TO BE WRITTEN OUT, WRITE 1 ON THE 1ST LINE, 4 - 6 ON THE 2ND LINE,
C  9 - 10 OR THE 3RD LINE, AND 12 ON THE 4TH.


C  NEXTIND IS THE INDEX OF THE NEXT SUBJECT NO. TO BE WRITTEN.

	NEXTIND = 0

   50   NEXTIND = NEXTIND + 1

C  IF NEXTIND .GT. NSUB, THE NOS. HAVE ALL BEEN WRITTEN OUT, SO STOP
C  THE WRITING.

	IF(NEXTIND .GT. NSUB) GO TO 100

C  ESTABLISH THE NOS. TO BE WRITTEN ON THE NEXT LINE. THE FIRST NO.
C  WILL BE IPATVEC(NEXTIND)

	IFIRST = IPATVEC(NEXTIND)


C  IF NEXTIND = NSUB, THIS IS THE LAST PATIENT NO. TO BE WRITTEN OUT.


	IF(NEXTIND .EQ. NSUB) THEN
	 IF(IFILE .EQ. 27) WRITE(27,222) IFIRST

	 IF(IFILE .EQ. 24) WRITE(24,222) IFIRST
  222    FORMAT(1X,I5)
	 GO TO 100
	ENDIF

C  IF THE NEXT PATIENT NO. IN IPATVEC = IFIRST + 1, THEN IFIRST IS THE

C  FIRST OF A STRING OF CONSECUTIVE NUMBERS (FIND THE LAST NO. IN THIS
C  STRING AND WRITE THE STRING OUT). OTHERWISE, IFIRST WILL BE WRITTEN
C  OUT BY ITSELF.

	IF(IPATVEC(NEXTIND+1) .NE. IFIRST + 1) THEN
	 IF(IFILE .EQ. 27) WRITE(27,222) IFIRST
	 IF(IFILE .EQ. 24) WRITE(24,222) IFIRST
	 GO TO 50
	ENDIF


C  SET ILAST = THE LAST NO. IN THE STRING USING THE FOLLOWING DO LOOP.

	ILAST = IPATVEC(NEXTIND+1)
	NEXT = NEXTIND+1

	DO I = NEXTIND+2,NSUB

	 IF(IPATVEC(I) .NE. ILAST + 1) GO TO 80
	 ILAST = IPATVEC(I)
	 NEXT = I
	END DO



   80	IF(IFILE .EQ. 27) WRITE(27,221) IFIRST,ILAST
   	IF(IFILE .EQ. 24) WRITE(24,221) IFIRST,ILAST
  221   FORMAT(1X,I5,'   - ',I5)

C  THE INDEX OF THE LAST NO. WRITTEN OUT IS NEXT.

	NEXTIND = NEXT


	GO TO 50

  100   RETURN

	END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
	SUBROUTINE GETIPATF(IFILE,NSUBTOT,NSUB,MAXSUB,
     1   IPATVEC,IERRR)
	DIMENSION IPATVEC(MAXSUB)
	CHARACTER READLINE*1000


C  SUBROUTINE GETIPATF IS CALLED BY MAIN TO OBTAIN THE INDICES OF
C  THE "ACTIVE" SUBJECTS, IPATVEC(I),I=1,NSUB, FOR THIS RUN. THESE
C  INDICES ARE OBTAINED FROM FILE IFILE.

    3   FORMAT(A1000)

	NSUBB = 0
	NUMCUR = 0

C  NSUBB WILL BE THE NO. OF SUBJECTS SELECTED BY THE USER. IT IS
C  INITIALIZED AS 0, AND WILL GROW AS EACH LINE OF THE FILE IS READ.


C  NUMCUR IS THE INDEX OF THE HIGHEST PATIENT NO. ENTERED SO FAR.

C  NOTE THAT EACH LINE CONTAINS EITHER A SUBJECT NO. OR A RANGE OF

C  SUBJECT NOS. TO BE INCLUDED IN THE ANALYSIS. MULTIPLE SUBJECTS
C  CAN BE ENTERED USING COMMAS, SPACES AND/OR HYPHENS. FOR EXAMPLE,
C  2, 17 - 28 INDICATES SUBJECTS 2 AND 17 THROUGH 28;
C  17,28 INDICATES SUBJECTS 17 AND 28;
C  17 28 INDICATES SUBJECTS 17 AND 28.

C  RESTRICTIONS: 1. ON EACH LINE, USE NO MORE THAN 70 CHARACTERS;
C                2. PATIENT NOS., OR RANGES OF PATIENT NOS.
C                   MUST BE LISTED IN ASCENDING ORDER.

C  A LINE WITH JUST A 0 --> END OF THE LIST OF SUBJECT NOS.


 4210	IF(IFILE .EQ. 23) READ(23,3,ERR=4200) READLINE

	IF(IFILE .EQ. 25) READ(25,3,ERR=4200) READLINE


C  CALL SUBROUTINE GETNUMSF TO UPDATE NSUBB AND IPATVEC, WHERE IPATVEC
C  IS THE VECTOR WHICH CONTAINS THE PATIENT NOS. TO BE INCLUDED IN THE
C  ANALYSIS.

C  NOTE THAT ISTOP RETURNS AS 0 TO INDICATE THE END OF THE LIST OF

C  PATIENT NOS; IT RETURNS AS -1 IF THERE IS A CONFLICT IN THE LIST

C  (SEE RESTRICTION ABOVE) OR A PATIENT NO. LARGER THAN NSUBTOT
C  (THE MAXIMUM ALLOWABLE NO. OF SUBJECTS) HAS BEEN READ IN; AND IT

C  RETURNS AS 1 IF THERE ARE MORE LINES TO BE READ IN.

	CALL GETNUMSF(1,READLINE,NSUBB,NSUBTOT,NUMCUR,ISTOP,
     1                  MAXSUB,IPATVEC)
	IF(ISTOP .EQ. -1) GO TO 4200
	IF(ISTOP .EQ. 1) GO TO 4210


C  TO GET TO THIS POINT, ISTOP = 0 --> USER HAS STOPPED ENTERING

C  PATIENT NOS.

C  CHECK THAT NSUB, AS INPUT TO THIS ROUTINE (FROM MAIN) IS THE SAME
C  AS NSUBB, AS OBTAINED FROM THE LIST OF SUBJECTS TO BE INCLUDED IN
C  THE ANALYSIS. IF NOT, TELL USER AND RETURN IERRR = -1 SO THE USER
C  CAN MAKE A CORRECTION.


	IF(NSUB .EQ. NSUBB) THEN
	 IERRR = 0
	 RETURN
	ENDIF

	IF(NSUB .NE. NSUBB) THEN
         WRITE(*,2)
    2   FORMAT(//' THERE WAS AN ERROR IN THE READING OF PATIENT NOS.'/
     1' TO BE USED FOR THIS ANALYSIS. IN PARTICULAR, THE NO. OF '/
     2' SUBJECTS TO BE INCLUDED IN THE ANALYSIS, AS ENTERED IN THE'/
     3' INSTRUCTION FILE, DOES NOT MATCH THE LIST OF SUBJECT NOS.'/
     4' WHICH FOLLOW THAT NUMBER. PLEASE ENTER DATA VIA THE KEYBOARD'/
     5' OR USING ANOTHER INSTRUCTION FILE.'/)
	IERRR = -1
	 RETURN
	ENDIF

 4200   WRITE(*,1)
    1   FORMAT(//' THERE WAS AN ERROR IN THE READING OF PATIENT NOS.'/
     1' TO BE USED FOR THIS ANALYSIS. PLEASE ENTER DATA VIA THE '/
     2' KEYBOARD OR USING ANOTHER INSTRUCTION FILE.'/)
	IERRR = -1


	RETURN
	END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
	SUBROUTINE GETNUMSF(IINCLUDE,READLINE,NSUBB,NSUBTOT,NUMCUR,
     1    ISTOP,MAXSUB,IPATVECC)
	DIMENSION IPATVECC(MAXSUB)
	CHARACTER READLINE*1000

C  SUBROUTINE GETNUMSF IS CALLED BY GETIPATF (OVER AND OVER)
C  TO ESTABLISH NSUBB AND IPATVECC, WHERE NSUBB IS THE NO. OF SUBJECTS
C  TO BE INCLUDED (IF IINCLUDE = 1) OR EXCLUDED (IF IINCLUDE = 2) IN THE
C  ANALYSIS, AND IPATVECC IS THE VECTOR WHICH CONTAINS THE CORRESPONDING
C  PATIENT NOS. EACH CALL TO GETNUMSF EITHER ADDS TO THE VALUES IN
C  IPATVECC (AND INCREASES NSUBB) OR STOPS THE PROCESS.

C  NOTE THAT GETNUMSF IS THE SAME AS GETNUMS EXCEPT THAT THE COMMENTS
C  TO THE USER ARE DIFFERENT SINCE THIS ROUTINE IS CALLED BY GETIPATF
C  WHICH IS READING A FILE, RATHER THAN KEYBOARD ENTRIES.

C  NOTE THAT ISTOP RETURNS AS 0 IF THE USER IS FINISHED ENTERING
C  PATIENT NOS; IT RETURNS AS -1 IF THE USER HAS ENTERED A CONFLICTING
C  SET OF PATIENT NOS. (EACH PATIENT NO. OR RANGE OF NUMBERS MUST BE
C  GREATER THAN ANY PATIENT NO. ALREADY ENTERED ... THE LARGEST PATIENT
C  NO. ENTERED SO FAR IS NUMCUR) OR A PATIENT NO. LARGER THAN NSUBTOT
C  (THE MAXIMUM ALLOWABLE NO. OF SUBJECTS); AND IT RETURNS AS 1 IF THE
C  USER HAS CORRECTLY ENTERED PATIENT DATA AND WANTS TO CONTINUE

C  ENTERING OTHER NOS.

	ISTOP = 1


C  CHECK TO SEE IF THIS IS A BLANK LINE. IF SO, RETURN ISTOP = -1


C  WITH A MESSAGE TO THE USER.

	DO J = 1,70
	 IF(READLINE(J:J) .NE. ' ') GO TO 10
	END DO

C  TO GET HERE --> READLINE IS COMPLETELY BLANK.





	IF(NSUBB .EQ. 0) WRITE(*,1)
    1   FORMAT(/' THE INSTRUCTION OR OUTPUT FILE HAS AN IMPROPER BLANK'/

     1' LINE IN THE PATIENT NUMBER SECTION. ')
	ISTOP = -1
	RETURN


   10   CONTINUE

C  CHECK TO SEE IF THIS LINE HAS JUST A 0 ON IT. IF SO, RETURN ISTOP
C  = 0, UNLESS NSUBB = 0 AND IINCLUDE = 1, IN WHICH CASE THIS IS AN
C  ERROR. SIMPLY CHECK THE FIRST NON-BLANK CHARACTER (THERE MUST BE ONE
C  SINCE IF THE LINE IS COMPLETELY BLANK, THE CODE ABOVE ABOVE WOULD
C  HAVE DETECTED IT AND RETURNED CONTROL TO THE CALLING ROUTINE) AND
C  SEE IF a. IT IS A 0, AND b. EVERY OTHER CHARACTER IS A BLANK. IF
C  a. AND b. ARE TRUE, THE LINE JUST HAS A 0 IN IT. OTHERWISE NOT.



	DO J = 1,70
	 IF(READLINE(J:J) .NE. ' ') GO TO 20
	END DO

   20   ISTART = J
	IF(READLINE(ISTART:ISTART) .NE. '0') GO TO 30

	DO I = ISTART+1,70
	 IF(READLINE(I:I) .NE. ' ') GO TO 30
	END DO

C  TO GET HERE --> READLINE HAS JUST A 0 ON IT AND NOTHING ELSE.

C  IF THE USER HAS ENTERED A 0 WITH NSUBB = 0 (I.E., HE HAS NOT
C  ENTERED PREVIOUS SUBJECT NOS.), THIS IS OK IF IINCLUDE = 2 (SINCE
C  IT IS OK TO EXCLUDE 0 PATIENTS), BUT IT IS NOT OK IF IINCLUDE = 1
C  (SINCE THIS WOULD MEAN THE ANALYSIS WOULD BE ON 0 SUBJECTS).


	IF(IINCLUDE .EQ. 1 .AND. NSUBB .EQ. 0) THEN
	 WRITE(*,3)
    3    FORMAT(/' THE INSTRUCTION OR OUTPUT FILE HAS AN IMPROPER '/
     1' LINE - WITH JUST A "0" ON IT - IN THE PATIENT NUMBER SECTION.')

	 ISTOP = -1
	 RETURN
	ENDIF

	IF(IINCLUDE .EQ. 2 .OR. NSUBB .GT. 0) THEN
	 ISTOP = 0
	 RETURN
	ENDIF


   30   CONTINUE



C  TO GET TO THIS POINT MEANS READLINE HAS A POTENTIAL NO. BEGINNING
C  AT ENTRY ISTART. IF THIS IS A LEGITIMATE NO., IT ENDS THE ENTRY

C  BEFORE THE NEXT SPACE, COMMA, DASH, WHICHEVER COMES FIRST.

     	DO I = ISTART+1,70
	 IF(READLINE(I:I) .EQ. ' ' .OR. READLINE(I:I) .EQ. ',' .OR.
     1      READLINE(I:I) .EQ. '-') GO TO 40
	END DO

   40   IEND = I-1

C  CALL ROUTINE GETSUB WHICH OBTAINS THE SUBJECT NO. FROM THE

C  CHARACTERS IN READLINE(ISTART:IEND).

	CALL GETSUB(READLINE,ISTART,IEND,ISUB,IERROR)

C  IF IERROR RETURNS AS -1, IT MEANS THE USER HAS ENTERED A NON-NUMERIC
C  CHARACTER. IN THIS CASE, PRINT AN ERROR MESSAGE AND RETURN.

	IF(IERROR .EQ. -1) THEN
	 WRITE(*,7)
    7    FORMAT(/' THE INSTRUCTION OR OUTPUT FILE HAS AN IMPROPER '/
     1' LINE - WITH AN INVALID CHARACTER ON IT - IN THE PATIENT '/
     2' NUMBER SECTION.')
	 ISTOP = -1

	 RETURN
	ENDIF



C  IF ISUB IS .LE. NUMCUR, THE LAST (AND HIGHEST PATIENT NO. ENTERED
C  PREVIOUSLY), WRITE AN ERROR MESSAGE TO THE USER AND RETURN.
C  SIMILARLY, IF ISUB .GE. NSUBTOT.




	IF(ISUB .LE. NUMCUR) THEN
	 WRITE(*,4) ISUB,NUMCUR
    4    FORMAT(/' THE INSTRUCTION OR OUTPUT FILE HAS AN IMPROPER '/
     1' LINE IN IT IN THE PATIENT NUMBER SECTION.'//
     2' IT HAS A SUBJECT NO. (',I4,' ) WHICH IS LESS THAN OR EQUAL TO '/


     3' A PREVIOUSLY ENTERED SUBJECT NO. (',I4,').')
	 ISTOP = -1
	 RETURN


	ENDIF

	IF(ISUB .GT. NSUBTOT) THEN
	 WRITE(*,6) ISUB,NSUBTOT
    6    FORMAT(/' THE INSTRUCTION OR OUTPUT FILE HAS AN IMPROPER '/
     1' LINE IN IT IN THE PATIENT NUMBER SECTION.'//

     2' IT HAS A SUBJECT NO. (',I4,' ) WHICH IS GREATER THAN THE NO.'/
     3' OF SUBJECTS IN YOUR DATA FILE (',I4,').')
	 ISTOP = -1
	 RETURN
	ENDIF


C  TO GET TO THIS POINT, THE PATIENT NO., ISUB, IS LEGITIMATE. I.E.,
C  IT IS .GT. NUMCUR AND .LE. NSUBTOT. THERE ARE 4 POSSIBILITIES:


C  1. IF THERE ARE NO OTHER ENTRIES IN READLINE PAST THIS POINT,
C  ISUB IS A SINGLE PATIENT NO.
C  2. IF THE NEXT NON-BLANK ENTRY IN READLINE IS A COMMA OR ANOTHER
C  NUMBER, ISUB IS A SINGLE PATIENT NO.
C  3. IF THE NEXT NON-BLANK ENTRY IN READLINE IS A DASH, ISUB IS THE
C  START OF A PATIENT RANGE.
C  4. IF THE NEXT NON-BLANK ENTRY IN READLINE IS ANOTHER CHARACTER
C  (I.E., NOT A NUMBER, DASH, OR COMMA), THE LINE HAS BEEN ENTERED
C  INCORRECTLY BY THE USER.


C  CHECK FOR NO. 1. ABOVE ...


	DO I = IEND+1,70
	 IF(READLINE(I:I) .NE. ' ') GO TO 50
	END DO

C  TO GET TO THIS POINT, ISUB IS AN INDIVIDUAL SUBJECT NO., AND THE
C  LAST NO. ON THE LINE. INCREASE NSUBB, NUMCUR, AND PUT THIS SUBJECT

C  NO. INTO IPATVECC BEFORE RETURNING.

	NUMCUR = ISUB
	NSUBB = NSUBB + 1
	IPATVECC(NSUBB) = ISUB
	RETURN


   50   CONTINUE

C  CHECK FOR NOS. 2,3, OR 4 (SEE ABOVE).

C  TO GET TO THIS POINT, THERE IS AT LEAST ONE CHARACTER ENTRY AFTER
C  ISUB, AND THE FIRST OCCURS AT LOCATION I. IF THIS CHARACTER IS A
C  COMMA THEN ISUB IS AN INDIVIDUAL SUBJECT NO.

	IF(READLINE(I:I) .EQ. ',') THEN

	 NUMCUR = ISUB
 	 NSUBB = NSUBB + 1
	 IPATVECC(NSUBB) = ISUB

C  CHECK TO SEE IF THERE IS ANOTHER ENTRY ON THIS LINE. IF SO,
C  RETURN CONTROL TO LABEL 30 AND CONTINUE CHECKING FOR OTHER NOS. IF
C  NOT, IT MEANS THE USER HAS ENDED THE LINE WITH A COMMA ... WHICH
C  IS ASSUMED TO BE SUPERFLOUS.

	 DO J = I+1,70
	  IF(READLINE(J:J) .NE. ' ') GO TO 60
	 END DO

	 RETURN

   60    ISTART = J
	 GO TO 30

	ENDIF


C  TO GET TO THIS POINT, THERE IS AT LEAST ONE CHARACTER ENTRY AFTER
C  ISUB, AND THE FIRST OCCURS AT LOCATION I ... AND THIS ENTRY IS NOT
C  A COMMA. CHECK TO SEE IF IT IS ANOTHER NUMBER. IN THIS CASE, ISUB
C  IS AN INDIVIDUAL SUBJECT NO.

	INUM = 0
	IF(READLINE(I:I) .EQ. '0') INUM = 1
	IF(READLINE(I:I) .EQ. '1') INUM = 1
	IF(READLINE(I:I) .EQ. '2') INUM = 1
	IF(READLINE(I:I) .EQ. '3') INUM = 1
	IF(READLINE(I:I) .EQ. '4') INUM = 1
	IF(READLINE(I:I) .EQ. '5') INUM = 1
	IF(READLINE(I:I) .EQ. '6') INUM = 1
	IF(READLINE(I:I) .EQ. '7') INUM = 1
	IF(READLINE(I:I) .EQ. '8') INUM = 1

	IF(READLINE(I:I) .EQ. '9') INUM = 1

	IF(INUM .EQ. 1) THEN
	 NUMCUR = ISUB
 	 NSUBB = NSUBB + 1
	 IPATVECC(NSUBB) = ISUB

C  RETURN CONTROL TO LABEL 30 AND CONTINUE CHECKING FOR OTHER NOS.
C  STARTING WITH LOCATION I.

         ISTART = I
	 GO TO 30

	ENDIF


C  TO GET TO THIS POINT, THERE IS AT LEAST ONE CHARACTER ENTRY AFTER
C  ISUB, AND THE FIRST OCCURS AT LOCATION I ... AND THIS ENTRY IS NOT
C  A COMMA OR A NUMBER. CHECK TO SEE IF IT IS A DASH. IN THIS CASE,
C  ISUB IS THE FIRST NO. IN A RANGE OF PATIENT NUMBERS.

	IF(READLINE(I:I) .EQ. '-') THEN

C  STORE ISUB INTO NUMCUR1, BUT NOT NUMCUR. IN CASE THE USER
C  HAS NOT ENTERED A LEGITIMATE NO. AFTER THE DASH, KEEP THE PREVIOUS

C  VALUE OF NUMCUR (THE LAST PATIENT INDEX PUT INTO IPATVECC) INTACT.

	 NUMCUR1 = ISUB

C  READ UNTIL THE NEXT NON-BLANK CHARACTER, WHICH SHOULD BE THE
C  BEGINNING OF THE NUMBER WHICH ENDS THE RANGE.


	 DO J = I+1,70
	  IF(READLINE(J:J) .NE. ' ') GO TO 70
	 END DO

C  TO GET TO THIS POINT MEANS THE USER ENDED A LINE WITH A DASH, WHICH
C  IS NOT ALLOWED. WRITE AN ERROR MESSAGE AND RETURN.

	 WRITE(*,8)
    8    FORMAT(/' THE INSTRUCTION OR OUTPUT FILE HAS AN IMPROPER '/
     1' LINE IN IT IN THE PATIENT NUMBER SECTION.'//
     2' A LINE HAS BEEN ENDED WITH A DASH.')
	 ISTOP = -1
	 RETURN

   70   ISTART = J


C  TO GET TO THIS POINT, THERE IS AN ENTRY IN LOCATION ISTART, WHICH
C  SHOULD BE THE BEGINNING OF THE ENDING PATIENT NO. OF A RANGE OF
C  PATIENT NOS. THIS NUMBER ENDS THE ENTRY BEFORE A SPACE OR A
C  COMMA.

     	DO K = ISTART+1,70
	 IF(READLINE(K:K) .EQ. ' ' .OR. READLINE(K:K) .EQ. ',')
     1    GO TO 80
	END DO

   80   IEND = K-1


C  CALL ROUTINE GETSUB WHICH OBTAINS THE SUBJECT NO. FROM THE
C  CHARACTERS IN READLINE(ISTART:IEND).

	CALL GETSUB(READLINE,ISTART,IEND,ISUB,IERROR)

C  IF IERROR RETURNS AS -1, IT MEANS THE USER HAS ENTERED A NON-NUMERIC
C  CHARACTER. IN THIS CASE, PRINT AN ERROR MESSAGE AND RETURN.


	IF(IERROR .EQ. -1) THEN
	 WRITE(*,7)

	 ISTOP = -1
	 RETURN
	ENDIF

C  IF ISUB IS .LE. NUMCUR1 (THE BEGINNING NO. IN THIS RANGE), WRITE AN
C  ERROR MESSAGE TO THE USER AND RETURN. SIMILARLY, IF ISUB .GE.
C  NSUBTOT

	IF(ISUB .LE. NUMCUR1) THEN
	 WRITE(*,9)

    9    FORMAT(/' THE INSTRUCTION OR OUTPUT FILE HAS AN IMPROPER '/
     1' LINE IN IT IN THE PATIENT NUMBER SECTION.'//
     2' IT HAS A RANGE OF SUBJECT NOS. WITH THE ENDING NO. LESS THAN '/
     3' OR EQUAL TO THE BEGINNING NO.')

	 ISTOP = -1
	 RETURN
	ENDIF

	IF(ISUB .GT. NSUBTOT) THEN
	 WRITE(*,6) ISUB,NSUBTOT
	 ISTOP = -1
	 RETURN
	ENDIF


C  TO GET TO THIS POINT MEANS THE USER HAS CORRECTLY ENTERED A RANGE
C  OF PATIENT NOS. FROM NUMCUR1 TO ISUB. UPDATE NSUBB, NUMCUR, AND
C  IPATVECC.

	 NUMCUR = ISUB
	 NN = NSUBB
 	 NSUBB = NSUBB + (NUMCUR - NUMCUR1) + 1

	 NONEW = 0
	 DO K = NN+1,NSUBB
	  NONEW = NONEW + 1
	  IPATVECC(K) = NUMCUR1 - 1 + NONEW
	 END DO

C  CHECK TO SEE IF THERE IS ANOTHER CHARACTER ON THE LINE AFTER
C  LOCATION IEND (IGNORE A COMMA AT THIS POINT, SINCE IT IS POSSIBLE
C  THAT THE USER HAS PUT IN A COMMA AT THE END OF HIS SUBJECT RANGE).
C  IF SO, RETURN CONTROL TO LABEL 30 AND CONTINUE CHECKING FOR OTHER
C  NOS. IF NOT, RETURN.

	 DO J = IEND+1,70
	  IF(READLINE(J:J) .NE. ' ' .AND. READLINE(J:J) .NE. ',' )
     1    GO TO 90
	 END DO

	 RETURN

   90    ISTART = J
	 GO TO 30

	ENDIF


C  THE ABOVE ENDIF IS FOR THE  IF(READLINE(I:I) .EQ. '-')  CONDITION.


C  TO GET TO THIS POINT, THERE IS AT LEAST ONE CHARACTER ENTRY AFTER
C  ISUB, AND THE FIRST OCCURS AT LOCATION I ... AND THIS ENTRY IS NOT
C  A COMMA, A NUMBER, OR A DASH, WHICH MEANS IT IS AN ERRONEOUS ENTRY.
C  WRITE AN ERROR MESSAGE TO THE USER AND RETURN.




	WRITE(*,7)
	ISTOP = -1


	RETURN
	END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
	SUBROUTINE GETNSUB2(NSUBTOT)
	CHARACTER READLINE*1000

C  THIS ROUTINE IS A VARIATION OF TEST38.FOR, WHICH READS AN INTEGER
C  ANYWHERE ON A GIVEN LINE WITH A PARTICULAR SET OF WORDS AT THE START
C  OF THAT LINE.

        CHARACTER ERRFIL*20

      COMMON/ERROR/ERRFIL
C  COMMON/ERROR/ IS SUPPLIED TO ALL THE ROUTINES WHICH COULD WRITE TO
C  ERRFIL. 



    2   FORMAT(A1000)

C  READ UNTIL THE LINE WHICH HAS THE WORDS "CTS IN THE DATA SET IS" ON
C  IT SOMEWHERE.

   10   READ(25,2) READLINE
	ILINE=0
	 DO I=1,51
	  IF(READLINE(I:I+21) .EQ. 'CTS IN THE DATA SET IS') THEN
	   ILINE=1
	   GO TO 20
	  ENDIF
	 END DO
   20   IF(ILINE .EQ. 0) GO TO 10

C  SOMEWHERE AFTER THE CHARACTERS IN ENTRIES I:I+21 IS THE INTEGER.
C  READ THE CHARACTERS FOR THIS INTEGER, AND THEN CONVERT IT TO
C  AN INTEGER VALUE. AFTER THE FOLLOWING LOOP, THESE CHARACTERS WILL BE
C  IN READLINE(ISTART:IEND).

	 IEND = 0
	 ISTART = 0


	  DO J = I+22, 72
	   IF(ISTART .EQ. 0 .AND. READLINE(J:J) .NE. ' ') ISTART = J
	   IF(ISTART .NE. 0 .AND. READLINE(J:J) .EQ. ' ') THEN
	    IEND = J-1
	    GO TO 30
	   ENDIF
	  END DO

C  CHECK TO MAKE SURE THAT THE NO. OF CHARACTERS READ IN FOR THE INTEGER
C  IS NOT MORE THAN 4 (I.E., 4 CHARACTERS ALLOW A MAXIMUM SIZE OF 9999
C  WHICH IS MORE THAN THE LARGEST VALUE THIS INTEGER CAN BE).

   30	ISIZE = IEND-ISTART

	IF(ISIZE .GT. 3) THEN



	 WRITE(*,*)' NSUBTOT IS ',NSUBTOT,' WHICH IS TOO LARGE. '
	 WRITE(*,*)' THE PROGRAM STOPS. '

        OPEN(42,FILE=ERRFIL)
         WRITE(42,*)' NSUBTOT IS ',NSUBTOT,' WHICH IS TOO LARGE. '
         WRITE(42,*)' THE PROGRAM STOPS. '
        CLOSE(42)



	 CALL PAUSE
	 STOP



	ENDIF

C  CONVERT AS INDICATED ABOVE.

	NSUBTOT = 0

	 DO K=ISTART,IEND
	  IF(READLINE(K:K) .EQ. '0') IVAL = 0
	  IF(READLINE(K:K) .EQ. '1') IVAL = 1
	  IF(READLINE(K:K) .EQ. '2') IVAL = 2

	  IF(READLINE(K:K) .EQ. '3') IVAL = 3
	  IF(READLINE(K:K) .EQ. '4') IVAL = 4
	  IF(READLINE(K:K) .EQ. '5') IVAL = 5
	  IF(READLINE(K:K) .EQ. '6') IVAL = 6
	  IF(READLINE(K:K) .EQ. '7') IVAL = 7
	  IF(READLINE(K:K) .EQ. '8') IVAL = 8
	  IF(READLINE(K:K) .EQ. '9') IVAL = 9
	  NSUBTOT = NSUBTOT + IVAL*10**ISIZE
	  ISIZE = ISIZE-1
	 END DO


	RETURN
	END
C

CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
	SUBROUTINE GETIPATFF(IFILE,NSUBTOT,NSUB,MAXSUB,
     1   IPATVEC,IERRR)
	DIMENSION IPATVEC(MAXSUB)
	CHARACTER READLINE*1000

C  SUBROUTINE GETIPATFF IS THE SAME AS GETIPATF, EXCEPT THE ERROR
C  MESSAGES TO THE USER ARE DIFFERENT.

C  SUBROUTINE GETIPATFF IS CALLED BY PREVRUN TO OBTAIN THE INDICES OF
C  THE "ACTIVE" SUBJECTS, IPATVEC(I),I=1,NSUB, FOR THIS RUN. THESE
C  INDICES ARE OBTAINED FROM FILE IFILE.

    3   FORMAT(A1000)

	NSUBB = 0
	NUMCUR = 0


C  NSUBB WILL BE THE NO. OF SUBJECTS SELECTED BY THE USER. IT IS
C  INITIALIZED AS 0, AND WILL GROW AS EACH LINE OF THE FILE IS READ.

C  NUMCUR IS THE INDEX OF THE HIGHEST PATIENT NO. ENTERED SO FAR.

C  NOTE THAT EACH LINE CONTAINS EITHER A SUBJECT NO. OR A RANGE OF

C  SUBJECT NOS. TO BE INCLUDED IN THE ANALYSIS. MULTIPLE SUBJECTS
C  CAN BE ENTERED USING COMMAS, SPACES AND/OR HYPHENS. FOR EXAMPLE,
C  2, 17 - 28 INDICATES SUBJECTS 2 AND 17 THROUGH 28;
C  17,28 INDICATES SUBJECTS 17 AND 28;
C  17 28 INDICATES SUBJECTS 17 AND 28.

C  RESTRICTIONS: 1. ON EACH LINE, USE NO MORE THAN 70 CHARACTERS;
C                2. PATIENT NOS., OR RANGES OF PATIENT NOS.
C                   MUST BE LISTED IN ASCENDING ORDER.

C  A LINE WITH JUST A 0 --> END OF THE LIST OF SUBJECT NOS.



 4210	IF(IFILE .EQ. 23) READ(23,3,ERR=4200) READLINE
	IF(IFILE .EQ. 25) READ(25,3,ERR=4200) READLINE

C  CALL SUBROUTINE GETNUMSF TO UPDATE NSUBB AND IPATVEC, WHERE IPATVEC
C  IS THE VECTOR WHICH CONTAINS THE PATIENT NOS. TO BE INCLUDED IN THE

C  ANALYSIS.

C  NOTE THAT ISTOP RETURNS AS 0 TO INDICATE THE END OF THE LIST OF
C  PATIENT NOS; IT RETURNS AS -1 IF THERE IS A CONFLICT IN THE LIST
C  (SEE RESTRICTION ABOVE) OR A PATIENT NO. LARGER THAN NSUBTOT
C  (THE MAXIMUM ALLOWABLE NO. OF SUBJECTS) HAS BEEN READ IN; AND IT
C  RETURNS AS 1 IF THERE ARE MORE LINES TO BE READ IN.

	CALL GETNUMSF(1,READLINE,NSUBB,NSUBTOT,NUMCUR,ISTOP,
     1                  MAXSUB,IPATVEC)
	IF(ISTOP .EQ. -1) GO TO 4200
	IF(ISTOP .EQ. 1) GO TO 4210

C  TO GET TO THIS POINT, ISTOP = 0 --> USER HAS STOPPED ENTERING
C  PATIENT NOS.

C  CHECK THAT NSUB, AS INPUT TO THIS ROUTINE (FROM MAIN) IS THE SAME
C  AS NSUBB, AS OBTAINED FROM THE LIST OF SUBJECTS TO BE INCLUDED IN
C  THE ANALYSIS. IF NOT, TELL USER AND RETURN IERRR = -1 SO THE USER
C  CAN MAKE A CORRECTION.

	IF(NSUB .EQ. NSUBB) THEN
	 IERRR = 0
	 RETURN
	ENDIF

	IF(NSUB .NE. NSUBB) THEN
         WRITE(*,2)

    2   FORMAT(//' THERE WAS AN ERROR IN THE READING OF PATIENT NOS.'/
     1' USED FOR THIS ANALYSIS. IN PARTICULAR, THE NO. OF '/
     2' SUBJECTS TO BE INCLUDED IN THE ANALYSIS, AS ENTERED IN THE'/
     3' OUTPUT FILE, DOES NOT MATCH THE LIST OF SUBJECT NOS.'/
     4' WHICH FOLLOW THAT NUMBER. IF YOU DID NOT MANUALLY EDIT THE'/
     5' OUTPUT FILE AFTER THE RUN, PLEASE CONTACT LAPK AND REPORT THIS'/
     6' ERROR.'//)
	IERRR = -1
	 RETURN
	ENDIF

 4200   WRITE(*,1)
    1   FORMAT(//' THERE WAS AN ERROR IN THE READING OF PATIENT NOS.'/
     1' USED FOR THIS ANALYSIS FROM THE OUTPUT FILE. IF YOU DID NOT '/
     2' MANUALLY EDIT THE OUTPUT FILE AFTER THE RUN, PLEASE CONTACT '/
     3' LAPK AND REPORT THIS ERROR.'//)

	IERRR = -1

	RETURN
	END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C 
       SUBROUTINE READBLOCK(ICALL,NSUB,MAXSUB,NOUT,NDRUG,PATH,C0P,C1P,
     1   C2P,C3P,C4P,C5P,MAXNUMEQ)

        IMPLICIT REAL*8(A-H,O-Z)

        CHARACTER ERRFIL*20

      COMMON/TOWRITE/IALLIN,IVERIFY,NCOVA,ICOVTYPE,COVNAME
      COMMON/ERROR/ERRFIL
C  COMMON/ERROR/ IS SUPPLIED TO ALL THE ROUTINES WHICH COULD WRITE TO
C  ERRFIL. 

C  AS OF IT2B109.FOR, COMMON/TOWRITE IS PROVIDED TO 
C  SUBROUTINE READBLOCK FROM MAIN.

	DIMENSION TIMOUT(MAXSUB,MAXNUMEQ,650),TIMIV(MAXSUB,7,650),
     1 NTIMOUT(MAXSUB,MAXNUMEQ),NTIMIV(MAXSUB,7),RATEIV(MAXSUB,7,650),
     2 BOLUS(MAXSUB,7,650),OUT(MAXSUB,MAXNUMEQ,650),COV(MAXSUB,26,650),
     3 ICOVTYPE(26),TIMBOL(MAXSUB,7,650),NTIMBOL(MAXSUB,7),
     4 NTIMCOV(MAXSUB,26),TIMCOV(MAXSUB,26,650),TIMALL(MAXSUB,5000),
     5 NTIMALL(MAXSUB),TIMI(5000),C0P(MAXNUMEQ),C1P(MAXNUMEQ),
     6 C2P(MAXNUMEQ),C3P(MAXNUMEQ),C4P(MAXNUMEQ),C5P(MAXNUMEQ),
     7 CSUB(MAXSUB,6,MAXNUMEQ),NSST(MAXSUB),DOSELINEST(MAXSUB,99,100)

	CHARACTER READLINE*1000,COVNAME(26)*11,NUMBER(MAXSUB)*3,PATFIL*20,
     2   CHARSUB*3,SUBID*11,SUBIDPREV*11,SUBARRAY(MAXSUB)*11,
     3   PATH*60,TMPFILE*13,PATHFILE*73


C  THIS ROUTINE IS BASED ON THE STAND-A-LONE PROGRAM, TESTRD8.FOR.

C  IT READS IN THE PATIENT DATA FROM ALREADY OPENED FILE 66, AND
C  IF ICALL = 1, CREATES INDIVIDUAL SUJBECT FILES WITH PREFIX XQZPJ,
C                AND SUFFIX ZMQ.
C  IF ICALL = 2, ESTABLISHES THE VALUE NOUT (THE NO. OF OUTPUT EQS.), 
C                AND THE VALUE OF NDRUG (THE NO. OF DRUGS), AND RETURNS
C                THEM TO SUBROUTINE GETNUMEQ.


    1   FORMAT(A1000)

C  INITIALIZE NDRUG (THE NO. OF DRUGS IN THE PATIENT DATA SET) TO BE
C  0. EVERY TIME IDRUGNO IS READ BELOW, NDRUG WILL BE SET =
C  MAX(NDRUG,IDRUGNO).

C  SIMILARLY, INITIALIZE NOUT (THE NO. OF OUTPUT EQUATIONS IN THE
C  PATIENT DATA SET) TO BE 0. EVERY TIME IOUTEQ IS READ BELOW,
C  NOUT WILL BE SET = MAX(NOUT,IOUTEQ).

	NDRUG = 0
	NOUT = 0

C  INITIALIZE NSST(ISUB) TO 0. IT GIVES THE NO. OF STEADY STATE DOSE
C  LINES THAT WILL BE WRITTEN TO THE DOSAGE BLOCK FOR EACH SUBJECT. 

      DO ISUB = 1,MAXSUB
       NSST(ISUB) = 0
      END DO


C  NOTE THAT ANY LINE STARTING WITH A # WILL BE IGNORED. THE FIRST LINE
C  WILL ALSO BE IGNORED - IT HAS ALREADY BEEN VERIFIED TO HAVE THE
C  REQUIRED CODE IN IT.

	READ(66,*)

C  READ THE 2ND LINE, WHICH MUST HAVE A # AS THE FIRST CHARACTER. IT HAS
C  THE NAMES OF THE COLUMNS. COUNT THE NO. OF COMMAS ON THE LINE. THE 
C  NO. OF COVARIATES WILL BE THE NO. OF COMMAS - 11 (SINCE THERE ARE 12
C  FIXED ENTRIES WHICH POTENTIALLY SHOW UP ON EACH LINE: PATIENT ID, 
C  EVENT ID, TIME, INFUSION DURATION, TOTAL DOSE, INPUT DRUG NO.,
C  OUTPUT VALUE, OUTPUT EQ., AND 4 SPOTS FOR ASSAY COEFFICIENTS WHICH 
C  ONLY SHOW UP ON OUTPUT LINES). NOTE THAT THIS VALUE WILL BE CALLED
C  NCOVA, WHICH MEANS NO. OF ADDITION COVARIATES (IN ADDITION TO THE 4
C  PERMANENT ONES AT THE TOP OF EACH PATIENT'S WORKING COPY FILE (AGE,
C  SEX, HEIGHT, ETHNICITY FLAG), TO DISTINGUISH IT FROM NCOV USED IN 
C  THE REST OF THE PROGRAM, WHICH REPRESENTS THE TOTAL NO. OF COVARIATES
C  INCLUDING THE PERMANENT 4 ONES.

	  READ(66,1) READLINE
        NCOMMA = 0

        DO ISTART = 1,1000	 
         IF(READLINE(ISTART:ISTART) .EQ. ',') THEN
          NCOMMA = NCOMMA + 1
         ENDIF
        END DO

        NCOVA = NCOMMA - 11


	IF(NCOVA .GT. 0) THEN

C  READ THE NAMES OF THE NCOVA COVARIATES FROM THE LINE STARTING WITH
C  #ID OR "#ID.

C  NOTE THAT AFTERCOMMA OPENS AND PUTS INTO FILE 57 THE PART OF READLINE
C  WHICH IS BETWEEN COMMA C AND COMMA C+1, WHERE C IS THE 3RD ARGUMENT.
C  ALSO,NOTE THAT NCOVA MUST BE PROVIDED TO AFTERCOMMA SO IT WILL KNOW
C  THE TOTAL NO. OF COMMAS IN READLINE (WHICH = 11 + NCOVA).

	REWIND(66)
  120	READ(66,1) READLINE
	IF(READLINE(1:3) .NE. '#ID' .AND. READLINE(1:4).NE. '"#ID'
     1  .AND. READLINE(1:3) .NE. '#id' .AND. READLINE(1:4).NE. '"#id')
     2   GO TO 120

	 DO ICOV = 1,NCOVA
	  CALL AFTERCOMMA(NCOVA,READLINE,11+ICOV)
	  BACKSPACE(57)
	  READ(57,2) COVNAME(ICOV)
    2   FORMAT(A11)
	  CLOSE(57)
	 END DO

	ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(NCOVA .GT. 0)  CONDITION.


C  AS OF IT2B109.FOR, GETMAXTIM WILL NOT BE CALLED IF ICALL = 2 (TIMADD
C  IS UNNEEDED IN THIS CASE, AND WILL BE SET = 0).

      TIMADD = 0

      IF(ICALL .EQ. 1) THEN


C  CALL SUBROUTINE GETMAXTIM TO GET THE MAXIMUM TIME OVER ALL THE
C  SUBJECTS IN FILE 66. THIS INCLUDES THE ENDING TIME OVER ALL IV
C  EVENTS. THEN SET TIMADD = THIS TIME + 1. FOR EACH SUBJECT BELOW,
C  EACH TIME WILL HAVE TIMADD*NRESET ADDED TO IT, WHERE NRESET IS THE
C  NO. OF TIME RESETS (FOR THAT SUBJECT) UP TO AND INCLUDING THAT TIME.
C  THIS WILL MAKE EACH TIME A UNIQUE TIME (I.E., WITH TIME RESETS IN
C  THE BLOCK FORMAT FILE, THERE COULD BE MANY TIMES WITH THE SAME
C  VALUE).

	CALL GETMAXTIM(NCOVA,TIMAX)

C  VERIFY THAT TIMAX WAS CALCULATED CORRECTLY - I.E., THAT IT IS NOT
C  STILL THE INITIALIZED NEGATIVE VALUE IN GETMAXTIM.

	IF(TIMAX .LT. 0) THEN



	 WRITE(*,11)
   11    FORMAT(/' THERE IS SOMETHING WRONG WITH YOUR BLOCK FORMAT'/
     1' FILE. THE TIMES IN COLUMN 3 AND/OR THE TIME DURATIONS'/
     2' IN COLUMN 4 ARE BAD. PLEASE CHECK YOUR VALUES. '//
     3' THE PROGRAM STOPS.')

        OPEN(42,FILE=ERRFIL)
         WRITE(42,11) 
        CLOSE(42)	



	 CALL PAUSE
	 STOP



	ENDIF


   	TIMADD = TIMAX + 1.D0

      ENDIF

C  ENDIF ABOVE IS FOR THE  IF(ICALL .EQ. 1)  CONDITION.



C  REWIND FILE 66, READ PAST THE FIRST LINE WHICH HAS THE CODE, AND
C  THE SECOND LINE, WHICH HAS THE COVARIATE INFORMATION ON IT, AND
C  THEN READ ALL LINES, EXCEPT THOSE THAT START WITH # OR "#.
C  GO THROUGH EACH SUCCEEDING LINE IN FILE 66 AND EXTRACT ALL THE
C  INFORMATION. NOTE THAT EACH LINE CAN CONTAIN OUTPUT INFO OR DOSAGE
C  INFO (INCLUDING COVARIATE VALUES), DEPENDING ON THE VALUE FOR IDEVENT
C  (THE 2ND ENTRY IN EACH LINE), BUT NOT BOTH. IN PARTICULAR, IF
C  IDEVENT = 0 --> THE ROW HAS OUTPUT EQUATION INFO.
C  IDEVENT = 1 --> THE ROW HAS DOSAGE/COVARIATE INFO.
C  IDEVENT = 4 --> SAME AS IDEVENT = 1, EXCEPT THIS ROW REPRESENTS A TIME
C                  RESET.

	REWIND(66)
	READ(66,1)
	READ(66,1)

C  INITIALIZE SUBIDPREV (THE PREVIOUS SUBJECT ID) TO BE '%^&*' SO THE
C  FIRST SUJBECT ID READ IN BELOW WILL BE DIFFERENT THAN THIS, AND SO
C  START THE SUBJECT ID LOGIC. ALSO, INITIALIZE THE SUBJECT NO. TO 0.

	SUBIDPREV = '%^&*'
	NSUB = 0


C  NOTE THAT IEND .LT. 0 --> END OF FILE REACHED.

   10	READ(66,1,IOSTAT=IEND) READLINE
	IF(IEND .LT. 0) GO TO 100
	IF(READLINE(1:1) .EQ. '#' .OR. READLINE(1:2) .EQ. '"#') GO TO 10

C  THE FIRST VALUE (I.E., AFTER COMMA NO. 0) IS THE SUBJECT ID.

	CALL AFTERCOMMA(NCOVA,READLINE,0)
	BACKSPACE(57)
	READ(57,2) SUBID
	CLOSE(57)

C  NOTE THAT SUBID CONTAINS THE 1ST 11 CHARACTERS OF THE LINE, BUT THE
C  SUBJECT ID IS JUST THE SET OF CHARACTERS PRIOR TO THE 1ST COMMA.
C  CALL SUBROUTINE GETID TO CORRECT THE VALUE OF SUBID.

	CALL GETID(SUBID)

C  IF SUBID = SUBIDPREV, THIS IS ANOTHER LINE FOR THE CURRENT SUBJECT.
C  IF SUBID .NE. SUBIDPREV, THIS IS THE 1ST EVENT FOR A NEW SUBJECT, SO
C  INCREASE NSUB, AND SET THE NO. OF INFUSIONS (FOR EACH DRUG), BOLI,
C  OBSERVATION, AND COVARIATE TIMES FOR THIS SUBJECT TO 0 (THEY WILL
C  BE UPDATED BELOW AS REQUIRED). SIMILARY SET THE TOTAL NO. OF DOSE
C  EVENTS = 0.

C  ALSO, SINCE THIS IS A NEW SUBJECT, DEFAULT THE ASSAY COEFFICIENTS FOR
C  OUTPUT EQ. IEQ TO [C0P(IEQ),C1P(IEQ),C2P(IEQ),C3P(IEQ)], 
C  IEQ = 1,MAXNUMEQ (THE MAX VALUE OF NUMEQT). THEN, AS THIS 
C  SUBJECT'S INFO IS BEING READ BELOW, ANY ASSAY C'S SPECIFIED FOR
C  THIS SUBJECT WILL OVERWRITE THE DEFAULT VALUES. AND NOTE THAT IF
C  A SUBJECT HAS MORE THAN ONE SET OF ASSAY C'S FOR A GIVEN OUTPUT EQ.,
C  THE LAST SET WILL BE USED.

C  NOTE THAT AFTER READBLOCK HAS FINISHED READING THE PATIENT INFO,
C  CSUB(I,J,K), J=1,4 WILL BE ASSAY C'S [C0 C1 C2 C3] FOR SUBJECT I
C  AND OUTPUT EQ. K.  


	IF(SUBID .NE. SUBIDPREV) THEN

	 SUBIDPREV = SUBID
	 NSUB = NSUB + 1

	 WRITE(*,8888) NSUB
 8888    FORMAT('+ ',' NOW WORKING ON SUBJECT NO. ',I4)

	 SUBARRAY(NSUB) = SUBID

	 NTIMALL(NSUB) = 0

	 DO K = 1,7
	  NTIMIV(NSUB,K) = 0
	  NTIMBOL(NSUB,K) = 0
	 END DO

	 DO K = 1,26
	  NTIMCOV(NSUB,K) = 0
	 END DO

        DO K = 1,6
         NTIMOUT(NSUB,K) = 0
         CSUB(NSUB,1,K) = C0P(K)
         CSUB(NSUB,2,K) = C1P(K)
         CSUB(NSUB,3,K) = C2P(K)
         CSUB(NSUB,4,K) = C3P(K)
         CSUB(NSUB,5,K) = 0.0
         CSUB(NSUB,6,K) = 0.0
        END DO

 
C  SEE LOGIC BELOW. IF THIS ROW REPRESENTS A TIME RESET, THEN AN
C  EXTRA VALUE (-99) AT AN EXTRA TIME (0) WILL BE ADDED TO EACH OUTPUT
C  EQUATION ARRAY. BUT THIS NEEDS TO BE DONE JUST ONCE FOR EACH TIME
C  RESET, NOT FOR EACH DOSAGE LINE THAT HAS A RESET. I.E., IF THERE
C  ARE 5 DRUGS, THEN THERE COULD BE AS MANY AS 5 DOSE LINES WITH A
C  RESET VALUE. ALSO, WITHIN EACH LINE, A DOSE AND/OR A COVARIATE
C  COULD HAVE A RESET TIME OF 0. THEREFORE EACH BLOCK OF CODE BELOW,
C  FOR EACH DRUG NO. AND EACH COVARIATE, IS TESTED FOR A TIME RESET,
C  AND IN EACH CASE, EXTRA LINES ARE POTENTIALLY ADDED TO THE OUPUT
C  ARRAYS. TO PREVENT MORE EXTRA LINES (OF OUTPUT VALUES = -99 AT
C  TIMES = 0) THAN ARE NECESSARY, INITIALIZE NRESETADD = 0. THIS
C  TELLS THE PROGRAM THAT NO EXTRA LINES HAVE BEEN ADDED TO THE OUTPUT
C  ARRAYS SINCE THE LAST ACTUAL OUTPUT VALUE WAS PUT INTO ONE OF THE
C  ARRAYS. NRESETADD WILL BE CHANGED TO 1 WHENEVER EXTRA LINES HAVE
C  BEEN ADDED TO THE OUTPUT ARRAYS, AND THEN BACK TO 0 WHENEVER ANOTHER
C  ACTUAL OUTPUT VALUE HAS BEEN PUT INTO AN ARRAY.

	NRESETADD = 0


C  INITIALIZE NRESET TO 0. IT WILL BE THE NO. OF TIME RESETS THAT
C  HAVE OCCURRED UP TO ANY TIME. ALSO INITIALIZE TIMERESET = 0; THIS
C  WILL BE THE RUNNING TIME TO BE ADDED TO EACH ACTUAL TIME. IT WILL
C  ALWAYS BE SET = TIMADD*NRESET BELOW.


	NRESET = 0
	TIMERESET = TIMADD*NRESET


C  ALSO INITIALIZE NRESETLAST = -1 (SEE CODE BELOW).

       NRESETLAST = -1
       DOSELINEST(NSUB,1,100) = -99

C  DOSELINEST(NSUB,1,100) IS INITIALIZED TO BE -99. IF IT CHANGES BELOW
C  TO BE .GE. 0, IT MEANS THAT THERE IS AT LEAST ONE STEADY STATE DOSE
C  SET, AND THE FIRST ONE OCCURS AT THE VALUE OF NRESET =
C  DOSELINEST(NSUB,1,100).



C  VERIFY THAT THE 2ND VALUE (I.E., AFTER COMMA NO. 1), WHICH IS THE
C  EVENT ID, IDEVENT, IS 1 SINCE THE FIRST EVENT FOR EACH SUBJECT
C  SHOULD BE 1 (A NON-TIME-RESET DOSE EVENT).

	CALL AFTERCOMMA(NCOVA,READLINE,1)
	BACKSPACE(57)
	READ(57,*) IDEVENT
	CLOSE(57)

	IF(IDEVENT .NE. 1) THEN

	 WRITE(*,402) SUBARRAY(NSUB),IDEVENT
  402    FORMAT(/' THERE IS AN ERROR IN THE BLOCK FORMAT. FOR SUBJECT '/
     1 1X,A11,', THE FIRST EVENT ID IS NOT 1 AS REQUIRED. IT IS ',I3/
     3' THE PROGRAM STOPS.'/)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,402) SUBARRAY(NSUB),IDEVENT 
        CLOSE(42)

	 CALL PAUSE
	 STOP



	ENDIF


	ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(SUBID .NE. SUBIDPREV)  CONDITION.


C  THE 2ND VALUE (I.E., AFTER COMMA NO. 1) IS THE EVENT ID, IDEVENT
C  (SEE ABOVE).

	CALL AFTERCOMMA(NCOVA,READLINE,1)
	BACKSPACE(57)	
      READ(57,*,ERR=470) IDEVENT
	CLOSE(57)
      GO TO 480

  470  WRITE(*,471) NSUB,READLINE(1:75)
  471  FORMAT(/' THERE IS AN ERROR IN YOUR BLOCK FORMAT FILE FOR '/
     1' SUBJECT NO. ',I5,'. THERE IS NO EVENT ID. THE 1ST 75'/
     2' CHARACTERS OF THE LINE ARE:'/
     2A75//
     3' THE PROGRAM STOPS.'/)
	 WRITE(*,401) NSUB,SUBARRAY(NSUB)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,471) NSUB,READLINE(1:75)
         WRITE(42,401) NSUB,SUBARRAY(NSUB)
        CLOSE(42)	

  	 CALL PAUSE
	 STOP


  480  CONTINUE


C  IF THE ID OF THIS EVENT IS NO. 4, IT IS A TIME RESET EVENT. IN THIS
C  CASE, INCREASE NRESET AND TIMERESET AS INDICATED ABOVE.

	IF(IDEVENT .EQ. 4) THEN
	 NRESET = NRESET + 1
	 TIMERESET = TIMADD*NRESET
	ENDIF


C  THE 3RD VALUE (I.E., AFTER COMMA NO. 2) IS THE TIME OF THE EVENT.
C  READ THIS VALUE NOW.

	CALL AFTERCOMMA(NCOVA,READLINE,2)
	BACKSPACE(57)
	READ(57,*) TIMEVENT
	CLOSE(57)

      IF(TIMEVENT .LT. 0.D0) THEN

C  STORE INTO DOSELINEST(.,.,.) ALL THE INFO FOR THE WORKING COPY FILE
C  FOR THIS STEADY STATE DOSE SET.

C  COMPARE NRESET WITH THE PREVIOUS VALUE OF NRESET WHEN THIS PART OF
C  THE CODE WAS USED: IF THEY ARE THE SAME, THIS LINE WILL PROVIDES
C  MORE INFO (FOR A DIFFERENT DRUG NO.) FOR THE SAME STEADY STATE DOSE
C  EVENT TO BE PUT INTO THE WORKING COPY FILE. IF THEY ARE DIFFERENT,
C  THIS LINE IS THE FIRST LINE OF A NEW STEADY STATE DOSE SET.


       IF(NRESET .GT. NRESETLAST) THEN

C  PUT IN NEW INFO FOR A NEW LINE (FOR A NEW STEADY STATE DOSE SET).
C  THIS LINE IS THE FIRST LINE WITH INFO ON A NEW STEADY STATE DOSE SET.
C  STORE ALL THE INFO FROM THIS LINE, INCLUDING NRESET, SO SUBROUTINE
C  WRITEDOS CAN WRITE THE INFO FOR THIS LINE SEPARATELY. NOTE THAT THIS
C  LINE WILL NOT BE A PART OF THE LOGIC BELOW WHICH STORES ALL DOSE 
C  INFO, AND THEN SORTS IT BY TIME. NOTE THAT NRESET IS STORED INTO
C  ENTRY 100 FOR THIS LINE.

        NSST(NSUB) = NSST(NSUB) + 1

        IF(NSST(NSUB) .GT. 99) THEN



         WRITE(*,172) NSUB
  172    FORMAT(/' FOR SUBJECT NO. ',I5,' THE NO. OF STEADY STATE DOSE'/
     1' SETS IS MORE THAN 99, THE MAXIMUM ALLOWED. PLEASE RERUN THE'/
     2' PROGRAM AFTER REDUCING THE NO. OF STEADY STATE DOSE SETS TO'/
     3' NO MORE THAN 99.'//
     4' THE PROGRAM STOPS.'/)
	  WRITE(*,401) NSUB,SUBARRAY(NSUB)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,172) NSUB
         WRITE(42,401) NSUB,SUBARRAY(NSUB)
        CLOSE(42)

        CALL PAUSE
        STOP



        ENDIF


        DOSELINEST(NSUB,NSST(NSUB),100) = NRESET

C  TIMEVENT IS THE NEGATIVE OF THE INTERDOSE INTERVAL, WHICH WILL SHOW
C  UP IN THE TIME COLUMN OF THE WORKING COPY FILE.

        DOSELINEST(NSUB,NSST(NSUB),1) = TIMEVENT

C  ZERO OUT ALL THE IV AND BOLUS ENTRIES FOR ALL POSSIBLE DRUGS
C  (I.E., THERE COULD BE AS MANY AS 7 DRUGS).

        DO I = 1,7
         DOSELINEST(NSUB,NSST(NSUB),2*I) = 0.D0

         DOSELINEST(NSUB,NSST(NSUB),2*I+1) = 0.D0
        END DO


C  STORE ANY COVARIATE INFO INTO THE COVARIATE ENTRIES. NOTE IT IS NOT
C  KNOWN AT THIS POINT HOW MANY TOTAL DRUGS ARE USED IN THE MODEL SINCE
C  THE VALUE FOR NDRUG HAS NOT YET FINISHED UPDATING (IN THE CODE BELOW,
C  IT IS SET = IDRUGNO IF NDRUG .LT. IDRUGNO). SO, THE COVARIATE VALUES
C  WILL BE STORED FAR ENOUGH OUT IN THE DOSELINEST(.,.,.) ARRAY TO NOT
C  INTERFERE WITH THE ENTRIES FOR THE MAXIMUM NO. OF POSSIBLE DRUGS.
C  SINCE THERE ARE AT MOST 7 POSSIBLE DRUGS, ENTRIES 2,3,...,14,15 WILL
C  BE RESERVED FOR THESE DRUG VALUES, AND THE COVARIATE VALUES WILL
C  START WITH ENTRY NO. 20.

        IF(NCOVA .GT. 0) THEN
         
         DO 110 ICOV = 1,NCOVA
          CALL AFTERCOMMA(NCOVA,READLINE,11+ICOV)
          BACKSPACE(57)
 	    READ(57,*,ERR=95) COVVAL
	    CLOSE(57)
          DOSELINEST(NSUB,NSST(NSUB),19+ICOV) = COVVAL
          GO TO 110
   95     DOSELINEST(NSUB,NSST(NSUB),19+ICOV) = -99.D0
  110    CONTINUE

        ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(NCOVA .GT. 0)  CONDITION.


C  FOR NPAG104.FOR, ADD LOGIC FOR EXTRA OBS. LINE WITH VALUES OF -99'S.

C  THIS IS EITHER A TIME RESET EVENT, OR THE TOP OF THE PATIENT'S FILE.
C  IF IT IS THE TOP OF THE PATIENT'S FILE, NRESET WILL = 0. IF IT IS A 
C  TIME RESET EVENT, NRESET WILL BE > 0, AND IN THIS CASE, MUST STORE 
C  VALUES INTO THE OUPUT ARRAYS (SEE LOGIC BELOW) WHICH INDICATE THAT
C  SUBSEQUENT OUTPUT TIMES ARE BASED ON THIS TIME RESET.


       IF(NRESET .GT. 0) THEN
        DO IOUTEQ = 1,MAXNUMEQ
         NTIMOUT(NSUB,IOUTEQ) = NTIMOUT(NSUB,IOUTEQ) + 1
         TIMOUT(NSUB,IOUTEQ,NTIMOUT(NSUB,IOUTEQ)) = TIMERESET
         OUT(NSUB,IOUTEQ,NTIMOUT(NSUB,IOUTEQ)) = -99.D0
        END DO
       ENDIF


       ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(NRESET .GT. NRESETLAST)  CONDITION.


C  ESTABLISH THE DURATION, (4TH VALUE, AFTER THE 3RD COMMA), DOSE (5TH
C  VALUE, AFTER THE 4TH COMMA), AND DRUG NO. (6TH VALUE, AFTER THE 5TH
C  COMMA) FOR THIS LINE.

        CALL AFTERCOMMA(NCOVA,READLINE,3)
        BACKSPACE(57)
        READ(57,*,ERR=170) DUR
        CLOSE(57)

        CALL AFTERCOMMA(NCOVA,READLINE,4)
        BACKSPACE(57)
        READ(57,*,ERR=170) TOTDOS
        CLOSE(57)

        CALL AFTERCOMMA(NCOVA,READLINE,5)
        BACKSPACE(57)
        READ(57,*,ERR=170) IDRUGNO
	  IF(NDRUG .LT. IDRUGNO) NDRUG = IDRUGNO

        CLOSE(57)

C  STORE THE IV RATE INTO THE IV ENTRY FOR DRUG NO. IDRUGNO; SIMILARLY,
C  STORE THE TOTAL DOSE INTO THE BOLUS ENTRY FOR DRUG NO. IDRUGNO.
C  NOTE THAT IF DUR = 0, THIS LINE REPRESENTS A STEADY STATE OF BOLUS 
C  VALUES. IN THIS CASE, SET THE IV RATE TO 0.

        IF(DUR .LE. 0.D0) 
     1   DOSELINEST(NSUB,NSST(NSUB),2*IDRUGNO) = 0.D0
        IF(DUR .GT. 0.D0)
     1   DOSELINEST(NSUB,NSST(NSUB),2*IDRUGNO) = TOTDOS/DUR
        DOSELINEST(NSUB,NSST(NSUB),2*IDRUGNO+1) = TOTDOS


C  NOTE THAT COVARIATE VALUES ARE ONLY READ FOR THE FIRST DOSE LINE
C  IN A STEADY STATE SET (I.E., WHEN NRESET .GT. NRESETLAST). IT IS
C  POSSIBLE THAT THE USER'S .csv FILE HAS A DIFFERENT SET OF COV. VALUES
C  FOR EACH LINE (FOR A DIFFERENT DRUG) THAT IS INCLUDED IN THE 
C  CURRENT STEADY STATE DOSE SET. BUT, THIS WOULD BE A MISTAKE SINCE
C  ONLY 1 SET OF COV. VALUES CAN BE USED FOR THE STEADY STATE SET. THE
C  FIRST SET OF VALUES WILL BE USED (AND ALL OTHERS WILL BE IGNORED).
 
C  SET NRESETLAST = NRESET SO IF ANOTHER LINE OF DOSE INFO FOR THE
C  CURRENT STEADY STATE SET FOLLOWS, THE PROGRAM WILL KNOW IT IS
C  MORE INFO ON THE CURRENT SET, AND NOT NEW INFO ON THE NEXT SET.
  
       NRESETLAST = NRESET

       GO TO 10


  170  WRITE(*,171) NSUB,READLINE(1:75)
  171  FORMAT(/' THERE IS AN ERROR IN YOUR BLOCK FORMAT FILE FOR '/

     1' SUBJECT NO. ',I5,'. EITHER THE DURATION, THE DOSE, OR THE '/
     2' DRUG NUMBER IS MISSING. THE 1ST 75 CHARACTERS OF THE LINE ARE:'/
     2A75//
     3' THE PROGRAM STOPS.'/)
	 WRITE(*,401) NSUB,SUBARRAY(NSUB)

        OPEN(42,FILE=ERRFIL)

         WRITE(42,171) NSUB,READLINE(1:75)
         WRITE(42,401) NSUB,SUBARRAY(NSUB)
        CLOSE(42)



  	 CALL PAUSE
	 STOP


      ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(TIMEVENT .LT. 0.D0)  CONDITION.


      
	TIMEVENT = TIMEVENT + TIMERESET


C  IF IDEVENT = 0, IT MEANS THAT THIS ROW IS AN OBSERVED VALUE ROW.
C  IN THIS CASE, READ THE OBSERVED VALUE INFO.

	IF(IDEVENT .EQ. 0) THEN

C  THE 7TH ENTRY (AFTER COMMA NO. 6) IS AN OUTPUT VALUE FOR THIS TIME
C  IF THERE IS AN ERROR, IT IS ASSUMED THAT THE PROGRAM READ A DOT,
C  WHICH WOULD BE INCONSISTENT SINCE IDEVENT = 0 (MEANING THERE SHOULD
C  BE AN OUTPUT VALUE ON THE ROW).

	CALL AFTERCOMMA(NCOVA,READLINE,6)
	BACKSPACE(57)
	READ(57,*,ERR=30) YVAL
	CLOSE(57)

C  TO GET TO THIS POINT --> YVAL CONTAINS AN OUTPUT VALUE FOR THIS
C  LINE. BEFORE THIS VALUE CAN BE STORED, MUST READ THE OUTPUT EQUATION
C  NO. AFTER COMMA NO. 7.


	CALL AFTERCOMMA(NCOVA,READLINE,7)
	BACKSPACE(57)
	READ(57,*,ERR=30) IOUTEQ
	IF(NOUT .LT. IOUTEQ) NOUT = IOUTEQ
	CLOSE(57)

C  STORE THIS VALUE. ALSO STORE THE TIME OF THIS EVENT INTO THE ARRAY
C  WHICH STORES OUTPUT TIMES.

	NTIMOUT(NSUB,IOUTEQ) = NTIMOUT(NSUB,IOUTEQ) + 1
	TIMOUT(NSUB,IOUTEQ,NTIMOUT(NSUB,IOUTEQ)) = TIMEVENT
	OUT(NSUB,IOUTEQ,NTIMOUT(NSUB,IOUTEQ)) = YVAL
	NRESETADD = 0


C  SEE CODE ABOVE REGARDING NRESEADD.

	GO TO 20

   30   WRITE(*,31) NSUB, TIMEVENT - TIMERESET
   31   FORMAT(/' THERE IS AN ERROR IN THE BLOCK FORMAT. FOR SUBJECT '/
     1' NO. ',I4,' AND TIME ',F10.4, ' A LINE HAS AN EVENT ID OF 0 IN'/
     2' COL. 2, INDICATING OBSERVED VALUE INFORMATION. BUT THERE IS '/
     3' EITHER NO OBSERVED VALUE IN COL. 7, OR NO OUTPUT EQUATION NO.'/
     4' IN ENTRY 8. '//
     3' THE PROGRAM STOPS.')
        WRITE(*,401) NSUB,SUBARRAY(NSUB)
  401   FORMAT(/' NOTE: THE ID FOR SUBJECT NO. ',I4,' IS ',A11/)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,31) NSUB, TIMEVENT - TIMERESET
         WRITE(42,401) NSUB,SUBARRAY(NSUB)
        CLOSE(42)
	


	CALL PAUSE
	STOP

   20 CONTINUE

C  THE 9TH - 12TH ENTRIES FOR THIS ROW POTENTIALLY HOLD NEW ASSAY 
C  COEFFICIENTS FOR THIS SUBJECT (NSUB) AND OUTPUT EQ. (IOUTEQ).
C  READ THESE VALUES. IF THEY ARE NOT MISSING, UPDATE THE ASSAY
C  COEFFICIENT INFO FOR THIS SUBJECT/OUTPUT EQ.

C  NOTE THAT THESE ENTRIES SHOULD ALL BE MISSING (DOTS OR n's) OR ALL
C  BE NUMBERS. IF THERE IS A COMBINATION  OF MISSING VALUES AND NUMBERS,
C  STOP THE PROGRAM AND TELL THE USER.

        IMISSC0 = 0
        IMISSC1 = 0
        IMISSC2 = 0
        IMISSC3 = 0
C IMISSC4 = 0
C IMISSC5 = 0 ! csv file has only the 1st 4 C values
      
        CALL AFTERCOMMA(NCOVA,READLINE,8)
        BACKSPACE(57)
        READ(57,*,ERR=230) C0
        CLOSE(57)

        GO TO 235
  230   IMISSC0 = 1

  235   CALL AFTERCOMMA(NCOVA,READLINE,9)
        BACKSPACE(57)
        READ(57,*,ERR=240) C1
        CLOSE(57)

        GO TO 245
  240   IMISSC1 = 1

  245   CALL AFTERCOMMA(NCOVA,READLINE,10)
        BACKSPACE(57)
        READ(57,*,ERR=250) C2
        CLOSE(57)

        GO TO 255

  250   IMISSC2 = 1

  255   CALL AFTERCOMMA(NCOVA,READLINE,11)
        BACKSPACE(57)
        READ(57,*,ERR=260) C3
        CLOSE(57)

        GO TO 265
  260   IMISSC3 = 1

  265   CONTINUE

C  IF ALL IMISSCx VALUES ARE 0, UPDATE THE ASSAY C'S FOR THIS
C  SUBJECT AND OUTPUT EQ. NO. IF ALL IMISSCx VALUES ARE 1, THEY
C  ARE ALL MISSING, SO JUST CONTINUE. IF SOME OF THE IMISSCx VALUES
C  ARE 0 AND SOME ARE 1, THIS IS AN INCONSISTENCY (I.E., THE USER HAS
C  ENTERED SOME BUT NOT ALL OF THE ASSAY C'S). IN THIS CASE, STOP THE
C  PROGRAM AFTER INFORMING THE USER OF HIS ERROR.

        ISUMC = IMISSC0 + IMISSC1 + IMISSC2 + IMISSC3

        IF(ISUMC .EQ. 0) THEN
         CSUB(NSUB,1,IOUTEQ) = C0
         CSUB(NSUB,2,IOUTEQ) = C1
         CSUB(NSUB,3,IOUTEQ) = C2
         CSUB(NSUB,4,IOUTEQ) = C3
         CSUB(NSUB,5,IOUTEQ) = 0.0
         CSUB(NSUB,6,IOUTEQ) = 0.0
        ENDIF

        IF(ISUMC .NE. 0 .AND. ISUMC .NE. 4) THEN



         WRITE(*,231) NSUB, TIMEVENT - TIMERESET,IOUTEQ
  231    FORMAT(/' THERE IS AN ERROR IN THE BLOCK FORMAT. FOR SUBJECT '/
     1' NO. ',I4,' AND TIME ',F10.4, ' A LINE HAS AN EVENT ID OF 0 IN'/
     2' COL. 2, INDICATING OBSERVED VALUE INFORMATION, BUT THIS LINE'/
     3' HAS AN INCOMPLETE SET OF ASSAY COEFFICIENTS FOR OUTPUT EQ. '/
     4' NUMBER ',I3,'. THERE MUST BE EITHER 4 ASSAY COEFFICIENTS ON'/
     5' AN OUTPUT LINE, OR NONE (IF NO OUTPUT LINES FOR A PARTICULAR'/
     6' SUBJECT x OUTPUT EQ. COMBO HAVE ASSAY COEFFICIENTS, THEN THE'/
     7' POPULATION COEFFICIENTS WILL BE USED).'//
     8' THE PROGRAM STOPS.')
         WRITE(*,401) NSUB,SUBARRAY(NSUB)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,231) NSUB, TIMEVENT - TIMERESET,IOUTEQ
         WRITE(42,401) NSUB,SUBARRAY(NSUB)
        CLOSE(42)	



         CALL PAUSE
         STOP



        ENDIF


	ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(IDEVENT .EQ. 0)  CONDITION.


	IF(IDEVENT .EQ. 1 .OR. IDEVENT .EQ. 4) THEN


C  IDEVENT = 1 OR 4 --> DOSE AND/OR COVARITE INFO IS TO BE READ IN.


C  THE 4TH ENTRY (AFTER COMMA NO. 3) IS AN INFUSION DURATION, AND THE
C  5TH ENTRY (AFTER COMMA NO. 4) IS THE TOTAL DOSE ... IF THIS LINE
C  HAS DOSE INFORMATION. NOTE THAT IF THERE IS NO DOSE, THE TOTAL DOSE
C  ENTRY WILL BE A DOT ("."). ALSO, IF THERE IS A TOTAL DOSE, BUT THE
C  INFUSION DURATION IS 0, THIS LINE REPRESENTS A BOLUS INPUT.

C  SO, 1ST TRY READING THE TOTAL DOSE AS A REAL NUMBER; IF THERE IS AN
C  ERROR, IT IS ASSUMED THAT THE PROGRAM READ A DOT.

	CALL AFTERCOMMA(NCOVA,READLINE,4)
	BACKSPACE(57)
	READ(57,*,ERR=40) TOTDOS
	CLOSE(57)

C  TO GET TO THIS POINT --> TOTDOS CONTAINS A TOTAL DOSE VALUE FOR THIS
C  LINE. READ THE INFUSION DURATION AFTER COMMA NO. 3 TO SEE IF THIS
C  DOSE IS AN INFUSION (WITH A POSITIVE DURATION) OR A BOLUS (WITH A
C  0 DURATION).

	CALL AFTERCOMMA(NCOVA,READLINE,3)
	BACKSPACE(57)
	READ(57,*,ERR=50) DUR
	CLOSE(57)

C  BEFORE THIS VALUE CAN BE STORED, MUST READ THE DRUG NO. AFTER COMMA
C  NO. 5.

	CALL AFTERCOMMA(NCOVA,READLINE,5)
	BACKSPACE(57)
	READ(57,*,ERR=50) IDRUGNO
	IF(NDRUG .LT. IDRUGNO) NDRUG = IDRUGNO
	CLOSE(57)

C  STORE THE ABOVE VALUES DEPENDING ON WHETHER THEY REPRESENT AN
C  INFUSION OR A BOLUS INPUT.

C  INCREASE THE NO. OF DOSAGE LINES FOR THIS SUBJECT. IF DUR > 0, THE
C  NO. OF DOSAGE LINES INCREASES BY 2 SINCE THERE WILL BE A START TIME
C  AND AN ENDING TIME. IF DUR = 0, THE NO. OF DOSAGE LINES WILL INCREASE
C  BY 1.

	IF(DUR .GT. 0) THEN

C  THE INFUSION RATE IS TOTDOS/DUR. SO THE DOSE VALUE THE 1ST DOSE
C  TIME BELOW WILL BE THIS INFUSION RATE, AND THE DOSE VALUE AT THE
C  2ND DOSE TIME BELOW WILL BE 0.

C  NOTE THAT EVERYTIME NTIMALL(NSUB) IS INCREASED, THE PROGRAM CHECKS
C  THAT IT HAS NOT GONE PAST 5000. IF SO, A MESSAGE TO THE USER IS
C  WRITTEN THAT THIS IS NOT ALLOWED AND THE PROGRAM STOPS.


	 NTIMALL(NSUB) = NTIMALL(NSUB) + 1

	 IF(NTIMALL(NSUB) .GT. 5000) THEN



	  WRITE(*,3001) NSUB
 3001     FORMAT(/' THE NO. OF LINES IN THE DOSAGE REGIMEN FOR SUBJECT'/
     1' NO. ',I5,' IS MORE THAN THE LIMIT OF 5000. PLEASE RERUN THE'/
     2' PROGRAM AFTER REDUCING THIS NO. TO BE LESS THAN 5000.'/)
	  WRITE(*,401) NSUB,SUBARRAY(NSUB)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,3001) NSUB
         WRITE(42,401) NSUB,SUBARRAY(NSUB)
        CLOSE(42)	



	  CALL PAUSE
	  STOP




	 ENDIF

	 TIMALL(NSUB,NTIMALL(NSUB)) = TIMEVENT


	 IF(IDEVENT .EQ. 4) THEN

C  IF IDEVENT = 4, IT MEANS THAT THIS IS A TIME RESET POINT (I.E., A
C  TIME IN THE DISTANT FUTURE WHICH WILL SHOW UP AS T = 0 IN THE
C  WORKING COPY FORMAT FILE). 

C  IN THIS CASE, IF NRESETADD = 0, ADD VALUES TO NTIMOUT, TIMOUT, AND
C  OUT FOR EACH  OF THE MAXNUMEQ POSSIBLE OUTPUT EQUATIONS (THERE ARE
C  NOUT OUTPUT EQUATIONS SO FAR, BUT IN SUBSEQUENT ROWS, NOUT COULD
C  INCREASE TO AT MOST MAXNUMEQ) TO INDICATE THAT
C  ANY OUTPUTS FOLLOWING THIS TIME ARE BASED ON THE TIME RESET. TO DO
C  THIS, PUT IN THE CURRENT TIME IN TIMOUT, AND A CORRESPONDING VALUE OF
C  -99 (MISSING VALUE), FOR EACH OUTPUT EQUATION.


C  STORE VALUES INTO THE OUPUT ARRAYS (TIME = 0 AND VALUE = -99) WHICH
C  INDICATE THAT SUBSEQUENT OUTPUT TIMES ARE BASED ON THIS TIME RESET.
C  ... BUT ONLY STORE THESE EXTRA VALUES IF NRESETADD = 0. IF
C  NRESETADD = 1, IT MEANS THAT THESE LINES HAVE ALREADY BEEN ADDED
C  SINCE THE LAST ACTUAL OUTPUT VALUE WAS PUT INTO ONE OF THE OUTPUT
C  ARRAYS.

	  IF(NRESETADD .EQ. 0) THEN
           DO IOUTEQ = 1,MAXNUMEQ
	    NTIMOUT(NSUB,IOUTEQ) = NTIMOUT(NSUB,IOUTEQ) + 1
            TIMOUT(NSUB,IOUTEQ,NTIMOUT(NSUB,IOUTEQ)) = TIMEVENT
   	    OUT(NSUB,IOUTEQ,NTIMOUT(NSUB,IOUTEQ)) = -99.D0
	   END DO
	   NRESETADD = 1
	  ENDIF

	 ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(IDEVENT .EQ. 4)  CONDITION.

C  IF THE CURRENT TIME IS THE SAME AS THE ENDING TIME OF THE PREVIOUS 
C  IV, DO NOT INCREASE NTIMIV(.,.) BELOW, BECAUSE THE NEW STARTING IV 
C  RATE MUST REPLACE THE 0.0 FROM THE ENDING OF THE PREVIOUS IV.

        ISAME = 0
        IF(NTIMIV(NSUB,IDRUGNO) .GT. 0) 
     1   CALL THESAME(TIMEVENT,TIMIV(NSUB,IDRUGNO,NTIMIV(NSUB,IDRUGNO)),
     2 ISAME)

        IF(ISAME .EQ. 0) NTIMIV(NSUB,IDRUGNO) = NTIMIV(NSUB,IDRUGNO) + 1
        TIMIV(NSUB,IDRUGNO,NTIMIV(NSUB,IDRUGNO)) = TIMEVENT
        RATEIV(NSUB,IDRUGNO,NTIMIV(NSUB,IDRUGNO)) = TOTDOS/DUR

	 NTIMALL(NSUB) = NTIMALL(NSUB) + 1

	 IF(NTIMALL(NSUB) .GT. 5000) THEN



	  WRITE(*,3001) NSUB
	  WRITE(*,401) NSUB,SUBARRAY(NSUB)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,3001) NSUB
         WRITE(42,401) NSUB,SUBARRAY(NSUB)
        CLOSE(42)	



	  CALL PAUSE
	  STOP




	 ENDIF

	 TIMALL(NSUB,NTIMALL(NSUB)) = TIMEVENT + DUR
	 NTIMIV(NSUB,IDRUGNO) = NTIMIV(NSUB,IDRUGNO) + 1
	 TIMIV(NSUB,IDRUGNO,NTIMIV(NSUB,IDRUGNO)) = TIMEVENT + DUR
	 RATEIV(NSUB,IDRUGNO,NTIMIV(NSUB,IDRUGNO)) = 0.D0

	ENDIF


C  THE ABOVE ENDIF IS FOR THE  IF(DUR .GT. 0)  CONDITION.



	IF(DUR .LE. 0) THEN

C  STORE THE BOLUS VALUE AT THE INDICATED TIME, TIMEVENT.

	 NTIMALL(NSUB) = NTIMALL(NSUB) + 1

	 IF(NTIMALL(NSUB) .GT. 5000) THEN


	  WRITE(*,3001) NSUB
	  WRITE(*,401) NSUB,SUBARRAY(NSUB)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,3001) NSUB
         WRITE(42,401) NSUB,SUBARRAY(NSUB)
        CLOSE(42)	



	  CALL PAUSE
	  STOP



	 ENDIF

	 TIMALL(NSUB,NTIMALL(NSUB)) = TIMEVENT


	 IF(IDEVENT .EQ. 4) THEN

C  SEE LOGIC ABOVE FOR TIME RESET LOGIC, AND ADDING LINES TO THE
C  OUTPUT EQUATION VALUES IN THAT CASE.

C  STORE VALUES INTO THE OUPUT ARRAYS (SEE LOGIC ABOVE) WHICH
C  INDICATE THAT SUBSEQUENT OUTPUT TIMES ARE BASED ON THIS TIME RESET.
C  ... BUT ONLY STORE THESE EXTRA VALUES IF NRESETADD = 0. IF
C  NRESETADD = 1, IT MEANS THAT THESE LINES HAVE ALREADY BEEN ADDED
C  SINCE THE LAST ACTUAL OUTPUT VALUE WAS PUT INTO ONE OF THE OUTPUT
C  ARRAYS.

	  IF(NRESETADD .EQ. 0) THEN
           DO IOUTEQ = 1,MAXNUMEQ
	    NTIMOUT(NSUB,IOUTEQ) = NTIMOUT(NSUB,IOUTEQ) + 1
            TIMOUT(NSUB,IOUTEQ,NTIMOUT(NSUB,IOUTEQ)) = TIMEVENT
   	    OUT(NSUB,IOUTEQ,NTIMOUT(NSUB,IOUTEQ)) = -99.D0
	   END DO
	   NRESETADD = 1
	  ENDIF

	 ENDIF


C  THE ABOVE ENDIF IS FOR THE  IF(IDEVENT .EQ. 4)  CONDITION.

	 NTIMBOL(NSUB,IDRUGNO) = NTIMBOL(NSUB,IDRUGNO) + 1
	 TIMBOL(NSUB,IDRUGNO,NTIMBOL(NSUB,IDRUGNO)) = TIMEVENT
	 BOLUS(NSUB,IDRUGNO,NTIMBOL(NSUB,IDRUGNO)) = TOTDOS

	ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(DUR .LE. 0)  CONDITION.


	GO TO 40


   50   WRITE(*,51) NSUB, TIMEVENT - TIMERESET
   51   FORMAT(/' THERE IS AN ERROR IN THE BLOCK FORMAT. FOR SUBJECT '/
     1' NO. ',I4,' AND TIME ',F10.4,' A LINE HAS A DOSAGE AMT., BUT NO'/
     2' DURATION (EVEN A BOLUS SHOULD HAVE A DURATION OF 0) IN '/
     3' ENTRY 4., OR NO DRUG NO. IN ENTRY 5.'//
     3' THE PROGRAM STOPS.')
	WRITE(*,401) NSUB,SUBARRAY(NSUB)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,51) NSUB,TIMEVENT - TIMERESET
         WRITE(42,401) NSUB,SUBARRAY(NSUB)
        CLOSE(42)	



	CALL PAUSE
	STOP


   40   CONTINUE


C  READ IN ANY COVARIATE VALUES IF NCOVA .GT. 0.

	IF(NCOVA .GT. 0) THEN

         DO 60 ICOV = 1,NCOVA

	  CALL AFTERCOMMA(NCOVA,READLINE,11+ICOV)
	  BACKSPACE(57)
 	  READ(57,*,ERR=70) COVVAL
	  CLOSE(57)

C  TO GET TO THIS POINT --> COVVAL REPRESENTS THE VALUE OF COV. NO.
C  ICOV. STORE IT AT THE INDICATED TIME, TIMEVENT.

	  NTIMALL(NSUB) = NTIMALL(NSUB) + 1

	 IF(NTIMALL(NSUB) .GT. 5000) THEN



	  WRITE(*,3001) NSUB
	  WRITE(*,401) NSUB,SUBARRAY(NSUB)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,3001) NSUB
         WRITE(42,401) NSUB,SUBARRAY(NSUB)
        CLOSE(42)	



	  CALL PAUSE
	  STOP



	 ENDIF

	 TIMALL(NSUB,NTIMALL(NSUB)) = TIMEVENT


	 IF(IDEVENT .EQ. 4) THEN

C  SEE LOGIC ABOVE FOR TIME RESET LOGIC, AND ADDING LINES TO THE
C  OUTPUT EQUATION VALUES IN THAT CASE.

C  STORE VALUES INTO THE OUPUT ARRAYS (TIME = 0 AND VALUE = -99) WHICH
C  INDICATE THAT SUBSEQUENT OUTPUT TIMES ARE BASED ON THIS TIME RESET.
C  ... BUT ONLY STORE THESE EXTRA VALUES IF NRESETADD = 0. IF
C  NRESETADD = 1, IT MEANS THAT THESE LINES HAVE ALREADY BEEN ADDED
C  SINCE THE LAST ACTUAL OUTPUT VALUE WAS PUT INTO ONE OF THE OUTPUT
C  ARRAYS.

	  IF(NRESETADD .EQ. 0) THEN
           DO IOUTEQ = 1,MAXNUMEQ
	    NTIMOUT(NSUB,IOUTEQ) = NTIMOUT(NSUB,IOUTEQ) + 1
            TIMOUT(NSUB,IOUTEQ,NTIMOUT(NSUB,IOUTEQ)) = TIMEVENT
   	    OUT(NSUB,IOUTEQ,NTIMOUT(NSUB,IOUTEQ)) = -99.D0
	   END DO
	   NRESETADD = 1
	  ENDIF

	 ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(IDEVENT .EQ. 4)  CONDITION.

C  SINCE MULTIPLE DOSE LINES CAN OCCUR AT THE SAME TIME (DEFINING
C  DOSES FOR DIFFERENT DRUGS OR IV VS. BOLUS VALUES, IT IS POSSIBLE
C  THAT A COVARIATE VALUE IS BEING RESET AT THE SAME TIME AS IN A
C  PREVIOUS LINE. IF THIS IS TRUE, TELL THE USER THAT THE COVARIATE
C  VALUE FROM THE FIRST LINE WILL BE USED. THIS MUST BE CHECKED ONLY
C  IF THE INDEX OF THE NO. OF COVARIATE VALUES IS > 0 - OTHERWISE
C  THIS IS THE FIRST LINE WITH A COVARIATE VALUE ON IT).

C  BUT, ONLY WRITE THIS WARNING IF THE TWO COVARIATE VALUES ARE
C  ACTUALLY DIFFERENT, BECAUSE IF THEY ARE THE SAME, THERE IS NO
C  CONFLICT, JUST REDUNDANCY.


	  IF(NTIMCOV(NSUB,ICOV) .GT. 0) THEN

	   CALL THESAME(TIMEVENT,TIMCOV(NSUB,ICOV,NTIMCOV(NSUB,ICOV)),
     1                  ISAMETIME)

	   CALL THESAME(COVVAL,COV(NSUB,ICOV,NTIMCOV(NSUB,ICOV)),
     1                  ISAMECOV)

	   IF(ISAMETIME .EQ. 1 .AND. ISAMECOV .EQ. 1) GO TO 60


	   IF(ISAMETIME .EQ. 1 .AND. ISAMECOV .EQ. 0) THEN
            WRITE(*,41) NSUB,TIMEVENT-TIMERESET,ICOV,
     1       COV(NSUB,ICOV,NTIMCOV(NSUB,ICOV)),COVVAL
   41       FORMAT(/' FOR SUBJECT, 'I2,' AT TIME ',G12.4,', COVARIATE'/
     1' NO. ',I2,' WAS SET TO BOTH ',G12.4,' AND ',G12.4,'. YOU SHOULD'/
     2' CHECK YOUR BLOCK FILE. FOR NOW, THE FIRST VALUE WILL BE USED.')

	    GO TO 60
	   ENDIF

	  ENDIF

	  NTIMCOV(NSUB,ICOV) = NTIMCOV(NSUB,ICOV) + 1
	  TIMCOV(NSUB,ICOV,NTIMCOV(NSUB,ICOV)) = TIMEVENT
	  COV(NSUB,ICOV,NTIMCOV(NSUB,ICOV)) = COVVAL

	  GO TO 60

   70     CONTINUE

C  TO GET TO LABEL 70 --> THERE WAS NO NUMBER IN THE ENTRY FOR
C  COVARIATE, ICOV.

   60   CONTINUE


	ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(NCOVA .EQ. 0)  CONDITION.


	ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(IDEVENT .EQ. 1 .OR. IDEVENT .EQ. 4)
C  CONDITION.



C  RETURN TO LABEL 10 TO READ THE NEXT LINE IN THE BLOCK PATIENT
C  DATA FILE.

	GO TO 10


  100   CONTINUE


C  IF ICALL = 2, THE CALL TO THIS ROUTINE WAS FROM GETNUMEQ. IN
C  THIS CASE, RETURN AT THIS POINT, SINCE GETNUMEQ ONLY NEEDS THE
C  VALUES FOR NOUT AND NDRUG.

	IF(ICALL .EQ. 2) RETURN


C  TO GET TO THIS POINT, ICALL = 1.

C  AS OF IT2B109.FOR, IALLIN AND IVERIFY ARE PROVIDED TO THIS
C  ROUTINE BY COMMON/TOWRITE FROM MAIN. IF IALLIN = 1 AND IVERIFY = 0, 
C  ICOVTYPE HAS ALREADY BEEN ESTABLISHED FROM THE INSTRUCTION FILE,
C  AND THE USER WANTS TO RUN THE PROGRAM WITH NO MORE INTERACTION.
C  IN THIS CASE, SKIP THE IF(NCOVA .GT. 0) CODE BELOW.
C  BUT NOTE THAT IN CASE THE USER USED AN INSTRUCTION FILE WITH
C  THE ICOVTYPE(.) VALUES NOT SPECIFIED (IN WHICH CASE ICOVTYPE(.)
C  COULD HAVE GARBAGE VALUES), DEFAULT THE VALUES TO BE INTERPOLATED,
C  WHICH IS A VALUE OF 2. SO THIS IS EQUIVALENT TO SETTING ANY
C  ICOVTYPE(.) VALUE NOT = 1 TO BE 2.

      IF(IALLIN .EQ. 1 .AND. IVERIFY .EQ. 0) THEN
  
       DO ICOV = 1,NCOVA
        IF(ICOVTYPE(ICOV) .NE. 1) ICOVTYPE(ICOV) = 2
       END DO
   
       GO TO 1050

      ENDIF


	IF(NCOVA .GT. 0) THEN

	 WRITE(*,111) NCOVA
  111    FORMAT(/' YOUR BLOCK FORMAT PATIENT INFORMATION FILE SHOWS'/
     1' ',I2,' COVARIATES. EACH COVARIATE MUST BE SPECIFIED TO BE '/
     2' EITHER A PIECEWISE CONSTANT COVARIATE OR AN INTERPOLATED '/
     3' COVARIATE.'//
     4' A PIECEWISE CONSTANT COVARIATE WILL HAVE THE SAME VALUE FROM'/
     5' ONE EXPLICITLY CODED VALUE, THROUGH ALL INTERVEENING DOSE'/
     6' TIMES, TO THE NEXT EXPLICITLY CODED VALUE (WHEN IT WILL CHANGE).
     7 '//
     8' AN INTERPOLATED COVARIATE WILL HAVE INTERPOLATED VALUES FROM'/
     9' ONE EXPLICITY CODED VALUE, THROUGH ALL INTERVEENING DOSE '/
     1' TIMES, TO THE NEXT EXPLCITLY CODED VALUE.'//)


	 DO ICOV = 1,NCOVA
  130	  WRITE(*,112) COVNAME(ICOV)
  112     FORMAT(/' FOR COVARIATE ',A11/
     1'  ENTER 1 IF IT IS TO BE PIECEWISE CONSTANT; '/
     2'  ENTER 2 IF IT IS TO BE INTERPOLATED: ')
	  READ(*,*,ERR=130) ITYPE
	  IF(ITYPE .NE. 1 .AND. ITYPE .NE. 2) GO TO 130
	  ICOVTYPE(ICOV) = ITYPE
	 END DO

	ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(NCOVA .GT. 0)  CONDITION.

 1050 CONTINUE


C  WRITE OUT ALL THE INFO IN THE ABOVE ARRAYS INTO A WORKING COPY
C  FORMAT. ACTUALLY, FOR NOW, JUST TRY TO CREATE THE DOSAGE AND
C  OBSERVATION PART OF A FILE SIMILAR TO 2DRUG001 (I.E., DON'T
C  WORRY NOW ABOUT THE TOP PART OF THE FILE, OR THE BOTTOM).

C  FIRST, CALL SUBROUTINE GETCHAR TO ESTABLISH THE NUMBER ARRAY.

	DO JSUB = 1,NSUB
	 CALL GETCHAR(JSUB,CHARSUB)
	 NUMBER(JSUB) = CHARSUB
	END DO


	DO 1000 ISUB = 1,NSUB


C  NOTE THAT THE WORKING COPY SUBJECTS WILL BE PLACED INTO THE
C  WORKING DIRECTORY. THE PREFIX WILL BE HARDCODED TO 'XQZPJ', AND THE
C  SUFFIX TO 'ZMQ'.

	 PATFIL = 'XQZPJ'//NUMBER(ISUB)//'.ZMQ'


C  CALL FULLNAME WHICH CONVERTS THE FILENAME TO PATHFILE, THE COMPLETE
C  NAME OF THE FILE, WHICH INCLUDES THE PATH (IF THE PATH IS NOT THE
C  CURRENT DIRECTORY).

         TMPFILE = ' '
	 TMPFILE = PATFIL
	 CALL FULLNAME(PATH,TMPFILE,PATHFILE)


	 OPEN(33,FILE=PATHFILE)

	 IF(NDRUG .GT. 7) THEN



	  WRITE(*,101) NDRUG
  101     FORMAT(/' NO. OF DRUGS IN THIS PATIENT DATA SET IS ',I2/
     1'  THIS IS MORE THAN 7, THE MAXIMUM --> PROGRAM STOPS.'/)
	  WRITE(*,401) ISUB,SUBARRAY(ISUB)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,101) NDRUG
         WRITE(42,401) ISUB,SUBARRAY(ISUB)
        CLOSE(42)	



	  CALL PAUSE
	  STOP



	 ENDIF




	 IF(NOUT .GT. MAXNUMEQ) THEN



	  WRITE(*,106) NOUT,MAXNUMEQ
  106     FORMAT(/' NO. OF OUTPUT EQS. THIS PATIENT DATA SET IS ',I2/
     1' THIS IS MORE THAN THE MAX. ALLOWED VALUE OF ',I2,'. SO THE'/
     2' PROGRAM STOPS.'/)
	  WRITE(*,401) ISUB,SUBARRAY(ISUB)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,106) NOUT,MAXNUMEQ
         WRITE(42,401) ISUB,SUBARRAY(ISUB)
        CLOSE(42)
	


	  CALL PAUSE
	  STOP



	 ENDIF

	 IF(NCOVA .GT. 26) THEN



	  WRITE(*,103) NCOVA
  103     FORMAT(/' NO. OF COVARIATES IN THIS PATIENT DATA SET IS ',I3/
     1'  THIS IS MORE THAN 26, THE MAXIMUM --> PROGRAM STOPS.'/)
	  WRITE(*,401) ISUB,SUBARRAY(ISUB)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,103) NCOVA
         WRITE(42,401) ISUB,SUBARRAY(ISUB)
        CLOSE(42)
	


	  CALL PAUSE
	  STOP



	 ENDIF


C  BEFORE CALLING WRITEDOS, CALL TIMESET FOR THIS SUBJECT TO
C  ELIMINATE ALL THE DUPLICATE TIMES IN TIMALL(ISUB,.). THERE COULD BE
C  DUPLICATE TIMES BECAUSE NTIMALL(ISUB) WAS INCREASED BY 1 FOR EACH
C  BOLUS, IV, OR COVARIATE VALUE, AND SOME OF THESE VALUES OCCUR AT THE
C  SAME TIME.  TIMESET ALSO ORDERS THE TIMES AND THEY COULD BE OUT OF
C  ORDER DUE TO AN IV RATE WHOSE DURATION RESULTS IN THE ENDING TIME
C  BEING PAST THE NEXT DOSE EVENT.

C  TIMESET RETURNS THE COMPLETE SET OF TIMES FOR THIS SUBJECT'S DOSAGE
C  REGIMEN IN TIMI (AND THERE ARE NTIMI OF THEM).

	 CALL TIMESET(MAXSUB,ISUB,SUBARRAY(ISUB),NTIMALL,TIMALL,NTIMI,
     1    TIMI)


C  CALL WRITEDOS TO WRITE THE PATIENT INFO TO PATHFILE = FILE 33.


	 CALL WRITEDOS(ISUB,NTIMIV,TIMIV,RATEIV,NTIMBOL,TIMBOL,BOLUS,
     1    NTIMCOV,TIMCOV,COV,ICOVTYPE,NDRUG,NCOVA,NOUT,NTIMOUT,
     2    TIMOUT,OUT,SUBARRAY(ISUB),COVNAME,MAXSUB,NTIMI,TIMI,TIMADD,
     3    CSUB,NSST,DOSELINEST,MAXNUMEQ)


 1000   CONTINUE




	RETURN
	END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
	SUBROUTINE AFTERCOMMA(NCOVA,READLINE,NCOMMA)
	CHARACTER READLINE*1000,ERRFIL*20

      COMMON/ERROR/ERRFIL
C  COMMON/ERROR/ IS SUPPLIED TO ALL THE ROUTINES WHICH COULD WRITE TO
C  ERRFIL. NOTE THAT ERRFIL IS SET = 'ERRORLOG' BELOW.

C  OPEN AND WRITE INTO SCRATCH FILE 57 THE PART OF READLINE THAT
C  IS BETWEEN COMMAS NCOMMA AND NCOMMA+1 ... UNLESS NCOMMA IS THE MAX.
C  NO. OF COMMAS (11+NCOVA). IN THIS CASE, WRITE INTO SCRATCH FILE 57 
C  THE PART OF READLINE THAT FOLLOWS COMMA NCOMMA (SINCE THERE WILL NOT
C  BE ANOTHER COMMA).

    1   FORMAT(A1000)

C  IF NCOMMA = 0, SET ISTART = 0 AND GO TO LABEL 10.

	IF(NCOMMA .EQ. 0) THEN
	 ISTART = 0
	 GO TO 10
	ENDIF

	ICOMMA = 0

	DO ISTART = 1,300
	 IF(READLINE(ISTART:ISTART) .EQ. ',') THEN
	  ICOMMA = ICOMMA + 1

	  IF(ICOMMA .EQ. NCOMMA) GO TO 10
	 ENDIF
	END DO

C  TO GET TO THIS POINT MEANS THAT THE NO. OF COMMAS IN LINE
C  READLINE IS LESS THAN NCOMMA. WRITE A MESSAGE AND STOP.

	WRITE(*,2) NCOMMA,ICOMMA,READLINE
    2   FORMAT(/' THE FOLLOWING LINE WAS SUPPOSED TO HAVE AT LEAST ',I3/
     1' COMMAS, BUT IT HAD ONLY ',I3,' SO THE PROGRAM STOPS.'//
     2A1000)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,2) NCOMMA,ICOMMA,READLINE
        CLOSE(42)	



	CALL PAUSE
	STOP


C  TO REACH LABEL 10, ISTART IS NOW THE COLUMN NO. WHICH HAS THE
C  NCOMMAth COMMA IN LINE READLINE.  FIND IEND, WHICH IS THE COLUMN NO.



C  WHICH HAS THE NCOMMA+1 ST COMMA IN THE LINE. THEN WRITE THE PORTION
C  OF READLINE WHICH IS BETWEEN ISTART AND IEND INTO FILE57.

   10	ICOMMA = 0

	DO IEND = 1,300
	 IF(READLINE(IEND:IEND) .EQ. ',') THEN
	  ICOMMA = ICOMMA + 1
	  IF(ICOMMA .EQ. NCOMMA+1) GO TO 20
	 ENDIF
	END DO

C  TO GET TO THIS POINT MEANS THAT THE NO. OF COMMAS IN LINE
C  READLINE IS LESS THAN NCOMMA+1. THIS IS OK IF NCOMMA IS THE MAXIMUM
C  NO. OF COMMAS, WHICH IS 11+NCOVA. OTHERWISE, WRITE A MESSAGE AND
C  STOP.

	IF(NCOMMA .LT. 11 + NCOVA) THEN



	 WRITE(*,2) NCOMMA+1,ICOMMA,READLINE

        OPEN(42,FILE=ERRFIL)
         WRITE(42,2) NCOMMA+1,ICOMMA,READLINE
        CLOSE(42)
	


	 CALL PAUSE
	 STOP



	ENDIF

	IF(NCOMMA .EQ. 11 + NCOVA) IEND = 301

   20	  OPEN(57,STATUS='SCRATCH')


C  SEE CODE AT TOP OF ITBIG10.FOR TO SEE WHY FORMATTED WRITE
C  STATEMENTS ARE USED (UNLESS NUMCHAR BELOW IS > 11, IN WHICH CASE
C  A FREE FORMAT WRITE STATEMENT IS STILL USED).

        NUMCHAR = IEND - ISTART - 1

        IF(NUMCHAR .EQ. 1) WRITE(57,101) READLINE(ISTART+1:IEND-1)
  101   FORMAT(A1)

        IF(NUMCHAR .EQ. 2) WRITE(57,102) READLINE(ISTART+1:IEND-1)
  102   FORMAT(A2)

        IF(NUMCHAR .EQ. 3) WRITE(57,103) READLINE(ISTART+1:IEND-1)
  103   FORMAT(A3)

        IF(NUMCHAR .EQ. 4) WRITE(57,104) READLINE(ISTART+1:IEND-1)
  104   FORMAT(A4)

        IF(NUMCHAR .EQ. 5) WRITE(57,105) READLINE(ISTART+1:IEND-1)
  105   FORMAT(A5)

        IF(NUMCHAR .EQ. 6) WRITE(57,106) READLINE(ISTART+1:IEND-1)
  106   FORMAT(A6)

        IF(NUMCHAR .EQ. 7) WRITE(57,107) READLINE(ISTART+1:IEND-1)
  107   FORMAT(A7)

        IF(NUMCHAR .EQ. 8) WRITE(57,108) READLINE(ISTART+1:IEND-1)
  108   FORMAT(A8)

        IF(NUMCHAR .EQ. 9) WRITE(57,109) READLINE(ISTART+1:IEND-1)
  109   FORMAT(A9)

        IF(NUMCHAR .EQ. 10) WRITE(57,110) READLINE(ISTART+1:IEND-1)
  110   FORMAT(A10)

        IF(NUMCHAR .EQ. 11) WRITE(57,111) READLINE(ISTART+1:IEND-1)
  111   FORMAT(A11)

        IF(NUMCHAR .GT. 11) WRITE(57,*) READLINE(ISTART+1:IEND-1)


	RETURN
	END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C	SUBROUTINE GETCHAR(JSUB,CHARSUB)

C  THIS ROUTINE IS INCLUDED IN THE MODULE SCAT72XX.FOR.

C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
	SUBROUTINE WRITEDOS(ISUB,NTIMIV,TIMIV,RATEIV,NTIMBOL,TIMBOL,
     1   BOLUS,NTIMCOV,TIMCOV,COV,ICOVTYPE,NDRUG,NCOVA,NOUT,NTIMOUT,
     2   TIMOUT,OUT,SUBID,COVNAME,MAXSUB,NTIMI,TIMI,TIMADD,CSUB,NSST,
     3   DOSELINEST,MAXNUMEQ)

	IMPLICIT REAL*8(A-H,O-Z)

	DIMENSION BOLVAL(7),COVVAL(26),XIVVAL(7),DOSELINE(650,43),
     1 TIMOUT(MAXSUB,MAXNUMEQ,650),TIMIV(MAXSUB,7,650),
     2 NTIMOUT(MAXSUB,MAXNUMEQ),
     2 NTIMIV(MAXSUB,7),RATEIV(MAXSUB,7,650),BOLUS(MAXSUB,7,650),
     3 OUT(MAXSUB,MAXNUMEQ,650),COV(MAXSUB,26,650),ICOVTYPE(26),
     4 TIMBOL(MAXSUB,7,650),NTIMBOL(MAXSUB,7),NTIMCOV(MAXSUB,26),
     5 TIMCOV(MAXSUB,26,650),INDIV(7),INDBOL(7),INDCOV(26),
     6 TIMI(5000),TIMORD(3900),BLOCKOUT(3900,MAXNUMEQ),

     7 CSUB(MAXSUB,6,MAXNUMEQ),
     7 NSST(MAXSUB),DOSELINEST(MAXSUB,99,100),DOSELINES(100)

	CHARACTER SUBID*11,COVNAME(26)*11,ERRFIL*20

      COMMON/ERROR/ERRFIL
C  COMMON/ERROR/ IS SUPPLIED TO ALL THE ROUTINES WHICH COULD WRITE TO
C  ERRFIL. NOTE THAT ERRFIL IS SET = 'ERRORLOG' BELOW.

C  THIS ROUTINE WRITES THE DOSE EVENTS AND THE OBSERVATION EVENTS OF
C  THE PATIENT DATA FILE TO FILE33. NOTE THAT A DOSE EVENT OCCURS
C  WHENEVER THERE IS A BOLUS APPLIED, AN IV RATE CHANGE, AND/OR A
C  COVARIATE VALUE APPLIED.


C----------------- WRITE THE TOP OF FILE BELOW -------------------------

	WRITE(33,301) SUBID
  301   FORMAT('  LAST AND FIRST NAMES ARE: ',A11)
	WRITE(33,302) SUBID
  302   FORMAT(' CHART NUMBER IS: ',A11//
     1' WARD NO, PATIENT AGE (YEARS), SEX, HEIGHT (INCHES),'/
     2' ETHNICITY FLAG, AND ETHNICITY DESCRIPTION (IF ANY)   FOLLOW ON'/
     3' THE NEXT 6 LINES:'/
     4'-99'/
     5'-99'/
     6'M'/
     7'-99'/
     8'1'/
     9'Ethnicity Description'//
     1' DATE OF FIRST THERAPY IS   1   1   08'/
     2'CCR ML/MIN/    0.00 150.00'/
     3'HOURS    MG     MG/HR    MCG/ML KG       MG/DL    60  .00 ')


C----------------- WRITE THE TOP OF FILE ABOVE -------------------------


C----------------- WRITE THE DOSE EVENTS BELOW -------------------------

	 WRITE(33,102) NDRUG
  102    FORMAT(/'     ',I1,' ... NO. OF DRUGS')

C  NOTE THAT NCOVA IS THE NO. OF COVARIATES IN THE USER'S BLOCK FORMAT
C  FILE. THIS AUTOMATICALLY BECOMES NADD, THE NO. OF "ADDITIONAL"
C  COVARIATES IN THE WORKING COPY FILE.

	 WRITE(33,104) NCOVA
  104    FORMAT('    ',I2,' ... NO. OF ADDITIONAL COVARIATES')

C  INCREASE THE NO. OF DOSE EVENTS BY THE NO. OF STEADY STATE DOSE LINES
C  THAT WILL BE IN THE FILE (THESE WERE NOT PART OF THE ARRAY EXAMINED
C  BY SUBROUTINE TIMESET).

	WRITE(33,2) NTIMI + NSST(ISUB)
    2   FORMAT('   ',I3,' ... NO. OF DOSE EVENTS'//
     1'    TIME, IV/PO FOR EACH DRUG; ADDITIONAL COVARIATES IF ANY')

C  SET THE IVs FOR EACH DRUG TO 0. EACH DRUG IV VALUE STAYS THE SAME
C  AS ITS PREVIOUS VALUE UNTIL CHANGED. ALSO INITIALIZE EACH BOLUS
C  VALUE TO 0.

	DO IDRUG = 1,NDRUG
	 XIVVAL(IDRUG) = 0.D0
	 BOLVAL(IDRUG) = 0.D0
	END DO

C  SET EACH COVARIATE VALUE TO ITS INITIAL VALUE. IT IS ASSUMED THAT
C  EACH COV. HAS ITS FIRST VALUE SET AT THE FIRST DOSE TIME (T=0).
C  IF THIS IS NOT TRUE, SEE REMARK BELOW WHERE THE COVARIATE VALUES
C  ARE SET FOR EACH TIME.

	DO ICOV = 1,NCOVA
	 COVVAL(ICOV) = COV(ISUB,ICOV,1)
	END DO


C  INITIALIZE THE INDEX OF THE NEXT TIME IN EACH TIME ARRAY TO BE 1.

	DO IDRUG = 1,NDRUG

	 INDIV(IDRUG) = 1
	 INDBOL(IDRUG) = 1
	END DO



	DO ICOV = 1,NCOVA
	 INDCOV(ICOV) = 1
	END DO


C  GO THROUGH ALL THE NTIMI DOSAGE BLOCK TIMES IN TIMI AND ESTABLISH ALL
C  IV, BOLUS, AND COV. VALUES AT EACH TIME AND WRITE THEM TO THE DOSAGE
C  REGIMEN, BUT NOTE THAT EACH TIME MUST BE REDUCED BY TIMERESET, WHERE
C  TIMERESET = TIMADD*NRESET, WHERE NRESET IS THE NO. OF TIME RESETS
C  THROUGH THAT TIME (SEE IN READBLOCK THAT TIMERESET WAS ADDED TO EACH
C  TIME).

	NRESET = 0
	TIMERESET = TIMADD*NRESET

C  INITIALIZE NSSEVENTS = 1. THIS WILL BE THE INDEX OF THE NEXT STEADY
C  STATE DOSE EVENT (IF ANY) IN THE CURRENT PATIENT'S DATA FILE. THE
C  TOTAL NO. OF SUCH EVENTS IS NSST(ISUB).

      NSSEVENTS = 1

C  AS OF IT2B103, PUT IN A STEADY STATE LINE AS THE FIRST DOSE EVENT
C  IF ONE EXISTS. 


C  DOSELINEST(ISUB,1,100) = NRESET, THE NO. OF DOSE RESETS BEFORE THE
C  1ST STEADY STATE DOSE SET. 


C  IF DOSELINST(ISUB,1,100) = 0, IT MEANS THAT THERE IS A STEADY STATE
C  DOSE SET AT THE TOP OF THE FILE (I.E., BEFORE ANY RESETS). 


C  IF DOSELINEST(ISUB,1,100) IS = -99, IT MEANS THERE ARE NO STEADY 
C  STATE LINES FOR THIS SUBJECT. 

C  IF DOSELINEST(ISUB,1,100) = N > 0, IT MEANS THE FIRST STEADY STATE
C  DOSE SET OCCURS AFTER RESET NO. N.

      CALL THESAME(DOSELINEST(ISUB,1,100),0.D0,ISAME)

      IF(ISAME .EQ. 1) THEN

C  FILL IN THE ENTRIES TO DOSELINE FOR THE STEADY STATE DOSE AT THE
C  TOP OF THE PATIENT'S FILE.

C  THE FIRST ENTRY IN DOSELINST IS TIMEVENT = THE NEGATIVE OF THE
C  INTERDOSE INTERVAL.

	 DOSELINES(1) = DOSELINEST(ISUB,1,1)
	 NENTRY = 1

C  FOR EACH DRUG, THE IV AND TOTAL VALUES ARE ALREADY STORED INTO
C  DOSELINEST(ISUB,1,2*I) AND DOSELINEST(ISUB,1,2*I+1), I=1,NDRUG.

	 DO IDRUG = 1,NDRUG
	  NENTRY = NENTRY+1
        DOSELINES(NENTRY) = DOSELINEST(ISUB,1,2*IDRUG)
	  NENTRY = NENTRY+1
	  DOSELINES(NENTRY) = DOSELINEST(ISUB,1,2*IDRUG+1)
	 END DO

C  FOR EACH COVARIATE, IF ANY, THE VALUES ARE STORED INTO
C  DOSELINEST(ISUB,1,19+ICOV), ICOV = 1,NCOVA.

       IF(NCOVA .GT. 0) THEN
	  DO ICOV = 1,NCOVA
	   NENTRY = NENTRY+1
	   DOSELINES(NENTRY) = DOSELINEST(ISUB,1,19+ICOV)
	  END DO
       ENDIF

       WRITE(33,1) (DOSELINES(J),J=1,NENTRY)

       NSSEVENTS = NSSEVENTS + 1

      ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(ISAME .EQ. 1)  CONDITION.



	DO 1000 ITIM = 1,NTIMI

	 TIME = TIMI(ITIM)


C  IF THIS TIME = THE NEXT MULTIPLE OF TIMADD, INCREASE THE NO. OF
C  RESETS BY 1 AND RECALCULATE TIMERESET, THE CURRENT AMOUNT THAT EACH
C  TIME MUST BE REDUCED BEFORE BEING WRITTEN INTO THE WORKING COPY
C  FILE.

C  AS OF IT2B103.FOR, THIS TIME COULD BE PAST A TIME RESET POINT. THIS
C  WOULD HAPPEN IF A TIME RESET HAD A STEADY STATE DOSE SET ASSOCIATED
C  WITH IT, WITHOUT A NON STEADY STATE DOSE IMMEDIATELY FOLLWOING IT (IF
C  A NON STEADY STATE DOSE IMMEDIATELY FOLLOWED A STEADY STATE SET, 
C  THEN THERE WILL BE TIMI(.) ENTRY THAT = TIMADD*(NRESET+1)). IN THIS
C  CASE TOO, UPDATE NRESET AND TIMERESET.

C  CALL THESAME HERE TO ESTABLISH THE VALUE FOR ISAMERESET. IT
C  WILL USED BELOW TO SUPPRESS INTERPOLATION OF COVARIATES ACROSS A
C  TIME RESET.

       CALL THESAME(TIME,TIMADD*(NRESET+1),ISAMERESET)   



       IF(TIME .GE. TIMADD*(NRESET+1)) THEN

C  TIME IS AT OR PAST THE NEXT MULTIPLE OF TIMADD (I.E., IT IS A TIME
C  RESET POINT). IN THIS CASE, INCREASE NRESET BY 1 AND RECALCULATE
C  TIMERESET.

	  NRESET = NRESET + 1
	  TIMERESET = TIMADD*NRESET


C  FOR THIS TIME RESET, CHECK TO SEE IF THE FIRST DOSE LINE WILL BE
C  A STEADY STATE DOSE EVENT. THE NO. OF STEADY STATE DOSE EVENTS IN
C  THIS PATIENT'S FILE IS NSST(ISUB), AND THE NO. OF SUCH EVENTS THAT
C  HAVE ALREADY BEEN WRITTEN TO FILE 33 IS NSSEVENTS-1 SO FAR.

        IF(NSSEVENTS .LE. NSST(ISUB)) THEN


C  THE NEXT STEADY STATE DOSE EVENT OCCURS AFTER RESET NO.
C  DOSELINEST(ISUB,NSSEVENTS,100). CHECK TO SEE IF THIS VALUE IS
C  THE SAME AS NRESET. IF SO, THIS RESET STARTS WITH A STEADY STATE
C  LINE.

         XRESET = NRESET

         CALL THESAME(DOSELINEST(ISUB,NSSEVENTS,100),XRESET,ISAME)

         IF(ISAME .EQ. 1) THEN

C  FILL IN THE ENTRIES TO DOSELINE FOR THE STEADY STATE DOSE AT THE
C  BEGINNING OF THIS DOSE RESET.


C  THE FIRST ENTRY IN DOSELINST IS TIMEVENT = THE NEGATIVE OF THE
C  INTERDOSE INTERVAL.


          DOSELINES(1) = DOSELINEST(ISUB,NSSEVENTS,1)
          NENTRY = 1

C  FOR EACH DRUG, THE IV AND TOTAL VALUES ARE ALREADY STORED INTO
C  DOSELINEST(ISUB,NSSEVENTS,2*I) AND DOSELINEST(ISUB,NSSEVENTS,2*I+1),
C  I=1,NDRUG.

          DO IDRUG = 1,NDRUG
           NENTRY = NENTRY+1
           DOSELINES(NENTRY) = DOSELINEST(ISUB,NSSEVENTS,2*IDRUG)
           NENTRY = NENTRY+1
           DOSELINES(NENTRY) = DOSELINEST(ISUB,NSSEVENTS,2*IDRUG+1)
          END DO

C  FOR EACH COVARIATE, IF ANY, THE VALUES ARE STORED INTO

C  DOSELINEST(ISUB,NSSEVENTS,19+ICOV), ICOV = 1,NCOVA.

          IF(NCOVA .GT. 0) THEN
           DO ICOV = 1,NCOVA
            NENTRY = NENTRY+1
            DOSELINES(NENTRY) = DOSELINEST(ISUB,NSSEVENTS,19+ICOV)
           END DO
          ENDIF


          WRITE(33,1) (DOSELINES(J),J=1,NENTRY)

          NSSEVENTS = NSSEVENTS + 1

         ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(ISAME .EQ. 1)  CONDITION.


        ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(NSSEVENTS .LE. NSST(ISUB))  CONDITION.


	 ENDIF

C  THE ABOVE ENDIF IS FOR THE IF(TIME .GE. TIMADD*(NRESET+1)) CONDITION.




C  CHECK TO SEE IF ANY BOLUS TIMES = TIME.

	DO IDRUG = 1,NDRUG

C  IF THE CURRENT INDEX FOR THIS BOLUS IS MORE THAN THE NO.
C  OF ENTRIES IN THE CORRESPONDING ARRAY, IT MEANS THAT THERE ARE NO
C  MORE BOLUS VALUES FOR THIS DRUG. IN THAT CASE, SET ITS TIME TO -99.
C  OTHERWISE, SET ITS TIME TO THE NEXT TIME IN THE ARRAY.

	 IF(INDBOL(IDRUG) .GT. NTIMBOL(ISUB,IDRUG)) TIMEB = -99.D0

	 IF(INDBOL(IDRUG) .LE. NTIMBOL(ISUB,IDRUG)) THEN
	  TIMEB = TIMBOL(ISUB,IDRUG,INDBOL(IDRUG))
	 ENDIF

	 CALL THESAME(TIME,TIMEB,ISAME)


C  IF ISAME RETURNS FROM SUBROUTINE THESAME AS 1, THE TIMES ARE THE
C  "SAME" (I.E., WITHIN 1.D-10). IN THIS CASE, SET THE BOLUS VALUE FOR
C  THIS EVENT TO THE CORRESPONDING VALUE IN BOLUS, AND INCREASE THE
C  INDEX OF THE NEXT TIME BY 1. IF ISAME RETURNS AS 0, SET THE BOLUS
C  VALUE = 0.

	  IF(ISAME .EQ. 0) BOLVAL(IDRUG) = 0.D0

	  IF(ISAME .EQ. 1) THEN
	   BOLVAL(IDRUG) = BOLUS(ISUB,IDRUG,INDBOL(IDRUG))
	   INDBOL(IDRUG) = INDBOL(IDRUG) + 1
	  ENDIF

	 END DO


C  CHECK TO SEE IF ANY COVARIATE TIMES = TIME.

	DO ICOV = 1,NCOVA

C  IF THE CURRENT INDEX FOR THIS COVARIATE IS MORE THAN THE NO.
C  OF ENTRIES IN THE CORRESPONDING ARRAY, IT MEANS THAT THERE ARE NO
C  MORE COV VALUES FOR THIS COVARIATE. IN THAT CASE, SET ITS TIME TO
C  -99. OTHERWISE, SET ITS TIME TO THE NEXT TIME IN THE ARRAY.

	 IF(INDCOV(ICOV) .GT. NTIMCOV(ISUB,ICOV)) TIMEC = -99.D0

	 IF(INDCOV(ICOV) .LE. NTIMCOV(ISUB,ICOV)) THEN
	  TIMEC = TIMCOV(ISUB,ICOV,INDCOV(ICOV))
	 ENDIF

	 CALL THESAME(TIME,TIMEC,ISAME)


C  IF ISAME RETURNS FROM SUBROUTINE THESAME AS 1, THE TIMES ARE THE
C  "SAME" (I.E., WITHIN 1.D-10). IN THIS CASE, SET THE COVARIATE VALUE
C  FOR THIS EVENT TO THE CORRESPONDING VALUE IN COV, AND INCREASE THE
C  INDEX OF THE NEXT TIME BY 1.

        IF(ISAME .EQ. 1) THEN
         COVVAL(ICOV) = COV(ISUB,ICOV,INDCOV(ICOV))	   
         INDCOV(ICOV) = INDCOV(ICOV) + 1
        ENDIF


C  IF ISAME RETURNS AS 0, THE COV. VALUE WILL BE THE SAME AS IT WAS
C  PREVIOUSLY IF ICOVTYPE(ICOV) = 1 OR 0 (I.E., IF THIS IS A PIECEWISE
C  CONTINOUS COVARIATE). IT WILL ALSO BE THE SAME AS IT WAS PREVIOUSLY
C  IF ICOVTYPE(ICOV) = 2 (I.E., FOR A LINEARLY INTERPOLATED COVARIATE)
C  IF TIMEC = -99, OR IF ISAMERESET = 1. HERE IS WHY:

C  TIMEC = -99 --> THERE ARE NO MORE COVARIATE VALUES (SEE ABOVE).
C  IF ISAMERESET = 1, THEN THIS IS A TIME RESET POINT. AND IN THIS CASE,
C  EVEN AN INTERPOLATED COVARIATE VALUE SHOULD BE SET = ITS LAST VALUE
C  FROM BEFORE THE RESET, SINCE NO INTERPOLATION IS POSSIBLE FOR OUT OF
C  ORDER TIMES (E.G., (T,COV) = (24,400), FOLLOWED BY (T,COV) =
C  (20,1000) --> INTERPOLATED VALUE AT 0 WOULD BE:
C  (0-24)/(20-24) * (1000 - 400) + 400 = 4000, WHICH IS PREPOSTEROUS).


	IF(ISAME .EQ. 0) THEN

C  SET INTERP = 1, WHICH MEANS THAT THIS COVARIATE VALUE SHOULD BE
C  INTERPOLATED FROM THE TWO SURROUNDING COVARIATE VALUES (WHICH HAVE
C  BEEN EXPLICITLY SPECIFIED IN THE BLOCK FORMAT FILE). CHANGE INTERP
C  TO 0 IF THIS IS NOT AN INTERPOLATED COVARIATE (ICOVTYPE(ICOV) = 1
C  OR 0) OR IF THIS IS AN INTERPOLATED COVARIATE BUT THERE ARE NO MORE
C  COVARIATE VALUES FOR THIS COVARIATE (TIMEC = -99) OR IF THIS IS A
C  TIME RESET VALUE (ISAMERESET = 1), OR IF THE CURRENT COVARIATE TIME
C  (WHICH WOULD BE USED IN THE INTERPOLATION) IS AT OR PAST THE NEXT
C  TIME RESET.


	 INTERP = 1
	 IF(ICOVTYPE(ICOV) .EQ. 1 .OR. ICOVTYPE(ICOV) .EQ. 0)
     1    INTERP = 0
	 IF(TIMEC .LE. -99) INTERP = 0
	 IF(ISAMERESET .EQ. 1) INTERP = 0
	 IF(TIMEC .GE. TIMERESET + TIMADD) INTERP = 0


C  IF INTERP = 1:

C  NOTE THAT INDCOV(ICOV) MUST BE .GE. 2 UNLESS THE USER HAS MADE A
C  MISTAKE SINCE THE FIRST TIME (TIME = 0) IS SUPPOSED TO HAVE ALL
C  COVARIATE VALUES SPECIFIED, WHICH MEANS THE FIRST TIME THROUGH THIS
C  PART OF THE CODE ABOVE, INDCOV(ICOV) WAS INCREASED BY 1 (FROM ITS
C  ORIGINAL VALUE OF 1). IF THIS IS NOT TRUE, WRITE A MESSAGE TO THE
C  USER AND STOP.


	 IF(INDCOV(ICOV) .EQ. 1) THEN



	  WRITE(*,111) ICOV
  111     FORMAT(/' THERE IS A MISTAKE IN THE BLOCK FORMAT PATIENT'/
     1' DATA FILE. THE FIRST VALUE FOR COVARIATE NO. ',I2,' WAS NOT'/
     2' SPECIFIED AT THE ORIGINAL TIME = 0, AS IS REQUIRED. PLEASE'/
     3' FIX THIS ERROR AND RERUN THE PROGRAM. '//)
	  WRITE(*,401) ISUB,SUBID
  401     FORMAT(/' NOTE: THE ID FOR SUBJECT NO. ',I4,' IS ',A11/)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,111) ICOV
         WRITE(42,401) ISUB,SUBID
        CLOSE(42)	



	  CALL PAUSE
	  STOP



	 ENDIF


	 CLAST = COV(ISUB,ICOV,INDCOV(ICOV)-1)

	 IF(INTERP .EQ. 0) COVVAL(ICOV) = CLAST

	 IF(INTERP .EQ. 1) THEN

C  NOTE: THE LAST COV. VALUE WAS CLAST WHICH OCCURRED AT TLAST. THE NEXT

C  COV VALUE IS CNEXT WHICH OCCURS AT TNEXT. SO ESTABLISH THE
C  LINEARLY INTERPOLATED VALUE FOR THIS TIME, TIME. NOTE THAT THE TIMES,
C  TLAST AND TNEXT, MUST BE RECAST AS THEIR ACTUAL TIMES (BY REDUCING
C  THEM BY TIMERESET) FIRST.

	  TLAST = TIMCOV(ISUB,ICOV,INDCOV(ICOV)-1) - TIMERESET
	  CNEXT = COV(ISUB,ICOV,INDCOV(ICOV))
	  TNEXT = TIMCOV(ISUB,ICOV,INDCOV(ICOV)) - TIMERESET
	  TIMEREAL = TIME - TIMERESET
	  COVVAL(ICOV) = (TIMEREAL-TLAST)/(TNEXT-TLAST) * (CNEXT-CLAST)
     1     + CLAST
	 ENDIF

	ENDIF


C  THE ABOVE ENDIF IS FOR THE  IF(ISAME .EQ. 0)  CONDITION.




	 END DO

C  THE ABOVE END DO IS FOR THE  DO ICOV = 1,NCOVA  LOOP.



C  CHECK TO SEE IF ANY IV TIMES = TIME.

	DO IDRUG = 1,NDRUG

C  IF THE CURRENT INDEX FOR THIS IV IS MORE THAN THE NO.
C  OF ENTRIES IN THE CORRESPONDING ARRAY, IT MEANS THAT THERE ARE NO
C  MORE IV VALUES FOR THIS DRUG. IN THAT CASE, SET ITS TIME TO -99.
C  OTHERWISE, SET ITS TIME TO THE NEXT TIME IN THE ARRAY.

	 IF(INDIV(IDRUG) .GT. NTIMIV(ISUB,IDRUG)) TIMEI = -99.D0

	 IF(INDIV(IDRUG) .LE. NTIMIV(ISUB,IDRUG)) THEN
	  TIMEI = TIMIV(ISUB,IDRUG,INDIV(IDRUG))
	 ENDIF


	 CALL THESAME(TIME,TIMEI,ISAME)

C  IF ISAME RETURNS FROM SUBROUTINE THESAME AS 1, THE TIMES ARE THE

C  "SAME" (I.E., WITHIN 1.D-10). IN THIS CASE, SET THE IV VALUE FOR
C  THIS EVENT TO THE CORRESPONDING VALUE IN RATEIV, AND INCREASE THE
C  INDEX OF THE NEXT TIME BY 1. IF ISAME RETURNS AS 0, THE IV VALUE
C  WILL REMAIN WHAT IT WAS PREVIOUSLY.

	  IF(ISAME .EQ. 1) THEN
	   XIVVAL(IDRUG) = RATEIV(ISUB,IDRUG,INDIV(IDRUG))
	   INDIV(IDRUG) = INDIV(IDRUG) + 1
	  ENDIF

	 END DO


C  PUT THE ACTUAL TIME (I.E., TIME - TIMERESET) INTO THE 1ST ENTRY FOR
C  THIS ROW. THEN PUT IN THE IV/BOLUS VALUES FOR EACH OF THE NDRUG DRUGS
C  IN ORDER; THEN ALL ADDITIONAL COV. VALUES.

	 DOSELINE(ITIM,1) = TIME - TIMERESET
	 NENTRY = 1

	 DO IDRUG = 1,NDRUG
	  NENTRY = NENTRY+1
	  DOSELINE(ITIM,NENTRY) = XIVVAL(IDRUG)
	  NENTRY = NENTRY+1

	  DOSELINE(ITIM,NENTRY) = BOLVAL(IDRUG)
	 END DO

	 DO ICOV = 1,NCOVA
	  NENTRY = NENTRY+1
	  DOSELINE(ITIM,NENTRY) = COVVAL(ICOV)
	 END DO

       WRITE(33,1) (DOSELINE(ITIM,J),J=1,NENTRY)
    1  FORMAT(43(G19.9,1X))

 1000   CONTINUE

C  THE ABOVE LABEL IS THE END OF THE  DO 1000 ITIM = 1,NTIMI  LOOP.

C  NOW CHECK TO SEE IF THE DOSAGE REGIMEN ENDS WITH ONE OR MORE STEADY
C  STATE EVENTS. NOTE THAT THERE ARE NSST(ISUB) STEADY STATE EVENTS,
C  AND NSSEVENTS - 1 OF THESE HAVE BEEN WRITTEN TO THE WORKING COPY FILE
C  SO FAR. 

 1010   CONTINUE

        IF(NSSEVENTS .LE. NSST(ISUB)) THEN



C  THE NEXT STEADY STATE DOSE EVENT OCCURS AFTER RESET NO.
C  DOSELINEST(ISUB,NSSEVENTS,100). 

C  FILL IN THE ENTRIES TO DOSELINE FOR THE STEADY STATE DOSE AT THE
C  BEGINNING OF THIS DOSE RESET.

C  THE FIRST ENTRY IN DOSELINST IS TIMEVENT = THE NEGATIVE OF THE
C  INTERDOSE INTERVAL.

          DOSELINES(1) = DOSELINEST(ISUB,NSSEVENTS,1)
          NENTRY = 1

C  FOR EACH DRUG, THE IV AND TOTAL VALUES ARE ALREADY STORED INTO
C  DOSELINEST(ISUB,NSSEVENTS,2*I) AND DOSELINEST(ISUB,NSSEVENTS,2*I+1),
C  I=1,NDRUG.

          DO IDRUG = 1,NDRUG
           NENTRY = NENTRY+1
           DOSELINES(NENTRY) = DOSELINEST(ISUB,NSSEVENTS,2*IDRUG)


           NENTRY = NENTRY+1
           DOSELINES(NENTRY) = DOSELINEST(ISUB,NSSEVENTS,2*IDRUG+1)
          END DO

C  FOR EACH COVARIATE, IF ANY, THE VALUES ARE STORED INTO
C  DOSELINEST(ISUB,NSSEVENTS,19+ICOV), ICOV = 1,NCOVA.

          IF(NCOVA .GT. 0) THEN
           DO ICOV = 1,NCOVA
            NENTRY = NENTRY+1
            DOSELINES(NENTRY) = DOSELINEST(ISUB,NSSEVENTS,19+ICOV)

           END DO
          ENDIF

          WRITE(33,1) (DOSELINES(J),J=1,NENTRY)

          NSSEVENTS = NSSEVENTS + 1
 
          GO TO 1010

        ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(NSSEVENTS .LE. NSST(ISUB))  CONDITION.



C----------------- WRITE THE DOSE EVENTS ABOVE -------------------------


C----------------- WRITE THE OBSERVATION EVENTS BELOW ------------------


	WRITE(33,106) NOUT
  106   FORMAT(/'     ',I1,' ... NO. OF TOTAL OUTPUT EQUATIONS')


C  EACH SET OF TIMES FOR EACH OUTPUT EQUATION, TIMOUT(ISUB,IOUT,I),
C  I = 1,NTIMOUT(ISUB,IOUT), IS IN ORDER, BUT EACH TIME HAS ADDED
C  TO IT TIMADD*NRESET, WHERE NRESET IS THE NO. OF TIME RESETS UP TO
C  AND TIME.

C  CALL FIXOUTIM TO OBTAIN NTIMORD, TIMORD, AND BLOCKOUT, WHERE
C  NTIMORD IS THE TOTAL NO. OF UNIQUE TIMES TO BE PUT INTO THE
C  OBSERVATION BLOCK; TIMORD(.) IS THE ORDERED ACTUAL TIMES (I.E., EACH
C  OF THE TIMES IN TIMOUT(.,.,.) HAS BEEN REDUCED BY TIMADD*NRESET - SEE
C  ABOVE), EXCEPT THAT EACH TIME OF 0 IS NOT ORDERED (IT INDICATES THE
C  NEXT TIME RESET) FOR THE OBSERVATION BLOCK; AND BLOCKOUT IS THE
C  CORRESPONDING ARRAY OF OBSERVED VALUES FOR THE NOUT OUTPUT EQUATIONS

C  AT THE TIMES IN TIMORD.



	CALL FIXOUTIM(MAXSUB,ISUB,SUBID,NOUT,NTIMOUT,TIMOUT,OUT,NTIMORD,
     1   TIMORD,BLOCKOUT,TIMADD,MAXNUMEQ)


      	WRITE(33,62) NTIMORD

   62   FORMAT('   ',I3,' ... NO. OF OBSERVED VALUE TIMES')

	DO I = 1,NTIMORD
	 WRITE(33,63) TIMORD(I),(BLOCKOUT(I,J),J=1,NOUT)
   63    FORMAT(7(G16.8,1X))
	END DO


C----------------- WRITE THE OBSERVATION EVENTS ABOVE ------------------


C----------------- WRITE THE BOTTOM OF FILE BELOW ----------------------

	WRITE(33,303)
  303   FORMAT(/' COVARIATE NAMES AND VALUES (1ST, LAST, AND MEAN) FOLLO

     1W:')

C  FOR NOW, THE MEAN VALUE OF EACH COV. WILL BE -99 ... UNTIL WE DECIDE
C  WHAT KIND OF MEAN WE WANT. E.G., IF A COV. = 100 AT T=0 AND
C  200 AT T = 10 AND 300 AT T = 11, WHICH IS THE LAST TIME, DO WE
C  SIMPLY AVERAGE 100,200, AND 300, OR DO WE TAKE A WEIGHTED MEAN
C  WHICH WOULD BE (100*10 + 200*1 + 300*0)/11, OR SOMETHING ELSE???

	XMEAN = -99
	DO ICOV = 1,NCOVA
   	 WRITE(33,304) COVNAME(ICOV),COV(ISUB,ICOV,1),
     1    COV(ISUB,ICOV,NTIMCOV(ISUB,ICOV)),XMEAN
	END DO
  304   FORMAT(A11,3X,3(F15.5,1X))

	WRITE(33,306)
  306   FORMAT(/'ASSAY COEFFICIENTS FOLLOW, ONE SET FOR EACH OUTPUT EQUA
     1TION:')

        DO K = 1,NOUT
         WRITE(33,3061) (CSUB(ISUB,I,K),I=1,6)
         write(*,*) (CSUB(ISUB,I,K),I=1,6)
        END DO

 3061   FORMAT(F12.6,1X,F12.6,1X,F12.6,1X,F12.6,1X,F12.6,1X,F12.6)
C 3061   FORMAT(4(F17.8,1X),' 0.0 0.0')
        write (33,*) 'I am wondering if this is the correct file'
        write (*,*) 'I am wondering if this is the correct file'

C----------------- WRITE THE BOTTOM OF FILE ABOVE ----------------------

	CLOSE(33)


	RETURN
	END

C

CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
	SUBROUTINE THESAME(X1,X2,ISAME)
	IMPLICIT REAL*8(A-H,O-Z)

C  THIS ROUTINE CHECKS TO SEE IF X1 AND X2 ARE VIRTUALLY THE SAME
C  VALUES (I.E., IF THEY ARE WITHIN 1.D-10 OF EACH OTHER). IF SO,
C  ISAME RETURNS AS 1; IF NOT ISAME RETURNS AS 0.

	ISAME = 0
	XDEL = DABS(X1-X2)
	IF(XDEL .LE. 1.D-10) ISAME = 1

	RETURN
	END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
	SUBROUTINE GETID(SUBID)
	CHARACTER SUBID*11,SUB*11

C  THIS ROUTINE IS CALLED TO REPLACE SUBID (WHICH HAS 11 CHARACTERS IN
C  IT) WITH THE CHARACTERS UP TO BUT NOT INCLUDING THE 1ST COMMA.

	SUB = '           '
	DO I = 1,11
	 IF(SUBID(I:I) .NE. ',') SUB(I:I) = SUBID(I:I)
	 IF(SUBID(I:I) .EQ. ',') GO TO 10
	END DO

   10   SUBID = SUB

	RETURN
	END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
	SUBROUTINE TIMESET(MAXSUB,ISUB,SUBID,NTIMALL,TIMALL,NTIMI,
     1    TIMI)

	IMPLICIT REAL*8(A-H,O-Z)
	DIMENSION TIMALL(MAXSUB,5000),NTIMALL(MAXSUB),TIMI(5000),
     1   TIM(5000)

	CHARACTER SUBID*11


C  THIS ROUTINE IS CALLED BY READBLOCK, TO ORDER ALL THE NTIMALL(ISUB)
C  TIMES IN TIMALL(ISUB,.), ELIMINATING DUPLICATE TIMES.

C  RETURNED TO READBLOCK IS THE VECTOR TIMI, WITH NTIMI TIMES,
C  ESTABLISHED AS INDICATED ABOVE.



C  THE FIRST TIME IS TIMALL(ISUB,1) AND SHOULD BE 0. CHECK THIS FIRST.

	CALL THESAME(TIMALL(ISUB,1),0.D0,ISAME)

C  IF ISAME RETURNS FROM SUBROUTINE THESAME AS 1, THE TIMES ARE THE
C  "SAME" (I.E., WITHIN 1.D-10). OTHERWISE, THE TIMES ARE NOT THE

C  SAME AND ISAME = 0.

C  STARTING WITH IT2B103.FOR, DO NOT CHECK THAT THE FIRST DOSE TIME IN
C  EACH PATIENT IS 0, SINCE THE FIRST TIME MAY BE NEGATIVE (WHICH 
C  SIGNIFIES THE DOSAGE REGIMEN BEGINS WITH A STEADY STATE OF DOSES).
    

C	IF(ISAME .EQ. 0) THEN
C	 WRITE(*,1) ISUB,TIMALL(ISUB,1)
C    1    FORMAT(/' THE FIRST TIME IN THE DOSAGE BLOCK FOR SUBJECT ',I5,
C     1' IS NOT 0; IT IS ',G14.5//

C     2' THIS IS NOT ALLOWED. PLEASE SET THE FIRST TIME IN THE DOSAGE'/
C     3' BLOCKS FOR ALL SUBJECTS TO BE 0, AND RERUN THE PROGRAM.')
C	 WRITE(*,401) ISUB,SUBID
C  401    FORMAT(/' NOTE: THE ID FOR SUBJECT NO. ',I4,' IS ',A11/)
C	 CALL PAUSE
C	 STOP
C	ENDIF



C  CALL SUBROUTINE PUTORDER TO ORDER THE NTIMALL(ISUB) VALUES IN
C  TIMALL(ISUB,.).

	DO I = 1,NTIMALL(ISUB)
	 TIM(I) = TIMALL(ISUB,I)
	END DO

	CALL PUTORDER(NTIMALL(ISUB),TIM)

C  THE NTIMALL(ISUB) VALUES ARE NOW ORDERED IN TIM.

C  THE CODE BELOW BELOW WILL REMOVE DUPLICATE TIMES.

	TIMELAST = -1.D39

	NTIMI = 0

	DO I = 1,NTIMALL(ISUB)

	 TIME = TIM(I)
	 CALL THESAME(TIME,TIMELAST,ISAME)

C  IF ISAME RETURNS FROM SUBROUTINE THESAME AS 1, TIME = TIMELAST (OR AT

C  LEAST, THEY ARE WITHIN 1.D-10), AND THIS TIME CAN BE IGNORED SINCE IT
C  WAS ALREADY PUT INTO TIMI (ACTUALLY THE VALUE REDUCED BY TIMERESET)
C  BY A PREVIOUS TIME.

	 IF(ISAME .EQ. 1) GO TO 30

C  TO GET HERE, ISAME = 0, WHICH MEANS THIS IS A NEW TIME. SO PUT
C  TIME INTO TIMI. THEN SET TIMELAST = TIME AND CONTINUE THE LOOP.

	  NTIMI = NTIMI + 1
	  TIMI(NTIMI) = TIME
	  TIMELAST = TIME

   30    CONTINUE

	END DO


	RETURN
	END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
	SUBROUTINE PUTORDER(NX,XX)

C  SUBROUTINE PUTORDER IS CALLED BY SUBROUTINE TIMESET. IT INPUTS XX, A

C  VECTOR OF SIZE, NX, AND RETURNS RETURNS XX, BUT WITH THE VALUES
C  ORDERED FROM LOW TO HIGH.

	IMPLICIT REAL*8(A-H,O-Z)
	DIMENSION XX(5000),Y(5000),IZ(5000),IZZ(5000)

C  ORDER THE NX VALUES IN X AS FOLLOWS:

C  PUT THE NX VALUES INTO VECTOR Y TO START.
C  INITIALIZE VECTOR IZ TO BE -99 IN ALL ITS NX LOCATIONS. THEN, FOR
C  EXAMPLE, IF ENTRY 17 IS THE SMALLEST VALUE IN Y, IZ(17) WILL BE
C  SET = 0, AND THE PROGRAM WILL KNOW NOT TO CHECK THE 17TH ENTRY

C  AGAIN (SINCE IT HAS ALREADY BEEN SELECTED). IF THE NEXT SMALLEST
C  ENTRY HAS INDEX 37, THEN IZ(37) WILL BE SET = 0, ETC.

C  NOTE THAT IZZ WILL BE THE ARRAY WHICH CONTAINS THE ACTUAL ORDERING.
C  IN THE EXAMPLE ABOVE, IZZ(1) = 17, IZZ(2) = 37. IT WILL BE EASY TO

C  ASSIGN ORDERED VALUES BACK INTO XX USING IZZ. IN THE EXAMPLE ABOVE,
C  XX(1) = Y(IZZ(1)) = Y(17), XX(2) = Y(IZZ(2)) = Y(37), ETC.

	 DO I=1,NX
	  Y(I) = XX(I)
	  IZ(I) = -99
	 END DO


	 DO IPLACE = 1,NX

C  PUT THE NEXT LOWEST VALUE OF Y INTO THE IPLACE LOCATION OF
C  IZZ.

C  TEMP IS THE RUNNING VALUE OF THE NEXT VALUE TO BE PLACED INTO Y.
C  INITIALIZE IT TO BE VERY HIGH VALUE SO THE FIRST VALUE Y WILL BE
C  SURE TO BE LOWER THAN IT IS.

	  TEMP = 1.D50

	  DO I=1,NX
	   IF(Y(I) .LT. TEMP .AND. IZ(I) .EQ. -99) THEN
	    TEMP = Y(I)
	    IND = I
	   ENDIF
	  END DO

C  AT THIS POINT, IND IS THE INDEX OF THE SMALLEST REMAINING VALUE
C  (TEMP) IN Y. PUT THIS INFORMATION INTO IZZ. ALSO,
C  SET IZ(IND) = 0 --> THE IND LOCATION IN Y HAS BEEN USED.

	  IZZ(IPLACE) = IND
	  IZ(IND) = 0

	 END DO

C  AT THIS POINT IZZ CONTAINS THE ORDERED INDICES (LOW TO HIGH) OF Y.
C  USE THIS TO RE-ESTABLISH X TO BE ORDERED LOW TO HIGH.

	 DO I = 1,NX
	  XX(I) = Y(IZZ(I))
	 END DO



	RETURN
	END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
	SUBROUTINE FIXOUTIM(MAXSUB,ISUB,SUBID,NOUT,NTIMOUT,TIMOUT,OUT,
     1   NTIMORD,TIMORD,BLOCKOUT,TIMADD,MAXNUMEQ)

	IMPLICIT REAL*8(A-H,O-Z)

	DIMENSION TIMOUT(MAXSUB,MAXNUMEQ,650),NTIMOUT(MAXSUB,MAXNUMEQ),
     1 IENTRY(MAXNUMEQ),OUT(MAXSUB,MAXNUMEQ,650),TIMORD(3900),
     2 BLOCKOUT(3900,MAXNUMEQ)

	CHARACTER SUBID*11,ERRFIL*20

      COMMON/ERROR/ERRFIL
C  COMMON/ERROR/ IS SUPPLIED TO ALL THE ROUTINES WHICH COULD WRITE TO
C  ERRFIL. 



C  FIXOUTIM IS CALLED BY WRITEDOS TO ORDER THE OUTPUT TIMES AMONG ALL
C  THE NOUT OUTPUT EQUATIONS. NOTE THAT EACH OF THE TIMES CURRENTLY IN
C  TIMOUT HAS BEEN INCREASE BY TIMERESET = TIMADD*NRESET, WHERE NRESET
C  IS THE NO. OF TIME RESETS UP TO AND INCLUDING THAT TIME (THIS WAS
C  DONE IN SUBROUTINE READBLOCK).



C  RETURNED TO SUBROUTINE WRITEDOS ARE:

C  NTIMORD = NO. OF TIME VALUES IN TIMORD.

C  TIMORD(I), I=1,NTIMORD = THE ORDERED SET OF TIMES (EXCEPT FOR 0'S
C   WHICH INDICATE A TIME RESET) OVER ALL THE NOUT TIME ARRAYS.


C  BLOCKOUT(I,J) = OBSERVED VALUE FOR IOUTPUT EQUATION J, FOR THE TIME
C   VALUE, TIMORD(I), I=1,NEXT; J = I,NOUT.


C  NOTE THAT EACH OF THE TIME ARRAYS, TIMOUT(ISUB,IOUT,.) HAS ITS OWN
C  VALUES IN ORDER (THEY WERE FILLED IN ORDER IN READBLOCK). NOW,
C  ESTABLISH THE ARRAY, TIMORD, WHICH HAS THE ORDERED SET OF
C  TIMES OVER ALL THE NOUT TIME ARRAYS. ALSO, REDUCE EACH TIME BY
C  TIMRESET = NRESET*TIMADD TO RETURN EACH TIME TO ITS ORIGINAL VALUE.
C  NOTE THAT THIS WILL HAVE THE EFFECT OF SETTING TO 0 THE TIMES WHICH
C  ARE THE TIME RESET POINTS (THEIR ACCOMPANYING OUTPUT VALUES WILL
C  OF COURSE BE SET TO -99).

C  INITIALIZE THE NEXT TIME TO BE PUT INTO TIMORD TO BE A LARGE NO.
C  AND INITIALIZE THE INDEX OF THE NEXT ENTRY IN EACH OF THE TIMOUT
C  ARRAYS TO BE 1. ALSO INITIALIZE INEXT TO BE 1. IT WILL BE THE
C  RUNNING INDEX OF THE NEXT ENTRY TO BE PUT INTO TIMORD.



	DO IOUT = 1,NOUT

	 IENTRY(IOUT) = 1
	END DO

	INEXT = 1

   20	TIMENEXT = 1.D50


C  SET IANOTHER = 0. IF IT STAYS 0, THERE ARE NO MORE TIMES IN
C  ANY OF THE ARRAYS.

	 IANOTHER = 0


        DO IOUT	= 1,NOUT

C  FOR OUTPUT EQUATION IOUT, IF IENTRY(IOUT) .LE. THE NO. OF ENTRIES
C  IN THE TIME ARRAY FOR IOUT, THEN THIS ENTRY IS EQUATION IOUT'S
C  CANDIDATE FOR THE NEXT LOWEST TIME.

	 IF(IENTRY(IOUT) .LE. NTIMOUT(ISUB,IOUT)) THEN
	  IANOTHER = 1
	  IF(TIMOUT(ISUB,IOUT,IENTRY(IOUT)) .LE. TIMENEXT)
     1     TIMENEXT = TIMOUT(ISUB,IOUT,IENTRY(IOUT))
	 ENDIF

	END DO

C  IF IANOTHER = 0, ALL TIME ARRAY, AND CORRESPONDING OBSERVED, VALUES
C  HAVE BEEN STORED, SO GO TO 100 TO RECAST TIMORD BEFORE RETURNING.

	IF(IANOTHER .EQ. 0) GO TO 100



C  AT THIS POINT, TIMENEXT IS THE NEXT LOWEST TIME OVER ALL THE NOUT
C  TIMOUT ARRAYS. PUT IT INTO TIMORD, AND PUT THE CORRESPONDING ENTRIES
C  FOR EACH OF THE NOUT OUTPUT EQUATIONS INTO THE ARRAY BLOCKOUT. ALSO,
C  INCREASE THE ENTRY NO. FOR THE TIME ARRAY(S) WHICH HAD THIS TIME.
C  BUT CHECK THAT THE NO. OF ENTRIES INTO TIMORD IS NOT > THE MAX, 3900.
C  IF IT IS, STOP.


	IF(INEXT .GT. 3900) THEN

	 WRITE(*,1)
    1    FORMAT(/' THE TOTAL NO. OF OBSERVATION TIMES IS GREATER THAN'/
     1' THE MAXIMUM ALLOWABLE VALUE OF 3900 (SUBROUTINE FIXOUTIM).'/
     2' RERUN THE PROGRAM AFTER REDUCING THE NO. OF OBS. TIMES.'/)
	 WRITE(*,401) ISUB,SUBID
  401    FORMAT(/' NOTE: THE ID FOR SUBJECT NO. ',I4,' IS ',A11/)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,1) 
         WRITE(42,401) ISUB,SUBID
        CLOSE(42)	



	 CALL PAUSE
	 STOP

	ENDIF


	TIMORD(INEXT) = TIMENEXT

        DO IOUT	= 1,NOUT

	  BLOCKOUT(INEXT,IOUT) = -99.D0
	  CALL THESAME(TIMENEXT,TIMOUT(ISUB,IOUT,IENTRY(IOUT)),ISAME)

	  IF(ISAME .EQ. 1) THEN
	   BLOCKOUT(INEXT,IOUT) = OUT(ISUB,IOUT,IENTRY(IOUT))
	   IENTRY(IOUT) = IENTRY(IOUT) + 1
	  ENDIF

	END DO


	INEXT = INEXT + 1

	GO TO 20


  100   NTIMORD = INEXT - 1


C  NOW, RECAST TIMORD TO BE THE CORRECT TIME VALUES. RECALL THAT,
C  CURRENTLY, EACH TIME HAS NRESET*TIMADD ADDED TO ITS VALUE WHERE
C  NRESET IS THE NO. OF TIME RESET 0'S UP TO AND INCLUDING THAT TIME
C  VALUE.

C  INITIALIZE NRESET = 0. THIS IS THE RUNNING NUMBER OF TIME RESETS
C  THAT HAVE OCCURED. ALSO INITIALIZE TIMERESET AS THE CURRENT AMOUNT
C  OF TIME TO SUBTRACT TO DO THE RECASTING.

	NRESET = 0
	TIMERESET = TIMADD*NRESET

	DO I = 1,NTIMORD
	 CALL THESAME(TIMORD(I),TIMADD*(NRESET+1),ISAME)

	 IF(ISAME .EQ. 1) THEN
	  NRESET = NRESET + 1
	  TIMERESET = TIMADD*NRESET
	 ENDIF


	 TIMORD(I) = TIMORD(I) - TIMERESET
	END DO


	RETURN

	END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
	SUBROUTINE GETMAXTIM(NCOVA,TIMAX)

	IMPLICIT REAL*8(A-H,O-Z)
	CHARACTER READLINE*1000

C  THIS SUBROUTINE IS CALLED BY READBLOCK TO GET TIMAX, THE MAXIMUM TIME
C  OVER ALL SUBJECTS IN FILE 66. THIS MAXIMUM TIME INCLUDES THE ENDING
C  TIME FOR ALL IV RATES.

C  GO THROUGH ALL THE ROWS OF THE BLOCK FORMAT FILE. READ THE EVENT
C  TIMES IN ENTRY 3. IF THE ROW IS AN IV ROW, ADD THIS VALUE TO THE
C  DURATION TIME IN ENTRY 4. THEN UPDATE TIMAX IF THIS TOTAL TIME IS
C  > TIMAX, WHICH IS INITIALIZED BELOW TO BE NEGATIVE.

C  AS OF IT2B108.FOR, WRITE TO THE SCREEN INFO ABOUT THE 
C  MAXIMUM TIME SO FAR IN CASE THERE ARE A LARGE NO. OF PATIENTS
C  WITH A LOT OF DATA. OTHERWISE, THERE COULD BE A LONG "DEAD" TIME ON
C  THE SCREEN MAKING THE PROGRAM LOOK LIKE IT HAS "HUNG".

      WRITE(*,103) 
  103 FORMAT(' FINDING THE MAXIMUM TIME OVER ALL SUBJECTS ... '/)

	TIMAX = -1.D0

   10   READ(66,1,IOSTAT=IEND) READLINE
    1   FORMAT(A1000)
	IF(IEND .LT. 0) RETURN
	IF(READLINE(1:1) .EQ. '#' .OR. READLINE(1:2) .EQ. '"#') GO TO 10

	 CALL AFTERCOMMA(NCOVA,READLINE,2)
	 BACKSPACE(57)
	 READ(57,*) TIMEVENT
	 CLOSE(57)

	 CALL AFTERCOMMA(NCOVA,READLINE,3)
	 BACKSPACE(57)
	 READ(57,*,ERR=15) TIMDUR
	 GO TO 20
   15  TIMDUR = 0.D0
   20  TIME = TIMEVENT + TIMDUR
	 CLOSE(57)


	 IF(TIMAX .LT. TIME) TIMAX = TIME

C  AS OF IT2B108.FOR (SEE ABOVE), WRITE OUT THE TIME TO THE SCREEN.
      WRITE(*,104) TIME,TIMAX
  104 FORMAT(' TIME AND MAX TIME ARE: ',2(G20.10,2X))

	 GO TO 10


	END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
	SUBROUTINE GETCOVR2(NCOV,DESCR)
	IMPLICIT REAL*8(A-H,O-Z)
	CHARACTER READLINE*1000,DESCR(26)*20


C  THIS ROUTINE IS CALLED BY SUBROUTINE PREVRUN TO OBTAIN, FROM FILE
C  27, THE NO. OF COVARIATES (NCOV), AND THEIR NAMES(DESCR(I),I=1,NCOV).

    2   FORMAT(A20)
   33   FORMAT(A1000)

	REWIND(27)


C  VERIFY THAT THE FIRST PATIENT DATA FILE IN FILE 27 (WHICH IS THE
C  CONCATENATED PATIENT DATA FILE) IS A 'CURRENT' TYPE WORKING COPY-LIKE
C  FILE (I.E., CREATED BY CONVRTI.FOR OR LATER VERSION). IF NOT, IT
C  DOESN'T HAVE ANY EXTRA COVARIATE INFO, OR EVEN AGE, SEX, HEIGHT,
C  ETHNICITY FLAG, AND SO IT IS A WASTE TO USE THIS PROGRAM WITH ITS
C  EXPANDED MENU ON FILES WHICH (BECAUSE THEY HAVE NO EXTRA
C  COVARIATES/DESCRIPTORS) CAN'T POSSIBLY TAKE ADVANTAGE OF IT.

C  AS OF NPBIG11.FOR, THE WORKING COPY FILES REQUIRED ARE THE NEWEST
C  TYPE (FROM THE NEW BOXES PROGRAM BY ANDREAS). BUT THE PROGRAM WOULD
C  NOT HAVE GOTTEN TO THIS POINT (I.E., PAST SUBROUTINE STACK, CALLED
C  BY SUBROUTINE PREVRUN) IF THE FILES WERE NOT THE CORRECT TYPE. SO

C  NO CHECKING OF THE FILE FORMAT IS REQUIRED HERE.

C  THE NO. OF ADDITIONAL COVARIATES IS ON THE LINE HAVING
C  "NO. OF ADDITIONAL COVARIATES" STARTING IN ENTRY 12.

   10	READ(27,33) READLINE
	IF(READLINE(12:28) .NE. 'NO. OF ADDITIONAL') GO TO 10
	BACKSPACE(27)
    3   FORMAT(T2,I5)
        READ(27,3) NADD

C  THE TOTAL NO. OF COVARIATES WILL BE 4 + NADD, SINCE THERE WILL
C  ALWAYS BE THE STANDARD 4 COVARIATES (AGE, SEX, HEIGHT,
C  ETHNICITY FLAG), IN ADDITION TO THE EXTRA ONES.



	NCOV = 4 + NADD

C  READ THE 1ST NCOV - 4 COVARIATE NAMES FROM BELOW THE LINE HAVING
C  "COVARIATE NAMES" STARTING IN COLUMN 2. IF NCOV = 4, NO NAMES 
C  WILL BE READ.


   20	READ(27,33) READLINE
	IF(READLINE(2:16) .NE. 'COVARIATE NAMES') GO TO 20


        IF(NCOV .GT. 4) THEN


         DO J = 1,NCOV-4

          READ(27,33) READLINE

C  FOR THIS COVARIATE, ESTABLISH DESCR(J) AS THE PORTION OF THE
C  CURRENT READLINE UP TO THE  FIRST SPACE, WHICH WILL BE ASSUMED TO BE
C  THE END OF THE COV. NAME. IN CASE THERE IS A SPACE OR TWO AT THE
C  BEGINNING OF READLINE FOR SOME REASON, START CHECKING FOR SPACES AT
C  ENTRY 3.

          DO I = 3,20
           IF(READLINE(I:I) .EQ. ' ') GO TO 30
          END DO

   30     DESCR(J) = READLINE(1:I-1)

         END DO

        ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(NCOV .GT. 4)  CONDITION.


     	DESCR(NCOV-3) = 'AGE'
	DESCR(NCOV-2) = 'SEX'
	DESCR(NCOV-1) = 'HEIGHT'
	DESCR(NCOV) = 'ETHNICITY FLAG'

	REWIND(27)

	RETURN
	END


C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
	SUBROUTINE GETNSUB(NSUB)

C  THIS ROUTINE IS A VARIATION OF TEST38.FOR, WHICH READS AN INTEGER
C  ANYWHERE ON A GIVEN LINE WITH A PARTICULAR SET OF WORDS AT THE START
C  OF THAT LINE.

	CHARACTER READLINE*1000,ERRFIL*20

      COMMON/ERROR/ERRFIL
C  COMMON/ERROR/ IS SUPPLIED TO ALL THE ROUTINES WHICH COULD WRITE TO
C  ERRFIL. 


    2   FORMAT(A1000)

C  READ UNTIL THE LINE WHICH HAS THE WORDS "THE NO. OF SUBJECTS IS" ON
C  IT SOMEWHERE.

   10   READ(25,2) READLINE
	ILINE=0

	 DO I=1,51
	  IF(READLINE(I:I+21) .EQ. 'THE NO. OF SUBJECTS IS') THEN
	   ILINE=1
	   GO TO 20
	  ENDIF
	 END DO
   20   IF(ILINE .EQ. 0) GO TO 10

C  SOMEWHERE AFTER THE CHARACTERS IN ENTRIES I:I+21 IS THE INTEGER.
C  READ THE CHARACTERS FOR THIS INTEGER, AND THEN CONVERT IT TO

C  AN INTEGER VALUE. AFTER THE FOLLOWING LOOP, THESE CHARACTERS WILL BE
C  IN READLINE(ISTART:IEND).

	 IEND = 0
	 ISTART = 0
	  DO J = I+22, 72
	   IF(ISTART .EQ. 0 .AND. READLINE(J:J) .NE. ' ') ISTART = J
	   IF(ISTART .NE. 0 .AND. READLINE(J:J) .EQ. ' ') THEN
	    IEND = J-1

	    GO TO 30
	   ENDIF
	  END DO

C  CHECK TO MAKE SURE THAT THE NO. OF CHARACTERS READ IN FOR THE INTEGER
C  IS NOT MORE THAN 4 (I.E., 4 CHARACTERS ALLOW A MAXIMUM SIZE OF 9999
C  WHICH IS MORE THAN THE LARGEST VALUE THIS INTEGER CAN BE).

   30	ISIZE = IEND-ISTART

	IF(ISIZE .GT. 3) THEN



	 WRITE(*,*)' NSUB IS ',NSUB,' WHICH IS TOO LARGE. '
	 WRITE(*,*)' THE PROGRAM STOPS. '

        OPEN(42,FILE=ERRFIL)
        WRITE(42,*)' NSUB IS ',NSUB,' WHICH IS TOO LARGE. '
        WRITE(42,*)' THE PROGRAM STOPS. '
        CLOSE(42)



	 CALL PAUSE
	 STOP



	ENDIF

C  CONVERT AS INDICATED ABOVE.

	NSUB = 0
	 DO K=ISTART,IEND
	  IF(READLINE(K:K) .EQ. '0') IVAL = 0
	  IF(READLINE(K:K) .EQ. '1') IVAL = 1
	  IF(READLINE(K:K) .EQ. '2') IVAL = 2
	  IF(READLINE(K:K) .EQ. '3') IVAL = 3
	  IF(READLINE(K:K) .EQ. '4') IVAL = 4
	  IF(READLINE(K:K) .EQ. '5') IVAL = 5
	  IF(READLINE(K:K) .EQ. '6') IVAL = 6
	  IF(READLINE(K:K) .EQ. '7') IVAL = 7
	  IF(READLINE(K:K) .EQ. '8') IVAL = 8
	  IF(READLINE(K:K) .EQ. '9') IVAL = 9
	  NSUB = NSUB + IVAL*10**ISIZE
	  ISIZE = ISIZE-1
	 END DO


	RETURN
	END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
        SUBROUTINE PAUSE

C  THIS ROUTINE IS USED TO REPLACE A PAUSE STATEMENT, WHICH CAUSES
C  WARNINGS WHEN THIS PROGRAM IS COMPILED AND LINKED USING gfortran
C  (AND FORCES THE USER TO TYPE "go" INSTEAD OF SIMPLY HITTING THE
C  ENTER KEY).

        WRITE(*,1)
    1   FORMAT(' HIT ANY KEY TO CONTINUE: ')
        READ(*,*,ERR=10) IKEY
        IF(IKEY .EQ. 1) RETURN
   10   RETURN
        END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
        SUBROUTINE NEWCSV

C  NEWCSV IS CALLED BY MAIN TO CONVERT THE .CSV FILE IN FILE 77 TO
C  A NEW .CSV FILE IN FILE 67, WITH ALL MISSING VALUE DOTS CHANGED TO
C  n's. THIS CODE IS BASED ON THE STAND-A-LONE PROGRAM NEWCSV.FOR.

C  IN PARTICULAR, THE FOLLOWING SEQUENCES WILL BE REPLACED AS SHOWN:

C   ,.,  WILL BE REPLACED BY  ,n,
C   ,.   WILL BE REPLACED BY  ,n  <-- THIS OCCURS AT END OF LINES.

C  NOTE THAT THE SECOND SEQUENCE ABOVE IS COMMA/DOT/SPACE, NOT JUST
C  COMMA/DOT SINCE WE DON'T WANT ,.35  REPLACED BY ,n35, FOR EXAMPLE.

        IMPLICIT REAL*8(A-H,O-Z)

        CHARACTER READLINE*1000

C  WRITE EACH LINE OF FILE 77 TO FILE 67, BUT REPLACE ALL MISSING VALUE
C  DOTS WITH n's.

   10   READ(77,4,IOSTAT=IEND) READLINE
    4   FORMAT(A1000)
        IF(IEND .LT. 0) GO TO 100

C  FOR THIS LINE, READLINE, FIND IENDL, THE LAST CHARACTER WHICH IS NOT
C  BLANK. THEN ONLY CHARACTERS 1:IENDL WILL BE WRITTEN TO FILEOUT.

        DO IENDL = 1000,1,-1
         IF(READLINE(IENDL:IENDL) .NE. ' ') GO TO 20
        END DO

   20   CONTINUE

C  BEFORE WRITING READLINE(1:IENDL) TO FILE 22, GO THROUGH THE LINE AND
C  REPLACE ANY DOTS WHICH REPRESENT MISSING VALUES WITH n's.


C  NOTE THAT, AS EXPLAINED ABOVE, THIS MEANS REPLACING AS FOLLOWS:
C   ,.,  WILL BE REPLACED BY  ,n,
C   ,.   WILL BE REPLACED BY  ,n  <-- THIS OCCURS AT END OF LINES.

        DO I = 1,IENDL-2
         IF(READLINE(I:I+2) .EQ. ',.,') READLINE(I:I+2) = ',n,'
        END DO

        IF(READLINE(IENDL-1:IENDL) .EQ. ',.')
     1   READLINE(IENDL-1:IENDL) = ',n'


C  CANNOT USE WRITE(67,4) READLINE(1:IENDL) SINCE, FOR SOME REASON,
C  WRITING LIKE THIS "RIGHT JUSTIFIES" THE CHARACTERS AT THE END
C  OF THE A1000 FORMAT. INSTEAD MUST WRITE (67,__) READLINE, WHERE
C  THE FORMAT IS DETERMINED BY THE LAST NON-BLANK CHARACTER (IENDL)

C  IN READLINE.

	IF(IENDL .LE. 26) THEN
	 WRITE(67,26) READLINE
   26    FORMAT(A26)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 51) THEN
	 WRITE(67,51) READLINE
   51    FORMAT(A51)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 76) THEN
	 WRITE(67,76) READLINE
   76    FORMAT(A76)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 101) THEN
	 WRITE(67,101) READLINE
  101    FORMAT(A101)

	 GO TO 10
	ENDIF

	IF(IENDL .LE. 126) THEN
	 WRITE(67,126) READLINE
  126    FORMAT(A126)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 151) THEN
	 WRITE(67,151) READLINE
  151    FORMAT(A151)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 176) THEN
	 WRITE(67,176) READLINE
  176    FORMAT(A176)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 201) THEN
	 WRITE(67,201) READLINE
  201    FORMAT(A201)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 226) THEN
	 WRITE(67,226) READLINE
  226    FORMAT(A226)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 251) THEN
	 WRITE(67,251) READLINE
  251    FORMAT(A251)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 276) THEN
	 WRITE(67,276) READLINE
  276    FORMAT(A276)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 301) THEN
	 WRITE(67,301) READLINE
  301    FORMAT(A301)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 326) THEN
	 WRITE(67,326) READLINE
  326    FORMAT(A326)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 351) THEN
	 WRITE(67,351) READLINE
  351    FORMAT(A351)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 376) THEN
	 WRITE(67,376) READLINE
  376    FORMAT(A376)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 401) THEN
	 WRITE(67,401) READLINE
  401    FORMAT(A401)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 426) THEN
	 WRITE(67,426) READLINE
  426    FORMAT(A426)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 451) THEN
	 WRITE(67,451) READLINE
  451    FORMAT(A451)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 476) THEN
	 WRITE(67,476) READLINE
  476    FORMAT(A476)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 501) THEN
	 WRITE(67,501) READLINE
  501    FORMAT(A501)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 526) THEN
	 WRITE(67,526) READLINE
  526    FORMAT(A526)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 551) THEN
	 WRITE(67,551) READLINE
  551    FORMAT(A551)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 576) THEN
	 WRITE(67,576) READLINE
  576    FORMAT(A576)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 601) THEN
	 WRITE(67,601) READLINE
  601    FORMAT(A601)

	 GO TO 10
	ENDIF


	IF(IENDL .LE. 626) THEN
	 WRITE(67,626) READLINE
  626    FORMAT(A626)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 651) THEN
	 WRITE(67,651) READLINE
  651    FORMAT(A651)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 676) THEN
	 WRITE(67,676) READLINE
  676    FORMAT(A676)
	 GO TO 10

	ENDIF

	IF(IENDL .LE. 701) THEN
	 WRITE(67,701) READLINE
  701    FORMAT(A701)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 726) THEN
	 WRITE(67,726) READLINE
  726    FORMAT(A726)
	 GO TO 10

	ENDIF

	IF(IENDL .LE. 751) THEN
	 WRITE(67,751) READLINE

  751    FORMAT(A751)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 776) THEN
	 WRITE(67,776) READLINE
  776    FORMAT(A776)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 801) THEN
	 WRITE(67,801) READLINE
  801    FORMAT(A801)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 826) THEN
	 WRITE(67,826) READLINE
  826    FORMAT(A826)
	 GO TO 10
	ENDIF


	IF(IENDL .LE. 851) THEN
	 WRITE(67,851) READLINE
  851    FORMAT(A851)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 876) THEN

	 WRITE(67,876) READLINE
  876    FORMAT(A876)

	 GO TO 10
	ENDIF

	IF(IENDL .LE. 901) THEN
	 WRITE(67,901) READLINE
  901    FORMAT(A901)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 926) THEN

	 WRITE(67,926) READLINE
  926    FORMAT(A926)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 951) THEN
	 WRITE(67,951) READLINE
  951    FORMAT(A951)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 976) THEN
	 WRITE(67,976) READLINE
  976    FORMAT(A976)
	 GO TO 10
	ENDIF

	WRITE(67,4) READLINE
	GO TO 10



  100   CLOSE(77)

        REWIND(67)

        RETURN
        END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
       SUBROUTINE WORKTOCSV(NSUBTOT,PATH,PREFIX,EXT,OUTCSVNAME,
     1 MAXNUMEQ)

C  THIS SUBROUTINE IS BASED ON THE STAND-A-LONE PROGRAM,
C  WORKCSV.FOR, BUT SOME OF THE DIMENSIONS ARE DIFFERENT TO BE
C  COMPATIBLE WITH THIS PROGRAM.

        PARAMETER(MAXSUB=10000)
        IMPLICIT REAL*8(A-H,O-Z)

       DIMENSION SIG(4000),RS(4000,34),YO(594,MAXNUMEQ),C0(MAXNUMEQ),
     1 C1(MAXNUMEQ),C2(MAXNUMEQ),C3(MAXNUMEQ),C4(MAXNUMEQ),C5(MAXNUMEQ),
     2 TIM(594)

        CHARACTER PREFIX*5,EXT*3,NUMBER(MAXSUB)*3,PATFIL*13,PATH*60,
     1   TMPFILE*13,PATHFILE*73,SUBID*11,DESCR(26)*20,OUTCSVNAME*12,
     2   PATHFILE2*73,TOPLINE*1000,TOP1*50,READLINE*80,CHARSUB*3,

     3   COVTIGHT*550,CODE*14

        CODE = 'POPDATA APR_11'

C  CALL FULLNAME WHICH CONVERTS THE FILENAME TO PATHFILE2, THE COMPLETE 
C  NAME OF THE FILE, WHICH INCLUDES THE PATH (IF THE PATH IS NOT THE 
C  CURRENT DIRECTORY).

         TMPFILE = ' '
         TMPFILE = OUTCSVNAME 

         CALL FULLNAME(PATH,TMPFILE,PATHFILE2)
         OPEN(29,FILE=PATHFILE2)

C  CALL SUBROUTINE GETCHAR TO ESTABLISH THE NUMBER ARRAY.

        DO ISUB = 1,NSUBTOT
         CALL GETCHAR(ISUB,CHARSUB)
         NUMBER(ISUB) = CHARSUB
        END DO


	DO 1000 ISUB = 1,NSUBTOT

	 PATFIL = PREFIX//NUMBER(ISUB)//'.'//EXT

C  CALL FULLNAME WHICH CONVERTS THE FILENAME TO PATHFILE, THE COMPLETE 

C  NAME OF THE FILE, WHICH INCLUDES THE PATH (IF THE PATH IS NOT THE 
C  CURRENT DIRECTORY).

         TMPFILE = ' '

         TMPFILE = PATFIL 
         CALL FULLNAME(PATH,TMPFILE,PATHFILE)
         OPEN(33,FILE=PATHFILE)

C  FOR THIS SUBJECT, READ THE NAME. ALSO, IF IT IS THE FIRST SUBJECT,
C  READ THE NO. AND NAMES OF THE ADDITIONAL COVARIATES (BEYOND THE
C  4 PERMANENT ONES, AGE, SEX, HEIGHT, ETHNICITY FLAG, AT THE TOP
C  OF EACH WORKING COPY FILE) IF ANY, AND WRITE THE TOP LINE OF THE
C  .CSV FILE.

C  THE NAME IS ON LINE 1 IN ENTRIES 29 TO 39. 

         READ(33,9) SUBID
    9    FORMAT(T29,A11)

C  NOTE THAT SUBID CONTAINS THE 1ST 11 CHARACTERS OF THE NAME ON THE TOP
C  LINE OF THE WORKING COPY FILE. BUT THERE IS A CHANCE THAT THE NAME
C  COULD INCLUDE A COMMA, SO CALL SUBID TO RESET SUBID TO JUST THE SET
C  OF CHARACTERS PRIOR TO THE 1ST COMMA (SINCE A COMMA IN A .CSV FILE
C  SIGNALS A SEPARATOR OF FIELDS).

	CALL GETID(SUBID)


         IF(ISUB .EQ. 1) THEN

C  WRITE THE FIRST LINE (THE ONE WITH THE CODE) INTO FILE 29.

          WRITE(29,14) CODE
   14     FORMAT(A14)
        
          CALL GETCOVNAME(NCOVA,DESCR)
          
          TOP1 = '#ID,EVID,TIME,DUR,DOSE,INPUT,OUT,OUTEQ,C0,C1,C2,C3'


C  THE TOP LINE OF THE .CSV FILE WILL ALWAYS HAVE TOP1 IN IT, BUT IT  
C  WILL ALSO HAVE THE NAMES OF THE ADDITIONAL COVARIATES, IF ANY, ON 
C  IT. IF NCOVA > 0, CALL COVSTRING TO OBTAIN THE CHARACTER STRING OF 
C  COVARIATE NAMES (COVTIGHT), TIGHTENED TO REMOVE UNNECCESARY SPACES.
C  NCOVTIGHT RETURNS AS THE NO. OF CHARACTERS IN COVTIGHT.

          TOPLINE = TOP1  

          IF(NCOVA .GT. 0) THEN
           CALL COVSTRING(NCOVA,DESCR,COVTIGHT,NCOVTIGHT)
           TOPLINE = TOP1//COVTIGHT(1:NCOVTIGHT)
          ENDIF

          CALL CONDENSE(TOPLINE)

C  CONDENSE WRITES TOPLINE INTO FILE 29 AFTER CONDENSING IT.

         ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(ISUB .EQ. 1)  CONDITION.


C  READ THE DOSAGE INFO AFTER READING THE NO. OF DRUGS, AND THE NO.
C  OF DOSE EVENTS.

   10	   READ(33,22) READLINE
   22    FORMAT(A80)


         IF(READLINE(12:23) .NE. 'NO. OF DRUGS') GO TO 10
         BACKSPACE(33)
         READ(33,13) NDRUG
   13    FORMAT(T2,I5)

C  SKIP THE NEXT LINE. IT HAS NCOVA ON IT, WHICH IS ALREADY KNOWN.

         READ(33,*)

         NI = 2*NDRUG + NCOVA
      
C  READ THE NO. OF DOSE EVENTS ON THE NEXT LINE.

         READ(33,13) ND
         READ(33,*)
         READ(33,*)

         IF(ND.EQ.0) GO TO 40

         DO I = 1,ND

          READ(33,*) SIG(I),(RS(I,J),J=1,NI)
         END DO

C  READ THE NO. OF OUTPUT EQUATIONS FROM THE LINE WITH 'NO. OF TOTAL'
C  AS ENTRIES 12:23. THEN READ NO. OF OBSERVED VALUE TIMES, ETC.

   40	   READ(33,22) READLINE
         IF(READLINE(12:23) .NE. 'NO. OF TOTAL') GO TO 40
         BACKSPACE(33)

         READ(33,13) NUMEQT
         READ(33,13) M

         DO I=1,M
          READ(33,*) TIM(I),(YO(I,J),J=1,NUMEQT)
         END DO

C  AT THIS POINT, MUST SKIP THE COVARIATE INFO IN THE FILE, AND PROCEED
C  TO READ THE ASSAY NOISE COEFFICIENTS BELOW THAT, IF THEY ARE
C  INCLUDED. IF THEY ARE NOT INCLUDED, SET ALL ASSAY COEFFICIENTS TO 0.


   50	   READ(33,22) READLINE
	   IF(READLINE(1:18) .NE. 'ASSAY COEFFICIENTS') GO TO 50


         IF(READLINE(20:25) .EQ. 'FOLLOW') THEN
          DO IEQ = 1,NUMEQT
           READ(33,*) C0(IEQ),C1(IEQ),C2(IEQ),C3(IEQ),C4(IEQ),C5(IEQ)
          END DO
         ENDIF

         IF(READLINE(20:25) .NE. 'FOLLOW') THEN
          DO IEQ = 1,NUMEQT
           C0(IEQ) = 0.D0
           C1(IEQ) = 0.D0
           C2(IEQ) = 0.D0
           C3(IEQ) = 0.D0
           C4(IEQ) = 0.D0
           C5(IEQ) = 0.D0
          END DO
         ENDIF

         CLOSE(33)

C  CALL WRITECSV TO CONVERT THIS SUBJECT'S VALUES INTO A BLOCK OF
C  LINES IN THE .CSV FILE.


         CALL WRITECSV(SUBID,NDRUG,NCOVA,ND,SIG,RS,NUMEQT,M,TIM,YO,C0,
     1    C1,C2,C3,MAXNUMEQ)


 1000   CONTINUE

C  THE ABOVE LINE IS THE END OF THE  DO 1000  LOOP.

        CLOSE(29)

        RETURN
        END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
	SUBROUTINE GETCOVNAME(NCOVA,DESCR)
	IMPLICIT REAL*8(A-H,O-Z)
	CHARACTER READLINE*1000,DESCR(26)*20

C  THIS ROUTINE IS CALLED BY SUBROUTINE WORKTOCSV TO OBTAIN, FROM 
C  FILE 33, THE NO. OF ADDITIONAL COVARIATES (NCOVA), AND THEIR 
C  NAMES (DESCR(I),I=1,NCOVA).


    2   FORMAT(A20)
   33   FORMAT(A1000)

        REWIND(33)

C  THE NO. OF ADDITIONAL COVARIATES IS ON THE LINE HAVING
C  "NO. OF ADDITIONAL COVARIATES" STARTING IN ENTRY 12.

   10	READ(33,33) READLINE
	IF(READLINE(12:28) .NE. 'NO. OF ADDITIONAL') GO TO 10
	BACKSPACE(33)
    3 FORMAT(T2,I5)
      READ(33,3) NCOVA

C  READ THE NCOVA ADDITIONAL COVARIATE NAMES FROM BELOW THE LINE HAVING
C  "COVARIATE NAMES" STARTING IN COLUMN 2. IF NCOVA = 0, NO NAMES 
C  WILL BE READ.

   20	READ(33,33) READLINE
	IF(READLINE(2:16) .NE. 'COVARIATE NAMES') GO TO 20


        IF(NCOVA .GT. 0) THEN

         DO J = 1,NCOVA

          READ(33,33) READLINE

C  FOR THIS COVARIATE, ESTABLISH DESCR(J) AS THE PORTION OF THE
C  CURRENT READLINE UP TO THE  FIRST SPACE, WHICH WILL BE ASSUMED TO BE
C  THE END OF THE COV. NAME. IN CASE THERE IS A SPACE OR TWO AT THE
C  BEGINNING OF READLINE FOR SOME REASON, START CHECKING FOR SPACES AT
C  ENTRY 3.

          DO I = 3,20
           IF(READLINE(I:I) .EQ. ' ') GO TO 30
          END DO

   30     DESCR(J) = READLINE(1:I-1)

         END DO

        ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(NCOVA .GT. 0)  CONDITION.


	REWIND(33)

	RETURN
	END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
        SUBROUTINE WRITECSV(SUBID,NDRUG,NCOVA,ND,SIG,RS,NUMEQT,M,TIM,
     1   YO,C0,C1,C2,C3,MAXNUMEQ)

C  WRITECSV IS CALLED BY WORKTOCSV TO CONVERT THIS SUBJECT'S VALUES INTO
C  A BLOCK OF LINES IN THE .CSV FILE.

        IMPLICIT REAL*8(A-H,O-Z)

       DIMENSION SIG(4000),RS(4000,34),YO(594,MAXNUMEQ),
     1 C0(MAXNUMEQ),C1(MAXNUMEQ),C2(MAXNUMEQ),C3(MAXNUMEQ),
     2 TIM(594),BS(4000,7),NOIV(7),AMTIV(7,4000),DURIV(7,4000),
     3 IVDOSE(7,4000)

        CHARACTER SUBID*11,DOSESTRING*12,OBSSTRING*52,BIGLINE*1000,
     1   SMALLLINE*1000


C  INITIALIZE IDOSENEXT TO BE 0. SEE LOGIC BELOW.

        IDOSENEXT = 0


C  ASSIGN THE VALUES IN EACH DRUG'S PO COLUMN TO THE CORRESPONDING
C  COLUMN IN ARRAY BS.

        DO IDOSE = 1,ND
         DO JDRUG = 1,NDRUG
          BS(IDOSE,JDRUG) = RS(IDOSE,2*JDRUG)
         END DO
        END DO


C  FIND THE LARGEST OBSERVATION TIME, TIMOBSMAX. IT WILL ONLY BE USED
C  IN CASE AN IV IS READ IN AS GOING ON INDEFINITELY. IN THAT CASE,

C  THIS IV, WHICH NEEDS A STOPPING TIME IN THE .CSV FILE (UNLIKE IN
C  A WORKING COPY FILE), WILL BE SHOWN AS STOPPING AT TIMOBSMAX. NOTE
C  THAT IF THERE ARE TIME RESETS, IT IS POSSIBLE THAT THE MAXIMUM
C  OBSERVATION TIME FOR THE TIME PERIOD OF THE NEVER-ENDING IV IS 
C  LESS THAN TIMOBSMAX, BUT THIS DOESN'T MATTER (SINCE THE IV WILL
C  HAVE GONE AT LEAST AS LONG AS REQUIRED IN THIS CASE).

        TIMOBSMAX = -1.D39
        DO I = 1,M
         IF(TIM(I) .GT. TIMOBSMAX) TIMOBSMAX = TIM(I)
        END DO

  
C  DETERMINE, FOR EACH DRUG, THE TOTAL AMOUNT OF IV THAT IS GIVEN,
C  AND THE TIME OVER WHICH IT IS GIVEN, FOR EACH SEPARATE IV INFUSION.

        DO JDRUG = 1,NDRUG

C  NOIV(JDRUG) WILL BE THE NO. OF IVs FOR THIS DRUG.

         NOIV(JDRUG) = 0

         IDOSE = 0

   40    IDOSE = IDOSE + 1


C  IF IDOSE IS NOW > ND, THERE ARE NO MORE POSSIBLE IVs FOR THIS DRUG.

          IF(IDOSE .GT. ND) GO TO 60

C  IF THE CURRENT DOSE IS .NE. 0, IT IS THE START OF THE NEXT IV.
    
          CALL THESAME(RS(IDOSE,2*JDRUG-1),0.D0,ISAME) 

          IF(ISAME .EQ. 0) THEN

C  FOR DRUG NO. JDRUG, AN IV STARTS WITH DOSE NO. IDOSE. ESTABLISH THE
C  TOTAL AMOUNT FOR THIS IV, AND THE TIME IT LASTS.

           PREVIV = RS(IDOSE,2*JDRUG-1)


           IIDOSE = IDOSE

   50      IIDOSE = IIDOSE + 1

C  IF THIS DOSE TIME IS 0, IT INDICATES A DOSE RESET TIME. THIS MEANS
C  THAT THE CURRENT IV WILL BE SET TO END TIMOBSMAX.

            CALL THESAME(SIG(IIDOSE),0.D0,ISAME)
            IF(ISAME .EQ. 1) THEN
             TIMIV = TIMOBSMAX - SIG(IDOSE)
             TOTIV = TIMIV*RS(IDOSE,2*JDRUG-1)
             GO TO 30
            ENDIF

C  TO GET HERE --> THIS DOSE TIME, SIG(IIDOSE), IS NOT 0. IN THIS CASE,
C  IF THE IV FOR THIS DRUG IS .NE. PREVIV, THIS DOSE TIME IS THE ENDING
C  TIME FOR THE IV. OTHERWISE, CONTINUE THE LOOP.

            CALL THESAME(RS(IIDOSE,2*JDRUG-1),PREVIV,ISAME)
            IF(ISAME .EQ. 0) THEN
             TIMIV = SIG(IIDOSE) - SIG(IDOSE)
             TOTIV = TIMIV*RS(IDOSE,2*JDRUG-1)
             GO TO 30
            ENDIF

           IF(IIDOSE .LT. ND) GO TO 50

C  TO GET HERE --> THE IV STARTED AT DOSE NO. IDOSE WAS NEVER ENDED
C  IN THE WORKING COPY FILE, AND A TIME RESET (A DOSE TIME OF 0) WAS
C  NEVER ENCOUNTERED. THIS MEANS THE IV MUST BE SHOWN TO CONTINUE
C  UNTIL TIMOBSMAX (SEE ABOVE). 

C  ALSO NOTE THAT THIS IS THE END OF POSSIBLE IVs FOR THIS DRUG SINCE
C  THE IV THAT WAS STARTED AT IDOSE WAS NEVER TURNED OFF. SO SET
C  IIDOSE = ND + 1 SO THAT BELOW WHEN IDOSE = IIDOSE - 1, IDOSE WILL
C  = ND, WHICH MEANS AFTER THE TRANSFER BACK TO LABEL 40, IDOSE WILL
C  THEN BE SET = ND+1 --> END OF SEARCHING FOR NEW IVs FOR THIS DRUG.

            TIMIV = TIMOBSMAX - SIG(IDOSE)
            TOTIV = TIMIV*RS(IDOSE,2*JDRUG-1)
            IIDOSE = ND + 1


   30      NOIV(JDRUG) = NOIV(JDRUG) + 1
           AMTIV(JDRUG,NOIV(JDRUG)) = TOTIV 
           DURIV(JDRUG,NOIV(JDRUG)) = TIMIV
           IVDOSE(JDRUG,NOIV(JDRUG)) = IDOSE

C  THE ABOVE ARRAYS SHOW THAT FOR DRUG NO. JDRUG, IV NO. NOIV(JDRUG)
C  STARTED AT DOSE NO. IDOSE, LASTED FOR DURIV(JDRUG,NOIV(JDRUG)), AND
C  HAD A TOTAL AMOUNT OF AMTIV(JDRUG,NOIV(JDRUG)). FOR EXAMPLE, IF FOR
C  DRUG 4, THE 3RD IV STARTS AT DOSE NO. 7, THEN IVDOSE(4,3) = 7.

C  SET IDOSE TO IIDOSE - 1, SO THAT WHEN AFTER TRANSFER BACK TO 
C  LABEL 40, THE NEXT IDOSE TO BE CONSIDERED WILL BE THE CURRENT
C  IIDOSE (I.E., THE NEXT IV COULD BE STARTING WITH THE DOSE WHICH
C  ENDED THE CURRENT IV).

           IDOSE = IIDOSE - 1
           GO TO 40     
            
          ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(ISAME .EQ. 0)  CONDITION.

C  TO GET HERE MEANS THAT THE CURRENT IV IS 0, SO CONTINUE LOOKING
C  FOR THE START OF THE NEXT IV.

         GO TO 40

   60    CONTINUE

        END DO


C  THE ABOVE END DO IS FOR THE  DO JDRUG = 1,NDRUG  LOOP.


C  ESTABLISH TWO STRINGS WHICH WILL WE NEEDED IN WRITING TO FILE 25.
C  DOSESTRING CONSISTS OF THE COMMAS AND DOTS WHICH REPRESENT MISSING
C  OUTPUT AND ASSAY COEFFCIENT INFO FOR EACH DOSE LINE.
C  OBSSTRING CONSISTS OF THE COMMAS AND DOTS WHICH REPRESENT MISSING
C  COVARIATE VALUES FOR EACH DOSE LINE. 

        DOSESTRING = ',.,.,.,.,.,.'
       

C  ESTABLISH OBSSTRING TO CONTAIN NCOVA SETS OF ',.', AND ILASTOBS TO
C  BE THE NO. OF CHARACTERS IN OBSSTRING (NOT COUNTING BLANKS).

        DO I = 1,52
         OBSSTRING(I:I) = ' '
        END DO

        IF(NCOVA .GE. 1) THEN
         OBSSTRING(1:2) = ',.'
         ILASTOBS = 2
        ENDIF

        IF(NCOVA .GT. 1) THEN

         DO ICOVA = 2,NCOVA

          DO I = 52,1,-1
           IF(OBSSTRING(I:I) .NE. ' ') GO TO 65 
          END DO

   65     ILAST = I


          OBSSTRING = OBSSTRING(1:ILAST)//',.'

         END DO

         ILASTOBS = ILAST + 2

        ENDIF


C  GO THROUGH ALL THE ND DOSE EVENTS AND THE M OBSERVATION LINES AT THE
C  SAME TIME, AND PUT LINES INTO FILE 25 IN THE PROPER ORDER FOR THIS
C  SUBJECT. 
        
        IDOSE = 1
        IOBS = 1


  100   CONTINUE

C  IF IOBS > M, THERE ARE NO MORE OBSERVATION ROWS TO WRITE TO FILE 25.
C  IF IDOSE > ND, THERE ARE NO MORE DOSE EVENT ROWS TO WRITE TO FILE 25.

        IF(IOBS .GT. M .AND. IDOSE .GT. ND) RETURN

C  IF IOBS > M, ALL THAT IS LEFT ARE DOSE EVENTS.
C  IF IDOSE > ND, ALL THAT IS LEFT ARE OBSERVATION ROWS.

        IF(IOBS .GT. M) GO TO 10
        IF(IDOSE .GT. ND) GO TO 20


C  TO GET HERE MEANS THERE ARE BOTH DOSE EVENTS AND OBSERVATION ROWS
C  TO BE WRITTEN. WRITE THE NEXT DOSE IF IT OCCURS BEFORE THE NEXT

C  OBSERVATION TIME. OTHERWISE, WRITE THE NEXT OBSERVATION ROW.
C  ... BUT CHECK FIRST TO SEE IF EITHER THE DOSE TIME OR THE OBSERVATION
C  TIME REPRESENTS A TIME RESET.

C  IF THIS IS A DOSE TIME RESET, BUT NOT AN OBSERVATION TIME RESET,
C  THEN THE OBSERVATION GOES FIRST. AND VICE-VERSA.

C  THIS IS A DOSE TIME RESET IF SIG(IDOSE) = 0 AND IDOSE > 1.

        IDOSERESET = 0
        CALL THESAME(SIG(IDOSE),0.D0,ISAME)

        IF(ISAME .EQ. 1 .AND. IDOSE .GT. 1) IDOSERESET = 1   

        IOBSRESET = 0
        CALL THESAME(TIM(IOBS),0.D0,ISAME)
        IF(ISAME .EQ. 1 .AND. IOBS .GT. 1) IOBSRESET = 1   

        IF(IDOSERESET .EQ. 1 .AND. IOBSRESET .EQ. 1) THEN


C  THIS IS BOTH A DOSE AND AN OBSERVATION TIME RESET. IN THIS CASE,
C  GO TO 20 TO WRITE OBSERVATIONS, IF ANY ARE NOT EQUAL TO -99 FOR THIS
C  OBSERVATION TIME, AND THEN IMMEDIATELY GO TO 10 TO WRITE THE DOSE 
C  INFO. AT THIS TIME RESET. SET IDOSENEXT = 1 IN THIS CASE SO THE 
C  PROGRAM WILL KNOW TO GO DIRECTLY TO 10 AFTER DOING THE CODE AT 20,
C  WITHOUT GOING BACK TO 100 FIRST. NOTE THAT AT THE BOTTOM OF THE
C  DOSE CODE STARTING AT 10, IDOSENEXT IS RESET BACK TO 0.


         IDOSENEXT = 1
         GO TO 20

        ENDIF

        IF(IDOSERESET .EQ. 1 .AND. IOBSRESET .EQ. 0) GO TO 20
        IF(IDOSERESET .EQ. 0 .AND. IOBSRESET .EQ. 1) GO TO 10

        IF(SIG(IDOSE) .GE. TIM(IOBS)) GO TO 20


C  THE NEXT LINES TO BE WRITTEN TO FILE 25 ARE DOSE LINES.

   10    CONTINUE

C  IF THIS IS NOT A TIME RESET, THE EVENT ID IS 1; IF IT IS A TIME 
C  RESET, THE EVENT ID IS 4. IT IS A TIME RESET IF SIG(IDOSE) = 0
C  AND IDOSE > 1.

        IDEVENT = 1
        CALL THESAME(SIG(IDOSE),0.D0,ISAME)
        IF(ISAME .EQ. 1 .AND. IDOSE .GT. 1) IDEVENT = 4   

C  IF IDEVENT = 4 (I.E., THIS IS A DOSE TIME RESET),  ONLY THE FIRST
C  ROW RELATED TO THIS EVENT SHOULD SHOULD AN IDEVENT OF 4; SUBSEQUENT
C  ROWS MUST SHOW IDEVENT = 1. FOR EXAMPLE, IF A DOSE TIME RESET OCCURS
C  WITH BOTH AN IV AND A BOLUS FOR A DRUG, OR AN IV FOR ONE DRUG AND
C  A BOLUS FOR ANOTHER, ONLY THE 1ST ROW SHOULD SHOW AN IDEVENT OF 4;
C  OTHERWISE, THE PROGRAM WILL THINK THAT THE 2ND ROW IS ANOTHER DOSE
C  TIME RESET AFTER THE ONE IN THE 1ST ROW.  


C  THE TIME OF THIS DOSE IS SIG(IDOSE). FOR EACH DRUG, DETERMINE IF
C  THIS TIME REPRESENTS THE TIME OF A NON-0 BOLUS AND/OR THE START OF
C  AN IV. 

C  INITIALIZE IDOSWRITE TO 0. IF IT REMAINS 0 AFTER THE
C  DO JDRUG = 1,NDRUG LOOP, IT MEANS THAT THIS DOSE EVENT HAS NEITHER
C  A BOLUS VALUE OR A STARTING IV FOR ANY OF THE DRUGS. IN THIS CASE,
C  A LINE WILL BE WRITTEN TO FILE 25 WITH THE COVARIATE VALUES IN 
C  THIS LINE. IF IT CHANGES TO 1, THERE IS NO NEED TO WRITE ANOTHER
C  LINE WITH THE COVARIATE VALUES FOR THIS LINE SINCE THEY HAVE ALREADY
C  BEEN INCLUDED IN AT LEAST ONE LINE ALREADY WRITTEN.

         IDOSWRITE = 0


         DO JDRUG = 1,NDRUG

C  CHECK TO SEE IF BOLUS(IDOSE,JDRUG) IS THE SAME AS 0.0. IF NOT,
C  THIS TIME HAS A BOLUS VALUE FOR THIS DRUG. IN THAT CASE, PUT IN
C  A LINE TO FILE 25 FOR THIS VALUE.

          CALL THESAME(BS(IDOSE,JDRUG),0.D0,ISAME)

          IF(ISAME .EQ. 0) THEN

           OPEN(37,STATUS='SCRATCH')

           IF(NCOVA .GT. 0) WRITE(37,13) SUBID,IDEVENT,SIG(IDOSE),
     1      BS(IDOSE,JDRUG),JDRUG,DOSESTRING,
     2      (RS(IDOSE,2*NDRUG+K),K=1,NCOVA)
   13      FORMAT(A11,',',I1,',',G14.7,',0,',G14.7,',',I1,A12,
     1      26(',',G14.7))

           IF(NCOVA .EQ. 0) WRITE(37,14) SUBID,IDEVENT,SIG(IDOSE),
     1      BS(IDOSE,JDRUG),JDRUG,DOSESTRING   
   14      FORMAT(A11,',',I1,',',G14.7,',0,',G14.7,',',I1,A12)

           BACKSPACE(37)
           READ(37,12) BIGLINE
           CLOSE(37)
           CALL REDUCE(BIGLINE,SMALLLINE)
           CALL CONDENSE(SMALLLINE)
           IDOSWRITE = 1
           IDEVENT = 1
C  EVEN IF IDEVENT = 4, IT SHOULD BE CHANGED AFTER THE ABOVE WRITING,
C  SINCE EACH DOSE RESET ROW SHOULD HAVE JUST ONE IDEVENT = 4 ROW
C  IN THE .CSV FILE; ALL SUBSEQUENT ROWS FOR THIS EVENT SHOULD SHOW
C  IDEVENT = 1. 
           

          ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(ISAME .EQ. 0)  CONDITION.


C  CHECK TO SEE IF DRUG JDRUG HAS AN IV WHICH STARTS AT DOSE NO. IDOSE.

C  IF SO, PUT IN A LINE TO FILE 25 FOR THIS VALUE.

          IF(NOIV(JDRUG) .GE. 1) THEN

           DO IN = 1,NOIV(JDRUG)

            IF(IVDOSE(JDRUG,IN) .EQ. IDOSE) THEN

             OPEN(37,STATUS='SCRATCH') 

             IF(NCOVA .GT. 0) WRITE(37,16) SUBID,IDEVENT,SIG(IDOSE),
     1        DURIV(JDRUG,IN),AMTIV(JDRUG,IN),JDRUG,
     2        DOSESTRING,(RS(IDOSE,2*NDRUG+K),K=1,NCOVA)
   16        FORMAT(A11,',',I1,',',G14.7,',',G14.7,',',G14.7,',',I1,A12,
     1        26(',',G14.7))

             IF(NCOVA .EQ. 0) WRITE(37,17) SUBID,IDEVENT,SIG(IDOSE),
     1        DURIV(JDRUG,IN),AMTIV(JDRUG,IN),JDRUG,
     2        DOSESTRING 
   17        FORMAT(A11,',',I1,',',G14.7,',',G14.7,',',G14.7,',',I1,A12)

             BACKSPACE(37)
             READ(37,12) BIGLINE
             CLOSE(37)
             CALL REDUCE(BIGLINE,SMALLLINE)
             CALL CONDENSE(SMALLLINE)
             IDOSWRITE = 1
             IDEVENT = 1
C  EVEN IF IDEVENT = 4, IT SHOULD BE CHANGED AFTER THE ABOVE WRITING,
C  SINCE EACH DOSE RESET ROW SHOULD HAVE JUST ONE IDEVENT = 4 ROW

C  IN THE .CSV FILE; ALL SUBSEQUENT ROWS FOR THIS EVENT SHOULD SHOW
C  IDEVENT = 1. 

             GO TO 70

            ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(IVDOSE(JDRUG,IN) .EQ. IDOSE)  
C  CONDITION.  

           END DO

C  THE ABOVE END DO IS FOR THE  DO IN = 1,NOIV(DRUG)  LOOP.


          ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(NOIV(JDRUG) .GE. 1)  CONDITION.

   70     CONTINUE

         END DO

C  THE ABOVE END DO IS FOR THE  DO JDRUG = 1,NDRUG  LOOP.


C  IF IDOSWRITE = 0, MUST PUT IN A LINE TO ESTABLISH THE COVARIATE
C  VALUES (SEE ABOVE).

         IF(IDOSWRITE .EQ. 0) THEN

          OPEN(37,STATUS='SCRATCH') 

          IF(NCOVA .GT. 0) WRITE(37,18) SUBID,IDEVENT,SIG(IDOSE),
     1     DOSESTRING,(RS(IDOSE,2*NDRUG+K),K=1,NCOVA)
   18     FORMAT(A11,',',I1,',',G14.7,',0,0,1',A12,26(',',G14.7))


          IF(NCOVA .EQ. 0) WRITE(37,19) SUBID,IDEVENT,SIG(IDOSE),
     1     DOSESTRING   
   19     FORMAT(A11,',',I1,',',G14.7,',0,0,1',A12)
  
          BACKSPACE(37)

          READ(37,12) BIGLINE
          CLOSE(37)
          CALL REDUCE(BIGLINE,SMALLLINE)
          CALL CONDENSE(SMALLLINE)

         ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(IDOSWRITE .EQ. 0)  CONDITION.

 

         IDOSE = IDOSE + 1


C  SET IDOSENEXT TO 0. SEE LOGIC BELOW LABEL 20.

         IDOSENEXT = 0


         GO TO 100


C  TO GET TO 20 MEANS THAT OBSERVATION ROWS WILL BE WRITTEN.

   20   CONTINUE

C  THE NEXT LINES TO BE WRITTEN TO FILE 29 ARE OBSERVATION LINES, ONE
C  FOR EACH OUTPUT EQUATION WHICH HAS A NON-MISSING OBSERVATION AT THE
C  CURRENT TIME, TIM(IOBS).


C  ALSO NOTE THAT THE ASSAY COEFFICIENTS WILL BE WRITTEN TO EACH LINE.

         DO IEQ = 1,NUMEQT

C  CHECK TO SEE IF OBSERVATION IOBS FOR OUTPUT EQ. IEQ IS -99. IF NOT,
C  WRITE A LINE INTO FILE 25 FOR THIS VALUE. IN THIS CASE, WRITE THE
C  INFO TO SCRATCH FILE 37, READ THIS LINE AS A CHARACTER CONSTANT,
C  CALL REDUCE TO REMOVE THE SPACES IN THIS CHARACTER CONSTANT, AND THEN
C  CALL CONDENSE TO WRITE THIS REDUCED CONSTANT TO FILE 25 WITH AS 
C  SMALL A FORMAT AS POSSIBLE (WITHIN 25 CHARACTERS).

          CALL THESAME(YO(IOBS,IEQ),-99.D0,ISAME)

          IF(ISAME .EQ. 0) THEN
           OPEN(37,STATUS='SCRATCH') 

           IF(NCOVA .GT. 0) WRITE(37,11)SUBID,TIM(IOBS),YO(IOBS,IEQ),
     1      IEQ,C0(IEQ),C1(IEQ),C2(IEQ),C3(IEQ),OBSSTRING(1:ILASTOBS)
   11      FORMAT(A11,',0,',G14.7,',.,.,.,',G14.7,',',I1,',',
     1      G14.7,',',G14.7,',',G14.7,',',G14.7,A)

           IF(NCOVA .EQ. 0) WRITE(37,111)SUBID,TIM(IOBS),YO(IOBS,IEQ),
     1      IEQ,C0(IEQ),C1(IEQ),C2(IEQ),C3(IEQ)
  111      FORMAT(A11,',0,',G14.7,',.,.,.,',G14.7,',',I1,',',
     1      G14.7,',',G14.7,',',G14.7,',',G14.7)



           BACKSPACE(37)
           READ(37,12) BIGLINE
   12      FORMAT(A1000)

           CLOSE(37)
           CALL REDUCE(BIGLINE,SMALLLINE)
           CALL CONDENSE(SMALLLINE)

          ENDIF

         END DO

C  THE ABOVE END DO IS FOR THE  DO IEQ = 1,NUMEQT  LOOP.

         IOBS = IOBS + 1

         IF(IDOSENEXT .EQ. 1) GO TO 10
C  NOTE THAT IF IDOSENEXT = 1, IT MEANS THAT THE CURRENT TIME
C  REPRESENTS BOTH AN OBSERVATION AND A DOSE TIME RESET. SINCE THE

C  CODE TO WRITE THE INFO FOR THE OBSERVATION HAS NOW BEEN COMPLETED,
C  CONTROL SHIFTS IMMEDIATELY TO LABEL 10 WHERE THE DOSE INFO WILL NEXT
C  BE WRITTEN.

         GO TO 100


        END

C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
        SUBROUTINE REDUCE(BIGLINE,SMALLLINE)
        CHARACTER BIGLINE*1000,SMALLLINE*1000

C  THIS ROUTINE, CALLED BY WRITECSV, INPUTS BIGLINE, AND OUTPUTS
C  SMALLLINE WHICH HAS ALL THE NON-BLANK CHARACTERS OF BIGLINE
C  (EXCEPT THAT THE FIRST 11 CHARACTERS, WHICH CONSTITUTE THE
C  PATIENT NAME) CAN HAVE BLANKS.

C  FIRST BLANK OUT ALL OF SMALLLINE, IN CASE IT HAS SOME "JUNK" IN 
C  SOME OF ITS ENTRIES.

        DO I = 1,1000
         SMALLLINE(I:I) = ' '
        END DO
 
        SMALLLINE(1:11) = BIGLINE(1:11)

        IENTRY = 11

        DO I = 12,1000
         IF(BIGLINE(I:I) .NE. ' ') THEN
          IENTRY = IENTRY + 1
          SMALLLINE(IENTRY:IENTRY) = BIGLINE(I:I)
         ENDIF

        END DO

C  BECAUSE OF THE FORMAT USED TO WRITE DOSES TO FILE 37 IN MAIN, IT IS
C  POSSIBLE THAT THE LAST CHARACTER COULD BE A COMMA. SO CHECK THE LAST
C  ENTRY IN SMALLLINE, AND IF IT IS A COMMA, CHANGE IT TO A BLANK.

        IF(SMALLLINE(IENTRY:IENTRY) .EQ. ',') 
     1   SMALLLINE(IENTRY:IENTRY) = ' '

        RETURN
        END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
        SUBROUTINE CONDENSE(READLINE)
        CHARACTER READLINE*1000        

C  SUBROUTINE CONDENSE IS CALLED BY WRITECSV TO WRITE READLINE WITH AS 
C  SMALL A FORMAT AS POSSIBLE (WITHIN 25 CHARACTERS) TO FILE 29.

C  FOR THIS LINE, READLINE, FIND IEND, THE LAST CHARACTER WHICH IS NOT
C  BLANK. THEN ONLY CHARACTERS 1:IEND WILL BE WRITTEN TO FILE 29.



	DO IEND = 1000,1,-1
	 IF(READLINE(IEND:IEND) .NE. ' ') GO TO 20
	END DO



   20   CONTINUE


C  CANNOT USE WRITE(29,_) READLINE(1:IEND) SINCE, FOR SOME REASON,
C  WRITING LIKE THIS "RIGHT JUSTIFIES" THE CHARACTERS AT THE END
C  OF THE A1000 FORMAT. INSTEAD MUST WRITE(29,__) READLINE, WHERE
C  THE FORMAT IS DETERMINED BY THE LAST NON-BLANK CHARACTER (IEND)
C  IN READLINE.

	IF(IEND .LE. 26) THEN
	 WRITE(29,26) READLINE
   26    FORMAT(A26)
	 RETURN
	ENDIF

	IF(IEND .LE. 51) THEN
	 WRITE(29,51) READLINE
   51    FORMAT(A51)
	 RETURN
	ENDIF

	IF(IEND .LE. 76) THEN
	 WRITE(29,76) READLINE
   76    FORMAT(A76)
	 RETURN
	ENDIF

	IF(IEND .LE. 101) THEN
	 WRITE(29,101) READLINE
  101    FORMAT(A101)
	 RETURN
	ENDIF

	IF(IEND .LE. 126) THEN
	 WRITE(29,126) READLINE
  126    FORMAT(A126)
	 RETURN
	ENDIF

	IF(IEND .LE. 151) THEN
	 WRITE(29,151) READLINE
  151    FORMAT(A151)
	 RETURN
	ENDIF

	IF(IEND .LE. 176) THEN
	 WRITE(29,176) READLINE
  176    FORMAT(A176)
	 RETURN
	ENDIF

	IF(IEND .LE. 201) THEN
	 WRITE(29,201) READLINE
  201    FORMAT(A201)
	 RETURN
	ENDIF

	IF(IEND .LE. 226) THEN
	 WRITE(29,226) READLINE
  226    FORMAT(A226)
	 RETURN
	ENDIF

	IF(IEND .LE. 251) THEN
	 WRITE(29,251) READLINE
  251    FORMAT(A251)

	 RETURN
	ENDIF

	IF(IEND .LE. 276) THEN
	 WRITE(29,276) READLINE
  276    FORMAT(A276)
	 RETURN
	ENDIF

	IF(IEND .LE. 301) THEN
	 WRITE(29,301) READLINE
  301    FORMAT(A301)
	 RETURN
	ENDIF

	IF(IEND .LE. 326) THEN

	 WRITE(29,326) READLINE
  326    FORMAT(A326)
	 RETURN
	ENDIF

	IF(IEND .LE. 351) THEN
	 WRITE(29,351) READLINE
  351    FORMAT(A351)

	 RETURN
	ENDIF

	IF(IEND .LE. 376) THEN
	 WRITE(29,376) READLINE
  376    FORMAT(A376)
	 RETURN
	ENDIF

	IF(IEND .LE. 401) THEN
	 WRITE(29,401) READLINE
  401    FORMAT(A401)
	 RETURN
	ENDIF

	IF(IEND .LE. 426) THEN
	 WRITE(29,426) READLINE
  426    FORMAT(A426)
	 RETURN
	ENDIF

	IF(IEND .LE. 451) THEN
	 WRITE(29,451) READLINE
  451    FORMAT(A451)
	 RETURN
	ENDIF

	IF(IEND .LE. 476) THEN
	 WRITE(29,476) READLINE

  476    FORMAT(A476)
	 RETURN
	ENDIF

	IF(IEND .LE. 501) THEN
	 WRITE(29,501) READLINE

  501    FORMAT(A501)
	 RETURN
	ENDIF

	IF(IEND .LE. 526) THEN
	 WRITE(29,526) READLINE
  526    FORMAT(A526)
	 RETURN
	ENDIF

	IF(IEND .LE. 551) THEN
	 WRITE(29,551) READLINE
  551    FORMAT(A551)

	 RETURN
	ENDIF

	IF(IEND .LE. 576) THEN

	 WRITE(29,576) READLINE
  576    FORMAT(A576)
	 RETURN
	ENDIF

	IF(IEND .LE. 601) THEN
	 WRITE(29,601) READLINE
  601    FORMAT(A601)
	 RETURN
	ENDIF

	IF(IEND .LE. 626) THEN
	 WRITE(29,626) READLINE
  626    FORMAT(A626)
	 RETURN
	ENDIF

	IF(IEND .LE. 651) THEN
	 WRITE(29,651) READLINE
  651    FORMAT(A651)
	 RETURN
	ENDIF

	IF(IEND .LE. 676) THEN
	 WRITE(29,676) READLINE
  676    FORMAT(A676)
	 RETURN
	ENDIF

	IF(IEND .LE. 701) THEN
	 WRITE(29,701) READLINE
  701    FORMAT(A701)
	 RETURN
	ENDIF

	IF(IEND .LE. 726) THEN
	 WRITE(29,726) READLINE
  726    FORMAT(A726)
	 RETURN
	ENDIF

	IF(IEND .LE. 751) THEN
	 WRITE(29,751) READLINE
  751    FORMAT(A751)
	 RETURN
	ENDIF

	IF(IEND .LE. 776) THEN
	 WRITE(29,776) READLINE
  776    FORMAT(A776)
	 RETURN
	ENDIF

	IF(IEND .LE. 801) THEN
	 WRITE(29,801) READLINE
  801    FORMAT(A801)
	 RETURN
	ENDIF

	IF(IEND .LE. 826) THEN
	 WRITE(29,826) READLINE
  826    FORMAT(A826)

	 RETURN
	ENDIF

	IF(IEND .LE. 851) THEN
	 WRITE(29,851) READLINE
  851    FORMAT(A851)
	 RETURN
	ENDIF

	IF(IEND .LE. 876) THEN
	 WRITE(29,876) READLINE
  876    FORMAT(A876)
	 RETURN
	ENDIF

	IF(IEND .LE. 901) THEN
	 WRITE(29,901) READLINE
  901    FORMAT(A901)
	 RETURN
	ENDIF

	IF(IEND .LE. 926) THEN
	 WRITE(29,926) READLINE
  926    FORMAT(A926)
	 RETURN
	ENDIF

	IF(IEND .LE. 951) THEN
	 WRITE(29,951) READLINE
  951    FORMAT(A951)
	 RETURN
	ENDIF

	IF(IEND .LE. 976) THEN
	 WRITE(29,976) READLINE
  976    FORMAT(A976)
	 RETURN
	ENDIF

	WRITE(29,4) READLINE
    4    FORMAT(A1000)
        RETURN

        END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

C
        SUBROUTINE COVSTRING(NCOVA,DESCR,COVTIGHT,NCOVTIGHT)

        CHARACTER DESCR(26)*20,COVTIGHT*550,BIGLINE*1000


C  THIS SUBROUTINE IS CALLED BY MAIN TO PLACE INTO COVTIGHT THE
C  LIST OF NCOVA COVARIATE NAMES, EACH SEPARATED BY A COMMA.

C  NCOVTIGHT RETURNS AS THE NO. OF CHARACTERS IN COVTIGHT.
        
        DO I = 1,1000
         BIGLINE(I:I) = ' '
        END DO


        BIGLINE(1:21) = ','//DESCR(1)

        IF(NCOVA .GT. 1) THEN


        DO I = 2,NCOVA


C  CALL CALCSTART TO DETERMINE THE LAST USED CHARACTER IN BIGLINE.

         CALL CALCSTART(BIGLINE,ILAST)
         BIGLINE = BIGLINE(1:ILAST)//','//DESCR(I)

        END DO

        ENDIF

C  THE NO. OF ENTRIES IN BIGLINE IS ILAST + 20 (SINCE THE LAST
C  COVARIATE, DESCR(NCOVA), HAS AT MOST 20 ENTRIES).

        NCOVTIGHT = ILAST + 20
        COVTIGHT = BIGLINE(1:NCOVTIGHT)

        RETURN 
        END
               
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
        SUBROUTINE CALCSTART(BIGLINE,ILAST)
        CHARACTER BIGLINE*1000

        DO I = 1000,1,-1
         IF(BIGLINE(I:I) .NE. ' ') GO TO 10
        END DO

        ILAST = 0
        RETURN


   10   ILAST = I

        RETURN
        END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
      SUBROUTINE CSVCHANGE

C  SUBROUTINE CSVCHANGE IS CALLED BY MAIN AND SUBROUTINE GETNUMEQ TO
C  CHANGE .csv FILES WITH CODE OF POPDATA DEC_11 (I.E., THOSE WITH 2
C  EXTRA COLUMNS FOR ADDL AND II) TO EQUIVALENT .csv FILES WITH CODE OF
C  POPDATA APR_11 (THOSE WITHOUT THE TWO EXTRA COLUMNS). IT READS
C  FILE 67, AND WRITES THE INFORMATION TO SCRATCH FILE 66. NOTE THAT IF
C  THE .csv FILE READ IN ALREADY IS THE OLDER VERSION (WITH CODE 
C  POPDATA APR_11), THIS ROUTINE SIMPLY REWRITES IT TO FILE 66, WHICH IS
C  THEN READ BY SUBROUTINE READBLOCK.

C  THIS ROUTINE IS BASED ON THE STAND-A-LONE PROGRAM, CSVCHANGE.FOR.
C  AS OF IT2B104.FOR, THIS ROUTINE IS BASED ON CSVCHANGE2.FOR.

C  CSVCHANGE.FOR                                           12/6/11

C  THIS PROGRAM CONVERTS THE NEW-STYLE .csv FILES (WITH TWO ADDITIONAL
C  COLUMNS (ADDL AND II) TO THE PREVIOUS .csv FORMAT.

C  ADDL GIVES THE NO. OF ADDITIONAL DOSES FOR ANY DOSE EVENT, AND II
C  GIVES THE INTERDOSE INTERVAL FOR THE ADDITIONAL DOSES.

C  EX: IF TIME = 0, DUR = 2, DOSE = 1000, ADDL = 2, II = 12, THIS
C  PROGRAM WOULD PUT IN TWO EXTRA LINES AS FOLLOWS:

C  TIME    DUR    DOSE  ADDL  II    
C   0       2     1000   2    12  <-- ONLY LINE IN NEW-STYLE FILE
C  12       2     1000   <-- THESE TWO LINES ARE ADDED TO THE OLD
C  24       2     1000       STYLE FILE (WHICH DOESN'T HAVE ADDL AND
C                            II COLUMNS.


C  NOTE THAT ADDL = -1 IS A STEADY STATE DOSE INDICATOR. IN THIS CASE,
C  CHANGE THE TIME OF THE DOSE TO -II, SO SUBROUTINES READBLOCK/WRITEDOS
C  WILL RECOGNIZE THE LINE AS THE BEGINNING OF A STEADY STATE DOSE SET.

C  NOTE THAT ONCE ALL THE ADDITIONAL DOSES ARE ADDED TO THE DOSE
C  ARRAY, THEY MUST ALL BE ORDERED AMONG THEMSELVES (UNTIL THE NEXT
C  DOSE/TIME RESET) SINCE READBLOCK EXPECTS ORDERED DOSES. BUT IT IS
C  OK FOR ALL THE DOSES IN A GIVEN REGION TO COME FIRST, AND THEN ALL
C  THE OBSERVATIONS TO FOLLOW (I.E., THE DOSES SHOULD BE ORDERED AMONG
C  THEMSELVES AND THE OBSERVATIONS FOLLOW THE DOSES, ORDERED AMONG
C  THEMSELVES).

C  NOTE THAT ADDL AND II ENTRIES ARE IGNORED IF EVID = 0 (I.E.,THE
C  EVENT IS AN OBSERVATION).

C  NOTE THAT IF ADDL AND II ARE MISSING FOR A DOSE EVENT (EVID = 1 OR
C  4) THEN ADDL IS ASSUME TO BE 0 (NO ADDITIONAL DOSES) AND II IS
C  IRRELEVANT.

C  NOTE THAT THIS PROGRAM WILL OPEN AND READ THE NEW-STYLE .csv
C  FILE FROM FILE 67, AND THEN WRITE THE PREVIOUS .csv FORMAT TO FILE
C  66.

      IMPLICIT REAL*8(A-H,O-Z)
      DIMENSION TIMENTRY(99999),IDENTRY(99999)

      CHARACTER READLINE*1000,CODEPAT*15,
     1 READLINE2*1000,HOLDMAT(99999)*1000,TIMCHAR*50,SUBID*11,
     2 SUBIDPREV*11,ERRFIL*20

      COMMON/ERROR/ERRFIL
C  COMMON/ERROR/ IS SUPPLIED TO ALL THE ROUTINES WHICH COULD WRITE TO
C  ERRFIL. 



    1 FORMAT(A1000)
    2 FORMAT(A20)

      OPEN(66)

      ICODEPAT = 0


    6 FORMAT(A15)
      ICODEPAT = -1


      READ(67,6) CODEPAT
      IF(CODEPAT .EQ. '"POPDATA DEC_11') ICODEPAT = 1
      IF(CODEPAT(1:14) .EQ. 'POPDATA DEC_11') ICODEPAT = 1

      IF(CODEPAT .EQ. '"POPDATA APR_11') ICODEPAT = 0
      IF(CODEPAT(1:14) .EQ. 'POPDATA APR_11') ICODEPAT = 0


      IF(ICODEPAT .EQ. -1) THEN

       WRITE(*,7)
    7  FORMAT(//' YOUR PATIENT DATA BLOCK FILE IS NOT FROM THE'/
     1' ALLOWABLE SET OF SUCH FILES.'//
     2' A PATIENT DATA BLOCK FILE MUST HAVE "POPDATA XXX_XX IN'/
     3' COLUMNS 1 THROUGH 15 ON LINE 1, WHERE  XXX_XX  IS APR_11 OR A '/
     4' MORE RECENT DATE.'//)
       WRITE(*,*)' THE PROGRAM STOPS.'

        OPEN(42,FILE=ERRFIL)
         WRITE(42,7) 
         WRITE(42,*)' THE PROGRAM STOPS.'
        CLOSE(42)
	


       CALL PAUSE
       STOP

      ENDIF

C  IF ICODEPAT = 0, THE INPUT .csv FILE IS ALREADY IN THE CORRECT FORM
C  TO BE READ BY SUBROUTINE READBLOCK. IN THIS CASE, JUST COPY FILE 67,
C  LINE BY LINE TO FILE 66.

      IF(ICODEPAT .EQ. 0) THEN

C  WRITE THE TOP LINE (WITH THE CODE) TO FILE 66.

       CODEPAT = 'POPDATA APR_11'
       WRITE(66,6) CODEPAT

 1020  READ(67,1,IOSTAT=IEND) READLINE
        IF(IEND .LT. 0) THEN
         CLOSE(67)
         RETURN
        ENDIF
       WRITE(66,1) READLINE
       GO TO 1020

      ENDIF


C  ICODEPAT = 1. SO WRITE THE INFO IN FILE 67 TO FILE 66 IN THE OLD
C  FORMAT (WITHOUT THE TWO COLUMNS FOR ADDL AND II).

C  WRITE THE TOP LINE (WITH THE CODE) TO FILE 66.

      CODEPAT = 'POPDATA APR_11'
      WRITE(66,6) CODEPAT

C  READ THE 2ND LINE OF FILE 67 AND WRITE THIS LINE TO FILE 66, BUT



C  WITHOUT THE ADDL AND II NAMES. 

      READ(67,1) READLINE

C  SEARCH FOR THE CHARACTER STRING  ",ADDL,II"  IN THE EARLY PART OF
C  READLINE AND ELIMINATE IT, BEFORE WRITING THE LINE TO FILE 66. IF
C  THIS STRING IS NOT FOUND, TELL THE USER HIS FILE 67 HAS AN ERROR IN 
C  IT, AND STOP

      DO I = 1,50
       IF(READLINE(I:I+7) .EQ. ',ADDL,II') THEN
        ISS = I
        GO TO 10
       ENDIF
      END DO

C  TO GET HERE MEANS THE ABOVE STRING WAS NEVER FOUND. SO WRITE A 
C  MESSAGE TO THE USER AND STOP.

       WRITE(*,8)
    8  FORMAT(//' YOUR PATIENT DATA BLOCK FILE IS NOT FROM THE '/
     1' ALLOWABLE SET OF SUCH FILES.'//
     2' A PATIENT DATA BLOCK FILE MUST HAVE ",ADDL,II" AS THE 6TH AND'/
     3' 7TH COLUMN HEADINGS ON LINE 2.'//)
       WRITE(*,*)' THE PROGRAM STOPS.'

        OPEN(42,FILE=ERRFIL)


         WRITE(42,8) 
         WRITE(42,*)' THE PROGRAM STOPS.'
        CLOSE(42)
	


       CALL PAUSE
       STOP


   10 CONTINUE

C  PUT ALL OF READLINE, EXCEPT ENTRIES ISS:ISS+7 INTO READLINE2,
C  AND WRITE READLINE2 INTO FILE 66.

      READLINE2(1:ISS-1) = READLINE(1:ISS-1)
      READLINE2(ISS:992) = READLINE(ISS+8:1000)

      WRITE(66,1) READLINE2


C  EACH LINE IN FILE 67, STARTING WITH LINE 3 (EXCEPT FOR LINES 
C  BEGINNING WITH #) HAS A SUBJECT ID IN THE 1ST 11 ENTRIES. THEN
C  THE ENTRIES ARE, IN ORDER, EVID, TIME, DUR, DOSE, ADDL, II, INPUT,
C  ...

C  READ EACH DOSE LINE (EVID = 1 OR 4) TO OBTAIN THE VALUES OF ADDL AND
C  II FOR THOSE. ADDL IS THE NO. OF ADDITIONAL DOSE LINES THAT ARE 
C  IDENTICAL TO THE CURRENT LINE, AND II IS THE ASSOCIATED INTERDOSE

C  INTERVAL. IF ADDL = -1, THIS REPRESENTS A STEADY STATE SET OF DOSES.

C  FOR A DOSE LINE, IF ADDL = 0 OR IS MISSING (WHICH MEANS ADDL IS
C  ASSUMED TO BE 0), WRITE THE LINE, WITHOUT THE ADDL AND II VALUES,
C  INTO HOLDMAT. 

C  FOR EACH DOSE LINE WITH AN ADDL > 0, WRITE THAT LINE
C  WITHOUT THE ADDL AND II VALUES, AND ADDL MORE SIMILAR LINES INTO THE
C  HOLDMAT, MAKING SURE THAT THE TIME FOR EACH SUCCESSIVE LINE
C  IS INCREASED BY II FROM THE PREVIOUS LINE.

C  NOTE THAT THE ABOVE PROCESS CAN CAUSE THE DOSE LINES TO BE OUT OF
C  ORDER IN HOLDMAT. EACH BLOCK OF DOSE LINES WILL BE 
C  ORDERED UP TO THE NEXT DOSE/TIME RESET LINE BELOW. AND NOTE THAT
C  ALL THE DOSES IN EACH REGION (UNTIL THE NEXT TIME RESET LINE - I.E.,
C  UNTIL THE NEXT EVID = 4) WILL BE WRITTEN TOGETHER, AND THEN BE
C  FOLLOWED BY ALL THE OBSERVATION LINES IN THAT REGION).


C  NOTE BELOW THAT AFTERCOMMA OPENS AND PUTS INTO FILE 57 THE PART OF
C  READLINE WHICH IS BETWEEN COMMA C AND COMMA C+1, WHERE C IS THE 3RD
C  ARGUMENT. ALSO,NOTE THAT NCOVA MUST BE PROVIDED TO AFTERCOMMA SO IT
C  WILL KNOW THE TOTAL NO. OF COMMAS IN READLINE, WHICH = 13 + NCOVA 
C  SINCE THIS FILE HAS 14 FIXED FIELDS (COUNTING THE 2 NEWS ONES, 
C  ADDL AND II).
C  
C  SO, FIRST FIND NCOVA FROM READLINE JUST READ IN (THE 2ND LINE OF THE
C  .csv FILE).

        NCOMMA = 0

        DO ISTART = 1,1000	 
         IF(READLINE(ISTART:ISTART) .EQ. ',') THEN
          NCOMMA = NCOMMA + 1
         ENDIF
        END DO

        NCOVA = NCOMMA - 13

C  INITIALIZE SUBIDPREV (THE PREVIOUS SUBJECT ID), AND THE CURRENT
C  SUBJECT TO BE '%^&*'.

	SUBIDPREV = '%^&*'

	SUBID = '%^&*'
      NROW = 0


C  NROW IS THE RUNNING INDEX OF THE NEXT LINE TO BE PUT INTO THE
C  HOLDMAT.


   20 READ(67,1,IOSTAT=IEND) READLINE


C  IF IEND .LT. 0, THE FILE HAS BEEN READ THROUGH COMPLETELY, SO GO TO
C  LABEL 100 TO WRITE THE LAST SUBJECT'S ROWS TO FILE 66.

	IF(IEND .LT. 0) GO TO 100

C  IF READLINE(1:1) IS #, THIS LINE IS A COMMENT LINE AND CAN BE
C  SKIPPED (I.E., NOT WRITTEN INTO HOLDMAT).

      IF(READLINE(1:1) .EQ. '#') GO TO 20


C  WILL ALSO GO TO LABEL 100 IF THIS SUBJECT ID IS DIFFERENT THAN
C  SUBIDPREV (SINCE THAT MEANS THAT THE PREVIOUS SUBJECT'S LINES ARE
C  READY TO BE WRITTEN TO FILE 66).    

C  THE FIRST VALUE (I.E., AFTER COMMA NO. 0) IS THE SUBJECT ID.

	CALL AFTERCOMMA(NCOVA,READLINE,0)
	BACKSPACE(57)
	READ(57,222) SUBID
  222 FORMAT(A11)
	CLOSE(57)

C  NOTE THAT SUBID CONTAINS THE 1ST 11 CHARACTERS OF THE LINE, BUT THE
C  SUBJECT ID IS JUST THE SET OF CHARACTERS PRIOR TO THE 1ST COMMA.
C  CALL SUBROUTINE GETID TO CORRECT THE VALUE OF SUBID.

	CALL GETID(SUBID)

      IF(SUBID .NE. SUBIDPREV) GO TO 100


C  TO GET TO THIS POINT, SUBID = SUBIDPREV, WHICH MEANS THIS IS A
C  LINE FOR THE CURRENT SUBJECT.

C  IF THE EVENT ID, IN ENTRY NO. 2 (I.E., AFTER COMMA NO. 1) IN 
C  READLINE IS 0, THE LINE REPRESENTS AN OBSERVATION AND CAN BE WRITTEN
C  INTO HOLDMAT, EXCEPT FOR ADDL AND II AS DONE ABOVE.



	CALL AFTERCOMMA(NCOVA,READLINE,1)
	BACKSPACE(57)
	READ(57,*,ERR=470) IDEVENT
	CLOSE(57)
      GO TO 480


  470  WRITE(*,471) READLINE(1:75)
  471  FORMAT(/' THERE IS AN ERROR IN YOUR BLOCK FORMAT FILE FOR '/
     1' ONE OF YOUR SUBJECTS. THE EVENT ID IS MISSING. THE 1ST 75'/
     2' CHARACTERS OF THE LINE ARE: '/
     2A75//
     3' THE PROGRAM STOPS.'/)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,471) READLINE(1:75)
        CLOSE(42)	

  	 CALL PAUSE
	 STOP

 480  CONTINUE

      IF(IDEVENT .EQ. 0) THEN
       NROW = NROW + 1
       CALL GETCOM(NCOMMA,READLINE,I5,I7)
       HOLDMAT(NROW) = READLINE(1:I5)//READLINE(I7+1:1000)
      ENDIF

C  IF THE EVENT ID IS 1 OR 4, THE LINE REPRESENTS A DOSE
C  EVENT (1 -> REGULAR DOSE; 4 -> TIME RESET EVENT WITH A DOSE). EITHER
C  WAY IF THE ENTRY FOR ADDL IS MISSING OR A 0, IT MEANS THAT THIS LINE
C  REPRESENTS A SINGLE DOSE. IF ADDL > 0, THIS LINE MUST BE COPIED
C  ADDL TIMES. NOTE THAT THE ADDL ENTRY IS NO. 6, AFTER COMMA NO. 5.

      IF(IDEVENT .EQ. 1 .OR. IDEVENT .EQ. 4) THEN

       CALL AFTERCOMMA(NCOVA,READLINE,5)
       BACKSPACE(57)
       READ(57,*,ERR=25) IADDL
       CLOSE(57)
       GO TO 30

   25  IADDL = 0

C  TO GET TO LABEL 25 MEANS IADDL TRIED TO READ A NON-NUMBER, WHICH 
C  MEANS IT IS MISSING --> IT IS EQUIVALENT TO 0. IN THIS CASE, WRITE
C  THE LINE INTO HOLDMAT, EXCEPT FOR IADDL AND II AS 
C  DONE ABOVE.

   30  CONTINUE
       
       IF(IADDL .GE. 0) THEN
        NROW = NROW + 1
        CALL GETCOM(NCOMMA,READLINE,I5,I7)
        HOLDMAT(NROW) = READLINE(1:I5)//READLINE(I7+1:1000)
       ENDIF

       IF(IADDL .GT. 0) THEN

C  THIS LINE MUST BE COPIED IADDL TIMES, BUT EACH LINE MUST HAVE ITS 
C  TIME ENTRY INCREASED BY XII (THE INTERDOSE INTERVAL) FROM THE 
C  PREVIOUS LINE. FIRST FIND THE VALUE OF XII, IN THE 7TH ENTRY, AFTER
C  THE 6TH COMMA. IF XII IS MISSING, STOP THE PROGRAM TELLING THE USER
C  THAT THE .cvs FILE HAS AN ERROR; IT HAS A ROW WITH AN IADDL > 0, BUT
C  WITH AN ACCOMPANYING INTERDOSE INTERVAL WHICH IS MISSING. NOTE THAT
C  THIS LINE NO. IS 2 (THE TOP 2 LINES) + NROW + 1 = NROW + 3.

	  CALL AFTERCOMMA(NCOVA,READLINE,6)
	  BACKSPACE(57)
	  READ(57,*,ERR=35) XII
	  CLOSE(57)
        GO TO 40
        
   35   WRITE(*,36) NROW + 3
   36   FORMAT(/' THE INTERDOSE INTERVAL IS MISSING ON LINE NO. ',I6//
     1' PLEASE CORRECT YOUR .csv FILE AND RERUN THE PROGRAM.'/)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,36) NROW + 3 
        CLOSE(42)	



        CALL PAUSE
        STOP

   40   CONTINUE

C  THE TIME FOR THE ORIGINAL DOSE IS IN ENTRY NO. 3, AFTER COMMA NO. 2.


	  CALL AFTERCOMMA(NCOVA,READLINE,2)
	  BACKSPACE(57)
	  READ(57,*) TIM
	  CLOSE(57)

        DO IADD = 1,IADDL

C  NOTE THAT THE ORIGINAL LINE FOR THIS DOSE HAS ALREADY BEEN WRITTEN
C  TO HOLDMAT (IN THE IF(IADDL .GE. 0) SECTION ABOVE). SO

C  NOW MUST WRITE IADDL LINES TO HOLDMAT, EACH IDENTICAL TO
C  THE CURRENT LINE, EXCEPT EACH TIM WILL BE INCREMENTED BY
C  XII. TO DO THIS, WRITE THE NEXT TIM + XII TO SCRATCH FILE 57; THEN
C  REREAD THIS VALUE AS A CHARACTER SO IT CAN BE INSERTED INTO
C  THE CHARACTER STRING READLINE AND THEN WRITTEN TO THE HOLDING
C  MATRIX.

C  ... AND ...

C  BUG CORRECTION FOR IT2B109.FOR. EACH REPEATED ROW MUST HAVE IDEVENT
C  SET TO 1. I.E., IF IDEVENT FOR THE ORIGINAL ROW (WHICH IS BEING
C  REPEATED IADDL TIMES) IS 4, THIS IS A TIME RESET EVENT, BUT THE
C  REPEATED ROWS WILL ALL HAVE IDEVENTS OF 1 (OTHERWISE IT WOULD LOOK
C  LIKE REPEATED TIME RESET EVENTS WHICH IS NOT WHAT IS INTENDED).
C  FOR EXAMPLE, IADDL = 3 IN AN IDEVENT = 4 LINE --> THE FIRST LINE IN
C  FILE 66 SHOULD HAVE IDEVENT = 4, BUT THE NEXT TWO LINES MUST HAVE
C  IDEVENT = 1 (I.E., THEY ARE REGULAR DOSE LINES THAT FOLLOW THE
C  IDEVENT = 4 LINE AT TIME INTERVALS OF XII).


C  FIRST RESET READLINE TO HOLDMAT(NROW), WHICH DOES NOT HAVE THE
C  ADDL AND II ENTRIES.

         READLINE(1:1000) = HOLDMAT(NROW)

   	  OPEN(57,STATUS='SCRATCH')
         WRITE(57,*) TIM + XII*IADD
         BACKSPACE(57)
         READ(57,41) TIMCHAR
   41    FORMAT(A50)
        CLOSE(57)

C  TAKE OUT ALL SPACES AT THE END OF TIMCHAR.

         DO IEND = 50,1,-1
          IF(TIMCHAR(IEND:IEND) .NE. ' ') GO TO 50
         END DO

   50    CONTINUE


C  NOW TIMCHAR(1:IEND) IS THE CONDENSED FORM OF THE TIME FOR THIS
C  ROW. REPLACE WHAT IS CURRENTLY BETWEEN COMMAS 2 AND 3 OF 
C  HOLDMAT(NROW) WITH THIS, AND STORE IT INTO THE NEXT ROW OF HOLDMAT.
C  ALSO, DETERMINE I1 = CHARACTER NO. FOR COMMA 1, IN ORDER TO KNOW
C  WHERE TO WRITE THE IDEVENT NO. WHICH WILL ALWAYS BE 1. 

         ICOMMA = 0

         DO I = 1,1000
          IF(READLINE(I:I) .EQ. ',') THEN
           ICOMMA = ICOMMA + 1
           IF(ICOMMA .EQ. 1) I1 = I
           IF(ICOMMA .EQ. 2) I2 = I
           IF(ICOMMA .EQ. 3) THEN
            I3 = I
            GO TO 60
           ENDIF
          ENDIF
         END DO

   60    READLINE2 =
     1    READLINE(1:I1)//'1,'//TIMCHAR(1:IEND)//READLINE(I3:1000)
         NROW = NROW + 1         
         HOLDMAT(NROW) = READLINE2(1:1000)
         
        END DO

C  THE ABOVE END DO IS FOR THE  DO IADD = 1,IADDL  LOOP.


       ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(IADDL .GT. 0)  CONDITION.


       IF(IADDL .EQ. -1) THEN


C  WRITE JUST ONE LINE TO THE NEW .CSV FILE, EVEN THOUGH IADDL = -1
C  REPRESENTS A STEADY STATE DOSE SET OF 100 DOSES. MAKE THE TIME FOR
C  THIS EVENT = -II SO READBLOCK/WRITEDOS WILL KNOW THIS IS A LINE WITH
C  STEADY STATE DOSE INFO.

	  CALL AFTERCOMMA(NCOVA,READLINE,6)
	  BACKSPACE(57)
	  READ(57,*,ERR=65) XII
	  CLOSE(57)
        GO TO 70
        
   65   WRITE(*,36) NROW + 3

        OPEN(42,FILE=ERRFIL)
         WRITE(42,36) NROW + 3 
        CLOSE(42)	


        CALL PAUSE
        STOP

   70   CONTINUE

C  NOW ESTABLISH THE NEXT LINE OF HOLDMAT AS THE CURRENT
C  READLINE, BUT WITHOUT THE ENTRIES FOR ADDL AND II; THEN RESET
C  READLINE TO BE THIS NEW LINE.

        NROW = NROW + 1
        CALL GETCOM(NCOMMA,READLINE,I5,I7)
        HOLDMAT(NROW) = READLINE(1:I5)//READLINE(I7+1:1000)
        READLINE(1:1000) = HOLDMAT(NROW)

C  NOW ESTABLISH READLINE2 = READLINE, BUT WITH THE TIME VALUE RESET
C  TO BE TIME = -XII. TO DO THIS, WRITE -XII TO SCRATCH FILE 57; THEN
C  REREAD THIS VALUE AS A CHARACTER SO IT CAN BE INSERTED INTO
C  THE CHARACTER STRING READLINE AND THEN WRITTEN TO THE HOLDING
C  MATRIX.

   	  OPEN(57,STATUS='SCRATCH')
         WRITE(57,*) -XII
         BACKSPACE(57)
         READ(57,41) TIMCHAR
        CLOSE(57)

C  TAKE OUT ALL SPACES AT THE END OF TIMCHAR.


         DO IEND = 50,1,-1
          IF(TIMCHAR(IEND:IEND) .NE. ' ') GO TO 80
         END DO

   80    CONTINUE

C  NOW TIMCHAR(1:IEND) IS THE CONDENSED FORM OF THE TIME FOR THIS
C  ROW. REPLACE WHAT IS CURRENTLY BETWEEN COMMAS 2 AND 3 OF 
C  HOLDMAT(NROW) WITH THIS, AND STORE IT BACK INTO THE SAME ROW OF 
C  HOLDMAT.

         ICOMMA = 0

         DO I = 1,1000
          IF(READLINE(I:I) .EQ. ',') THEN
           ICOMMA = ICOMMA + 1
           IF(ICOMMA .EQ. 2) I2 = I
           IF(ICOMMA .EQ. 3) THEN
            I3 = I
            GO TO 90
           ENDIF
          ENDIF
         END DO

   90    READLINE2 =
     1    READLINE(1:I2)//TIMCHAR(1:IEND)//READLINE(I3:1000)
         HOLDMAT(NROW) = READLINE2(1:1000)


       ENDIF 

C  THE ABOVE ENDIF IS FOR THE  IF(IADDL .EQ. -1)  CONDITION.


      ENDIF

C  THE ABOVE ENDIF IS FOR THE  
C   IF(IDEVENT .EQ. 1 .OR. IDEVENT .EQ. 4)  CONDITION.


      GO TO 20


  100 CONTINUE

C  AS OF IT2B108.FOR, WRITE LINE TO THE SCREEN TELLING THE USER WHICH
C  SUBJECT IS BEING CONVERTED, IN CASE THERE ARE A LARGE NO. OF PATIENTS
C  WITH A LOT OF DATA. OTHERWISE, THERE COULD BE A LONG "DEAD" TIME ON
C  THE SCREEN MAKING THE PROGRAM LOOK LIKE IT HAS "HUNG".

      WRITE(*,103) SUBID
  103 FORMAT(' EXAMINING .CSV FORMAT FOR SUBJECT  ',A11)


C  THE FIRST TWO LINES OF FILE 66 WERE WRITTEN ABOVE. NOW WRITE THE 
C  REST OF THE FILE.

C  NOTE THAT IN EACH SECTION OF DOSES (I.E., UNTIL THE NEXT IDEVENT 
C  = 4), MUST ORDER THE DOSES SINCE THEY COULD BE OUT OF ORDER DUE TO
C  THE ADDL ENTRY. 

C  FOR EXAMPLE, A DOSE OF T = 0 WITH ADDL = 2 AND II = 12 --> DOSES AT
C  T = 0, 12, AND 24. THEN ANOTHER DOSE (FOR A DIFFERENT DRUG, OR THE
C  SAME DRUG WITH A DIFFERENT ROUTE) COULD OCCUR AT T = 8. THEN, FROM
C  THE ABOVE CODE, THE CURRENT DOSE TIMES WOULD BE [0 12 24 8].

C  SO GO THROUGH THE NROW ROWS OF HOLDMAT, AND ORDER THE ROWS IN EACH
C  SECTION (I.E., UNTL THE NEXT IDEVENT = 4 ROW). IN PARTICULAR, FIRST
C  ORDER THE DOSE ROWS (IDEVENT = 1). IF THESE ROWS FOLLOW AN 
C  IDEVENT = 4 ROW, THAT ROW GOES FIRST OF COURSE. THEN WRITE IN THE
C  OBSERVATION ROWS (THEY SHOULD ALREADY BE IN ORDER).

C  PUT ALL THE IDEVENT ENTRIES IN HOLDMAT INTO IDENTRY(.), AND PUT ALL
C  THE TIME ENTRIES IN HOLDMAT INTO TIMENTRY(.).

      DO I = 1,NROW

       READLINE(1:1000) = HOLDMAT(I)



       CALL AFTERCOMMA(NCOVA,READLINE,1)
	 BACKSPACE(57)
	 READ(57,*,ERR=570) IDEVENT
       CLOSE(57)
       GO TO 580

  570  WRITE(*,471) READLINE(1:75)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,471) READLINE(1:75)
        CLOSE(42)	

  	 CALL PAUSE
	 STOP

 580  CONTINUE



       IDENTRY(I) = IDEVENT
	 CLOSE(57)

       CALL AFTERCOMMA(NCOVA,READLINE,2)
	 BACKSPACE(57)

	 READ(57,*) TIM

       TIMENTRY(I) = TIM
	 CLOSE(57)

      END DO


      NN = 0
      NFIRST = 1

C  NN IS THE RUNNING INDEX OF THE ROW IN HOLDMAT UNDER CONSIDERATION.
C  NFIRST IS THE RUNNING INDEX OF THE FIRST ROW IN THE NEXT SECTION
C  UNDER CONSIDERATION.

  150 CONTINUE

C  ORDER ALL THE ROWS UNTIL THE NEXT IDENTRY(.) = 4, OR UNTIL THE 
C  END OF THE ROWS IS ENCOUNTERED, WHICHEVER COMES FIRST.

      NN = NN + 1
      IF(NN .GT. NROW) GO TO 200

      IF(IDENTRY(NN) .NE. 4 .AND. NN .LT. NROW) GO TO 150

C  ORDER THE ENTRIES IN HOLDMAT FROM NFIRST TO EITHER NROW
C  (IF NN = NROW) OR TO NN-1 (IF IDENTRY(NN) = 4), AND THEN
C  WRITE THEM INTO FILE 66.

      IF(NN .EQ. NROW) NLAST = NROW
      IF(IDENTRY(NN) .EQ. 4) NLAST = NN - 1
      CALL ORDERHOLD(HOLDMAT,NFIRST,NLAST,IDENTRY,TIMENTRY)

C  NOTE THAT SINCE HOLDMAT(I) IS DIMENSIONED 1000, BUT IS LIKELY
C  TO HOLD A LOT FEWER CHARACTERS, TO SAVE SPACE IN FILE 66, 
C  CALL SUBROUTINE CONDENSE2 TO WRITE EACH LINE IN AS OPTIMUM A 
C  WAY AS POSSIBLE.

      DO I = NFIRST,NLAST
       CALL CONDENSE2(HOLDMAT(I))
      END DO      

      NFIRST = NLAST + 1

      GO TO 150
   
  200 CONTINUE

C  IF FILE 67 HAS BEEN COMPLETELY READ, RETURN.

	IF(IEND .LT. 0) THEN
       CLOSE(67)
       RETURN
      ENDIF


C  SINCE IEND .GE. 0, THE FILE HAS NOT BEEN COMPLETELY READ. SO, RESET
C  SUBIDPREV = SUBID AND NROW TO BE 0, AND BACKSPACE FILE 67 SINCE THE
C  FIRST LINE FOR THE NEXT SUBJECT WAS ALREADY READ (I.E., THE NEXT
C  READ OF FILE 67 SHOULD REREAD THIS FIRST LINE) AND GO BACK TO LABEL
C  20 TO CONTINUE READING THE FILE.

      SUBIDPREV = SUBID
      NROW = 0

      BACKSPACE(67)
      GO TO 20


      END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
      SUBROUTINE GETCOM(NCOMMA,READLINE,I5,I7)

      CHARACTER READLINE*1000,ERRFIL*20

      COMMON/ERROR/ERRFIL
C  COMMON/ERROR/ IS SUPPLIED TO ALL THE ROUTINES WHICH COULD WRITE TO
C  ERRFIL. 


C  GETCOM IS CALLED BY CSVCHANGE TO FIND THE ENTRY NO. FOR COMMA NO. 5
C (I5), AND THE ENTRY FOR COMMA NO. 7 (I7).

    1 FORMAT(A1000)
 
      ICOMMA = 0

      DO I = 1,300
       IF(READLINE(I:I) .EQ. ',') THEN
        ICOMMA = ICOMMA + 1
         IF(ICOMMA .EQ. 5) I5 = I
          IF(ICOMMA .EQ. 7) THEN
           I7 = I
           RETURN
          ENDIF
       ENDIF
      END DO

C  TO GET TO THIS POINT MEANS THAT READLINE DOESN'T HAVE 7 COMMAS IN
C  IT. REPORT THIS ERROR TO THE USER AND STOP.

      WRITE(*,2) NCOMMA,READLINE(1:70)
    2 FORMAT(/' ONE OF THE LINES IN YOUR .cvs FILE HAS AN ERROR.'/
     1' IT IS SUPPOSED TO HAVE ',I2,' COMMAS, BUT IT HAS FEWER THAN'/
     2' 7. THE FOLLOWING LINE SHOWS THE 1ST 70 CHARACTERS OF THE LINE:'/
     3' ',A70//
     4' THE PROGRAM STOPS.'/)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,2) NCOMMA,READLINE(1:70)
        CLOSE(42)
	


      CALL PAUSE
      STOP
    
      END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
      SUBROUTINE ORDERHOLD(HOLDMAT,NFIRST,NLAST,IDENTRY,TIMENTRY)

      IMPLICIT REAL*8(A-H,O-Z)

      DIMENSION TIMENTRY(99999),IDENTRY(99999),IZ(99999),IZZ(99999),
     1 DOSTIME(99999)
      CHARACTER HOLDMAT(99999)*1000,HOLDMAT2(99999)*1000

C  ORDER THE ENTRIES IN HOLDMAT FROM NFIRST TO NLAST, AS FOLLOWS:

C  1. PUT ALL THE DOSE EVENTS (IDENTRY(.) = 1 OR 4) FIRST, ORDERED BY
C  INCREASING TIMENTRY(.).

C  2. PUT ALL THE OBSERVATION EVENTS (IDENTRY(.) = 0) AFTER THE DOSE
C  EVENTS (THEY SHOULD ALREADY BE ORDERED).


C  FIRST, STORE THE DOSE ROWS FROM NFIRST TO NLAST IN HOLDMAT TO 
C  HOLDMAT2, STARTING AT ROW 1 IN HOLDMAT2.

C  ALSO, PUT ALL THE DOSE EVENTS TIMES INTO DOSTIME, AND INITIALIZE
C  VECTOR IZ TO BE -99 IN ALL ITS NDOSE LOCATIONS

      NDOSE = 0

      DO I = NFIRST,NLAST
       IF(IDENTRY(I) .EQ. 1 .OR. IDENTRY(I) .EQ. 4) THEN
        NDOSE = NDOSE + 1
        HOLDMAT2(NDOSE) = HOLDMAT(I)
        DOSTIME(NDOSE) = TIMENTRY(I)
        IZ(NDOSE) = -99
       ENDIF
      END DO

C  NOW, FOR EXAMPLE, IF ENTRY 17 IS THE SMALLEST VALUE IN DOSTIME,
C  IZ(17) WILL BE SET = 0, AND THE PROGRAM WILL KNOW NOT TO CHECK THE
C  17TH ENTRY AGAIN (SINCE IT HAS ALREADY BEEN SELECTED). IF THE NEXT
C  SMALLEST ENTRY HAS INDEX 37, THEN IZ(37) WILL BE SET = 0, ETC.

C  NOTE THAT IZZ WILL BE THE ARRAY WHICH CONTAINS THE ACTUAL ORDERING.
C  IN THE EXAMPLE ABOVE, IZZ(1) = 17, IZZ(2) = 37. IT WILL BE EASY TO
C  ASSIGN ORDERED VALUES BACK INTO HOLDMAT USING IZZ. IN THE EXAMPLE
C  ABOVE, HOLDMAT(1) WILL HAVE DOSE TIME = DOSTIME(IZZ(1)) =
C  DOSTIME(17); HOLDMAT(2) WILL HAVE DOSE TIME = DOSTIME(IZZ(2)) =
C  DOSTIME(37); ETC.


C  NOW PUT THE OBSERVATION ROWS FROM NFIRST TO NLAST IN HOLDMAT TO
C  HOLDMAT2, STARTING AT ROW NDOSE + 1 IN HOLDMAT2.

      NEXT = NDOSE

      DO I = NFIRST,NLAST
       IF(IDENTRY(I) .EQ. 0) THEN
        NEXT = NEXT + 1
        HOLDMAT2(NEXT) = HOLDMAT(I)
       ENDIF
      END DO


C  NOW ORDER THE FIRST NDOSE ROWS IN HOLDMAT2 ACCORDING TO THE DOSE
C  TIMES, LOW TO HIGH.

	 DO IPLACE = 1,NDOSE

C  PUT THE NEXT LOWEST VALUE OF DOSTIME INTO THE IPLACE LOCATION OF
C  IZZ.

C  TEMP IS THE RUNNING VALUE OF THE NEXT VALUE TO BE PLACED INTO 
C  DOSTIME. INITIALIZE IT TO BE VERY HIGH VALUE SO THE FIRST VALUE 
C  OF DOSTIME WILL BE SURE TO BE LOWER THAN IT IS.

	  TEMP = 1.D50

	  DO I=1,NDOSE
	   IF(DOSTIME(I) .LT. TEMP .AND. IZ(I) .EQ. -99) THEN
	    TEMP = DOSTIME(I)
	    IND = I
	   ENDIF
	  END DO

C  AT THIS POINT, IND IS THE INDEX OF THE SMALLEST REMAINING VALUE
C  (TEMP) IN DOSTIME. PUT THIS INFORMATION INTO IZZ. ALSO, SET
C  IZ(IND) = 0 --> THE IND LOCATION IN DOSTIME HAS BEEN USED.

	  IZZ(IPLACE) = IND
	  IZ(IND) = 0

	 END DO

C  AT THIS POINT IZZ CONTAINS THE ORDERED INDICES (LOW TO HIGH) OF THE
C  NDOSE VALUES IN DOSTIME, AND SO GIVES THE ORDER THAT THE NDOSE ROWS
C  NOW IN HOLDMAT2 SHOULD BE WRITTEN.

C  WRITE THESE NDOSE DOSE ROWS IN THE CORRECT ORDER INTO HOLDMAT, AND
C  THEN WRITE THE REMAINING ROWS (OBSERVATION ROWS) INTO HOLDMAT. 

      DO IDOSE = 1,NDOSE
       HOLDMAT(NFIRST-1+IDOSE) = HOLDMAT2(IZZ(IDOSE))
      END DO

C  STORE THE OBSERVATION ROWS INTO ENTRIES NFIRST + NDOSE,..., NLAST OF
C  HOLDMAT. THEY WERE STORED INTO THE LAST NOBS ROWS OF HOLDMAT2 ABOVE. 

      NEXT = NDOSE

      DO IOBS = NFIRST + NDOSE,NLAST
       NEXT = NEXT + 1
       HOLDMAT(IOBS) = HOLDMAT2(NEXT)
      END DO
     
       
      RETURN
      END

C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
      SUBROUTINE CONVERTCSV
      IMPLICIT REAL*8(A-H,O-Z)
      CHARACTER READLINE*1000,ERRFIL*20

      COMMON/ERROR/ERRFIL
C  COMMON/ERROR/ IS SUPPLIED TO ALL THE ROUTINES WHICH COULD WRITE TO
C  ERRFIL. 



C  SUBROUTINE CONVERTCSV READS FILE 87 AND WRITES SCRATCH FILE 77.
C  IF FILE 87 IS ALREADY IN THE TYPICAL "AMERICAN" .CSV FORMAT, 
C  FILE 77 IS THE SAME AS FILE 87. 

C  IF FILE 87 IS IN THE "EUROPEAN" .CSV FORMAT, WHERE SEMICOLONS
C  ARE THE FIELD SEPARATORS, AND COMMAS ARE USED TO SEPARATE THE
C  WHOLE AND FRACTIONAL PARTS OF NUMBERS, IT WILL BE WRITTEN TO
C  FILE 77 WITH THE INDICATED CHANGES BELOW.


C  FILE 87 IS AT LINE 1. READ PAST THIS LINE TO READ LINE 2 AND CHECK
C  FOR A SEMICOLON. IF ONE IS FOUND, THEN THIS IS A "EUROPEAN" VERSION OF
C  A .CSV FILE. NOTE THAT IT IS ONLY NECESSARY TO CHECK THE FIRST FEW
C  CHARACTERS OF THIS LINE - EITHER THERE WILL BE COMMAS OR SEMICOLONS.
C  IF THERE ARE BOTH COMMAS AND SEMICOLONS, SOMETHING IS WRONG WITH THE
C  FILE; IN THIS CASE, PRINT A MESSAGE TO THE USER AND STOP.
C  NOTE THAT, EVEN IN THE "EURO" VERSION, IT WILL STILL BE ASSUMED THAT
C  A DOT REPRESENTS AN UNNEEDED VALUE.

        READ(87,*)
        READ(87,4) READLINE

        ICOMMA = 0
        ISEMICOLON = 0

        DO I = 1,20
         IF(READLINE(I:I) .EQ. ',') ICOMMA = 1
         IF(READLINE(I:I) .EQ. ';') ISEMICOLON = 1

        END DO

C  IF ICOMMA = 1 AND ISEMICOLON = 0, NO CONVERSION IS NEEDED AS THIS
C  FILE IS A TYPICAL .CSV FILE. IN THIS CASE SET ICONVERT = 0.

C  IF ICOMMA = 0 AND ISEMICOLON = 1, CONVERT THIS FILE AS FOLLOWS:
C  a. CHANGE ALL COMMAS TO PERIODS; THEN
C  b. CHANGE ALL SEMICOLONS TO COMMAS.
C  IN THIS CASE, SET ICONVERT = 1.

C  IF ICOMMA = 1 AND ISEMICOLON = 1, STOP THE PROGRAM WITH A MESSAGE TO
C  THE USER.

        IF(ICOMMA .EQ. 1 .AND. ISEMICOLON .EQ. 1) THEN



         WRITE(*,121)
  121    FORMAT(/' YOUR .CSV FILE HAS BOTH COMMAS AND SEMICOLONS IN '/
     1' THE SECOND LINE. THIS IS A CONFLICT. IF YOU ARE USING THE '/
     2' "EUROPEAN" VERSION OF A .CSV FILE, WITH SEMICOLONS AS FIELD'/
     3' SEPARATORS AND COMMAS TO SEPARATE THE WHOLE AND FRACTIONAL'/
     4' PARTS OF NUMBERS, THERE SHOULD BE NO COMMAS IN THE SECOND'/
     5' LINE.'//
     6' SIMILARLY IF YOU ARE USING THE "AMERICAN" VERSION OF A .CSV'/
     7' FILE, WITH COMMAS AS FIELD SEPARATORS, AND PERIODS TO SEPARTE'/
     8' THE WHOLE AND FRACTIONAL PARTS OF NUMBERS, THERE SHOULD BE NO'/
     9' SEMICOLONS IN THE SECOND LINE.'//
     1' PLEASE CORRECT YOUR .CSV FILE AND RERUN THE PROGRAM.'//)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,121) 
        CLOSE(42)	




         CALL PAUSE

         STOP



        ENDIF


        IF(ICOMMA .EQ. 1 .AND. ISEMICOLON .EQ. 0) ICONVERT = 0
        IF(ICOMMA .EQ. 0 .AND. ISEMICOLON .EQ. 1) ICONVERT = 1      

        REWIND(87)
        OPEN(77)


C  COPY FILE 87 TO FILE 77 BUT MAKE THE INDICATED CHANGES, IF
C  ICONVERT = 1, LINE BY LINE.


   10   READ(87,4,IOSTAT=IEND) READLINE
    4   FORMAT(A1000)
        IF(IEND .LT. 0) GO TO 100

C  FOR THIS LINE, READLINE, FIND IENDL, THE LAST CHARACTER WHICH IS NOT
C  BLANK. THEN ONLY CHARACTERS 1:IENDL WILL BE WRITTEN TO FILEOUT.

        DO IENDL = 1000,1,-1
         IF(READLINE(IENDL:IENDL) .NE. ' ') GO TO 20
        END DO

   20   CONTINUE

        DO I = 1,IENDL
         IF(ICONVERT .EQ. 1) THEN
          IF(READLINE(I:I) .EQ. ',') READLINE(I:I) = '.'
          IF(READLINE(I:I) .EQ. ';') READLINE(I:I) = ','
         ENDIF
        END DO


C  CANNOT USE WRITE(77,4) READLINE(1:IENDL) SINCE, FOR SOME REASON,
C  WRITING LIKE THIS "RIGHT JUSTIFIES" THE CHARACTERS AT THE END
C  OF THE A1000 FORMAT. INSTEAD MUST WRITE (77,__) READLINE, WHERE
C  THE FORMAT IS DETERMINED BY THE LAST NON-BLANK CHARACTER (IENDL)
C  IN READLINE.

	IF(IENDL .LE. 26) THEN
	 WRITE(77,26) READLINE
   26    FORMAT(A26)
	 GO TO 10
	ENDIF


	IF(IENDL .LE. 51) THEN
	 WRITE(77,51) READLINE
   51    FORMAT(A51)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 76) THEN
	 WRITE(77,76) READLINE
   76    FORMAT(A76)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 101) THEN

	 WRITE(77,101) READLINE
  101    FORMAT(A101)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 126) THEN
	 WRITE(77,126) READLINE
  126    FORMAT(A126)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 151) THEN
	 WRITE(77,151) READLINE

  151    FORMAT(A151)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 176) THEN
	 WRITE(77,176) READLINE
  176    FORMAT(A176)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 201) THEN
	 WRITE(77,201) READLINE
  201    FORMAT(A201)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 226) THEN
	 WRITE(77,226) READLINE
  226    FORMAT(A226)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 251) THEN
	 WRITE(77,251) READLINE
  251    FORMAT(A251)

	 GO TO 10
	ENDIF

	IF(IENDL .LE. 276) THEN
	 WRITE(77,276) READLINE
  276    FORMAT(A276)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 301) THEN
	 WRITE(77,301) READLINE
  301    FORMAT(A301)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 326) THEN
	 WRITE(77,326) READLINE
  326    FORMAT(A326)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 351) THEN
	 WRITE(77,351) READLINE
  351    FORMAT(A351)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 376) THEN
	 WRITE(77,376) READLINE
  376    FORMAT(A376)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 401) THEN
	 WRITE(77,401) READLINE
  401    FORMAT(A401)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 426) THEN
	 WRITE(77,426) READLINE
  426    FORMAT(A426)
	 GO TO 10
	ENDIF


	IF(IENDL .LE. 451) THEN
	 WRITE(77,451) READLINE
  451    FORMAT(A451)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 476) THEN

	 WRITE(77,476) READLINE
  476    FORMAT(A476)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 501) THEN
	 WRITE(77,501) READLINE
  501    FORMAT(A501)
	 GO TO 10
	ENDIF


	IF(IENDL .LE. 526) THEN

	 WRITE(77,526) READLINE
  526    FORMAT(A526)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 551) THEN
	 WRITE(77,551) READLINE
  551    FORMAT(A551)
	 GO TO 10
	ENDIF



	IF(IENDL .LE. 576) THEN
	 WRITE(77,576) READLINE
  576    FORMAT(A576)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 601) THEN
	 WRITE(77,601) READLINE
  601    FORMAT(A601)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 626) THEN
	 WRITE(77,626) READLINE
  626    FORMAT(A626)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 651) THEN
	 WRITE(77,651) READLINE
  651    FORMAT(A651)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 676) THEN
	 WRITE(77,676) READLINE
  676    FORMAT(A676)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 701) THEN
	 WRITE(77,701) READLINE
  701    FORMAT(A701)
	 GO TO 10

	ENDIF

	IF(IENDL .LE. 726) THEN
	 WRITE(77,726) READLINE
  726    FORMAT(A726)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 751) THEN
	 WRITE(77,751) READLINE
  751    FORMAT(A751)
	 GO TO 10

	ENDIF

	IF(IENDL .LE. 776) THEN
	 WRITE(77,776) READLINE

  776    FORMAT(A776)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 801) THEN
	 WRITE(77,801) READLINE
  801    FORMAT(A801)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 826) THEN
	 WRITE(77,826) READLINE
  826    FORMAT(A826)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 851) THEN
	 WRITE(77,851) READLINE
  851    FORMAT(A851)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 876) THEN
	 WRITE(77,876) READLINE
  876    FORMAT(A876)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 901) THEN
	 WRITE(77,901) READLINE
  901    FORMAT(A901)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 926) THEN
	 WRITE(77,926) READLINE
  926    FORMAT(A926)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 951) THEN
	 WRITE(77,951) READLINE
  951    FORMAT(A951)


	 GO TO 10
	ENDIF


	IF(IENDL .LE. 976) THEN
	 WRITE(77,976) READLINE
  976    FORMAT(A976)
	 GO TO 10
	ENDIF

	WRITE(77,4) READLINE
	GO TO 10


  100   CLOSE(87)
        REWIND(77)

        RETURN
        END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
        SUBROUTINE CONDENSE2(READLINE)
        CHARACTER READLINE*1000        

C  SUBROUTINE CONDENSE2 IS CALLED BY SUBROUTINE CSVCHANGE TO WRITE 
C  READLINE WITH AS SMALL A FORMAT AS POSSIBLE (WITHIN 25 CHARACTERS) 
C  TO FILE 66

C  FOR THIS LINE, READLINE, FIND IEND, THE LAST CHARACTER WHICH IS NOT
C  BLANK. THEN ONLY CHARACTERS 1:IEND WILL BE WRITTEN TO FILE 66.


	DO IEND = 1000,1,-1
	 IF(READLINE(IEND:IEND) .NE. ' ') GO TO 20
	END DO

   20   CONTINUE

C  CANNOT USE WRITE(66,_) READLINE(1:IEND) SINCE, FOR SOME REASON,
C  WRITING LIKE THIS "RIGHT JUSTIFIES" THE CHARACTERS AT THE END
C  OF THE A1000 FORMAT. INSTEAD MUST WRITE (66,__) READLINE, WHERE
C  THE FORMAT IS DETERMINED BY THE LAST NON-BLANK CHARACTER (IEND)
C  IN READLINE.


	IF(IEND .LE. 26) THEN
	 WRITE(66,26) READLINE
   26    FORMAT(A26)
	 RETURN

	ENDIF

	IF(IEND .LE. 51) THEN
	 WRITE(66,51) READLINE
   51    FORMAT(A51)
	 RETURN
	ENDIF

	IF(IEND .LE. 76) THEN
	 WRITE(66,76) READLINE
   76    FORMAT(A76)
	 RETURN
	ENDIF


	IF(IEND .LE. 101) THEN
	 WRITE(66,101) READLINE
  101    FORMAT(A101)
	 RETURN
	ENDIF

	IF(IEND .LE. 126) THEN
	 WRITE(66,126) READLINE
  126    FORMAT(A126)
	 RETURN
	ENDIF

	IF(IEND .LE. 151) THEN
	 WRITE(66,151) READLINE
  151    FORMAT(A151)
	 RETURN
	ENDIF

	IF(IEND .LE. 176) THEN

	 WRITE(66,176) READLINE
  176    FORMAT(A176)
	 RETURN
	ENDIF

	IF(IEND .LE. 201) THEN
	 WRITE(66,201) READLINE
  201    FORMAT(A201)
	 RETURN
	ENDIF

	IF(IEND .LE. 226) THEN
	 WRITE(66,226) READLINE

  226    FORMAT(A226)
	 RETURN
	ENDIF


	IF(IEND .LE. 251) THEN
	 WRITE(66,251) READLINE
  251    FORMAT(A251)

	 RETURN
	ENDIF

	IF(IEND .LE. 276) THEN
	 WRITE(66,276) READLINE
  276    FORMAT(A276)
	 RETURN
	ENDIF

	IF(IEND .LE. 301) THEN
	 WRITE(66,301) READLINE
  301    FORMAT(A301)
	 RETURN
	ENDIF

	IF(IEND .LE. 326) THEN
	 WRITE(66,326) READLINE
  326    FORMAT(A326)
	 RETURN
	ENDIF

	IF(IEND .LE. 351) THEN
	 WRITE(66,351) READLINE
  351    FORMAT(A351)
	 RETURN
	ENDIF

	IF(IEND .LE. 376) THEN
	 WRITE(66,376) READLINE
  376    FORMAT(A376)
	 RETURN
	ENDIF

	IF(IEND .LE. 401) THEN
	 WRITE(66,401) READLINE

  401    FORMAT(A401)
	 RETURN
	ENDIF

	IF(IEND .LE. 426) THEN
	 WRITE(66,426) READLINE
  426    FORMAT(A426)
	 RETURN
	ENDIF

	IF(IEND .LE. 451) THEN
	 WRITE(66,451) READLINE
  451    FORMAT(A451)
	 RETURN
	ENDIF

	IF(IEND .LE. 476) THEN

	 WRITE(66,476) READLINE
  476    FORMAT(A476)
	 RETURN
	ENDIF

	IF(IEND .LE. 501) THEN
	 WRITE(66,501) READLINE
  501    FORMAT(A501)
	 RETURN
	ENDIF

	IF(IEND .LE. 526) THEN
	 WRITE(66,526) READLINE
  526    FORMAT(A526)
	 RETURN
	ENDIF

	IF(IEND .LE. 551) THEN
	 WRITE(66,551) READLINE
  551    FORMAT(A551)
	 RETURN
	ENDIF

	IF(IEND .LE. 576) THEN
	 WRITE(66,576) READLINE
  576    FORMAT(A576)
	 RETURN
	ENDIF


	IF(IEND .LE. 601) THEN
	 WRITE(66,601) READLINE
  601    FORMAT(A601)
	 RETURN
	ENDIF

	IF(IEND .LE. 626) THEN
	 WRITE(66,626) READLINE
  626    FORMAT(A626)
	 RETURN
	ENDIF

	IF(IEND .LE. 651) THEN
	 WRITE(66,651) READLINE
  651    FORMAT(A651)
	 RETURN
	ENDIF

	IF(IEND .LE. 676) THEN
	 WRITE(66,676) READLINE
  676    FORMAT(A676)
	 RETURN
	ENDIF


	IF(IEND .LE. 701) THEN
	 WRITE(66,701) READLINE
  701    FORMAT(A701)
	 RETURN
	ENDIF


	IF(IEND .LE. 726) THEN
	 WRITE(66,726) READLINE
  726    FORMAT(A726)
	 RETURN
	ENDIF

	IF(IEND .LE. 751) THEN
	 WRITE(66,751) READLINE

  751    FORMAT(A751)
	 RETURN
	ENDIF


	IF(IEND .LE. 776) THEN

	 WRITE(66,776) READLINE
  776    FORMAT(A776)
	 RETURN
	ENDIF

	IF(IEND .LE. 801) THEN
	 WRITE(66,801) READLINE
  801    FORMAT(A801)
	 RETURN
	ENDIF

	IF(IEND .LE. 826) THEN

	 WRITE(66,826) READLINE
  826    FORMAT(A826)
	 RETURN
	ENDIF


	IF(IEND .LE. 851) THEN
	 WRITE(66,851) READLINE
  851    FORMAT(A851)
	 RETURN
	ENDIF

	IF(IEND .LE. 876) THEN
	 WRITE(66,876) READLINE
  876    FORMAT(A876)
	 RETURN
	ENDIF

	IF(IEND .LE. 901) THEN
	 WRITE(66,901) READLINE
  901    FORMAT(A901)
	 RETURN
	ENDIF

	IF(IEND .LE. 926) THEN
	 WRITE(66,926) READLINE
  926    FORMAT(A926)
	 RETURN
	ENDIF

	IF(IEND .LE. 951) THEN
	 WRITE(66,951) READLINE
  951    FORMAT(A951)
	 RETURN
	ENDIF

	IF(IEND .LE. 976) THEN
	 WRITE(66,976) READLINE
  976    FORMAT(A976)
	 RETURN
	ENDIF

	WRITE(66,4) READLINE
    4    FORMAT(A1000)
        RETURN

        END







