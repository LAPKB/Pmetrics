C
C wmy20190326
C
C Major changes
C 01. dvode_v1.f90, 0blasnpag.f, and emint_b01.f, are linked to
C     this code at compile time (SIMrun.R)
C 02. several subroutines common with NPAG are moved to npag_utils.f90
C 03. some PARAMETERized integers from npag_utils.mod are used for
C     dimensioning
C

C-----------------------------------------------------------------------

C  MONT114.FOR                                             3/25/16

C  MONT114 HAS THE FOLLOWING CHANGES FROM MONT113:

C  1. SUBROUTINE GETNUMEQ IS MADE MORE EFFICIENT. THE CODE THERE TO READ
C  NUMEQT WAS A VERSION OF OTHER CODE WHICH NEEDED TO READ MORE VALUES
C  IN THE PATIENT'S DATA FILE IN ADDITION TO JUST NUMEQT. NOW THE 
C  UNNEEDED CODE IS REMOVED. THIS ALSO REMOVES A SUBTLE POTENTIAL "BUG" 
C  BECAUSE ARRAY XX() IS NO LONGER ESTABLISHED (WHICH IS GOOD SINCE 
C  XX(14) COULD HAVE BEEN ASKED TO STORE AS MANY AS 34 VALUES FOR 
C  PATIENT DATA FILES WITH LOTS OF COVARIATES AND/OR DRUGS).

C  2. SUBROUTINE INOUT IS CHANGED SO THAT THE PATIENT NAME OF EACH
C  SUBJECT HAS THE SUBJECT NO. IN IT. PREVIOUSLY, ALL SIMULATED
C  SUBJECTS HAD THE SAME NAME, "WhoopteeDo Yowza". THIS CAUSES A 
C  PROBLEM IF A WORKTOCSV PROGRAM MAKES A .CSV FILE FROM THESE 
C  SIMULATED SUBJECTS, SINCE THEN THE .CSV FILE LOOKS LIKE IT
C  CONSISTS OF JUST 1 SUBJECT. THIS HAPPENED WHEN QMZJPZQX.CSV WAS MADE
C  BY IT2B114.FOR BY SUBROUTINE WORKTOCSV AND ALL THE PATIENT NAMES WERE
C  THE SAME, "WhoopteeDo Yowza"... AND THEN THIS FILE WAS PUT INTO
C  FROMxxxx, WHICH WAS NOT READ PROPERLY BY NPAG120.FOR BECAUSE IT
C  LOOKED AS IF IT CONSISTED OF JUST 1 PATIENT).

C-----------------------------------------------------------------------

C  MONT113.FOR                                             12/16/15

C  MONT113 HAS THE FOLLOWING CHANGES FROM MONT112:

C  1. THIS PROGRAM IS NOW COMPATIBLE WITH THE NEW VERSION 43 OUTPUT FILE
C  MADE BY THE NEW NPAG PROGRAM (NPAG119.FOR/npagranfix5.f), WHICH HAS
C  NRANFIX PARAMETERS.

C  2. XVERIFY IS DIMENSIONED 900 INSTEAD OF 200 (IN 10 ROUTINES). 
C  ACTUALLY, IT ONLY NEEDS TO BE DIMENSIONED THE LARGEST DIMENSION OF 
C  ANY ARRAY IT STORES, WHICH IS 594. THIS BUG WAS NOT DISCOVERED 
C  UNTIL THIS PROGRAM WAS RUN WITH A TEMPLATE PATIENT FILE WHICH HAD
C  311 OBSERVED VALUES. 

C-----------------------------------------------------------------------

C  MONT112.FOR                                             4/27/15

C  MONT112 HAS THE FOLLOWING CHANGES FROM MONT111:

C  1. ALL NUMBERS WRITTEN OUT IN F OR G FORMAT ARE NOT TESTED TO SEE IF
C  THEY ARE INSIDE [-1.D-99, 1.D-99]. IF SO, THEY ARE CHANGED TO BE 0.
C  THE REASON IS THAT OTHERWISE THEY WILL BE PRINTED OUT WITHOUT THE
C  ACCOMPANYING D OR E (E.G., AS .934-106, RATHER THAN .934E=106).

C  NOTE THAT A NEW SUBROUTINE VERIFYVAL IS ADDED TO THE CODE TO DO THE
C  INDICATED TESTING ABOVE.

C  2. A SLIGHT BUG IS CORRECTED IN FORMAT 5001. "TSTMULTI.FOR" IS 
C  CHANGED TO BE "TSTMULTM.FOR". NOTE THAT THIS PROGRAM IS NOT LINKED 
C  WITH TSTMULTN.FOR SINCE IT WON'T BE RUN IN PARALLEL. 

C  3. BELOW FORMAT 38 IN MAIN, ERR=145 IS ADDED, SO THE PROGRAM WILL
C  REPEAT THE WRITING OF FORMAT 38 IF THE USER ENTERS A NON-NUMBER.
C  THIS IS AN IMPROVEMENT OVER BOMBING, WHICH WOULD OCCUR OTHERWISE.

C-----------------------------------------------------------------------

C  MONT111.FOR                                             9/14/14

C  MONT111 HAS A BUG FIX TO MONT110. PREVIOUSLY, IN SUBROUTINE 
C  COVSTRING, THE PARAMETER ILAST WAS NOT ESTABLISHED IF NCOVA = 1. THE
C  RESULT WAS THAT IT WOULD REMAIN SET TO A RANDOM NUMBER IN THIS CASE.
C  AND CAUSED THE PROGRAM TO RETURN A RANDOM VALUE FOR THE PARAMETER
C  NCOVTIGHT TO SUBROUTINE WORKTOCSV, WHICH THEN WOULD STORE SPURIOUS
C  CHARACTERS TO TOPLINE. THIS DID NOT AFFECT THIS PROGRAM, BUT COULD
C  CAUSE THE IT2B OR NPAG PROGRAM WHICH READS THE RESULTANT .CSV FILE
C  TO READ JUNK CHARACTERS AND BOMB.

C  THE FIX IS TO SET ILAST = 1 IF NCOVA = 1 IN SUBROUTINE COVSTRING.

C-----------------------------------------------------------------------

C  MONT110.FOR                                             8/28/14

C  MONT110 HAS THE FOLLOWING CHANGES FROM MONT109:

C  1. SUBROUTINE NEWWORK1 IS MODIFIED SO THAT A STEADY STATE REGIMEN 
C  NOW TRANSLATES TO 101 DOSE SETS, RATHER THAN 100. THE EFFECT IS 
C  THAT IF, FOR EXAMPLE, A PATIENT HAS AN OBSERVATION AT TIME T = 2 HRS.
C  AFTER A STEADY STATE REGIMEN WITH AN INTER-DOSE INTERVAL (II) OF
C  24 HOURS, THIS OBSERVATION WILL NOW BE 2 HOURS AFTER THE BEGINNING OF
C  THE LAST (THE 101ST) DOSE SET, AS OPPOSED TO 26 HOURS (AFTER THE 
C  100TH DOSE SET IN THE PREVIOUS PROGRAM).

C  ALSO NOTE THAT AN EXTRA CHECK IS PUT INTO SUBROUTINE NEWWORK1 TO
C  MAKE SURE THAT NO TWO DOSE TIMES ARE THE SAME. THIS COULD HAPPEN,
C  FOR EXAMPLE, IF THE 101ST DOSE SET OF A STEADY STATE DOSE REGIMEN
C  HAD AN ENDING IV TIME OF 3 HOURS, AND THE FIRST NON-STEADY-STATE
C  IV DOSE FOLLOWING STARTED AT T = 3 HOURS. HAVING TWO DOSE TIMES WHICH
C  ARE THE SAME CAN CONFUSE THE LOGIC IN SUBROUTINE SHIFT, AND CAUSE
C  IT TO GET INTO AN INFINITE LOOP (see NPAG115.EXP, TESTCASE 5).

C  2. AN BUG IS FIXED IN SUBROUTINE READBLOCK2. FORMAT 106 IS CORRECTED
C  TO HAVE NOUT WRITTEN, INSTEAD OF NOU.

C  3. A BUG IS FIXED IN SUBROUTINE FUNC2. THE CLOSE(42) LINE IS MOVED
C  BELOW THE DO I = 1,ND LOOP (SINCE FILE 42 IS STILL BEING ACCESSED
C  IN THAT LOOP).

C  4. A SUBTLE BUG IS FIXED IN SUBROUTINE WRITECSV. IT OCCURRED WHEN A
C  STEADY STATE DOSE SET FOLLOWED A DOSE WITH AN IV WHICH WAS NOT
C  TURNED OFF. SEE NPAG115.EXT FOR DETAILS ON THE TESTCASE WHICH
C  REVEALED THE BUG. 

C  NOTE THAT TEST109.FOR IS THE VERSION OF MONT109.FOR WITH THE CODE
C  CORRECTED IN SUBROUTINE WRITECSV.

C  5. FORMATS 919 AND 5001 HAVE BEEN CHANGED TO REFLECT THAT THE
C  TEMPLATE MODEL FILE IS NOW TSTMULTM.FOR, RATHER THAN TSTMULTI.FOR.

C-----------------------------------------------------------------------

C  MONT109.FOR                                             6/4/14

C  MONT109 HAS THE FOLLOWING CHANGES TO MONT108:

C  1. THE SAME CHANGE THAT WAS MADE PREVIOUSLY SO THAT ANY PREDICTED
C  VALUE LESS THAN 1.D-8 WAS CHANGED TO BE 1.D-8 (SEE CHANGE NO. 5.
C  IN MONT100.FOR) IS NOW MADE ALSO FOR THE COMPARTMENT AMOUNTS. THE
C  REASON IS THE SAME AS BEFORE. ONE EXAMPLE I SAW SHOWED A COMPARTMENT
C  AMOUNT OF 0.8628658D-138 WRITTEN TO THE OUTPUT FILE AS 0.8628658-138.

C  2. A NEW FILE, "ERRORLOG" WILL BE WRITTEN IF THIS PROGRAM STOPS
C  WITHOUT COMPLETING. ESSENTIALLY AT EVERY PLACE THE PROGRAM HAS A
C  CALL PAUSE COMMAND BEFORE STOPPING, WHATEVER COMMENT IS WRITTEN TO
C  THE SCREEN WILL ALSO BE PLACED INTO "ERRORLOG". NOTE THAT
C  "ERRORLOG" IS PASSED TO SUBROUTINES VIA COMMON/ERROR/ERRFIL,
C  WHERE ERRFIL IS SET = 'ERRORLOG'.

C  3. THE MAXIMUM NO. OF OUTPUT EQUATIONS WILL BE CHANGED FROM 6 TO 7,
C  AND TO FACILITATE ANY FUTURE SUCH CHANGES, THIS NUMBER WILL BE SET
C  = MAXNUMEQ (SO ONLY THE PARAMETER STATEMENT WILL HAVE TO BE CHANGED
C  IN THE FUTURE). RATHER THAN PASS MAXNUMEQ TO ALL THE RELEVANT 
C  SUBROUTINES (AS IS DONE IN NPAG113.FOR AND IT2B110.FOR), THIS 
C  PROGRAM WILL JUST HAVE MAXNUMEQ SET IN A PARAMETER STATEMENT IN ALL
C  THESE ROUTINES. AND NOTE THAT IN THOSE SUBROUTINES, ANY 6
C  REFERRING TO THE MAX. NO. OF OUTPUT EQUATIONS WILL BE CHANGED TO
C  MAXNUMEQ.

C-----------------------------------------------------------------------

C  MONT108.FOR                                             1/29/14

C  1. MONT108 HAS A CHANGE FROM MONT107, RELATED TO CHANGE NO. 1 IN 
C  MONT107. IN THE 3RD WAY THE USER HAS TO ENTER PARAMETER 
C  DISTRIBUTIONS, VIA THE RESULTS OF AN NPAG RUN, THERE WILL NOW BE
C  3 OPTIONS RATHER THAN JUST 1 (ENTERING THE NAME OF THE NPAG OUTPUT
C  FILE). THE OTHER TWO OPTIONS WILL BE: ENTERING THE GRID PTS. 
C  MANUALLY; AND ENTERING THE GRID PTS. VIA A SIMPLE TEXT FILE.
C  THE CHANGES WILL BE MOSTLY IN SUBROUTINES GETDIST AND READNPAG.

C  2. THERE IS A CORRECTION IN SUBROUTINE READNPAG. PREVIOUSLY, AN NPAG
C  OUTPUT FILE HAD TO HAVE A VERSION BETWEEN 36 AND 40 TO BE ACCEPTABLE.
C  BUT, THIS HAS BEEN CORRECTED TO BE A VERSION BETWEEN 36 AND 42.

C-----------------------------------------------------------------------

C  MONT107.FOR                                             1/17/14

C  MONT107 HAS THE FOLLOWING CHANGES TO MONT106:

C  1. IN MONT106, THE USER HAD TWO WAYS TO ENTER THE PARAMETER
C  DISTRIBUTIONS: WITH A SPECIFIED MIXTURE OF NORMAL OR LOGNORMAL
C  DISTRIBUTIONS; OR USING THE FINAL CYCLE DENSITY GRID PTS. FROM AN
C  NPAG RUN (WITH EACH COVARIANCE BEING THE FINAL CYCLE COVARIANCE 
C  DIVIDED THE NO. OF ACTIVE GRID PTS). NOW, THERE WILL BE A THIRD WAY:
C  THIS WILL ALSO USE THE FINAL CYCLE DENSITY FROM AN NPAG RUN, BUT 
C  IN THIS CASE, EACH GRID PT. IN THAT DENSITY WILL BE THE PARAMETER 
C  SET OF A SIMULATED SUBJECT. 

C  THE MAIN DIFFERENCE FOR THIS THIRD WAY VS. THE SECOND WAY IS 
C  SHOWN IN THE FOLLOWING EXAMPLE. SUPPOSE THERE ARE 5 GRID PTS. IN THE 
C  FINAL CYCLE DENSITY FROM A PREVIOUS NPAG RUN, AND THERE ARE NOW 100 
C  SUBJECTS TO BE SIMULATED. IN THE 2ND WAY, FOR EACH SUBJECT, ONE OF
C  THE 5 GRID PTS. WOULD BE SELECTED AT RANDOM (THE HIGHER A PROB. 
C  ASSOCIATED WITH A GRID PT., THE MORE LIKELY THAT GRID PT. WOULD BE
C  TO BE SELECTED). BUT IN THIS 3RD WAY, THE NO. OF GRID PTS. IN THE
C  FINAL CYCLE DENSITY IS AUTOMATICALLY THE NO. OF SUBJECTS TO BE
C  SIMULATED, AND EACH SIMULATED SUBJECT HAS EXACTLY THE PARAMETER SET
C  OF ONE OF THE 5 GRID PTS (I.E., THE COVARIANCES FOR EACH DISTRIBUTION
C  WILL BE ALL 0'S).

C  NOTE THAT FOR BOTH THE 2ND AND 3RD WAYS, THE USER WILL ENTER A
C  COMBINED OUTPUT FILE (OUTxxxx) FROM AN NPAG RUN. BUT IN THE 3RD 
C  WAY, THE FINAL CYCLE COVARIANCE MATRIX FROM THE OUTPUT FILE WILL
C  NOT BE NEEDED, JUST THE FINAL CYCLE DENSITY.

C  NOTE THAT THE MAXIMUM NO. OF DISTRIBUTIONS HAS BEEN RAISED FROM
C  30 TO 150. THIS OF COURSE IS ALSO THE MAXIMUM NO. OF GRID PTS.
C  WHICH CAN BE READ IN FROM THE FINAL CYCLE DENSITY OF A PREVIOUS
C  NPAG RUN FOR THE THIRD WAY ABOVE (I.E., EACH GRID PT. IS EQUIVALENT
C  TO A DISTRIBUTION (WITH 0 COVARIANCES) IN THIS CASE).
 

C  2. OPEN(57) IS REPLACED BY OPEN(57,STATUS='SCRATCH') IN 3 LOCATIONS.
C  THE REASON IS THE SAME AS FOR CHANGE 5. IN NPAG111.FOR (WITHOUT
C  A 'SCRATCH' SPECIFIER WHEN OPENING SCRATCH FILES, SOMETIMES THE
C  PROGRAM OBJECTS WITH A " ... CANNOT WRITE TO FILE OPENED FOR READ"
C  ERROR.

C  3. IN 3 FORMATS, F10.5 IS REPLACED BY G10.3. OTHERWISE ANY VALUES
C  GREATER THAN 9999 ARE PRINTED AS *'S. (REF: \ALAN3\ANDERS\SIM.EXP).

C-----------------------------------------------------------------------


C  MONT106.FOR                                             10/02/12

C  MONT106 HAS THE FOLLOWING CHANGES TO MONT105.FOR:

C  1. IN SUBROUTINE FUNC2, BEFORE THE FIRST CALL TO GETFA, THE R(.) ARE
C  SET = RSN(.,.) IN CASE ANY OF THE FA(.) ARE FUNCTIONS OF THE 
C  COVARIATES WHICH ARE ESTABLISHED FROM THE R(.) VALUES IN  GETFA. IN
C  ADDITION, PRIOR TO THE 2 SECTIONS WHERE THE FA(.) ARE USED, GETFA IS
C  CALLED SO THAT THE FA(.) ARE UPDATED TO CURRENT VALUES, BASED ON THE
C  MOST RECENT COVARIATE VALUES IN THE PATIENT'S DATA FILE. IN PREVIOUS
C  PROGRAMS, IT WAS SIMPLY ASSUMED THAT THE FA(.) WERE FUNCTIONS OF THE
C  PARAMETERS, BUT NOT THE COVARIATES, AND SO THIS WASN'T NECESSARY. 
C  BUT THE CODE IN TSTMULTI.FOR (AND NOW TSTMULTK.FOR) IMPLIES THAT THE
C  FA(.) COULD BE FUNCTIONS OF THE COVARIATES, AND SO THIS CHANGE IS 
C  NECESSARY.

C  NOTE THAT SETTING THE R(.) TO RSN(.,.) BEFORE THE FIRST CALL TO
C  GETFA ALSO MEANS THE R(.) WILL BE SET BEFORE GETIX AND GETTLAG ARE
C  FIRST CALLED, WHICH AGAIN IS REQUIRED IN CASE THEY ESTABLISH VALUES
C  AS FUNCTIONS OF THE COVARIATES IN THE PATIENT DATA FILE.

C  ALSO, THE R(.) ARE ALSO RESET = RSN(.,.) BEFORE GETIX IS CALLED
C  IN THE TIME RESET SECTION OF SUBROUTINE FUNC2. NOT DOING THIS WOULD
C  MEAN THAT IF THE INITIAL CONDITIONS FOR THE X(.) ARE FUNCTIONS OF 
C  THE COVARIATES (ESTABLISHED IN GETIX FROM THE R(.) VALUES), THEY
C  WOULD BE ASSIGNED VALUES BASED ON COVARIATES FROM A PREVIOUS
C  DOSAGE LINE IN THE PATIENT'S DATA FILE, RATHER THAN THE LINE
C  WHICH IS THE DOSE RESET LINE.

C  2. SUBROUTINE SHIFT HAS NEW CHANGES, BASED ON shift9.f (UPDATED FROM
C  shift8.f). THE CHANGE IS SUBTLE - SEE CODE IN shift9.f AND
C  SUBROUTINE SHIFT.

C-----------------------------------------------------------------------


C  MONT105.FOR                                             9/13/12

C  MONT105 HAS THE FOLLOWING CHANGES FROM MONT104:

C  1. CHANGES ARE MADE IN STEP 4 OF SUBROUTINE SHIFT TO CORRECT THE 
C  CODE. BOLUSES HAVE BEEN ALLOWED IN STEADY STATE DOSE SETS SINCE 
C  MONT102.FOR, BUT THEY WERE NOT TESTED IN THE PRESENCE OF TIMELAGS,
C  AND THAT COMBINATION OF FACTORS WAS FOUND TO NOT WORK PROPERLY. THIS
C  BUG HAS NOW BEEN CORRECTED (SEE DETAILS IN STEP 4 OF SHIFT).

C  2. BS IS DIMENSIONED IN SUBROUTINE WRITESTEADY, AND VALFIX IS 
C  DIMENSIONED IN SUBROUTINE SIMBIG. THESE TWO DIMENSIONS SHOULD HAVE
C  BEEN DONE PREIVOUSLY (THEY CAUSE WARNINGS IN THE NEW gfortran
C  COMPILER, BUT NO ERRORS).

C-----------------------------------------------------------------------

C  MONT104.FOR                                             6/14/12

C  MONT104 HAS THE FOLLOWING TWO CHANGES FROM MONT103:

C  1. SUBROUTINE FUNC2 HAS A BUG CORRECTION AT LABEL 20, WHICH IS 
C  CHANGED FROM:

C  20    IF(TIMN(KNT) .GT. SIGN(KNS) .AND. SIGN(KNS) .NE. 0) GO TO 25

C  TO

C  20    IF(TIMN(KNT) .GT. SIGN(KNS) .AND. SIGN(KNS) .GT. 0) GO TO 25

C  THE CODE IS NOW CONSISTENT WITH idm1x11.f (IN THE npageng17.f 
C  PROGRAM) AND RECOGNIZES STEADY STATE DOSE SETS.

C  EXAMPLE: SUPPOSED SIGN(KNS) = -4 WHICH SIGNIFIES THE NEXT DOSE
C  EVENT IS THE START OF A STEADY STATE DOSE SET; AND TIMN(KNT) = 10,
C  WHICH MEANS THE PROGRAM SHOULD STILL INTEGRATE THROUGH T = 10 TO
C  GET THE OBSERVATION AT THIS POINT FROM THE CURRENT SECTION.

C  IN THE OLD CODE, SINCE 10 > -4 AND -4 .NE. 0, CONTROL WOULD SHIFT
C  TO LABEL 25 WHERE ID WOULD BE SET = 1 AND TOUT SET = -4. I.E., THE
C  PROGRAM WOULD FASTFORWARD TO THE STEADY STATE DOSE SET IN THE NEXT
C  SECTION WITHOUT COMPLETING OBS. VALUES IN THE CURRENT SECTION. AND
C  THIS WOULD SCREW UP THE PROGRAM COMPLETELY SINCE THE PROGRAM WOULD
C  START INTEGRATING THROUGH THE STEADY STATE DOSE SET WITHOUT EVER
C  SEEING THE CORRESPONDING TIMN(.) = 0 (WHICH WOULD HAVE FOLLOWED THE
C  TIMN(I) = 10 AT SOME POINT).


C  NOW, SINCE SIGN(KNS) = -4 WHICH IS NOT .GT. 0, CONTROL WILL DROP
C  DOWN TO LABEL 15, SET ID = 0 AND TOUT = 10 AND OBTAIN THE OBS.
C  VALUE AT T = 10 AS DESIRED.


C  2. ALL TIMES REPORTED IN THE OUTPUT FILE WILL NOW BE RELATIVE TIMES.
C  IN THE EXAMPLE ABOVE, IF II = 24, AND AN OBSERVATION OCCURRED AT A
C  RELATIVE TIME OF 1.5, THIS RELATIVE TIME OF 1.5 WOULD BE WRITTEN 
C  CORRECTLY IN THE SIMULATED .CSV AND WORKING COPY FILES; BUT IN THE 
C  OUTPUT FILE, THE OBSERVATION WOULD HAVE A TIME OF 2401.5. NOW, THE
C  OBSERVATION TIMES IN THE OUTPUT FILE WILL ALSO BE RELATIVE TIMES.

C  THIS CHANGE IS MADE BY WRITING TIMORIG(I), RATHER THAN TIM(I) TO
C  FILE 23 (FORMAT 7008) 3 PLACES IN SUBROUTINE SIMBIG.


C  NOTES: SEE MONT104.EXP, REMARKS 6, 7, 8:

C  1. THE USER SHOULD NEVER SPECIFY AN OBS. TIME OF 0 IN A .CSV FILE. 
C     AND IN A WORKING COPY FILE, THE USER SHOULD SPECIFY AN OBS. TIME
C     OF 0 ONLY IF THAT LINE REPRESENT A TIME RESET LINE.
C  2. THE USER SHOULD NOT SPECIFY A DOSE TIME OF 0 UNLESS IT IS TO 
C     REPRESENT A DOSE RESET LINE. I.E., IF IT FOLLOWS A STEADY STATE
C     DOSE SET, THE PROGRAM WILL INTERPRET IT, NOT AS A DOSE AT EXACTLY
C     THE END OF THAT STEADY STATE DOSE SET, BUT RATHER AS THE FIRST
C     DOSE IN A NEW SECTION AFTER A DOSE RESET.

C-----------------------------------------------------------------------

C  MONT103.FOR                                             5/24/12

C  MONT103 HAS THE FOLLOWING CHANGE TO MONT102:

C  IT HAS CODE CHANGES IN SUBROUTINE PREDLAST3 TO HANDLE THE CASE WHERE
C  PRED1 + PRED3 - 2*PRED2 = 0 --> PREDNEG SHOULD NOT BE CALCULATED. 
C  USUALLY THIS WILL HAPPEN WHEN THE MODEL/DOSAGE REGIMEN IS SO "EASY"
C  TO PREDICT THAT THE 3 PREDICTED VALUES ARE VERY CLOSE TO EACH OTHER,
C  AND BY "BAD LUCK" COULD BE IN A LINEAR PROGRESSION. I.E., IF
C  PRED1 + DEL = PRED2, AND PRED2 + DEL = PRED3, THEN 
C  PRED1 + PRED3 - 2*PRED2 = 0.

C  IN THIS CASE, OF COURSE, PREDNEG SHOULD NOT BE CALCULATED SINCE THAT
C  WILL RESULT IN A DIVIDE BY 0, OR A NaN IF THE PROGRAM DOES NOT STOP.

C  WHEN THIS HAPPENS (SEE CODE IN PREDLAST3), WHETHER OR NOT CONVERGENCE
C  IS ACHIEVED WILL DEPEND SOLELY ON THE TOL1 CRITERION (I.E., THE TOL2
C  CRITERION CANNOT BE USED, AND IS UNNEEDED).

C-----------------------------------------------------------------------

C  MONT102.FOR                                             4/26/12

C  MONT102 HAS THE FOLLOWING CHANGES TO MONT101G:

C  IT NO LONGER RESTRICTS STEADY STATE DOSES TO BE IVs. NOW THEY CAN
C  BE BOLUSES TOO. BUT, FOR EACH DRUG IN A STEADY STATE SET CAN HAVE 
C  EITHER AN IV OR A BOLUS, BUT NOT BOTH. THE REASON IS THAT THE DOSE 
C  COLUMN IN THE .CSV FILE IS USED FOR THE TOTAL AMOUNT OF DRUG GIVEN.
C  IF THE CORRESPONDING DURATION IS 0, THIS REPRESENTS A BOLUS; IF THE
C  CORRESPONDING DURATION > 0, THIS REPRESENTS THE TOTAL AMOUNT OF THE
C  IV (WITH THE INDICATED DURATION). IF THERE WERE TO BE BOTH AN IV AND
C  A BOLUS, THERE WOULD BE NO WAY TO IMPART THIS INFORMATION IN THE TWO
C  ENTRIES (DUR AND DOSE).

C  TO DO THIS, THE FOLLOWING CHANGES ARE IMPLEMENTED:


C  1. IN SUBROUTINE READBLOCK2, THE IV RATE IS SET = 0 IF DUR = 0.

C  2. SEVERAL CODE CHANGES ARE MADE TO SUBROUTINE NEWWORK1.

C  3. IN SUBROUTINE FUNC2, AN ADDITIONAL PARAMETER, ISKIPBOL, IS USED
C  SO WHEN CONVERGENCE OCCURS IN A STEADY STATE DOSE SET, THE LAST
C  BOLUS FROM THAT SET WILL NOT BE REAPPLIED BELOW LABEL 83.

C  4. SEVERAL CHANGES HAVE BEEN MADE TO SUBROUTINE WRITESTEADY BECAUSE
C  NOW RIV, THE IV RATE FOR A STEADY STATE DOSE, MAY BE 0. IF RBOL IS
C  > 0 AND RIV = 0, THIS IS NO LONGER AN ERROR. IN THIS CASE, THE
C  DURATION OF EACH DOSE IS, OF COURSE, 0.

C  5. THE G15.6 FORMAT IN FORMAT 1 IN SUBROUTINE WRITEDOS IS CHANGED
C  TO BE G19.9 (TO GIVE A LITTLE MORE PRECISION).

C  6. SOME UNNEEDED ARRAYS AND VARIABLES HAVE BEEN REMOVED.

C-----------------------------------------------------------------------

C  MONT101G.FOR                                            3/26/12

C  MONT101G HAS THE FOLLOWING CHANGES FROM MONT101F:

C  1. THE USER IS NOW ALLOWED TO PUT IN SPECIFIED BOUNDARIES FOR EACH
C  RANDOM VARIABLE. THEN, IF A SIMULATED PARAMETER SET HAS A R.V.
C  OUTSIDE ITS BOUNDARIES, THAT SET WILL NOT BE USED TO SIMULATE A 

C  SUBJECT. BUT ITS VALUES WILL BE PART OF THE OVERALL SUMMARY 
C  STATISTICS IN THE OUTPUT FILE. IN THIS CASE, THE SUMMARY STATISTICS
C  SECTION OF THE OUTPUT FILE WILL HAVE SAMPLE MEANS, COV. MATRIX, AND
C  CORR. MATRIX FOR BOTH THE OVERALL PARAMETER SETS, AND THOSE SETS 
C  WHICH WERE USED TO SIMULATE SUBJECTS. IF ALL SIMULATED SETS HAVE
C  ACCEPTABLE VALUES WITHIN THEIR SPECIFIED BOUNDARIES, THEN THE OUTPUT
C  FILE SUMMARY STATISTICS SECTION WILL SHOW JUST ONE SET OF SAMPLE
C  MEANS, COV. MATRIX, AND CORR. MATRIX.

C  2. OSname and ListDir ARE ADDED AS ARGUMENTS TO GETDIST, SO THAT
C  THEY CAN BE PASSED TO READNPAG. THIS SHOULD HAVE BEEN DONE BEFORE.
C  IT SHOWED UP AS A WARNING IN THE COMPILER, RATHER THAN AN ERROR.

C  3. JUST BELOW THE START OF LOOP 1000 IN SUBROUTINE WRITEDOS, 
C  SUBROUTINE THESAME IS CALLED TO ESTABLISH THE VALUE FOR ISAMERESET.
C  THIS CALL HAD BEEN REMOVED IN MONT101F.FOR SINCE NRESET AND 
C  TIMERESET WERE SET IN THE  IF(TIME .GE. TIMADD*(NRESET+1))
C  BLOCK. BUT IT IS NECESSARY FOR ISAMERESET TO BE SET = 1 WHEN
C  TIME = TIMADD*(NRESET+1) ... SINCE IT IS USED BELOW TO PREVENT
C  INTERPOLATION OF COVARIATES ACROSS A TIME RESET.

C-----------------------------------------------------------------------


C  MONT101F.FOR                                            3/17/12

C  MONT101F HAS THE FOLLOWING CHANGE FROM MONT101E:        

C  1. IT ALLOWS A NEW VERSION OF THE .csv FILE. THIS FILE WILL HAVE
C  THE CODE,"POPDATA DEC_11" AT THE TOP, RATHER THAN "POPDATA APR_11".
C  THIS NEW .csv FILE WILL HAVE TWO EXTRA COLUMNS, ADDL AND II, WHICH
C  ALLOW THE USER TO SPECIFY THAT THE CURRENT DOSE LINE IS TO BE
C  REPLICATED ADDL TIMES AT AN INTERDOSE INTERVAL OF II. IF ADDL IS

C  MISSING, IT IS ASSUMED TO BE 0 (WHICH MEANS THE LINE IS NOT TO BE
C  REPLICATED). IF ADDL = -1, IT INDICATES A STEADY STATE DOSE SET IS 
C  BEGINNING WITH THAT LINE.

C  TO HANDLE THE NEW .csv FILE, A NEW SUBROUTINE, CSVCHANGE, WILL BE
C  CALLED (AFTER SUBROUTINE NEWCSV IS CALLED AND BEFORE READBLOCK IS
C  CALLED) TO CHANGE THE NEW .csv FILE INTO THE CORRESPONDING ONE
C  WITH THE OLD FORMAT. THIS WILL MINIMIZE THE CHANGES TO SUBROUTINE
C  READBLOCK, WHICH WILL STILL NEED TO BE CHANGED TO DEAL WITH 
C  NEGATIVE DOSE TIMES (WHICH WILL NOW INDICATE THE BEGINNING OF A 
C  STEADY STATE DOSE SET) - SEE CODE IN READBLOCK.

C  ALSO NOTE THAT CSVCHANGE CONVERTS SCRATCH FILE 67 TO SCRATCH FILE
C  66, WHICH MEANS THAT ALL THE READ(67,..) STATEMENTS IN READBLOCK ARE
C  NOW CHANGED TO READ(66,...) STATEMENTS. SIMILARLY, THE READ(67,...)
C  IN SUBROUTINE GETMAXTIM IS CHANGED TO READ(66,...).

C  SOME NOTES REGARDING THE NEW .csv FORMAT:

C  a. THE COLUMNS WILL NOW BE:
C  ID,EVID,TIME,DUR,DOSE,ADDL,II,INPUT,OUT,OUTEQ,C0,C1,C2,C3,Covs if any

C  b. ADDL AND II ARE ONLY RELEVANT FOR EVID=1 AND EVID=4. FOR EVID=0,
C  (OBSERVATIONS) THEY ARE IGNORED.

C  c. ADDL CONTAINS THE NO. OF ADDITIONAL DOSES TO GIVE, AT THE 
C  INTERDOSE INTERVAL OF II.

C  d. If ADDL IS MISSING FOR AN EVID=1 OR EVID=4 EVENT, IT IS ASSUMED 
C  TO BE 0 --> NO ADDITIONAL DOSES ARE GIVEN. IN THIS CASE, II IS
C  IRRELEVANT.

C  e. IF ADDL > 0, THEN ADDL ADDITIONAL DOSES ARE GIVEN (I.E., A TOTAL
C  OF ADDL + 1) AT INTERVAL II. A MISSING II IN THIS CASE WILL RESULT
C  IN THE PROGRAM STOPPING WITH AN ERROR MESSAGE TO THE USER.

C  f. ADDL > 0 CAN OCCUR ON ANY DOSE EVENT, BUT ADDL = -1 (A STEADY
C  STATE DOSE INDICATOR) CAN ONLY OCCUR AT T = 0 AT THE BEGINNING OF
C  A PATIENT'S FILE, OR AT A DOSE RESET TIME.

C  NOTE THAT A NEW ROUTINE, NEWWORK1, IS CALLED BEFORE SIMBIG CALLS
C  IDCALCY TO CONVERT A WORKING COPY FILE, WHICH MAY HAVE STEADY STATE
C  DOSE INDICATORS (I.E., NEGATIVE DOSE TIMES) TO A WORKING COPY FILE
C  WITH EACH STEADY STATE DOSE INDICATOR LINE REPLACED BY 100 STEADY
C  STATE DOSE SETS, IN THE FORMAT THAT CAN THEN BE READ BY SUBROUTINE
C  FUNC2. ALSO, A NEW SUBROUTINE STOREOBSER IS USED TO READ THIS NEW
C  WORKING COPY FILE IN ORDER TO STORE THE PROPER VALUES INTO THE 
C  ARRAYS OF THE COMMONS SUPPLIED TO SUBROUTINE FUNC2.
 
C  2. IN SUBROUTINE TIMESET, THE FIRST TIME IN THE DOSAGE BLOCK FOR EACH
C  SUBJECT IS NO LONGER TESTED TO MAKE SURE IT IS 0. THE REASON, OF
C  COURSE, IS THAT NOW THE FIRST TIME MAY BE NEGATIVE (WHICH SIGNIFIES
C  THAT THE DOSAGE REGIMEN BEGINS WITH A STEADY STATE OF DOSES).

C  3. A NEW SUBROUTINE CONVERTCSV IS CALLED BEFORE EACH CALL TO
C  SUBROUTINE NEWCSV TO CONVERT, IF NECESSARY, A "EUROPEAN" VERSION OF
C  A .CSV FILE TO THE FORM READBLOCK EXPECTS. IN THE "EURO" VERSION, THE
C  FIELD SEPARATORS ARE SEMICOLONS, RATHER THAN COMMAS, AND THE 
C  CHARACTER USED TO SEPARATE THE WHOLE PART OF A NUMBER FROM THE
C  FRACTIONAL PART IS A COMMA, RATHER THAN A PERIOD. TO DO THIS REQUIRES
C  READING THE SECONDS LINE OF THE .CSV FILE (THE FIRST LINE HAS THE
C  VERSION CODE) AND CHECKING FOR SEMICOLONS. IF THERE ARE ANY, THEN THE
C  FILE IS CHANGED SO THAT, IN ORDER, ALL COMMAS ARE CHANGED TO PERIODS,
C  AND THEN ALL SEMICOLONS ARE CHANGED TO COMMAS. NOTE THAT, EVEN IN THE
C  "EURO" VERSION, IT WILL STILL BE ASSUMED THAT A DOT REPRESENTS
C  A MISSING (OR UNNEEDED) VALUE.

C  NOTE THAT BLOCKPAT IS NOW OPENED AS SCRATCH FILE 87. THEN CONVERTCSV
C  WRITES THIS FILE AS THE CORRECTED VERSION TO SCRATCH FILE 77. THEN,
C  ROUTINE NEWCSV CONVERTS THIS FILE TO SCRATCH FILE 67. THEN ROUTINE
C  CSVCHANGE CONVERTS THIS FILE TO SCRATCH FILE 66, WHICH IS READ BY
C  ROUTINE READBLOCK2.

C  4. SUBROUTINE IDCALCY IS NOW BASED ON idm2x9f (SEE NPAG105.EXP),
C  UPDATED FROM idm2x5.f. THIS MEANS IT HAS CORRESPONDING CHANGES TO
C  THOSE LISTED ABOVE; THE MAIN CHANGE IS THAT IT NOW ACCOMMODATES
C  STEADY STATE DOSING.

C  5. SUBROUTINE FUNC2 IS CHANGED TO BE SIMILAR TO THE CHANGES IN
C  IN idm2x9.f (WHICH ACCOMMODATE STEADY STATE DOSING). ALSO, 
C  SUBROUTINE PREDLAST3 (WHICH IS IN THE idm1x9.f MODULE IN THE
C  NPAG AND IT2B PROGRAMS) IS COPIED INTO THIS PROGRAM.

C  6. ALL ARRAYS RELATED TO DOSES (SIG,SIGO,RS,RSO,BS,ETC.) IN

C  SUBROUTINES FUNC2, SIMBIG, INOUT, SHIFT, WORKTOCSV, AND WRITECSV HAVE
C  THEIR 4000's CHANGED TO 5000's. SIMILARLY, THE PROGRAM VERIFIES THAT
C  THE NO. OF DOSES DOES NOT EXCEED 5000, RATHER THAN 4000, IN SEVERAL 
C  PLACES.

C  7. SUBROUTINE SHIFT IS NOW BASED ON shift7.f (WHICH ACCOMMODATES
C  STEADY STATE DOSING).

C  8. FORMAT 1 IN SUBROUTINE WRITEDOS IS CHANGED FROM G15.6 TO G15.9
C  SO THE DOSES WILL HAVE MORE PRECISION.

C  9. CHANGES ARE MADE IN SUBROUTINES WORKTOCSV AND WRITECSV, AND A NEW
C  SUBROUTINE, WRITESTEADY, IS ADDED, TO ENABLE THE PROGRAM TO CREATE
C  THE NEW-STYLE (WITH CODE = 'POPDATA DEC_11') .CSV FILES, WITH THE TWO
C  EXTRA COLUMNS FOR ADDL AND II, FROM THE SIMULATED DATA.

C-----------------------------------------------------------------------

C  MONT101E.FOR                                            8/4/11

C  MONT101E HAS THE FOLLOWING CHANGE FROM MONT101D:

C  IT CORRECTS A BUG IN SUBROUTINE FUNC2 WHICH OCCURS WHEN TIME RESETS
C  ARE USED, IN THE ESTABLISHMENT OF THE NOISY DOSE AND OBSERVATION


C  TIMES. NOW, EACH DOSE AND OBSERVATION TIME PAST THE FIRST ONE IS
C  CHECKED TO SEE IF IT IS = 0.0. IF IT IS, IT IS IDENTIFIED AS A
C  TIME RESET 0, AND IS HARDCODED TO BE 0 (WITH NO NOISE APPLIED SO THAT

C  THE REST OF THE CODE WILL KNOW IT IS A TIME RESET). PREVIOUSLY, WHEN
C  A TIME RESET OCCURRED, IT MEANT THAT A TIME WAS LESS THAN THE 

C  PREVIOUS VALUE (BEFORE NOISE WAS APPLIED), AND THIS SCREWED UP THE
C  LOGIC THAT ASSUMED THAT TIMES WERE MONOTONICALLY INCREASING.


C-----------------------------------------------------------------------
C  MONT101D.FOR                                            7/20/11

C  MONT101D HAS THE FOLLOWING CHANGES TO MONT101C:

C  1. IN SUBROUTINE INOUT, THE NAME OF THE PATIENT FILE IS CHANGED FROM

C  WhoopteeDo, Yowza  TO  WhoopteeDo Yowza. I.E., THE COMMA IS TAKEN
C  OUT. THE REASON IS THAT IF THESE SIMULATED PATIENT FILES ARE LATER
C  CONVERTED TO .CSV FORMAT, THE .CSV FILE COULD BE SCREWED UP BY 

C  HAVING COMMAS IN THE SUBJECT ID (BECAUSE COMMAS IN A .CSV FILE

C  ARE USED TO SEPARATE FIELDS).

C  2. IN SUBROUTINE WRITECSV, THE DIMENSION OF Y0 IS CHANGED FROM
C  Y0(150,6) TO YO(594,6) TO BE CONSISTENT WITH THE REST OF THE PROGRAM.

C-----------------------------------------------------------------------

C  MONT101C.FOR                                            6/14/11

C  MONT101C IS THE SAME CODE AS MONT101A, EXCEPT FOR THE ADDITION OF
C  WALTER'S CHANGES TO ALLOW THIS PROGRAM TO OPERATE UNDER UNIX AS
C  WELL AS DOS. SEE CODE BELOW MARKED WITH "Yamada".

C-----------------------------------------------------------------------

C  MONT101A.FOR                                            6/13/11

C  MONT101A HAS A COUPLE OF SMALL FORMATCHANGES TO REMOVE THE POSSIBILITY
C  THAT OUTPUT INFO RUNS TOGETHER (IN THE OUTPUT FILE).

C  FORMAT 7007 HAS AN EXTRA "1X" TO ENSURE THAT THE SUBJECT NO. IS
C  SEPARATED FROM THE BEGINNING OF THE PARAMETER VALUES. A SIMILAR
C  CHANGE TO FORMAT 9012 SERVES THE SAME PURPOSE.

C-----------------------------------------------------------------------

C  MONT101.FOR                                             5/25/11

C  MONT101 HAS THE FOLLOWING CHANGES FROM MONT100:

C  1. THE SIMULATED PATIENT INFO, WHICH PREVIOUSLY WAS OUTPUT AS A SET
C  OF WORKING COPY PATIENT FILES, CAN NOW BE OUTPUT AS EITHER A SET OF
C  WORKING COPY PATIENT FILES, A BLOCK .CSV FILE, OR BOTH. OF COURSE,
C  THE OPTION REMAINS TO DO NEITHER, WHICH IS WHAT USERS WHO ONLY NEED
C  THE OUTPUT FILE ITSELF WILL SELECT.


C  TO MAKE A .CSV FILE FROM THE SIMULATED SUBJECTS REQUIRES A NEW
C  SET OF SUBROUTINES, BASED ON THE STAND-A-LONE PROGRAM, WORKCSV.FOR.

C  NOTE THAT BECAUSE OF THE NEW INFO REGARDING THE ABOVE SELECTION,
C  THE INSTRUCTION FILE WILL HAVE A NEW CODE, 'MONTBIG JUN_11'.


C  2. UNLIKE PREVIOUS PROGRAMS, THE CORRECT ASSAY COEFFICIENTS (I.E.,
C  THOSE WHICH WERE USED TO SIMULATE THE SUBJECTS) WILL BE WRITTEN TO
C  THE SIMULATED PATIENT DATA FILES, IF THEY ARE CREATED (PREVIOUSLY,
C  THE ASSAY C'S WHICH WERE WRITTEN WERE THOSE IN THE TEMPLATE WORKING
C  COPY FILE). SIMILARLY, IF A .CSV FILE IS TO BE CREATED, IT WILL ALSO
C  CONTAIN THESE CORRECT ASSAY C'S.

C  3. THE FORMAT IS CHANGED SO THAT VERY LARGE OUTPUT TIMES NO LONGER
C  ARE TRUNCATED AFTER 4 SIGNIFICANT DIGITS. IN PARTICULAR, IN FORMATS
C  7007, 7008, 9012 IN SUBROUTINE SIMBIG, AND IN FORMAT 41 IN 
C  SUBROUTINE READBLOCK2, G12.4 IS REPLACED BY G14.7. (SEE TEST46.FOR
C  WHICH SHOWS THAT A G12.4 FORMAT REPORTS 1.234567 AS SIMPLY 1.235.

C  NOTE THAT FORMAT 7006 IS CHANGED ACCORDINGLY SO THE PARAMETER
C  NAMES ARE ABOVE THEIR VALUES. 

C-----------------------------------------------------------------------

C  MONT100.FOR (REVISED)                                  5/17/11

C  MONT100.FOR (REVISED) HAS THE FOLLOWING CHANGES FROM MONT100.FOR:

C  1. ALL FORMATS RELATED TO THE NO. OF DOSE EVENTS ARE CHANGED TO
C     I5 FROM I4, AND NOTE THAT THE I3 IN FORMAT 2 OF WRITEDOS,
C     WHICH HAD BEEN CHANGED TO I4 IN MONTBG21, BUT SOMEHOW CHANGED
C     BACK TO I3, IS ALSO NOW I5.
C  2. ALL FORMATS RELATED TO THE NO. OF OBSERVED VALUE TIMES ARE 
C     CHANGED TO I4 FROM I3.

C  SEE NOTES IN MONTBG21.FOR AND MONTBG22.FOR; THE MAX. NO. OF DOSE
C  EVENTS IS 4000, AND THE MAX. NO. OF OBSERVED VALUE TIMES IS 594,
C  BUT THE ABOVE CHANGES ALLOW FOR MORE DOSES AND OBSERVED VALUES IN

C  THE FUTURE (IF DIMENSIONS ARE CHANGED).

C-----------------------------------------------------------------------

C  MONT100.FOR                                             5/6/11

C  MONT100 HAS THE FOLLOWING CHANGES FROM MONTBG22:

C  1 MANY CHANGES ARE MADE IN SUBROUTINES READBLOCK2, WRITEDOS, ETC. 
C  SO THAT WT. AND CCR. ARE NO LONGER PUT IN AS DUMMY COVARIATES WHEN
C  THE WORKING COPY FILES ARE MADE FROM THE .CSV FILE. FROM NOW ON,
C  THE ONLY COVARIATES PUT INTO THE WORKING COPY FILES ARE THE ONES
C  SPECIFIED IN THE .CSV FILE. THIS WILL REQUIRE A NEW TEMPLATE MODEL
C  FILE (TSTMULTI.FOR, UPDATED FROM TSTMULTH.FOR) WHICH WILL NO LONGER
C  HAVE THE WARNINGS THAT THE USER SHOULDN'T REFER TO CV(1) AND CV(2)
C  IF THE PATIENT DATA INFO WAS INPUT VIA A .CSV FILE. ALSO THE DO 

C  LOOPS IN THAT FILE THAT WERE OVER I = 1,2+NADD WILL NOW BE OVER
C  I = 1,NADD (SINCE WT. AND CCR. WILL NOW BE INCLUDED AMONG THE NADD
C  ADDITIONAL COVARIATES).

C  ALSO NOTE THAT "NCOV" IN SUBROUTINES READBLOCK2 THROUGH THE REST OF
C  THE FILE HAS BEEN CHANGED TO "NCOVA". THIS STANDS FOR NO. OF 
C  ADDITIONAL COVARIATES - NOT INCLUDING THE 4 PERMANENT ONES AT THE
C  TOP OF ALL WORKING COPY FILES (AGE, SEX, HEIGHT, ETHNICITY FLAG).
C  THIS WAS DONE TO BE CONSISTENT WITH THE NAME USED IN NPAG100.FOR.

C  2. THE FORMAT OF THE .CSV FILE READ BY READBLOCK IS CHANGED. THERE

C  WILL BE 4 ADDITIONAL COLUMNS (COL. NOS. 9 - 12) TO CONTAIN THE
C  ASSAY COEFFICIENTS FOR EACH PATIENT/OUTPUT EQ. SO NOW THE 12
C  PERMANENT COLUMNS WILL BE, IN ORDER, #ID, EVENT ID, TIME,
C  INFUSION DURATION, TOTAL DOSE, INPUT (DRUG) NO., OUTPUT VALUE,
C  OUTPUT EQUATION, C0, C1, C2, C3. ANY ADDITIONAL COVARIATES (BEYOND
C  THE 4 AT THE TOP OF EACH WORKING COPY FILE (AGE, SEX, HEIGHT, 
C  ETHNICITY FLAG) WILL HAVE THEIR COLUMNS AFTER THE PERMANENT 12
C  ABOVE.


C  NOTE THAT EACH PATIENT NEEDS ONE SET OF ASSAY COEFFICIENTS FOR EACH
C  OF THE NUMEQT OUTPUT EQUATIONS. IF ANY OF THESE NUMEQT SETS IS
C  MISSING, THE CORRESPONDING POPULATION SET OF ASSAY C'S FOR THAT
C  OUPUT EQUATION WILL BE ASSIGNED TO THAT PATIENT. FOR THIS REASON,
C  THE ARGUMENT LIST FOR READBLOCK WILL BE EXPANDED TO CONTAIN
C  C0P,C1P,C2P, AND C3P (NOTE THAT THE ARRAYS C0, C1, C2, C3 ARE
C  RENAMED TO BE C0P, C1P, C2P, C3P, TO DISTINGUISH THEM FROM THE
C  SCALARS C0, C1, C2, C3 IN SUBROUTINE READBLOCK2.


C  NOTE THAT EACH ROW IN THE .CSV FILE WHICH HAS EVENT ID = 0 (I.E., IS
C  AN OUPUT VALUE ROW) CAN HAVE ASSAY COEFFICIENT INFO. IF THIS INFO
C  IS SUPPLIED FOR THE SAME SUBJECT AND OUTPUT EQ. MORE THAN ONCE, THE
C  LAST SUCH ROW OF VALUES WILL BE USED. ALSO NOTE THAT IF ANY SET OF
C  ASSAY C'S IS INCOMPLETE (I.E., IT HAS AT LEAST ONE VALUE BUT NOT ALL
C  4), THE PROGRAM WILL STOP WITH A MESSAGE TO THE USER THAT THIS TYPE
C  OF INCOMPLETE ASSAY INFO LINE IS IMPERMISSABLE.

C  BECAUSE OF THE NEW .CSV FORMAT, THERE WILL BE NO BACKWARDS 

C  COMPATIBILITY TO .CSV FILES WITH THE OLD FORMAT.

C  3. THERE WILL BE A NEW CODE FOR THE INSTRUCTION FILE, 
C  'MONTBIG MAY_11', WITH ICODE = 07. THE DIFFERENCE IS THAT NOW THE
C  INSTRUCTION FILE WILL ALSO HAVE TEXT DESCRIBING WHAT INFO IS INPUT.


C  4. IN SUBROUTINE AFTERCOMMA, THE FREE FROMAT WRITE STATEMENT TO 
C  FILE 57 IS REPLACED BY A SERIES OF FORMATTED WRITE STATEMENTS,
C  BASED ON THE NO. OF CHARACTERS TO BE WRITTEN (1 - 11). IF THE NO. OF 
C  CHARACTERS IS > 11, A FREE FORMAT IS STILL USED. THE REASON IS THAT
C  WHEN THIS PROGRAM IS COMPILED AND LINKED UNDER gfortran, A FREE 

C  FORMAT WRITE HAS AN EXTRA SPACE INSERTED AT THE BEGINNING OF THE 
C  LINE. THIS MEANT THAT, WHEN A .CSV FILE HAD AN 11 CHARACTER 
C  SUBJECT ID, ONLY THE 1ST 11 WOULD BE WRITTEN TO FILE 57. THEN, IN
C  READBLOCK, WHEN FILE 57 WAS READ, TWO OR MORE SUBJECTS WHOSE FIRST
C  10 CHARACTERS WERE THE SAME (I.E., THEY HAD DIFFERENCES ONLY IN THE
C  11TH CHARACTER) WOULD HAVE THEIR DATA COMBINED INTO THE SAME WORKING
C  COPY PATIENT DATA FILE. THIS PROBLEM DOES NOT OCCUR WHEN THIS PROGRAM
C  IS COMPILED UNDER LAHEY F90. 


C  5. THE CODE WHICH CHANGED ANY PREDICTED VALUE < 0 TO BE 1.D-8 IS 
C  CHANGED TO CHANGE ANY PREDICTED VALUE < 1.D-8 TO BE 1.D-8. THE 

C  REASON IS THAT VALUES LOWER THAN 1.D-99 ARE WRITTEN IMPROPERLY TO
C  THE PATIENT DATA FILES AND THE OUTPUT FILE. EX: A VALUE OF 1.D-123
C  GETS WRITTEN AS .1-122 = -121.9.

C  6. SEVERAL STOP STATEMENTS WERE NOT PRECEDED BY A CALL PAUSE 
C  STATEMENT PREVIOUSLY (AS THEY SHOULD HAVE BEEN). THIS HAS NOW BEEN
C  CORRECTED.

C-----------------------------------------------------------------------

C  MONTBG22.FOR                                            3/20/11

C  MONTBG22 HAS THE FOLLOWING CHANGES FROM MONTBG21:

C  1. IT CORRECTS INCONSISTENCIES IN DIMENSION STATEMENTS. SPECIFICALLY,
C  SEVERAL 150s HAVE BEEN CHANGED TO 594s IN SUBROUTINES SIMBIG, GNRAT,
C  NOSGEN, AND SQROOT (E.G., AS1, AS, ASUB, AMEANC, COVC, ALF - THE LAST
C  3 ONLY NEED THE LARGER DIMENSION TO BE COMPATIBLE WITH THE DUMMY
C  ARGUMENTS IN CALLED ROUTINES).


C  2. THE G15.6 IN FORMAT 1 IN SUBROUTINE WRITEDOS WAS CHANGED TO G19.10 
C  BECAUSE A TIME OF 10000.01 IN G15.6 IS ROUNDED TO 10000.0, AND THIS
C  CAUSED A PROBLEM WHEN A SHORT TERM IV OF .01 THEN LOOKED LIKE IT WAS
C  TURNED ON AND OFF AT THE SAME TIME.

C-----------------------------------------------------------------------


C  MONTBG21.FOR                                            3/16/11


C  MONTBG21 IS THE SAME AS MONTBG20 EXCEPT FOR THE FOLLOWING:

C  1. THE MAXIMUM NO. OF  DOSE EVENTS IS INCREASED FROM 500 TO 4000. 
C  SO ALL DIMENSIONS OF 500 RELATED TO THE NO. OF DOSES ARE CHANGED TO
C  4000. IN ADDITION, THE 650 DIMENSIONS WHICH REFER TO DOSE-RELATED
C  DIMENSIONS ARE ALL CHANGED ACCORDINGLY (MULTIPLIED BY 8) TO BE 5200.
C  AND THE TOTAL NO. OF DOSE LINES ALLOWED IS CHANGED FROM 3000 TO 
C  24000.

C  ALSO FORMAT 1013 IN SUBROUTINE INOUT IS CHANGED TO ACCOMODATE UP TO
C  A 4-DIGIT NO. OF DOSE EVENTS. AND A SIMILAR CHANGE IS MADE TO FORMAT 
C  2 OF SUBROUTINE WRITEDOS.

C  2. SEVERAL VARIABLES WHICH WERE NOT USED ARE NOW REMOVED FROM
C  THE DECLARATION STATEMENTS IN READLBLOCK2 (AGE, ETHNIC, DATE,
C  HEIGHT, WEIGHT, CCR, PATNAME, SEXI, PAT, SEX)

C  3. A SMALL BUG IS REMOVED IN SUBROUTINE READBLOCK2. IN FORMAT 11,
C  FILEIN IS NO LONGER REFERENCED - IT IS NOT PASSED TO THE ROUTINE,
C  AND SO WOULD BE PRINTED AS BLANKS IF FORMAT 11 WAS WRITTEN.

C  4. A SMALL BUG IS FIXED IN VERIF1. WHEN READING IN FILEIN, THE FORMAT
C  IS CHANGED FROM 2 TO 212.

C-----------------------------------------------------------------------

C  MONTBG20.FOR                                            1/21/11

C  MONTBG20 HAS THE FOLLOWING CHANGES TO MONTBG19:

C  1. IT CORRECTS A SUBTLE BUG IN SUBROUTINE READBLOCK2. PREVIOUSLY IF
C  AN IV STARTED AT EXACTLY THE ENDING TIME OF THE PREVIOUS IV, THIS
C  WOULD RESULT IN BOTH 0.0 AND THE NEW IV RATE BEING ASSIGNED TO THE
C  SAME TIME. THE RESULT, IN WRITEDOS, WOULD BE THAT 0.0 WOULD BE 
C  ASSIGNED TO THIS TIME (I.E., THE NEW IV RATE WOULD BE LOST). NOW,
C  THIS BUG IS CORRECTED IN SUBROUTINE READBLOCK2, WHERE THE BEGINNING
C  TIME OF EACH IV IS TESTED AGAINST THE ENDING TIME OF THE PREVIOUS 
C  (IF THERE IS A PREVIOUS ONE), AND IF THEY ARE THE SAME, THEN THE NEW
C  IV RATE OVERWRITES THE 0.0 WHICH WOULD HAVE BEEN THE NEW IV RATE IF
C  THERE HADN'T BEEN ANOTHER STARTING IV AT THAT TIME.

C  2. IN FORMAT 5001, ONE OF THE 'TSTMULTG.FOR's WAS NOT CHANGED TO 
C  'TSTMULTH.FOR' IN MONTBG19.FOR. THIS HAS NOW BEEN CORRECTED.

C-----------------------------------------------------------------------
 
C  MONTBG19.FOR                                             1/7/10

C  MONTBG19 HAS THE FOLLOWING CHANGES TO MONTBG18:

C  1. BEFORE THE THREE CALLS TO SUBROUTINE READBLOCK2, NEW CODE IS PUT
C  IN TO CALL NEW SUBROUTINE NEWCSV (BASED ON THE STAND-A-LONG PROGRAM,  
C  NEWCSV.FOR) WHICH CONVERTS THE .CSV FILE INTO A SCRATCH FILE WITH 
C  EACH MISSING VALUE DOT REPLACED BY AN n. THIS IS NECESSARY SINCE, 
C  WHEN THIS PROGRAM IS COMPILED/LINKED WITH gfortran, IT INTERPRETS
C  A DOT AS A 0 (I.E., A NUMBER RATHER THAN A NON-NUMBER). THE RESULT
C  IS THAT THE STATEMENT ...
C    READ(57,*,ERR=70) COVVAL
C  IS IMPROPERLY EVALUATED WHEN A DOT IS READ. I.E., RATHER THAN 
C  BRANCHING TO LABEL 70, THE PROGRAM SETS COVVAL = 0 AND CONTINUES.

C  SINCE THERE ARE OTHER SIMILAR READ STATEMENTS, RATHER THAN TRY TO


C  ADDRESS EACH ONE INDIVIDUALLY, READBLOCK2 WILL READ THE SCRATCH FILE
C  INSTEAD OF THE ORIGINAL .CSV FILE. SINCE gfortran SEES AN n AS A
C  NON-NUMBER, THE CODE WILL NOW BE EXECUTED CORRECTLY.

C  NOTE THAT THE .CSV FILE WILL NOW BE OPENED AS FILE 77, AND THE 
C  SCRATCH FILE WILL BE FILE 67.



C  2. THE TEMPLATE MODEL FILE WILL NOW BE TSTMULTH.FOR, RATHER THAN
C  TSTMULTG.FOR. TSTMULTH.FOR ALLOWS N=-1 IN SUBROUTINE SYMBOL, WHICH
C  TELLS THE PROGRAM THAT THE MODEL IS THE STANDARD 3-COMP. LINEAR
C  MODEL, AND THE BASIC 5 PARAMETERS ARE CODED IN SUBROUTINE ANAL3 BY
C  THE USER. THE USER ALSO CODES THE OTHER ROUTINES IN TSTMULTH.FOR, 
C  AS INDICATED IN THE COMMENTS IN THAT TEMPLATE MODEL FILE.

C  NOTE THAT CHANGES ARE MADE IN SUBROUTINE FUNC2 TO BE COMPATIBLE WITH
C  THE NEW TSTMULTH.FOR MODEL FILE, AND THE POSSIBILITY THAT N=-1. IN 
C  PARTICULAR, IF N .EQ. -1, SUBROUTINE ANAL3 IS CALLED RATHER THAN 
C  SUBROUTINE USERANAL. ALSO, THE CODE TO RESET X(I),I=1,N TO 0 WHERE 
C  THERE IS A TIME RESET NOW INCLUDES EXTRA CODE TO SET X(I),I=1,3 TO 0

C  IF N .EQ. -1. SIMILARLY, TWO OTHER TIMES IN FUNC2, WHEN A
C  DO ICOMPART = 1,N IS USED TO SET XPRED, THE CODE IS CHANGED TO BE 
C  DO ICOMPART = 1,3 IF N .EQ. -1.

C  NOTE THAT 2 DO LOOPS INVOLVING NDIM ARE CHANGED TO 3 IF NDIM = -1

C  SINCE THERE REALLY ARE 3 COMPARTMENTS (-1 IS JUST A CODE FOR THE
C  PROGRAM TO KNOW TO USE ANALYTIC SOLUTIONS).

C  3. SEVERAL BUGS ARE FIXED RELATED TO SUBROUTINE READBLOCK2, WHICH WAS 
C  INTRODUCTED IN MONTBG18.FOR. 

C   a. WHEN INOPT = 1, READBLOCK2 WAS NOT CALLED, AND SO XQZPJ001.ZMQ 
C      WAS NOT MADE IN THIS CASE. THIS HAS BEEN CORRECTED.
C   b. IN READBLOCK2, CALL GETCHAR IS REPLACED BY CALL GETCHAR2, WHICH
C      IS THE ROUTINE ADDED FROM SCAT72X1.FOR WHICH RETURNS A 
C      3-CHARACTER CHARSUB RATHER THAN A 5-CHARACTER CHARSUB (WHICH 
C      IS WHAT GETCHAR RETURNS). 
C   c. THE SIZE OF PATH, TMPFILE, AND PATHFILE IN READBLOCK2 HAVE BEEN
C      CHANGED FROM 60, 13, AND 73, RESPECTIVELY, TO 61, 32, AND 93,
C      RESPECTIVELY (TO BE CONSISTENT WITH THE REST OF THIS PROGRAM).
C      ALSO, IN SUBROUTINE READNPAG (WHICH WAS NEW IN MONTBG18.FOR), 
C      THE SIZES OF THESE CHARACTER VARIABLES ARE SIMILARLY CORRECTED.
C   d. THE CALL TO READBLOCK2 IN THE INOPT = 1 SECTION IS NOW ONLY MADE
C      IF ICSVFILE = 1 (OBVIOUSLY READBLOCK2 IS UNNEEDED IF FILEIN IS
C      ALREADY A WORKING COPY FILE).
C   e. IN MAIN AND VERIF1, AT LABEL 5470, A CONTINUE STATEMENT REPLACES
C      THE FORMER OPEN(21 ... STATEMENT. TO GET TO THIS POINT, FILE 21
C      WAS ALREADY OPENED, AND OPENED CORRECTLY WITH FILE=PATHFILE, NOT
C      THE NON-PATH XQZPJ001.ZMQ.

C  4. A CALL TO NEW SUBROUTINE PAUSE REPLACES EACH PAUSE STATEMENT. 
C  THIS IS BECAUSE A PAUSE STATEMENT CAUSES A WARNING WHEN THE PROGRAM
C  IS COMPILED AND LINKED USING gfortran (AND IT FORCES THE USER TO 
C  TYPE "go" INSTEAD OF SIMPLY HITTING THE ENTER KEY. 

    
C-----------------------------------------------------------------------

C  MONTBG18.FOR                                                9/3/10

C  MONTBG18 HAS THE FOLLOWING CHANGES FROM MONTBG17:

C  1. THE USER WILL NOW HAVE THE EXTRA OPTION TO INPUT THE MIXTURE OF 
C  DISTRIBUTIONS FROM WHICH THE PATIENTS WILL BE SIMULATED FROM THE 
C  OUTPUT OF A BIG NPAG RUN. IN THIS CASE, EACH DISTRIBUTION WILL 
C  CORRESPOND TO ONE OF THE ACTIVE GRID POINTS FROM THE FINAL CYCLE.
C  THE MEAN OF THE DIST. WILL BE THE COORDINATES OF THE GRID PT., THE
C  WEIGHT WILL BE THE PROBABILITY OF THE GRID PT., AND THE COV. MATRIX
C  WILL BE THE FINAL CYCLE COV. MATRIX FROM THE RUN, DIVIDED BY THE NO.
C  OF ACTIVE GRID POINTS ... IN THE IDEAL SETTING. BUT IF THE BIG NPAG
C  RUN HAS A FINAL CYCLE COV. MATRIX WHICH WAS NOT WRITTEN (BECAUSE ONE
C  OF THE ASSOCIATED VARIANCES WAS NUMERICALLY .LE. 0), THEN THE COV.
C  MATRIX FOR EACH DISTRIBUTION/GRID PT. WILL AUTOMATICALLY BE DIAGONAL
C  WITH EACH STD. DEV. = .25 * THE CORRESPONDING MEAN. ALSO, IF THE NO.
C  OF ACTIVE GRID POINTS IS > 30 (THE MAXIMUM VALUE FOR NGAUS), THE 
C  USER WILL BE ABLE TO STOP THE PROGRAM, OR HAVE IT CONTINUE USING JUST
C  THE FIRST 30 GRID POINTS.

C  TO AFFECT THE ABOVE OPTION, SUBROUTINE GETDIST HAS SEVERAL CHANGES,
C  AND IT CALLS NEW SUBROUTINE READNPAG (WHICH DOES THE ACTUAL READING
C  OF THE BIG NPAG OUTPUT FILE.

C  2. SUBROUTINE READBLOCK2 (BASED ON READBLOCK IN NPBG15E1.FOR) AND ALL
C  THE ROUTINES IT CALLS ARE ADDED TO THIS PROGRAM SO THAT THE USER MAY 
C  ENTER DOSE/COVARIATE AND OBS. TIME VALUES FOR THE SIMULATED PATIENTS
C  VIA A .CSV FILE, AS WELL AS THE OLD WAY (VIA A MULTIPLE DRUG WORKING
C  COPY PATIENT DATA FILE). IF THE USER CHOOSES THE NEW WAY, READBLOCK2
C  IS CALLED TO READ THE .CSV FILE AND CREATE A MULTIPLE DRUG WORKING

C  COPY PATIENT DATA FILE FROM THE INFO OF THE FIRST SUBJECT'S DATA

C  IN THE .CSV FILE. THIS FILE WILL THEN BE READ AND USED AS USUAL.

C  3. FUNCTIONS GASDEV AND RAN1 HAVE BEEN CHANGED BY WALTER YAMADA TO
C  FIX A COMPILER ISSUE RELATED TO GFORTRAN VS. G95. IN ADDITION, WALTER
C  HAS INCLUDED A NEW SUBROUTINE, INIT_RANDOM_SEED, WHICH IS CALLED BY 
C  THE NEW RAN1 (SEE COMMENTS IN THE CODE FOR THOSE FUNCTIONS/ROUTINE).
C  NOTE THAT THE NEW CODE WAS ORIGINALLY PART OF WALTER'S MCB17ALP.FOR
C  PROGRAM WHICH WAS TESTED AGAINST MONTBG17.FOR FOR THE FIRST TESTCASE
C  IN MONTBG17.EXP, AND GAVE THE SAME RESULTS.

C-----------------------------------------------------------------------

C  MONTBG17.FOR                                                8/1/10

C  MONTBG17 HAS TWO BUG CORRECTIONS TO MONTBG16, BOTH IN SUBROUTINE 
C  FUNC2:

C  1. IN THE   IF(TIMN(KNT) .EQ. 0.D0 .AND. SIGN(KNS) .EQ. 0.D0) BLOCK,
C  THE TIME, T, IS ALSO RESET = 0 SINCE THE INTEGRATION WILL AGAIN
C  START FROM TIME 0. WHEN THIS WASN'T DONE, THE RESULTS WERE
C  UNPREDICTABLE (DEPENDING ON HOW THE DVODE INTEGRATION ROUTINES
C  TREATED A (T,TOUT) PAIR WHICH DECREASED RATHER THAN INCREASED.

C  THIS IS THE SAME CHANGE THAT idm2x5.f MADE TO idm2x4.f.

C  2. THE BSN(.,.) VALUES ARE ESTABLISHED BELOW THE IF(NTL .EQ. 1)
C  BLOCK, RATHER THAN INSIDE IT, SINCE THESE VALUES MUST BE SET
C  REGARDLESS OF WHETHER OR NOT NTL = 1.

C-----------------------------------------------------------------------

C  MONTBG16.FOR							3/7/10

C  MONTBG16 IS AN EXTENSION TO MONTBG15. IT ALLOWS SIMULATION OF 
C  PATIENTS WITH MULTIPLE DRUGS (MONTBG15 WAS LIMITED TO SIMULATING

C  PATIENTS WITH A SINGLE DRUG). THE SPECIFIC CHANGES ARE:

C  1. THE TEMPLATE MODEL FILE WILL NOW BE TSTMULTG.FOR, RATHER THAN
C  INITCN22.FOR.

C  2. LOTS OF CHANGES ARE MADE IN THE IDCALCY/FUNC2/EVAL2 PART OFS
C  THE CODE, WHICH IS NOW BASED ON idm2x4.f (OF THE bigmlt5.f MULTIPLE
C  DRUG PROGRAM), RATHER THAN idcy_53f.f (OF THE big26.f SINGLE DRUG 
C  PROGRAM).

C  3. CHANGES ARE MADE THROUGHOUT THE PROGRAM WHEREVER THE WORKING COPY 
C  PATIENT DATA FILES OCCURS, SINCE THE MULTIPLE DRUG STRUCTURE IS
C  DIFFERENT THAN THE SINGLE DRUG STRUCTURE.

C-----------------------------------------------------------------------

C  MONTBG15.FOR						1/8/09

C  MONTBG15 HAS THE FOLLOWING IMPROVEMENT TO MONTBG14:

C  FILES MAY NOW BE UP TO 32 CHARACTERS IN LENGTH, RATHER THAN JUST
C  12. I.E., TMPFILE HAS BEEN CHANGED TO *32 FROM *12. IN FACT, ALL
C  FILES ARE ALSO CHANGED FROM *20 TO *32.


C  ALSO, SINCE PATHFILE IS THE CONCATENATION OF PATH + FILENAME, AND
C  PATH REMAINS *61, PATHFILE WILL NOW BE *93 INSTEAD OF *73.

C  NOTE THAT ALL A20 FORMATS ARE NOW CHANGED TO A32, AND ALL A73 FORMATS
C  ARE NOW A93.

C  NOTE ALSO THAT IN SUBROUTINE FULLNAME, THE DO I=1,73 IS CHANGED TO
C  DO I=1,93.

C-----------------------------------------------------------------------

C  SEE THE COMMENTS FOR PROGRAMS MONTBG14.FOR ... MONT5CL.FOR IN
C  MONTBG15.FOR, IF NEEDED.


C***********************************************************************

C wmy2019.02.27 -- NPAG reconciliation
      USE npag_utils, only : verifyval,max_pop_rand_varbs

      IMPLICIT REAL*8(A-H,O-Z)

      PARAMETER(MAXDIM=30,MAXNUMEQ=7)

      DIMENSION VALFIX(20),AMEAN(150,30),COF(150),COV(150,30,30),
     1 IRAN(32),ATOL(20),C0(MAXNUMEQ),C1(MAXNUMEQ),C2(MAXNUMEQ),
     2 C3(MAXNUMEQ),CORR(30,30),BOUND(32,2),ILIMIT(32),XVERIFY(900)

C wmy2019.02.26 -- NPAG reconciliation
      integer, dimension(128) :: INTLIST
      integer, dimension(257) :: IPAR
      double precision, dimension(257) :: RPAR
C ---

      CHARACTER FILNFO*32,PREFIX*3,EXT*3,PAR(30)*11,PARFIX(20)*11,
     1   SAVFIL*32,FILOUT*32,FILEIN*32,PATH*61,TMPFILE*32,
     2   PATHFILE*93,CODE*14,FORFILE*32,OUTNPAG*20,OUTCSVNAME*32,
     3   TEXTFILE*20,ERRFIL*20

      COMMON/TOUSER/NDIM,MF,RTOL,ATOL
      COMMON/NOISE/ C0DT,C1DT,C2DT,C3DT,C0DA,C1DA,C2DA,C3DA,
     1   C0OT,C1OT,C2OT,C3OT

      COMMON/ERROR/ERRFIL
C  COMMON/ERROR/ IS SUPPLIED TO ALL THE ROUTINES WHICH COULD WRITE TO
C  ERRFIL. NOTE THAT ERRFIL IS SET = 'ERRORLOG' BELOW.

C Yamada 5/5/2010
C NOTE length of char array should be at least max expected + 1
C
      CHARACTER(LEN=20) :: OSName
      CHARACTER(LEN=5) :: CopyFile
      CHARACTER(LEN=4) :: DeleteFile
      CHARACTER(LEN=6) :: ClearScreen
      CHARACTER(LEN=10) :: ListDir
C
C Yamada 5/5/2010 ... The above are used for distinguishing

C    the Operating System and creating appropriate system calls.
C
C ------------------------------------------------------------
C Yamada 5/5/2010
C
C Initialize system calls here, e.g.:
C 1. CopyFile = COPY or cp
C 2. DeleteFile = DEL or rm
C
C NOTE the use of INDEX; be careful what substrings are allowed
C    for the ID of an operating system
C NOTE the extra space after each command; this makes it easier
C    to concatenate arguments to the system command.
C

      ERRFIL = 'ERRORLOG'


       CALL GET_COMMAND_ARGUMENT(1,OSName)
       IF ((INDEX(OSName,"MacOSX",.TRUE.).EQ.1)
     $ .OR.(INDEX(OSName,"Darwin",.TRUE.).EQ.1)
     $ .OR.(INDEX(OSName,"BSD",.TRUE.).EQ.1)) THEN
          PRINT *,"Requested OS is ", OSName
          OSName="UNIX"
          PRINT *,"Setting OS to ", OSName
          PRINT *,""
          CopyFile="cp "

          DeleteFile="rm "
          ClearScreen="clear "
          ListDir="ls -tp "
       ELSE IF ((INDEX(OSName,"DOS",.TRUE.).EQ.1)
     $ .OR.(INDEX(OSName,"WinXP",.TRUE.).EQ.1)
     $ .OR.(INDEX(OSName,"XP",.TRUE.).EQ.1)
     $ .OR.(INDEX(OSName,"WinXP",.TRUE.).EQ.1)
     $ .OR.(INDEX(OSName,"Vista",.TRUE.).EQ.1)
     $ .OR.(INDEX(OSName,"Win7",.TRUE.).EQ.1)) THEN
          PRINT *,"Requested OS is ", OSName
          OSName="DOS"
          PRINT *,"Setting OS to ", OSName
          CopyFile="COPY "
          DeleteFile="DEL "
          ClearScreen="CLS "
          ListDir="DIR /OD "
       ELSE
          PRINT *,"WARNING: Operating system not declared."
          PRINT *,"WARNING: Can not initialize system calls."
          PRINT *,""

          PRINT *,"Possible command line error, try:"
          PRINT *,"C:\> npbig.exe <DOS,Win,XP,Vista,or Win7>"
          PRINT *,"unix$ npbig <MacOSX,Darwin,BSD>"
          PRINT *,""
          PRINT *,"NPAG Exiting with status 2"
          PRINT *,""
          CALL EXIT(2)
       END IF
C ------------------------------------------------------------

C  COMMON/TOUSER IS SUPPLIED TO SUBROUTINE USERANAL.
C  COMMON/NOISE IS SUPPLIED TO SUBROUTINE FUNC2.

C  INPUT DATA FROM THE USER DIRECTLY, OR FROM AN INPUT FILE. THE 
C  FOLLOWING WILL BE ENTERED:

C  PREFIX = 3-CHARACTER PREFIX FOR ALL SUBJECT FILENAMES. THEN 
C           001, 002,... UP TO 10000  WILL COMPLETE THE 1ST NAMES OF THE 
C           INDIVIDUAL FILENAMES WHICH ARE READ IN.

C  EXT = AN OPTIONAL 3-CHARACTER EXTENSION (AFTER DECIMAL POINT) 


C	 FOR THE INPUT FILENAMES. 

C  ICSVFILE = 0 IF THE DOSAGE REGIMEN AND OBSERVATION TIMES FOR THE
C               SIMULATED SUBJECTS WILL BE INPUT USING A (MULTIPLE DRUG)
C               WORKING COPY PATIENT DATA FILE.
C           = 1 IF THIS INFO WILL BE INPUT USING A .CSV FILE. IN THIS
C               CASE, THE INFO WILL BE TAKEN FROM THE FIRST SUBJECT'S
C               DATA IN THE .CSV FILE.

C  FILEIN = THE NAME OF THE FILE WHICH HAS THE PATIENT DOSAGE REGIMEN
C           AND OBS. TIMES. IF ICSVFILE = 0, IT WILL BE A (WORKING COPY)
C           PATIENT DATA FILE; IF ICSVFILE = 1, IT WILL BE A .CSV FILE.


   
C  NSUB = NO. OF SUBJECT DATA FILES TO BE GENERATED. (MAX NO. = 999).

C  NVAR = NO. OF R.V.'S (1 .LE. NVAR .LE. MAXDIM).

C  NOFIX = NO. OF NON-RANDOM PARAMETERS WHOSE FIXED VALUES ARE TO BE SET
C	   BY THE USER. NOFIX MUST BE LESS THAN OR EQUAL TO 20.

C  VALFIX(I) = VALUE OF FIXED PARAMETER I, I=1,NOFIX.

C  C0(J),C1(J),C2(J),C3(J) = THE COEFFICIENTS FOR THE ASSAY STD. DEV. 
C   OF OUTPUT EQUATION J OF THE OUTPUT VALUES (THE C(J)'S ARE THE SAME 

C   FOR ALL SUBJECTS), J=1,NOS.

C  AF = ACTIVE (SALT) FRACTION OF THE DRUG.

C  INFO ON THE DISTRIBUTION OF THE SUBJECT VECTORS TO BE GENERATED. 
C  ASSUME EACH SUBJECT VECTOR COMES FROM A GAUSSIAN MIXTURE 
C  DISTRIBUTION, SUM[COF(I)*N(I)], I=1,NGAUS. WHERE THE SUM OF THE   
C  COEFFICIENTS, COF(I), IS 1.0, AND EACH N(I) IS AN NP-VARIATE NORMAL
C  DISTRIBUTION.

C  SO THE USER WILL ENTER NGAUS, COF(I), I=1,NGAUS, AND NGAUS SETS OF
C  MEAN VECTORS AND COVARIANCE MATRICES. OR THE USER MAY ENTER THE 
C  OUTPUT FILE FROM A BIG NPAG RUN, AND THE MIXTURE WILL BE TAKEN FROM
C  THE NACTVE FINAL CYCLE GRID PTS, AND THE FINAL CYCLE COV. MATRIX 
C  (IF IT EXISTS) - SEE CODE BELOW. 

C  AS OF MONTBIG2.FOR, THE USER WILL BE ABLE TO SIMULATE LOGNORMAL
C  VECTORS AS WELL AS NORMAL VECTORS. SEE CODE BELOW.

C  FILOUT = NAME OF FILE TO HOLD THE SUMMARY INFO FROM THE SIMULATION.
C
C-----------------------------------------------------------------------

  138   FORMAT(/' PLEASE ENTER ONE OF THE REQUESTED VALUES: ') 


    2 FORMAT(A32)
  222 FORMAT(A3)
 2222 FORMAT(A3)

C  CALL GETPATH TO GET FROM THE USER THE PATH WHERE THE INPUT FILES ARE
C  LOCATED (AND WHERE THE OUTPUT FILES WILL GO). NOTE THAT PATH IS THE
C  PATH WITH A TRAILING BACKSLASH, AND NOB IS THE NO. OF THE ENTRY WITH
C  THE LAST NON-BLANK ENTRY.

     	CALL GETPATH(PATH,NOB,INTLIST,RPAR,IPAR)



C  SET OUTNPAG TO ALL BLANKS. IF IT CHANGES AFTER A CALL TO GETDIST, IT
C  MEANS THAT IT CONTAINS THE NAME OF THE BIG NPAG OUTPUT FILE FROM 
C  WHICH THE NGAUS DISTRIBUTIONS WERE ESTABLISHED. SIMILARLY FOR
C  TEXTFILE WHICH, IF NOT ALL BLANKS, CONTAINS THE NAME OF THE TEXT FILE
C  WHICH HAS THE NGAUS DISTRIBUTIONS MEANS.

        OUTNPAG(1:20) = '                    '
        TEXTFILE(1:20) = '                    '

 
  145	WRITE(*,38)
   38   FORMAT(/' ENTER 0 IF INPUT IS TO BE FROM THE KEYBOARD; '/
     1' ENTER 1 IF INPUT IS TO BE FROM A FILE: ')
	READ(*,*,ERR=145) INOPT
      
	IF(INOPT .NE. 0 .AND. INOPT .NE. 1) THEN
	   WRITE(*,138)
	   GO TO 145 
	ENDIF

	IF(INOPT .EQ. 1) THEN

	 WRITE(*,39)
   39 	 FORMAT(/' ENTER THE NAME OF THE INSTRUCTION FILE; '/
     1' ENTER -99 TO SEE ALL OR A PART OF YOUR DIRECTORY: ')

	 READ(*,2) FILNFO
	 IF(FILNFO(1:3) .EQ. '-99') CALL SEEDIR(PATH,NOB,FILNFO,
     1      OSname,ListDir)

C  CALL FULLNAME WHICH CONVERTS THE FILENAME TO PATHFILE, THE COMPLETE 
C  NAME OF THE FILE, WHICH INCLUDES THE PATH (IF THE PATH IS NOT THE 
C  CURRENT DIRECTORY).

	 TMPFILE = ' '
	 TMPFILE = FILNFO
	 CALL FULLNAME(PATH,TMPFILE,PATHFILE)
	 OPEN(23,FILE=PATHFILE,ERR=6330,STATUS='OLD')
	 GO TO 6335
 6330    WRITE(*,5316) PATHFILE
 5316    FORMAT(//' THE FOLLOWING FILE DOES NOT EXIST ... '/
     1' ',A93)
	 GO TO 145
 6335    CONTINUE

C  READ ALL INPUT DATA FROM FILE FILNFO, WHICH WAS FILLED FROM A
C  PREVIOUS RUNNING OF THIS PROGRAM.

C  THE 1ST LINE IN FILNFO IS THE CODE WHICH GIVES THE VERSION NO. OF 

C  THE PROGRAM. 

	 READ(23,7123) CODE
 7123    FORMAT(A14)

	 ICODE = 0
	 IF(CODE .EQ. 'MONTBIG APR_04') ICODE = 01
	 IF(CODE .EQ. 'MONTBIG MAR_07') ICODE = 02
	 IF(CODE .EQ. 'MONTBIG JUN_08') ICODE = 03
	 IF(CODE .EQ. 'MONTBIG JUL_08') ICODE = 04
	 IF(CODE .EQ. 'MONTBIG AUG_08') ICODE = 05
       IF(CODE .EQ. 'MONTBIG SEP_10') ICODE = 06
       IF(CODE .EQ. 'MONTBIG MAY_11') ICODE = 07
       IF(CODE .EQ. 'MONTBIG JUN_11') ICODE = 08
       IF(CODE .EQ. 'MONTBIG MAR_12') ICODE = 09

	 IF(ICODE .LT. 5) THEN
	  WRITE(*,7124)

 7124   FORMAT(/' THIS FILE IS NOT AN UP-TO-DATE INSTRUCTION FILE'/
     1' FOR THIS PROGRAM. '//
     2' YOU HAVE THE FOLLOWING 2 OPTIONS:'//
     3' YOU MAY USE A SAVED INSTRUCTION FILE FROM A PREVIOUS RUNNING '/
     4' OF THIS PROGRAM. THE 1ST LINE OF THE SAVED FILE MUST HAVE '/
     5' MONTBIG XXX_XX, WHERE XXX_XX IS AUG_08 OR A MORE RECENT DATE.'//
     6' OR YOU MAY SIMPLY ENTER DATA FROM THE KEYBOARD.'/)
	  CALL PAUSE
	  GO TO 145
	 ENDIF



        IF(ICODE .GE. 7) THEN

C  SKIP THIS LINE. IT CONTAINS 'MODEL FILENAME '
         READ(23,*)

        ENDIF


	READ(23,2) FORFILE
	WRITE(*,919) FORFILE
  919   FORMAT(/' YOUR MODEL FILE, ',A32,' MUST BE AN EDITED VERSION'/
     1' OF THE TEMPLATE FILE, TSTMULTM.FOR. AND IT MUST ALREADY HAVE'/
     2' BEEN COMPILED AND LINKED WITH THIS PROGRAM. IF THIS IS NOT'/
     3' THE CASE, STOP NOW, AND THEN RERUN THE PROGRAM. '//
     4' NOTE THAT IF YOU USE A MODEL FILE BASED ON A PREVIOUS '/
     5' TEMPLATE FILE, YOUR RESULTS WILL BE UNPREDICTABLE.'///)

	CALL PAUSE


C  CALL FULLNAME WHICH CONVERTS THE FILENAME TO PATHFILE, THE COMPLETE 
C  NAME OF THE FILE, WHICH INCLUDES THE PATH (IF THE PATH IS NOT THE 
C  CURRENT DIRECTORY).


 5010	TMPFILE = ' '
	TMPFILE = FORFILE
	CALL FULLNAME(PATH,TMPFILE,PATHFILE)
        OPEN(28,FILE=PATHFILE,ERR=50,STATUS='OLD',POSITION='APPEND')
	GO TO 30
   50   WRITE(*,4406) FORFILE
 4406    FORMAT(//' THE FOLLOWING FILE DOES NOT EXIST ... '/

     1'    ',A93/
     2' ENTER THE CORRECT FILENAME OR ... '/
     2' ENTER -99 TO SEE ALL OR A PART OF YOUR DIRECTORY: ') 

	READ(*,2) FORFILE
	IF(FORFILE(1:3) .EQ. '-99') CALL SEEDIR(PATH,NOB,FORFILE,
     1     OSname,ListDir)

	GO TO 5010

   30	CALL USERPREP(NDIM,NP,NVAR,MAXDIM,PAR,NOFIX,PARFIX,IRAN,INOPT,
     1  ICODE,ILIMIT,BOUND,INTLIST,RPAR,IPAR)

	CLOSE(28)


C  THE ABOVE CALL OBTAINS THE FOLLOWING VALUES:


C  NDIM = NO. OF STATES FOR THE O.D.E.
C  NP = TOTAL NO. OF PARAMETERS = NVAR + NOFIX.
C  NVAR = NO. OF R.V.'S (1 .LE. NVAR .LE. MAXDIM).
C  PAR(I),I=1,NVAR = NAMES OF THE RANDOM VARIABLES FOR THIS RUN.

C  NOFIX = NO. OF NON-RANDOM (FIXED) PARAMETERS WHOSE FIXED VALUES ARE 

C          TO BE SET BY THE USER. 
C  PARFIX(I),I=1,NOFIX = NAMES OF FIXED PARAMETERS FOR THIS RUN.
C  IRAN(I) = 1 IF PARAMATER I IS RANDOM;
C	     0 IF PARAMETER I IS FIXED; I = 1,NVAR+NOFIX.
C  ILIMIT(I),I=1,NVAR = 1 IF VARIABLE I IS UNLIMITED IN ITS ALLOWED
C   SIMULATION VALUE; = 0 IF ITS SIMULATED VALUES ARE TO BE LIMITED.
C  BOUND(I,J),J=1,2; I=1,NVAR. IF LIMIT(I) = 0, THEN THE SIMULATED
C   VALUES FOR R.V. I (TO SIMULATE A SUBJECT) MUST BE WITHIN THE
C   BOUNDS, [BOUND(I,1), BOUND(I,2)].


        IF(ICODE .GE. 7) THEN


         IF(ICODE .EQ. 7) THEN
C  SKIP THIS LINE. IT CONTAINS 'PREFIX'
          READ(23,*)
          READ(23,2222) PREFIX
C  SKIP THIS LINE. IT CONTAINS 'EXT'.
          READ(23,*)
          READ(23,222) EXT
         ENDIF

C  SKIP THIS LINE. IT CONTAINS 'ICSVFILE'
         READ(23,*)
         READ(23,*) ICSVFILE

C  SKIP THIS LINE. IT CONTAINS 'FILEIN'
         READ(23,*)
         READ(23,2) FILEIN

C  CHECK THAT THIS IS AN EXISTING FILE.

C  CALL FULLNAME WHICH CONVERTS THE FILENAME TO PATHFILE, THE COMPLETE 
C  NAME OF THE FILE, WHICH INCLUDES THE PATH (IF THE PATH IS NOT THE 
C  CURRENT DIRECTORY).

        IF(ICSVFILE .EQ. 0) THEN


         TMPFILE = ' '
         TMPFILE = FILEIN
         CALL FULLNAME(PATH,TMPFILE,PATHFILE)
         OPEN(67,FILE=PATHFILE,ERR=8440,STATUS='OLD')
         GO TO 8455
 8440    WRITE(*,5316) PATHFILE

        OPEN(42,FILE=ERRFIL)
         WRITE(42,5316) PATHFILE 
        CLOSE(42)



         CALL PAUSE
         STOP
 8455    CLOSE(67)



        ENDIF

C  IF ICSVFILE = 1, CREATE THE MULTIPLE DRUG WORKING COPY FILE 
C  XQZPJ001.ZMQ IN THE WORKING COPY DIRECTORY FROM THE DATA OF THE 
C  FIRST SUBJECT IN PATHFILE. NOTE THAT READBLOCK2 BELOW IS BASED ON
C  READBLOCK IN THE NPAG PC PREP PROGRAM, BUT ONLY CREATES A WORKING
C  COPY FILE FOR THE FIRST SUBJECT.

        IF(ICSVFILE .EQ. 1) THEN

         TMPFILE = ' '
         TMPFILE = FILEIN
         CALL FULLNAME(PATH,TMPFILE,PATHFILE)
         OPEN(87,FILE=PATHFILE,STATUS='OLD')

C  AS OF MONT101F.FOR, BEFORE CALLING NEWCSV, MUST CALL CONVERTCSV,
C  WHICH CONVERTS A "EUROPEAN" .CSV FILE TO THE TYPICAL "AMERICAN"
C  VERSION. IF THE .CSV FILE IS ALREADY IN THE "AMERICAN" FORMAT,
C  CONVERTCSV SIMPLY REWRITES FILE 87 TO SCRATCH FILE 77. NOTE THAT
C  NEWCSV CONVERTS FILE 77 TO FILE 67.

        CALL CONVERTCSV

C  CALL SUBROUTINE NEWCSV WHICH CONVERTS THE .CSV FILE IN FILE 77 TO
C  A NEW .CSV FILE IN FILE 67, WITH ALL MISSING VALUE DOTS CHANGED TO
C  n's. THEN CALL CSVCHANGE WHICH CHANGES .csv FILES WITH CODE OF
C  POPDATA DEC_11 (I.E., THOSE WITH 2 EXTRA COLUMNS FOR ADDL AND II)
C  TO EQUIVALENT .csv FILES WITH CODE OF POPDATA APR_11 (THOSE WITHOUT
C  THE TWO EXTRA COLUMNS). CSVCHANGE READS FILE 67, AND WRITES THE 
C  INFORMATION TO SCRATCH FILE 66. NOTE THAT IF THE .csv FILE READ IN
C  ALREADY IS THE OLDER VERSION (WITH CODE POPDATA APR_11), CSVCHANGE
C  SIMPLY REWRITES IT TO FILE 66, WHICH IS THEN READ BY SUBROUTINE
C  READBLOCK2.


         OPEN(67)
         CALL NEWCSV
         CALL CSVCHANGE
         REWIND(66)
         CALL READBLOCK2(PATH,C0,C1,C2,C3,INTLIST,RPAR,IPAR)
         CLOSE(66)

C  NOW OPEN THE JUST MADE WORKING COPY PATIENT DATA FILE.

         TMPFILE = ' '
         TMPFILE = 'XQZPJ001.ZMQ'
         CALL FULLNAME(PATH,TMPFILE,PATHFILE)
         OPEN(21,FILE=PATHFILE,ERR=8465,STATUS='OLD')
         GO TO 8470
 8465    WRITE(*,5466) PATHFILE,FILEIN

        OPEN(42,FILE=ERRFIL)
         WRITE(42,5466) PATHFILE,FILEIN
        CLOSE(42)



         CALL PAUSE
         STOP

 8470    CONTINUE
         CLOSE(21)

        ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(ICSVFILE .EQ. 1) CONDITION.



C  SKIP THIS LINE. IT CONTAINS 'NSUB'.
         READ(23,*)
         READ(23,*) NSUB

C  NOTE THAT NOFIX WAS OBTAINED ABOVE IN THE CALL TO USERPREP, BUT IT
C  MUST BE READ IN BELOW SO MAURICE'S GUI WILL KNOW WHETHER THE 
C  FOLLOWING LINE CONTAINS FIXED VALUES OR NOT (AS OF MONTBIG7.FOR).
C  NOTE THAT MAURICE'S GUI IS NO LONGER UP TO DATE.

C  SKIP THIS LINE. IT CONTAINS 'NOFIX'.

         READ(23,*)
         READ(23,*) NOFIX

C  SKIP THIS LINE. IT CONTAINS 'VALFIX ARRAY IF NOFIX > 0'.
         READ(23,*)
         IF(NOFIX .GT. 0) READ(23,*) (VALFIX(I),I=1,NOFIX)

C  CHECK THAT NOFIX .LE. 20. IF NOT, PRINT MESSAGE TO USER AND STOP.

	 IF(NOFIX .GT. 20) THEN

	  WRITE(*,3177) NOFIX
 3177     FORMAT(/' NOFIX WAS READ IN FROM THE INSTRUCTION FILE TO '/
     1' BE ', I3,'. THIS IS > 20, THE MAXIMUM ALLOWED VALUE.'//
     2' PLEASE RERUN THE PROGRAM WITH KEYBOARD ENTRY, OR USE AN '/
     3' INSTRUCTION FILE HAVING NOFIX .LE. 20.')

        OPEN(42,FILE=ERRFIL)
         WRITE(42,3177) NOFIX
        CLOSE(42)



	  CALL PAUSE
	  STOP

	 ENDIF


C  SEE NOTES BELOW REGARDING MF,RTOL,ATOL.


C  SKIP THIS LINE. IT CONTAINS 'TOLER'.
         READ(23,*)
         READ(23,*) TOLER
	   RTOL = TOLER

         DO I=1,NDIM
          ATOL(I) = TOLER
         END DO

         MF = 22


C  SKIP THIS LINE. IT CONTAINS 'NUMEQT'.
         READ(23,*)
         READ(23,*) NUMEQT
         INTLIST(9) = NUMEQT

C  SKIP THIS LINE. IT CONTAINS 'NUMEQT LINES OF ASSAY COEFFICIENTS'.
         READ(23,*)

         DO IEQ=1,NUMEQT
          READ(23,*) C0(IEQ),C1(IEQ),C2(IEQ),C3(IEQ)
         END DO

C  SKIP THIS LINE. IT CONTAINS 'ERROR COEFFS. FOR DOSE TIMES'.
         READ(23,*)
         READ(23,*) C0DT,C1DT,C2DT,C3DT
	
C  SKIP THIS LINE. IT CONTAINS 'ERROR COEFFS. FOR DOSE AMOUNTS'.
         READ(23,*)
         READ(23,*) C0DA,C1DA,C2DA,C3DA


C  SKIP THIS LINE. IT CONTAINS 'ERROR COEFFS. FOR OBSEVATION TIMES'.
         READ(23,*)
         READ(23,*) C0OT,C1OT,C2OT,C3OT

C  SKIP THIS LINE. IT CONTAINS 'IDIST'.

         READ(23,*)
         READ(23,*) IDIST


C  SKIP THIS LINE. IT CONTAINS 'NGAUS'
         READ(23,*)
         READ(23,*) NGAUS



C  SKIP THIS LINE. IT CONTAINS 
C   'NGAUS SETS OF COF(.), AMEAN(.,.), COV(.,.,.)'.
         READ(23,*)

         DO IGAUS=1,NGAUS
          READ(23,*) COF(IGAUS)

          READ(23,*) (AMEAN(IGAUS,I),I=1,NVAR)
           DO I=1,NVAR
            READ(23,*) (COV(IGAUS,I,J),J=1,I)
           END DO
         END DO

C  SKIP THIS LINE. IT CONTAINS 'FILOUT'.
         READ(23,*)
         READ(23,2) FILOUT


C  READ IN IPRNPAT.
C  IPRNPAT = 0 --> PATIENT FILES WILL NOT BE CREATED. THIS OPTION IS FOR
C   THOSE USERS WHO JUST WANT TO USE THE INFO WRITTEN TO THE OUPUT FILE.
C  IPRNPAT = 1 --> PATIENT INFO WILL BE WRITTEN TO A .CSV FILE OF THE
C                  USER'S CHOICE. THE PATIENT DATA FILES WHICH ARE
C                  CREATED WILL BE ERASED AFTER THE .CSV FILE IS MADE. 
C  IPRNPAT = 2 --> PATIENT FILES WILL BE CREATED, BUT A .CSV FILE WILL
C                  NOT BE MADE.
C  IPRNPAT = 3 --> PATIENT INFO WILL BE WRITTEN TO A .CSV FILE OF THE
C                  USER'S CHOICE, AND PATIENT FILES WILL ALSO BE
C                  CREATED.



C  SKIP THIS LINE. IT CONTAINS 'IPRNPAT'.
         READ(23,*)
         READ(23,*) IPRNPAT


         IF(ICODE .EQ. 7) THEN
          IF(IPRNPAT .EQ. 1) IPRNPAT = 2
         ENDIF

         IF(ICODE .GE. 8) THEN

C  SKIP THIS LINE. IT CONTAINS 'OUTCSVNAME'
          READ(23,*)
          READ(23,2) OUTCSVNAME
C  NOTE THAT OUTCSVNAME WILL NOT BE USED UNLESS IPRNPAT = 1 OR 3.


C  SKIP THIS LINE. IT CONTAINS 'PREFIX'
          READ(23,*)

 
          READ(23,2222) PREFIX
C  SKIP THIS LINE. IT CONTAINS 'EXT'.
          READ(23,*)
          READ(23,222) EXT
C  NOTE THAT PREFIX AND EXT WILL NOT BE USED UNLESS IPRNPAT = 2 OR 3.

         ENDIF

C  SKIP THIS LINE. IT CONTAINS 'ISEEDIND'.


         READ(23,*)
         READ(23,*) ISEEDIND

C  AS OF MONTBIG9.FOR, THE SEED INDICATOR, ISEEDIND IS READ IN. IF
C  ISEEDIND = 1, THIS PROGRAM WILL USE THE DEFAULT SEED = -17;

C  ISEEDIND = 0, THIS PROGRAM WILL USE THE SEED NO. STORED INTO
C    SEEDTO.MON (AND UPDATE THE VALUE IN THAT FILE BY -123 FOR THE
C    NEXT RUN).




         CLOSE(23)

         GO TO 7300

        ENDIF 


C  THE ABOVE ENDIF IS FOR THE  IF(ICODE .GE. 7)  CONDITION


C THE CODE BELOW IS FOR THE ICODE .LT. 7 CASE.

        READ(23,2222) PREFIX

        READ(23,222) EXT

        IF(ICODE .LT. 6) ICSVFILE = 0
        IF(ICODE .GE. 6) READ(23,*) ICSVFILE

	 READ(23,2) FILEIN


C  CHECK THAT THIS IS AN EXISTING FILE.

C  CALL FULLNAME WHICH CONVERTS THE FILENAME TO PATHFILE, THE COMPLETE 

C  NAME OF THE FILE, WHICH INCLUDES THE PATH (IF THE PATH IS NOT THE 
C  CURRENT DIRECTORY).

        IF(ICSVFILE .EQ. 0) THEN
         TMPFILE = ' '
         TMPFILE = FILEIN
         CALL FULLNAME(PATH,TMPFILE,PATHFILE)
         OPEN(67,FILE=PATHFILE,ERR=7440,STATUS='OLD')
         GO TO 7455

 7440    WRITE(*,5316) PATHFILE

        OPEN(42,FILE=ERRFIL)
         WRITE(42,5316) PATHFILE 
        CLOSE(42)



         CALL PAUSE
         STOP

 7455    CLOSE(67)



        ENDIF

C  IF ICSVFILE = 1, CREATE THE MULTIPLE DRUG WORKING COPY FILE 
C  XQZPJ001.ZMQ IN THE WORKING COPY DIRECTORY FROM THE DATA OF THE 
C  FIRST SUBJECT IN PATHFILE. NOTE THAT READBLOCK2 BELOW IS BASED ON
C  READBLOCK IN THE NPAG PC PREP PROGRAM, BUT ONLY CREATES A WORKING
C  COPY FILE FOR THE FIRST SUBJECT.


        IF(ICSVFILE .EQ. 1) THEN


         TMPFILE = ' '
         TMPFILE = FILEIN
         CALL FULLNAME(PATH,TMPFILE,PATHFILE)
         OPEN(87,FILE=PATHFILE,STATUS='OLD')


C  AS OF MONT101F.FOR, BEFORE CALLING NEWCSV, MUST CALL CONVERTCSV,
C  WHICH CONVERTS A "EUROPEAN" .CSV FILE TO THE TYPICAL "AMERICAN"
C  VERSION. IF THE .CSV FILE IS ALREADY IN THE "AMERICAN" FORMAT,
C  CONVERTCSV SIMPLY REWRITES FILE 87 TO SCRATCH FILE 77. NOTE THAT
C  NEWCSV CONVERTS FILE 77 TO FILE 67.

        CALL CONVERTCSV

C  CALL SUBROUTINE NEWCSV WHICH CONVERTS THE .CSV FILE IN FILE 77 TO
C  A NEW .CSV FILE IN FILE 67, WITH ALL MISSING VALUE DOTS CHANGED TO
C  n's. THEN CALL CSVCHANGE WHICH CHANGES .csv FILES WITH CODE OF
C  POPDATA DEC_11 (I.E., THOSE WITH 2 EXTRA COLUMNS FOR ADDL AND II)
C  TO EQUIVALENT .csv FILES WITH CODE OF POPDATA APR_11 (THOSE WITHOUT
C  THE TWO EXTRA COLUMNS). CSVCHANGE READS FILE 67, AND WRITES THE 
C  INFORMATION TO SCRATCH FILE 66. NOTE THAT IF THE .csv FILE READ IN
C  ALREADY IS THE OLDER VERSION (WITH CODE POPDATA APR_11), CSVCHANGE
C  SIMPLY REWRITES IT TO FILE 66, WHICH IS THEN READ BY SUBROUTINE
C  READBLOCK2.

         OPEN(67)
         CALL NEWCSV
         CALL CSVCHANGE
         REWIND(66)
         CALL READBLOCK2(PATH,C0,C1,C2,C3,INTLIST,RPAR,IPAR)
         CLOSE(66)

C  NOW OPEN THE JUST MADE WORKING COPY PATIENT DATA FILE.

         TMPFILE = ' '
         TMPFILE = 'XQZPJ001.ZMQ'
         CALL FULLNAME(PATH,TMPFILE,PATHFILE)
         OPEN(21,FILE=PATHFILE,ERR=7465,STATUS='OLD')
         GO TO 7470

 7465    WRITE(*,5466) PATHFILE,FILEIN

        OPEN(42,FILE=ERRFIL)
         WRITE(42,5466) PATHFILE,FILEIN
        CLOSE(42)



         CALL PAUSE

         STOP

 7470    CONTINUE
         CLOSE(21)

        ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(ICSVFILE .EQ. 1) CONDITION.

	 READ(23,*) NSUB

C  NOTE THAT NOFIX WAS OBTAINED ABOVE IN THE CALL TO USERPREP, BUT IT
C  MUST BE READ IN BELOW SO MAURICE'S GUI WILL KNOW WHETHER THE 
C  FOLLOWING LINE CONTAINS FIXED VALUES OR NOT (AS OF MONTBIG7.FOR).

	 READ(23,*) NOFIX
	 IF(NOFIX .GT. 0) READ(23,*) (VALFIX(I),I=1,NOFIX)

C  CHECK THAT NOFIX .LE. 20. IF NOT, PRINT MESSAGE TO USER AND STOP.

	 IF(NOFIX .GT. 20) THEN



	  WRITE(*,3177) NOFIX

        OPEN(42,FILE=ERRFIL)
         WRITE(42,3177) NOFIX    
        CLOSE(42)



	  CALL PAUSE
	  STOP



	 ENDIF


C  READ IN VALUES FOR MF, RTOL, AND ATOL, WHICH ARE NEEDED FOR THE 
C  O.D.E. SOLVER USED BY ROUTINE USERANAL (IN MODULE SIMBIG.FOR).

C MF     = Method flag.  Standard values are..
C          10 for nonstiff (Adams) method, no Jacobian used.
C          21 for stiff (BDF) method, user-supplied full Jacobian.


C          22 for stiff method, internally generated full Jacobian.

C	   FOR NOW MF = 22 WILL BE HARDCODED (SINCE THERE IS NO
C	   JACOBIAN SUBROUTINE (JACOB HAS BEEN TAKEN OUT FOR NOW).


C          24 for stiff method, user-supplied banded Jacobian.

C          25 for stiff method, internally generated banded Jacobian.
C RTOL   = Relative tolerance parameter (scalar).
C ATOL   = Absolute tolerance parameter.

C          The estimated local error in X(i) will be controlled so as
C          to be roughly less (in magnitude) than
C             EWT(i) = RTOL*abs(X(i)) + ATOL(i)  SINCE ITOL = 2.
C          Thus the local error test passes if, in each component,

C          either the absolute error is less than ATOL (or ATOL(i)),
C          or the relative error is less than RTOL.
C          Use RTOL = 0.0 for pure absolute error control, and
C          use ATOL = 0.0 (or ATOL(i) = 0.0) for pure relative error
C          control.  Caution.. Actual (global) errors may exceed these

C          local tolerances, so choose them conservatively.


	 READ(23,*) TOLER
	
	 RTOL = TOLER


	 DO I=1,NDIM
	  ATOL(I) = TOLER
	 END DO

	 MF = 22

	 READ(23,*) NUMEQT
         INTLIST(9) = NUMEQT


	 DO IEQ=1,NUMEQT
	  READ(23,*) C0(IEQ),C1(IEQ),C2(IEQ),C3(IEQ)

	 END DO

	 READ(23,*) C0DT,C1DT,C2DT,C3DT
	 READ(23,*) C0DA,C1DA,C2DA,C3DA
	 READ(23,*) C0OT,C1OT,C2OT,C3OT

	 READ(23,*) IDIST
	 READ(23,*) NGAUS


	 DO IGAUS=1,NGAUS

	  READ(23,*) COF(IGAUS)
	  READ(23,*) (AMEAN(IGAUS,I),I=1,NVAR)
	   DO I=1,NVAR
          READ(23,*) (COV(IGAUS,I,J),J=1,I)
	   END DO
	 END DO

	 READ(23,2) FILOUT

C  READ IN IPRNPAT - SEE ABOVE.

	 READ(23,*) IPRNPAT
       IF(IPRNPAT .EQ. 1) IPRNPAT = 2

	 READ(23,*) ISEEDIND

C  AS OF MONTBIG9.FOR, THE SEED INDICATOR, ISEEDIND IS READ IN. IF


C  ISEEDIND = 1, THIS PROGRAM WILL USE THE DEFAULT SEED = -17;
C  ISEEDIND = 0, THIS PROGRAM WILL USE THE SEED NO. STORED INTO
C    SEEDTO.MON (AND UPDATE THE VALUE IN THAT FILE BY -123 FOR THE
C    NEXT RUN).

	 CLOSE(23)


	ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(INOPT .EQ. 1)  CONDITION.


	IF(INOPT .EQ. 0) THEN


C  INPUT THE NAME OF THE FORTRAN FILE WHICH HAS ALREADY BEEN LINKED
C  INTO THIS PROGRAM (SEE FORMAT 919 ABOVE). THIS FILE, IDENTIFIES THE 
C  MODEL AND THE PARAMETERS FOR THE USER'S ANALYSIS. THEN CALL 
C  SUBROUTINE USERPREP TO INPUT VALUES FROM THIS FILE.

        WRITE(*,5001)
 5001   FORMAT(/' ENTER THE NAME OF THE FORTRAN FILE WHICH HAS BEEN'/
     1' LINKED WITH THIS PROGRAM. NOTE THAT IT MUST BE AN EDITED '/
     2' VERSION OF THE TEMPLATE FILE, TSTMULTM.FOR. IF THIS IS NOT'/
     3' THE CASE, STOP NOW, AND THEN RERUN THE PROGRAM. '//
     4' NOTE THAT IF YOU USE A MODEL FILE BASED ON A PREVIOUS '/
     5' TEMPLATE FILE, YOUR RESLTS WILL BE UNPREDICTABLE.'///
     6' ENTER YOUR MODEL FILE NOW IF IT IS AN EDITED VERSION OF '/
     7' TSTMULTM.FOR: ')

     	  READ(*,2) FORFILE

C wmy2018.02.13 debug
C         write (*,*) "presumably got the model file name", FORFILE

C  CALL FULLNAME WHICH CONVERTS THE FILENAME TO PATHFILE, THE COMPLETE 
C  NAME OF THE FILE, WHICH INCLUDES THE PATH (IF THE PATH IS NOT THE 

C  CURRENT DIRECTORY).



 9010	TMPFILE = ' '
	TMPFILE = FORFILE
	CALL FULLNAME(PATH,TMPFILE,PATHFILE)

C        write (*,*) "... openning", PATHFILE

        OPEN(28,FILE=PATHFILE,ERR=950,STATUS='OLD',POSITION='APPEND')
	GO TO 930
  950   WRITE(*,4406) FORFILE
	READ(*,2) FORFILE
	IF(FORFILE(1:3) .EQ. '-99') CALL SEEDIR(PATH,NOB,FORFILE,
     1     OSname,ListDir)
	GO TO 9010

C wmy2019.02.13
  930   continue
C       write (*,*) "Openned FORFILE, and Calling Userprep"

  	CALL USERPREP(NDIM,NP,NVAR,MAXDIM,PAR,NOFIX,PARFIX,IRAN,INOPT,
     1  ICODE,ILIMIT,BOUND,INTLIST,RPAR,IPAR)

	CLOSE(28)

C  THE ABOVE CALL OBTAINS THE FOLLOWING VALUES:

C  NDIM = NO. OF STATES FOR THE O.D.E.
C  NP = TOTAL NO. OF PARAMETERS = NVAR + NOFIX.
C  NVAR = NO. OF R.V.'S (1 .LE. NVAR .LE. MAXDIM).
C  PAR(I),I=1,NVAR = NAMES OF THE RANDOM VARIABLES FOR THIS RUN.

C  NOFIX = NO. OF NON-RANDOM (FIXED) PARAMETERS WHOSE FIXED VALUES ARE 
C          TO BE SET BY THE USER. 
C  PARFIX(I),I=1,NOFIX = NAMES OF FIXED PARAMETERS FOR THIS RUN.

C  IRAN(I) = 1 IF PARAMATER I IS RANDOM;
C	     0 IF PARAMETER I IS FIXED; I = 1,NVAR+NOFIX.
C  ILIMIT(I),I=1,NVAR = 1 IF VARIABLE I IS UNLIMITED IN ITS ALLOWED
C   SIMULATION VALUE; = 0 IF ITS SIMULATED VALUES ARE TO BE LIMITED.
C  BOUND(I,J),J=1,2; I=1,NVAR. IF LIMIT(I) = 0, THEN THE SIMULATED
C   VALUES FOR R.V. I (TO SIMULATE A SUBJECT) MUST BE WITHIN THE
C   BOUNDS, [BOUND(I,1), BOUND(I,2)].



 5020   WRITE(*,5002)
 5002   FORMAT(/' THE DOSE/COVARIATE AND OBSERVATION TIME INFORMATION'/
     1' WHICH WILL BE USED TO SIMULATE THE PATIENT DATA FILES CAN BE'/
     2' INPUT VIA A (MULTIPLE DRUG) WORKING COPY PATIENT DATA FILE OR'/
     3' VIA A BLOCK MATRIX .CSV FILE (THE INFO WILL COME FROM THE '/
     4' DATE OF THE FIRST SUBJECT IN THIS CASE).'//
     5' ENTER 1 TO ENTER INFO USING A .CSV FILE; '/

     6' ENTER 0 TO ENTER INFO USING A WORKING COPY PATIENT DATA FILE: ')
        READ(*,*,ERR=5020) ICSVFILE
        IF(ICSVFILE .NE. 1 .AND. ICSVFILE .NE. 0) GO TO 5020



        IF(ICSVFILE .EQ. 0) THEN


        WRITE(*,1021)
 1021   FORMAT(/' ENTER THE NAME OF THE WORKING COPY PATIENT DATA FILE'/
     1' WHICH CONTAINS THE DOSE/COVARIATE INFORMATION WHICH WILL BE'/
     2' USED TO SIMULATE THE PATIENT DATA FILES.'//
     3' BE SURE THAT THIS IS A MULTI-DRUG WORKING COPY DATA FILE.'//
     1' ENTER -99 TO SEE ALL OR A PART OF YOUR DIRECTORY: ')
     	  READ(*,2) FILEIN
        IF(FILEIN(1:3) .EQ. '-99') CALL SEEDIR(PATH,NOB,FILEIN,
     1     OSname,ListDir)


C  CHECK THAT THIS IS AN EXISTING FILE.

C  CALL FULLNAME WHICH CONVERTS THE FILENAME TO PATHFILE, THE COMPLETE 
C  NAME OF THE FILE, WHICH INCLUDES THE PATH (IF THE PATH IS NOT THE 
C  CURRENT DIRECTORY).

	TMPFILE = ' '
	TMPFILE = FILEIN
	CALL FULLNAME(PATH,TMPFILE,PATHFILE)

	OPEN(21,FILE=PATHFILE,ERR=6440,STATUS='OLD')
	GO TO 6455
 6440   WRITE(*,5316) PATHFILE
	GO TO 5020
 6455   CONTINUE

        ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(ICSVFILE .EQ. 0) CONDITION.


        IF(ICSVFILE .EQ. 1) THEN


        WRITE(*,3021)
 3021   FORMAT(/' ENTER THE NAME OF THE BLOCK MATRIX .CSV FILE. ONLY'/
     1' THE DATA FROM THE FIRST SUBJECT IN THIS FILE WILL BE READ TO'/
     2' OBTAIN THE DOSE/COVARIATE INFORMATION WHICH WILL BE USED TO'/
     3' TO SIMULATE THE PATIENT DATA FILES.'//
     1' ENTER -99 TO SEE ALL OR A PART OF YOUR DIRECTORY: ')
     	  READ(*,2) FILEIN
        IF(FILEIN(1:3) .EQ. '-99') CALL SEEDIR(PATH,NOB,FILEIN,
     1     OSname,ListDir)

C  CHECK THAT THIS IS AN EXISTING FILE.


C  CALL FULLNAME WHICH CONVERTS THE FILENAME TO PATHFILE, THE COMPLETE 
C  NAME OF THE FILE, WHICH INCLUDES THE PATH (IF THE PATH IS NOT THE 
C  CURRENT DIRECTORY).

        TMPFILE = ' '
        TMPFILE = FILEIN
        CALL FULLNAME(PATH,TMPFILE,PATHFILE)
        OPEN(87,FILE=PATHFILE,ERR=5440,STATUS='OLD')
        GO TO 5455
 5440   WRITE(*,5316) PATHFILE
        GO TO 5020
 5455   CONTINUE

C  AS OF MONT101F.FOR, BEFORE CALLING NEWCSV, MUST CALL CONVERTCSV,
C  WHICH CONVERTS A "EUROPEAN" .CSV FILE TO THE TYPICAL "AMERICAN"
C  VERSION. IF THE .CSV FILE IS ALREADY IN THE "AMERICAN" FORMAT,
C  CONVERTCSV SIMPLY REWRITES FILE 87 TO SCRATCH FILE 77. NOTE THAT
C  NEWCSV CONVERTS FILE 77 TO FILE 67.

        CALL CONVERTCSV


C  CALL SUBROUTINE NEWCSV WHICH CONVERTS THE .CSV FILE IN FILE 77 TO
C  A NEW .CSV FILE IN FILE 67, WITH ALL MISSING VALUE DOTS CHANGED TO
C  n's. THEN CALL CSVCHANGE WHICH CHANGES .csv FILES WITH CODE OF
C  POPDATA DEC_11 (I.E., THOSE WITH 2 EXTRA COLUMNS FOR ADDL AND II)
C  TO EQUIVALENT .csv FILES WITH CODE OF POPDATA APR_11 (THOSE WITHOUT
C  THE TWO EXTRA COLUMNS). CSVCHANGE READS FILE 67, AND WRITES THE 
C  INFORMATION TO SCRATCH FILE 66. NOTE THAT IF THE .csv FILE READ IN
C  ALREADY IS THE OLDER VERSION (WITH CODE POPDATA APR_11), CSVCHANGE
C  SIMPLY REWRITES IT TO FILE 66, WHICH IS THEN READ BY SUBROUTINE
C  READBLOCK2.

         OPEN(67)
         CALL NEWCSV
         CALL CSVCHANGE
         REWIND(66)
         CALL READBLOCK2(PATH,C0,C1,C2,C3,INTLIST,RPAR,IPAR)
         CLOSE(66)


C  NOW OPEN THE JUST MADE WORKING COPY PATIENT DATA FILE.

        TMPFILE = ' '
        TMPFILE = 'XQZPJ001.ZMQ'
        CALL FULLNAME(PATH,TMPFILE,PATHFILE)
        OPEN(21,FILE=PATHFILE,ERR=5465,STATUS='OLD')
        GO TO 5470
 5465   WRITE(*,5466) PATHFILE,FILEIN
 5466   FORMAT(//' THE FOLLOWING FILE DOES NOT EXIST ... '/
     1' ',A93/
     2' WHICH MEANS THAT YOUR .CSV FILE, ',A20,' WAS NOT READ '/
     3' PROPERLY. PLEASE CHECK THIS FILE TO MAKE SURE IT IS CORRECT.'//)
        GO TO 5020

 5470   CONTINUE

        ENDIF


C  THE ABOVE ENDIF IS FOR THE  IF(ICSVFILE .EQ. 1) CONDITION.



C  CALL SUBROUTINE GETNUMEQ, WHICH READS FILE 21 OPENED ABOVE TO GET
C  THE NO. OF OUTPUT EQUATIONS (NUMEQT). 

	CALL GETNUMEQ(NUMEQT,INTLIST,RPAR,IPAR)
	CLOSE(21)


        WRITE(*,21) 
   21   FORMAT(/' ENTER THE NO. OF SUBJECTS TO BE SIMULATED. THIS '/
     1' NUMBER MUST BE LESS THAN OR EQUAL TO 10000.'//
     2' NOTE THAT IF YOU SELECT TO HAVE ONE SUBJECT SIMULATED WITH'/
     3' EXACTLY THE PARAMETER VALUES OF EACH GRID PT. FROM THE LAST'/
     4' CYCLE OF AN NPAG RUN, THIS VALUE WILL BE IRRELEVANT: ')

 4070	READ(*,*,ERR=4075) NSUB
        GO TO 4078
 4075	WRITE(*,4076)
 4076	FORMAT(/' SEE ABOVE; ENTER AN INTEGER BETWEEN 1 AND 10000: ')
	GO TO 4070



 4078	IF(NSUB .LE. 0 .OR. NSUB .GT. 10000) GO TO 4075


	IF(NOFIX .GT. 0) THEN
	  WRITE(*,4836) NOFIX
 4836     FORMAT(/' ENTER, THE ',I2,' FIXED PARAMETER VALUES: ')
	  DO 9190 I=1,NOFIX
	  WRITE(*,2112) PARFIX(I)
 2112     FORMAT(/' ',A11,': ')
 7110     READ(*,*,ERR=7115) VALFIX(I)
	  GO TO 9190
 7115     WRITE(*,7116)
 7116     FORMAT(/' SEE ABOVE; ENTER A NON-NEGATIVE NUMBER: ')
	  GO TO 7110
 9190     CONTINUE
	ENDIF


  915   WRITE(*,913)
  913   FORMAT(/' ENTER 1 TO SET ALL TOLERANCES (FOR THE O.D.E. '/
     1'         SOLVER) TO THE DEFAULT VALUE ... 1.D-4.'/
     2' ENTER 0 TO SELECT A DIFFERENT VALUE FOR THE TOLERANCES: ')
	READ(*,*,ERR=915) ITOL
	IF(ITOL .NE. 0 .AND. ITOL .NE. 1) GO TO 915



	TOLER=1.D-4

	IF(ITOL .EQ. 0) THEN

  910	WRITE(*,914) 
  914  FORMAT(/' ENTER A POSITIVE VALUE FOR THE TOLERANCE PARAMETERS: ')
	READ(*,*,ERR=910) TOLER
	IF(TOLER .LE. 0.D0) GO TO 910

	ENDIF

	RTOL = TOLER
	DO I=1,NDIM
	 ATOL(I) = TOLER
	END DO


	MF = 22


	WRITE(*,19) 
   19 FORMAT(//' FOR EACH OUTPUT EQUATION, ENTER, IN ORDER, '/
     1' C0,C1,C2,C3, WHERE, FOR EACH OBSERVED VALUE, Y, THE ASSAY'/
     3' STANDARD DEVIATION IS SD = C0+C1*Y+C2*Y**2+C3*Y**3):')

	DO IEQ = 1,NUMEQT
	 WRITE(*,1119) IEQ
 1119    FORMAT(/' ENTER THE VALUES FOR [C0,C1,C2,C3] FOR OUTPUT'/
     1'  EQUATION ',I1,': ')
 4140    READ(*,*,ERR=4145) C0(IEQ),C1(IEQ),C2(IEQ),C3(IEQ)
   	 GO TO 2120
 4145    WRITE(*,4146)
 4146    FORMAT(/' SEE ABOVE; PLEASE ENTER FOUR REAL NUMBERS: ')
	 GO TO 4140
 2120	 CONTINUE
	END DO


 2020	WRITE(*,219)
  219 FORMAT(//' THE DOSE TIMES, THE DOSE AMOUNTS (INCLUDING ALL BOLUS'/
     1' VALUES AND THE IV RATE WHICH IS ASSUMED TO BE THE 2ND ENTRY'/
     2' IN EACH DOSE ROW), AND THE OBSERVATION TIMES WHICH THE PROGRAM'/
     3' HAS READ FROM THE WORKING COPY PATIENT DATA FILE ABOVE WILL '/
     4' ALL BE ASSUMED TO BE "NOISY" VALUES.'//
     5' ENTER 0 FOR AN EXPLANATION OF HOW THE "NOISY" VALUES ARE OBTAINE

     1D.'/
     6' ENTER 1 TO CONTINUE: ')
	READ(*,*,ERR= 2020) ICONT

	IF(ICONT .NE. 0 .AND. ICONT .NE. 1) GO TO 2020

	IF(ICONT .EQ. 0) CALL EXPLAINOISE

	WRITE(*,6223)
 6223   FORMAT(/' ENTER C0,C1,C2,C3 FOR THE DOSE TIMES: ')
 6140   READ(*,*,ERR=6145) C0DT,C1DT,C2DT,C3DT
   	GO TO 6120
 6145   WRITE(*,4146)
	GO TO 6140
 6120	CONTINUE

	WRITE(*,7223)
 7223   FORMAT(/' ENTER C0,C1,C2,C3 FOR THE DOSE AMOUNTS: ')
 7140   READ(*,*,ERR=7145) C0DA,C1DA,C2DA,C3DA
   	GO TO 7120
 7145   WRITE(*,4146)
	GO TO 7140
 7120	CONTINUE

	WRITE(*,8223)
 8223   FORMAT(/' ENTER C0,C1,C2,C3 FOR THE OBSERVATION TIMES: ')
 8140   READ(*,*,ERR=8145) C0OT,C1OT,C2OT,C3OT
   	GO TO 8120
 8145   WRITE(*,4146)
	GO TO 8140


 8120	CONTINUE



C  CALL GETDIST TO OBTAIN THE DESIRED DISTRIBUTION DETAILS FROM THE 
C  USER.

	CALL GETDIST(IDIST,NGAUS,NVAR,COF,AMEAN,COV,PATH,NOB,OUTNPAG,
     1 TEXTFILE,OSname,ListDir,INTLIST,RPAR,IPAR)

      WRITE(*,1117)
 1117 FORMAT(/,' ENTER THE OUTPUT FILENAME WHICH WILL CONTAIN ALL THE'/
     1' GENERATED DATA OF THIS PROGRAM: ')

      READ(*,2) FILOUT

C  FILOUT WILL CONTAIN, FOR EACH OF THE NSUB PATIENTS:

C      ALF(I),I=1,NP, THE GENERATED PARAMETER VALUES. 
C      AS(J,K), J=1,M; K=1,NOS THE N(0,1) VALUES USED IN 
C             ESTABLISHING THE ASSAY NOISE VALUES (M = NO. OF 
C             OBSERVATION TIMES; K = NO. OF OUTPUT EQUATIONS; THEY

C	      ARE INPUT IN SUBROUTINE INOUT). 
C      Y(J,K), J=1,M; K=1,NOS = THE OUTPUT CONCENTRATIONS (WHICH HAVE
C             BEEN 'CORRUPTED' WITH THE ASSAY NOISE.


C  READ IN IPRNPAT ... SEE COMMENTS ABOVE.

 1230	  WRITE(*,1234) NSUB,NSUB
 1234   FORMAT(/' ENTER 1 IF YOU WOULD LIKE THE INFORMATION FROM '/
     1'         THE ',I5,' SIMULATED PATIENT DATA FILES TO BE SAVED'/
     2'         IN BLOCK FORMAT TO A .CSV FILE; '/
     3' ENTER 2 IF YOU WOULD LIKE TO CREATE THE ',I5,' SIMULATED '/
     4'         PATIENT DATA FILES IN WORKING COPY FORMAT; '/
     5' ENTER 3 IF YOU WOULD LIKE BOTH A .CSV FILE AND A SET OF '/


     6'         WORKING COPY FILES TO BE MADE;'/
     7' ENTER 0 IF YOU DO NOT NEED A .CSV FILE OR A SET OF WORKING '/
     8'         COPY FILES (I.E., YOU ONLY NEED THE INFO THAT IS '/
     9'         SUPPLIED IN THE OUTPUT FILE): ')
        READ(*,*,ERR=1230) IPRNPAT
        IF(IPRNPAT .LT. 0 .OR. IPRNPAT .GT. 3) GO TO 1230

        IF(IPRNPAT .EQ. 1 .OR. IPRNPAT .EQ. 3) THEN

 1390    WRITE(*,1236)
 1236    FORMAT(/' ENTER THE NAME OF THE FILE WHICH WILL STORE THE'/
     1' SIMULATED INFO IN .CSV FORMAT: ')
         
         READ(*,2) OUTCSVNAME

C  CALL FULLNAME WHICH CONVERTS THE FILENAME TO PATHFILE, THE COMPLETE 
C  NAME OF THE FILE, WHICH INCLUDES THE PATH (IF THE PATH IS NOT THE 
C  CURRENT DIRECTORY).

 1380	   TMPFILE = ' '
         TMPFILE = OUTCSVNAME
         CALL FULLNAME(PATH,TMPFILE,PATHFILE)
         OPEN(29,FILE=PATHFILE,ERR=1370,STATUS='NEW')
         GO TO 1375
 1370    WRITE(*,9826) PATHFILE
         READ(*,*,ERR=1370) IFILE
         IF(IFILE .NE. 0 .AND. IFILE .NE. 1) GO TO 1370

         IF(IFILE .EQ. 0) GO TO 1390
         IF(IFILE .EQ. 1) OPEN(29,FILE=PATHFILE)


 1375    CLOSE(29)


        ENDIF

        
        IF(IPRNPAT .EQ. 2 .OR. IPRNPAT .EQ. 3) THEN

         WRITE(*,4041)
 4041    FORMAT(/' ENTER THE 3-CHAR PREFIX FOR THE SIMULATED PATIENT'/
     1' FILENAMES : ')
         READ(*,2222) PREFIX

         WRITE(*,4043)
 4043	   FORMAT(/' IF THERE IS A 3-CHAR EXTENSION FOR THE PATIENT '/
     1' FILENAMES, ENTER IT NOW; OTHERWISE, PRESS ENTER: ')
         READ(*,222) EXT


        ENDIF

    
 1240	WRITE(*,1231)
 1231   FORMAT(/' ENTER 1 IF YOU WISH THE STARTING SEED NO. FOR THE'/
     1' 	SIMULATOR TO BE THE DEFAULT VALUE OF -17;'/

     2' ENTER 0 IF YOU WISH THE STARTING SEED NO. TO BE READ FROM'/
     3'		THE FILE, "SEEDTO.MON" (IN THIS CASE THIS FILE WILL'/
     4'		HAVE ITS SEED NO. DECREASED BY 123 FOR THE NEXT RUN): ')
	READ(*,*,ERR=1240) ISEEDIND
	IF(ISEEDIND .NE. 1 .AND. ISEEDIND .NE. 0) GO TO 1240	

C  AS OF MONTBIG9.FOR, THE SEED INDICATOR, ISEEDIND IS READ IN. IF
C  ISEEDIND = 1, THIS PROGRAM WILL USE THE DEFAULT SEED = -17;
C  ISEEDIND = 0, THIS PROGRAM WILL USE THE SEED NO. STORED INTO
C    SEEDTO.MON (AND UPDATE THE VALUE IN THAT FILE BY -123 FOR THE
C    NEXT RUN).


	ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(INOPT .EQ. 0)  CONDITION.


 7300    CONTINUE




C  PRINT TO THE SCREEN ALL INPUT INFO FOR VERIFICATION.

	CALL VERIF1(PREFIX,EXT,NSUB,NVAR,C0,C1,C2,C3,NOFIX,VALFIX,
     1   PARFIX,FILEIN,IDIST,NGAUS,COF,AMEAN,COV,FILOUT,PATH,NOB,
     2   NUMEQT,IPRNPAT,C0DT,C1DT,C2DT,C3DT,C0DA,C1DA,C2DA,C3DA,
     3   C0OT,C1OT,C2OT,C3OT,ISEEDIND,PAR,ICSVFILE,OUTNPAG,TEXTFILE,
     4   OUTCSVNAME,OSname,ListDir,ILIMIT,BOUND,INTLIST,RPAR,IPAR)

C  AS OF MONT107, IF IDIST = 0, NSUB MUST = NGAUS.

       IF(IDIST .EQ. 0) NSUB = NGAUS


C  CHECK THAT FILOUT DOES NOT ALREADY EXIST; IF IT DOES, GIVE USER 
C  CHANCE TO CHANGE IT.

C  CALL FULLNAME WHICH CONVERTS THE FILENAME TO PATHFILE, THE COMPLETE 
C  NAME OF THE FILE, WHICH INCLUDES THE PATH (IF THE PATH IS NOT THE 
C  CURRENT DIRECTORY).

 1980	TMPFILE = ' '
	TMPFILE = FILOUT
	CALL FULLNAME(PATH,TMPFILE,PATHFILE)
     	OPEN(23,FILE=PATHFILE,ERR=1970,STATUS='NEW')
	GO TO 1975
 1970   WRITE(*,9826) PATHFILE
 9826   FORMAT(/' THE FOLLOWING FILE ALREADY EXISTS ....'/
     1'    ',A93/
     1' ENTER 0 TO ENTER A NEW FILENAME;'/
     2' ENTER 1 TO OVERWRITE THIS FILE: ')

	READ(*,*,ERR=1970) IFILE
	IF(IFILE .NE. 0 .AND. IFILE .NE. 1) GO TO 1970

	IF(IFILE .EQ. 0) THEN
	 WRITE(*,*)' ENTER THE NAME OF THE OUTPUT FILE. ALL OUTPUT FROM'
	 WRITE(*,*)' THE PROGRAM WILL BE PUT INTO THIS FILE: '
	 READ(*,2) FILOUT
	 GO TO 1980
	ENDIF

	IF(IFILE .EQ. 1) OPEN(23,FILE=PATHFILE)

 1975   CLOSE(23)


C  GIVE USER OPTION TO SAVE INPUT DATA TO AN INPUT FILE (FOR ANOTHER
C  RUNNING OF THE PROGRAM).

	WRITE(*,1118)
 1118   FORMAT(//' ENTER 1 TO SAVE THE INPUT DATA INTO AN INPUT FILE;'/

     1' ENTER 0 OTHERWISE : ')
 1120   READ(*,*,ERR=1125) ISAVFL
	IF(ISAVFL .EQ. 0 .OR. ISAVFL .EQ. 1) GO TO 1130
 1125   WRITE(*,1126)
 1126   FORMAT(/' SEE ABOVE; ENTER 0 OR 1: ')
	GO TO 1120

 1130   IF(ISAVFL .EQ. 1) THEN

	 WRITE(*,1131)
 1131	 FORMAT(/' ENTER NAME OF FILE TO SAVE INPUT DATA : ')
	 READ(*,2) SAVFIL


C  CALL FULLNAME WHICH CONVERTS THE FILENAME TO PATHFILE, THE COMPLETE 

C  NAME OF THE FILE, WHICH INCLUDES THE PATH (IF THE PATH IS NOT THE 
C  CURRENT DIRECTORY).

 1180	TMPFILE = ' '

	TMPFILE = SAVFIL

	CALL FULLNAME(PATH,TMPFILE,PATHFILE)
     	OPEN(24,FILE=PATHFILE,ERR=1170,STATUS='NEW')
	GO TO 1175
 1170   WRITE(*,9826) PATHFILE
	READ(*,*,ERR=1170) IFILE
	IF(IFILE .NE. 0 .AND. IFILE .NE. 1) GO TO 1170

	IF(IFILE .EQ. 0) THEN
	 WRITE(*,*)' ENTER THE NAME OF THE FILE TO SAVE INPUT DATA: '   
	 READ(*,2) SAVFIL
	 GO TO 1180
	ENDIF

	IF(IFILE .EQ. 1) OPEN(24,FILE=PATHFILE)

 1175   CONTINUE

	 CODE = 'MONTBIG MAR_12'
       WRITE(24,7123) CODE

       WRITE(24,8111) 
 8111  FORMAT(' MODEL FILENAME')
	 WRITE(24,2) FORFILE

       WRITE(24,8112)
 8112  FORMAT(' IRAN INDICES')
	 WRITE(24,*) (IRAN(I),I=1,NP)


       WRITE(24,8151)
 8151  FORMAT(' BOUNDARIES FOR RANDOM VARIABLES')

       DO I = 1,NVAR

        IF(ILIMIT(I) .EQ. 1) THEN
         BOUND(I,1) = -99
         BOUND(I,2) = -99
        ENDIF

C  REPLACE WRITING OF BOUND() WITH XVERIFY (SEE LOGIC IN SUBROUTINE
C  VERIFYVAL). SIMIARLY FOR ALL CALLS TO VERIFYVAL.

        XVERIFY(1) = BOUND(I,1)
        XVERIFY(2) = BOUND(I,2)
        CALL VERIFYVAL(2,XVERIFY)

C        WRITE(24,8152) ILIMIT(I),BOUND(I,1),BOUND(I,2)
         WRITE(24,8152) ILIMIT(I),XVERIFY(1),XVERIFY(2)
 8152   FORMAT(5X,I1,2X,2(G19.9,1X))

       END DO

       WRITE(24,8116)
 8116  FORMAT(' ICSVFILE')
       WRITE(24,*) ICSVFILE

       WRITE(24,8117)
 8117  FORMAT(' FILEIN')
	 WRITE(24,2) FILEIN

       WRITE(24,8118) 
 8118  FORMAT(' NSUB')
	 WRITE(24,*) NSUB

 2416  FORMAT(30(G14.7,1X))

       WRITE(24,8119)
 8119  FORMAT(' NOFIX')
	 WRITE(24,*) NOFIX

C  REPLACE WRITING OF VALFIX() WITH XVERIFY (SEE LOGIC IN SUBROUTINE
C  VERIFYVAL). 

      IF(NOFIX .GT. 0) THEN
       DO I=1,NOFIX
        XVERIFY(I) = VALFIX(I)
       END DO
       CALL VERIFYVAL(NOFIX,XVERIFY)
      ENDIF

       WRITE(24,8121)
 8121  FORMAT(' VALFIX ARRAY IF NOFIX > 0')
C	 IF(NOFIX .GT. 0) WRITE(24,2416) (VALFIX(I),I=1,NOFIX)
       IF(NOFIX .GT. 0) WRITE(24,2416) (XVERIFY(I),I=1,NOFIX)

       WRITE(24,8122)
 8122  FORMAT(' TOLER')
	 WRITE(24,*) TOLER

       WRITE(24,8123)
 8123  FORMAT(' NUMEQT')
	 WRITE(24,*) NUMEQT


C  REPLACE WRITING OF C0(),...,C3() WITH XVERIFY (SEE LOGIC IN 
C  SUBROUTINE VERIFYVAL).

       WRITE(24,8124)
 8124  FORMAT(' NUMEQT LINES OF ASSAY COEFFICIENTS')
       DO IEQ=1,NUMEQT
        XVERIFY(1) = C0(IEQ)
        XVERIFY(2) = C1(IEQ)
        XVERIFY(3) = C2(IEQ)
        XVERIFY(4) = C3(IEQ)
        CALL VERIFYVAL(4,XVERIFY)
C	  WRITE(24,2416) C0(IEQ),C1(IEQ),C2(IEQ),C3(IEQ)
        WRITE(24,2416) (XVERIFY(IXV),IXV=1,4)
	 END DO

C  REPLACE WRITING OF C0DT,...,C3DT WITH XVERIFY (SEE LOGIC IN 
C  SUBROUTINE VERIFYVAL).

       WRITE(24,8126)
 8126  FORMAT(' ERROR COEFFS. FOR DOSE TIMES')
        XVERIFY(1) = C0DT
        XVERIFY(2) = C1DT
        XVERIFY(3) = C2DT
        XVERIFY(4) = C3DT
        CALL VERIFYVAL(4,XVERIFY)
C	  WRITE(24,2416) C0DT,C1DT,C2DT,C3DT
        WRITE(24,2416) (XVERIFY(IXV),IXV=1,4)


C  REPLACE WRITING OF C0DT,...,C3DT WITH XVERIFY (SEE LOGIC IN 
C  SUBROUTINE VERIFYVAL).

       WRITE(24,8127)
 8127  FORMAT(' ERROR COEFFS. FOR DOSE AMOUNTS')
        XVERIFY(1) = C0DA
        XVERIFY(2) = C1DA
        XVERIFY(3) = C2DA
        XVERIFY(4) = C3DA
        CALL VERIFYVAL(4,XVERIFY)
C	  WRITE(24,2416) C0DA,C1DA,C2DA,C3DA
        WRITE(24,2416) (XVERIFY(IXV),IXV=1,4)


C  REPLACE WRITING OF C0OT,...,C3OT WITH XVERIFY (SEE LOGIC IN 
C  SUBROUTINE VERIFYVAL).

       WRITE(24,8128)
 8128  FORMAT(' ERROR COEFFS. FOR OBSERVATION TIMES')
        XVERIFY(1) = C0OT
        XVERIFY(2) = C1OT
        XVERIFY(3) = C2OT
        XVERIFY(4) = C3OT
        CALL VERIFYVAL(4,XVERIFY)
C	  WRITE(24,2416) C0OT,C1OT,C2OT,C3OT
        WRITE(24,2416) (XVERIFY(IXV),IXV=1,4)


       WRITE(24,8129)
 8129  FORMAT(' IDIST')
	 WRITE(24,*) IDIST

       WRITE(24,8131)
 8131  FORMAT(' NGAUS')
	 WRITE(24,*) NGAUS

C  REPLACE WRITING OF AMEAN(),COV() WITH XVERIFY (SEE LOGIC IN 
C  SUBROUTINE VERIFYVAL).

       WRITE(24,8132)
 8132  FORMAT(' NGAUS SETS OF COF(.), AMEAN(.,.), COV(.,.,.)')

       DO IGAUS = 1,NGAUS

	  WRITE(24,*) COF(IGAUS)

        DO I = 1,NVAR
         XVERIFY(I) = AMEAN(IGAUS,I)
        END DO
        CALL VERIFYVAL(NVAR,XVERIFY)      

C	  WRITE(24,2416) (AMEAN(IGAUS,I),I=1,NVAR)
        WRITE(24,2416) (XVERIFY(I),I=1,NVAR)

        DO I = 1,NVAR
         DO J = 1,I
          XVERIFY(J) = COV(IGAUS,I,J)
         END DO
         CALL VERIFYVAL(I,XVERIFY)
C        WRITE(24,2416) (COV(IGAUS,I,J),J=1,I)
         WRITE(24,2416) (XVERIFY(J),J=1,I) 
        END DO
	 
       END DO
C  END OF DO IGAUS = 1,NGAUS LOOP.


       WRITE(24,8133)
 8133  FORMAT(' FILOUT')
	 WRITE(24,2) FILOUT



       WRITE(24,8134)
 8134  FORMAT(' IPRNPAT')
	 WRITE(24,*) IPRNPAT

       WRITE(24,8139)
 8139  FORMAT(' OUTCSVNAME')
       IF(IPRNPAT .EQ. 0 .OR. IPRNPAT .EQ. 2) WRITE(24,8141)
 8141  FORMAT(' NOT APPLICABLE')
       IF(IPRNPAT .EQ. 1 .OR. IPRNPAT .EQ. 3) WRITE(24,2) OUTCSVNAME


       WRITE(24,8142)
 8142  FORMAT(' PREFIX')
       IF(IPRNPAT .EQ. 0 .OR. IPRNPAT .EQ. 1) WRITE(24,8141)
       IF(IPRNPAT .EQ. 2 .OR. IPRNPAT .EQ. 3) WRITE(24,2222) PREFIX

       WRITE(24,8143)
 8143  FORMAT(' EXT')

       IF(IPRNPAT .EQ. 0 .OR. IPRNPAT .EQ. 1) WRITE(24,8141)
       IF(IPRNPAT .EQ. 2 .OR. IPRNPAT .EQ. 3) WRITE(24,222) EXT


       WRITE(24,8136)
 8136  FORMAT(' ISEEDIND')
	 WRITE(24,*) ISEEDIND

	 CLOSE(24)

	ENDIF

C  THE ABOVE ENDIF ENDS THE SAVING INFO TO INPUT FILE OPTION. 


C  ESTABLISH THE FULL NAME OF THE OUTPUT FILE AND PUT IN ALL THE
C  USER-INPUT INSTRUCTIONS AT THE TOP OF IT.

      TMPFILE = ' '
	TMPFILE = FILOUT
	CALL FULLNAME(PATH,TMPFILE,PATHFILE)

	OPEN(23,FILE=PATHFILE)

        WRITE(23,231)
  231   FORMAT(/' THE USER-INPUT INSTRUCTIONS FOR THIS RUN FOLLOW: ')
	

        WRITE(23,233) FORFILE
  233   FORMAT(/' THE FORTRAN MODEL FILE USED WAS ',A32)

        WRITE(23,234) 
  234   FORMAT(/' THE IRAN VECTOR IS SHOWN BELOW, WHERE IRAN(I)= 1'/
     1' IF PARAMATER I WAS RANDOM; 0 IF PARAMETER I WAS FIXED.')
        WRITE(23,*) (IRAN(I),I=1,NP)

        WRITE(23,2234)
 2234   FORMAT(/' THE REQUIRED BOUNDARIES FOR THE RANDOM VARIABLES'/
     1' WHICH ARE USED TO SIMULATE SUBJECTS ARE AS FOLLOWS: ')

        DO I = 1,NVAR
         IF(ILIMIT(I) .EQ. 1) WRITE(23,2236) PAR(I)
 2236     FORMAT(1X,A11,' <-- NO RESTRICTIONS ON PARAMETER VALUES ')
         IF(ILIMIT(I) .EQ. 0) WRITE(23,2237) PAR(I),BOUND(I,1),
     1    BOUND(I,2)
 2237     FORMAT(1X,A11,2X,G19.9,'  TO  ',G19.9)
        END DO


        IF(ICSVFILE .EQ. 0) THEN
         WRITE(23,238)
  238    FORMAT(/' THE NAME OF THE WORKING COPY PATIENT DATA FILE'/
     1' WHICH CONTAINS THE DOSE/COVARIATE INFORMATION WHICH WILL BE'/
     2' USED TO SIMULATE THE PATIENT DATA FILES IS: ')
         WRITE(23,2) FILEIN


        ENDIF


        IF(ICSVFILE .EQ. 1) THEN
         WRITE(23,1238) 
 1238    FORMAT(/' THE NAME OF THE .CSV FILE WHICH CONTAINS THE DOSE/'/
     1' COVARIATE INFORMATION (IN ITS FIRST SUBJECT BLOCK) WHICH WILL '/
     2' BE USED TO SIMULATE THE PATIENT DATA FILES IS: ')
         WRITE(23,2) FILEIN
        ENDIF

        WRITE(23,239) NSUB
  239   FORMAT(/' THE NO. OF SIMULATED SUBJECTS WAS ',I6)

        IF(NOFIX .EQ. 0) WRITE(23,241) 
  241   FORMAT(/' THERE WERE NO FIXED PARAMETERS IN THIS RUN.')


C  REPLACE WRITING OF VALFIX() WITH XVERIFY (SEE LOGIC IN SUBROUTINE
C  VERIFYVAL).

        IF(NOFIX .GT. 0) THEN

         DO I=1,NOFIX
          XVERIFY(I) = VALFIX(I)
         END DO
         CALL VERIFYVAL(NOFIX,XVERIFY)

         WRITE(23,242)
  242    FORMAT(/' THE FIXED PARAMETER VALUES, IN ORDER, WERE: ')
C         WRITE(23,2416) (VALFIX(I),I=1,NOFIX)
          WRITE(23,2416) (XVERIFY(I),I=1,NOFIX)

        ENDIF

        WRITE(23,243) 
  243   FORMAT(/' THE TOLERANCES FOR THE O.D.E. SOLVER WERE ALL ')
        WRITE(23,*) TOLER

        WRITE(23,244) NUMEQT
  244   FORMAT(/' THE NO. OF OUTPUT EQUATIONS WAS ',I3)

C  REPLACE WRITING OF C0(),...,C3() WITH XVERIFY (SEE LOGIC IN 
C  SUBROUTINE VERIFYVAL).

        WRITE(23,246)
  246   FORMAT(/' THE ASSAY COEFFICIENTS FOR EACH OF THE OUTPUT '/
     1' EQUATIONS, IN ORDER, WERE: ')

        DO IEQ = 1,NUMEQT
         XVERIFY(1) = C0(IEQ)
         XVERIFY(2) = C1(IEQ)
         XVERIFY(3) = C2(IEQ)
         XVERIFY(4) = C3(IEQ)
         CALL VERIFYVAL(4,XVERIFY)
C	   WRITE(23,2416) C0(IEQ),C1(IEQ),C2(IEQ),C3(IEQ)
         WRITE(23,2416) (XVERIFY(IXV),IXV=1,4)
        END DO

       WRITE(23,247)
  247  FORMAT(/' THE DOSE TIMES, THE DOSE AMOUNTS (INCLUDING ALL BOLUS'/
     1' VALUES AND THE IV RATES), AND THE OBSERVATION TIMES WHICH THE'/
     2' PROGRAM READ FROM THE WORKING COPY PATIENT DATA FILE ABOVE'/
     3' WERE ALL ASSUMED TO BE "NOISY" VALUES.'//
     5' EACH DOSE TIME IS MADE "NOISY" AS FOLLOWS:'/
     1' THE FIRST DOSE TIME, WITH A TRUE VALUE OF VTRUE, WILL BE '/
     2' CHANGED TO BE VNOISY, WHERE VNOISY = VTRUE + Ei, WHERE'/
     3' Ei ~ N(0,STDI**2), WHERE '/
     4' STDI = C0 + C1*VTRUE + C2*VTRUE**2 + C3*VTRUE**3'//
     5' FOR SUBSEQUENT DOSE TIMES, THE NOISY DOSE TIME IS '/
     6' DETERMINED AS FOLLOWS:'/
     7' a. SET DUR = NOMINAL DURATION BETWEEN THE PREVIOUS DOSE TIME '/
     8'    AND THE CURRENT DOSE TIME.'/
     3' b. CALC. THE NOISY DURATION, DURNOISY, AS '/
     4'    DURNOISY = DUR + Ei, Ei ~ N(0,STDI**2), WHERE '/
     7'    STDI = C0 + C1*DUR + C2*DUR**2 + C3*DUR**3'/
     8' c. ... BUT LIMIT DURNOISY TO BE .GE. .5*DUR AND .LE. 2*DUR.'/
     9' d. SET THE CURRENT NOISY DOSE TIME = PREVIOUS NOISY DOSE TIME'/
     1'    + DURNOISY.'//
     2' THE SAME LOGIC APPLIES FOR OBS. TIMES. '//
     3' NOTE THIS LOGIC --> TIMES CANNOT BE OUT OF ORDER.'//

     4' EACH IV RATE AND EACH BOLUS VALUE WHICH = 0 WILL NOT'/
     1' BE MADE NOISY. I.E., IT IS ASSUMED THAT IF A RATE OR BOLUS IS'/
     2' INTENDED TO BE 0, IT WILL BE ACHIEVED WITHOUT ERROR.'
     2/
     3' A NON-ZERO IV OR BOLUS VALUE, WITH A TRUE VALUE OF VTRUE, '/
     4' WILL BE CHANGED TO BE VNOISY, WHERE VNOISY = VTRUE + Ei, WHERE'/
     6' Ei ~ N(0,STDI**2), WHERE '/
     7' STDI = C0 + C1*VTRUE + C2*VTRUE**2 + C3*VTRUE**3')


C  REPLACE WRITING OF C0DT,...,C3DT; C0DA,...,C3DA; AND
C  C0OT,...C3OT; WITH XVERIFY (SEE LOGIC IN SUBROUTINE VERIFYVAL).

        WRITE(23,248)
  248   FORMAT(/' C0,C1,C2,C3 FOR THE DOSE TIMES WERE: ')
        XVERIFY(1) = C0DT
        XVERIFY(2) = C1DT
        XVERIFY(3) = C2DT
        XVERIFY(4) = C3DT
        CALL VERIFYVAL(4,XVERIFY)
C       WRITE(23,2416) C0DT,C1DT,C2DT,C3DT
        WRITE(23,2416) (XVERIFY(IXV),IXV=1,4)

        WRITE(23,249)
  249   FORMAT(/' C0,C1,C2,C3 FOR THE DOSE AMOUNTS WERE: ')
        XVERIFY(1) = C0DA
        XVERIFY(2) = C1DA
        XVERIFY(3) = C2DA
        XVERIFY(4) = C3DA
        CALL VERIFYVAL(4,XVERIFY)
C	  WRITE(23,2416) C0DA,C1DA,C2DA,C3DA
        WRITE(23,2416) (XVERIFY(IXV),IXV=1,4)


        WRITE(23,251)
  251   FORMAT(/' C0,C1,C2,C3 FOR THE OBSERVATION TIMES WERE: ')
        XVERIFY(1) = C0OT
        XVERIFY(2) = C1OT
        XVERIFY(3) = C2OT
        XVERIFY(4) = C3OT
        CALL VERIFYVAL(4,XVERIFY)
C	  WRITE(23,2416) C0OT,C1OT,C2OT,C3OT
        WRITE(23,2416) (XVERIFY(IXV),IXV=1,4)


C  IF OUTNPAG IS NOT ALL BLANKS, IT MEANS THAT THE NGAUS DISTRIBUTIONS
C  CAME FROM THE OUTPUT FILE IN OUTNPAG. WRITE THIS INTO OUTPUT FILE.
C  SIMILARLY, IF TEXTFILE IS NOT ALL BLANKS, THE NGAUS MEANS CAME 
C  FROM THIS TEXT FILE.

        IF(OUTNPAG(1:10) .NE. '          ') WRITE(23,351) NGAUS,OUTNPAG
  351    FORMAT(/' THE MIXTURE OF ',I3,' DISTRIBUTION(S) DESCRIBED '/
     1' BELOW CAME FROM THE BIG NPAG OUTPUT FILE, ',A20)

       IF(TEXTFILE(1:10) .NE. '          ') WRITE(23,751) NGAUS,TEXTFILE
  751  FORMAT(/' THE MIXTURE OF ',I3,' DISTRIBUTION(S) DESCRIBED '/
     1' BELOW CAME FROM THE TEXT FILE, ',A20)



      IF(IDIST .EQ. 0) THEN

        WRITE(23,254) NGAUS
  254   FORMAT(/' THE OBSERVATIONS FOR EACH OF THE ',I3,' SUBJECT'/
     1' VECTORS WERE GENERATED BY ASSUMING EACH SUBJECT HAD EXACTLY'/
     2' THE PARAMETER VALUES OF ONE OF THE GRID PTS. IN THE FINAL'/
     3' CYCLE DENSITY FROM THE INPUT NPAG RUN. THESE GRID PTS. ARE: '/)


C  REPLACE WRITING OF AMEAN() WITH XVERIFY (SEE LOGIC IN 
C  SUBROUTINE VERIFYVAL).

       DO IGAUS = 1,NGAUS
        WRITE(23,9004) IGAUS
 9004   FORMAT(//' GRID PT. NO: ',I3)
        DO I = 1,NVAR
         XVERIFY(I) = AMEAN(IGAUS,I)
        END DO
        CALL VERIFYVAL(NVAR,XVERIFY)      
C       WRITE(23,9007) (AMEAN(IGAUS,I),I=1,NVAR)
        WRITE(23,9007) (XVERIFY(I),I=1,NVAR)
 9007   FORMAT(/' PAR. VALUES: ',150G10.3)
       END DO

      ENDIF
C  THE ABOVE ENDIF IS FOR THE  IF(IDIST .EQ. 0)  CONDITION.

 
        IF(IDIST .EQ. 1) WRITE(23,252) NGAUS
  252   FORMAT(/' THE SUBJECT VECTORS WERE GENERATED FROM A MIXTURE'/
     1' OF ',I3,' GAUSSIAN DISTRIBUTIONS. THE FOLLOWING DESCRIBES '/
     2' THESE DISTRIBUTIONS: ')

        IF(IDIST .EQ. 2) WRITE(23,253) NGAUS
  253   FORMAT(/' THE SUBJECT VECTORS WERE GENERATED FROM A MIXTURE'/
     1' OF ',I3,' LOGNORMAL DISTRIBUTIONS. THE FOLLOWING DESCRIBES '/
     2' THESE DISTRIBUTIONS: ')




      IF(IDIST .NE. 0) THEN

C  REPLACE WRITING OF AMEAN(),COV(),COF(), AND CORR() WITH XVERIFY 
C (SEE LOGIC IN SUBROUTINE VERIFYVAL).

	DO 8020 IGAUS=1,NGAUS

	WRITE(23,8004) IGAUS
 8004 FORMAT(//' DISTRIBUTION NO: ',I3)
      XVERIFY(1) = COF(IGAUS)
      CALL VERIFYVAL(1,XVERIFY)
C	WRITE(23,8006) COF(IGAUS) 
      WRITE(23,8006) XVERIFY(1)
 8006 FORMAT(/' WEIGHTING COEFFICIENT: ',F10.3)

       DO I = 1,NVAR
        XVERIFY(I) = AMEAN(IGAUS,I)
       END DO
       CALL VERIFYVAL(NVAR,XVERIFY)
C	 WRITE(23,8007) (AMEAN(IGAUS,I),I=1,NVAR)
       WRITE(23,8007) (XVERIFY(I),I=1,NVAR)
 8007  FORMAT(/' MEAN VECTOR: ',150G10.3)
       WRITE(23,8008) 
 8008   FORMAT(/' THE COVARIANCE MATRIX, IN LOWER-TRIANGULAR FORM IS: ')

        DO I=1,NVAR
         DO J = 1,I
          XVERIFY(J) = COV(IGAUS,I,J)
         END DO
         CALL VERIFYVAL(I,XVERIFY)
C        WRITE(23,2416) (COV(IGAUS,I,J),J=1,I)
         WRITE(23,2416) (XVERIFY(J),J=1,I)
        END DO

C  ESTABLISH THE LOWER-TRIANGULAR CORRELATION MATRIX.

	DO I = 1,NVAR
	 DO J = 1,I
	  CORR(I,J)= COV(IGAUS,I,J)/DSQRT(COV(IGAUS,I,I)*COV(IGAUS,J,J))
	 END DO
	END DO

      WRITE(23,8009)
 8009 FORMAT(/' THE CORRELATION MATRIX, IN LOWER-TRIANGULAR FORM IS:')

        DO I = 1,NVAR
         DO J = 1,I
          XVERIFY(J) = CORR(I,J)
         END DO
         CALL VERIFYVAL(I,XVERIFY)
C        WRITE(23,2416) (CORR(I,J),J=1,I)
         WRITE(23,2416) (XVERIFY(J),J=1,I)
        END DO

 8020   CONTINUE

      ENDIF
C  THE ABOVE ENDIF IS FOR THE  IF(IDIST .NE. 0)  CONDITION.


        IF(IPRNPAT .EQ. 1 .OR. IPRNPAT .EQ. 3) 
     1   WRITE(23,9013) NSUB,OUTCSVNAME
 9013   FORMAT(/' THE INFORMATION FROM THE ',I5,' SIMULATED PATIENT'/
     1' DATA FILES WAS SAVED IN BLOCK FORMAT TO '/
     2' FILE ',A32)

        IF(IPRNPAT .EQ. 2 .OR. IPRNPAT .EQ. 3) 
     1   WRITE(23,8013) NSUB,PREFIX,EXT
 8013   FORMAT(/' THIS RUN CREATED ',I5,' SIMULATED PATIENT DATA '/
     1' FILES, WITH PREFIX ',A3,' AND EXTENSION ',A3) 
       
        IF(IPRNPAT .EQ. 0) WRITE(23,8014) NSUB
 8014   FORMAT(/' THE INFORMATION FROM THE ',I5,' SIMULATED PATIENT'/
     1' DATA FILES WAS NOT SAVED IN BLOCK FORMAT TO A .CSV FILE, AND'/
     2' NO SIMULATED PATIENT DATA FILES WERE CREATED')



	IF(ISEEDIND .EQ. 1) WRITE(23,257)
  257   FORMAT(/' THIS RUN USED THE DEFAULT SEED NO. -17.')

	IF(ISEEDIND .EQ. 0) WRITE(23,258)
  258   FORMAT(/' THIS RUN USED THE SEED NO. STORED IN "SEEDTO.MON" '/
     1' (SEE BELOW) AND UPDATED THE VALUE IN THAT FILE BY -123 FOR THE'/
     2' NEXT RUN.')



	WRITE(23,232)
  232   FORMAT(/' THE USER-INPUT INSTRUCTIONS FOR THIS RUN ARE ABOVE.'/
     1/

     2'*************************************************************'/
     3'*************************************************************'//
     4'********** THE FOLLOWING ARE THE RESULTS OF THIS RUN ********'//)


	CALL SIMBIG(PREFIX,EXT,FILEIN,NSUB,NVAR,NOFIX,IRAN,VALFIX,
     1   C0,C1,C2,C3,IDIST,NGAUS,COF,AMEAN,COV,PATH,NDIM,PAR,
     2   IPRNPAT,ISEEDIND,ICSVFILE,OUTCSVNAME,OSname,DeleteFile,
     3   ListDir,ILIMIT,BOUND,INTLIST,RPAR,IPAR)


      STOP
      END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
      SUBROUTINE GNRAT(N,MEAN,COV,VEC,IDUM)
      IMPLICIT REAL*8(A-H,O-Z)
      DIMENSION MEAN(594),COV(594,594),VEC(594),SIG(594,594),RVEC(594),
     1 ID(594),A(594,594),R(594)
      DOUBLE PRECISION MEAN
C
C  THIS SUBROUTINE, CALLED BY SIMBIG, INPUTS N,MEAN, COV, AND IDUM, AND 
C  RETURNS VEC, A NORMAL VECTOR (OF LENGTH N)--N(MEAN,COV), WHERE COV IS

C  THE LOWER TRI FORM OF THE DESIRED COVARIANCE MATRIX.
C
C  IDUM IS THE DUMMY INDEX USED BY THE RANDOM NUMBER GENERATOR, RAN1; IT
C  IS INITIALIZED TO BE A NEGATIVE NO. THE 1ST CALL, AND THEN, FOREVER 
C  MORE, IS POSITIVE.
C
C  FIRST, OBTAIN THE 'SQUARE ROOT' OF COV (I.E., THE LOWER-TRI MATRIX,
C  A, WHERE A*A'=COV.

C
C  COV SHOULD BE A SYMMETRIC POS-DEF. MATRIX (SINCE IT IS A COV MATRIX),
C  BUT IN A TEST CASE, SOME OF THE ROWS MIGHT BE ALL 0, INDICATING THAT
C  THAT COMPONENT OF VEC IS TO = ITS MEAN. SINCE SUBROUTINE SQROOT,
C  WHICH CALCULATES A, REQUIRES A POS-DEF. MATRIX, SUBSTITUTE .0001 FOR
C  ALL DIAGONAL ELEMENTS WHICH ARE 0; THEN, BEFORE RETURNING VEC, SIMPLY
C  SET VEC(I)=MEAN(I) FOR EACH I WHERE COV(I,I) WAS ORIGINALLY = 0.
C

C  LET ID(I)=0 IF THE (I,I) ELEMENT OF COV = 0. SET SIG(I,J)= COV(I,J)
C  UNLESS COV(I,I)=0 (IN WHICH CASE, SET SIG(I,I)=.0001).

C
C  NOTE: IF A VARIANCE = 0, ALL COVARIANCES FOR THAT R.V. WOULD ALSO BE
C  0, SO THE ARBITRARY VALUE (.0001) USED IS UNIMPORTANT; IT WON'T      
C  AFFECT OTHER VALUES IN VEC.

      DO 10 I=1,N
   10 ID(I)=1
C
      DO 30 I=1,N
      DO 20 J=1,I
   20 SIG(I,J)=COV(I,J)
      IF(SIG(I,I) .EQ. 0.D0) THEN
         SIG(I,I)=1.D-4
         ID(I)=0
         ENDIF
   30 CONTINUE
C
      CALL SQROOT(N,SIG,A)
C
C  NOW OBTAIN N INDEPENDENT N(0,1) VARIATES.
C
      DO 40 I=1,N
   40 R(I)=GASDEV(IDUM)

C
C  NOW R--IID--N(0,I); CALCULATE RVEC = A*R--IID--N(0,AA'=SIG).
C
      DO 60 I=1,N

      SUM=0.D0
      DO 50 J=1,I
C
C  RECALL A IS A LOWER-TRI MATRIX, SO A(I,J)=0 IF J.GT. I.
C
   50 SUM=SUM+A(I,J)*R(J)
   60 RVEC(I)=SUM
C
C  NOW, CONVERT TO VEC WHICH HAS MEAN=MEAN. SO, FOR ANY VARIABLE I, 
C  WHICH HAD VARIANCEC = 0.0 ORIGINALLY, SET VEC(I)=MEAN(I); OTHERWISE, 
C  SET VEC(I) = RVEC(I)+MEAN(I) TO GET (VEC(1),...,VEC(N))--N(MEAN,COV).
C
      DO 70 I=1,N
      VEC(I)=RVEC(I)+MEAN(I)
   70 IF(ID(I) .EQ. 0) VEC(I)=MEAN(I)
C
C
      RETURN
      END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
      SUBROUTINE SQROOT(N,SIG,A)
      IMPLICIT REAL*8(A-H,O-Z)
      DIMENSION SIG(594,594),A(594,594)

      CHARACTER ERRFIL*20

      COMMON/ERROR/ERRFIL
C  COMMON/ERROR/ IS SUPPLIED TO ALL THE ROUTINES WHICH COULD WRITE TO
C  ERRFIL.

C  THIS SUBROUTINE INPUTS AN N x N SYMMETRIC, POSITIVE-DEFINITE MATRIX,
C  SIG, AND OUTPUTS THE LOWER-TRIANGULAR MATRIX, A, WHERE  A*A'= SIG.
C
C  SQROOT IS CALLED BY SUBROUTINE GNRAT.
C
C  SET UPPER-TRI PART OF A = 0. 

      DO 10 I=1,N
      DO 10 J=I+1,N
   10 A(I,J)=0.D0
C
C  SOLVE FOR A(I,J) IN THE ORDER (((I,J),J=1,I),I=1,N).
C
      DO 100 I=1,N
      DO 100 J=1,I
C
C  IF I=J, FIND THE DIAGONAL ELEMENT A(I,I), AND, AT THE SAME TIME,
C  CHECK THAT THE UPPER LEFT  I x I  PORTION OF MATRIX SIG HAS A 
C  POSITIVE DETERMINANT (AS IS REQUIRED OF SIG, SINCE IT IS SUPPOSED
C  TO BE POSITIVE-DEFINITE).
C
      IF(I .EQ. J) THEN
	SUM=0.D0
	DO 20 K=1,I-1
   20 	SUM=SUM+A(I,K)*A(I,K)		
	RAD=SIG(I,I)-SUM

	IF(RAD .LE. 0.D0) THEN



	  WRITE(*,101)
  101   FORMAT(/' COV MATRIX IS NOT POS-DEF; PROGRAM STOPS. ')
	  WRITE(23,101)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,101) 
        CLOSE(42)



        CALL PAUSE
	  STOP



	 ENDIF



C  RAD .GT. 0, SO CALCULATE A(I,I) AND PROCEED.

	A(I,I)=DSQRT(RAD)
C
	ELSE
C
C  I .NE. J (ACTUALLY I .GT. J), SO FIND THE LOWER-TRI ELT, A(I,J).
C
	SUM=0.D0
	DO 30 K=1,J-1
   30   SUM=SUM+A(I,K)*A(J,K)
	A(I,J)=(SIG(I,J)-SUM)/A(J,J)
C
C  NOTE: A(J,J) IN DENOMINATOR ABOVE IS .NE. 0, SINCE ALL THE A(I,I)
C	 PREVIOUSLY CALCULATED ARE .GT. 0 (I.E., A(I,I) =DSQRT(RAD)
C 	 WHERE RAD MUST BE .GT. 0, OR PROGRAM WOULD HAVE STOPPED).
C
	ENDIF
C
  100 CONTINUE
      RETURN
      END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C      REAL*8 FUNCTION GASDEV(IDUM)

C	IMPLICIT REAL*8 (A-H,O-Z)

C      DATA ISET/0/
C      IF (ISET.EQ.0) THEN
C1       V1=2.*RAN1(IDUM)-1.
C        V2=2.*RAN1(IDUM)-1.
C        R=V1**2+V2**2
C        IF(R.GE.1.)GO TO 1
C        FAC=SQRT(-2.*LOG(R)/R)
C        GSET=V1*FAC
C        GASDEV=V2*FAC
C        ISET=1
C      ELSE
C        GASDEV=GSET
C        ISET=0
C      ENDIF
C      RETURN
C      END
C

C
C Yamada replaced above w/the following:
C
C    This was necessary to fix a compiler issue. In gfortran
C we need to explicitely set variables to static state -- unlike

C g95, which is backwards compatible to FORTRAN90, and uses a
C compiler flag to set (? all ?) local variables to static.

      REAL*8 FUNCTION GASDEV(IDUM)
        IMPLICIT REAL*8 (A-H,O-Z)
      DATA ISET/0/
C
C YAMADA 4/14/2010
C      REAL*8, SAVE :: GSET
      double precision, save :: GSET
C
      IF (ISET.EQ.0) THEN

1       V1=2.*RAN1(IDUM)-1.
        V2=2.*RAN1(IDUM)-1.
        R=V1**2+V2**2
        IF(R.GE.1.)GO TO 1
        FAC=SQRT(-2.*LOG(R)/R)

        GSET=V1*FAC
        GASDEV=V2*FAC
        ISET=1
      ELSE
        GASDEV=GSET
        ISET=0
      ENDIF
      RETURN
      END
C
C END Yamada.
C

C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C      REAL*8 FUNCTION RAN1(IDUM)
C	IMPLICIT REAL*8 (A-H,O-Z)
C      DIMENSION R(97)
C      PARAMETER (M1=259200,IA1=7141,IC1=54773,RM1=3.8580247E-6)

C      PARAMETER (M2=134456,IA2=8121,IC2=28411,RM2=7.4373773E-6)
C      PARAMETER (M3=243000,IA3=4561,IC3=51349)
C      DATA IFF /0/
C      IF (IDUM.LT.0.OR.IFF.EQ.0) THEN
C        IFF=1
C        IX1=MOD(IC1-IDUM,M1)
C        IX1=MOD(IA1*IX1+IC1,M1)
C        IX2=MOD(IX1,M2)
C        IX1=MOD(IA1*IX1+IC1,M1)
C        IX3=MOD(IX1,M3)
C        DO 11 J=1,97
C          IX1=MOD(IA1*IX1+IC1,M1)
C          IX2=MOD(IA2*IX2+IC2,M2)
C          R(J)=(FLOAT(IX1)+FLOAT(IX2)*RM2)*RM1
C11      CONTINUE
C        IDUM=1
C      ENDIF
C      IX1=MOD(IA1*IX1+IC1,M1)
C      IX2=MOD(IA2*IX2+IC2,M2)
C      IX3=MOD(IA3*IX3+IC3,M3)
C      J=1+(97*IX3)/M3

C      IF(J.GT.97.OR.J.LT.1) CALL PAUSE
C      RAN1=R(J)
C      R(J)=(FLOAT(IX1)+FLOAT(IX2)*RM2)*RM1
C      RETURN
C      END
C
C Yamada replaced the above w/the code below ... the same issue
C as for  SUBROUTINE GNRAT() ... we need a static variable, and must
C explicitely declare it so.
C

      DOUBLE PRECISION FUNCTION RAN1(IDUM)
C
        IMPLICIT REAL*8 (A-H,O-Z)
      DIMENSION R(97)
C
C YAMADA 16 Mar 2010; 4/14/2010
C
C      REAL*8 :: rrr(1,1)
C      REAL*8, SAVE :: zzz(1,97)

C      INTEGER*4, SAVE :: IX1
C      INTEGER*4, SAVE :: IX2
C      INTEGER*4, SAVE :: IX3
C      DOUBLE PRECISION,SAVE :: zzz(1,97)
      DOUBLE PRECISION,SAVE :: rrr
      DOUBLE PRECISION,DIMENSION(97),SAVE :: zzz
      INTEGER*4 IX1
      INTEGER*4 IX2
      INTEGER*4 IX3
      SAVE :: IX1, IX2, IX3
C
C end YAMADA 16 Mar 2010
C
      PARAMETER (M1=259200,IA1=7141,IC1=54773,RM1=3.8580247E-6)
      PARAMETER (M2=134456,IA2=8121,IC2=28411,RM2=7.4373773E-6)
      PARAMETER (M3=243000,IA3=4561,IC3=51349)
      DATA IFF /0/
      IF (IDUM.LT.0.OR.IFF.EQ.0) THEN
        IFF=1


        IX1=MOD(IC1-IDUM,M1)
        IX1=MOD(IA1*IX1+IC1,M1)
        IX2=MOD(IX1,M2)
        IX1=MOD(IA1*IX1+IC1,M1)
        IX3=MOD(IX1,M3)

        DO 11 J=1,97
          IX1=MOD(IA1*IX1+IC1,M1)
          IX2=MOD(IA2*IX2+IC2,M2)
          R(J)=(FLOAT(IX1)+FLOAT(IX2)*RM2)*RM1
          zzz(J) = R(J)
11      CONTINUE
        IDUM=1
      ENDIF
      IX1=MOD(IA1*IX1+IC1,M1)
      IX2=MOD(IA2*IX2+IC2,M2)
      IX3=MOD(IA3*IX3+IC3,M3)
      J=1+(97*IX3)/M3
      IF(J.GT.97.OR.J.LT.1) THEN
C
C YAMADA 12/30/09
C Rather than just hanging or crashing w/a PAUSE: try to recover
C by choosing a random J. But note: this IF block should never ever
C get called ... if you are here you are in major doodoo ... and
C recovering will likely not get you anything better than a safer
C exit from the program.
C
        CALL init_random_seed(J)
        CALL RANDOM_NUMBER(rrr)
        PRINT *, 'In RAN1() old J corresponds to: ', J, IX1, IX2, IX3
        J = 97*rrr


        IF(J.LT.1) J=J+1

        write(*,FMT = 1112) J
 1112   FORMAT( 'WARNING: Increment into rvec went out of range: ', I5 )
      ENDIF
      RAN1=zzz(J)
      R(J)=(FLOAT(IX1)+FLOAT(IX2)*RM2)*RM1
      zzz(J)=R(J)

      RETURN
      END
C
C End Yamada.
C

C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C YAMADA 1/7/2010
C
C This routine is to initialize RANDOM_NUMBER() based on the current 
C time. Call this routine prior to calling RANDOM_NUMBER(). Note that
C this routine should never need to be called -- unless there is a
C serious error in the random number generator and we are trying to
C recover -- but in that case, we might just rather crash! (Or generate
C bogus output ... this routine is the tail end of a series of edits to
C fix random number generation in UNIX, which is not at all backwards
C compatible w/FORTRAN90.




       SUBROUTINE init_random_seed()
          INTEGER :: i, n, clock
          INTEGER, DIMENSION(:), ALLOCATABLE :: seed

          CALL RANDOM_SEED(size = n)
          ALLOCATE(seed(n))

          CALL SYSTEM_CLOCK(COUNT=clock)

          seed = clock + 37 * (/ (i - 1, i = 1, n) /)
          CALL RANDOM_SEED(PUT = seed)

          DEALLOCATE(seed)
       END SUBROUTINE

C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
      SUBROUTINE NOSGEN(M,VAR,IDUM,AS1)

      IMPLICIT REAL*8(A-H,O-Z)

      DIMENSION AS1(594),AM(594),COV(594,594)

CHANGE ALL SIZES FROM 150 TO 594, I THINK.

C  THIS SUBROUTINE, CALLED BY SIMBIG, INPUTS M AND VAR (AND IDUM), AND
C  RETURNS THE M x 1 VECTOR, AS1--IID--N(0,COV), WHERE COV REPRESENTS 
C  THE COVARIANCE MATRIX HAVING VAR ON THE DIAGONAL, AND 0 ON THE 
C  OFF-DIAGONAL, ELEMENTS. 



C  IDUM IS THE DUMMY INDEX NEEDED BY THE RANDOM NO. GENERATOR, RAN1.

C  SUBROUTINE GNRAT IS USED. 

C  ESTABLISH THE MEAN VECTOR, AM, AND THE COV VECTOR, COV.

      DO 10 I=1,M
   10 AM(I)=0.D0

      DO 20 I=1,M
      DO 20 J=1,I
   20 COV(I,J)=0.D0

      DO 30 I=1,M
   30 COV(I,I)=VAR

      CALL GNRAT(M,AM,COV,AS1,IDUM)

      RETURN
      END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
      SUBROUTINE STATT(NSUB,NP,V,SAMMEN,SAMCOV)
      IMPLICIT REAL*8(A-H,O-Z)
      DIMENSION V(100000,30),SAMMEN(30),SAMCOV(30,30),SUM(30),
     1SUMPRD(30,30)

C  THIS SUBROUTINE, CALLED BY SIMBIG, INPUTS NSUB,NP, AND V. V IS
C  AN NSUB x NP MATRIX.
C


C  IT OUTPUTS:
C
C  SAMMEN(I) = MEAN OF COLUMN I IN V, I=1,NP.


C  SAMCOV(I,J) = COVARIANCE BETWEEN VALUES IN COLS I AND J OF MATRIX
C                V (NOTE: NSUB, NOT NSUB-1 IS USED IN DENOMINATORS).
C
C  CALCULATE THE MEANS OF THE NP COLUMNS.

C
      DO 10 J=1,NP
   10 SUM(J)=0.D0
C
      DO 30 J=1,NP
      DO 20 I=1,NSUB
   20 SUM(J)=SUM(J)+V(I,J)

   30 SAMMEN(J)=SUM(J)/NSUB
C
C  CALCULATE THE COVARIANCES FOR EACH PAIR OF COLUMNS.
C
      DO 40 J=1,NP
      DO 40 K=1,J
   40 SUMPRD(J,K)=0.D0
C
      DO 60 J=1,NP
      DO 60 K=1,J
C
      DO 50 I=1,NSUB

   50 SUMPRD(J,K)=SUMPRD(J,K)+V(I,J)*V(I,K)
C
   60 SAMCOV(J,K)=(SUMPRD(J,K)-NSUB*SAMMEN(J)*SAMMEN(K))/NSUB
C
      RETURN
      END

C

CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
	SUBROUTINE VERIF1(PREFIX,EXT,NSUB,NVAR,C0,C1,C2,C3,
     1   NOFIX,VALFIX,PARFIX,FILEIN,IDIST,NGAUS,COF,AMEAN,COV,FILOUT,
     2   PATH,NOB,NUMEQT,IPRNPAT,C0DT,C1DT,C2DT,C3DT,
     3   C0DA,C1DA,C2DA,C3DA,C0OT,C1OT,C2OT,C3OT,ISEEDIND,PAR,ICSVFILE,
     4   OUTNPAG,TEXTFILE,OUTCSVNAME,OSname,ListDir,ILIMIT,BOUND,
     5   INTLIST,RPAR,IPAR)

        use npag_utils, only: verifyval

	IMPLICIT REAL*8(A-H,O-Z)

	PARAMETER(MAXNUMEQ=7)

        integer, dimension(128) :: INTLIST
        double precision, dimension(257) :: RPAR
        integer, dimension(257) :: IPAR

	DIMENSION VALFIX(20),COF(150),AMEAN(150,30),COV(150,30,30),
     1 C0(MAXNUMEQ),C1(MAXNUMEQ),C2(MAXNUMEQ),C3(MAXNUMEQ),
     2 CORR(30,30),ILIMIT(32),BOUND(32,2),XVERIFY(900)

	CHARACTER PREFIX*3,EXT*3,PARFIX(20)*11,PAR(30)*11,
     1   FILOUT*32,FILEIN*32,PATH*61,TMPFILE*32,PATHFILE*93,OUTNPAG*20,
     2   OUTCSVNAME*32,OSname*20,ListDir*10,TEXTFILE*20

C  SUBROUTINE VERIF1 IS CALLED BY MAIN TO PRINT TO THE SCREEN THE INPUT
C  INFO, SO THE USER CAN VERIFY THAT THE VALUES WERE ENTERED CORRECTLY.
C  IF NOT, THE USER MAY CHANGE THESE VALUES.

C  NOTE: SUBROUTINE CHANGE BELOW IS CALLED SEVERAL TIMES. ITS ARGUMENT,
C        ICHANG, RETURNS AS 1 IF THE PREVIOUS INFORMATION PRINTED TO THE
C        SCREEN IS VALIDATED BY THE USER; IT RETURNS AS 0 IF THE USER
C        WANTS TO CHANGE SOMETHING. 

  102   FORMAT(A32)
  103   FORMAT(A3)
  104   FORMAT(A3)

 8040   WRITE(*,1)
    1   FORMAT(///' THE FOLLOWING INFO WAS READ IN; IF ANY OF IT IS '/
     1' INCORRECT, MAKE THE DESIRED CHANGES.')
C
C  
C
        IF(ICSVFILE .EQ. 0) WRITE(*,8002) FILEIN

 8002   FORMAT(/' THE PATIENT DOSE/COVARIATE AND OBS. TIME INFO WILL '/
     1' BE INPUT FROM THE WORKING COPY PATIENT FILE: ',A32)

        IF(ICSVFILE .EQ. 1) WRITE(*,8023) FILEIN
 8023   FORMAT(/' THE PATIENT DOSE/COVARIATE AND OBS. TIME INFO WILL '/
     1' BE FROM THE DATA OF THE FIRST SUBJECT IN THE BLOCK MATRIX '/
     2' .CSV FILE: ',A32) 
C
C 
C

	CALL CHANGE(ICHANG)

	IF(ICHANG .EQ. 0) THEN
C
C
C
 5020   WRITE(*,5002)
 5002   FORMAT(/' THE DOSE/COVARIATE AND OBSERVATION TIME INFORMATION'/
     1' WHICH WILL BE USED TO SIMULATE THE PATIENT DATA FILES CAN BE'/
     2' INPUT VIA A (MULTIPLE DRUG) WORKING COPY PATIENT DATA FILE OR'/

     3' VIA A BLOCK MATRIX .CSV FILE (THE INFO WILL COME FROM THE '/
     4' DATE OF THE FIRST SUBJECT IN THIS CASE).'//
     5' ENTER 1 TO ENTER INFO USING A .CSV FILE; '/
     6' ENTER 0 TO ENTER INFO USING A WORKING COPY PATIENT DATA FILE: ')
        READ(*,*,ERR=5020) ICSVFILE
        IF(ICSVFILE .NE. 1 .AND. ICSVFILE .NE. 0) GO TO 5020

        IF(ICSVFILE .EQ. 0) THEN

        WRITE(*,1021)
 1021   FORMAT(/' ENTER THE NAME OF THE WORKING COPY PATIENT DATA FILE'/
     1' WHICH CONTAINS THE DOSE/COVARIATE INFORMATION WHICH WILL BE'/
     2' USED TO SIMULATE THE PATIENT DATA FILES.'//
     3' BE SURE THAT THIS IS A MULTI-DRUG WORKING COPY DATA FILE.'//
     1' ENTER -99 TO SEE ALL OR A PART OF YOUR DIRECTORY: ')
        READ(*,212) FILEIN

        IF(FILEIN(1:3) .EQ. '-99') CALL SEEDIR(PATH,NOB,FILEIN,
     1     OSname,ListDir)

C  CHECK THAT THIS IS AN EXISTING FILE.

C  CALL FULLNAME WHICH CONVERTS THE FILENAME TO PATHFILE, THE COMPLETE 
C  NAME OF THE FILE, WHICH INCLUDES THE PATH (IF THE PATH IS NOT THE 
C  CURRENT DIRECTORY).

	TMPFILE = ' '
	TMPFILE = FILEIN
	CALL FULLNAME(PATH,TMPFILE,PATHFILE)
	OPEN(21,FILE=PATHFILE,ERR=6440,STATUS='OLD')
	GO TO 6455
 6440 WRITE(*,5316) PATHFILE
 5316 FORMAT(//' THE FOLLOWING FILE DOES NOT EXIST ... '/
     1' ',A93)

	GO TO 5020
 6455 CONTINUE

        ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(ICSVFILE .EQ. 0) CONDITION.


        IF(ICSVFILE .EQ. 1) THEN

        WRITE(*,3021)
 3021   FORMAT(/' ENTER THE NAME OF THE BLOCK MATRIX .CSV FILE. ONLY'/
     1' THE DATA FROM THE FIRST SUBJECT IN THIS FILE WILL BE READ TO'/
     2' OBTAIN THE DOSE/COVARIATE INFORMATION WHICH WILL BE USED TO'/
     3' TO SIMULATE THE PATIENT DATA FILES.'//
     1' ENTER -99 TO SEE ALL OR A PART OF YOUR DIRECTORY: ')
     	  READ(*,212) FILEIN
  212   FORMAT(A32)
        IF(FILEIN(1:3) .EQ. '-99') CALL SEEDIR(PATH,NOB,FILEIN,
     1     OSname,ListDir)

C  CHECK THAT THIS IS AN EXISTING FILE.

C  CALL FULLNAME WHICH CONVERTS THE FILENAME TO PATHFILE, THE COMPLETE 
C  NAME OF THE FILE, WHICH INCLUDES THE PATH (IF THE PATH IS NOT THE 
C  CURRENT DIRECTORY).

        TMPFILE = ' '
        TMPFILE = FILEIN
        CALL FULLNAME(PATH,TMPFILE,PATHFILE)
        OPEN(87,FILE=PATHFILE,ERR=5440,STATUS='OLD')


        GO TO 5455
 5440   WRITE(*,5316) PATHFILE
        GO TO 5020

 5455   CONTINUE



C  AS OF MONT101F.FOR, BEFORE CALLING NEWCSV, MUST CALL CONVERTCSV,
C  WHICH CONVERTS A "EUROPEAN" .CSV FILE TO THE TYPICAL "AMERICAN"
C  VERSION. IF THE .CSV FILE IS ALREADY IN THE "AMERICAN" FORMAT,
C  CONVERTCSV SIMPLY REWRITES FILE 87 TO SCRATCH FILE 77. NOTE THAT
C  NEWCSV CONVERTS FILE 77 TO FILE 67.

        CALL CONVERTCSV

C  CALL SUBROUTINE NEWCSV WHICH CONVERTS THE .CSV FILE IN FILE 77 TO
C  A NEW .CSV FILE IN FILE 67, WITH ALL MISSING VALUE DOTS CHANGED TO

C  n's. THEN CALL CSVCHANGE WHICH CHANGES .csv FILES WITH CODE OF
C  POPDATA DEC_11 (I.E., THOSE WITH 2 EXTRA COLUMNS FOR ADDL AND II)
C  TO EQUIVALENT .csv FILES WITH CODE OF POPDATA APR_11 (THOSE WITHOUT
C  THE TWO EXTRA COLUMNS). CSVCHANGE READS FILE 67, AND WRITES THE 

C  INFORMATION TO SCRATCH FILE 66. NOTE THAT IF THE .csv FILE READ IN
C  ALREADY IS THE OLDER VERSION (WITH CODE POPDATA APR_11), CSVCHANGE
C  SIMPLY REWRITES IT TO FILE 66, WHICH IS THEN READ BY SUBROUTINE
C  READBLOCK2.

         OPEN(67)
         CALL NEWCSV
         CALL CSVCHANGE 
         REWIND(66)

C  CREATE THE MULTIPLE DRUG WORKING COPY FILE XQZPJ001.ZMQ IN THE
C  WORKING COPY DIRECTORY FROM THE DATA OF THE FIRST SUBJECT IN 
C  PATHFILE. NOTE THAT READBLOCK2 BELOW IS BASED ON
C  READBLOCK IN THE NPAG PC PREP PROGRAM, BUT ONLY CREATES A WORKING
C  COPY FILE FOR THE FIRST SUBJECT.

         CALL READBLOCK2(PATH,C0,C1,C2,C3,INTLIST,RPAR,IPAR)
         CLOSE(66)

C  NOW OPEN THE JUST MADE WORKING COPY PATIENT DATA FILE.

        TMPFILE = ' '
        TMPFILE = 'XQZPJ001.ZMQ'
        CALL FULLNAME(PATH,TMPFILE,PATHFILE)
        OPEN(21,FILE=PATHFILE,ERR=5465,STATUS='OLD')
        GO TO 5470
 5465   WRITE(*,5466) PATHFILE,FILEIN

 5466   FORMAT(//' THE FOLLOWING FILE DOES NOT EXIST ... '/
     1' ',A93/
     2' WHICH MEANS THAT YOUR .CSV FILE, ',A20,' WAS NOT READ '/
     3' PROPERLY. PLEASE CHECK THIS FILE TO MAKE SURE IT IS CORRECT.'//)
        GO TO 5020
        
 5470   CONTINUE

        ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(ICSVFILE .EQ. 1) CONDITION.


C  CHECK THAT NUMEQT FOR THIS NEW WORKING COPY FILE IS THE SAME AS 
C  NUMEQT FOR THE OLD FILE. IF NOT CHANGE NUMEQT AND TELL THE USER.

C  CALL SUBROUTINE GETNUMEQ, WHICH READS FILE 21 OPENED  ABOVE TO GET
C  THE NO. OF OUTPUT EQUATIONS (NUMEQT2). 

	CALL GETNUMEQ(NUMEQT2,INTLIST,RPAR,IPAR)
	CLOSE(21)

	IF(NUMEQT .NE. NUMEQT2) THEN

	 WRITE(*,7512) NUMEQT2,NUMEQT
 7512    FORMAT(//' YOUR NEW WORKING COPY FILE HAS ',I4,' OUTPUT'/
     1' EQUATION(S), RATHER THAN THE ',I4,' OUTPUT EQUATION(S) THAT '/
     2' YOUR ORIGINAL WORKING COPY FILE HAD. BE SURE TO CHANGE THE '/
     3' ASSAY COEFFICIENT INFORMATION BELOW, IF NEEDED.')


C  IF NUMEQT (OLD) < NUMEQT2 (NEW), PUT 1'S IN ALL NEW ENTRIES OF
C  C0,...,C3. THEY CAN BE CHANGED BY USER BELOW.

	 IF(NUMEQT .LT. NUMEQT2) THEN
	  DO IEQ = NUMEQT+1,NUMEQT2
	   C0(IEQ) = 1
	   C1(IEQ) = 1
	   C2(IEQ) = 1
	   C3(IEQ) = 1
	  END DO
	 ENDIF


	NUMEQT = NUMEQT2
        INTLIST(9) = NUMEQT


	ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(NUMEQT .NE. NUMEQT2)  CONDITION.
C
C
C
	ENDIF
C
C 
C
	WRITE(*,6) NSUB
    6   FORMAT(/' THE NO. OF PATIENT FILES TO BE SIMULATED IS: ',I5)
C
C

	CALL CHANGE(ICHANG)
	IF(ICHANG .EQ. 0) THEN
C
C
 4070   WRITE(*,121) 
  121   FORMAT(/' ENTER THE NO. OF SUBJECTS TO BE SIMULATED (LESS THAN'/
     1'		10000): ')
	READ(*,*,ERR=4070) NSUB
	IF(NSUB .LE. 0 .OR. NSUB .GT. 10000) GO TO 4070
C
C
        ENDIF
C
C
	WRITE(*,5183)
 5183   FORMAT(//' IF YOU WOULD LIKE TO CHANGE YOUR FORTRAN MODEL'/
     1' FILE OR THE DESIGNATION OF WHICH PARAMETERS ARE TO BE RANDOM'/
     2' AND WHICH FIXED, PLEASE STOP THIS PROGRAM NOW, AND THEN '/
     3' RERUN IT.'//
     4' YOU WILL, HOWEVER, BE ABLE TO CHANGE THE FIXED PARAMETER'/
     5' VALUES, AS WELL AS THE DISTRIBUTION OF THE RANDOM PARAMETERS,'/
     6' AND THEIR BOUNDARIES, BELOW.'//)

	CALL PAUSE

	WRITE(*,201)
  201   FORMAT(/' THE USER-ENTERED FIXED PARAMETER VALUE(S) IS (ARE):')

	IF(NOFIX .EQ. 0) WRITE(*,*)' ... NONE SELECTED.'

	IF(NOFIX .GT. 0) THEN
	  DO 210 I=1,NOFIX
  210     WRITE(*,211) PARFIX(I),VALFIX(I)
	ENDIF

  211   FORMAT(/' ',A11,': ',G17.10)



C  REPLACE WRITING OF C0(),...,C3() WITH XVERIFY (SEE LOGIC IN 
C  SUBROUTINE VERIFYVAL.

	WRITE(*,12)
   12   FORMAT(/' THE ASSAY S.D. COEFFICIENTS, [C0,C1,C2,C3] ARE, FOR'/
     1' EACH OUPUT EQUATION, AS FOLLOWS: ')
       DO IEQ = 1,NUMEQT
        XVERIFY(1) = C0(IEQ)
        XVERIFY(2) = C1(IEQ)
        XVERIFY(3) = C2(IEQ)
        XVERIFY(4) = C3(IEQ)
        CALL VERIFYVAL(4,XVERIFY)
C	  WRITE(*,162) IEQ,C0(IEQ),C1(IEQ),C2(IEQ),C3(IEQ)
        WRITE(*,162) IEQ,(XVERIFY(IXV),IXV=1,4)
	  CALL PAUSE
       END DO

  162   FORMAT(' EQ. ',I2,': ',4(G16.10,1X))
C


C
	CALL CHANGE(ICHANG)
	IF(ICHANG .EQ. 0) THEN

C
C
	WRITE(*,119) 
  119 FORMAT(//' FOR EACH OUTPUT EQUATION, ENTER, IN ORDER, '/
     1' C0,C1,C2,C3, WHERE, FOR EACH OBSERVED VALUE, Y, THE ASSAY'/
     3' STANDARD DEVIATION IS SD = C0+C1*Y+C2*Y**2+C3*Y**3):')

	DO IEQ = 1,NUMEQT
	 WRITE(*,1119) IEQ
 1119    FORMAT(/' ENTER THE VALUES FOR [C0,C1,C2,C3] FOR OUTPUT'/
     1'  EQUATION ',I1,': ')
 4140    READ(*,*,ERR=4145) C0(IEQ),C1(IEQ),C2(IEQ),C3(IEQ)
   	 GO TO 2120
 4145    WRITE(*,4146)
 4146    FORMAT(/' SEE ABOVE; PLEASE ENTER FOUR REAL NUMBERS: ')
	 GO TO 4140
 2120	 CONTINUE
	END DO
C
C
	ENDIF 
C
C
 2020	WRITE(*,2219)
 2219 FORMAT(//' THE DOSE TIMES, THE DOSE AMOUNTS (INCLUDING ALL IV'/
     1' RATES AND BOLUS VALUES), AND THE OBSERVATION TIMES WHICH THE'/ 
     2' PROGRAM HAS READ FROM THE WORKING COPY PATIENT DATA FILE '/
     3' ABOVE WILL ALL BE ASSUMED TO BE "NOISY" VALUES.'//
     5' ENTER 0 FOR AN EXPLANATION OF HOW THE "NOISY" VALUES ARE OBTAINE
     1D.'/
     6' ENTER 1 TO CONTINUE: ')
	READ(*,*,ERR= 2020) ICONT
	IF(ICONT .NE. 0 .AND. ICONT .NE. 1) GO TO 2020

	IF(ICONT .EQ. 0) CALL EXPLAINOISE

C  REPLACE WRITING OF C0DT,...,C3DT WITH XVERIFY (SEE LOGIC IN 
C  SUBROUTINE VERIFYVAL. SIMILARLY, FOR C0DA...; C0OT...

        XVERIFY(1) = C0DT
        XVERIFY(2) = C1DT
        XVERIFY(3) = C2DT
        XVERIFY(4) = C3DT
        CALL VERIFYVAL(4,XVERIFY)
C	  WRITE(*,2221) C0DT,C1DT,C2DT,C3DT
        WRITE(*,2221) (XVERIFY(IXV),IXV=1,4)
 2221   FORMAT(/' FOR THE DOSE TIMES, THE Cs ARE ',4(G14.8,1X))

        XVERIFY(1) = C0DA
        XVERIFY(2) = C1DA
        XVERIFY(3) = C2DA
        XVERIFY(4) = C3DA
        CALL VERIFYVAL(4,XVERIFY)
C       WRITE(*,2222) C0DA,C1DA,C2DA,C3DA
        WRITE(*,2222) (XVERIFY(IXV),IXV=1,4)

 2222   FORMAT(/' FOR THE DOSE AMOUNTS, THE Cs ARE ',4(G14.8,1X))

        XVERIFY(1) = C0OT
        XVERIFY(2) = C1OT
        XVERIFY(3) = C2OT
        XVERIFY(4) = C3OT
        CALL VERIFYVAL(4,XVERIFY)
C       WRITE(*,2223) C0OT,C1OT,C2OT,C3OT
        WRITE(*,2223) (XVERIFY(IXV),IXV=1,4)


 2223   FORMAT(/' FOR THE OBS. TIMES, THE Cs ARE ',4(G14.8,1X))

C
C
	CALL CHANGE(ICHANG)
	IF(ICHANG .EQ. 0) THEN
C

C
	WRITE(*,6223)
 6223   FORMAT(/' ENTER C0,C1,C2,C3 FOR THE DOSE TIMES: ')
 6140   READ(*,*,ERR=6145) C0DT,C1DT,C2DT,C3DT

   	GO TO 6120
 6145   WRITE(*,4146)
	GO TO 6140
 6120	CONTINUE

	WRITE(*,7223)
 7223   FORMAT(/' ENTER C0,C1,C2,C3 FOR THE DOSE AMOUNTS: ')
 7140   READ(*,*,ERR=7145) C0DA,C1DA,C2DA,C3DA
   	GO TO 7120
 7145   WRITE(*,4146)
	GO TO 7140

 7120	CONTINUE

	WRITE(*,8223)
 8223   FORMAT(/' ENTER C0,C1,C2,C3 FOR THE OBSERVATION TIMES: ')
 8140   READ(*,*,ERR=8145) C0OT,C1OT,C2OT,C3OT
   	GO TO 8120
 8145   WRITE(*,4146)
	GO TO 8140
 8120	CONTINUE
C
C
	ENDIF 
C
C

      IF(IDIST .EQ. 0) THEN

        WRITE(*,254) NGAUS
  254   FORMAT(/' THE OBSERVATIONS FOR EACH OF THE ',I3,' SUBJECT'/
     1' VECTORS WILL BE GENERATED BY ASSUMING EACH SUBJECT HAS EXACTLY'/
     2' THE PARAMETER VALUES OF ONE OF THE GRID PTS. IN THE FINAL'/
     3' CYCLE DENSITY FROM THE INPUT NPAG RUN. THESE GRID PTS. ARE: '/)

        CALL PAUSE
C  CALL PAUSE ADDED HERE (IN MONT108.FOR) BECAUSE IF NGAUS IS LARGER 
C  THAN ABOUT 5, THE ABOVE STATEMENT WILL SCROLL OFF THE SCREEN.

C  REPLACE WRITING OF AMEAN(),COV() WITH XVERIFY (SEE LOGIC IN 
C  SUBROUTINE VERIFYVAL).

       DO IGAUS = 1,NGAUS
        WRITE(*,9004) IGAUS
 9004   FORMAT(//' GRID PT. NO: ',I3)
        DO I = 1,NVAR
         XVERIFY(I) = AMEAN(IGAUS,I)
        END DO
        CALL VERIFYVAL(NVAR,XVERIFY)
C       WRITE(*,9007) (AMEAN(IGAUS,I),I=1,NVAR)     
        WRITE(*,9007) (XVERIFY(I),I=1,NVAR)
 9007   FORMAT(/' PAR. VALUES: ',30G10.3)
       END DO

      ENDIF
C  THE ABOVE ENDIF IS FOR THE  IF(IDIST .EQ. 0)  CONDITION.


	IF(IDIST .EQ. 1) WRITE(*,8003) NGAUS
 8003   FORMAT(/' THE SUBJECT VECTORS WILL BE GENERATED FROM A MIXTURE'/
     1' OF ',I3,' GAUSSIAN DISTRIBUTIONS. THE FOLLOWING DESCRIBES '/
     2' THESE DISTRIBUTIONS: ')

	IF(IDIST .EQ. 2) WRITE(*,9003) NGAUS
 9003   FORMAT(/' THE SUBJECT VECTORS WILL BE GENERATED FROM A MIXTURE'/
     1' OF ',I3,' LOGNORMAL DISTRIBUTIONS. THE FOLLOWING DESCRIBES '/
     2' THESE DISTRIBUTIONS: ')


      IF(IDIST .NE. 0) THEN

 4320	WRITE(*,4321)
 4321   FORMAT(/' ENTER 1 TO SEE INFO IN TERMS OF CORRELATIONS; '/
     1' ENTER 0 TO SEE INFO IN TERMS OF COVARIANCES: ')
	READ(*,*,ERR=4320) ICORR
	IF(ICORR .NE. 1 .AND. ICORR .NE. 0) GO TO 4320

	DO 8020 IGAUS=1,NGAUS

C  REPLACE WRITING OF AMEAN(),COF() WITH XVERIFY (SEE LOGIC IN 
C  SUBROUTINE VERIFYVAL).

        WRITE(*,8004) IGAUS
 8004   FORMAT(//' DISTRIBUTION NO: ',I3)
        XVERIFY(1) = COF(IGAUS)
        CALL VERIFYVAL(1,XVERIFY)      
C       WRITE(*,8006) COF(IGAUS)
        WRITE(*,8006) XVERIFY(1)
 8006   FORMAT(/' WEIGHTING COEFFICIENT: ',F10.3)

        IF(ICORR .EQ. 0) THEN
         DO I = 1,NVAR
          XVERIFY(I) = AMEAN(IGAUS,I)
         END DO
         CALL VERIFYVAL(NVAR,XVERIFY)      
C        WRITE(*,8007) (AMEAN(IGAUS,I),I=1,NVAR)
         WRITE(*,8007) (XVERIFY(I),I=1,NVAR)
 8007    FORMAT(/' MEAN VECTOR: ',30G10.3)
         WRITE(*,8008) 
 8008    FORMAT(/' THE COVARIANCE MATRIX, IN LOWER-TRIANGULAR FORM IS:')
         DO I=1,NVAR
          WRITE(*,*) (COV(IGAUS,I,J),J=1,I)
         END DO
	  ENDIF

        IF(ICORR .EQ. 1) THEN

         DO I = 1,NVAR

C  REPLACE WRITING OF AMEAN(),DSQRT() WITH XVERIFY (SEE LOGIC IN 
C  SUBROUTINE VERIFYVAL).

         XVERIFY(1) = AMEAN(IGAUS,I)
         XVERIFY(2) = DSQRT(COV(IGAUS,I,I))
         CALL VERIFYVAL(2,XVERIFY)      
C        WRITE(*,4323) PAR(I),AMEAN(IGAUS,I),DSQRT(COV(IGAUS,I,I))
         WRITE(*,4323) PAR(I),(XVERIFY(IXV),IXV=1,2) 

 4323   FORMAT(/' THE MEAN AND STD. DEV. FOR ',A30,' ARE ',2(G10.3,2X)
     1) 

         END DO

         WRITE(*,4324)
 4324    FORMAT(/' THE CORR. MATRIX IN LOWER-TRIANGULAR FORM IS: ')
	
C  ESTABLISH THE LOWER-TRIANGULAR CORRELATION MATRIX.

	 DO I = 1,NVAR
	  DO J = 1,I
	   CORR(I,J)=COV(IGAUS,I,J)/DSQRT(COV(IGAUS,I,I)*COV(IGAUS,J,J))

	  END DO
	 END DO

	 DO I = 1,NVAR
	  WRITE(*,*) (CORR(I,J),J=1,I)
	 END DO

        ENDIF


C  THE ABOVE ENDIF IS FOR THE  IF(ICORR .EQ. 1) THEN  CONDITION.


	CALL PAUSE

 8020   CONTINUE

C  AS OF MONTBIG7.FOR, 8020 HAS BEEN CHANGED TO BE A CONTINUE STMT SINCE
C  SOME COMPILERS "COMPLAIN" ABOUT ENDING A DO LOOP WITH A PAUSE 
C  COMMAND.

      ENDIF
C  THE ABOVE ENDIF IS FOR THE  IF(IDIST .NE. 0)  CONDITION.

C
C
      CALL CHANGE(ICHANG)
      IF(ICHANG .EQ. 0) THEN

C  SET OUTNPAG TO ALL BLANKS. IF IT CHANGES AFTER A CALL TO GETDIST, IT
C  MEANS THAT IT CONTAINS THE NAME OF THE BIG NPAG OUTPUT FILE FROM 
C  WHICH THE NGAUS DISTRIBUTIONS WERE ESTABLISHED. SIMILARLY FOR
C  TEXTFILE WHICH, IF NOT ALL BLANKS, CONTAINS THE NAME OF THE TEXT FILE
C  WHICH HAS THE NGAUS DISTRIBUTIONS MEANS.

        OUTNPAG(1:20) = '                    '
        TEXTFILE(1:20) = '                    '



C  CALL GETDIST TO OBTAIN THE DESIRED DISTRIBUTION DETAILS FROM THE 
C  USER.

       CALL GETDIST(IDIST,NGAUS,NVAR,COF,AMEAN,COV,PATH,NOB,OUTNPAG,
     1  TEXTFILE,OSname,ListDir,INTLIST,RPAR,IPAR)

      ENDIF


C  IF IDIST = 0, SET ALL ILIMIT(.) VALUES TO BE 1.

      IF(IDIST .EQ. 0) THEN
       DO I =1,NVAR
        ILIMIT(I) = 1
       END DO
      ENDIF


      IF(IDIST .NE. 0) THEN

      WRITE(*,143)
  143 FORMAT(/' THE ALLOWABLE BOUNDARIES FOR EACH R.V. ARE SHOWN'/
     1' BELOW. IF A SIMULATED R.V. IS OUTSIDE ITS ALLOWABLE'/
     2' BOUNDARIES, THE CORRESPONDING PARAMETER SET WILL NOT BE USED'/
     3' TO SIMULATE A SUBJECT, BUT WILL BE INCLUDED IN THE CALCULATION'/
     4' OF THE OVERALL SUMMARY STATISTICS IN THE OUTPUT FILE.'//)

C  REPLACE WRITING OF BOUND() WITH XVERIFY (SEE LOGIC IN SUBROUTINE
C  VERIFYVAL). SIMIARLY FOR ALL CALLS TO VERIFYVAL.

       DO I = 1,NVAR
        IF(ILIMIT(I) .EQ. 1) WRITE(*,141) PAR(I)
  141   FORMAT(/1X,A11,' HAS NO RESTRICTIONS ON ITS SIMULATED VALUES')

        XVERIFY(1) = BOUND(I,1)
        XVERIFY(2) = BOUND(I,2)
        CALL VERIFYVAL(2,XVERIFY)
C       IF(ILIMIT(I) .EQ. 0) WRITE(*,142) PAR(I),BOUND(I,1),BOUND(I,2)
        IF(ILIMIT(I) .EQ. 0) WRITE(*,142) PAR(I),(XVERIFY(IXV),IXV=1,2)
  142   FORMAT(/1X,A11,' HAS BOUNDARIES: ',G19.9,'  TO  ',G19.9)   
       END DO 

	 CALL CHANGE(ICHANG)
       IF(ICHANG .EQ. 0) THEN

       DO I = 1,NVAR


  160   WRITE(*,146) PAR(I)
  146   FORMAT(//' FOR ',A11/
     1/' ENTER 1 IF THERE ARE TO BE NO RESTRICTIONS ON ITS SIMULATED VAL
     2UES;'/
     3' ENTER 0 IF THE SIMULATED VALUES ARE TO BE RESTRICTED: ')
        READ(*,*,ERR=160) ILIMIT(I)
        IF(ILIMIT(I) .NE. 1 .AND. ILIMIT(I) .NE. 0) GO TO 160


        IF(ILIMIT(I) .EQ. 0) THEN
  170    WRITE(*,144)
  144    FORMAT(/' ENTER THE DESIRED BOUNDARIES [L,U], WHERE L < U: ')
         READ(*,*,ERR=170) BOUND(I,1),BOUND(I,2)
         IF(BOUND(I,1) .GE. BOUND(I,2)) GO TO 170
        ENDIF

        END DO 

C  THE ABOVE END DO IS FOR THE  DO I = 1,NVAR  LOOP.

       ENDIF

      ENDIF
C  THE ABOVE ENDIF IS FOR THE  IF(IDIST .NE. 0)  CONDITION.

C
C------------------------------------
C

	WRITE(*,8011) FILOUT
 8011   FORMAT(/' THE OUTPUT FILE, WHICH WILL CONTAIN ALL THE'/

     1' GENERATED DATA OF THE PROGRAM IS: ',A32)
C
C
	CALL CHANGE(ICHANG)
	IF(ICHANG .EQ. 0) THEN
C
C
      WRITE(*,1117)
 1117 FORMAT(/,' ENTER THE OUTPUT FILENAME WHICH WILL CONTAIN ALL THE'/
     1' GENERATED DATA OF THIS PROGRAM: ')
      READ(*,102) FILOUT
C
C
	ENDIF

C
C------------------------------------
C
        IF(IPRNPAT .EQ. 1 .OR. IPRNPAT .EQ. 3) 
     1   WRITE(*,9013) NSUB,OUTCSVNAME

 9013   FORMAT(/' THE INFORMATION FROM THE ',I5,' SIMULATED PATIENT'/
     1' DATA FILES WILL BE SAVED IN BLOCK FORMAT TO '/
     2' FILE ',A32)

        IF(IPRNPAT .EQ. 2 .OR. IPRNPAT .EQ. 3) 
     1   WRITE(*,8013) NSUB,PREFIX,EXT
 8013   FORMAT(/' THIS RUN WILL CREATE ',I5,' SIMULATED PATIENT DATA '/
     1' FILES, WITH PREFIX ',A3,' AND EXTENSION ',A3) 
       
        IF(IPRNPAT .EQ. 0) WRITE(*,8014)
 8014   FORMAT(/' THE INFORMATION FROM THIS RUN WILL NOT BE SAVED IN'/
     1' BLOCK FORMAT TO A .CSV FILE, AND NO SIMULATED PATIENT DATA '/
     2' FILES WILL BE CREATED. THIS MEANS THAT YOU ARE ONLY INTERESTED'/
     3' IN THE INFORMATION WRITTEN TO THE OUTPUT FILE.')


        CALL CHANGE(ICHANG)

        IF(ICHANG .EQ. 0) THEN

 1230	  WRITE(*,1234) NSUB,NSUB
 1234   FORMAT(/' ENTER 1 IF YOU WOULD LIKE THE INFORMATION FROM '/

     1'         THE ',I5,' SIMULATED PATIENT DATA FILES TO BE SAVED'/
     2'         IN BLOCK FORMAT TO A .CSV FILE; '/
     3' ENTER 2 IF YOU WOULD LIKE TO CREATE THE ',I5,' SIMULATED '/
     4'         PATIENT DATA FILES IN WORKING COPY FORMAT; '/
     5' ENTER 3 IF YOU WOULD LIKE BOTH A .CSV FILE AND A SET OF '/
     6'         WORKING COPY FILES TO BE MADE;'/
     7' ENTER 0 IF YOU DO NOT NEED A .CSV FILE OR A SET OF WORKING '/
     8'         COPY FILES (I.E., YOU ONLY NEED THE INFO THAT IS '/

     9'         SUPPLIED IN THE OUTPUT FILE): ')
        READ(*,*,ERR=1230) IPRNPAT
        IF(IPRNPAT .LT. 0 .OR. IPRNPAT .GT. 3) GO TO 1230

        IF(IPRNPAT .EQ. 1 .OR. IPRNPAT .EQ. 3) THEN

 1390    WRITE(*,1236)
 1236    FORMAT(/' ENTER THE NAME OF THE FILE WHICH WILL STORE THE'/
     1' SIMULATED INFO IN .CSV FORMAT: ')
         
         READ(*,102) OUTCSVNAME

C  CALL FULLNAME WHICH CONVERTS THE FILENAME TO PATHFILE, THE COMPLETE 
C  NAME OF THE FILE, WHICH INCLUDES THE PATH (IF THE PATH IS NOT THE 
C  CURRENT DIRECTORY).

 1380	   TMPFILE = ' '
         TMPFILE = OUTCSVNAME
         CALL FULLNAME(PATH,TMPFILE,PATHFILE)
         OPEN(29,FILE=PATHFILE,ERR=1370,STATUS='NEW')
         GO TO 1375
 1370    WRITE(*,9826) PATHFILE
 9826    FORMAT(/' THE FOLLOWING FILE ALREADY EXISTS ....'/
     1'    ',A93/
     1' ENTER 0 TO ENTER A NEW FILENAME;'/
     2' ENTER 1 TO OVERWRITE THIS FILE: ')
         READ(*,*,ERR=1370) IFILE
         IF(IFILE .NE. 0 .AND. IFILE .NE. 1) GO TO 1370

         IF(IFILE .EQ. 0) GO TO 1390
         IF(IFILE .EQ. 1) OPEN(29,FILE=PATHFILE)

 1375    CLOSE(29)

        ENDIF

        
        IF(IPRNPAT .EQ. 2 .OR. IPRNPAT .EQ. 3) THEN

         WRITE(*,4041)
 4041    FORMAT(/' ENTER THE 3-CHAR PREFIX FOR THE SIMULATED PATIENT'/
     1' FILENAMES : ')
         READ(*,104) PREFIX
         WRITE(*,4043)
 4043	   FORMAT(/' IF THERE IS A 3-CHAR EXTENSION FOR THE PATIENT '/
     1' FILENAMES, ENTER IT NOW; OTHERWISE, PRESS ENTER: ')
         READ(*,103) EXT

        ENDIF


        ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(ICHANG .EQ. 0)  CONDITION.

C
C------------------------------------
C
	
	IF(ISEEDIND .EQ. 1) WRITE(*,1251)
 1251   FORMAT(/' THE STARTING SEED NO. FOR THE SIMULATOR WILL BE THE'/
     1' DEFAULT VALUE OF -17.')

	IF(ISEEDIND .EQ. 0) WRITE(*,1252)
 1252   FORMAT(/' THE STARTING SEED NO. FOR THE SIMULATOR WILL BE READ'/
     1' FROM THE FILE, "SEEDTO.MON", AND THIS FILE WILL THEN HAVE ITS '/
     2' SEED NO. DECREASED BY 123 FOR THE NEXT RUN.')

	CALL CHANGE(ICHANG)
	IF(ICHANG .EQ. 0) THEN

 1240	WRITE(*,1231)
 1231   FORMAT(/' ENTER 1 IF YOU WISH THE STARTING SEED NO. FOR THE'/
     1' 	SIMULATOR TO BE THE DEFAULT VALUE OF -17;'/
     2' ENTER 0 IF YOU WISH THE STARTING SEED NO. TO BE READ FROM'/
     3'		THE FILE, "SEEDTO.MON" (IN THIS CASE THIS FILE WILL'/
     4'		HAVE ITS SEED NO. DECREASED BY 123 FOR THE NEXT RUN): ')

	READ(*,*,ERR=1240) ISEEDIND
	IF(ISEEDIND .NE. 1 .AND. ISEEDIND .NE. 0) GO TO 1240	

	ENDIF
C
C------------------------------------
C

 5005   WRITE(*,5001)
 5001   FORMAT(///' ENTER 1 IF ALL INSTRUCTIONS ARE NOW CORRECT;'/
     2' ENTER 0 OTHERWISE: ') 
        READ(*,*,ERR=5005) ICHANG
	IF(ICHANG .NE. 0 .AND. ICHANG .NE. 1) GO TO 5005
	IF(ICHANG .EQ. 0) GO TO 8040


	RETURN


	END


C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
	SUBROUTINE CHANGE(ICHANG)
C
C  THIS SUBROUTINE IS CALLED BY SUBROUTINE VERIF1 TO HAVE THE USER CHECK
C  WHETHER HIS INPUT INFO IS CORRECT OR NEEDS TO BE CHANGED.

C
C  INPUT: NOTHING
C
C  OUTPUT:
C
C  ICHANG = 1 IF INFO PRINTED PREVIOUSLY TO THE SCREEN IS CORRECT.
C         = 0 IF INFO PRINTED PREVIOUSLY TO THE SCREEN SHOULD BE 
C             CHANGED.

C
   10   WRITE(*,1)
    1   FORMAT(//' ENTER 1 IF THE ABOVE INFORMATION IS CORRECT;'/
     1' ENTER 0 IF IT SHOULD BE CHANGED: ') 
	READ(*,*,ERR=10) ICHANG
	IF(ICHANG .NE. 0 .AND. ICHANG .NE. 1) GO TO 10
	RETURN
	END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
	SUBROUTINE OldSEEDIR(PATH,NOB,FILENAME)

	CHARACTER FILENAME*32,PATH*61,PRTDIR*47,TEMP*72,PRTDIR2*47

C  NOTE THAT PATH(1:NOB) IS THE CONDENSED (WITHOUT BLANKS) PATH.

   10	PRTDIR = ' '

	WRITE(*,6)
    6   FORMAT(/' PRESS THE ENTER KEY TO SEE YOUR ENTIRE DIRECTORY;'//
     1' ENTER A PARTIAL FILENAME (WITH THE * WILDCARD) TO SEE A '/
     2'       PARTICULAR SUBSET OF FILENAMES IN YOUR DIRECTORY. '/
     3'       e.g., ENTER  "TO*.INS TO SEE A LIST OF ALL FILES WHICH'/
     4'       BEGIN WITH "TO" AND HAVE A .INS SUFFIX '//
     5' NOTE THAT THE FILES WILL AUTOMATICALLY BE TIME-ORDERED FROM '/
     6' OLDEST TO NEWEST.'//
     7' ENTER YOUR CHOICE NOW: ')
	READ(*,1) PRTDIR
    1   FORMAT(A47)

C  REMOVE ANY BLANKS FROM PRTDIR SINCE THERE CAN BE NO BLANKS BETWEEN
C  THE END OF THE PATH AND THE BEGINNING OF THE "OBJECT" OF THE 
C  DIR COMMAND FOR SUBDIRECTORIES. PRTDIR, WITHOUT BLANKS, WILL BE 

C  PRTDIR2.

	IF(PRTDIR .EQ. ' ') TEMP = 'DIR/OD '//PATH(1:NOB)//' |MORE'

	IF(PRTDIR .NE. ' ') THEN
	 PRTDIR2 = ' '
	 J = 0
	 DO I=1,47
	  IF(PRTDIR(I:I) .NE. ' ') THEN
	   J = J+1
	   PRTDIR2(J:J) = PRTDIR(I:I)
	  ENDIF

	 END DO
	 TEMP = 'DIR/OD '//PATH(1:NOB)//PRTDIR2(1:J)//' |MORE'
	ENDIF

        CALL SYSTEM(TEMP)

     	WRITE(*,3)
    3   FORMAT(/' ENTER THE NAME OF THE DESIRED FILE (WITHOUT THE PATH);
     1'/
     2' ENTER -99 TO ENTER A DIFFERENT FILE SPECIFICATION: ')

	READ(*,2) FILENAME

    2   FORMAT(A32)
	IF(FILENAME(1:3) .EQ. '-99') GO TO 10

	RETURN

	END
C
C NEW SEEDIR() for UNIX by Yamada.

C
        SUBROUTINE SEEDIR(PATH,NOB,FILENAME,OSName,ListDir)
        CHARACTER FILENAME*20,PATH*60,PRTDIR*47,TEMP*72,PRTDIR2*47,
     1  OSName*20,ListDir*10

C  NOTE THAT PATH(1:NOB) IS THE CONDENSED (WITHOUT BLANKS) PATH.

   10   PRTDIR = ' '
        IF (INDEX(OSName,"UNIX",.TRUE.).eq.1) THEN
          WRITE(*,7)
        ELSE IF (INDEX(OSName,"DOS",.TRUE.).eq.1) THEN
          WRITE(*,6)
        END IF

    7   FORMAT(/' Press the ENTER key to call system(ls -t). '//
     1' Or type a partial filename (use the * wildcard) to call '/
     2'       system(ls -t arg_1), '/
     3'       e.g., type "to*.f ENTER" to see a list of all files '/
     4'       that begin with "to" and have a .f suffix. '//
     5' ENTER YOUR CHOICE NOW: ')

    6   FORMAT(/' PRESS THE ENTER KEY TO SEE YOUR ENTIRE DIRECTORY;'//
     1' ENTER A PARTIAL FILENAME (WITH THE * WILDCARD) TO SEE A '/
     2'       PARTICULAR SUBSET OF FILENAMES IN YOUR DIRECTORY. '/
     3'       e.g., ENTER  "TO*.INS TO SEE A LIST OF ALL FILES WHICH'/
     4'       BEGIN WITH "TO" AND HAVE A .INS SUFFIX '//
     5' NOTE THAT THE FILES WILL AUTOMATICALLY BE TIME-ORDERED FROM '/
     6' OLDEST TO NEWEST.'//
     7' ENTER YOUR CHOICE NOW: ')
        READ(*,1) PRTDIR
    1   FORMAT(A47)

C  REMOVE ANY BLANKS FROM PRTDIR SINCE THERE CAN BE NO BLANKS BETWEEN
C  THE END OF THE PATH AND THE BEGINNING OF THE "OBJECT" OF THE
C  DIR COMMAND FOR SUBDIRECTORIES. PRTDIR, WITHOUT BLANKS, WILL BE

C  PRTDIR2.

        IF (INDEX(OSName,"UNIX",.TRUE.).eq.1) THEN
           IF(PRTDIR .EQ. ' ') THEN
             TEMP = ListDir//PATH(1:NOB)
           ENDIF
        ELSE IF (INDEX(OSName,"DOS",.TRUE.).eq.1) THEN
           IF(PRTDIR .EQ. ' ') THEN
             TEMP = ListDir//PATH(1:NOB)//' |MORE'
           ENDIF
        ENDIF

        IF(PRTDIR .NE. ' ') THEN
         PRTDIR2 = ' '
         J = 0
         DO I=1,47
          IF(PRTDIR(I:I) .NE. ' ') THEN
           J = J+1
           PRTDIR2(J:J) = PRTDIR(I:I)
          ENDIF
         END DO

         IF (INDEX(OSName,"UNIX",.TRUE.).eq.1) THEN
           TEMP = ListDir//PATH(1:NOB)//PRTDIR2(1:J)
         ELSE IF (INDEX(OSName,"DOS",.TRUE.).eq.1) THEN
           TEMP = ListDir//PATH(1:NOB)//PRTDIR2(1:J)//' |MORE'
         ENDIF

        ENDIF

        CALL SYSTEM(TEMP)

        WRITE(*,3)
    3   FORMAT(/' ENTER THE NAME OF THE DESIRED FILE (WITHOUT THE PATH);
     1'/
     2' ENTER -99 TO ENTER A DIFFERENT FILE SPECIFICATION,'/
     3' OR TO VIEW THE DIRECTORY LISTING AGAIN ')
        READ(*,2) FILENAME
    2   FORMAT(A20)

        IF(FILENAME(1:3) .EQ. '-99') GO TO 10

        RETURN
        END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
	SUBROUTINE FULLNAME(PATH,FILE,FILE2)

C  FULLNAME CONVERTS FILE TO FILE2, THE COMPLETE NAME OF
C  THE FILE, WHICH INCLUDES THE PATH (IF THE PATH IS NOT THE CURRENT
C  DIRECTORY).

	CHARACTER PATH*61,FILE2*93,FILE*32,FILE1*93

C  INITIALIZE FILE1 AND FILE2 AS ALL BLANKS, IN CASE THE USER IS 
C  RE-ENTERING HIS FILENAME (SO THERE WON'T BE SOMETHING ALREADY IN 
C  THESE FILENAMES).

	FILE2 = ' '
	FILE1 = ' '
	FILE1 = PATH//FILE

C  ESTABLISH FILE2 AS FILE1 WITHOUT ANY BLANKS.

	J = 0
        DO I=1,93
	 IF(FILE1(I:I) .NE. ' ') THEN
	  J= J+1
	  FILE2(J:J) = FILE1(I:I)
	 ENDIF
	END DO

	RETURN
	END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C

	SUBROUTINE GETPATH(PATH,NOB,INTLIST,RPAR,IPAR)

C  THIS ROUTINE OBTAINS FROM THE USER THE PATH WHERE THE INPUT FILES 

C  ARE LOCATED (AND WHERE THE OUTPUT FILES WILL BE SENT). NOTE THAT
C  PATH RETURNS AS THE PATH WITH A TRAILING BACKSLASH.

C  NOB RETURNS AS THE NO. OF THE LAST NON-BLANK ENTRY IN PATH.

	CHARACTER PATH*61

        integer, dimension(128) :: intlist
        double precision, dimension(257) :: RPAR
        integer, dimension(257) :: IPAR

   10	WRITE(*,1)
    1   FORMAT(/' ENTER 1 IF THE FILES FOR THIS RUN ARE IN THE CURRENT D
     1IRECTORY; '/
     1' ENTER 0 OTHERWISE: ')
	READ(*,*,ERR=10) IPATH
	IF(IPATH .NE. 0 .AND. IPATH .NE. 1) GO TO 10

	IF(IPATH .EQ. 1) PATH = ' '
	NOB = 0

C  IF THE USER ENTERS A NON-NULL PATH BELOW, NOB WILL BE THE NO. OF
C  CHARACTERS IN THE PATH. IF HE ENTERS NOTHING, NOB STAYS 0, WHICH IS

C  THE CORRECT NO. OF CHARACTERS IN A NULL PATH.

	IF(IPATH .EQ. 0) THEN

	 WRITE(*,3)
    3    FORMAT(/' ENTER THE LOCATION (PATH) OF YOUR INPUT FILES. NOTE'/
     1' THAT THE PATH IS LIMITED TO 60 CHARACTERS AND THAT EACH SUB-DIRE
     2CTORY'/
     3' CAN HAVE AT MOST 8 CHARACTERS (E.G, INSTEAD OF " \DIRECTORY ", U
     4SE '/
     5' THE DOS-EQUIVALENT NAME, WHICH MIGHT BE " \DIRECT~1 "). '//
     6' ENTER THE PATH NOW: ')

	 READ(*,2) PATH


    2    FORMAT(A60)

C  IF THE USER DIDN'T END HIS PATH WITH A '\', PUT ONE IN FOR PATH.

C  NOTE THAT IF THE USER ENTERED A BLANK PATH, IT WILL BE ASSUMED THAT
C  HE WANTS THE CURRENT (WORKING) DIRECTORY.

	 DO I=1,60
	  J = 60 + 1 - I
	  IF(PATH(J:J) .NE. ' ') THEN
	   NOB = J
	   IF(PATH(J:J) .NE. '\') THEN
	    PATH(J+1:J+1) = '\'
	    NOB = J+1
	   ENDIF
	   RETURN
	  ENDIF
	 END DO


	ENDIF

	
	RETURN
	END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
	SUBROUTINE USERPREP(NDIM,NP,NVAR,MAXDIM,PAR,NOFIX,
     1  PARFIX,IRAN,INOPT,ICODE,ILIMIT,BOUND,INTLIST,RPAR,IPAR)

C  THIS SUBROUTINE, CALLED BY MAIN, READS THE FORTRAN FILE, FORFILE,
C  OPENED IN MAIN (FILE 28), WHICH WAS CREATED BY A 'BOXES'- TYPE 
C  PROGRAM, AND RETURNS THE VALUES IN THE ABOVE ARGUMENT LIST. 

C ???
C  NOTE: WHEN THIS PROGRAM STARTS READING THE NEW BOXES PROGRAM, MAKE
C      SURE THAT THE MICHAELIS-MENTIN EQUATION IS CORRECT - IT SHOULD
C	 BE  (SEE PAGE *1 OF M2_7/m2_7calc.f NOTES OR NOTES FROM PG. 5.
C  	 OF PHARMACOKINETICS AND PHARMACODYNAMICS, VOL 2).

C	 dX/dT = (VM x X) / (KM x V1 + X), WHERE VM = V1 * Vmax, AND
C	  THE UNITS ARE: X --> grams; T --> hours; VM --> grams/hour;

C			 V1 --> liters; KM --> grams/liter;
C			 Vmax --> grams/(liter * hour)

C  NOTE: THE ABOVE EQUATION IS EXACTLY THE SAME AS
C	 dC/dT = (Vmax * C)/(KM + C), WHERE C = X/V1, WHICH IS
C	  EQUATION 3 ON PG. 5 OF PHARMACOKINETICS AND PHARMACODYNAMICS, 
C         VOL 2, WHERE:
C	  Vmax = dC/dT AS C--> infinity;
C	  KM = C WHEN dC/dT = Vmax/2.

C	  ABOVE COMMENTS WERE IMPROVED 7/27/99 AFTER 
C         CONVERSATION WITH ROGER AND DARRYL CLARDY.
C ???

        IMPLICIT REAL*8(A-H,O-Z)
	DIMENSION IRAN(32),BOUND(32,2),ILIMIT(32)

        integer, dimension(128) :: INTLIST
        integer, dimension(257) :: RPAR
        integer, dimension(257) :: IPAR

        CHARACTER PAR(30)*11,PARFIX(20)*11,READLINE*78,PSYM(32)*11,
     1  RR*1,TEMP*11,C*1,ERRFIL*20



      COMMON/ERROR/ERRFIL
C  COMMON/ERROR/ IS SUPPLIED TO ALL THE ROUTINES WHICH COULD WRITE TO
C  ERRFIL.



C  FILE 28 WAS OPENED (IN MAIN) AT THE END OF THE FILE. BACKSPACE AND 
C  THEN READ IN NDIM, NP AND PSYM(I),I=1,NP.

    2   FORMAT(A78)

   30	BACKSPACE(28)


	BACKSPACE(28)
	READ(28,2) READLINE
	IF(READLINE(8:9) .NE. 'N=') GO TO 30
	BACKSPACE(28)
	READ(28,3) NDIM
    3   FORMAT(T10,I3)

   40	READ(28,2) READLINE
	IF(READLINE(8:9) .NE. 'NP') GO TO 40
	BACKSPACE(28)
	READ(28,4) NP
    4   FORMAT(T11,I3)

   50	READ(28,2) READLINE
	IF(READLINE(8:11) .NE. 'PSYM') GO TO 50


	BACKSPACE(28)

	DO 70 I=1,NP

	IF(I .LE. 9) READ(28,14) TEMP
	IF(I .GE. 10 .AND. I .LE. 99) READ(28,6) TEMP

C  WRITE TEMP INTO PSYM, STRIPPING OFF THE ENDING QUOTE MARK, IF ONE


C  IS THERE.

	C = ''''
	PSYM(I) = TEMP

	DO J=1,11

	 IF(TEMP(J:J) .EQ. C) THEN
	  PSYM(I) = TEMP(1:J-1)
	  GO TO 70
	 ENDIF	  


	END DO


   70   CONTINUE

   14   FORMAT(T17,A11)
    6   FORMAT(T18,A11)



C  IF INOPT .EQ. 1 (MEANING THE PROGRAM HAS ALREADY
C  OPENED AN INSTRUCTION FILE) THE NEXT LINE IN THE INSTRUCTION FILE HAS
C  THE VALUES FOR IRAN(I),I=1,NP. READ THIS LINE AND PRESENT THE INFO TO
C  THE USER.

        IF(INOPT .EQ. 1) THEN

        IF(ICODE .GE. 7) READ(23,*)
C  SKIP THIS LINE. IT CONTAINS 'IRAN INDICES' IF ICODE .GE. 7.
        
	 READ(23,*) (IRAN(I),I=1,NP)
	 WRITE(*,201)
  201    FORMAT(/' YOU HAVE SELECTED YOUR PARAMETERS TO BE RANDOM'/
     1' OR FIXED AS INDICATED BELOW. IF YOU WANT TO CHANGE THIS, YOU'/
     2' WILL HAVE TO RERUN THIS PROGRAM WITHOUT AN INSTRUCTION FILE'/
     3' SINCE THE REST OF THIS INSTRUCTION FILE (BOUNDARIES AND/OR'/
     4' FIXED VALUES WILL NOT BE COMPATIBLE WITH YOUR CHANGED '/
     5' DESIGNATIONS.'/)


	 CALL PAUSE


	 NVAR = 0
	 NOFIX = 0
	

	 DO I = 1,NP

	  IF(IRAN(I) .EQ. 1) THEN
	   TEMP = 'RANDOM'
	   NVAR = NVAR+1
	   PAR(NVAR) = PSYM(I)
	  ENDIF

	  IF(IRAN(I) .EQ. 0) THEN
	   TEMP = 'FIXED'

	   NOFIX = NOFIX + 1
	   PARFIX(NOFIX) = PSYM(I)
	  ENDIF

	  WRITE(*,202) PSYM(I),TEMP
  202     FORMAT(2X,A11,2X,A11)

	 END DO

  210	 WRITE(*,203)
  203    FORMAT(/' ENTER 1 IF THE ABOVE DESIGNATIONS ARE CORRECT;'/
     1' ENTER 0 OTHERWISE: ')
	 READ(*,*,ERR=210) ICORRECT
	 IF(ICORRECT .NE. 1 .AND. ICORRECT .NE. 0) GO TO 210
	 

	 IF(ICORRECT .EQ. 0) THEN



	  WRITE(*,204)
  204     FORMAT(//' PLEASE RERUN THE PROGRAM WITH KEYBOARD ENTRY.'/)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,204) 

        CLOSE(42)




        CALL PAUSE
	  STOP



	 ENDIF

C  IF NVAR .GT. MAXDIM, PRINT MESSAGE TO USER AND HAVE HIM TRY AGAIN.
C  SIMILARLY IF NOFIX .GT. 20, OR IF NVAR + NOFIX .GT. 32.



  	IF(NVAR .GT. MAXDIM) THEN



	 WRITE(*,207) NVAR,MAXDIM
  207    FORMAT(//' SOMEHOW, YOUR INSTRUCTION FILE HAS ',I2,/
     1' PARAMETERS DESIGNATED TO BE RANDOM VARIABLES. THE LIMIT IS '/
     2' CURRENTLY ',I2,'. PLEASE USE A CURRENT INSTRUCTION FILE OR'/
     3' RERUN THE PROGRAM WITH KEYBOARD ENTRY.'//)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,207) NVAR,MAXDIM
        CLOSE(42)




	 CALL PAUSE
	 STOP



	ENDIF

	IF(NOFIX .GT. 20) THEN



	 WRITE(*,208) NOFIX
  208    FORMAT(//' SOMEHOW, YOUR INSTRUCTION FILE HAS ',I2,/
     1' PARAMETERS DESIGNATED TO BE FIXED. THE LIMIT IS CURRENTLY 20.'/
     2' PLEASE USE A CURRENT INSTRUCTION FILE OR RERUN THE PROGRAM'/
     3' WITH KEYBOARD ENTRY.'//)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,208) NOFIX    
        CLOSE(42)




	 CALL PAUSE
	 STOP



	ENDIF

	IF(NVAR + NOFIX .GT. 32) THEN

	 WRITE(*,209) NVAR + NOFIX
  209    FORMAT(//' SOMEHOW, YOUR INSTRUCTION FILE HAS ',I2,' TOTAL'/
     1' PARAMETERS. THE LIMIT IS CURRENTLY 32. PLEASE USE A CURRENT '/
     2' INSTRUCTION FILE OR RERUN THE PROGRAM WITH KEYBOARD ENTRY.'//)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,209) NVAR + NOFIX
        CLOSE(42)



	 CALL PAUSE
	 STOP



	ENDIF


      IF(ICODE .GE. 9) READ(23,*)
C  SKIP THIS LINE. IT CONTAINS 'BOUNDARIES FOR RANDOM VARIABLES'

C  READ IN ILIMIT(I) FOR EACH RANDOM VARIABLE, AND THE CORRESPONDING

C  DESIRED BOUNDARIES FOR THAT R.V. NOTE THAT IF LIMIT(I) = 1, THE
C  CORRESPONDING BOUNDARIES (WHICH WILL BE = -99  -99), WILL NOT BE
C  USED. NOTE THAT IF ICODE < 7, ALL THE ILIMIT(.) VALUES WILL BE
C  DEFAULTED TO 1.


C  NOTE THAT THESE RESTRICTED BOUNDARIES MAY BE CHANGED BY THE USER 
C  WHEN SUBROUTINE VERIF1 IS CALLED.

       NVAR = 0

       DO I = 1,NP
        IF(IRAN(I) .EQ. 1) THEN
         NVAR = NVAR+1
         IF(ICODE .LE. 8) ILIMIT(NVAR) = 1
         IF(ICODE .GE. 9) READ(23,*) ILIMIT(NVAR),BOUND(NVAR,1),
     1    BOUND(NVAR,2)
        ENDIF
       END DO 


      ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(INOPT .EQ. 1) CONDITION.



C  THE CODE BELOW IS FOR THE INOPT .EQ. 0 CASE. 

	IF(INOPT .EQ. 0) THEN

C  NOW QUIZ THE USER TO SEE WHICH PARAMETERS ARE FIXED, AND WHICH ARE
C  RANDOM. 

C  SET IRAN(I) = 1 IF PSYM(I) = RANDOM;
C		 0 IF PSYM(I) = FIXED.

   80	WRITE(*,7) NP
    7   FORMAT(/' FOR EACH OF THE ',I2,' PARAMETERS, '//
     1' ENTER "R" IF IT IS TO BE A RANDOM VARIABLE;'/
     2' ENTER "F" IF IT IS TO BE A FIXED PARAMETER.'//)

	NVAR = 0
	NOFIX = 0

	DO I=1,NP

   8     FORMAT(1X,A11,':  ')
   60	 WRITE(*,8) PSYM(I)
	 READ(*,9) RR
    9    FORMAT(A1)
	 IF(RR .NE. 'R' .AND. RR .NE. 'r' .AND. RR .NE. 'F' 
     1      .AND. RR .NE. 'f') GO TO 60

	 IF(RR .EQ. 'R' .OR. RR .EQ. 'r') THEN


	  NVAR = NVAR+1
	  PAR(NVAR) = PSYM(I)
	  IRAN(I) = 1


  120 WRITE(*,119)
  119 FORMAT(/' ENTER 1 IF THE SIMULATED VALUES FOR THIS VARIABLE'/
     1'         WILL BE SOLELY DETERMINED BY THE PARAMETERS OF ITS'/
     2'         DISTRIBUTION (AS SPECIFIED BELOW);'/
     3' ENTER 0 IF THE SIMULATED VALUES FOR THIS VARIABLE WILL BE'/
     4'         DETERMINED BY THE PARAMETERS OF ITS DISTRIBUTION ...'/
     5'         SUBJECT TO THE ADDITIONAL CONTRAINT THAT THESE VALUES'/
     6'         BE WITHIN A SPECIFIED INTERVAL THAT YOU ENTER BELOW: '//
     7)
      READ(*,*,ERR=120) ILIMIT(NVAR)
      IF(ILIMIT(NVAR) .NE. 1 .AND. ILIMIT(NVAR) .NE. 0) GO TO 120



      IF(ILIMIT(NVAR) .EQ. 0) THEN

  130  WRITE(*,131)
  131  FORMAT(/' ENTER THE ALLOWABLE BOUNDS (LOWER,UPPER) FOR THE'/
     1' SIMULATED VALUES FOR THIS VARIABLE: ')
       READ(*,*,ERR=130) (BOUND(NVAR,J),J=1,2)

       IF(BOUND(NVAR,1) .GE. BOUND(NVAR,2)) THEN
        WRITE(*,132)
  132   FORMAT(/' THE LOWER BOUNDARY MUST BE < THE UPPER BOUNDARY.')
        GO TO 130
       ENDIF

      ENDIF



      ENDIF

C  THE ABOVE ENDIF IS FOR THE  
C   IF(RR .EQ. 'R' .OR. RR .EQ. 'r')  CONDITION.


	 IF(RR .EQ. 'F' .OR. RR .EQ. 'f') THEN
	  NOFIX = NOFIX+1
        PARFIX(NOFIX) = PSYM(I)
	  IRAN(I) = 0
	 ENDIF

	END DO

C  IF NVAR .GT. MAXDIM, PRINT MESSAGE TO USER AND HAVE HIM TRY AGAIN.
C  SIMILARLY IF NOFIX .GT. 20, OR IF NVAR + NOFIX .GT. 32.

  	IF(NVAR .GT. MAXDIM) THEN
	 WRITE(*,111) NVAR,MAXDIM
  111    FORMAT(//' YOU HAVE SELECTED ',I2,' PARAMETERS TO BE RANDOM'/
     1' VARIABLES. THE LIMIT IS CURRENTLY ',I2,'. PLEASE RESELECT YOUR'/
     2' RANDOM VARIABLES WITH THIS LIMIT IN MIND.'//)
	 GO TO 80
	ENDIF

	IF(NOFIX .GT. 20) THEN
	 WRITE(*,112) NOFIX
  112    FORMAT(//' YOU HAVE SELECTED ',I2,' PARAMETERS TO BE FIXED'/
     1' PARAMETERS. THE LIMIT IS CURRENTLY 20. PLEASE RESELECT YOUR'/
     2' RANDOM VARIABLES WITH THIS LIMIT IN MIND.'//)
	 GO TO 80
	ENDIF

	IF(NVAR + NOFIX .GT. 32) THEN



	 WRITE(*,113) NVAR + NOFIX
  113    FORMAT(//' YOUR MODEL FILE HAS A TOTAL OF ',I2,' PARAMETERS.'/
     1' THE LIMIT IS CURRENTLY 32. PLEASE EDIT YOUR MODEL FILE SO '/
     2' THAT IT HAS .LE. 32 PARAMETERS. '//)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,113) NVAR + NOFIX
        CLOSE(42)



	 CALL PAUSE
	 STOP



	ENDIF


	ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(INOPT .EQ. 0)  CONDITION.


C  THIS COMMENT CORRECTED IN MONTBIG9.FOR. FA IS NO LONGER 

C  NECESSARILY 1.0 (SEE INITCN22.FOR, THE TEMPLATE MODEL FILE).

	RETURN
	END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C  SIMBIG.FOR							4-02-04

C  SIMBIG IS A SIGNIFICANT VARIATION TO SIMALL. SIMALL WAS LINKED TO
C  MONTALL WHICH ALLOWED THE SIMULATION OF PATIENTS HAVING A 
C  3-COMPARTMENT LINEAR MODEL WITH ANY PARAMETERS FROM MENUS 1 OR 2 
C  (SEE COMMENTS BELOW), SIMBIG WILL BE A PART OF MONTBIG WHICH WILL
C  SIMULATE PATIENTS HAVING ANY MODEL WHICH CAN BE CODED INTO THE
C  THE USER-COMPLETED MODULE MONTMOD.FOR, WHICH HAS ROUTINES DIFFEQ, 
C  OUTPUT, AND SYMBOL (THIS MODULE MAY BE MADE BY A BOXES-TYPE PROGRAM 

C  IN THE FUTURE).

C  NEW SUBROUTINES INCLUDE IDCALCY, FUNC2, EVAL2 (FROM idm2x4.f),
C  USERANAL, JACOB (FROM idm1x4.f), ALL THOSE OF MODULE VODTOT.FOR 

C  AND MAKEVEC (FROM bigmlt5.f), SHIFT (FROM SHIFT5.F).

C  SUBROUTINES DELETED INCLUDE ANAL3,CASE1,CASE2,CASE3,CASE4,OUTPUT,
C  GETCOVAR, PRINTMENU, GETIND, PRINCOV, WRITDESC, PARNAM, PARNAM2, 

C  AND PARDEF.


C  SEVERAL DIMENSIONS HAVE BEEN CHANGED (E.G., YPRED IS NOW 2-DIM
C  RATHER THAN 1-DIM). COMMON STATEMENTS HAVE BEEN ADDED; OTHERS 
C  DELETED. 

C-----------------------------------------------------------------------


C  SIMALL.FOR							3-28-01


C  SIMALL HAS THE CHANGES TO SIM5CL TO MAKE IT COMPATIBLE WITH THE
C  MONTALL.FOR PROGRAM (SIM5CL IS PART OF THE MONT5CL.FOR PROGRAM).
C  THE CHANGE IS THAT INSTEAD OF THE PARAMETER SELECTION BEING LIMITED 
C  TO 5 PARAMETERS (CL,VS,KA,KCP,KPC), IT WILL NOW BE EXTENDED TO THE 
C  ENTIRE MENU LIST FROM MENUS 1 AND 2 OF THE LITTLE NPEM PROGRAMS.

C  THIS WILL REQUIRE THE SAME LOGIC AS IN LITTLE NPEM REGARDING THE
C  IDENTIFYING OF COVARIATE INFORMATION, AS WELL AS USING SUBROUTINE
C  PARDEF (CURRENTLY IN PARADP17.FOR).

C  NOTE THAT NPAR, NOFIX, NFIX, AND VALFIX WILL NO LONGER BE PASSED
C  TO SUBROUTINE SIMMN2 (SINCE THESE VALUES WILL BE PASSED DIRECTLY TO
C  SUBROUTINE PARDEF VIA COMMON/TOPAR).

C  NOTE THAT MODULES MOD4CL.FOR AND ANALAXLA.FOR HAVE BEEN REMOVED, AND

C  THEIR SUBROUTINES (OR VERSIONS THEREOF) HAVE BEEN RELOCATED INTO 
C  THIS MODULE (WHICH REPLACES SIM5CL.FOR).
  
C  NOTE THAT LOTS OF CODE PREVIOUSLY IN THE MAIN OF THIS MODULE HAS

C  BEEN RELOCATED TO IDCALCY AND THE ROUTINES IT CALLS. ALSO, THERE HAVE 

C  BEEN EXTENSIVE CHANGES (MOSTLY SIMPLIFICATIONS) IN SUBROUTINE INOUT.

C-----------------------------------------------------------------------

C  FOR COMMENTS ON PREVIOUS PROGRAMS, SEE SIMALL.FOR CODE.

C***********************************************************************

        SUBROUTINE SIMBIG(PREFIX,EXT,FILEIN,NSUB,NVAR,NOFIX,IRAN,VALFIX,
     1   C0,C1,C2,C3,IDIST,NGAUS,COF,AMEAN,COV,PATH,NDIM,PAR,
     2   IPRNPAT,ISEEDIND,ICSVFILE,OUTCSVNAME,OSname,DeleteFile,Listdir,
     3   ILIMIT,BOUND,INTLIST,RPAR,IPAR)

        use npag_utils, only : verifyval,makevec,max_pop_varbs,k_ig,i_ig

        IMPLICIT REAL*8(A-H,O-Z)

	PARAMETER(MAXNUMEQ=7)

        integer, dimension(128) :: INTLIST
        double precision, dimension(257) :: RPAR
        integer, dimension(257) :: IPAR

C wmy2019.03.12
      integer NRANFIX
      double precision, dimension(max_pop_varbs) :: RANFIXEST
C
C     NRANFIX and RANFIXEST are read in SUBROUTINE READNPAG;
C     but are not passed back to main. Also, MvG did not pass
C     them to MAKEVEC.
C
C TODO: Ability to pass NRANFIX and RANFIXEST back from READNPAG
C     to MAIN. Currently, we set NRANFIX and NRANFIXEST = 0 below,
C     as it will not be used in MAKEVEC.
C

        DIMENSION TIM(594),SIG(5000),Y(594,MAXNUMEQ),RS(5000,34),
     1   BS(5000,7),AMEAN(150,30),COV(150,30,30),ALF(594),
     2   AS(594,MAXNUMEQ),AMEANC(594),
     2   COVC(594,594),VALALF(100000,30),SAMMEN(30),SAMCOV(30,30),
     3   COF(150),YPRED(594,MAXNUMEQ),IRAN(32),AS1(594),PX(32),
     4   C0(MAXNUMEQ),C1(MAXNUMEQ),C2(MAXNUMEQ),C3(MAXNUMEQ),
     5   YPREDSUB(10000,594,MAXNUMEQ),YMEAN(594,MAXNUMEQ),
     1   YMIN(594,MAXNUMEQ),YMAX(594,MAXNUMEQ),YSD(594,MAXNUMEQ),
     2   Y025(594,MAXNUMEQ),Y25(594,MAXNUMEQ),Y50(594,MAXNUMEQ),
     3   Y75(594,MAXNUMEQ),Y975(594,MAXNUMEQ),ASUB(10000,594,MAXNUMEQ),
     3   XPRED(594,20),XPREDSUB(10000,594,20),SAMCOR(30,30),
     4   TIMORIG(594),ILIMIT(32),BOUND(32,2),OVERALF(100000,30),
     5   VALFIX(20),XVERIFY(900)

C  NOTE THAT AMEANC, COVC, AND ALF MUST HAVE DIMENSIONS OF 594 TO BE
C  COMPATIBLE WITH THEIR BEING CALLING ARGUMENTS TO SUBROUTINE GNRAT,
C  EVEN THOUGH THEY WILL CONTAIN NO MORE THAN NVAR ENTRIES IN EACH OF
C  THEIR DIMENSIONS.


	CHARACTER PREFIX*3,EXT*3,FILEIN*32,NUMBER(99999)*5,
     1   PATFIL*32,PATH*61,TMPFILE*32,PATHFILE*93,PATHFIL2*93,
     2   PATHFIL3*93,PAR(30)*11,CHARSUB*5,READBOT(99)*72,OUTCSVNAME*32,
     3   READBOTL*72,OSname*20,Deletefile*4,ListDir*10,ERRFIL*20


      COMMON/ERROR/ERRFIL
C  COMMON/ERROR/ IS SUPPLIED TO ALL THE ROUTINES WHICH COULD WRITE TO
C  ERRFIL.

	COMMON/OBSER/ TIM,SIG,RS,Y,BS
	COMMON/SUM2/ M,NPNL
        COMMON/CNST2/ NPL,NOS,NDRUG,NADD
	COMMON/COMAMT/XPRED
	COMMON/BOTPART/NBOTLINE,READBOT

C  COMMON/BOTPART IS PROVIDED FROM INOUT TO WRITE THE BOTTOM PART OF
C  THE WORKING COPY FILE TO EACH SIMULATED PATIENT DATA FILE.


C  CALL SUBROUTINE GETCHAR TO ESTABLISH THE NUMBER ARRAY.

	DO JSUB = 1,NSUB
	 CALL GETCHAR(JSUB,CHARSUB)
	 NUMBER(JSUB) = CHARSUB
	END DO


C*****INITIALIZE PROGRAM*****


C  FOR MONT101F.FOR, IJUMP IS REMOVED. SEE COMMENTS BELOW.


C  AS OF MONTBIG9.FOR, SEEDTO.MON IS ONLY ACCESSED IF ISEEDIND = 0.
C  OTHERWISE, THE INITIAL SEED NO., IDUM, IS SET = -17.

	IDUM = -17

	IF(ISEEDIND .EQ. 0) THEN

C  READ IDUM FROM THE FILE, 'SEEDTO.MON'

C  AS OF MONTBIG7.FOR, SEEDTO.MON IS NOW PART OF A BIGGER FILE WITH THE
C  PATH INCLUDED. 

C  CALL FULLNAME WHICH CONVERTS THE FILENAME TO PATHFILE, THE COMPLETE 
C  NAME OF THE FILE, WHICH INCLUDES THE PATH (IF THE PATH IS NOT THE 
C  CURRENT DIRECTORY).


        TMPFILE = ' '

	TMPFILE = 'SEEDTO.MON'
	CALL FULLNAME(PATH,TMPFILE,PATHFILE)

     	OPEN(25,FILE=PATHFILE,ERR=1200,STATUS='OLD')
	GO TO 1210
 1200   WRITE(*,1201)
 1201   FORMAT(/' PLEASE PUT THE SEED NO. FOR THE RANDOM NO. GENERATOR'/
     1' INTO THE TOP LINE OF THE FILE SEEDTO.MON, AND THEN RERUN THE '/
     2' PROGRAM.'//
     3' THE FILE, SEEDTO.MON, MUST BE IN THE SAME DIRECTORY AS THE'/
     4' WORKING DIRECTORY FOR THIS RUN. '//)
	WRITE(23,1201)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,1201) 
        CLOSE(42)



      CALL PAUSE
	STOP

 1210   READ(25,*) IDUM


C  REPLACE THE NO. IN 'SEEDTO.MON' BY IDUM-123

	JDUM = IDUM - 123
	BACKSPACE(25)
	WRITE(25,*) JDUM
	CLOSE(25)

	ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(ISEEDIND .EQ. 0)  CONDITION.



C  IDUM IS FED TO SUBROUTINES GNRAT AND NOSGEN, WHICH CALL RAN1 THE
C  UNIFORM [-1,1] GENERATOR. IT SHOULD BE INITIALIZED TO A NEGATIVE
C  NUMBER, BUT IS THEN, FOR EACH ADDITIONAL CALL, 1 (THIS TELLS RAN1
C  NOT TO REINITIALIZE).

C***********************************************************************

C  THE FOLOWING INFO WAS OBTAINED FROM THE USER, AND PASSED AS ARGUMENTS


C  FROM MONTALL/MAIN.

C  PREFIX+EXT WHICH DEFINES THE OUTPUT PATIENT FILENAMES (SEE BELOW). 


C  ICSVFILE = 0 IF THE DOSAGE REGIMEN AND OBSERVATION TIMES FOR THE
C               SIMULATED SUBJECTS WILL BE INPUT USING A (MULTIPLE DRUG)
C               WORKING COPY PATIENT DATA FILE.
C           = 1 IF THIS INFO WILL BE INPUT USING A .CSV FILE. IN THIS
C               CASE, THE INFO WILL BE TAKEN FROM THE FIRST SUBJECT'S

C               DATA IN THE .CSV FILE.

C  FILEIN = THE NAME OF THE FILE WHICH HAS THE PATIENT DOSAGE REGIMEN
C           AND OBS. TIMES. IF ICSVFILE = 0, IT WILL BE A (WORKING COPY)
C           PATIENT DATA FILE; IF ICSVFILE = 1, IT WILL BE A .CSV FILE.

C  NSUB = NO. OF SUBJECTS = NO. OF VECTORS (ALF(I),I=1,NVAR) TO BE 
C         GENERATED BELOW. (1 .LE. NSUB .LE. 999). 

C  NVAR = NO. OF VARIABLES FOR THIS SIMULATION.


C  C0(J),C1(J),C2(J),C3(J) = THE COEFFICIENTS FOR THE ASSAY STD. DEV. 
C   OF OUTPUT EQUATION J OF THE OUTPUT VALUES.

C  INFO ON THE DISTRIBUTION OF THE SUBJECT VECTORS TO BE GENERATED. 
C  ASSUME EACH SUBJECT VECTOR COMES FROM A GAUSSIAN MIXTURE (IF 
C  IDIST = 1) OR A LOGNORMAL MIXTURE (IF IDIST = 2). THIS MIXTURE WILL
C  BE SUM[COF(I)*D(I)], I=1,NGAUS, WHERE THE SUM OF THE   
C  COEFFICIENTS, COF(I), IS 1.0, AND EACH D(I) IS AN NVAR-VARIATE NORMAL
C  OR LOGNORMAL DISTRIBUTION.

C  SO THE USER ENTERED NGAUS, COF(I), I=1,NGAUS, AND NGAUS SETS OF
C  MEAN VECTORS, AMEAN(I,J), J=1,NVAR, I=1,NGAUS; AND COVARIANCE 
C  MATRICES, COV(I,J,K), K=1,J, J=1,NVAR, I=1,NGAUS.

C  AS OF MONT107.FOR, THE IDIST = 0 CASE --> SUBJECT I WILL HAVE EXACTLY
C  THE PARAMETER VALUES IN THE CORRESPONDING MEAN VECTOR AND, OF COURSE,
C  THE NO. OF SUBJECTS SIMULATED WILL BE = NGAUS, THE NO. OF GRID PTS.
C  IN THE INPUT NPAG OUTPUT FILE.


C  THE FOLLOWING IS OUTPUT BY THE PROGRAM:

C  FOR EACH OF THE NSUB PATIENTS:

C      ALF(I),I=1,NVAR, THE GENERATED PARAMETER VALUES. 
C      AS(J,K), J=1,M; K=1,NOS = THE N(0,1) VALUES USED IN 
C             ESTABLISHING THE ASSAY NOISE VALUES (M = NO. OF 
C             OBSERVATION TIMES; K= NO. OF OUTPUT EQUATIONS; THEY ARE
C             READ IN VIA SUBROUTINE INOUT). 
C      YPRED(J,K),J=1,M; K=1,NOS = THE OUTPUT CONCENTRATIONS (WHICH 
C             HAVE BEEN 'CORRUPTED' WITH THE ASSAY NOISE).
C      SIMULATED AMOUNTS IN ALL COMPARTMENTS.

C      SUMMARY STATISTICS ON THE PARAMETERS (ALF) AND THE CONCENTRATIONS
C             (YPRED).

C***********************************************************************

C  THE OUTPUT FILE (FILE 23) HAS ALREADY BEEN OPENED IN MAIN AND FILLED 
C  WITH THE USER-INPUT INSTRUCTIONS AT THE TOP. WRITE IDUM TO THIS FILE,
C  AND LEAVE IT OPEN (IT WILL BE FILLED WITH ALL THE SIMULATED VALUES
C  AS THEY ARE GENERATED).


     	WRITE(23,1202) IDUM
 1202   FORMAT(I9,' <-- SEED NO. FOR THE FOLLOWING SIMULATION. '/)


C  IF ICSVFILE = 0, FILEIN IS THE WORKING COPY FILE FROM WHICH THE
C   DOSAGE AND OBS. TIME INFO TO BE USED IN THE SIMULATIONS WILL BE 
C   READ.

C  IF ICSVFILE = 1, 'XQZPJ001.ZMQ' WAS CREATED IN MAIN TO BE THE WORKING
C   COPY FILE FROM WHICH THE DOSAGE AND OBS. TIME INFO TO BE USED IN THE
C   SIMULATIONS WILL BE READ.

        IF(ICSVFILE .EQ. 0) TMPFILE = FILEIN
        IF(ICSVFILE .EQ. 1) TMPFILE = 'XQZPJ001.ZMQ'

C  CONVERT FILEIN TO PATHFIL2, WHICH WILL INCLUDE THE PATH.
	
	 CALL FULLNAME(PATH,TMPFILE,PATHFIL2)

C  THE FILES TO BE MADE DEPEND ON IPRNPAT AS FOLLOWS:


C  IF IPRNPAT .GE. 1 --> MAKE WORKING COPY PATIENT FILES.
C   IPRNPAT .EQ. 1 --> CONVERT THESE PATIENT FILES TO BLOCK FORMAT
C                      INFO AND PUT INTO OUTCSVNAME.
C                      THEN, DELETE WORKING COPY PATIENT FILES.
C   IF IPRNPAT .EQ. 2 --> NOTHING ELSE TO BE DONE.
C   IF IPRNPAT .EQ. 3 --> CONVERT THESE PATIENTS TO BLOCK FORMAT INFO
C                         AND PUT INTO OUTCSVNAME.

C  BUT NOTE THAT IF IPRNPAT = 1, CHANGE PREFIX AND EXT FROM
C  WHATEVER THEY WERE BEFORE (THEY COULD HAVE BEEN READ IN IF
C  IPRNPAT WAS ORIGINALLY 2 OR 3 IN THE INSTRUCTION FILE) TO
C  PREFIX = '7Q9' AND EXT = 'Z3Q'. THE CHANCES THAT
C  THESE WOULD MATCH OTHER FILENAMES ARE 1/36^6 < 1 OUT OF 2 BILLION.
C  OTHERWISE, THERE IS A CHANCE THAT PATIENT DATA FILES WHICH
C  ALREADY EXIST WITH THE SAME NAME WILL BE OVERWRITTEN, AND 
C  THEN ERASED.

        IF(IPRNPAT .EQ. 1) THEN
         PREFIX = '7Q9'
         EXT = 'Z3Q'
        ENDIF
 
C  GENERATE NSUB PATIENT DATA FILES IF IPRNPAT .GE. 1.


C  INITIALIZE ITOTSETS = 0. THIS WILL BE THE RUNNING NO. OF TOTAL
C  PARAMETER SETS SIMULATED BELOW. IF EVERY PARAMETER SET HAS ALL ITS
C  PARAMETER VALUES WITHIN THE REQUIRED BOUNDARIES (SEE CODE/COMMENTS
C  AROUND THE GO TO 9800 STATEMENT BELOW), THEN ITOTSETS WILL BE THE
C  SAME AS NSUB AT THE END OF THE 9900 LOOP. BUT IF SOME PARAMETER SETS
C  HAVE PARAMETER VALUES OUTSIDE THEIR REQUIRED BOUNDARIES, ITOTSETS

C  WILL END UP BEING > NSUB.

        ITOTSETS = 0


        DO 9900 ISUB = 1,NSUB

	 IF(IPRNPAT .GE. 1) THEN
	  PATFIL=PREFIX//NUMBER(ISUB)//'.'//EXT
	  TMPFILE = PATFIL
	  CALL FULLNAME(PATH,TMPFILE,PATHFIL3)
	 ENDIF

C  AS OF MONT101F.FOR, INOUT WILL BE CALLED FOR EVERY SUBJECT, SINCE
C  IT IS NECESSARY TO RESET THE VALUES IN COMMON/OBSER IN THE CASE
C  WHERE PATHFIL2 CONTAINS STEADY STATE DOSE SETS. I.E., IN THIS CASE,
C  SUBROUTINE NEWWORK1 MUST ALTER THE DOSAGE BLOCK AND OBS. TIMES
C  TO BE WHAT IS EXPECTED BY SUBROUTINE FUNC2. BUT THE ORIGINAL
C  DOSAGE BLOCK AND OBS. TIMES ARE WHAT MUST BE WRITTEN TO EACH
C  SIMULATED PATIENT FILE.

         CALL INOUT(ISUB,PATHFIL2,PATHFIL3,IPRNPAT,TIMORIG,
     1     INTLIST,RPAR,IPAR)

C  OBTAIN THE PARAMETER VALUES FOR THIS SUBJECT'S SIMULATION, ALF(I),
C  I=1,NVAR. ALF HAS A GAUSSIAN (IF IDIST = 1) OR A LOGNORMAL 
C  (IF IDIST = 2) MIXTURE DIST. EACH PARAMETER HAS PROBABILITY COF(I) 
C  OF HAVING MEAN=AMEAN(I,.) AND COVARIANCE COV(I,.,.).
C  NOTE: SUM(COF(I))=1, OF COURSE.

C  AS OF MONT107.FOR, THE NEW IDIST = 0 OPTION --> ALF(I) WILL BE 
C  EXACTLY AMEAN(ISUB,I). SET THESE VALUES AND THEN GO IMMEDIATELY TO
C  LABEL 6510. NOTE THAT IF IDIST = 0, NSUB WAS SET = NGAUS IN MAIN,
C  AND SO AMEAN(ISUB,.) CONTAINS THE EXACT PARAMETER VALUES FOR THIS
C  SUBJECT. AMEAN(.,.) VALUES WERE SET IN SUBROUTINE READNPAG.
 

        IF(IDIST .EQ. 0) THEN

         DO I = 1,NVAR
          ALF(I) = AMEAN(ISUB,I)
         END DO
         GO TO 6510
        ENDIF



C  1ST, SELECT A UNIFORM RANDOM VARIABLE INSIDE [0,1]. THE SEED NO. 
C  (IDUM) FOR THE RANDOM NUMBER GENERATOR (RAN1) HAS ALREADY BEEN 
C  INITIALIZED AS A NEGATIVE NO AS REQUIRED. 

 9800   ZRAN=RAN1(IDUM)

C wmy20190410 -- not sure why only 1 of 4 distributions in mixture is
C  ever used:
       write (*,*) "ZRAN=",ZRAN


C  ZRAN IS THE PROPORTIONAL DISTANCE BETWEEN 0 AND 1 FOR THIS UNIFORM 
C  RANDOM VARIABLE. SELECT THE GAUSSIAN MIXTURE COMPONENT WHICH
C  CORRESPONDS TO THIS PROPORTION ...
C  (E.G., IF NGAUS=4 AND COF(I)=.25 FOR I=1,2,3,4, THEN SELECT THE 1ST
C  COMPONENT IF ZRAN IS IN [0,.25], THE 2ND COMPONENT IF ZRAN IS IN
C  [.25,.50], ETC.

        STRTIN=0.D0

        DO IGAUS = 1,NGAUS

         ENDIN = STRTIN + COF(IGAUS)

C  INTERVAL IGAUS IS [STRTIN,ENDIN].

         IF(ZRAN .GE. STRTIN .AND. ZRAN .LE. ENDIN) THEN
          ICOMP=IGAUS
          GO TO 5060
         ENDIF

C  UPDATE STRTIN FOR THE NEXT COMPONENT, AND CONTINUE CHECKING.

         STRTIN = ENDIN

        END DO

C  THE ABOVE END DO IS FOR THE  DO IGAUS = 1,NGAUS  LOOP.

C  NOW, CALL GNRAT TO GET ALF(I), I=1,NVAR, WHICH IS GENERATED FROM A
C  DIST, WITH MEAN=AMEAN(ICOMP,.) AND LOWER-TRI COV = COV(ICOMP,.,.),
C  WHERE THE DISTRIBUTION IS NORMAL IF IDIST = 1, AND LOGNORMAL IF
C  IDIST = 2.

 5060    DO I=1,NVAR
          AMEANC(I) = AMEAN(ICOMP,I)
          DO J=1,I
  	   COVC(I,J) = COV(ICOMP,I,J)
	  END DO
	 END DO

C  IF IDIST = 1, AMEANC AND COVC ALREADY CONTAIN THE MEAN AND COV.
C  MATRIX DESIRED. IF IDIST = 2, MUST CONVERT THE DESIRED LOGNORMAL
C  MEANS AND COVARIANCES INTO THE CORRESPONDING MEANS AND COVARIANCES 
C  FOR A NORMAL DIST.


	IF(IDIST .EQ. 2) THEN

	 DO I=1,NVAR
	  DO J=1,NVAR
	   COVC(I,J) = DLOG(COVC(I,J)/AMEANC(I)/AMEANC(J)+1.D0)
	  END DO 
	 END DO

C  COVC(.,.,.) NOW HAS THE COV. VALUES FOR THE NORMAL DISTRIBUTION 
C  WHICH CORRESPONDS TO THE DESIRED LOGNORMAL DISTRIBUTION.

	 DO I=1,NVAR
	  AMEANC(I) = DLOG(AMEANC(I)) - COVC(I,I)/2.D0
	 END DO

C  AMEANC(.,.) NOW HAS THE MEAN VALUES FOR THE NORMAL DISTRIBUTION 
C  WHICH CORRESPONDS TO THE DESIRED LOGNORMAL DISTRIBUTION.

	ENDIF


	 CALL GNRAT(NVAR,AMEANC,COVC,ALF,IDUM)

C  STORE THESE PARAMETER VALUES INTO VALALF, SO THE SAMPLE MEANS AND
C  COVARIANCES CAN BE CALCULATED LATER. BUT NOTE THAT ALF ARE THE
C  PARAMETER VALUES ONLY IF IDIST = 1. IF IDIST = 2, MUST CONVERT
C  ALF, WHICH ARE NORMAL VALUES, TO LOGNORMAL VALUES.

	 IF(IDIST .EQ. 2) THEN
	  DO I = 1,NVAR
	   ALF(I) = DEXP(ALF(I))
	  END DO
	 ENDIF

C  TEST THAT EACH ALF(I) IS WITHIN ITS REQUIRED BOUNDARIES ... IF
C  ITS ILIMIT(I) = 0 (OTHERWISE ALF(I) IS UNRESTRICTED).

      IOK = 1
      DO I = 1,NVAR
       IF(ILIMIT(I) .EQ. 0) THEN
        IF(ALF(I) .LT. BOUND(I,1) .OR. ALF(I) .GT. BOUND(I,2)) then
           IOK = 0

C wmy20190801 -- debug
        ELSE
           write (*,*) ISUB,"broke bound",I,ALF

        ENDIF
       ENDIF
      END DO


 6510  CONTINUE

C  6510 IS WHERE CONTROL IS TRANSFERRED FROM ABOVE IF IDIST = 0, SINCE
C  IN THAT CASE, ALF(I) WAS SET EXACTLY = AMEAN(ISUB,I), I=1,NVAR,
C  ABOVE.


C  STORE THIS ALF(.) VECTOR INTO THE OVERALL ARRAY OF PARAMETER SETS,
C  OVERALF. BUT DO NOT STORE IT INTO THE ARRAY VALALF, WHICH IS 
C  RESERVED FOR THOSE PARAMETER SETS THAT RESULT IN SIMULATED SUBJECTS,
C  UNLESS IOK = 1 (I.E., UNLESS ALL PARAMETER VALUES ARE WITHIN THEIR
C  REQUIRED BOUNDARIES). 

C  SO, IF IOK = 1, CONTINUE TO SIMULATES A SUBJECT. BUT IF IOK = 0,
C  RETURN TO LABEL 9800 TO GET THE NEXT PARAMETER SET CANDIDATE.


      ITOTSETS = ITOTSETS + 1

C  CHECK THAT ITOTSETS IS STILL WITHIN THE ALLOWED MAXIMUM. IF NOT,
C  WRITE STATEMENT TO THE USER AND STOP.

      IF(ITOTSETS .GT. 100000) THEN



       WRITE(*,9801) NSUB
 9801  FORMAT(//' BECAUSE OF THE BOUNDARY RESTRICTIONS ON PARAMETER'/
     1' VALUES, THE DESIRED NO. OF SUBJECTS, ',I6,', COULD NOT BE '/
     2' SIMULATED BEFORE THE MAXIMUM NO. OF SIMULATED PARAMETER SETS,'/
     3' 100000, WAS REACHED.'//
     4' THE PROGRAM STOPS.'//
     5' PLEASE RERUN THE PROGRAM WITH LESS RESTRICTIVE BOUNDARIES.'//)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,9801) NSUB  
        CLOSE(42)

       CALL PAUSE
       STOP



      ENDIF


      DO I = 1,NVAR
       OVERALF(ITOTSETS,I)=ALF(I)
      END DO

      IF(IOK .EQ. 0) GO TO 9800

C  TO GET HERE --> IOK = 1 --> STORE THIS PARAMETER SET INTO VALALF,
C  AND CONTINUE TO SIMULATE SUBJECT ISUB.

       DO I=1,NVAR
        VALALF(ISUB,I)=ALF(I)
       END DO


	 IF(IPRNPAT .GE. 1) WRITE(*,9009) ISUB

 9009    FORMAT(' SIMULATING SUBJECT NO. ',I7)


	 IF(IPRNPAT .EQ. 0) WRITE(*,9019) ISUB
 9019    FORMAT(' SUBJECT NO. ',I7)


C  OBTAIN THE ASSAY NOISE VALUES FOR THIS SUBJECT. CALL NOSGEN TO 
C  GET A NORMAL VECTOR OF LENGTH M, WITH MEAN = 0 VECTOR, AND COV. 
C  MATRIX = THE IDENTITY MATRIX. THIS VECTOR IS AS1(I),I=1,M. ASSIGN 
C  THESE VALUES TO AS(I,1). THEN REPEAT THIS STEP FOR EACH OF THE 
C  OUTPUT EQUATIONS J=1,NOS.

	 DO J=1,NOS
	  CALL NOSGEN(M,1.D0,IDUM,AS1)
	   DO I=1,M
	    AS(I,J) = AS1(I)
	    ASUB(ISUB,I,J) = AS(I,J)
	   END DO
	 END DO

C wmy2019.02.14
C         write (*,*) "passed NOSGEN, INTLIST(10)=",INTLIST(10)
C         write (*,*) "CHECK INTLIST",INTLIST

C  BEFORE CALLING IDCALCY TO HAVE IT CALCULATE PREDICTED VALUES,
C  MUST MAKE SURE THE CORRECT DOSAGE REGIMEN AND OUTPUT TIMES, ETC. ARE
C  STORED INTO THE ARRAYS IN COMMON/OBSER. THESE MUST BE THE ARRAYS IN 
C  THE WORKING COPY FILE CONVERTED FROM PATHFIL2 BY SUBROUTINE NEWWORK1 
C  (I.E., SUBROUTINE FUNC2 IS CODED TO WORK ON WORKING COPY FILES
C  AFTER THEY HAVE BEEN RUN THROUGH NEWWORK1). SO CALL NEWWORK1 TO 
C  CONVERT FILE PATHFIL2 (WHICH WILL BE OPENED BELOW AS FILE 31) TO
C  SCRATCH FILE 41, AND THEN CALL SUBROUTINE STOREOBSER TO READ
C  FILE 41 SO THAT THE PROPER ARRAY VALUES CAN BE STORED INTO 
C  COMMON/OBSER.

	OPEN(31,FILE=PATHFIL2,STATUS='OLD')

C  CALL SUBROUTINE NEWWORK1 TO CONVERT FILE 31 TO FILE 41 (BASED ON THE
C  STAND-A-LONE PROGRAM OF THE SAME NAME). NOTE THAT IF FILE 31 HAS NO
C  STEADY STATE DOSE INDICATORS, FILE 41 WILL = FILE 31; IF IT DOES, 
C  FILE 41 WILL BE ALTERED TO INCLUDE AN EXTRA 101 DOSES SETS FOR EACH
C  STEADY STATE DOSE INDICATOR. NOTE THAT, UNLIKE IN THE STAND-A-LONE
C  PROGRAM, SUBROUTINE NEWWORK1 WILL LEAVE IN THE NEGATIVE DOSE TIME 
C  (WHICH IS THE STEADY STATE DOSE INDICATOR) BECAUSE THE ID ROUTINE
C  IN THIS PROGRAM (FUNC2) NEEDS TO SEE THIS INDICATOR TO KNOW THAT A
C  STEADY STATE DOSE SET IS COMING.

       OPEN(41)
 
       CALL NEWWORK1 

C  NOTE THAT NEWWORK1 CLOSE FILES 31.
	  
       REWIND(41)


       CALL STOREOBSER(INTLIST)

C  NOTE THAT STOREOBSER CLOSES FILE 41.


C  CALL SUBROUTINE IDCALCY, A VERSION OF THE ID PROGRAM WHICH SIMPLY
C  CALCULATES THE PREDICTED VALUES OF YO(I,J) = OUTPUT CONCENTRATION OF
C  THE JTH OUTPUT EQUATION (J=1,NUMEQT) AT THE ITH OBSERVATION TIME
C  (I=1,NOBSER), ASSUMING THE PARAMETER VECTOR ALF ... BUT
C  BEFORE ALL CALLS TO IDCALCY, MUST INTEGRATE FIXED AND RANDOM
C  VALUES INTO PX, USING IRAN(I),I=1,NVAR+NOFIX. CALL MAKEVEC TO DO
C  THIS.

C wmy2019.02.14
C         write (*,*) "Calling MAKEVEC"

C wmy2019.03.12 -- Original Call:
C         CALL MAKEVEC(NVAR,NOFIX,IRAN,ALF,VALFIX,PX)
C ... is replaced by:
         NRANFIX = 0
         do I=1,max_pop_varbs
           RANFIXEST(I) = 0.D0
         end do
         CALL MAKEVEC(NVAR,NOFIX,NRANFIX,IRAN,ALF,VALFIX,RANFIXEST,PX)
C Above is validated by printing out and checking old call vs. new
C   call in write statement below:
C wmy2019.02.14
         write (*,*) "Calling IDCALCY,PX=",PX(1),PX(2),PX(3),PX(4)

C         RPAR(k_jsub) = ??? simout file number, I think.
         RPAR(k_ig) = dble(ISUB)
         IPAR(i_ig) = ISUB

	 CALL IDCALCY(NVAR+NOFIX,NDIM,PX,YPRED,IDUM,
     1     INTLIST,RPAR,IPAR)

c wmy2019.02.14
C         write (*,*) "Returned from IDCALCY; YPRED=", YPRED 

C*****OUTPUT RESULTS*****


C  THE GENERATED 'TRUE' OUTPUT VALUES (YPRED, OBTAINED FROM THE CALL
C  TO IDCALCY ABOVE) ARE TO BE 'CORRUPTED' WITH ASSAY NOISE. IN 
C  PARTICULAR, WITH YPRED(I,J) = Y(I,J):
C  FOR I=1,M; J=1,NOS, SET Y(I,J)=Y(I,J)+E(I,J), WHERE 
C  E(I,J)--N(0,STDIJ**2), WHERE
C  STDIJ = C0(J) + C1(J)*Y(I,J) + C2(J)*Y(I,J)**2 + C3(J)*Y(I,J)**3. 
C  SO E(I,J)=STDIJ*AS(I,J),
C  WHERE AS(I,J)--IID--N(0,1) WAS OBTAINED ABOVE FOR THIS SUBJECT.

C  ... EXCEPT NOTE THAT IN MONTBIG5.FOR, ANY YPRED(I,J) WHICH IS
C  SIMULATED TO BE < 0 IS REPLACED BY THE FIXED VALUE, 1.D-8.
C  AND, AS OF MONT100.FOR, ANY PREDICTED VALUE THAT IS LESS THAN
C  1.D-8 IS REPLACED BY 1.D-8. OTHERWISE, E.G., 1.D-123 GETS WRITTEN
C  AS .1-122 = -121.9.


C  STORE THESE PREDICTED VALUES YPREDSUB, SO THE SAMPLE MEANS, MEDIANS,
C  MINIMUMS, MAXIMUMS, S.D.'s, AND PERCENTILES CAN BE CALCULATED LATER.

C  AS OF MONTBIG7.FOR:
C  NOTE THAT Y(I,J) IS THE OBSERVED VALUE IN THE WORKING COPY FILE
C  SUPPLIED TO THIS PROGRAM. IF IT IS .LE. -99, THE CORRESPONDING 
C  SIMULATED VALUE SHOULD BE SET = -99 (I.E., IT WILL BE A MISSING 
C  VALUE).

	DO J=1,NOS
	 DO I=1,M
          STDIJ=C0(J) + C1(J)*YPRED(I,J) + C2(J)*YPRED(I,J)**2 + 
     1          C3(J)*YPRED(I,J)**3 
 	  YPRED(I,J)=YPRED(I,J)+AS(I,J)*STDIJ
	  IF(YPRED(I,J) .LE. 1.D-8) YPRED(I,J) = 1.D-8
	  IF(Y(I,J) .LE. -99.D0) YPRED(I,J) = -99.D0
	  YPREDSUB(ISUB,I,J) = YPRED(I,J)
	 END DO
	END DO

C  NOTE: IN THE POPULATION PROGRAMS WHICH ANALYZE THE DATA GENERATED BY 
C        THIS PROGRAM, THE ABOVE 'OBSERVED' (ALREADY NOISY) OUTPUTS WILL 
C        HAVE MORE NOISE ADDED. THIS IS A SLIGHT INCONSISTENCY.

C  STORE THE COMPARTMENT AMOUNTS FOR THIS SUBJECT. THEY WERE PASSED
C  IN COMMON TO THIS ROUTINE VIA COMMON/COMAMT FROM SUBROUTINE
C  FUNC2. 

C  BUT AS OF MONT109.FOR, ANY COMPARTMENT AMOUNT WHICH IS SIMULATED TO
C  BE < 1.D-8 IS REPLACED BY 1.D-8. OTHERWISE, E.G., 1.D-123 GETS
C  WRITTEN TO THE OUTPUT FILE AS .1-122 = -121.9. THIS IS SIMILAR TO 
C  THE CODE FOR THE PREDICTED VALUES ABOVE, WHICH WAS PUT IN BACK
C  IN MONT100.FOR.


C  NDIM = -1 --> 3 ANALYTIC SOLNS. FOR THE LINEAR 3-COMP. MODEL. IN THIS
C  CASE, THE DO LOOP BELOW IS OVER 1 TO 3.

        NNN = NDIM
        IF(NDIM .EQ. -1) NNN = 3

         DO ICOMPART = 1,NNN
          DO I = 1,M
           XPP = XPRED(I,ICOMPART)
           IF(XPP .LE. 1.D-8) XPP = 1.D-8
           XPREDSUB(ISUB,I,ICOMPART) = XPP
          END DO
         END DO

C  WRITE OBSERVATIONS TO PATIENT DATA FILE.

	 IF(IPRNPAT .GE. 1) THEN

C  REPLACE WRITING OF TIMORIG(),YPRED() WITH XVERIFY (SEE LOGIC IN 
C  SUBROUTINE VERIFYVAL).

        DO I = 1,M

         XVERIFY(1) = TIMORIG(I)

         DO J = 1,NOS
          XVERIFY(1+J) = YPRED(I,J)
         END DO
         CALL VERIFYVAL(1+NOS,XVERIFY) 
     
C	   WRITE(21,245) TIMORIG(I),(YPRED(I,J),J=1,NOS)
         WRITE(21,245) (XVERIFY(IXV),IXV=1,1+NOS)

        END DO

C  NOTE THAT AS OF MONT101F.FOR, TIMORIG(.) IS WRITTEN ABOVE, RATHER
C  THAN TIM. THIS IS BECAUSE TIMORIG(.) ARE THE ORIGINAL TIMES IN
C  PATHFIL2. IF THERE ARE STEADY STATE DOSE SETS, SUBROUTINE NEWWORK1
C  ABOVE WILL HAVE ALTERED THE TIM(.) VALUES, AND THE DOSAGE REGIMEN
C  TO BE WHAT SUBROUTINE FUNC2 EXPECTS. BUT THE TIME VALUES TO BE 
C  PUT INTO THE SIMULATED SUBJECTS MUST BE THE ORIGINAL ONES.

245       FORMAT(' ',F14.7,21(',',G14.7))


C----------------- WRITE THE BOTTOM OF FILE BELOW ----------------------

C  WRITE THE NBOTLINE LINES IN READBOT. THIS IS THE BOTTOM PART OF THE
C  WORKING COPY FILE, WHICH CONTAINS THE COV. NAMES, AND THE ASSAY
C  COEFFICIENT LINE(S).

C  NOTE THAT THE LINE(S) BELOW THE LINE THAT STARTS WITH


C  'ASSAY COEFFICIENTS' MAY CONTAIN NO ASSAY COEFFICIENTS (WHICH IS
C  THE CASE IF THE TEMPLATE WORKING COPY FILE DID NOT CONTAIN THEM), OR
C  THEY MAY NOT BE THE ONES USED ABOVE IN SIMULATING THE DATA FILES.

C  EITHER WAY, REPLACE THESE LINES WITH LINES WHICH HAVE THE ASSAY C'S
C  THAT WERE USED ABOVE.



        DO I = 1,NBOTLINE
         READBOTL = READBOT(I)
         IF(READBOTL(1:18) .EQ. 'ASSAY COEFFICIENTS') GO TO 9105
         WRITE(21,303) READBOT(I)
        END DO


  303    FORMAT(A72)

 9105   CONTINUE

C  TO GET HERE MEANS THAT ONLY THE ASSAY C'S ARE LEFT TO WRITE.


        READBOTL = 'ASSAY COEFFICIENTS FOLLOW, ONE SET FOR EACH OUTPUT E
     1QUATION:'            


        WRITE(21,303) READBOTL
        
C  REPLACE WRITING OF C0(),...,C3() WITH XVERIFY (SEE LOGIC IN 
C  SUBROUTINE VERIFYVAL.

        DO IEQ = 1,NOS
         XVERIFY(1) = C0(IEQ)
         XVERIFY(2) = C1(IEQ)
         XVERIFY(3) = C2(IEQ)


         XVERIFY(4) = C3(IEQ)
         CALL VERIFYVAL(4,XVERIFY)
C        WRITE(21,9106) C0(IEQ),C1(IEQ),C2(IEQ),C3(IEQ)
         WRITE(21,9106) (XVERIFY(IXV),IXV=1,4)
 9106    FORMAT(1X,4(G14.7,2X))
        END DO

C----------------- WRITE THE BOTTOM OF FILE ABOVE ----------------------

	  CLOSE(21)


	 ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(IPRNPAT .GE. 1)  CONDITION.




 9900   CONTINUE


C  IF IPRNPAT .GE. 1, NSUB PATIENT FILES HAVE NOW BEEN CREATED.
C  IF IPRNPAT = 1 OR 3, CALL SUBROUTINE WORKTOCSV, WHICH
C  IS BASED ON THE STAND-A-LONE PROGRAM, WORKCSV, TO WRITE ALL THE
C  SUBJECT INFO INTO THE STANDARD .CSV BLOCK FORMAT, AND PUT IT INTO
C  FILE OUTCSVNAME.

        IF(IPRNPAT .EQ. 1 .OR. IPRNPAT .EQ. 3) 
     1   CALL WORKTOCSV(NSUB,PATH,PREFIX,EXT,OUTCSVNAME,
     2     INTLIST)

C  IF IPRNPAT = 1, DELETE THE NSUB WORKING COPY FILES CREATED IN
C  LOOP 9900 ABOVE.

        IF(IPRNPAT .EQ. 1) THEN
         DO ISUB=1,NSUB
          PATFIL=PREFIX//NUMBER(ISUB)//'.'//EXT
          TMPFILE = PATFIL
          CALL FULLNAME(PATH,TMPFILE,PATHFIL3)
C          CALL SYSTEM('DEL '//PATHFIL3)
          CALL SYSTEM(DeleteFile//PATHFIL3)
         END DO
        ENDIF




C  WRITE ALL THE OUTPUT INFO. TO FILE 23 IN "BLOCK" FORMAT.

C  AS OF MONTBIG6.FOR, ONLY WRITE THE VALUES FOR THE FIRST 10000
C  SUBJECTS (I.E., IF NSUB > 10000, ONLY THE 1ST 10000 SUBJECTS HAVE 
C  THEIR VALUES WRITTEN). SAME FOR THE OTHER BLOCKS OF INFO BELOW.
C  ... ACTUALLY, I HAVE CHANGED THE MAXIMUM VALUE OF NSUB TO BE 10000,
C  SO IN THE CODE BELOW, NWRITE WILL ALWAYS = NSUB.


	NWRITE = NSUB
	IF(NSUB .GT. 10000) NWRITE = 10000


	IF(NSUB .GT. 10000) WRITE(23,6013)
 6013   FORMAT(//' THE FOLLOWING 10000 LINES HAVE THE SIMULATED '/
     1' PARAMETER VALUES FOR THE FIRST 10000 SUBJECTS ONLY.'//
     2' SIMILARLY, ALL THE BLOCKS BELOW WILL HAVE VALUES ONLY FOR'/
     3' THE FIRST 10000 SUBJECTS.')
   
	IF(NSUB .LE. 10000) WRITE(23,7013) NSUB

 7013   FORMAT(//' THE FOLLOWING ',I7,' LINES HAVE THE SIMULATED '/
     1' PARAMETER VALUES FOR ALL THE SUBJECTS.')

	WRITE(23,7006) (PAR(J),J=1,NVAR)
 7006   FORMAT(/' SUBJ.    ',30(A12,3X))


C  REPLACE WRITING OF VALALF() WITH XVERIFY (SEE LOGIC IN 
C  SUBROUTINE VERIFYVAL.

      DO ISUB = 1,NWRITE
       DO J=1,NVAR
        XVERIFY(J) = VALALF(ISUB,J)
       END DO
       CALL VERIFYVAL(NVAR,XVERIFY)
C      WRITE(23,7007) ISUB, (VALALF(ISUB,J),J=1,NVAR)
       WRITE(23,7007) ISUB, (XVERIFY(J),J=1,NVAR)
      END DO

 7007   FORMAT(I6,1X,200(G14.7,1X))

	WRITE(23,7014) NOS,M
 7014   FORMAT(//' THE FOLLOWING ',I2,' BLOCK(S) CONTAIN THE SIMULATED A
     1SSAY'/
     2' NOISE FOR EACH OUTPUT EQUATION. EACH BLOCK HAS THE NOISE FOR'/
     3' THE ',I4,' OBSERVED VALUES FOR EACH SUBJECT ON ONE LINE.'/)

	WRITE(23,7009)
 7009   FORMAT(/'        <---- OBSERVATION TIMES ... ')

C  REPLACE WRITING OF TIMORIG() WITH XVERIFY (SEE LOGIC IN 
C  SUBROUTINE VERIFYVAL.

       DO I=1,M
        XVERIFY(I) = TIMORIG(I)
       END DO
       CALL VERIFYVAL(M,XVERIFY)
C	 WRITE(23,7008) (TIMORIG(I),I=1,M)
       WRITE(23,7008) (XVERIFY(I),I=1,M)
 7008   FORMAT(/'SUBJ ',200(G14.7,1X))


C  REPLACE WRITING OF ASUB() WITH XVERIFY (SEE LOGIC IN 
C  SUBROUTINE VERIFYVAL.

      DO IOUTEQ = 1,NOS
       WRITE(23,7017) IOUTEQ
 7017  FORMAT(/' OUTPUT EQUATION NO. ',I2/)


       DO ISUB = 1,NWRITE
        DO I=1,M
         XVERIFY(I) = ASUB(ISUB,I,IOUTEQ)
        END DO
        CALL VERIFYVAL(M,XVERIFY)
C       WRITE(23,7007) ISUB,(ASUB(ISUB,I,IOUTEQ),I=1,M)
        WRITE(23,7007) ISUB,(XVERIFY(I),I=1,M)
       END DO
      END DO


	WRITE(23,7016) NOS,M

 7016   FORMAT(//' THE FOLLOWING ',I2,' BLOCK(S) CONTAIN THE SIMULATED O
     1BSERVED'/
     2' VALUES FOR EACH OUTPUT EQUATION. EACH BLOCK HAS THE ',I4,' OBSER
     3VED VALUES'/
     4' FOR EACH SUBJECT ON ONE LINE.'/)

C  REPLACE WRITING OF TIMORIG() WITH XVERIFY (SEE LOGIC IN 
C  SUBROUTINE VERIFYVAL.

       DO I=1,M
        XVERIFY(I) = TIMORIG(I)
       END DO
       CALL VERIFYVAL(M,XVERIFY)

       WRITE(23,7009)
C	 WRITE(23,7008) (TIMORIG(I),I=1,M)
       WRITE(23,7008) (XVERIFY(I),I=1,M)


C  REPLACE WRITING OF YPREDSUB() WITH XVERIFY (SEE LOGIC IN 
C  SUBROUTINE VERIFYVAL.

      DO IOUTEQ = 1,NOS
       WRITE(23,7017) IOUTEQ
       DO ISUB = 1,NWRITE
        DO I=1,M
         XVERIFY(I) = YPREDSUB(ISUB,I,IOUTEQ)
        END DO
        CALL VERIFYVAL(M,XVERIFY)
C       WRITE(23,7007) ISUB,(YPREDSUB(ISUB,I,IOUTEQ),I=1,M)
        WRITE(23,7007) ISUB,(XVERIFY(I),I=1,M)
       END DO
      END DO


C  NDIM = -1 --> 3 ANALYTIC SOLNS. FOR THE LINEAR 3-COMP. MODEL. IN THIS
C  CASE, THE DO LOOP BELOW IS OVER 1 TO 3. AND CHANGE THE WRITE(23,7021)
C  STATEMENT ACCORDINGLY.

        NNN = NDIM
        IF(NDIM .EQ. -1) NNN = 3

	WRITE(23,7021) NNN,M
 7021   FORMAT(//' THE FOLLOWING ',I2,' BLOCK(S) CONTAIN THE SIMULATED'/
     1' AMOUNTS FOR EACH COMPARTMENT. EACH BLOCK SHOWS THE ',I4,' AMOUNT
     2S '/
     2' FOR EACH SUBJECT ON ONE LINE. '/)

C  REPLACE WRITING OF TIMORIG() WITH XVERIFY (SEE LOGIC IN 
C  SUBROUTINE VERIFYVAL.

       DO I=1,M
        XVERIFY(I) = TIMORIG(I)
       END DO
       CALL VERIFYVAL(M,XVERIFY)

       WRITE(23,7009)
C	 WRITE(23,7008) (TIMORIG(I),I=1,M)
       WRITE(23,7008) (XVERIFY(I),I=1,M)


C  REPLACE WRITING OF XPREDSUB() WITH XVERIFY (SEE LOGIC IN 
C  SUBROUTINE VERIFYVAL.


      DO IDIM = 1,NNN
       WRITE(23,7022) IDIM
 7022  FORMAT(/' COMPARTMENT NO. ',I2/)
       DO ISUB = 1,NWRITE
        DO I=1,M
         XVERIFY(I) = XPREDSUB(ISUB,I,IDIM)
        END DO
        CALL VERIFYVAL(M,XVERIFY)
C       WRITE(23,7007) ISUB,(XPREDSUB(ISUB,I,IDIM),I=1,M)
        WRITE(23,7007) ISUB,(XVERIFY(I),I=1,M)

       END DO
      END DO


	WRITE(23,7019)
 7019   FORMAT(//'******************************************************
     1**********'//
     2' SUMMARY STATISTICS FOLLOW ...'/)


C  IF ITOTSETS = NSUB, THE ITOTSETS PARAMETER SETS IN OVERALF ARE THE
C  SAME AS THE NSUB PARAMETER SETS IN VALALF. IF ITOTSETS > NSUB, THEN
C  ITOTSETS - NSUB PARAMETER SETS IN OVERALF WERE NOT USED IN VALALF.
C  IN THE FORMER CASE, SUBROUTINE STATT WILL BE CALLED JUST ONCE. IN
C  THE LATTER CASE, STATT WILL BE CALLED TWICE, ONCE WITH OVERALF AS
C  THE ARRAY OF VALUES, AND ONCE WITH VALALF AS THE ARRAY OF VALUES.
C  ALSO, WRITE THE APPROPRIATE MESSAGE TO THE OUTPUT FILE.

      IF(ITOTSETS .GT. NSUB) THEN

       WRITE(23,9802) ITOTSETS,NSUB,ITOTSETS
 9802  FORMAT(//' BECAUSE OF PARAMETER BOUNDARY RESTRICTIONS, IT TOOK'/
     1I9,' PARAMETER SETS TO OBTAIN THE ',I8,' WHICH WERE ACCEPTABLE'/
     2' FOR THE SUBJECT SIMULATIONS.'//
     3' THE SAMPLE MEANS, COV. MATRIX, AND CORR. MATRIX FOR THE '/
     4' ENTIRE ',I9,' PARAMETER SETS WERE AS FOLLOWS: ')

C  CALL SUBROUTINE STATT TO OBTAIN THE SAMPLE MEANS, SAMMEN, AND THE
C  SAMPLE COVARIANCES, SAMCOV, FOR THE PARAMETER VALUES IN OVERALF.

	CALL STATT(ITOTSETS,NVAR,OVERALF,SAMMEN,SAMCOV)

C  WRITE THESE SAMPLE STATISTICS INTO FILE 23, THE OUTPUT FILE.

C  REPLACE WRITING OF SAMMEN() WITH XVERIFY (SEE LOGIC IN 
C  SUBROUTINE VERIFYVAL).

        DO I = 1,NVAR
         XVERIFY(I) = SAMMEN(I)
        END DO
        CALL VERIFYVAL(NVAR,XVERIFY)
C       WRITE(23,9804) (SAMMEN(I),I=1,NVAR)     
        WRITE(23,9804) (XVERIFY(I),I=1,NVAR)
 9804   FORMAT(//' SAMPLE MEANS OF ALL PARAMETER DATA ARE:'/
     1  30(F12.4,1X))

        WRITE(23,9806)
 9806   FORMAT(//' SAMPLE COV. MATRIX OF ALL PARAMETER DATA IS:')


C  REPLACE WRITING OF SAMCOV() WITH XVERIFY (SEE LOGIC IN 
C  SUBROUTINE VERIFYVAL).

        DO I=1,NVAR
         DO J = 1,I
          XVERIFY(J) = SAMCOV(I,J)
         END DO
         CALL VERIFYVAL(I,XVERIFY)
C        WRITE(23,9012) I,(SAMCOV(I,J),J=1,I)
         WRITE(23,9012) I,(XVERIFY(J),J=1,I) 
        END DO	
 9012   FORMAT(' ROW ',I2,1X,200(G14.7,1X))

C  CALCULATE AND WRITE THE SAMPLE CORRELATION MATRIX.

        DO I = 1,NVAR
         DO J = 1,I
          SAMCOR(I,J)=SAMCOV(I,J)/DSQRT(SAMCOV(I,I)*SAMCOV(J,J))
         END DO
        END DO

        WRITE(23,9807)
 9807   FORMAT(//' SAMPLE CORR. MATRIX OF ALL PARAMETER DATA IS:')

        DO I=1,NVAR
         DO J = 1,I
          XVERIFY(J) = SAMCOR(I,J)
         END DO
         CALL VERIFYVAL(I,XVERIFY)
C        WRITE(23,9012) I,(SAMCOR(I,J),J=1,I)
         WRITE(23,9012) I,(XVERIFY(J),J=1,I) 

        END DO	


       WRITE(23,9803) NSUB
 9803  FORMAT(//' CORRESPONDING VALUES FOR THE ',I8,' PARAMETER SETS'/
     1' WHICH WERE ACTUALLY USED TO SIMULATE SUBJECTS WERE ...')


      ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(ITOTSETS .GT. NSUB)  CONDITION.
  
  
      IF(ITOTSETS .EQ. NSUB) WRITE(23,9808) NSUB
 9808 FORMAT(//' ALL SIMULATED PARAMETER SETS WERE USED TO SIMULATE'/
     1' THE ',I8,' SUBJECTS; I.E., NONE WAS THROWN OUT BECAUSE OF '/
     2' PARAMETER BOUNDARY RESTRICTIONS. SO THE FOLLOWING SAMPLE'/
     3' MEANS, COV. MATRIX AND CORR. MATRIX ARE FOR ALL PARAMETER'/
     4' SETS.')

C  CALL SUBROUTINE STATT TO OBTAIN THE SAMPLE MEANS, SAMMEN, AND THE
C  SAMPLE COVARIANCES, SAMCOV, FOR THE GENERATED PARAMETER VALUES.

	CALL STATT(NSUB,NVAR,VALALF,SAMMEN,SAMCOV)

C  WRITE THESE SAMPLE STATISTICS INTO FILE 23, THE OUTPUT FILE.

C  REPLACE WRITING OF SAMMEN() WITH XVERIFY (SEE LOGIC IN 
C  SUBROUTINE VERIFYVAL).

        DO I = 1,NVAR
         XVERIFY(I) = SAMMEN(I)
        END DO
        CALL VERIFYVAL(NVAR,XVERIFY)
C       WRITE(23,9876) (SAMMEN(I),I=1,NVAR)
        WRITE(23,9876) (XVERIFY(I),I=1,NVAR)

 9876   FORMAT(/' SAMPLE MEANS OF PARAMETERS USED TO SIMULATE SUBJECTS:
     1 '/
     2  30(F12.4,1X))

        WRITE(23,9878)
 9878   FORMAT(//' SAMPLE COV. MATRIX OF PARAMETERS USED TO SIMULATE SUB
     1JECTS: '/)

C  REPLACE WRITING OF SAMCOV() WITH XVERIFY (SEE LOGIC IN 
C  SUBROUTINE VERIFYVAL).

        DO I=1,NVAR
         DO J = 1,I
          XVERIFY(J) = SAMCOV(I,J)
         END DO
         CALL VERIFYVAL(I,XVERIFY)
C        WRITE(23,9012) I,(SAMCOV(I,J),J=1,I)
         WRITE(23,9012) I,(XVERIFY(J),J=1,I) 
        END DO	

C  CALCULATE AND WRITE THE SAMPLE CORRELATION MATRIX.

	 DO I = 1,NVAR
	  DO J = 1,I
	   SAMCOR(I,J)=SAMCOV(I,J)/DSQRT(SAMCOV(I,I)*SAMCOV(J,J))
	  END DO
	 END DO

        WRITE(23,9877)
 9877   FORMAT(//' SAMPLE CORR. MATRIX OF PARAMETERS USED TO SIMULATE SU
     1BJECTS: '/)

        DO I=1,NVAR
         DO J = 1,I
          XVERIFY(J) = SAMCOR(I,J)
         END DO
         CALL VERIFYVAL(I,XVERIFY)
C        WRITE(23,9012) I,(SAMCOR(I,J),J=1,I)
         WRITE(23,9012) I,(XVERIFY(J),J=1,I) 
        END DO	


C  CALL SUBROUTINE STAT2 TO OBTAIN THE SUMMARY STATISTICS FOR THE
C  OUTPUT CONCENTRATIONS, STORED IN YPREDSUB. THEN WRITE THESE
C  STATISTICS TO THE OUTPUT FILE.

	CALL STAT2(NSUB,M,NOS,YPREDSUB,YMEAN,YMIN,YMAX,YSD,Y025,
     1   Y25,Y50,Y75,Y975)

	WRITE(23,9971) NOS,M,NSUB
 9971   FORMAT(//' THE STATISTICS FOR EACH OF THE ',I2,' OUTPUT '/
     1' EQUATION(S) AND ',I4,' OBSERVATION TIMES FOLLOW: '//
     2' FOR EACH OUTPUT EQUATION AND OBSERVATION, THE 9 VALUES '/
     3' REPRESENT, IN ORDER, THE MEAN, MINIMUM, MAXIMUM, STD. DEV.,'/
     4' 2.5%-TILE, 25%-TILE, 50%-TILE (MEDIAN), 75%-TILE, AND 97.5%-TILE
     5'/
     6' ... OVER ALL ',I7,' SUBJECTS.'/)



      DO IN = 1,NOS

	 WRITE(23,9972) IN
 9972    FORMAT(/' OUTPUT EQUATION ',I1,':')
	 
       DO IM = 1,M
	
        WRITE(23,9973) IM
 9973   FORMAT(/' FOR OBSERVATION ',I4,':')


C  REPLACE WRITING OF YMEAN(),...,Y975() WITH XVERIFY (SEE LOGIC IN 
C  SUBROUTINE VERIFYVAL.

        XVERIFY(1) = YMEAN(IM,IN)
        XVERIFY(2) = YMIN(IM,IN)
        XVERIFY(3) = YMAX(IM,IN)
        XVERIFY(4) = YSD(IM,IN)
        XVERIFY(5) = Y025(IM,IN)
        XVERIFY(6) = Y25(IM,IN)
        XVERIFY(7) = Y50(IM,IN)
        XVERIFY(8) = Y75(IM,IN)
        XVERIFY(9) = Y975(IM,IN)        
        CALL VERIFYVAL(9,XVERIFY)

C       WRITE(23,9974) YMEAN(IM,IN),YMIN(IM,IN),YMAX(IM,IN),YSD(IM,IN),
C    1   Y025(IM,IN),Y25(IM,IN),Y50(IM,IN),Y75(IM,IN),Y975(IM,IN)
        WRITE(23,9974) (XVERIFY(IXV),IXV=1,9)
 9974   FORMAT(9(1X,F10.3))

	 END DO


	END DO


C  THE ABOVE END DO's ARE FOR THE  DO IM = 1,M  LOOP, AND THE
C  DO IN = 1,NOS  LOOP, RESPECTIVELY.


	CLOSE(23)

	RETURN


	END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
	SUBROUTINE INOUT(ISUB,PATHFIL2,PATHFIL3,IPRNPAT,TIMORIG,
     1     INTLIST,RPAR,IPAR)

	IMPLICIT REAL*8(A-H,O-Z)

	PARAMETER(MAXNUMEQ=7)

        integer, dimension(128) :: intlist
        double precision, dimension(257) :: RPAR
        integer, dimension(257) :: IPAR

	CHARACTER SEX*1,READLINE*300,PATHFIL2*93,PATHFIL3*93,
     1   READLIN2*72,READBOT(99)*72,ERRFIL*20,CHARSUB*5

      COMMON/ERROR/ERRFIL
C  COMMON/ERROR/ IS SUPPLIED TO ALL THE ROUTINES WHICH COULD WRITE TO
C  ERRFIL.

      DIMENSION TIM(594),SIG(5000),RS(5000,34),YO(594,MAXNUMEQ),
     1 BS(5000,7),TIMORIG(594)

C  NOTE: AS OF MONT101F.FOR, THE FOLLOWING COMMONS, THAT ARE SUPPLIED TO
C        SUBROUTINE FUNC2, WILL BE OVERWRITTEN WHEN SUBROUTINE 
C        STOREOBSER IS CALLED AFTER SUBROUTINE NEWWORK1 CHANGES
C        PATHFIL2 TO A WORKING COPY FILE IN THE FORMAT THAT FUNC2 
C        EXPECTS (I.E., IF THERE ARE STEADY STATE DOSE SETS IN 
C        PATHFIL2, THE INFO MUST BE STORED IN THE WAY FUNC2 EXPECTS).

	COMMON/OBSER/ TIM,SIG,RS,YO,BS
	COMMON/CNST/ N,ND,NI,NUP,NUIC,NP
	COMMON/CNST2/ NPL,NUMEQT,NDRUG,NADD
	COMMON/SUM2/ M,NPNL
	COMMON/DESCR/AGE,HEIGHT,ISEX,IETHFLG
	COMMON/BOTPART/NBOTLINE,READBOT

C  COMMON/BOTPART IS PROVIDED TO SIMBIG TO WRITE THE BOTTOM PART OF
C  THE WORKING COPY FILE TO EACH SIMULATED PATIENT DATA FILE.


C  AS OF MONT101F.FOR, THE IJUMP PARAMETER IS REMOVED. NOW, EVERY TIME

C  INOUT IS CALLED, PATHFIL2 MUST BE READ TO ESTABLISH THE DOSAGE
C  REGIMEN ANEW. THE REASON IS THAT IF THERE ARE STEADY STATE DOSES
C  IN PATHFIL2, SUBROUTINE NEWWORK1 (CALLED BY SIMBIG) CHANGES
C  THE DOSE BLOCK AND THE OBSERVATION TIMES TO BE WHAT SUBROUTINE
C  FUNC2 EXPECTS ... BUT THE SIMULATED PATIENTS MUST HAVE THE 
C  ORIGINAL DOSAGE BLOCK AND SIMULATED TIMES THAT ARE IN PATHFIL2.

      OPEN(21,FILE=PATHFIL2,STATUS='OLD')


C  AGE, SEX, HEIGHT, AND ETHNICITY FLAG ARE ON LINES 8-11.

	DO I=1,7
	 READ(21,*)
	END DO
	 
	READ(21,*) AGE
	READ(21,2) SEX
    2   FORMAT(A1)
	ISEX=1
	IF(SEX .EQ. 'F') ISEX=2
	READ(21,*) HEIGHT
	READ(21,*) IETHFLG

        INTLIST(1) = int(AGE)
        INTLIST(2) = ISEX
        INTLIST(3) = int(HEIGHT)
        INTLIST(4) = IETHFLG

C  READ THE NO. OF DRUGS FROM THE LINE WITH 'NO. OF DRUGS' AS ENTRIES
C  12:23. THEN READ NO. OF ADDITIONAL COVARIATES, AND THE NO. OF DOSE 
C  EVENTS, ETC.

    1   FORMAT(A300)
   10	READ(21,1) READLINE
	IF(READLINE(12:23) .NE. 'NO. OF DRUGS') GO TO 10
	BACKSPACE(21)

    3   FORMAT(T2,I5)
        READ(21,3) NDRUG
        INTLIST(5) = NDRUG

	IF(NDRUG .GT. 7) THEN

	 WRITE(*,124)
  124    FORMAT(' YOUR PATIENT DATA FILES CANNOT HAVE MORE THAN 7'/
     1' DRUGS. THE PROGRAM IS NOW STOPPING. '/)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,124)          
        CLOSE(42)

       CALL PAUSE
	 STOP

	ENDIF

        READ(21,3) NADD
        INTLIST(6) = NADD

C  NOTE THAT THE NO. OF "RATES" INCLUDES 2 FOR EACH DRUG (THE IV AND
C  THE PO COLUMNS) + NADD (1 COLUMN FOR EACH ADDITIONAL COVARIATE 
C  BEYOND THE FIRST 4 ABOVE, AGE, SEX, HEIGHT, AND ETHNICITY FLAG).

	NI = 2*NDRUG + NADD
        INTLIST(7) = NI

	IF(NI .GT. 34) THEN

  	 WRITE(*,123)
  123    FORMAT(/' YOUR PATIENT DATA FILES HAVE TOO MANY COLUMNS IN '/
     1' THE DOSAGE REGIMEN BLOCK. THE NO. OF ADDITIONAL COVARIATES '/
     2' PLUS TWICE THE NO. OF DRUGS CANNOT EXCEED 34. THE PROGRAM IS'/
     3' NOW STOPPING. '/)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,123)          
        CLOSE(42)

	 CALL PAUSE
	 STOP

	ENDIF

        READ(21,3) ND
        INTLIST(8) = ND

	IF(ND .GT. 5000) THEN

	 WRITE(*,125)
  125  FORMAT(' YOUR PATIENT DATA FILES CANNOT HAVE MORE THAN 5000'/
     1' DOSE EVENTS. THE PROGRAM IS NOW STOPPING. '/)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,125) 
        CLOSE(42)

       CALL PAUSE
	 STOP

	ENDIF

	READ(21,*)
	READ(21,*)

        IF(ND.EQ.0) GO TO 40

	DO I = 1,ND
         READ(21,*) SIG(I),(RS(I,J),J=1,NI)
	END DO	 

C  ASSIGN THE VALUES IN EACH DRUG'S PO COLUMN TO THE CORRESPONDING
C  COLUMN IN ARRAY BS.


        DO I=1,ND
         DO J=1,NDRUG
          BS(I,J) = RS(I,2*J)
	 END DO
	END DO

C  READ THE NO. OF OUTPUT EQUATIONS FROM THE LINE WITH 'NO. OF TOTAL'
C  AS ENTRIES 12:23. THEN READ NO. OF OBSERVED VALUE TIMES, ETC.

   40	READ(21,1) READLINE
	IF(READLINE(12:23) .NE. 'NO. OF TOTAL') GO TO 40
	BACKSPACE(21)

        READ(21,3) NUMEQT
        READ(21,3) M
        INTLIST(9) = NUMEQT
        INTLIST(10) = M

	IF(M .GT. 594) THEN
	 WRITE(*,*) 'NO. OF OBSERVATIONS MUST BE .LE. 594'
	 WRITE(*,*) 'ONLY THE 1ST 594 OBSERVATION TIMES ARE USED.'
	 M=594
         INTLIST(10) = M
	ENDIF
C??? 150 CHANGED TO 594 IN MONTBG21.FOR.

	IF(NUMEQT .GT. MAXNUMEQ) THEN

  	 WRITE(*,127) NUMEQT,MAXNUMEQ 
  127    FORMAT(/' YOUR PATIENT DATA FILE HAS ',I3,' OUTPUT EQ.'/
     1' COLUMNS, WHICH IS MORE THAN ',I3,', THE MAX. ALLOWABLE NO. '/
     2' THE PROGRAM IS NOW STOPPING. '/)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,127) NUMEQT,MAXNUMEQ
        CLOSE(42)

       CALL PAUSE
	 STOP

	ENDIF


C  NOTE THAT ONLY THE OBSERVATION TIMES WILL BE READ IN EACH OF THE
C  M LINES BELOW (I.E., THE OBSERVED VALUES WILL BE IGNORED SINCE
C  THIS SUBJECT FILE IS BEING USED ONLY TO GET THE DOSAGE REGIMEN,
C  THE COVARIATE INFO (IF ANY), AND THE OBSERVED VALUE TIMES.

C  NO! AS OF MONTBIG7.FOR, THE OBSERVED VALUES WILL BE READ ALSO
C  SINCE ANY THAT ARE .LE. -99 ARE MISSING VALUES AND WILL BE SIMULATED
C  AS MISSING VALUES (I.E., THEIR VALUE WILL BE -99).

C  AS OF MONT101F.FOR, MUST ALSO STORE THE OBSERVATION TIMES FROM
C  PATHFIL2, SINCE NEW SUBROUTINE NEWWORK1 CAN CHANGE THESE VALUES
C  IF THERE ARE STEADY STATE DOSE SETS. THESE ORIGINAL TIMES MUST
C  BE THE ONES THAT ARE WRITTEN INTO THE SIMULATED PATIENT FILES.
C  STORE THESE TIMES INTO TIMORIG.


        DO I=1,M
         READ(21,*) TIM(I),(YO(I,J),J=1,NUMEQT)
         TIMORIG(I) = TIM(I)
        END DO

C  READ THE BOTTOM PART OF THE FILE, WHICH WILL BE PROVIDED TO
C  SUBROUTINE SIMBIG VIA COMMON/BOTPART (SO IT CAN BE PUT INTO EACH
C  SIMULATED PATIENT DATA FILE).
C  NOTE THAT IEND .LT. 0 --> END OF FILE REACHED.	

	NBOTLINE = 0

 1010	READ(21,22,IOSTAT=IEND) READLIN2
	IF(IEND .LT. 0) GO TO 1025
	NBOTLINE = NBOTLINE + 1
	READBOT(NBOTLINE) = READLIN2


	GO TO 1010
 1025	CLOSE(21)


C  WRITE ALL INFO TO PATIENT DATA FILE, EXCEPT THE SIMULATED OBSERVED
C  VALUES (WHICH WILL BE DONE IN SIMBIG/MAIN).

C  PATIENT DATA FILES WILL BE CREATED IF IPRNPAT = 1.

 	IF(IPRNPAT .GE. 1) THEN

       OPEN(21,FILE=PATHFIL3)

       CALL GETCHAR(ISUB,CHARSUB)

   22 FORMAT(A72)
	READLIN2 = '  LAST AND FIRST NAMES ARE: YOWZA '//CHARSUB

	WRITE(21,22) READLIN2
	READLIN2 = ' CHART NUMBER IS: 1234'
	WRITE(21,22) READLIN2
	WRITE(21,*)
	READLIN2= ' WARD NO, PATIENT AGE (YEARS), SEX, HEIGHT (INCHES),'
	WRITE(21,22) READLIN2
	READLIN2 = ' ETHNICITY FLAG, AND ETHNICITY DESCRIPTION (IF ANY) 
     1FOLLOW ON'
	WRITE(21,22) READLIN2
	READLIN2 = ' THE NEXT 6 LINES:'
	WRITE(21,22) READLIN2

	READLIN2 = '56'
	WRITE(21,22) READLIN2
	READLIN2 = ' 74.000000'

	WRITE(21,22) READLIN2
	READLIN2 = 'M'
	WRITE(21,22) READLIN2
	READLIN2 = ' 67.89'
	WRITE(21,22) READLIN2
	READLIN2 = '1'
	WRITE(21,22) READLIN2               
	WRITE(21,*)                
	WRITE(21,*)                                                        

	READLIN2 = ' DATE OF FIRST THERAPY IS    7  12  98'
	WRITE(21,22) READLIN2
	READLIN2 = 'CCR ML/MIN/    0.00 150.00'
	WRITE(21,22) READLIN2

	READLIN2 = 'HOURS    MG     MG/HR    MCG/ML KG       MG/DL    60
     1.00'
	WRITE(21,22) READLIN2
        WRITE(21,*)

	WRITE(21,1011) NDRUG
 1011   FORMAT(5X,I1,' ... NO. OF DRUGS')
	WRITE(21,1012) NADD
 1012   FORMAT(4X,I2,' ... NO. OF ADDITIONAL COVARIATES')
	WRITE(21,1013) ND
 1013   FORMAT(1X,I5,' ... NO. OF DOSE EVENTS')

	WRITE(21,1014)
 1014   FORMAT(/'    TIME, IV/PO FOR EACH DRUG; ADDITIONAL COVARIATES IF
     1 ANY')  

	DO I = 1,ND
         WRITE(21,*) SIG(I),(RS(I,J),J=1,NI)
	END DO	 

	WRITE(21,*)
	WRITE(21,1016) NUMEQT
 1016   FORMAT(5X,I1,' ... NO. OF TOTAL OUTPUT EQUATIONS')
	WRITE(21,1017) M
 1017   FORMAT(2X,I4,' ... NO. OF OBSERVED VALUE TIMES')


	ENDIF


C  THE ABOVE ENDIF IS FOR THE  IF(IPRNPAT .GE. 1)  CONDITION.

	RETURN


	END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

C
C  THIS IS SUBROUTINE IDCALCY FROM idm2x10.f, EXCEPT WITH THE ADDED CODE
C  RELATED TO APPLYING NOISE TO THE DOSE TIMES, DOSES, AND OBSERVATION 
C  TIMES (VIA THE PARAMETER, IDUM), AND THE CODE RELATED TO XPRED, 
C  SUPPLIED VIA COMMON/COMANT. THE SAME COMMENT APPLIES TO ROUTINES
C  FUNC2 AND EVAL2.

C  NOTE THAT SUBROUTINES USERANAL AND JACOB (FROM idm1x4.f) ARE 
C  UNCHANGED FROM MONTBG15.FOR. ALSO, VODTOT.FOR, LOCATED IN 
C  bigmlt5.f, AND SUBROUTINE SHIFT (IN SHIFT7.F) ARE INCLUDED.

	SUBROUTINE IDCALCY(NPP,NDIM,ESTML,YPRED,IDUM,INTLIST,RPAR,IPAR)

C  INPUT ARE:

C  NPP = NO. OF PARAMETERS (RANDOM AND FIXED) IN THE PARAMATER 
C       VECTOR, ESTML.
C  NDIM = NO. OF COMPARTMENTS IN THE MODEL.
C  ESTML = VECTOR OF PARAMETER ESTIMATES (RANDOM AND FIXED).

C  INFORMATION FROM A SUBJECT DATA FILE WHOSE INFO IS PASSED TO THE 
C  ROUTINES IN THIS MODULE VIA COMMONS /OBSER/, /CNST/, /CNST2/, AND 
C  /SUM2/.

C  OUTPUT IS:

C  YPRED(I,J), I=1,M; J=1,NOS = THE PREDICTED VALUE FOR THE ITH 
C	OBSERVATION OF THE JTH OUTPUT EQUATION, GIVEN THE INPUT VECTOR
C	ESTML. M AND NOS ARE INPUT TO THIS MODULE VIA COMMONS SUM2 AND
C	CNST2, RESPECTIVELY.

c-----------------------------------------------------------------------

C USE, Implicit, Parameters, and COMMONs
        use npag_utils, only: max_ODE_params,k_dvode_reserved,
     1    max_RS_J,k_p_end,i_dvode_reserved

        IMPLICIT none

        COMMON/PARAMD/ P
        COMMON/CNST/ N,ND,NI,NUP,NUIC,NP
        COMMON/BOLUSCOMP/NBCOMP

        integer, PARAMETER :: MAXNUMEQ=7

        double precision, dimension(32) :: P
        integer N,ND,NI,NUP,NUIC,NP
        integer, dimension(7) :: NBCOMP

C Argument list
        integer :: NPP,NDIM
        double precision, dimension(32) :: ESTML
        double precision, dimension(594,MAXNUMEQ) :: YPRED
        integer IDUM
        integer, dimension(128) :: INTLIST
        double precision, dimension(257) :: RPAR
        integer, dimension(257) :: IPAR

C Locals
        integer III

C*****INITIALIZE PROGRAM*****

	CALL SYMBOL(NBCOMP)

C  THE ABOVE CALL OBTAINS INFO FROM COMMONS.

C  NOTE THAT THIS PROGRAM NOW GETS N = NDIM AND NPP = NVAR+NOFIX
C  AS CALLING ARGUMENTS.

	N = NDIM
	NP = NPP

C  CALCULATE THE OUTPUT CONCENTRATION VECTOR, Y, FOR THE PARAMETER
C  VECTOR, ESTML.

C  First, PUT MODEL PARAMETER VALUES INTO /PARAMD/P.

        DO III=1,NP
	  P(III) = ESTML(III)
	END DO
C        write (*,*) P ! wmy20190308 -- seems correct here.

C  CALL SUBROUTINE EVAL2 TO GET Y, EVALUATED
C  AT ESTML(I) AS DEFINED ABOVE.

C-----------------------------------------------------------------------
C wmy2019.02.14 -- NPAG Reconciliation reqs RPAR and IPAR be used.
C        write (*,*) "Calling EVAL2; RPAR <- P; IPAR <- INTLIST" 

C        do III=1,max_ODE_params
        do III=1,32
          RPAR(k_dvode_reserved + III) = P(III)
        end do
C        do III = 1,max_RS_J
C          RPAR(k_p_end + III) = R(III) ! R() is initilized in FUNC2
C        end do
C        RPAR(k_jsub) = dble(JSUB)
C        RPAR(k_ig) = dble(IG)

        do III = 1,10
          IPAR(i_dvode_reserved + III) = INTLIST(III)
        end do
C        IPAR(i_jsub) = JSUB
C        IPAR(i_ig) = IG

C-----------------------------------------------------------------------

C wmy2019.03.06 -- check passed
        write (*,*) "Call EVAL2; RPAR(1)=",RPAR(k_dvode_reserved + 1)

	CALL EVAL2(YPRED,IDUM,INTLIST,RPAR,IPAR)

        RETURN
	END

C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
      SUBROUTINE FUNC2(F,IDUM,
     1  INTLIST,RPAR,IPAR)

C  THIS SUBROUTINE, CALLED BY EVAL2, FINDS F(I) = OUTPUT CONC. AT
C  TIME I, I=1,INTLIST(10), GIVEN PARAMETER VALUES IN P.
C
C  Note: INTLIST(10) == M, the total number of "measurements" 

      use npag_utils, only :  verifyval, SHIFT, thesame, predlast3,
     1  max_ODE_comps, max_ODE_params, max_SS_doses,
     2  max_RS_J, k_dvode_reserved, k_p_end, k_jsub, k_ig,
     3  i_dvode_reserved, i_jsub, i_ig

      IMPLICIT REAL*8(A-H,O-Z)

      integer, PARAMETER :: MAXNUMEQ=7

      integer, dimension(128) :: INTLIST
      double precision, dimension(257) :: RPAR
      integer, dimension(257) :: IPAR

      COMMON/BOLUSCOMP/NBCOMP
      COMMON/OBSER/ TIM,SIG,RS,YO,BS
      COMMON/CNST/ N,ND,NI,NUP,NUIC,NP
      COMMON/INPUT/ R,B
      COMMON/PARAMD/ P
      COMMON/CNST2/ NPL,NOS,NDRUG,NADD
      COMMON/STATE/ X
      COMMON/COMAMT/XPRED

      COMMON/NOISE/ C0DT,C1DT,C2DT,C3DT,C0DA,C1DA,C2DA,C3DA,
     1   C0OT,C1OT,C2OT,C3OT

      CHARACTER ERRFIL*20

      COMMON/ERROR/ERRFIL
C  COMMON/ERROR/ IS SUPPLIED TO ALL THE ROUTINES WHICH COULD WRITE TO
C  ERRFIL.

      DIMENSION TIM(594),SIG(5000),RS(5000,34),
     1 YT(MAXNUMEQ),YO(594,MAXNUMEQ),F(594,MAXNUMEQ),BS(5000,7),
     2Y(594,MAXNUMEQ),B(20),NBCOMP(7),TLAG(7),FA(7),XPRED(594,20),
     3AS1(594),SIGN(5000),TIMN(594),RSN(5000,34),BSN(5000,7),
     4XVERIFY(900)

      double precision, dimension(max_ODE_comps) :: X, XXPRED
      double precision, dimension(max_SS_doses,max_ODE_comps) :: XSTORE
      double precision, dimension(max_ODE_params) :: P
      double precision, dimension(37) :: R

C  NOTE THAT AS OF MONT109.FOR, THE DIMENSIONS OF 6 IN XSTORE AND XXPRED
C  HAVE BEEN CHANGED TO 20, WHICH IS WHAT THEY SHOULD HAVE BEEN ALL
C  ALONG (I.E., THE SAME AS FOR XPRED).

C  THE NOMINAL VALUES IN COMMON/OBSER, TIM,SIG,RS,BS, MUST HAVE NOISE
C  APPLIED TO THEM AT THIS POINT, ACCORDING TO THE NOISE C'S THE USER
C  SPECIFIED IN MAIN, NAMELY:
C  C0DT,C1DT,C2DT,C3DT <-- DOSE TIMES
C  C0DA,C1DA,C2DA,C3DA <-- DOSE AMOUNTS
C  C0OT,C1OT,C2OT,C3OT <-- OBSERVATION TIMES.


C  FIRST OBTAIN THE NOISY DOSE TIMES AND DOSE AMOUNTS.

	DO I = 1,ND

C  FOR EACH I BELOW, WILL CALL NOSGEN TO GET A NORMAL VECTOR OF 
C  LENGTH 1, WITH MEAN = 0 VECTOR, AND COV. MATRIX = 1, I.E, A N(0,1)
C  DEVIATE FOR THE DOSE TIME.

C  AS OF MONT101F.FOR, WHEN STEADY STATE DOSES ARE ALLOWED, THE 
C  FIRST DOSE WILL ALWAYS BE ASSUMED TO BE GIVEN AT TIME 0 (PREVIOUSLY
C  IT HAD NOISE ADDED). THIS IS CONSISTENT WITH SUBSEQUENT TIME RESETS,
C  AND STEADY STATE DOSE SETS, WHERE THE FIRST DOSE IS ALWAYS ASSUMED
C  TO BE GIVEN AT THE DESIRED TIME. SO, THERE WILL NO LONGER BE ANY
C  DISTINCTION BETWEEN I = 1 AND I > 1.

C  I.E., 


C  a. CHECK TO SEE IF SIG(I) .LE. 0. IF SO, THIS TIME IS THE BEGINNING
C     DOSE TIME, A TIME RESET, OR THE BEGINNING OF A STEADY STATE DOSE
C     SET, AND THEREFORE WILL NOT HAVE NOISE APPLIED TO IT (SO IT CAN BE
C     IDENTIFIED IN THE CODE AS THE BEGINNING TIME, A TIME RESET, OR THE
C     BEGINNING OF A STEADY STATE DOSE SET).

C  b. IF SIG(I) > 0:
   
C   - SET DUR = NOMINAL DURATION BETWEEN THE PREVIOUS DOSE TIME AND
C     THIS DOSE TIME.
C   - SET SI = STD. DEV. OF DUR (I.E., A CUBIC FNT. OF DUR, BASED ON
C     THE INPUT C'S).
C   - ESTABLISH DURNOISY AS THE NOISY DURATION BETWEEN THE PREVIOUS 
C     (NOISY) DOSE TIME AND THIS (NOISY) DOSE TIME. IT IS NORMALLY 
C     DISTRIBUTED WITH MEAN = DUR AND STD. DEV. = SI ... BUT WITH THE 
C     RESTRICTION THAT IT MUST BE .GE. .5*DUR AND .LE. 2*DUR.

C  NOTE THAT WITH THIS LOGIC, THE "NOISY" DOSE TIMES CANNOT OVERLAP 
C  (I.E., "NOISY" DOSE TIME I CANNOT OCCUR BEFORE "NOISY" DOSE 
C  TIME I-1).

C  IF SIG(I) > 0, APPLY NOISE. OTHERWISE, DON'T (SEE COMMENT ABOVE).

        IF(SIG(I) .LE. 0.D0) SIGN(I) = SIG(I)

         IF(SIG(I) .GT. 0) THEN
          DUR = SIG(I) - SIG(I-1)
          CALL NOSGEN(1,1.D0,IDUM,AS1)
          SI= C0DT + C1DT*DUR + C2DT*DUR**2.D0 + C3DT*DUR**3.D0
          DURNOISY = DUR + SI*AS1(1)
          IF(DURNOISY .LT. .5D0*DUR) DURNOISY = .5D0*DUR
          IF(DURNOISY .GT. 2.D0*DUR) DURNOISY = 2.D0*DUR
          SIGN(I) = SIGN(I-1) + DURNOISY
         ENDIF


C  FOR THE ITH DOSE TIME, CALL NOSGEN TO GET A NORMAL VECTOR OF 
C  LENGTH 2*NDRUG, WITH MEAN = 0 VECTOR, AND COV. MATRIX = THE
C  IDENTITY MATRIX. THESE VALUES WILL BE USED FOR THE 2*NDRUG IV
C  AND BOLUS VALUES.

	 CALL NOSGEN(2*NDRUG,1.D0,IDUM,AS1)

	  DO J = 1,2*NDRUG

	   SI = C0DA + C1DA*RS(I,J) + C2DA*RS(I,J)**2.D0 + 
     1        C3DA*RS(I,J)**3.D0

C  APPLY THE ABOVE N(0,1) DEVIATES TO GET NOISY DOSE VALUES ... UNLESS
C  THE NOMINAL VALUE = 0 (I.E., IT IS ASSUMED THAT A DOES WITH A NOMINAL
C  VALUE OF 0 HAS 0 NOISE ASSOCIATED WITH IT - I.E., IT WILL ALWAYS BE 
C  0).
	   RSN(I,J) = RS(I,J)
	   IF(RS(I,J) .GT. 0.D0) RSN(I,J) = RS(I,J) + SI*AS1(J)	 

       IF(RSN(I,J) .LT. 0.D0) THEN

C  REPLACE WRITING OF RSN() WITH XVERIFY (SEE LOGIC IN 
C  SUBROUTINE VERIFYVAL.
       
        XVERIFY(1) = RSN(I,J)
        CALL VERIFYVAL(1,XVERIFY)
C       WRITE(*,126) J,I,RSN(I,J) 
        WRITE(*,126) J,I,XVERIFY(1)
         
  126   FORMAT(/' THE NOISY VALUE OF DOSE NO. ',I5,' FOR DOSE'/
     1' TIME ',I5,' IS ',F12.4,' WHICH IS A NEGATIVE NUMBER.'//
     2' PLEASE RERUN THE PROGRAM AND SELECT SMALLER NOISE COEFFICIENTS'/
     3' FOR THE DOSAGE AMOUNTS.')

C       WRITE(23,126) J,I,RSN(I,J)
        WRITE(23,126) J,I,XVERIFY(1)

        OPEN(42,FILE=ERRFIL)
C       WRITE(42,126) J,I,RSN(I,J)
        WRITE(42,126) J,I,XVERIFY(1)
        CLOSE(42)

        CALL PAUSE
	  STOP

       ENDIF

	  END DO
C  THE ABOVE END DO IS FOR THE  DO J = 1,2*NDRUG  LOOP.


C  NOTE THAT ALL VALUES IN RS PAST INDEX 2*NDRUG ARE COVARIATE VALUES
C  AND ARE THEREFORE NOT NOISY --> ASSIGN THESE VALUES, UNCHANGED, TO 
C  RN.

	 DO J = 2*NDRUG+1,NI
	  RSN(I,J) = RS(I,J)
	 END DO


	END DO

C  THE ABOVE END DO IS FOR THE  DO I = 1,ND  LOOP.
C
C  wmy20190308 -- The noisy dose times are set
C   and RSN replaces RS; including COV values


C wmy2019.02.14
C        write (*,*) "In FUNC2 updating OBS times M = ", INTLIST(10)

C  NOW FIND THE NOISY OBSERVATION TIMES.
C INTLIST(10) == M
	DO I = 1,INTLIST(10)


C  FOR EACH I BELOW, WILL CALL NOSGEN TO GET A NORMAL VECTOR OF 
C  LENGTH 1, WITH MEAN = 0 VECTOR, AND COV. MATRIX = 1, I.E, A N(0,1)
C  DEVIATE FOR THE OBSERVATION TIME.


C  FOR I = 1, THE OBS. TIME IS NORMALLY DISTRIBUTED WITH MEAN =

C  THE NOMINAL OBS. TIME AND STD. DEV. = SI BELOW (I.E., A CUBIC FNT.
C  OF THE NOMINAL TIME, BASED ON THE INPUT C'S).

	 IF(I .EQ. 1) THEN
	  CALL NOSGEN(1,1.D0,IDUM,AS1)
	  SI = C0OT + C1OT*TIM(I) + C2OT*TIM(I)**2.D0 + C3OT*TIM(I)**3.D0
	  TIMN(I) = TIM(I) + SI*AS1(1)
	 ENDIF


C  FOR I > 1, THE NOISY OBS. TIME IS DETERMINED AS FOLLOWS:

C  a. CHECK TO SEE IF TIM(I) = 0. IF SO, THIS TIME IS A TIME RESET,
C     AND THEREFORE WILL NOT HAVE NOISE APPLIED TO IT (SO IT CAN BE
C     IDENTIFIED IN THE CODE BELOW AS A TIME RESET).

C  b. IF TIM(I) > 0:

C  -  SET DUR = NOMINAL DURATION BETWEEN THE PREVIOUS OBS. TIME AND

C     THIS OBS. TIME.
C  -  SET SI = STD. DEV. OF DUR (I.E., A CUBIC FNT. OF DUR, BASED ON
C     THE INPUT C'S).
C  -  ESTABLISH DURNOISY AS THE NOISY DURATION BETWEEN THE PREVIOUS 
C     (NOISY) OBS. TIME AND THIS (NOISY) OBS. TIME. IT IS NORMALLY 
C     DISTRIBUTED WITH MEAN = DUR AND STD. DEV. = SI ... BUT WITH THE 
C     RESTRICTION THAT IT MUST BE .GE. .5*DUR AND .LE. 2*DUR.

C  NOTE THAT WITH THIS LOGIC, THE "NOISY" OBS. TIMES CANNOT OVERLAP 
C  (I.E., "NOISY" OBS. TIME I CANNOT OCCUR BEFORE "NOISY" OBS.
C  TIME I-1).


C wmy2019.02.14
C        write (*,*) "IN FUNC2 w/I=",I,SI

        IF(I .GT. 1) THEN



         CALL THESAME(TIM(I),0.D0,ISAME)

         IF(ISAME .EQ. 1) TIMN(I) = 0.D0

         IF(ISAME .EQ. 0) THEN
          DUR = TIM(I) - TIM(I-1)
          CALL NOSGEN(1,1.D0,IDUM,AS1)
          SI= C0OT + C1OT*DUR + C2OT*DUR**2.D0 + C3OT*DUR**3.D0
          DURNOISY = DUR + SI*AS1(1)
          IF(DURNOISY .LT. .5D0*DUR) DURNOISY = .5D0*DUR
          IF(DURNOISY .GT. 2.D0*DUR) DURNOISY = 2.D0*DUR
          TIMN(I) = TIMN(I-1) + DURNOISY
         ENDIF

        ENDIF


	END DO


C  THE ABOVE END DO IS FOR THE  DO I = 1,M  LOOP.


C wmy2019.02.14
C        write (*,*) "IN FUNC2; M obs times are updated; begin sim"


C*****ODE CONSTANTS AND INITIALIZATION*****

      KNS=1
      KNT=1

C  NOTE THAT KNT IS THE RUNNING INDEX OF THE NEXT OBSERVATION TIME,
C  AND       KNS IS THE RUNNING INDEX OF THE NEXT DOSAGE TIME.

        T=0.0D0

C  INITIALIZE ISKIPBOL = 0. SEE CODE BELOW. IT IS ONLY NEEDED FOR A
C  STEADY STATE DOSE SET WHICH HAS BOLUS DOSES.

      ISKIPBOL = 0


      DO I = 1,NDRUG
       R(2*I-1) = 0.D0

      END DO

c  AS OF MONT101F.FOR, instead of R(1) = 0, the code has been changed to
c  set R(2*I-1) = 0, for I = 1,NDRUG. I.E., All IV rates for all NDRUG
c  drugs are initialized to be 0 ... in case the 1st obs. time is 0,
c  which means that OUTPUT is called before the R(I) are set below.

        

C  CALL SUBROUTINE GETFA IN npemdriv.f (THE FIRST TEMPLATE FILE TO 
C  INCLUDE GETFA IS TSTMULTG.FOR) TO OBTAIN THE VALUE OF FA FOR EACH
C  OF THE NDRUG DRUGS.

C  AS OF MONT106.FOR: BEFORE CALLING GETFA, MUST SET
C  THE R(.) IN CASE ANY OF THE FA(.) ARE FUNCTIONS OF THE 
C  COVARIATES WHICH ARE ESTABLISHED FROM THE R(.) VALUES IN
C  GETFA.
 
      DO I=1,NI
       R(I)=RSN(KNS,I)
      END DO


C wmy2019.02.26
C        write (*,*) "IN FUNC2; CALL GETFA #6762"

C
C SEGVIO happens here, after GETFA is called. This seems to be
C   because model.for is loaded w/the newer subroutines, that
C   do not use COMMON blocks. In npagranfix* the following call
C   to IDPC
C
C       CALL IDPC(JSUB,IG,NPX,PCOPY,NBCOMP,W,NOBSER,NUMEQT,
C    1    NDIM,MF,RTOL,ATOL,TIMCOPY,SIGCOPY,YO,RSCOPY,BSCOPY,
C     2    INTLIST,IPAR,ObsError,RPAR,ERRFILNAME)
C
C   includes all variables that need to be initialized prior
C   to calling GETFA, below.
C
C   original call from old MONTBIG:
C	 CALL GETFA(FA)
C
C   call in .../NPAG/engine/v125/idm3*.f
C         CALL GETFA(FA,X,ESTML,R,B,INTLIST)
C
C   X,P,R, and B are variables stored in COMMONs above.
C     but new PMetrics::makeModel() does not use these COMMON
C     blocks, so must pass them in:
	 CALL GETFA(FA,X,P,R,B,INTLIST)

C  NOTE THAT NBCOMP(I),I=1,NDRUG WAS SET IN SUBROUTINE SYMBOL AND
C  PASSED TO THIS ROUTINE VIA COMMON/BOLUSCOMP.


C  IF N = 0, THE OUTPUT EQUATION(S) FOR Y ARE CODED EXPLICITLY INTO
C  SUBROUTINE OUTPUT, AND NO D.E. SOLUTIONS (VIA USERANAL/DIFFEQ) ARE
C  TO BE USED. IN THIS CASE, SKIP THE CODE REGARDING INITIAL CONDITIONS

C  OF THE COMPARTMENTS, SINCE THEY ARE IRRELEVANT (I.E., THE COMPARTMENT
C  AMOUNTS DON'T NEED TO BE INITIALIZED SINCE THEY WON'T BE UPDATED BY
C  INTEGRATING D.E.'S). IN FACT, COULD PROBABLY SKIP TIMELAGS TOO, 
C  SINCE THEY CHANGE THE TIME THAT BOLUS DOSES ARE GIVEN, AND THIS
C  THEORETICALLY ONLY AFFECTS COMPARTMENT AMOUNTS (WHICH ARE NOT USED
C  IF N = 0), BUT JUST SKIP INITIAL CONDITIONS FOR NOW.

        IF(N .EQ. 0) GO TO 75


C  CALL SUBROUTINE GETIX IN npemdriv.f (THE FIRST TEMPLATE FILE TO 
C  INCLUDE GETIX IS TSTMULTG.FOR) TO OBTAIN THE VALUE OF X (THE INITIAL
C  COMPARTMENT AMOUNT) FOR EACH OF THE N COMPARTMENTS.

C wmy2019.02.14 - NPAG Reconciliation
C        write (*,*) "IN FUNC2; CALL GETIX #6891 w/N :", N

	 CALL GETIX(N,X,P,R,B,INTLIST)


C  NOTE THAT SIG AND RS DO NOT HAVE TO BE SAVED AS IN idm2x9.f, SINCE
C  THE NOISY VERSIONS OF THESE ARRAYS (SIGN AND RSN) WILL BE USED
C  BELOW (I.E., EVEN IF THERE ARE STEADY STATE DOSE SETS IN THIS RUN,
C  IT WILL BE SIGN(.) WHICH WILL BE CHANGED TO BE 0, NOT SIG(.).
  

C  CALL SUBROUTINE GETTLAG IN npemdriv.f (THE FIRST TEMPLATE FILE TO 
C  INCLUDE GETTLAG IS TSTMULTG.FOR) TO OBTAIN THE VALUE OF THE TIMELAG
C  FOR EACH OF THE NDRUG DRUGS.

C   75	 CALL GETTLAG(TLAG)
   75	 CALL GETTLAG(TLAG,X,P,R,B,INTLIST)

C wmy2019.02.14 -- NPAG Reconciliation
C        write (*,*) "IN FUNC2 #6907; Ret. fr. GETTLAG w/TLAG =", TLAG

C  IF ANY TLAG(.) VALUES RETURN AS .NE. 0, THEN, CALL SUBROUTINE SHIFT
C  TO ADJUST THE DOSAGE REGIMEN APPROPRIATELY.


        NTL = 0
	DO ID = 1,NDRUG
	 IF(TLAG(ID) .NE. 0) NTL = 1
	END DO

	IF(NTL .EQ. 1) THEN

C  STORE INCOMING VALUES IN ND, SIG, AND RS (WHICH CONTAINS BS VALUES)
C  SINCE THEY WILL BE CHANGED IN THE CALL TO SUBROUTINE SHIFT, WHICH 
C  "SHIFTS" THE DOSAGE REGIMEN MATRIX TO ACCOUNT FOR THE TIMELAG 
C  PARAMETER(S), TLAG(I). AT THE END OF THIS ROUTINE, THE VALUES IN ND, 
C  SIG, AND RS WILL BE RESET TO THEIR INCOMING VALUES - TO BE READY FOR 
C  THE NEXT CALL TO THIS ROUTINE WITH POSSIBLY DIFFERENT VALUES FOR 
C  TLAG(I).

C  NOTE THAT THE VALUES OF SIG AND RS DO NOT HAVE TO BE STORED SINCE
C  THESE VALUES WON'T BE USED BELOW - I.E., THE NOISY VERSIONS OF THESE
C  ARRAYS (SIGN AND RSN) ARE NOW USED. BUT ND COULD BE CHANGED IN THE
C  CALL TO SHIFT, SO STORE IT.

	 NDO = ND
C	 DO I=1,ND
C	  SIGO(I) = SIG(I)
C	  DO J=1,NI
C	   RSO(I,J) = RS(I,J)
C	  END DO
C	 END DO

C wmy2019.02.14
C        write (*,*) "IN FUNC2 and calling shift"

	 CALL SHIFT(TLAG,ND,SIGN,NDRUG,NADD,RSN,INTLIST)

	ENDIF
C  THE ABOVE ENDIF IS FOR THE  IF(NTL .EQ. 1)  CONDITION.

C wmy2019.02.14
C        write (*,*) "IN FUNC2; Passed if(NTL .EQ. 1)"

C  IN MONTBG17.FOR, THE FOLLOWING LOOP ESTABLISHING BSN(.,.) HAS BEEN
C  MOVED OUTSIDE THE IF(NTL .EQ. 1) SECTION, SINCE THE BSN VALUES MUST
C  BE SET REGARDLESS OF WHETHER OR NOT NTL = 1.

C  ESTABLISH THE VALUES IN EACH DRUG'S PO COLUMN TO THE CORRESPONDING
C  COLUMN IN ARRAY BS.

      DO I=1,ND
       DO J=1,NDRUG
        BSN(I,J)=RSN(I,2*J)
       END DO
      END DO


C wmy2019.02.14
C        write (*,*) "IN FUNC2; Forking to 12 or 45",
C     1   KNT, KNS, TIMN(KNT), SIGN(KNS)

        IF(TIMN(KNT).GE.SIGN(KNS)) GO TO 12
        IF(TIMN(KNT).NE.0.0D0) GO TO 45


C  THE ONLY WAY THE F0LLOWING CALL TO OUTPUT CAN OCCUR IS IF TIMN(KNT)
C  = 0 --> OBTAIN YT = OUTPUT VALUE(S) AT TIME 0.0.

C wmy2019.02.14
C        write (*,*) "IN FUNC2 missed jump to 12 or 45; calling OUTPUT"

      CALL OUTPUT(0.D0,YT,X,RPAR,IPAR)
      DO 2000 I=1,NOS
2000    Y(KNT,I)=YT(I)
        KNT=KNT+1

C        write (*,*) "Before going to 45: KNT,YT=",KNT,YT

        GO TO 45

C wmy2019.02.14 -- moved label 12 so write will be seen
12    CONTINUE
C      write (*,*) "IN FUNC2@12; Forking to 13 or 45",
C     1   KNT, KNS, TIMN(KNT), SIGN(KNS)
      IF(TIMN(KNT).GT.SIGN(KNS)) GO TO 13
	IF(TIMN(KNT).NE.0.0D0) GO TO 45

C  THE ONLY WAY THE F0LLOWING CALL TO OUTPUT CAN OCCUR IS IF TIMN(KNT)
C  = 0 --> OBTAIN YT = OUTPUT VALUE(S) AT TIME 0.0.

        CALL OUTPUT(0.D0,YT,X,RPAR,IPAR)
	DO 2005 I=1,NOS
2005    Y(KNT,I)=YT(I)
C
C wmy2019.03.06 -- 
C   the following ++KNT is in idm2; but NOT in older versions of MONTBIG
C        KNT=KNT+1
C ---

c wmy2019.03.04
C        write (*,*) "KNT,YT(KNT,I)",KNT,YT

C  ESTABLISH THE COMPARTMENT AMOUNTS AT THIS TIME (TIMN(KNT)). THESE
C  WILL BE PASSED IN COMMON/COMAMT BACK TO SUBROUTINE SIMBIG.

C  NEW CODE FOR MONTBG19.FOR, IN CASE N = -1, IN WHICH CASE THERE ARE
C  3 COMPARTMENTS.

        IF(N .GT. 0) THEN

         DO ICOMPART = 1,N
          XPRED(KNT,ICOMPART) = X(ICOMPART)
         END DO
        ENDIF

        IF(N .EQ. -1) THEN
         DO ICOMPART = 1,3
          XPRED(KNT,ICOMPART) = X(ICOMPART)
         END DO

        ENDIF

       KNT=KNT+1

13      IF(SIGN(KNS) .GT. 0.0D0) GO TO 45


C  CHECK TO SEE IF SIGN(KNS) < 0. IF SO, IT MEANS THAT 100 STEADY STATE
C  DOSES SHOULD NOW BE APPLIED WITH AN INTERDOSE INTERVAL EQUAL TO
C  -SIGN(KNS). NOTE THAT AS OF MONT110.FOR, THERE WILL ALSO BE AN 
C  ADDITIONAL 101ST DOSE SET APPLIED. THIS COMMENT APPLIES TO ALL
C  COMMENTS BELOW REGARDING 100 STEADY STATE DOSE SETS.

      ISTEADY = 0


      IF(SIGN(KNS) .LT. 0.D0) THEN


       ISTEADY = 1
       NSET = 1

C  NOTE THAT ISTEADY = 1 TELLS THE PROGRAM BELOW TO PROCEED AS IF THE
C  DOSE TIME IS 0, AND START INTEGRATING THROUGH THE SET OF 100 
C  DOSE SETS, ALL OF WHICH OCCUR BEFORE THE NEXT OBSERVATION TIME ...
C  BUT PAUSE AFTER THE END OF THE 5TH DOSE SET (NSET IS THE RUNNING NO.
C  OF THE CURRENT DOSE SETS THAT HAVE BEEN RUN) AND CALL SUBROUTINE
C  PREDLAST3 TO PREDICT THE STEADY STATE COMPARTMENT AMOUNTS AFTER THE
C  100 DOSE SETS (NOTE THAT THE COMPARTMENT AMOUNTS WILL HAVE TO BE
C  STORED AT THE END OF EACH OF THE STEADY STATE DOSE SETS AS THE LOGIC
C  OF PREDLAST3 REQUIRES). 

C  IF "CONVERGENCE" IS ACHIEVED AT THAT POINT, ASSIGN THE COMPARTMENT 
C  AMOUNTS TO BE THE PREDICTED AMOUNTS, AND ASSIGN KNS TO BE WHAT IT IS
C  WHEN THESE STEADY STATE DOSE SETS HAVE FINISHED. NOTE THAT THE END OF
C  THE 100TH DOSE SET WILL BE AT TIME 100*(-SIG(KNS)), SO KNS WILL BE 
C  THE INDEX OF THE FIRST DOSE EVENT WHICH OCCURS AFTER THIS TIME.

C  IF "CONVERGENCE" IS NOT ACHIEVED, CONTINUE APPLYING THE LOGIC OF
C  PREDLAST3 UNTIL IT IS ACHIEVED, OR UNTIL THE 100 DOSE SETS ARE ALL
C  INTEGRATED THROUGH, WHICHEVER COMES FIRST

       DOSEINT = -SIGN(KNS)

C  RESET SIGN(KNS) TO BE 0 SINCE THIS DOSE EVENT REPRESENTS THE START
C  OF 100 DOSE SETS THAT BEGIN AT TIME 0. 


       SIGN(KNS) = 0

      ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(SIGN(KNS) .LT. 0.D0)  CONDITION.


      DO I=1,NI
       R(I)=RSN(KNS,I)
      END DO

	IF(NDRUG .EQ. 0) GO TO 81


C  AS OF MONT106.FOR: MUST CALL GETFA BEFORE EVERY TIME THAT
C  FA(.) ARE USED IN CASE THE EQUATION(S) FOR THE FA(.) ARE BASED
C  ON THE COVARIATES, WHICH CAN CHANGE DOSE TO DOSE.

C         CALL GETFA(FA)
	 CALL GETFA(FA,X,P,R,B,INTLIST)


        IF(N .EQ. 0) GO TO 120

C wmy2019.02.14
        write (*,*) "IN FUNC2 and updating bolus ammnts"

        DO I=1,NDRUG

	 X(NBCOMP(I))=X(NBCOMP(I))+BSN(KNS,I)*FA(I)
	END DO


C wmy2019.02.14
C        write (*,*) "IN FUNC2 and going to 81"

C  NOTE THAT FA(I) IS THE FRACTION OF DRUG AVAILABLE FROM A BOLUS INPUT
C  INTO THE ABSORPTIVE COMPARTMENT.

	GO TO 81

120     DO I=1,NDRUG
	 B(I)=BSN(KNS,I)*FA(I)
	END DO

81      KNS=KNS+1
C
C*****INTEGRATION OF EQUATIONS*****

C
C  DETERMINE IF, OBSER(ID=0), OR DOSE(ID=1), OR BOTH(ID=2).

c wmy2019.03.04
45    Continue
C     write (*,*) "45, KNS, ND =", KNS, ND
      IF(KNS.GT.ND) GO TO 15

C wmy2019.03.04
C        write (*,*) "Passed 45 w/out going to 15",
C     1    KNT, TIMN(KNT)  

	IF(TIMN(KNT) .EQ. 0.D0 .AND. KNT .GT. 1) THEN

C wmy2019.03.06
C        write (*,*) "KNT,TIMN(KNT)",KNT,TIMN(KNT)


C  AS OF idm2x7.f, A TIME RESET NO LONGER REQUIRES ALL INITIAL
C  COMPARTMENT AMOUNTS TO BE RESET TO 0. THIS IS BECAUSE A TIME RESET
C  NO LONGER HAS TO MEAN THAT AN "INFINITE" AMOUNT OF TIME HAS OCCURRED
C  WITH NO DOSING; IT CAN ALSO NOW MEAN THAT AN "INFINITE" AMOUNT OF 

C  TIME HAS OCCURRED WITH UNKNOWN DOSING (IN THIS CASE, SUBROUTINE
C  GETIX WILL BE CALLED BELOW TO ESTABLISH INITIAL CONDITIONS FOR THIS
C  TIME PERIOD). 

C  ADVANCE KNS TO THE NEXT VALUE THAT HAS SIGN(KNS) .LE. 0. I.E., ONCE
C  TIMN(KNT) = 0, IT MEANS THAT WE ARE DONE WITH THE OUTPUT OBS.
C  TIMES IN THE PREVIOUS SECTION --> THERE IS NO POINT IN CONTINUING
C  TO INTEGRATE TILL THE END OF THE DOSES IN THE PREVIOUS SECTION
C  (IF THERE ARE ANY).

      DO IKNS = KNS,ND
C       write (*,*) "CHECK",KNS,IKNS,ND,SIGN(IKNS)
       IF(SIGN(IKNS) .LE. 0.D0) GO TO 110
      END DO

C  TO GET HERE MEANS THAT NO VALUE IN SIGN(.) FROM KNS TO ND HAS A 
C  VALUE .LE. 0, AND THIS IS AN ERROR. IT MEANS THAT THE PATIENT DATA
C  FILE HAS AN OBSERVATION TIME RESET ROW WITHOUT AN ACCOMPANYING
C  DOSE RESET ROW. TELL THE USER AND STOP.

C  REPLACE WRITING OF SIGN() WITH XVERIFY (SEE LOGIC IN 
C  SUBROUTINE VERIFYVAL.

      XVERIFY(1) = SIGN(KNS)
      CALL VERIFYVAL(1,XVERIFY)
C     WRITE(*,111) ND,KNS,SIGN(KNS)
      WRITE(*,111) ND,KNS,XVERIFY(1)

C     WRITE(25,111) ND,KNS,SIGN(KNS)
      WRITE(25,111) ND,KNS,XVERIFY(1)
 111  FORMAT(//' THE CURRENT SUBJECT HAS AN OBSERVATION TIME RESET'/
     1' ROW WITHOUT AN ACCOMPANYING DOSE RESET ROW. THE PROGRAM NOW'/
     2' STOPS. '//
     3' REVIEW YOUR PATIENT FILES AND CORRECT THE ERROR.'//
     4' NOTE THAT THE ',I4,' DOSE TIMES (POSSIBLY ALTERED BY TIMELAGS'/
     5' ARE THE FOLLOWING (AND THERE IS NO TIME .LE. 0 AFTER TIME'/
     6' NO. ',I4,' WHICH HAS CORRESPONDING TIME ',F15.4,'):')

      OPEN(42,FILE=ERRFIL)
C      WRITE(42,111) ND,KNS,SIGN(KNS)
       WRITE(42,111) ND,KNS,XVERIFY(1)
 
      DO I = 1,ND
       WRITE(*,*) SIGN(I)
       WRITE(25,*) SIGN(I)
       WRITE(42,*) SIGN(I)
      END DO

        CLOSE(42)

      CALL PAUSE
      STOP


c wmy2019.03.04
  110 Continue
C      write (*,*) "At 110 KNS = IKNS", KNS, IKNS
C      KNS = IKNS


C  THERE ARE TWO POSSIBILITES AT THIS POINT, EITHER SIGN(KNS) = 0
C  OR SIGN(KNS) < 0. 

C  IF SIGN(KNS) = 0, THIS REPRESENTS A TIME RESET (T WILL BE SET = 0
C  BELOW) WITH A SINGLE DOSE LINE TO START. IN THIS CASE, CALL GETIX
C  AGAIN (JUST AS WAS DONE NEAR THE TOP OF THIS ROUTINE) TO OBTAIN
C  INITIAL COMPARTMENT AMOUNTS. NOTE THAT BY DEFAULT, IN GETIX, ALL
C  COMPARTMENT AMOUNTS ARE SET = 0 (WHICH WOULD BE THE CASE IF IN THE 
C  LONG TIME PERIOD BETWEEN THE LAST SET OF DOSES AND THIS NEW
C  BEGINNING, NO DOSES HAVE BEEN GIVEN). BUT THE USER MAY ALSO HAVE
C  CODED INTO GETIX EQUATIONS THAT SET ONE OR MORE OF THE X(I) TO
C  FUNCTIONS OF COVARIATE AND PARAMETER VALUES (WHICH WOULD BE THE
C  SITUATION IF AN UNKNOWN DOSING REGIMEN HAS TAKEN PLACE BUT IT
C  DOESN'T MATTER WHAT IT WAS BECAUSE THE PATIENT COMES TO A LAB AND
C  SIMPLY HAS HIS COMPARTMENT VALUES ESTABLISHED BEFORE CONTINUING 
C  WITH THE OTHER VALUES IN HIS PATIENT FILE). 

C  IF SIGN(KNS) < 0, THIS REPRESENTS A TIME RESET WITH A STEADY STATE
C  SET OF 100 DOSES ABOUT TO BEGIN. IN THIS CASE, WE ASSUME THAT THE
C  PATIENT IS ABOUT TO GET 100 SETS OF DOSES SO THAT HIS COMPARTMENT
C  AMOUNTS WILL ACHIEVE STEADY STATE VALUES. THESE STEADY STATE VALUES
C  WILL BE ESTIMATED IN THE BLOCK OF CODE BELOW THAT STARTS WITH 
C  IF(ISTEADY .EQ. 1). IN THIS CASE, WE WILL STILL CALL GETIX TO 
C  MAKE SURE THAT ANY RESIDUAL COMPARTMENT AMOUNTS FROM A PREVIOUS
C  SET OF DOSES IS ZEROED OUT (OR SET = VALUES AS DETERMINED BY
C  SUBROUTINE GETIX). 


C  AS OF MONT106.FOR, BEFORE CALLING GETIX, MUST SET
C  THE R(.) IN CASE ANY OF THE INITIAL CONDITIONS FOR THE X(.)
C  ARE FUNCTIONS OF THE COVARIATES WHICH ARE ESTABLISHED FROM THE 
C  R(.) VALUES IN GETFA.

 
      DO I=1,NI
       R(I)=RSN(KNS,I)
      END DO


       CALL GETIX(N,X,P,R,B,INTLIST)

C  MUST ALSO RESET T = 0 SINCE THE INTEGRATION WILL AGAIN START FROM 
C  TIME 0.

       T = 0.D0


C  IF SIGN(KNS) .LT. 0, THIS IS NOT ONLY A TIME RESET, IT IS THE
C  BEGINNING OF A STEADY STATE DOSE SET. IN THIS CASE, APPLY 100 
C  STEADY STATE DOSES WITH AN INTERDOSE INTERVAL EQUAL TO -SIGN(KNS).

      ISTEADY = 0

      IF(SIGN(KNS) .LT. 0.D0) THEN

       ISTEADY = 1
       NSET = 1

C  NOTE THAT ISTEADY = 1 TELLS THE PROGRAM BELOW TO PROCEED AS IF THE
C  DOSE TIME IS 0, AND START INTEGRATING THROUGH THE SET OF 100 
C  DOSE SETS, ALL OF WHICH OCCUR BEFORE THE NEXT OBSERVATION TIME ...
C  BUT PAUSE AFTER THE END OF THE 5TH DOSE SET (NSET IS THE RUNNING NO.
C  OF THE CURRENT DOSE SETS THAT HAVE BEEN RUN) AND CALL SUBROUTINE
C  PREDLAST3 TO PREDICT THE STEADY STATE COMPARTMENT AMOUNTS AFTER THE
C  100 DOSE SETS (NOTE THAT THE COMPARTMENT AMOUNTS WILL HAVE TO BE
C  STORED AT THE END OF EACH OF THE STEADY STATE DOSE SETS AS THE LOGIC
C  OF PREDLAST3 REQUIRES). 

C  IF "CONVERGENCE" IS ACHIEVED AT THAT POINT, ASSIGN THE COMPARTMENT 
C  AMOUNTS TO BE THE PREDICTED AMOUNTS, AND ASSIGN KNS TO BE WHAT IT IS
C  WHEN THESE STEADY STATE DOSE SETS HAVE FINISHED. NOTE THAT THE END OF
C  THE 100TH DOSE SET WILL BE AT TIME 100*(-SIGN(KNS)), SO KNS WILL BE 
C  THE INDEX OF THE FIRST DOSE EVENT WHICH OCCURS AFTER THIS TIME.
C  NOTE THAT AS OF MONT110.FOR, THERE WILL ALSO BE AN ADDITIONAL 101ST
C  DOSE SET APPLIED. BUT KNS WILL STILL BE THE INDEX OF THE FIRST DOSE
C  EVENT AFTER THE 100TH DOSE SET.




C  IF "CONVERGENCE" IS NOT ACHIEVED, CONTINUE APPLYING THE LOGIC OF
C  PREDLAST3 UNTIL IT IS ACHIEVED, OR UNTIL THE 100 DOSE SETS ARE ALL
C  INTEGRATED THROUGH, WHICHEVER COMES FIRST. 


       DOSEINT = -SIGN(KNS)

C  RESET SIGN(KNS) TO BE 0 SINCE THIS DOSE EVENT REPRESENTS THE START
C  OF 100 DOSE SETS THAT BEGIN AT TIME 0. 

       SIGN(KNS) = 0

      ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(SIG(KNS) .LT. 0.D0)  CONDITION.



	ENDIF


C  THE ABOVE ENDIF IS FOR THE 
C   IF(TIMN(KNT) .EQ. 0.D0 .AND. KNT .GT. 1)  CONDITION.


c wmy2019.03.04
C      write (*,*) "IF(TIMN(KNT).NE.SIGN(KNS)) GO TO 20",
C     1   KNT,TIMN(KNT),KNS,SIGN(KNS),N

      IF(TIMN(KNT).NE.SIGN(KNS)) GO TO 20
      ID=2
      TOUT=TIMN(KNT)
      KNT=KNT+1
      KNS=KNS+1

      IF(N .EQ. 0) GO TO 31

      GO TO 30


C  AS OF MONT104.FOR, A BUG IS FIXED IN THE CODE BELOW. SEE COMMENTS
C  AT THE TOP OF MONT104.FOR.
20    IF(TIMN(KNT) .GT. SIGN(KNS) .AND. SIGN(KNS) .GT. 0) GO TO 25


15    ID=0
      TOUT=TIMN(KNT)
      KNT=KNT+1

      IF(N .EQ. 0) GO TO 31

      GO TO 30

25    ID=1
      TOUT=SIGN(KNS)
      KNS=KNS+1
      IF(N .EQ. 0) GO TO 31


30      CONTINUE



C wmy2019.02.14
        write (*,*) "Calling xANAL w/",N,KNT,KST,T,TOUT

C-----------------------------------------------------------------------
32      CONTINUE

C
C Verify RPAR and IPAR are initialized appropriately
C
C        do III=1,max_ODE_params
        do III=1,32
           RPAR(k_dvode_reserved + III) = P(III)
        end do
        do III = 1,max_RS_J
          RPAR(k_p_end + III) = R(III) ! R() is initilized in FUNC2
        end do
C        RPAR(k_jsub) = dble(JSUB)
C        RPAR(k_ig) = dble(IG)

        do III = 1,10
          IPAR(i_dvode_reserved + III) = INTLIST(III)
        end do
C        IPAR(i_jsub) = JSUB
C        IPAR(i_ig) = IG
C-----------------------------------------------------------------------

C wmy2019.03.04
C   Call to USERANAL must include all COMMON block variables
C   for NPAG reconciliation
C
C -- Original Call
C 32      IF(N .NE. -1) CALL USERANAL(X,T,TOUT)
C
C -- Call in NPAG::idm1
C 32      if (NDIM .NE. -1) then
C          CALL USERANAL(JSUB,IG,X,T,TOUT,
C     1      NDIM,MF,RTOL,ATOL,P,R,INTLIST,IPAR,RPAR)
C          if (IPAR(i_skip_ig).eq.0) return
C        endif
C
C -- Temporary Fix
C 32      if (NDIM .NE. -1) then ! Label 32 moved above to, init RPAR
        if (N .NE. -1) then
          CALL USERANAL(X,T,TOUT,RPAR,IPAR)
C          if (IPAR(i_skip_ig).eq.0) return
        endif
        IF(N .EQ. -1) CALL ANAL3(X,T,TOUT,RPAR,IPAR)

C -- End temporary Fix

C  IF ISTEADY = 1, THIS IS INSIDE A STEADY STATE DOSE SET. CHECK TO SEE
C  IF TOUT IS A MULTIPLE OF DOSEINT. IF SO, RECORD THE COMPARTMENT
C  AMOUNTS. THEN, AFTER COMPARTMENT AMOUNTS HAVE BEEN STORED FOR AT 
C  LEAST THE 1ST 5 MULTIPLES OF DOSEINT, STOP AND CALL SUBROUTINE
C  PREDLAST3 WHICH PREDICTS THE FINAL (STEADY STATE) COMPARTMENT AMOUNTS
C  AFTER THE LAST (100TH) DOSE SET. 

C  IF PREDLAST3 HAS PREDICTED VALUES WHICH "CONVERGE", ASSIGN THE
C  PREDICTED VALUES TO X, INCREASE KNS TO BE THE INDEX OF THE FIRST DOSE
C  EVENT WHICH OCCURS AFTER THE STEADY STATE DOSE SET ENDS AND CONTINUE.

C  IF PREDLAST3 VALUES DON'T CONVERGE, CONTINUE THE PROCESS WITH 
C  COMPARTMENT AMOUNTS FOR MULTIPLES 2 - 6 OF DOSEINT, TEST FOR
C  "CONVERGENCE", ETC. THIS PROCESS CONTINUES UNTIL "CONVERGENCE" IS
C  ACHIEVED FOR A SET OF 5 COMPARTMENT AMOUNTS (OR SETS OF AMOUNTS IF
C  NDRUG IS > 1), OR UNTIL ALL 100 DOSE SETS IN THE STEADY STATE REGIMEN
C  HAVE FINISHED. 

      IF(ISTEADY .EQ. 1) THEN


C  THE NEXT DOSE SET END TIME IS DOSEINT*NSET. IF TOUT = DOSEINT*NSET,
C  STORE THE COMPARTMENT AMOUNTS. IF NSET .GE. 5, CALL PREDLAST3 AND
C  PROCEED AS INDICATED ABOVE.

       CALL THESAME(TOUT,DOSEINT*NSET,ISAME)

       IF(ISAME .EQ. 1) THEN

        NN = N
        IF(N .EQ. -1) NN = 3

        DO J = 1,NN
         XSTORE(NSET,J) = X(J)
        END DO

        IF(NSET .GE. 5) THEN

         CALL PREDLAST3(NN,NSET,XSTORE,XXPRED,ICONV)
  
         IF(ICONV .EQ. 1) THEN

C  SINCE THE PREDICTED VALUES ARE CONSIDERED ACCURATE (I.E., 
C  "CONVERGENCE WAS ACHIEVED IN PREDLAST), RESET ISTEADY TO 0,
C  WHICH MEANS THAT THE STEADY STATE DOSES ARE FINISHED; ASSIGN THE
C  COMPARTMENT AMOUNTS TO BE THE PREDICTED VALUES; AND SET KNS TO THE
C  FIRST DOSE EVENT AFTER THE END OF THE STEADY STATE DOSE SET. ALSO,
C  SET T = THE ENDING TIME OF THE STEADY STATE DOSE SET = 100*DOSEINT,
C  SINCE THAT IS WHAT IT WOULD HAVE BEEN HAD ALL 100 DOSE SETS BEEN
C  RUN. NOTE THAT AS OF MONT110.FOR, THERE WILL ALSO BE AN 
C  ADDITIONAL 101ST DOSE SET APPLIED. BUT THE TIME WILL BE FORWARDED
C  TO THE END OF THE 100TH SET.



          ISTEADY = 0

          DO J = 1,NN
           X(J) = XXPRED(J)
          END DO

          T = 100.D0*DOSEINT




C  ADVANCE KNS TO BE THE FIRST DOSE PAST THE 100 DOSE SETS IN THIS
C  STEADY STATE SET. NOTE THAT THIS SET ENDS BEFORE 100*DOSEINT, SO
C  FIND THE FIRST SIGN(.) THAT IS .GE. 100*DOSEINT, OR THAT IS = 0
C  (WHICH SIGNIFIES A TIME RESET) OR THAT IS < 0 (WHICH SIGNIFIES 
C  ANOTHER STEADY STATE SET).

          DO I = KNS,ND
           IF(SIGN(I) .GE. 100.D0*DOSEINT .OR. SIGN(I) .LE. 0.D0) THEN
            KNSNEW = I
            GO TO 100
           ENDIF
          END DO

C  TO GET HERE MEANS THAT THERE ARE NO DOSE TIMES PAST THE END OF THIS
C  STEADY STATE DOSE SET. IN THIS CASE, SET KNS TO ND+1

          KNS = ND+1
          GO TO 200

  100     KNS = KNSNEW
  200     CONTINUE


C  SET ISKIPBOL = 1 WHENEVER CONVERGENCE OCCURS IN
C  THE STEADY STATE DOSES SINCE IN THIS CASE, WE DON'T WANT TO
C  REAPPLY THE LAST BOLUS FROM THE STEADY STATE SET BELOW LABEL 83.

          ISKIPBOL = 1


         ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(ICONV .EQ. 1)  CONDITION.

C  IF ICONV = 0, NSET WAS INCREASED ABOVE AND ISTEADY IS STILL = 1, 
C  WHICH MEANS THAT THE ATTEMPT TO PREDICT THE FINAL (STEADY STATE)
C  COMPARTMENT AMOUNTS CONTINUES.
          
        ENDIF
      
C  THE ABOVE ENDIF IS FOR THE  IF(NSET .GE. 5)  CONDITION.

C  SINCE ISAME = 1, THE END OF THE SET NO. NSET HAS OCCURRED -->
C  INCREASE NSET BY 1.


        NSET = NSET + 1

       ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(ISAME .EQ. 1)  CONDITION.

      ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(ISTEADY .EQ. 1)  CONDITION.



31      CONTINUE

C  RECORD OBSERVATION AND SUPPLY NEW DOSE
        IF(ID.EQ.1) GO TO 35
        KNTM1=KNT-1

C  NOTE THAT THE TIME AT WHICH THE OUTPUT IS DESIRED IS TIMN(KNTM1); 
C  THIS IS CLEAR SINCE THE RETURNING VALUE(S) IN YT ARE PUT INTO ROW NO.
C  KNTM1 OF Y.

        CALL OUTPUT(TIMN(KNTM1),YT,X,RPAR,IPAR)

	DO 2010 I=1,NOS
2010    Y(KNTM1,I)=YT(I)

C  ESTABLISH THE COMPARTMENT AMOUNTS AT THIS TIME (TIMN(KNTM1)). THESE
C  WILL BE PASSED IN COMMON/COMAMT BACK TO SUBROUTINE SIMBIG.

C  NEW CODE FOR MONTBG19.FOR, IN CASE N = -1, IN WHICH CASE THERE ARE
C  3 COMPARTMENTS.

        IF(N .GT. 0) THEN
         DO ICOMPART = 1,N
          XPRED(KNTM1,ICOMPART) = X(ICOMPART)
         END DO
        ENDIF 

        IF(N .EQ. -1) THEN
         DO ICOMPART = 1,3
          XPRED(KNTM1,ICOMPART) = X(ICOMPART)
         END DO
        ENDIF
 
C??? I THINK THIS IS WHERE THE Y's ARE ASSIGNED. THESE ARE THEN
C    ASSIGNED TO BE F(I,J) = Y(I,J) BELOW, WHERE F = YPRED VIA
C    EVAL AND FUNC2. 

C    SO, FROM THE CALL USERANAL(X,T,TOUT) LINE ABOVE, I THINK THAT
C    THE X AT THIS TIME WOULD BE THE COMPARTMENT VALUES AT THIS
C    TIME. SO MAYBE I CAN JUST STORE THESE X's AND PASS THIS BACK
C    TO MONTBIG4/MAIN TO BE STORED FOR THIS SUBJECT AND THIS TIME,
C    KNTM1.
  
C    MUST CHECK THIS. PERHAPS DO A RUN WITH VOLUME A FIXED KNOWN
C    VALUE AND, SAY, 2 OUTPUT EQUATIONS AND CHECK THAT THE 
C    YPRED(1) = X(1)/V AND YPRED(2) = X(2)/V.

C???


55      IF(ID.EQ.0) GO TO 40

  35    CONTINUE

	IF(NI .EQ. 0) GO TO 83

        DO I=1,NI
	 R(I)=RSN(KNS-1,I)
	END DO

C  AS OF MONT106.FOR: MUST CALL GETFA BEFORE EVERY TIME THAT
C  FA(.) ARE USED IN CASE THE EQUATION(S) FOR THE FA(.) ARE BASED
C  ON THE COVARIATES, WHICH CAN CHANGE DOSE TO DOSE.

C         CALL GETFA(FA)
	 CALL GETFA(FA,X,P,R,B,INTLIST)

83      IF(NDRUG .EQ. 0 .OR. N .EQ. 0) GO TO 82

C  ADDING N .EQ. 0 TO ABOVE IF STATEMENT SHOWS CLEARLY THAT IF
C  N = 0 (IN WHICH CASE ANALYTIC SOLUTIONS ARE CODED DIRECTLY INTO
C  SUBROUTINE OUTPUT, WHICH MAKES THE COMPARTMENT AMOUNTS IRRELEVANT)
C  SETTING VALUES FOR THE COMPARTMENTS, X, IS UNNECESSARY.

C  IF ISKIPBOL = 1, DO NOT APPLY BOLUSES FROM DOSE KNS-1, SINCE THESE
C  BOLUSES WERE PART OF THE STEADY STATE DOSE SET WHICH ALREADY HAD
C  BOLUSES (EFFECTIVELY) APPLIED ABOVE WHERE "CONVERGENCE" OF THE
C  STEADY STATE DOSE SET WAS OBTAINED.

        IF(ISKIPBOL .EQ. 0) THEN
         DO I=1,NDRUG
          X(NBCOMP(I))=X(NBCOMP(I))+BSN(KNS-1,I)*FA(I)
         END DO
        ENDIF

C  RESET ISKIPBOL = 0 HERE. IF IT IS NOW = 1, IT MEANS THAT
C  THE ABOVE APPLICATION OF BOLUSES WAS SKIPPED SINCE THERE HAS JUST
C  BEEN A STEADY STATE SET OF DOSES WHICH CONVERGED (AND WE DON'T
C  WANT THE LAST BOLUS DOSE REAPPLIED). BUT, GOING FORWARD, ISKIPBOL
C  SHOULD BE SET AGAIN TO 0 SO THE ABOVE APPLICATION OF BOLUSES WILL
C  OCCUR WHENEVER THERE IS A NEW BOLUS TO BE APPLIED.

      ISKIPBOL = 0




82      CONTINUE

C  CHECK STOPPING TIME.

40      IF(KNT .LE. INTLIST(10)) GO TO 45

C*****DETERMINE F(I)*****

C M = INTLIST(10); used to be first arg to FUNC2

	DO J=1,NOS
         DO I=1,INTLIST(10)
	  F(I,J) = Y(I,J)
	 END DO
	END DO


C  CODE FOR TIME LAGS, AS OF idcy_53g.f, which allows multiple drugs.
C  IF NTL = 1, THIS RUN INCLUDES AT LEAST ONE TIMELAG PARAMETER. 


C  IN THIS CASE, RESTORE THE VALUES IN ND, SIG, RS, AND BS TO THEIR 
C  INCOMING VALUES - TO BE READY FOR THE NEXT CALL TO THIS ROUTINE WITH 
C  A POSSIBLY DIFFERENT VALUE FOR THE TIMELAGS.

C  NOTE THAT THE VALUES OF SIG AND RS WERE NOT STORED ABOVE SINCE
C  THESE VALUES WEREN'T USED - I.E., THE NOISY VERSIONS OF 
C  THESE ARRAYS (SIGN AND RSN) WERE USED. SIMILARLY FOR BS VS. BSN.
C  BUT ND COULD BE HAVE BEEN CHANGED IN THE CALL TO SHIFT, SO RESTORE 
C  ITS VALUE.


	IF(NTL .EQ. 1) THEN

	 ND = NDO
         INTLIST(8) = ND
C	 DO I=1,ND
C	  SIG(I) = SIGO(I)
C	  DO J=1,NI
C	   RS(I,J) = RSO(I,J)
C	  END DO
C	 END DO

C  ESTABLISH THE VALUES IN EACH DRUG'S PO COLUMN TO THE CORRESPONDING
C  COLUMN IN ARRAY BS.

C         DO I=1,ND
C          DO J=1,NDRUG
C           BS(I,J)=RS(I,2*J)
C	   END DO
C	  END DO


	ENDIF
    


      RETURN
      END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
        SUBROUTINE EVAL2(Y,IDUM,INTLIST,RPAR,IPAR)

C  THIS SUBROUTINE, CALLED BY IDCALCY, FINDS THE OUTPUT CONC. 
C  VECTOR, Y, EVALUATED AT PARAMETER VALUES IN VECTOR P, STORED
C  IN RPAR (P used to be PASSED DIRECTLY TO SUBROUTINE FUNC2
C  VIA COMMON/PARAMD. IDUM is the seed for the random number
C  generator.  The purpose of this subroutine, to be a clean
C  envelope around FUNC2 to request M noisy calculations be
C  stored in Y, is "almost" deprecated as most pertinent
C  information (except for IDUM) is now stored in RPAR and IPAR.

        integer, parameter :: MAXNUMEQ = 7

        double precision, dimension(594,MAXNUMEQ) :: Y
        integer IDUM
        integer, dimension(128) :: INTLIST
        double precision, dimension(257) :: RPAR
        integer, dimension(257) :: IPAR

        CALL FUNC2(Y,IDUM,INTLIST,RPAR,IPAR)

	RETURN
	END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C  SUBROUTINES USERANAL AND JACOB ARE FROM idm1x4.f.

        SUBROUTINE USERANAL(X,TIN,TOUT,RPAR,IPAR)

C  PURPOSE:
C	GIVEN X(TIN) THE PROGRAM CALCULATES X(TOUT), WHERE X IS THE 

C	STATE VECTOR FOR THE MODEL UNDER CONSIDERATION (AS DEFINED
C	BY THE D.E'S IN SUBROUTINE DIFFEQ). THESE D.E'S ARE SOLVED
C	USING THE LINPACK ROUTINE, VODE.FOR (AND ASSOCIATED ROUTINES).

C  	THIS ROUTINE CALLS SUBROUTINE DVODE (VODE.FOR) ONCE FOR EACH
C	POINT AT WHICH ANSWERS ARE DESIRED. NOTE THAT DVODE WILL CALL
C	SUBROUTINE DIFFEQ (SUPPLIED BY THE USER -- IT GIVES THE 
C	DIFF. EQS. OF THE MODEL, XP(I)) AND, IF THE USER DESIRES,
C	SUBROUTINE JACOB (SUPPLIED BY THE USER -- IT GIVES THE


C	JACOBIAN OF PARTIAL DERIVATIVES, dXP(I)/dX(J)). SUBROUTINES
C	DIFFEQ AND JACOB ARE IN THIS MODULE.

C  ARGUMENTS ON INPUT:
C           X - AN ARRAY OF DIMENSION 20. IN THE STANDARD 3-COMPARTMENT
C		MODEL,  X(1), X(2), X(3) SHOULD
C               BE SET TO THE AMOUNT OF DRUG IN THE ABSORBTION,
C               CENTRAL, AND PERIPHERAL COMPARTMENTS, RESPECTIVELY,
C               AT TIME T=TIN.
C         TIN - CURRENT VALUE OF TIME.
C        TOUT - TIME AT WHICH SOLUTION IS DESIRED.

C	VALUES FROM COMMON/TOUSER (FROM MAIN) WHICH WERE INPUT
C 	REAL-TIME BY THE USER (SEE DETAILS BELOW).
C	 NDIM = NO. OF STATES IN MODEL.
C	 MF = METHOD FLAG
C	 RTOL = SCALAR RELATIVE TOLERANCE PARAMETER.
C	 ATOL(I), I=1,NDIM = ABSOLUTE TOLERANCE PARAMETERS.

C  ARGUMENTS ON OUTPUT:
C           X - THE COMPARTMENT AMOUNTS AT T=TOUT.
C         TIN - SET AT TOUT

        IMPLICIT REAL*8(A-H,O-Z)

        double precision, dimension(257) :: RPAR
        integer, dimension(257) :: IPAR

        DIMENSION X(20),ATOL(20),RWORK(1002),IWORK(50)

C  AS OF MONT109.FOR, THE DIMENSION OF RWORK IS CHANGED FROM 300 TO
C  1002 TO ACCOMADATE AN NDIM (NEQ IN SUBROUTINE DVODE) OF UP TO 20. SO
C  CHANGE LRW BELOW TO 1002. SIMILARLY THE DIMENSION OF IWORK AND
C  LIW BELOW ARE CHANGED FROM 40 TO 50. 

	EXTERNAL DIFFEQ,JACOB

	COMMON/TOUSER/NDIM,MF,RTOL,ATOL



C  THE LOGIC OF THIS CODE IS TAKEN FROM PROGRAM DESOLV3.FOR (4/28/96).

C  FOLLOWING VALUES ARE SUPPLIED TO SUBROUTINE DVODE:

C  DIFFEQ  = NAME OF SUBROUTINE COMPLETED BY USER WHICH GIVES THE D.E.'S 
C	     OF THE MODEL. IT MUST BE DECLARED EXTERNAL.
C TIN      = The initial value of the independent variable.
C TOUT   = First point where output is desired (.ne. TIN). 
C ITOL   = 2 SINCE ATOL IS AN ARRAY.
C RTOL   = Relative tolerance parameter (scalar).
C ATOL   = Absolute tolerance parameter.
C          The estimated local error in X(i) will be controlled so as
C          to be roughly less (in magnitude) than
C             EWT(i) = RTOL*abs(X(i)) + ATOL(i)  SINCE ITOL = 2.
C          Thus the local error test passes if, in each component,
C          either the absolute error is less than ATOL (or ATOL(i)),
C          or the relative error is less than RTOL.
C          Use RTOL = 0.0 for pure absolute error control, and
C          use ATOL = 0.0 (or ATOL(i) = 0.0) for pure relative error


C          control.  Caution.. Actual (global) errors may exceed these
C          local tolerances, so choose them conservatively.
C ITASK  = 1 for normal computation of output values of X at t = TOUT.
C ISTATE = Integer flag (input and output).  Set ISTATE = 1.
C IOPT   = 0 to indicate no optional input used.
C RWORK  = Real work array of length at least..

C             20 + 16*NDIM                      for MF = 10,
C             22 +  9*NDIM + 2*NDIM**2           for MF = 21 or 22,
C             22 + 11*NDIM + (3*ML + 2*MU)*NDIM  for MF = 24 or 25.
C	... I'LL USE AN ARRAY OF 300 (PLENTY FOR NDIM .LE. 8).
C LRW    = Declared length of RWORK (in user's DIMENSION statement).
C IWORK  = Integer work array of length at least..
C             30        for MF = 10,
C             30 + NDIM  for MF = 21, 22, 24, or 25.
C          If MF = 24 or 25, input in IWORK(1),IWORK(2) the lower
C          and upper half-bandwidths ML,MU.
C	... I'LL USE AN ARRAY OF 40 (PLENTY FOR NDIM .LE. 8).
C LIW    = Declared length of IWORK (in user's DIMENSION).
C JACOB    = Name of subroutine COMPLETED BY USER for Jacobian matrix 
C	     (MF = 21 or 24). If used, this name must be declared 
C	     external.  If not used, pass a dummy name.
C MF     = Method flag.  Standard values are..


C          10 for nonstiff (Adams) method, no Jacobian used.

C          21 for stiff (BDF) method, user-supplied full Jacobian.
C          22 for stiff method, internally generated full Jacobian.
C          24 for stiff method, user-supplied banded Jacobian.
C          25 for stiff method, internally generated banded Jacobian.
C RPAR,IPAR = user-defined real and integer SCALARS OR arrays passed to 
C	      DIFFEQ AND JACOB.

C Note that the main program must declare arrays X, RWORK, IWORK,
C and possibly ATOL, RPAR, and IPAR.


C  THE FOLLOWING VALUES RETURN FROM CALLS TO SUBROUTINE DVODE.

C      X = Array of computed values of X vector (AT TIME TOUT).
C      T = Corresponding value of independent variable (normally TOUT).
C ISTATE = 2  if DVODE was successful, negative otherwise.
C          -1 means excess work done on this call. (Perhaps wrong MF.)
C          -2 means excess accuracy requested. (Tolerances too small.)
C          -3 means illegal input detected. (See printed message.)

C          -4 means repeated error test failures. (Check all input.)
C          -5 means repeated convergence failures. (Perhaps bad
C             Jacobian supplied or wrong choice of MF or tolerances.)
C          -6 means error weight became zero during problem. (Solution

C             component i vanished, and ATOL or ATOL(i) = 0.)

	ITOL=2
	ITASK=1
	ISTATE=1
	IOPT=0
	LRW = 1002
	LIW = 50

        CALL DVODE(DIFFEQ,NDIM,X,TIN,TOUT,ITOL,RTOL,ATOL,ITASK,ISTATE,
     1            IOPT,RWORK,LRW,IWORK,LIW,JACOB,MF,RPAR,IPAR)

c        IF (ISTATE .LT. 0) THEN
c         WRITE(*,16) ISTATE

c 16      FORMAT(///' On return from DVODE, ISTATE =',I3)
c	ENDIF



	TIN=TOUT

        RETURN
        END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
	SUBROUTINE JACOB(NDIM, T, X, ML, MU, PD, NRPD, RPAR, IPAR)

	IMPLICIT REAL*8(A-H,O-Z)
        COMMON/PARAMD/ P

        COMMON/INPUT/ R,B
        DIMENSION X(NDIM),PD(NRPD,NDIM),P(32),R(37),B(20)


C  THIS ROUTINE IS CALLED BY LINPACK ROUTINE DVODE (WHICH IS CALLED
C  BY ROUTINE USERANAL). THE USER CODES THE JACOBIAN MATRIX CALCULATIONS
C  OF THE MODEL (I.E., THE PARTIAL DERIVATIVES OF XP(I) W.R.T. X(I),

C  WHERE XP(I) WERE CODED INTO ROUTINE DIFFEQ).

C  SINCE THIS ROUTINE CAN'T BE MADE BY THE 'BOXES' PROGRAM AT THIS TIME,
C  IT WILL NOT BE USED. IT IS JUST A DUMMY ROUTINE, NEEDED BECAUSE
C  DVODE EXPECTS TO 'SEE' IT.

C  INPUT ARE:

C  NDIM = NO. OF STATES (DIMENSION OF PROBLEM).
C  T = CURRENT TIME.
C  X(I) = VALUE OF STATE I AT T, I=1,NDIM.
C  [ML,MU] = HALF BANDWIDTH PARAMETERS ... UNNEEDED IF MF = 21 OR 22
C            --> FULL JACOBIAN IS PROVIDED BY USER BELOW (SEE 
C	     DESOLV3.FOR CODE FOR DETAILS).
C	     NOTE THAT SINCE MF = 21 OR 22 IN THIS CASE, NRPD = NDIM.
C  R AND B VIA COMMON/INPUT.


C  OUTPUT ARE:

C  PD(I,J) = PARTIAL DERIVATIVE OF XP(I) W.R.T. X(J), WHERE XP(I)
C	     ARE CALCULATED IN ROUTINE DIFFEQ ABOVE.

        RETURN
        END							  
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C wmy2019.03 -- MAKEVEC is a subroutine in npag_utils.f90
C
C
	SUBROUTINE Old_MAKEVEC(NVAR,NOFIX,IRAN,X,VALFIX,PX)
	IMPLICIT REAL*8(A-H,O-Z)
	DIMENSION IRAN(32),X(150),VALFIX(20),PX(32)
 
C  THIS ROUTINE, CALLED BY SUBROUTINE SIMBIG, INPUTS NVAR, NOFIX, IRAN, 

C  X, AND VALFIX, AND RETURNS PX(I) = A COMBINATION OF THE VALUES IN X 
C  AND VALFIX IN THE PROPER ORDER (AS DETERMINED BY IRAN).
 
	NNNVAR=0
	NNNFIX=0
 
	DO I=1,NVAR+NOFIX
 
	IF(IRAN(I) .EQ. 1) THEN
	 NNNVAR=NNNVAR+1

	 PX(I) = X(NNNVAR)
	ENDIF
 
	IF(IRAN(I) .EQ. 0) THEN
	 NNNFIX=NNNFIX+1
	 PX(I) = VALFIX(NNNFIX)
	ENDIF
 
	END DO
 
	RETURN

	END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC 
C
C wmy2019.03 -- SHIFT is a subroutine in npag_utils.f90
C
      SUBROUTINE Old_SHIFT(TAU,ND,SIG,NDRUG,NADD,RS,
     1  INTLIST)

      use npag_utils, only: thesame

      IMPLICIT REAL*8(A-H,O-Z)

      integer, dimension(128) :: INTLIST

      DIMENSION SIG(5000),RS(5000,34),TAU(7),XIV(7,5000,2),
     1  BOL(7,5000,2),COV(20,5000,2),INDIV(7),INDBOL(7),INDCOV(20),
     2  TIMCAN(34)

      CHARACTER ERRFIL*20


      COMMON/ERROR/ERRFIL
C  COMMON/ERROR/ IS SUPPLIED TO ALL THE ROUTINES WHICH COULD WRITE TO
C  ERRFIL.


C  INPUT ARE:

C  TAU(I) =  THE VALUE OF THE TIMELAG FOR DRUG I.

C  ND = ORIGINAL NO. OF DOSE EVENTS. 
C  SIG(I) = TIME FOR ITH DOSE EVENT IN THE ORIGINAL DOSAGE REGIMEN,
C           I=1,ND.

C  NDRUG = NO. OF DRUGS (EACH HAS AN IV, FOLLOWED BY A BOLUS COLUMN).
C  NADD = NO. OF ADDITIONAL COVARIATES (EACH IS IN ITS OWN COLUMN
C         FOLLOWING THE IV/BOLUS COLUMNS.
C  RS(I,J) = "RATE" J FOR THE ITH DOSE EVENT IN THE ORIGINAL DOSAGE
C            REGIMEN; J=1,NI, I=1,ND, WHERE NI = 2*NDRUG + NADD

C            BECAUSE THE "RATES" CONTAIN, IN ORDER, 2 ENTRIES FOR
C            EACH DRUG (1 FOR THE IV AND 1 FOR THE BOLUS) AND 1 EACH
C            FOR THE NADD ADDITIONAL COVARIATES.


C  OUTPUT ARE:

C  ND, SIG, RS, AS ABOVE, EXCEPT FOR THE ALTERED DOSAGE REGIMEN.

C-----------------------------------------------------------------------

c  shift7 differs from shift6 as follows:

c  1. The dimensions related to the no. of dose events are changed from
c  500 to 5000. This is needed as shift7 is compiled with idm1x7.f, 
c  idm2x7.f, and idm3x7.f (part of the npageng16.f "engine"), which
c  accommodates steady state dose sets.



c  2. 3 lines testing for IF(SIG(IDOSE) .EQ. 0 .AND. IDOSE .GT. 1)
c  are replaced by 	  IF(SIG(IDOSE) .LE. 0 .AND. IDOSE .GT. 1)
c  since now a dose reset occurs when a dose time is 0 (a regular
c  time reset) or < 0 (a time reset occurring with a steady state
c  dose set indicator).

c-----------------------------------------------------------------------


C  SHIFT6.F                                                4/26/11

C  SHIFT5 HAS THE FOLLOWING CHANGES TO SHIFT5:

C  WT AND CCR ARE NO LONGER ASSUMED TO BE SPECIAL COVARIATES IN EACH
C  PATIENT'S WORKING COPY PATIENT DATA FILE. SO ALL DO LOOPS THAT 

C  START WITH  DO I = 1, 2+NADD ARE CHANGED TO START WITH DO I = 1,NADD,
C  BUT ONLY IF NADD .GT. 0.


C-----------------------------------------------------------------------

C  SHIFT5.F							9/11/09

C  SHIFT5 HAS THE FOLLOWING CHANGES TO SHIFT4.F.

C  THE ARGUMENT LIST CONTAINS TAU(.) RATHER THAN NTLAG(.). THIS
C  MEANS THAT TAU(I) IS INPUT DIRECTLY AS THE TIMELAG FOR DRUG I.
C  I.E., IT NO LONGER HAS TO BE CALCULATED AS A FUNCTION OF THE
C  PARAMETER ARRAY, P. BECAUSE OF THIS, P IS REMOVED FROM THE ARGUMENT
C  LIST AND THE DIMENSION STATEMENT. ALSO, NTLAG IS REMOVED FROM 
C  THT DIMENSION STATEMENT.

C  THE FIRST SET OF ID MODULES TO CALL SHIFT5.F ARE idm1x3.f, 

C  idm2x3.f, AND idm3x3.f

C-----------------------------------------------------------------------

C  SHIFT4.FOR							9/1/09


C  SHIFT4 HAS THE FOLLOWING CHANGES FROM SHIFT3:

C  1. NTLAG(I) CAN NOW BE NEGATIVE. IF THIS OCCURS, IT MEANS THAT THE
C  TIMELAG PARAMETER FOR DRUG I WILL BE EXP(P(-NTLAG(I)).


C  2. A BUG IS CORRECTED RELATED TO TIME "RESETS". PREVIOUSLY, IF THE
C  USER HAD A TIME "RESET" IN HIS DOSAGE REGIMEN, THIS ROUTINE WOULD
C  NOT WORK. THE REASON IS THAT IN THE CODE BELOW, EACH NEXT TIME
C  FOR AN IV, COVARIATE, OR BOLUS IS COMPARED TO THE PREVIOUSLY
C  ESTABLISHED TIME IN THE DOSAGE ARRAY (TIMNXT) AND IS A CANDIDATE
C  TO BE THE NEXT TIMNXT IF IT IS .GE. TIMNXT. SO IF A TIME RESET
C  VALUE OF 0 OCCURS, IT WILL NEVER BE A CANDIATE SINCE IT IS NOT
C  .GE. THE LAST TIMNXT. TO FIX THIS, AND MAKE SURE THAT A TIME
C  RESET VALUE OF 0 IS INCLUDED IN THE ADJUSTED DOSAGE BLOCK, THE
C  CODE WILL ADD TO EACH IV, BOLUS, AND COVARIATE ARRAY AN EXTRA
C  LINE WHEN A TIME RESET OCCURS. THIS LINE WILL HAVE A TIME OF
C  1.D19 (I.E., A LARGE VALUE WHICH REPRSENTS INFINITY); AND IT
C  WILL BE FOLLOWED BY A LINE WITH THE ADJUSTED RESET TIME (0 FOR
C  IVs AND COVARIATES, AND 0 + TAU(I) FOR BOLI.

C-----------------------------------------------------------------------

C  SHIFT3.FOR							5-23-02

C  SHIFT3 HAS MAJOR CHANGES FROM SHIFT2 TO ALLOW FOR MULTIPLE TIMELAGS,
C  ONE POTENTIALLY FOR EACH BOLUS INPUT OF UP TO 7 DRUGS.

C-----------------------------------------------------------------------

C  SHIFT2.FOR							11-16-99

C  SHIFT2 HAS THE FOLLOWING CHANGE FROM SHIFT. AT THE END OF THE 
C  FORMATION OF ARRAY XMAT, ALL ROWS WHICH HAVE 0 BOLUS INPUT AND THE
C  SAME OTHER DATA VALUES (EXCEPT TIME) AS THE PREVIOUS ROW ARE NOT
C  USED IN THE NEW ARRAY XMAT2 WHICH HAS ONLY NON-REDUNDANT ROWS.
C  THIS, THEORETICALLY, SHOULDN'T HAVE ANY EFFECT ON CALCULATIONS, BUT 
C  NUMERICALLY IT DOES SINCE WHEN THE DVODE ROUTINE SOLVES D.E.'S, IT 
C  INTEGRATES OVER DIFFERENT INTERVALS IF EXTRA DOSAGE LINES ARE 
C  INCLUDED.

C  EX: TIME   IV   BOLUS	TIME   IV   BOLUS
C       0    100     0		 0    100     0
C       5    100   1000		 2    100   1000  


C  NOTE THAT BOTH ABOVE CASES SHOULD GIVE THE SAME RESULTS IF THERE IS
C  A TIME-LAG = 3 IN THE 2ND CASE. BUT, AS THE CODE IS WRITTEN IN
C  SHIFT.FOR, THE 2ND CASE WOULD TRANSLATE TO THE FOLLOWING:

C	 TIME   IV   BOLUS 
C         0    100     0   
C         2    100     0
C         5    100   1000

C  ... AND THIS WOULD MEAN THAT THE 1ST INTEGRATION BY DVODE WOULD END
C      AT T = 2, RATHER THAN 5 (OR, E.G., 3 IF 3 WAS THE
C      FIRST OBSERVATION TIME). THIS CREATES NUMERICAL DIFFERENCES DUE
C      TO SMALL ROUNDOFF ERRORS WHICH CAN GROW SIGNIFICANTLY.

C-----------------------------------------------------------------------


C  SHIFT.FOR							7-27-99

C  SHIFT.FOR IS A MODULE WHICH INCLUDES SUBROUTINE SHIFT. SHIFT WILL BE
C  CALLED BY ROUTINES OF THE "BIG" NPEM AND IT2B PROGRAMS WHICH HAVE
C  SUBROUTINES FUNC, FUNC1, FUNC2, OR FUNC3 IN THEM.

C  SHIFT INPUTS THE DOSAGE REGIMEN VIA THE INPUT ARGUMENTS (SEE BELOW),
C  AND RETURNS AN ALTERED DOSAGE REGIMEN, WHICH HAS EACH BOLUS INPUT 

C  TIME INCREASED BY THE INPUT VALUE OF TAU (THE TIME LAG). NOTE THAT
C  EACH ROW WITH A NON-0 BOLUS INPUT VALUE WILL RESULT IN A NEW ROW IN

C  THE DOSAGE REGIMEN.

C-----------------------------------------------------------------------

C  PROCEDURE FOR THE DOSAGE REGIMEN MODIFICATION:


C  1. ESTABLISH TAU(I) AS THE TIMELAG FOR DRUG I'S BOLUS COLUMN.
C     NO. AS OF SHIFT5.F, THIS VALUE IS INPUT AS AN ARGUMENT.

C  2. ESTABLISH THE IV VALUES AND TIMES INTO XIV(I,J,K). IN PARTICULAR,
C     XIV(I,J,2) IS THE JTH IV VALUE FOR DRUG I, AND XIV(I,J,1) IS THE 
C     TIME THIS IV VALUE FIRST OCCURRED. SET THE LAST TIME TO 1.D29 AS
C     AN INDICATOR THAT THERE ARE NO MORE ENTRIES IN THE ARRAY.

C  3. ESTABLISH THE COVARIATE VALUES AND TIMES INTO COV(I,J,K). IN 
C     PARTICULAR, COV(I,J,2) IS THE JTH VALUE FOR COVARIATE I, AND 
C     COV(I,J,1) IS THE TIME THIS COV VALUE FIRST OCCURRED. SET THE 
C     LAST TIME TO 1.D29 AS AN INDICATOR THAT THERE ARE NO MORE ENTRIES
C     IN THE ARRAY.


C  4. ESTABLISH THE BOLUS VALUES AND TIMES INTO BOL(I,J,K).
C     IN PARTICULAR, BOL(I,J,2) IS THE JTH BOLUS VALUE FOR DRUG I, AND
C     BOL(I,J,1) IS THE TIME THIS BOLUS OCCURRED. THE TIMES FOR EACH
C     BOLUS VALUE ARE THOSE ADJUSTED TIMES FROM THE ASSOCIATED TIMELAGS
C     TAU(I),I=1,NDRUG, FROM STEP 1. SET THE LAST TIME TO 1.D29 AS AN
C     INDICATOR THAT THERE ARE NO MORE ENTRIES IN THE ARRAY.

C  5. REASSIGN THE VALUES IN IV, BOL, AND COV TO THE APPROPRIATE ENTRIES

C     OF RS, KEEPING TRACK OF THE RUNNING INDEX, ND, OF DOSE EVENTS. IF

C     ND EXCEEDS 5000, STOP THE PROGRAM WITH A MESSAGE TO THE USER. ALSO
C     REASSIGN THE CORRESPONDING TIME VALUES TO ARRAY SIG.


C  STEP 1.

C  NOTHING TO DO. AS OF SHIFT5.F, TAU(I), I=1,NDRUG, IS INPUT AS
C  AN ARGUMENT TO THIS ROUTINE.



C  STEP 2:

C  ESTABLISH THE IV VALUES AND TIMES INTO XIV(I,J,K). IN PARTICULAR,
C  XIV(I,J,2) IS THE JTH IV VALUE FOR DRUG I, AND XIV(I,J,1) IS THE 
C  TIME THIS IV VALUE FIRST OCCURRED.

	DO I = 1,NDRUG

C  ESTABLISH XIV(I,J,K) FOR DRUG I'S IV. PRESET THE LAST VALUE TO
C  -99 SO THAT THE FIRST VALUE WILL BE DIFFERENT AND THEREFORE ENGAGE 
C  THE LOGIC (WHICH ONLY WRITES A ROW INTO THE ARRAY IF THE VALUE IS
C  DIFFERENT THAN THE PREVIOUS VALUE). 

C*** MODIFICATION IN SHIFT4.F: IF A TIME RESET OCCURS (I.E., A
C    SIG(IDOSE) = 0, WHERE IDOSE > 1), IT WILL BE HANDLED BY ASSIGNING 
C    AN EXTRA TIME VALUE OF 1.D19 (I.E., A LARGE VALUE REPRESENTING
C    TIME = INFINITY) TO THE IV TIME ARRAY. THEN THE REST OF THE
C    THE IV TIME ARRAY WILL BE ESTABLISHED WITH THE REST OF THE VALUES
C    IN SIG, STARTING, OF COURSE, WITH THE TIME RESET VALUE OF 0.


C    THE SAME LOGIC WILL APPLY TO THE COVARIATES AND THE BOLI.


C  NOTE THAT IND WILL BE THE RUNNING INDEX OF THE LATEST ENTRY INTO 
C  THE ARRAY. PLACE 1.D29 INTO THE LAST TIME ENTRY OF EACH SUB-ARRAY 
C  AS AN INDICATOR THAT THERE ARE NO MORE ENTRIES.

	 XIV(I,1,1) = 1.D29
	 IND = 0
	 VALAST = -99.D0

C  FOR DRUG I, THE IV VALUE IS IN COLUMN 2*I-1 OF ARRAY RS.


	  
	DO IDOSE = 1,ND

	  RR = RS(IDOSE,2*I-1)

C*** MODIFICATION IN SHIFT7.F: A TIME RESET IS NOW DESIGNATED BY A
C  SIG(IDOSE) .LE. 0, RATHER THAN JUST .EQ. 0 (SINCE A STEADY STATE
C  DOSE INDICATOR HAS A NEGATIVE DOSE TIME).

	  IF(SIG(IDOSE) .LE. 0 .AND. IDOSE .GT. 1) THEN


C  THIS REPRESENTS A TIME "RESET". IN THIS CASE, AS INDICATED ABOVE,
C  PUT IN AN EXTRA ROW FOR THE IV REPRESENTING A VERY LARGE TIME
C  AND THE SAME IV VALUE AS THE PREVIOUS VALUE. THEN PUT IN THE
C  LINE REPRESENTING THE RESET TIME OF 0.
	
	    IND = IND + 1
	    XIV(I,IND,1) = 1.D19
	    XIV(I,IND,2) = XIV(I,IND-1,2)

	    IND = IND + 1

C*** MODIFICATION IN SHIFT7.F. SET THE NEXT XIV(I,IND,1) TO BE

C  SIG(IDOSE), NOT 0, SINCE SIG(IDOSE) MAY BE < 0 (SINCE A STEADY STATE
C  DOSE INDICATOR HAS A NEGATIVE DOSE TIME).

	    XIV(I,IND,1) = SIG(IDOSE) 
	    XIV(I,IND,2) = RR
	    XIV(I,IND+1,1) = 1.D29
	    VALAST = RR

	    GO TO 200

	  ENDIF

C  TO GET HERE, THIS DOSE LINE DOES NOT REPRESENT A TIME RESET.

	  IF(RR .NE. VALAST) THEN
         IND = IND + 1
	   XIV(I,IND,1) = SIG(IDOSE)
	   XIV(I,IND,2) = RR
	   XIV(I,IND+1,1) = 1.D29
	   VALAST = RR
	  ENDIF

  200     CONTINUE

	 END DO

C  THE ABOVE END DO IS FOR THE  DO IDOSE = 1,ND  LOOP.


	END DO

C  THE ABOVE END DO IS FOR THE 	DO I = 1,NDRUG  LOOP.


C  STEP 3:

C  ESTABLISH THE COVARIATE VALUES AND TIMES INTO COV(I,J,K). IN 
C  PARTICULAR, COV(I,J,2) IS THE JTH VALUE FOR COVARIATE I, AND 
C  COV(I,J,1) IS THE TIME THIS COV VALUE FIRST OCCURRED. SET THE 
C  LAST TIME TO 1.D29 AS AN INDICATOR THAT THERE ARE NO MORE ENTRIES
C  IN THE ARRAY.

        IF(NADD .GT. 0) THEN

	DO I = 1, NADD



C  ESTABLISH COV(I,J,K) FOR COVARIATE NO. 
C  PRESET THE LAST VALUE TO -99 SO THAT THE FIRST VALUE WILL BE 
C  DIFFERENT AND THEREFORE ENGAGE THE LOGIC (WHICH ONLY WRITES A ROW 
C  INTO THE ARRAY IF THE VALUE IS DIFFERENT THAN THE PREVIOUS VALUE). 
C  NOTE THAT IND WILL BE THE RUNNING INDEX OF THE LATEST ENTRY INTO THE 
C  ARRAY. PLACE 1.D29 INTO THE LAST TIME ENTRY OF EACH SUB-ARRAY AS AN 
C  INDICATOR THAT THERE ARE NO MORE ENTRIES.

	 COV(I,1,1) = 1.D29
	 IND = 0
	 VALAST = -99.D0

C  FOR COVARIATE I, THE VALUE IS IN COLUMN 2*NDRUG+I OF ARRAY RS.	  

	 DO IDOSE = 1,ND

	  RR = RS(IDOSE,2*NDRUG+I)

C*** MODIFICATION IN SHIFT7.F: A TIME RESET IS NOW DESIGNATED BY A
C  SIG(IDOSE) .LE. 0, RATHER THAN JUST .EQ. 0 (SINCE A STEADY STATE
C  DOSE INDICATOR HAS A NEGATIVE DOSE TIME).

	  IF(SIG(IDOSE) .LE. 0 .AND. IDOSE .GT. 1) THEN


C  THIS REPRESENTS A TIME "RESET". IN THIS CASE, AS INDICATED ABOVE,
C  PUT IN AN EXTRA ROW FOR THE COVARIATE REPRESENTING A VERY LARGE TIME
C  AND THE SAME COV VALUE AS THE PREVIOUS VALUE. THEN PUT IN THE
C  LINE REPRESENTING THE RESET TIME OF 0.
	
	    IND = IND + 1
	    COV(I,IND,1) = 1.D19
	    COV(I,IND,2) = COV(I,IND-1,2)

	    IND = IND + 1

C*** MODIFICATION IN SHIFT7.F. SET THE NEXT COV(I,IND,1) TO BE
C  SIG(IDOSE), NOT 0, SINCE SIG(IDOSE) MAY BE < 0 (SINCE A STEADY STATE
C  DOSE INDICATOR HAS A NEGATIVE DOSE TIME).


	    COV(I,IND,1) = SIG(IDOSE) 
	    COV(I,IND,2) = RR
	    COV(I,IND+1,1) = 1.D29

	    VALAST = RR

	    GO TO 300

	  ENDIF

C  TO GET HERE, THIS DOSE LINE DOES NOT REPRESENT A TIME RESET.

	  IF(RR .NE. VALAST) THEN
           IND = IND + 1
	   COV(I,IND,1) = SIG(IDOSE)
	   COV(I,IND,2) = RR
	   COV(I,IND+1,1) = 1.D29
	   VALAST = RR
	  ENDIF

  300     CONTINUE

	 END DO


C  THE ABOVE END DO IS FOR THE   DO IDOSE = 1,ND  LOOP.


	END DO

C  THE ABOVE END DO IS FOR THE  DO I = 1, NADD  LOOP.

        ENDIF

C  THE ABOVE ENDIF IS FOR THE   IF(NADD .GT. 0)  CONDITION.




C  STEP 4:

C  ESTABLISH THE BOLUS VALUES AND TIMES INTO BOL(I,J,K). IN PARTICULAR, 
C  BOL(I,J,2) IS THE JTH BOLUS VALUE FOR DRUG I, AND BOL(I,J,1) IS THE
C  ADJUSTED (USING THE ASSOCIATED TIMELAGS TAU(I),I=1,NDRUG) TIME THIS 
C  BOLUS OCCURRED. 

	DO I = 1,NDRUG

C  ESTABLISH BOL(I,J,K) FOR DRUG I'S BOLUS. EACH ARRAY IS FILLED ONLY

C  WITH NON-0 BOLUS VALUES. NOTE THAT IND WILL BE THE RUNNING INDEX OF 
C  THE LATEST ENTRY INTO THE ARRAY. PLACE 1.D29 INTO THE LAST TIME ENTRY 
C  OF EACH SUB-ARRAY AS AN INDICATOR THAT THERE ARE NO MORE ENTRIES.

	 BOL(I,1,1) = 1.D29
	 IND = 0


C  FOR DRUG I, THE BOLUS VALUE IS IN COLUMN 2*I OF ARRAY RS.	  

	 DO IDOSE = 1,ND

	  RR = RS(IDOSE,2*I)

C*** MODIFICATION IN SHIFT7.F: A TIME RESET IS NOW DESIGNATED BY A
C  SIG(IDOSE) .LE. 0, RATHER THAN JUST .EQ. 0 (SINCE A STEADY STATE

C  DOSE INDICATOR HAS A NEGATIVE DOSE TIME).

	  IF(SIG(IDOSE) .LE. 0 .AND. IDOSE .GT. 1) THEN

C  THIS REPRESENTS A TIME "RESET". IN THIS CASE, AS INDICATED ABOVE,
C  PUT IN AN EXTRA ROW FOR THE BOLUS REPRESENTING A VERY LARGE TIME
C  AND AN ACCOMPANYING BOLUS VALUE OF 0. THEN PUT IN THE
C  LINE REPRESENTING THE RESET TIME OF 0 + THE TIMELAG ... IF
C  RR .NE. 0.
	
	    IND = IND + 1
	    BOL(I,IND,1) = 1.D19
	    BOL(I,IND,2) = 0.D0


	    IND = IND + 1


C*** THE FOLLOWING CODE IS CHANGED IN MONT106.FOR. IT IS BASED ON 
C  SHIFT9.F IN WHICH, UNLIKE IN SHIFT7.F, BOLUS VALUES CAN NOW BE
C  INCLUDED IN STEADY STATE DOSE SETS.

C  LOGIC IS NOW AS FOLLOWS:

C  IF SIG(IDOSE) = 0, THIS IS A TIME RESET WHICH IS NOT THE START OF
C     A STEADY STATE DOSE SET. IN THIS CASE, A BOLUS WITH A TIMELAG OF
C     TAU(I) WILL OCCUR AT SIG(IDOSE) + TAU(I) = TAU(I).

C  IF SIG(IDOSE) < 0, THIS IS A TIME RESET WHICH IS THE START OF A
C     STEADY STATE DOSE SET. IN THIS CASE:
C     THE BOLUS TIME WILL BE TAU(I) ONLY IF BOTH TAU(I) AND RR
C     ARE NOT 0. OTHERWISE, IT WILL BE SIG(IDOSE).
C     REASON: IF RR = 0, THERE IS NO BOLUS TO BE GIVEN, SO IT WOULD
C     BE SILLY TO INCLUDE AN EXTRA LINE IN THE DOSAGE REGIMEN WITH
C     A 0 BOLUS (AND IT WOULD VERY SLIGHTLY CHANGE THE RESULTS SINCE
C     THE NUMERICAL INTEGRATION THEN HAS TO INTEGRATE THROUGH AN EXTRA
C     TIME). IN AN EXAMPLE (REMARK 4.b IN NPAG109.EXP, THIS CHANGED THE
C     VALUES IN THE LOG-LIKELIHOODS OUT IN THE 13TH DIGIT, BUT SOME 
C     VALUES IN THE DENSITY FILE WERE CHANGED IN THE 4TH DIGIT).

C     ALSO, IF TAU(I) = 0, THE BOLUS HAS NO TIMELAG AND THEREFORE
C     OCCURS AT SIG(IDOSE).

C  THE FOLLOWING EXAMPLE SHOWS WHY A NON-0 BOLUS IN A STEADY STATE DOSE
C  SET, WITH TAU(I) .NE. 0, MUST BE GIVEN AT TAU(I) AND NOT
C  SIG(IDOSE) + TAU(I).

C  EX: IF SIG(IDOSE) = -12, IT MEANS THAT A STEADY STATE DOSE SET IS
C      STARTING WITH AN INTERDOSE INTERVAL OF 12 HOURS. SO, IF A 
C      BOLUS WITH A TLAG OF 1.5 HOURS IS GIVEN, ITS TIME MUST BE
C      1.5, NOT -12 + 1.5 = -10.5. REASON: AFTER THE SIG(IDOSE) OF
C      -12 IS CONVERTED IN SUBROUTINE FUNC2 TO 0, THE 1.5 WILL CORRECTLY
C      INDICATE THAT THE BOLUS IS GIVEN 1.5 HOURS AFTER THE START OF THE
C      STEADY STATE DOSE SET. ALSO, A TIME OF -10.5 WOULD COMPLETELY
C      SCREW UP THE FUNC2 LOGIC WHICH WOULD INTERPRET IT AS THE START
C      OF ANOTHER STEADY STATE DOSE SEST.

C      ON THE OTHER HAND, IF A DRUG HAS A TAU(I) = 0, IT CANNOT SHOW
C      UP AS OCCURRING AT TAU(I) = 0 SINCE THIS WILL COMPLETELY SCREW
C      UP FUNC2'S LOGIC, WHICH WILL INTERPRET THE TIME OF 0 AS A
C      TIME RESET EVENT. IN THIS CASE, THE BOLUS OCCURS AT THE START OF
C      THE STEADY STATE DOSE SET, I.E., AT SIG(IDOSE) = -12, WHICH WILL
C      BE CONVERTED TO 0 BY FUNC2).


      CALL THESAME(SIG(IDOSE),0.D0,ISAME1)
      CALL THESAME(TAU(I),0.D0,ISAME2)
      CALL THESAME(RR,0.D0,ISAME3)

      IF(ISAME1 .EQ. 1) BOL(I,IND,1) = TAU(I)
C  NOTE THAT, TECHNICALLY, WE SHOULD SET BOL(I,IND,1) = SIG(IDOSE) = 0
C  IF RR = 0, SINCE THERE IS NO REASON TO HAVE AN EXTRA LINE IN THE
C  DOSAGE REGIMEN FOR A 0 BOLUS ... BUT CHANGING THIS WOULD CHANGE
C  VERY SLIGHTLY THE RESULTS IN A 0 BOLUS CASE SINCE THERE WOULD BE ONE
C  LESS DOSAGE LINE FOR THE NUMERICAL INTEGRATOR TO INTEGRATE THROUGH,
C  SO THE CODE WILL BE LEFT AS IS, FOR CONSISTENCY SAKE.


      IF(ISAME1 .EQ. 0) THEN

       BOL(I,IND,1) = SIG(IDOSE)
       IF(ISAME2 .EQ. 0 .AND. ISAME3 .EQ. 0) BOL(I,IND,1) = TAU(I)
      ENDIF


  

	    BOL(I,IND,2) = RR
	    BOL(I,IND+1,1) = 1.D29
	    VALAST = RR

	    GO TO 400

	  ENDIF

C  TO GET HERE, THIS DOSE LINE DOES NOT REPRESENT A TIME RESET.


	  IF(RR .NE. 0.D0) THEN

           IND = IND + 1

C  *** CHANGE FOR MONT105.FOR.
C  NOW BOLUS VALUES CAN OCCUR IN STEADY STATE DOSES. AND IF THEY DO,
C  THE FIRST ONE MUST OCCUR AT TIME TAU(I), NOT SIG(IDOSE) + TAU(I)
C  AS THE FOLLOWING EXAMPLE ILLUSTRATES:
C  EX: SIG(1) = -12 INDICATING THAT THE STEADY STATE DOSE SET HAS
C      AN INTERDOSE INTERVAL OF 12 HOURS. TAU(1) = 1.5 -->
C      DRUG 1 HAS A TIMELAG OF 1.5 HOURS. SO, IF THE FIRST BOLUS TIME IS
C      SET =  SIG(1) + TAU(1) = -12 + 1.5 = -10.5, THIS WILL SCREW
C      UP THE FUNC2 LOGIC SINCE IN THAT CODE, THE FIRST TIME OF
C      -12 WILL BE RESET TO BE 0, AND THIS WILL BE FOLLOWED BY -10.5,

C      WHICH WILL LOOK LIKE THE START OF ANOTHER STEADY STATE DOSE
C      SET. INSTEAD, SET FIRST BOLUS TIME = TAU(1) = 1.5, WHICH IS
C      CORRECT SINCE IT OCCURS 1.5 HOURS AFTER THE STEADY STATE DOSE
C      STARTS.

         IF(SIG(IDOSE) .GE. 0.D0) BOL(I,IND,1) = SIG(IDOSE) + TAU(I)
         IF(SIG(IDOSE) .LT. 0.D0) BOL(I,IND,1) = TAU(I)

	   BOL(I,IND,2) = RR
	   BOL(I,IND+1,1) = 1.D29
	  ENDIF

  400     CONTINUE

	 END DO

C  THE ABOVE END DO IS FOR THE  DO IDOSE = 1,ND  LOOP.


	END DO


C  THE ABOVE END DO IS FOR THE  DO I = 1,NDRUG  LOOP.


C  STEP 5:

C  REASSIGN THE VALUES IN IV, BOL, AND COV TO THE APPROPRIATE ENTRIES
C  OF RS, KEEPING TRACK OF THE RUNNING INDEX, ND, OF DOSE EVENTS. IF
C  ND EXCEEDS 5000, STOP THE PROGRAM WITH A MESSAGE TO THE USER. ALSO,
C  REASSIGN THE CORRESPONDING TIME VALUES TO ARRAY SIG.




	NI = 2*NDRUG + NADD
	ND = 0
        INTLIST(7) = NI
        INTLIST(8) = ND

C  GO THROUGH THE ARRAYS IV, BOL, AND COV TO DETERMINE THE NEXT
C  LOWEST DOSE TIME. PUT THIS VALUE INTO RS, ALONG WITH THE 
C  CORRESPONDING VALUES FOR THE IV'S, THE BOLI, AND THE COVARIATES.

C  IN THE LOOP BELOW, IT IS NECESSARY TO KNOW TO WHAT POINT IN THE
C  IV, BOL, AND COV ARRAYS THE TIMES AND VALUES HAVE ALREADY BEEN 

C  STORED INTO RS. THESE INDICES ARE INDIV(I), I=1,NDRUG; INDBOL(I),
C  I=1,NDRUG; AND INDCOV(I), I=1,NADD, RESPECTIVELY. E.G., 
C  INDIV(2) = 4 MEANS THAT ALL VALUES IN THE IV, BOL, AND COV ARRAYS, 
C  THROUGH THE 4TH TIME FOR IV DRUG 2 (I.E., THROUGH TIME = XIV(2,4,1))
C  HAVE BEEN OR ARE ABOUT TO BE STORED INTO THE RS ARRAY.


C  SO PRESET ALL THESE INDEX INDICATORS = 1, AND INITIALIZE THE 
C  CURRENT DOSE TIME TO A NEGATIVE NO. SO THAT THE FIRST TIME

C  THROUGH THE FOLLOWING LOOP WILL ENGAGE THE LOGIC.


	DO I = 1,NDRUG
	 INDIV(I) = 1
	 INDBOL(I) = 1
	END DO

        IF(NADD .GT. 0) THEN
         DO I = 1,NADD
          INDCOV(I) = 1
         END DO
        ENDIF


        TIMNXT = -9999999.D0


  100   CONTINUE

C  FIND THE NEXT LOWEST TIME AMONG THE IV, BOL, AND COV ARRAYS.
C  ESTABLISH INTO TIMCAN(J) THE CANDIDATES FOR THE NEXT DOSE TIME
C  (AND CORRESPONDING VALUES FOR THE IV'S, BOLI, AND COVARIATES) TO
C  BE PUT INTO RS.


        DO I = 1,NDRUG
	 IF(XIV(I,INDIV(I),1) .GT. TIMNXT) TIMCAN(I)=XIV(I,INDIV(I),1)
	 IF(XIV(I,INDIV(I),1) .EQ. TIMNXT) TIMCAN(I)=XIV(I,INDIV(I)+1,1)
	END DO

        DO I = 1,NDRUG
	 IF(BOL(I,INDBOL(I),1) .GT. TIMNXT) TIMCAN(NDRUG+I) = 
     1    BOL(I,INDBOL(I),1)
	 IF(BOL(I,INDBOL(I),1) .EQ. TIMNXT) TIMCAN(NDRUG+I) = 
     1    BOL(I,INDBOL(I)+1,1)
	END DO

        IF(NADD .GT. 0) THEN
         DO I = 1,NADD
          IF(COV(I,INDCOV(I),1) .GT. TIMNXT) TIMCAN(2*NDRUG+I) = 
     1     COV(I,INDCOV(I),1)
          IF(COV(I,INDCOV(I),1) .EQ. TIMNXT) TIMCAN(2*NDRUG+I) = 
     1     COV(I,INDCOV(I)+1,1)
         END DO
        ENDIF


C  FIND THE NEXT TIMNXT, THE MINIMUM VALUE AMONG THE NI ENTRIES IN 
C  TIMCAN. TIMNXT WILL BE THE NEXT TIME TO BE PUT INTO ARRAY RS (ALONG 
C  WITH ALL THE CORRESPONDING IV'S, BOLI, AND COVARIATE VALUES). IF 
C  TIMNXT = 1.D29, IT IS BECAUSE THERE ARE NO FURTHER VALUES TO BE PUT 
C  INTO RS (I.E, THE PROCESS IS FINISHED).


	TIMNXT = TIMCAN(1)
	DO I = 2,NI
	 IF(TIMCAN(I) .LT. TIMNXT) TIMNXT = TIMCAN(I)
	END DO

	IF(TIMNXT .EQ. 1.D29) RETURN

C  SINCE TIMNXT < 1.D29, THERE ARE MORE VALUES TO BE PUT INTO RS.
C  GO THROUGH ALL THE SUBARRAYS AND PUT IN VALUES AS FOLLOWS. IF THE
C  CURRENT TIME FOR AN IV, BOLUS, OR COVARIATE IS THE SAME AS TIMNXT, 
C  PUT THE CORRESPONDING IV, BOLUS, OR COVARIATE VALUE INTO RS, AND 
C  INCREASE THE INDEX FOR THAT SUB-ARRAY TO THE NEXT VALUE. IF THE
C  CURRENT TIME FOR AN IV OR A COVARIATE IS .GT. TIMNXT, PUT THE IV OR 
C  COVARIATE VALUE FROM THE PREVIOUS ROW INTO RS, AND LEAVE THE INDEX 
C  UNCHANGED. IF THE CURRENT TIME FOR A BOLUS IS .GT. TIMNXT, PUT 0.0 
C  INTO RS (I.E., BOLUS VALUES ARE INSTANTANEOUS, WHEREAS IV AND 
C  COVARIATE VALUES CONTINUE UNTIL CHANGED), AND LEAVE THE INDEX
C  UNCHANGED.


C  TEST FOR TIMNXT = 1.D19, WHICH INDICATES A TIME RESET.

	IF(TIMNXT .EQ. 1.D19) THEN

C  TIMNXT = 1.D19 MEANS THAT THE NEXT TIME IN EACH ARRAY IS THE
C  TIME AT OR AFTER THE RESET. SO INCRASE ALL THE ARRAY INDICES BY
C  1, RESET TIMNXT TO A NEGATIVE NO. AND RETURN TO LABEL 100.

	 DO I = 1,NDRUG
	  INDIV(I) = INDIV(I) + 1
	  INDBOL(I) = INDBOL(I) + 1
	 END DO


        IF(NADD .GT. 0) THEN
         DO I = 1,NADD
          INDCOV(I) = INDCOV(I) + 1
         END DO
        ENDIF
	 


	 TIMNXT = -9999999.D0
	
	 GO TO 100

	ENDIF


	ND = ND+1
        INTLIST(8) = ND

	IF(ND .GT. 5000) THEN

C  IF ND > 5000, STOP WITH A MESSAGE TO THE USER THAT THE
C  PROGRAM ONLY ALLOWS A TOTAL OF 5000 DOSE EVENTS.

   10	 WRITE(*,1) ND


    1   FORMAT(/' THE NUMBER OF DOSE EVENTS, AFTER TAKING INTO'/
     1' ACCOUNT DIFFERING TIMES DUE TO TIMELAGS IS ',I6,', MORE THAN'/
     2' THE ALLOWABLE MAXIMUM OF 5000. THE PROGRAM IS STOPPING. PLEASE'/
     3' RERUN WITH PATIENTS HAVING FEWER DOSE EVENTS, OR WITH FEWER'/
     4' TIMELAG VALUES SELECTED AS FIXED OR RANDOM PARAMETERS.'//)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,1) ND
        CLOSE(42)



       CALL PAUSE
	 STOP

	ENDIF

C  ND .LE. 5000, SO CONTINUE. FOR THIS DOSE EVENT, PUT IN THE CURRENT 
C  TIME, AND THE CORRESPONDING IV, BOLUS, AND COVARIATE VALUES. 


	SIG(ND) = TIMNXT

        DO I = 1,NDRUG

	 IF(TIMNXT .LT. XIV(I,INDIV(I),1)) THEN
	  RS(ND,2*I-1) = RS(ND-1,2*I-1)
	 ENDIF

	 IF(TIMNXT .EQ. XIV(I,INDIV(I),1)) THEN
	  RS(ND,2*I-1) = XIV(I,INDIV(I),2)
	  INDIV(I) = INDIV(I) + 1
	 ENDIF

	 IF(TIMNXT .LT. BOL(I,INDBOL(I),1)) THEN
	  RS(ND,2*I) = 0.D0
	 ENDIF

	 IF(TIMNXT .EQ. BOL(I,INDBOL(I),1)) THEN
	  RS(ND,2*I) = BOL(I,INDBOL(I),2)
	  INDBOL(I) = INDBOL(I) + 1
	 ENDIF




	END DO




        IF(NADD .GT. 0) THEN
         DO I = 1,NADD
          IF(TIMNXT .LT. COV(I,INDCOV(I),1))
     1     RS(ND,2*NDRUG+I) = RS(ND-1,2*NDRUG+I)
          IF(TIMNXT .EQ. COV(I,INDCOV(I),1)) THEN
           RS(ND,2*NDRUG+I) = COV(I,INDCOV(I),2)
           INDCOV(I) = INDCOV(I) + 1
          ENDIF
         END DO

        ENDIF


	GO TO 100


	END

C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
	SUBROUTINE GETCHAR(JSUB,CHARSUB)
	CHARACTER CHARSUB*5
	CHARACTER*1 A,B,C,D,E

C  THIS ROUTINE, CALLED BY SIMBIG, INPUTS THE INTEGER JSUB
C  (BETWEEN 1 AND 99999), AND OUTPUTS THE 5-CHARACTER EQUIVALENT,
C  CHARSUB.

	ILEFT = JSUB

	I5 = ILEFT/10000
	ILEFT = ILEFT - I5*10000
	I4 = ILEFT/1000

	ILEFT = ILEFT - I4*1000
	I3 = ILEFT/100

	ILEFT = ILEFT - I3*100
	I2 = ILEFT/10
 	ILEFT = ILEFT - I2*10
	I1 = ILEFT

C  CONVERT THIS TO THE CHARACTER EQUIVALENT. 

	IF(I5 .EQ. 1) A='1'
	IF(I5 .EQ. 2) A='2'
	IF(I5 .EQ. 3) A='3'
	IF(I5 .EQ. 4) A='4'
	IF(I5 .EQ. 5) A='5'
	IF(I5 .EQ. 6) A='6'

	IF(I5 .EQ. 7) A='7'
	IF(I5 .EQ. 8) A='8'
	IF(I5 .EQ. 9) A='9'
	IF(I5 .EQ. 0) A='0'

	IF(I4 .EQ. 1) B='1'
	IF(I4 .EQ. 2) B='2'
	IF(I4 .EQ. 3) B='3'
	IF(I4 .EQ. 4) B='4'

	IF(I4 .EQ. 5) B='5'
	IF(I4 .EQ. 6) B='6'
	IF(I4 .EQ. 7) B='7'
	IF(I4 .EQ. 8) B='8'
	IF(I4 .EQ. 9) B='9'
	IF(I4 .EQ. 0) B='0'

	IF(I3 .EQ. 1) C='1'

	IF(I3 .EQ. 2) C='2'
	IF(I3 .EQ. 3) C='3'
	IF(I3 .EQ. 4) C='4'
	IF(I3 .EQ. 5) C='5'
	IF(I3 .EQ. 6) C='6'
	IF(I3 .EQ. 7) C='7'
	IF(I3 .EQ. 8) C='8'
	IF(I3 .EQ. 9) C='9'
	IF(I3 .EQ. 0) C='0'

	IF(I2 .EQ. 1) D='1'
	IF(I2 .EQ. 2) D='2'
	IF(I2 .EQ. 3) D='3'
	IF(I2 .EQ. 4) D='4'
	IF(I2 .EQ. 5) D='5'
	IF(I2 .EQ. 6) D='6'
	IF(I2 .EQ. 7) D='7'

	IF(I2 .EQ. 8) D='8'
	IF(I2 .EQ. 9) D='9'
	IF(I2 .EQ. 0) D='0'


	IF(I1 .EQ. 1) E='1'
	IF(I1 .EQ. 2) E='2'
	IF(I1 .EQ. 3) E='3'
	IF(I1 .EQ. 4) E='4'
	IF(I1 .EQ. 5) E='5'
	IF(I1 .EQ. 6) E='6'
	IF(I1 .EQ. 7) E='7'

	IF(I1 .EQ. 8) E='8'
	IF(I1 .EQ. 9) E='9'
	IF(I1 .EQ. 0) E='0'


	CHARSUB = A//B//C//D//E


	RETURN
	END

C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C wmy20190325 -- DVODTOT, BLAS, LAPACK, and emint, removed.
C
C Montbig now uses same DVODE and related libraries as
C NPAG.  These should be in ./NPAG/engine/.../dvode_v1.f90
C and 0blasnpag.f, which are linked with this routine at
C runtime. Montbig also uses two functions from the LAPACK
C package, these are in emint_b01.f (what's with the "b"?),
C which is also linked with this routine at runtime.
C See SIMrun.R for implementation detail (search for
C "enginecompile").
C
C TODO
C   Need a reasonable ODE validation run.
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
	SUBROUTINE GETNUMEQ(NUMEQT,INTLIST,RPAR,IPAR)

	IMPLICIT REAL*8(A-H,O-Z)

        integer, dimension(128) :: INTLIST
        double precision, dimension(257) :: RPAR
        integer, dimension(257) :: IPAR

	DIMENSION XX(14)
	CHARACTER READLINE*78,ERRFIL*20
      COMMON/ERROR/ERRFIL
C  COMMON/ERROR/ IS SUPPLIED TO ALL THE ROUTINES WHICH COULD WRITE TO
C  ERRFIL.

C  THIS SUBROUTINE READS THE PATIENT DATA FILE (FILE 21) TO FIND THE 
C  NO. OF OUTPUT EQUATIONS (NUMEQT).

C  PRINT MESSAGE TO THE USER THAT IF HE CHANGES HIS WORKING COPY 
C  FILE IN SUBROUTINE VERIF1, HE MUST MAKE SURE THAT THE NEW WORKING
C  COPY FILE HAS THE SAME NO. OF OUTPUT EQUATIONS AS THE FILE.

	WRITE(*,4)
    4   FORMAT(//' YOUR WORKING COPY FILE WILL NOW BE OPENED TO'/
     1' READ THE NUMBER OF OUTPUT EQUATIONS. LATER, YOU WILL HAVE THE '/
     2' OPTION TO CHANGE YOUR WORKING COPY FILE. IF YOU DO THIS, MAKE '/
     3' SURE THAT THE NEW FILE HAS THE SAME NUMBER OF OUTPUT '/
     4' EQUATIONS.'//)


	CALL PAUSE

C  VERIFY THAT PATHFIL2 IS A 'CURRENT' TYPE WORKING COPY FILE (I.E., 
C  CREATED BY CONVRTI.FOR OR LATER VERSION). IF NOT, IT DOESN'T HAVE THE
C  TEXT NEEDED BY THE LOGIC BELOW TO FIND NUMEQT.

   33   FORMAT(A78)
	READ(21,33) READLINE


	IF(READLINE(1:16) .NE. '  LAST AND FIRST') THEN

	 WRITE(*,37)
   37   FORMAT(/' RESTRICTION: THIS PROGRAM CAN ONLY READ WORKING COPY'/
     1'              FILES WHICH HAVE BEEN CREATED BY A RECENT VERSION'/
     2'              (1998 OR NEWER) OF THIS PROGRAM. THESE WORKING '/
     3'              COPY FILES MUST HAVE NAME, AGE, SEX, ETC. INFO '/
     4'              AT THE TOP.'//
     7' 	     YOU ARE TRYING TO USE A WORKING COPY PATIENT DATA'/

     1' 	     FILE WHICH WAS MADE BY AN OLDER VERSION OF THIS'/
     2'		     PROGRAM.'//
     3'		     PLEASE RERUN THE PROGRAM WITH AN APPROPRIATE '/
     4'              PATIENT DATA FILE.'/)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,37)
        CLOSE(42)

       CALL PAUSE
	 STOP

	ENDIF

    3   FORMAT(T2,I5)

C  READ THE NO. OF OUTPUT EQUATIONS FROM THE LINE WITH 'NO. OF TOTAL'
C  AS ENTRIES 12:23.


   50	READ(21,33) READLINE
      IF(READLINE(12:23) .NE. 'NO. OF TOTAL') GO TO 50
      BACKSPACE(21)
      READ(21,3) NUMEQT
      INTLIST(9) = NUMEQT

	RETURN
	END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
        SUBROUTINE GETDIST(IDIST,NGAUS,NVAR,COF,AMEAN,COV,PATH,NOB,
     1   OUTNPAG,TEXTFILE,OSname,ListDir,INTLIST,RPAR,IPAR)

        use npag_utils, only: verifyval

        IMPLICIT REAL*8(A-H,O-Z)

        integer, dimension(128) :: INTLIST
        double precision, dimension(257) :: RPAR
        integer, dimension(257) :: IPAR

        DIMENSION AMEAN(150,30),COF(150),COV(150,30,30),CORR(30,30),
     1   STD(30),XVERIFY(900)



        CHARACTER OUTNPAG*20,PATH*61,OSname*20,ListDir*10,TEXTFILE*20

C  THIS ROUTINE READS IN THE DESIRED DISTRIBUTION FROM THE USER, AND
C  RETURNS THE INFO TO MAIN.

      WRITE(*,1)
    1 FORMAT(/' THIS PROGRAM GENERATES SUBJECT VECTORS FROM A'/
     1' SET OF DISTRIBUTIONS WHICH WILL BE INPUT VIA THE KEYBOARD'/
     2' OR FROM THE OUTPUT OF A PREVIOUS NPAG RUN. ')


 2070   WRITE(*,1071)
 1071   FORMAT(/' ENTER 1 IF THE MIXTURE INDICATED ABOVE WILL BE INPUT'/
     1'         VIA THE KEYBOARD; '/
     2' ENTER 2 IF THE MIXTURE WILL COME FROM THE RESULTS OF A BIG'/
     3'         NPAG RUN: ')
        READ(*,*,ERR= 2070) KEYNPAG
        IF(KEYNPAG .NE. 1 .AND. KEYNPAG .NE. 2) GO TO 2070

        IF(KEYNPAG .EQ. 1) THEN

 1030   WRITE(*,1032)
 1032   FORMAT(/' FOR THE MIXTURE INDICATED ABOVE, ENTER THE NUMBER '/
     1' OF DISTRIBUTIONS DESIRED (BETWEEN 1 AND 30): ')
        READ(*,*,ERR=1030) NGAUS
        IF(NGAUS .LT. 1 .OR. NGAUS .GT. 30) GO TO 1030

 4320	WRITE(*,4321)
 4321   FORMAT(/' ENTER 1 TO ENTER INFO IN TERMS OF CORRELATIONS; '/
     1' ENTER 0 TO ENTER INFO IN TERMS OF COVARIANCES: ')
	READ(*,*,ERR=4320) ICORR
	IF(ICORR .NE. 1 .AND. ICORR .NE. 0) GO TO 4320


 1045   WRITE(*,1046) 
 1046   FORMAT(/' FOR EACH COMPONENT OF THE MIXTURE, ENTER THE '/
     1' REQUESTED INFORMATION AS PROMPTED ...')



      DO 1100 IGAUS=1,NGAUS


      WRITE(*,1051) IGAUS
 1051 FORMAT(//' FOR MIXTURE COMPONENT NO. ',I3,': ')
      WRITE(*,1052)
 1052 FORMAT(/' ENTER THE WEIGHT: ')
 1055 READ(*,*,ERR=1060) COF(IGAUS)
      IF(COF(IGAUS) .GT. 0.) GO TO 1065
 1060 WRITE(*,1061)
 1061 FORMAT(/' SEE ABOVE; ENTER A POSITIVE REAL NO.: ')
      GO TO 1055


 1065 CONTINUE

	IF(ICORR .EQ. 0) THEN
	
      WRITE(*,1066) 
 1066 FORMAT(/,' ENTER THE PARAMETER MEAN VECTOR: ')
 1070 READ(*,*,ERR=1075) (AMEAN(IGAUS,I),I=1,NVAR)
      GO TO 2080
 1075 WRITE(*,1076) NVAR
 1076 FORMAT(/' SEE ABOVE; ENTER ',I2,' REAL NUMBERS: ')
      GO TO 1070


 2080 WRITE(*,2081)
 2081 FORMAT(/' ENTER 1 TO SELECT A DIAGONAL COV. MATRIX WITH EACH'/
     1' 	STD. DEV. EXACTLY 25% OF THE CORRESPONDING MEAN. THIS'/
     2'		WILL ENSURE THAT NO PARAMETER VALUES ARE NEGATIVE.'/
     3' ENTER 0 TO ENTER A DIFFERENT COV. MATRIX (IN THIS CASE, YOU'/
     4'		WILL HAVE THE RESPONSIBILITY TO MAKE SURE THAT THE'/
     5'		COV. MATRIX IS CHOSEN PROPERLY SO THAT NO PARAMETER'/
     6'		VALUES ARE NEGATIVE: ')
	READ(*,*,ERR=2080) ICMAT
	IF(ICMAT .NE. 0 .AND. ICMAT .NE. 1) GO TO 2080



C  FIRST ZERO OUT THE COV. MATRIX

	 DO I = 1,NVAR
	  DO J = 1,NVAR
	   COV(IGAUS,I,J) = 0.D0
	  END DO
	 END DO	   


	IF(ICMAT .EQ. 1) THEN


	 DO I = 1,NVAR
	  COV(IGAUS,I,I) = (.25D0*AMEAN(IGAUS,I))**2.D0
	 END DO
	ENDIF

	IF(ICMAT .EQ. 0) THEN
 	 WRITE(*,1081)
 1081    FORMAT(/,' ENTER, ROW x ROW, LOWER-TRI PART OF THE COV MATRIX')
         DO 1095 I=1,NVAR

          WRITE(*,1086)I
 1085     READ(*,*,ERR=1090) (COV(IGAUS,I,J),J=1,I)
          GO TO 1095
 1090     WRITE(*,1076) I
          GO TO 1085
 1095    CONTINUE
 1086    FORMAT(' ',' ROW ',I3,' : ')
	ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(ICMAT .EQ. 0)  CONDITION.

	ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(ICORR .EQ. 0)  CONDITION.


	IF(ICORR .EQ. 1) THEN
	
 3065 WRITE(*,3066) 
 3066 FORMAT(/,' ENTER EACH PARAMETER MEAN AND STD. DEV. AS PROMPTED: ')

	DO I = 1,NVAR
 3070	 WRITE(*,3067) I
 3067    FORMAT(/' MEAN AND STD. DEV. FOR PARAMETER NO. ',I3,': ')
	 READ(*,*,ERR=3070) AMEAN(IGAUS,I),STD(I)
	END DO

 3080 WRITE(*,3081)
 3081 FORMAT(/,' ENTER, ROW x ROW, THE LOWER-TRI PART OF THE CORR '/
     1' MATRIX. RECALL THAT EACH DIAGONAL VALUE MUST BE 1.0 ')

      DO I=1,NVAR
 3090  WRITE(*,3086) I
 3085  READ(*,*,ERR=3090) (CORR(I,J),J=1,I)
      END DO

 3086 FORMAT(' ',' ROW ',I3,': ')


C  ESTABLISH THE COVARIANCE MATRIX FOR THIS COMPONENT, IGAUS.


	 DO I = 1,NVAR
	  DO J = 1,I
	   COV(IGAUS,I,J) = CORR(I,J)*STD(I)*STD(J)
	  END DO
	 END DO

	ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(ICORR .EQ. 1) THEN  CONDITION.


 1100 CONTINUE	

C  ENSURE THAT SUM(COF(I))=1.0.

      SUMCOF=0.D0
      DO 1110 IGAUS=1,NGAUS
 1110 SUMCOF=SUMCOF+COF(IGAUS)
      DO 1115 IGAUS=1,NGAUS
 1115 COF(IGAUS)=COF(IGAUS)/SUMCOF

C  REPLACE WRITING OF COF() WITH XVERIFY (SEE LOGIC IN 
C  SUBROUTINE VERIFYVAL).

        DO I = 1,NGAUS
         XVERIFY(I) = COF(I)
        END DO
        CALL VERIFYVAL(NGAUS,XVERIFY)      
C       WRITE(*,1116) (COF(I),I=1,NGAUS)
        WRITE(*,1116) (XVERIFY(IXV),IXV=1,NGAUS)
 1116 FORMAT(/' THE NORMALIZED COEFFICIENTS ARE: ',150F8.4)



        ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(KEYNPAG .EQ. 1)  CONDITION.


      IF(KEYNPAG .EQ. 2) THEN

 3010    WRITE(*,2)
    2    FORMAT(/' ENTER 1 IF EACH OF THE ACTIVE GRID PTS. WILL BE'/
     4'         A DISTRIBUTION WITH THE COORDINATES OF EACH GRID PT.'/
     5'         BEING THE MEAN OF THE DISTRIBUTION, AND THE PROB. OF'/
     6'         THE GRID PT. BEING THE WEIGHT. ALSO, THE COV. OF EACH'/
     7'         DIST. WILL BE THE FINAL CYCLE COV. MATRIX, DIVIDED BY'/
     8'         THE NO. OF ACTIVE PTS.); '/
     9' ENTER 2 IF EACH OF THE ACTIVE GRID PTS. WILL BE USED ONCE EACH'/
     1'         AS THE PARAMETER SET FOR A SIMULATED SUBJECT: ')
       READ(*,*,ERR=3010) KKEY
       IF(KKEY .NE. 1 .AND. KKEY .NE. 2) GO TO 3010       

        CALL READNPAG(NGAUS,KKEY,NVAR,COF,AMEAN,COV,PATH,NOB,OUTNPAG,
     1   TEXTFILE,OSname,ListDir)


      ENDIF
C  ABOVE ENDIF IS FOR THE  IF(KEYNPAG .EQ. 2) CONDITION.

       IF(KKEY .EQ. 2) KEYNPAG = 3

        IF(KEYNPAG .EQ. 3) IDIST = 0

        IF(KEYNPAG .EQ. 1 .OR. KEYNPAG .EQ. 2) THEN
        
 2040   WRITE(*,2031)
 2031   FORMAT(/' THIS PROGRAM GENERATES SUBJECT VECTORS FROM A'/
     1' DISTRIBUTION WHICH IS A MIXTURE OF GAUSSIAN DISTRIBUTIONS '/
     2' OR LOGNORMAL DISTRIBUTIONS. '/
     3' ENTER 1 FOR GAUSSIAN DISTRIBUTIONS;'/
     4' ENTER 2 FOR LOGNORMAL DISTRIBUTIONS: ')
	READ(*,*,ERR=2040) IDIST
	IF(IDIST .NE. 1 .AND. IDIST .NE. 2) GO TO 2040

      ENDIF





        RETURN

        END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
        SUBROUTINE STAT2(NSUB,M,NOS,YPREDSUB,YMEAN,YMIN,YMAX,YSD,Y025,
     1   Y25,Y50,Y75,Y975)

        IMPLICIT REAL*8(A-H,O-Z)

	PARAMETER(MAXNUMEQ=7)

        DIMENSION YPREDSUB(10000,594,MAXNUMEQ),YMEAN(594,MAXNUMEQ),
     1   YMIN(594,MAXNUMEQ),YMAX(594,MAXNUMEQ),YSD(594,MAXNUMEQ),
     2   Y025(594,MAXNUMEQ),Y25(594,MAXNUMEQ),Y50(594,MAXNUMEQ),
     3   Y75(594,MAXNUMEQ),Y975(594,MAXNUMEQ),X(10000)

C  THIS SUBROUTINE, CALLED BY SIMBIG, INPUTS NSUB (NO. OF SUBJECTS),
C  M (NO. OF OBSERVATIONS PER OUTPUT EQ.), NOS (NO. OF OUTPUT 
C  EQUATIONS), AND YPREDSUB (THE OUPUT CONCENTRATIONS WHICH IS
C  NSUB x M x NOS).

C  IT OUTPUTS:

C  FOR EACH OUTPUT EQUATION AND OBSERVATION TIME:
C  MEAN CONC.    OVER ALL THE SUBJECTS YMEAN(IM,IN), IN=1,NOS; IM=1,M.

C  MIN CONC.     OVER ALL THE SUBJECTS  YMIN(IM,IN), IN=1,NOS; IM=1,M.

C  MAX CONC.     OVER ALL THE SUBJECTS  YMAX(IM,IN), IN=1,NOS; IM=1,M.
C  S.D. CONC.    OVER ALL THE SUBJECTS   YSD(IM,IN), IN=1,NOS; IM=1,M.
C  2.5TH %-TILE CONC. OVER ALL SUBJECTS  Y025(IM,IN), IN=1,NOS; IM=1,N.
C   25TH %-TILE CONC. OVER ALL SUBJECTS   Y25(IM,IN), IN=1,NOS; IM=1,N.
C   50TH %-TILE CONC. OVER ALL SUBJECTS   Y50(IM,IN), IN=1,NOS; IM=1,N.
C   75TH %-TILE CONC. OVER ALL SUBJECTS   Y75(IM,IN), IN=1,NOS; IM=1,N.
C 97.5TH %-TILE CONC. OVER ALL SUBJECTS  Y975(IM,IN), IN=1,NOS; IM=1,N.


C  IF NSUB = 1, THERE IS NOTHING FOR THIS ROUTINE TO DO SINCE THE
C  MEAN, MED, MIN, MAX, AND ALL %-TILES ARE THE SINGLE VALUE. RETURN
C  IN THIS CASE.

	  IF(NSUB .EQ. 1) THEN
	   WRITE(23,101)
  101      FORMAT(/' SINCE NSUB = 1, SUBROUTINE STAT2 WILL CALCULATE'/
     1' NOTHING.')
	   RETURN
	  ENDIF


C  FOR EACH OUTPUT EQUATION AND EACH OBSERVATION TIME, CALCULATE THE
C  ABOVE VALUES:

	DO IM = 1,M
	 DO IN = 1,NOS


C  FIRST STORE THE NSUB VALUES INTO VECTOR X.

	  DO ISUB = 1,NSUB
	   X(ISUB) = YPREDSUB(ISUB,IM,IN)
	  END DO

C  CALCULATE THE MEAN AND STD. DEV. 

	  SUM = 0.D0
	  SUMSQ = 0.D0
	   DO ISUB = 1,NSUB

	    SUM = SUM + X(ISUB)
	    SUMSQ = SUMSQ + X(ISUB)*X(ISUB)
	   END DO
	  YMEAN(IM,IN) = SUM/NSUB
	  XBAR = YMEAN(IM,IN)

C  AS OF MONTBIG7.FOR, CHECK TO MAKE SURE THE ARGUMENT TO THE SQ. ROOT
C  BELOW IS NON-NEGATIVE. IF IT IS (WHICH COULD HAPPEN DUE TO 
C  NUMERICAL ROUNDOFF), SET IT = 0, WHICH IT SHOULD BE IN SUCH CASES.

	  ARG = (SUMSQ - NSUB*XBAR*XBAR)/(NSUB - 1.D0)
	  IF(ARG .LT. 0.D0) ARG = 0.D0
 
	  YSD(IM,IN) = DSQRT(ARG)


C  CALL SUBROUTINE PERCENT TO CALCULATE THE 2.5, 25, 50 (MEDIAN), 75,
C  AND 97.5 %-TILES OF THE NSUB VALUES IN X, ALONG WITH THE MINIMUM
C  AND MAXIMUM. AND THEN STORE THESE VALUES.

	  CALL PERCENT(NSUB,X,XMIN,XMAX,X025,X25,X50,X75,X975)

	   YMIN(IM,IN) = XMIN
	   YMAX(IM,IN) = XMAX
	   Y025(IM,IN) = X025
	    Y25(IM,IN) = X25
	    Y50(IM,IN) = X50 

 	    Y75(IM,IN) = X75 
	   Y975(IM,IN) = X975
	

	 END DO
	END DO




C  THE ABOVE END DO'S ARE FOR THE DO IN = 1,NOS AND DO IM= 1,M LOOPS.


      RETURN
      END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
	SUBROUTINE PERCENT(NSUB,X,XMIN,XMAX,X025,X25,X50,X75,X975)
        IMPLICIT REAL*8(A-H,O-Z)
        DIMENSION X(10000),XI(10001),CUMPROP(0:10000),NUM(10000)

C  THIS SUBROUTINE, CALLED BY STAT2, CALCULATES THE MIN, MAX, AND 
C  INDICATED PERCENTILES OF THE VALUES IN VECTOR X.


	XMAX = -1.D30
	XMIN =  1.D30
	DO ISUB = 1,NSUB
	 IF(X(ISUB) .GT. XMAX) XMAX = X(ISUB)
	 IF(X(ISUB) .LT. XMIN) XMIN = X(ISUB)	
	END DO

C  TO FIND THE %-TILES OF THE SAMPLE OF VALUES IN X, A RELATIVELY
C  EASY WAY, WHICH HANDLES THE POSSIBILITY OF TIES, IS TO ESTABLISH
C  10000 INTERVALS BETWEEN XMIN AND XMAX, AND RECORD HOW MANY VALUES
C  ARE IN EACH INTERVAL. THEN EACH %-TILE WILL BE IN THE INTERVAL 
C  WHERE THE CUMULATIVE PERCENTAGE TO THAT INTERVAL REACHES THE
C  CORRESPONDING PERCENT.

C  FIND THE 10000 INTERVALS -- EQUALLY SPACED -- BETWEEN XMIN AND XMAX.

	XINT=(XMAX - XMIN)/10000.D0
	XI(1) = XMIN
	XI(10001) = XMAX
	DO I = 1, 9999
         XI(I+1) = XI(I) + XINT
	END DO


C  FIND NUM(INTR) = NO. OF X's IN INTERVAL INTR; INTR = 1,10000.

 
	DO INTR = 1,10000
	 N = 0
	  DO ISUB = 1,NSUB
	   XX = X(ISUB)
	   IF(XX .GE. XI(INTR) .AND. XX .LT. XI(INTR+1)) N = N + 1
	   IF(INTR .EQ. 10000 .AND. XX .GE. XI(INTR+1)) N = N + 1 
	  END DO
	 NUM(INTR) = N
	END DO


C  FIND THE 5 %-TILE VALUES. 

C  X025 IS THE X-VALUE BELOW WHICH IS 2.5 % OF THE DISTRIBUTION.
C  X25  IS THE X-VALUE BELOW WHICH IS 25 % OF THE DISTRIBUTION.
C  X50  IS THE X-VALUE BELOW WHICH IS 50 % OF THE DISTRIBUTION.
C  X75  IS THE X-VALUE BELOW WHICH IS 75 % OF THE DISTRIBUTION.
C  X975 IS THE X-VALUE BELOW WHICH IS 97.5 % OF THE DISTRIBUTION.


C  ACTUALLY, X025 WILL BE THE WEIGHTED VALUE IN THE INTERVAL WHERE 
C  THE CUMULATIVE NO. X's EXCEEDS 2.5%. SIMILARLY FOR THE OTHER
C  %-TILE VALUES. 



C  FIND THE INTERVALS WHERE THE CUMULATIVE NO. OF X's EXCEED 2.5%, 
C  25%, 50%, 75%, AND 97.5%.

C  CUMPROP(I) BELOW IS THE CUMULATIVE PROPORTION OF X's THROUGH 
C  INTERVAL I.

	CUMPROP(0)=0.D0

	DO INTR = 1,10000
	 
	 CUMPROP(INTR) = CUMPROP(INTR-1) + 1.D0*NUM(INTR)/NSUB

	 IF(CUMPROP(INTR-1) .LT. .025D0 .AND. CUMPROP(INTR) .GE. .025D0) 
     1    IND025=INTR
	 IF(CUMPROP(INTR-1) .LT. .25D0 .AND. CUMPROP(INTR) .GE. .25D0) 
     1    IND25=INTR

	 IF(CUMPROP(INTR-1) .LT. .50D0 .AND. CUMPROP(INTR) .GE. .50D0) 
     1    IND50=INTR
	 IF(CUMPROP(INTR-1) .LT. .75D0 .AND. CUMPROP(INTR) .GE. .75D0) 
     1    IND75=INTR
	 IF(CUMPROP(INTR-1) .LT. .975D0 .AND. CUMPROP(INTR) .GE. .975D0) 
     1    IND975=INTR

	END DO


C  NOW IND025 IS THE INTERVAL WHERE THE CUMULATIVE PROPORTION OF X's
C  EXCEEDS .025 (SIMILARLY FOR THE OTHER IND'S).

	X025 = XI(IND025) + (XI(IND025+1)-XI(IND025))*
     1  (.025D0-CUMPROP(IND025-1))/(CUMPROP(IND025)-CUMPROP(IND025-1))

	X25 = XI(IND25)+(XI(IND25+1)-XI(IND25))*

     1  (.25D0-CUMPROP(IND25-1))/(CUMPROP(IND25)-CUMPROP(IND25-1))

	X50 = XI(IND50)+(XI(IND50+1)-XI(IND50))*

     1  (.50D0-CUMPROP(IND50-1))/(CUMPROP(IND50)-CUMPROP(IND50-1))

	X75 = XI(IND75)+(XI(IND75+1)-XI(IND75))*
     1  (.75D0-CUMPROP(IND75-1))/(CUMPROP(IND75)-CUMPROP(IND75-1))

	X975 = XI(IND975)+(XI(IND975+1)-XI(IND975))*
     1  (.975D0-CUMPROP(IND975-1))/(CUMPROP(IND975)-CUMPROP(IND975-1))


	RETURN
	END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
	SUBROUTINE EXPLAINOISE

C  THIS ROUTINE SIMPLY WRITES TO THE SCREEN THE EXPLANATION FOR HOW
C  THE NOISY DOSETIMES, DOSE AMOUNTS, AND OBSERVATION TIMES ARE
C  OBTAINED.

   20	WRITE(*,1)
    1   FORMAT(/' THE DOSE TIMES, DOSE AMOUNTS, AND OBSERVATION '/
     1' TIMES ARE MADE "NOISY" USING THE COEFFICIENTS YOU ENTER FOR'/
     2' EACH SET.'//
     3' ENTER 1 FOR NO MORE DETAIL;'/
     4' ENTER 2 FOR AN EXPLANATION OF THE "NOISY" DOSE TIMES AND'/
     4'         "NOISY" OBS. TIMES;'/
     4' ENTER 3 FOR AN EXPLANATION OF THE "NOISY" DOSE AMOUNTS: ')
	READ(*,*,ERR=20) IEXP
	IF(IEXP .NE. 1 .AND. IEXP .NE. 2 .AND. IEXP .NE. 3) GO TO 20

	IF(IEXP .EQ. 1) RETURN
	IF(IEXP .EQ. 2) WRITE(*,12)
	IF(IEXP .EQ. 3) WRITE(*,13)
	GO TO 20

   12   FORMAT(/' EACH DOSE TIME IS MADE "NOISY" AS FOLLOWS:'/
     1' THE FIRST DOSE TIME, WITH A TRUE VALUE OF VTRUE, WILL BE '/
     2' CHANGED TO BE VNOISY, WHERE VNOISY = VTRUE + Ei, WHERE'/
     3' Ei ~ N(0,STDI**2), WHERE '/
     4' STDI = C0 + C1*VTRUE + C2*VTRUE**2 + C3*VTRUE**3'//
     5' FOR SUBSEQUENT DOSE TIMES, THE NOISY DOSE TIME IS '/
     6' DETERMINED AS FOLLOWS:'/
     7' a. SET DUR = NOMINAL DURATION BETWEEN THE PREVIOUS DOSE TIME '/
     8'    AND THE CURRENT DOSE TIME.'/
     3' b. CALC. THE NOISY DURATION, DURNOISY, AS '/
     4'    DURNOISY = DUR + Ei, Ei ~ N(0,STDI**2), WHERE '/
     7'    STDI = C0 + C1*DUR + C2*DUR**2 + C3*DUR**3'/
     8' c. ... BUT LIMIT DURNOISY TO BE .GE. .5*DUR AND .LE. 2*DUR.'/
     9' d. SET THE CURRENT NOISY DOSE TIME = PREVIOUS NOISY DOSE TIME'/
     1'    + DURNOISY.'//
     2' THE SAME LOGIC APPLIES FOR OBS. TIMES. '//
     3' NOTE THIS LOGIC --> TIMES CANNOT BE OUT OF ORDER.')

   13   FORMAT(/' EACH IV RATE AND EACH BOLUS VALUE WHICH = 0 WILL NOT'/
     1' BE MADE NOISY. I.E., IT IS ASSUMED THAT IF A RATE OR BOLUS IS'/
     2' INTENDED TO BE 0, IT WILL BE ACHIEVED WITHOUT ERROR.'
     2/
     3' A NON-ZERO IV OR BOLUS VALUE, WITH A TRUE VALUE OF VTRUE, '/
     4' WILL BE CHANGED TO BE VNOISY, WHERE VNOISY = VTRUE + Ei, WHERE'/
     6' Ei ~ N(0,STDI**2), WHERE '/
     7' STDI = C0 + C1*VTRUE + C2*VTRUE**2 + C3*VTRUE**3')


	END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
        SUBROUTINE READNPAG(NGAUS,KKEY,NVAR,COF,AMEAN,COV,PATH,NOB,
     1   OUTNPAG,TEXTFILE,OSname,ListDir)


C  READNPAG IS CALLED BY GETDIST. IT INPUTS THE DISTRIBUTION 
C  MIXTURE (NGAUS, NVAR, COF, AMEAN, COV) FROM THE (COMBINED) OUTPUT 
C  FILE OF A BIG NPAG RUN ... OR, AS OF MONT108.FOR FROM A SIMPLE
C  TEXT FILE, OR VIA THE KEYBOARD.


C  IF KKEY = 1: EACH OF THE ACTIVE GRID PTS. WILL BE A DISTRIBUTION 
C  WITH THE COORDINATES OF EACH GRID PT. BEING THE MEAN OF THE
C  DISTRIBUTION,  AND THE PROB. OF THE GRID PT. BEING THE WEIGHT. ALSO,
C  THE COV. OF EACH DIST. WILL BE THE FINAL CYCLE COV. MATRIX, DIVIDED
C  BY THE NO. OF ACTIVE PTS.

C  IF KKEY = 2 (STARTING WITH MONT107.FOR), THE PROGRAM WILL USE THESE
C  NGAUS GRID PTS. ONCE EACH TO SIMULATE A SUBJECT. IN THIS CASE, THE 
C  COVARIANCE MATRIX IS IRRELEVANT.

        IMPLICIT REAL*8(A-H,O-Z)
        DIMENSION AMEAN(150,30),COF(150),COV(150,30,30),COVV(30,30),
     1   VALFIX(20),RANFIXEST(20)

        CHARACTER OUTNPAG*20,PATH*61,TMPFILE*32,PATHFILE*93,READLIN2*78,
     1   READLINE*1000,OSname*20,ListDir*10,TEXTFILE*20,ERRFIL*20



      COMMON/ERROR/ERRFIL
C  COMMON/ERROR/ IS SUPPLIED TO ALL THE ROUTINES WHICH COULD WRITE TO
C  ERRFIL.

    1   FORMAT(A20)

      IF(KKEY .EQ. 2) THEN
  
  180  WRITE(*,6321)
 6321  FORMAT(//' ENTER 1 TO INPUT THE ACTIVE GRID PTS. MANUALLY;'/
     1' ENTER 2 TO INPUT THE ACTIVE GRID PTS. FROM THE OUTPUT FILE'/
     2'         OF AN NPAG RUN;'/
     3' ENTER 3 TO INPUT THE ACTIVE GRID PTS. FROM A SIMPLE TEXT FILE: '
     4)
       READ(*,*,ERR=180) INHOW
       IF(INHOW .NE. 1 .AND. INHOW .NE. 2 .AND. INHOW .NE. 3) GO TO 180

       IF(INHOW .EQ. 2) GO TO 170


  280   WRITE(*,6322)
 6322   FORMAT(/' ENTER THE NO. OF ACTIVE GRID PTS. THIS NUMBER MUST'/
     1' BE .LE. 150: ')
        READ(*,*,ERR=280) NGAUS
        IF(NGAUS .LT. 1 .OR. NGAUS .GT. 150) GO TO 280


       IF(INHOW .EQ. 1) THEN

        WRITE(*,6323) NGAUS,NVAR
 6323   FORMAT(/' ENTER ',I4,' ROWS OF PARAMETER VALUES. EACH ROW MUST'/
     1' HAVE THE ',I3,' PARAMETER VALUES FOR THAT GRID PT. '//)
  
        DO IGAUS = 1,NGAUS
  220    WRITE(*,6324) NVAR,IGAUS
 6324    FORMAT(' ENTER ',I3,' PAR. VALUES FOR GRID PT. ',I4,': ')
         READ(*,*,ERR=220) (AMEAN(IGAUS,J),J=1,NVAR)
        END DO

C  GO TO LABEL 260 TO ESTABLISH COF(.) = 1, AND COV(.,.,.) = 0.

        GO TO 260

       ENDIF
C  THE ABOVE ENDIF IS FOR THE  IF(INHOW .EQ. 1)  CONDITION.
      

       IF(INHOW .EQ. 3) THEN

  230   WRITE(*,6326) NGAUS,NVAR 
 6326   FORMAT(/' ENTER THE NAME OF THE TEXT FILE WHICH HAS A MATRIX'/
     1' OF ',I4,' ROWS OF PARAMETER VALUES, EACH ROW HAVING THE ',I3/
     2' PARAMETER VALUES FOR A GRID PT.: ')

        WRITE(*,*)' ENTER -99 TO SEE ALL OR A PART OF YOUR DIRECTORY: ' 
        READ(*,1) TEXTFILE 
        IF(TEXTFILE(1:3) .EQ. '-99') CALL SEEDIR(PATH,NOB,TEXTFILE,
     1     OSName,ListDir)

C  CALL FULLNAME WHICH CONVERTS THE FILENAME TO PATHFILE, THE COMPLETE 
C  NAME OF THE FILE, WHICH INCLUDES THE PATH (IF THE PATH IS NOT THE 
C  CURRENT DIRECTORY).

     	  TMPFILE = ' '
        TMPFILE = TEXTFILE
        CALL FULLNAME(PATH,TMPFILE,PATHFILE)
        OPEN(45,FILE=PATHFILE,STATUS='OLD',ERR=250)
        GO TO 240
  250   WRITE(*,5316) PATHFILE

        GO TO 230

  240   DO IGAUS = 1,NGAUS
         READ(45,*) (AMEAN(IGAUS,J),J=1,NVAR)
        END DO

        CLOSE(45)

C  GO TO LABEL 260 TO ESTABLISH COF(.) = 1, AND COV(.,.,.) = 0.

        GO TO 260

       ENDIF
C  THE ABOVE ENDIF IS FOR THE  IF(INHOW .EQ. 3)  CONDITION.



      ENDIF
C  THE ABOVE ENDIF IS FOR THE  IF(KKEY .EQ. 2)  CONDITION.



  170   WRITE(*,5321) 
 5321   FORMAT(//' ENTER THE NAME OF A "COMBINED" OUTPUT FILE FROM A'/
     1' PREVIOUS RUN.'// 
     4' IT WILL BE OF THE FORM OUTxxxx, WHERE xxxx WAS THE JOB NUMBER'/
     5' ASSIGNED TO THE RUN.'//)
        WRITE(*,*)' ENTER -99 TO SEE ALL OR A PART OF YOUR DIRECTORY: ' 
        READ(*,1) OUTNPAG
        IF(OUTNPAG(1:3) .EQ. '-99') CALL SEEDIR(PATH,NOB,OUTNPAG,
     1     OSName,ListDir)

C  FOR SOME REASON, OUTNPAG IS NOT READ IN CORRECLY UNLESS THERE IS
C  A PAUSE AFTER IT IS READ.
        CALL PAUSE


C  CALL FULLNAME WHICH CONVERTS THE FILENAME TO PATHFILE, THE COMPLETE 
C  NAME OF THE FILE, WHICH INCLUDES THE PATH (IF THE PATH IS NOT THE 
C  CURRENT DIRECTORY).

     	TMPFILE = ' '
	TMPFILE = OUTNPAG
	CALL FULLNAME(PATH,TMPFILE,PATHFILE)
	OPEN(45,FILE=PATHFILE,STATUS='OLD',ERR=95)
	GO TO 210
   95   WRITE(*,5316) PATHFILE
 5316   FORMAT(//' THE FOLLOWING FILE DOES NOT EXIST ... '/
     1'    ',A73)
	GO TO 170


C  FIRST VERIFY THAT THE VERSION NO. FOR THIS OUPUT FILE IS AT LEAST
C  36, WHICH MEANS IT IS A COMBINED OUTPUT FILE.


  210   IVER=0


        READ(45,2) READLINE

        IF(READLINE(2:11) .EQ. 'VERSION 36') IVER=36
        IF(READLINE(2:11) .EQ. 'VERSION 37') IVER=37
        IF(READLINE(2:11) .EQ. 'VERSION 38') IVER=38
        IF(READLINE(2:11) .EQ. 'VERSION 39') IVER=39
        IF(READLINE(2:11) .EQ. 'VERSION 40') IVER=40
        IF(READLINE(2:11) .EQ. 'VERSION 41') IVER=41
        IF(READLINE(2:11) .EQ. 'VERSION 42') IVER=42
        IF(READLINE(2:11) .EQ. 'VERSION 43') IVER=43


        IF(IVER .EQ. 0) THEN
         WRITE(*,3013)
 3013    FORMAT(//' YOUR OUTPUT FILE IS NOT A "COMBINED" OUTPUT FILE'/
     1' AS REQUIRED BY THIS PROGRAM. SUCH A FILE WILL HAVE A VERSION '/
     2' NO. OF AT LEAST 36 ON THE FIRST LINE.')
         GO TO 170
        ENDIF


C  NEXT VERIFY THAT NVAR INPUT TO THIS ROUTINE MATCHES NVAR FROM THE 
C  OUTPUT FILE. THE NO. OF RANDOM VARIABLES WILL BE THE NO. OF TIMES
C  THE CHARACTER : IS READ IN IN COLUMN 13, JUST AFTER THE LINE
C  WHICH = " THE RANDOM VARIABLES AND THEIR RANGES ARE: "


   70   READ(45,2) READLINE
        IF(READLINE(1:21) .NE. ' THE RANDOM VARIABLES') GO TO 70
        READ(45,2) READLINE
        NVARR = 0
   80   READ(45,2) READLINE

        IF(READLINE(13:13) .EQ. ':') THEN
         NVARR = NVARR + 1
         GO TO 80
        ENDIF

        IF(READLINE(1:9) .EQ. ' THE USER') GO TO 100
        IF(READLINE(1:9) .EQ. ' NO FIXED') GO TO 100


        GO TO 80

  100   IF(NVARR .NE. NVAR) THEN
         WRITE(*,81) NVARR,NVAR,NVAR
   81    FORMAT(/' THE NO. OF RANDOM VARIABLES IN YOUR OUTPUT FILE'/
     1' IS ',I3,'. THIS IS DIFFERENT THAN THE NO. YOU ENTERED ABOVE,'/
     2' ... ',I3,'. PLEASE ENTER AN OUTPUT FILE WITH ',I3,' RANDOM'/
     3' VARIABLES.')
         GO TO 170
        ENDIF
       

C  PRINT TO THE SCREEN A SUMMARY OF THE INPUT INFO FOR THE RUN, SO
C  THE USER CAN VERIFY THAT THIS RUN IS THE ONE HE WANTS.

      WRITE(*,*)
      WRITE(*,*)
      WRITE(*,*)' THE FOLLOWING INFO SUMMARIZES THE INPUT INSTRUCTIONS'
      WRITE(*,*)' FOR THE RUN WHOSE OUTPUT FILE YOU JUST ENTERED: '
      WRITE(*,*)

        ILINES=3

C  ILINES IS THE RUNNING TOTAL OF LINES PRINTED TO THE SCREEN SINCE THE
C  LAST PAUSE. EVERYTIME IT GETS TO 20, PAUSE THE OUTPUT.

    2   FORMAT(A1000)
  202   FORMAT(A78)
  150	READ(45,202) READLIN2
	ILINES=ILINES+1
	WRITE(*,1102) READLIN2
 1102   FORMAT(' ',A78)

	IF(ILINES .EQ. 20) THEN
	  
	  ILINES=0	
	ENDIF

	IF(READLIN2(5:15) .NE. '***********') GO TO 150

  160	WRITE(*,12)
   12   FORMAT(//' ENTER 1 IF THE OUTPUT FILE DESCRIBED ABOVE IS THE'/
     1'         ONE FROM THE RUN FROM WHICH YOU WISH TO INPUT THE '/
     2'         DISTRIBUTION MIXTURE FOR THIS RUN;'/ 
     3' ENTER 0 IF YOU WISH TO ENTER ANOTHER OUTPUT FILE: ')
	READ(*,*,ERR=160) IANOT
	IF(IANOT .NE. 0 .AND. IANOT .NE. 1) GO TO 160

	IF(IANOT .EQ. 0) THEN 

	  CLOSE(45)
	  GO TO 170
	ENDIF

	
C  CLOSE AND REOPEN THE FILE AT THE END, AND THEN BACKSPACE UNTIL THE
C  FINAL CYCLE INFO CAN BE READ IN.

        CLOSE(45)
        OPEN(45,FILE=PATHFILE,POSITION='APPEND')

   30	  BACKSPACE(45)
	  BACKSPACE(45)

	  READ(45,2) READLINE
	  IF(READLINE(1:10) .NE. ' CYCLE NO.') GO TO 30
	
C  READ IN THE COV. MATRIX FOR THIS FINAL CYCLE ... UNLESS IT CAN'T
C  BE READ WHICH HAPPENS WHEN  A VARIANCE FOR A PARAMETER IS NUMERICALLY
C  .LE. 0. IN THAT CASE, TELL THE USER THAT EACH COV. MATRIX WILL BE 
C  DIAGONAL WITH EACH STD. DEV. EXACTLY 25% OF THE CORRESPONDING MEAN
C  ... IF KKEY = 1 (IF KKEY = 2, COVARIANCES ARE UNNEEDED).

   40   READ(45,2) READLINE
        IF(READLINE(1:15) .EQ. ' THE COV MATRIX') GO TO 50


        IF(READLINE(1:15) .EQ. ' THE VARIANCE F' .AND. KKEY .EQ. 1)
     1   GO TO 60

        IF(READLINE(1:15) .EQ. ' THE VARIANCE F' .AND. KKEY .EQ. 2)
     1   GO TO 90


        GO TO 40

   50   READ(45,2) READLINE

C  READ IN THE FINAL CYCLE COV. MATRIX. CALL IT COVV. BELOW, IT WILL BE
C  DIVIDED BY NACTVE TO GET COV.

        DO IVAR = 1,NVAR

         READ(45,*) (COVV(IVAR,J),J=1,IVAR)
        END DO

        ICOVMAT = 1

C  ICOVMAT = 1 --> COV(.,.,.) WILL BE SET = COVV(.,.)/NACTVE BELOW.

        GO TO 90


   60   WRITE(*,61)
   61 FORMAT(/' YOUR OUTPUT FILE HAS NO FINAL CYCLE COV. MATRIX'/
     1' SINCE AT LEAST ONE PARAMETER HAD A VARIANCE NUMERICALLY .LE. 0.'
     2//
     3' SO THE COV. MATRIX ASSOCIATED WITH EACH GRID PT. IN THE '/
     4' BIG NPAG RUN WILL DEFAULT TO A DIAGONAL COV. MATRIX WITH EACH'/
     5' STD. DEV. EXACTLY 25% OF THE CORRESPONDING MEAN. THIS WILL'/
     6' ENSURE THAT NO SIMULATED PARAMETER VALUES ARE NEGATIVE.'/)

      ICOVMAT = 0

C  ICOVMAT = 0 --> COV(.,.,.) WILL BE SET AS INDICATED IN FORMAT 61.


   90   CONTINUE

C  NOW READ THE DENSITY PART OF THE FILE TO OBTAIN NGAUS = THE NO. OF
C  ACTIVE GRID PTS. (NACTVE IN bigmlt6.f), COORDINATES OF THE GRID PTS.,
C  WHICH WILL BE THE MEANS OF NGAUS "DISTRIBUTIONS", AND THE 
C  PROBABILTIIES, WHICH WILL BE THE WEIGHTS OF THE "DISTRIBUTIONS".


  110   READ(45,2) READLINE

        IF(READLINE(19:34) .NE. 'START OF THE DEN') GO TO 110
        
        DO I = 1,4
         READ(45,2) READLINE
        END DO


        READ(45,*) NGAUS

C  THIS PROGRAM IS LIMITED TO NGAUS .LE. 150. IF NGAUS > 150, TELL
C  THE USER AND GIVE HIM THE OPTION OF STOPPING OR USING JUST THE
C  FIRST 150 GRID POINTS.

        IF(NGAUS .GT. 150) THEN

  120    WRITE(*,121) NGAUS
  121    FORMAT(/' YOUR OUTPUT FILE HAS A FINAL CYCLE WITH ',I5,/
     1' ACTIVE GRID POINTS. THIS IS MORE THAN THE ALLOWABLE VALUE OF '/
     2' 150. YOU HAVE THE OPTION OF STOPPING NOW, OR OF SIMPLY USING'/
     3' THE FIRST 150 GRID POINTS.'//

     4' ENTER 1 TO STOP;'/
     5' ENTER 2 TO CONTINUE, USING THE FIRST 150 GRID POINT: ')
         READ(*,*,ERR=120) ISTOP
         IF(ISTOP .NE. 1 .AND. ISTOP .NE. 2) GO TO 120
         IF(ISTOP .EQ. 1) STOP
         NGAUS = 150

        ENDIF


        READ(45,2) READLINE
        DO I = 1,NVAR
         READ(45,2) READLINE
        END DO

        READ(45,*) NOFIX
         DO I = 1,NOFIX
          READ(45,2) READLINE
         END DO

        IF(IVER .GE. 43) THEN
         READ(45,*) NRANFIX
         DO I = 1,NRANFIX
          READ(45,2) READLINE
         END DO
        ENDIF

        DO I = 1,NVAR
         READ(45,2) READLINE
        END DO
  
C  VALFIX(.) ARE NOT NEEDED, BUT MUST BE READ TO KEEP TRACK OF THE 
C  LOCATION OF READ STATEMENTS IN THE FILE.
  
        READ(45,*) (VALFIX(I),I=1,NOFIX)

C  RANFIXEST(.) ARE NOT NEEDED, BUT MUST BE READ TO KEEP TRACK OF THE 
C  LOCATION OF READ STATEMENTS IN THE FILE ... IF IVER .GE. 43.

        IF(IVER .GE. 43) READ(45,*) (RANFIXEST(I),I=1,NOFIX)

        READ(45,*) NINT

C  AS A MIDCOURSE CHECK, VERIFY THAT NINT = 100. IF NOT, STOP AND
C  TELL THE READER THAN SOMETHING IS AMISS.

        IF(NINT .NE. 100) THEN
         WRITE(*,111) NINT
  111    FORMAT(/' IN THE DENSITY PART OF THE FILE, NINT WAS READ'/
     1' AS ',I7,' BUT IT SHOULD HAVE BEEN 100. THE PROGRAM STOPS.'/
     2' PLEASE RECHECK YOUR OUTPUT FILE OR ASK LAPK TO ANALYZE YOUR'/
     3' FILE FOR YOU.'/)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,111) NINT
        CLOSE(42)

         CALL PAUSE
         STOP
        ENDIF  
       
        READ(45,2) READLINE
        READ(45,2) READLINE

C  AS THE WEIGHTS ARE BEING READ IN, IN THE DO LOOP BELOW, FIND THE SUM
C  SINCE THEY ARE NOT NORMALIZED TO SUM TO 1.0. NOTE THAT ABOVE IF NGAUS
C  WAS > 150, IT WAS RESET = 150 --> ONLY THE FIRST 150 SETS OF GRID
C  POINTS AND ASSOCIATED PROBABILITIES WILL BE READ IN IN THE LOOP 
C  BELOW. THIS IS OK SINCE THE WEIGHTS OF THE FIRST 150 GRID POINTS
C  WOULD THEN STILL BE NORMALIZED TO BE 1.0 IN THE 2ND LOOP BELOW. BUT 
C  IF ICOVMAT = 1 BELOW, AND IF NGAUS WAS LOWERED TO 150 ABOVE, THE 
C  COV(.,.,.) MATRIX WILL HAVE LARGER VALUES THAN IF NGAUS WAS NOT 
C  RESET. BUT SINCE THE "AD-HOC" PROCEDURE TO ESTABLISH THE COV(.,.,.)
C  MATRIX HAS NO REAL THEORETICAL BASIS, IT DOESN'T MATTER.

        SUMWEIGHT = 0.D0
        DO IGAUS = 1,NGAUS
         READ(45,*) (AMEAN(IGAUS,J),J=1,NVAR),COF(IGAUS)
         SUMWEIGHT = SUMWEIGHT + COF(IGAUS)
        END DO

        CLOSE(45)


C  ESTABLISH COV. AND COF. VALUES IF KKEY = 1.

      IF(KKEY .EQ. 1) THEN

C  NORMALIZE THE VALUES IN COF SO THAT THEY SUM TO 1.0.

        DO IGAUS = 1,NGAUS
         COF(IGAUS) = COF(IGAUS)/SUMWEIGHT
        END DO

C  ESTABLISH THE COVARIANCE MATRICES FOR THE NGAUS DISTRIBUTIONS
C  DEPENDING ON THE VALUE OF ICOVMAT. 

        IF(ICOVMAT .EQ. 1) THEN
          DO IGAUS = 1,NGAUS


           DO I = 1,NVAR
            DO J = 1,I
             COV(IGAUS,I,J) = COVV(I,J)/NGAUS
            END DO
          END DO
         END DO
        ENDIF


        IF(ICOVMAT .EQ. 0) THEN
          DO IGAUS = 1,NGAUS
           DO I = 1,NVAR
            DO J = 1,I
             COV(IGAUS,I,J) = 0.D0
             IF(I .EQ. J) COV(IGAUS,I,I) = AMEAN(IGAUS,I)*.0625D0
            END DO
          END DO
         END DO
        ENDIF

      ENDIF
C  ABOVE ENDIF IS FOR THE  IF(KKEY .EQ. 1)  CONDITION.


C  SET COV. AND COF. VALUES IF KKEY = 2.


  260 CONTINUE


      IF(KKEY .EQ. 2) THEN

C  RATHER THAN NORMALIZING THE VALUES IN COF SO THAT THEY SUM TO 1.0,
C  SET THEM ALL TO 1. IT DOESN'T MATTER SINCE THEY WON'T BE USED.


       DO IGAUS = 1,NGAUS
        COF(IGAUS) = 1.D0
       END DO


       DO IGAUS = 1,NGAUS
        DO I = 1,NVAR
         DO J = 1,I
          COV(IGAUS,I,J) = 0.D0
         END DO
        END DO
       END DO


      ENDIF
C  ABOVE ENDIF IS FOR THE  IF(KKEY .EQ. 2)  CONDITION.





        RETURN
        END

























C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C	
        SUBROUTINE READBLOCK2(PATH,C0,C1,C2,C3,
     1    INTLIST,RPAR,IPAR)

        use npag_utils, only: verifyval, thesame

	IMPLICIT REAL*8(A-H,O-Z)
	PARAMETER(MAXNUMEQ=7)

C  THIS ROUTINE IS BASED ON SUBROUTINE READBLOCK IN NPBG15E1.FOR, BUT
C  INSTEAD OF CREATING A WORKING COPY PATIENT DATA FILE FOR EACH BLOCK
C  OF DATA IN THE .CSV FILE ALREADY OPENED AS FILE 66 IN MAIN, IT ONLY
C  CREATES ONE MULTIPLE DRUG WORKING COPY PATIENT DATA FILE, 
C  XQZPJ001.ZMQ, FROM THE FIRST SUBJECT'S DATA. SO MAXSUB WILL BE 
C  HARDCODED = 1 BELOW, AND ALL DIMENSIONS WHICH WERE MAXSUB IN
C  NPBG15E1.FOR/READBLOCK WILL NOW BE 1.

        integer, dimension(128) :: INTLIST
        double precision, dimension(257) :: RPAR
        integer, dimension(257) :: IPAR

        DIMENSION TIMOUT(1,MAXNUMEQ,650),TIMIV(1,7,5200),
     1   NTIMOUT(1,MAXNUMEQ),NTIMIV(1,7),RATEIV(1,7,5200),
     2   BOLUS(1,7,5200),OUT(1,MAXNUMEQ,650),COV(1,26,5200),
     3   ICOVTYPE(26),TIMBOL(1,7,5200),NTIMBOL(1,7),NTIMCOV(1,26),
     4   TIMCOV(1,26,5200),TIMALL(1,24000),NTIMALL(1),TIMI(24000),
     5   C0(MAXNUMEQ),C1(MAXNUMEQ),C2(MAXNUMEQ),C3(MAXNUMEQ),
     6   CSUB(1,4,MAXNUMEQ),NSST(1),DOSELINEST(1,99,100),XVERIFY(900)



        CHARACTER READLINE*1000,COVNAME(26)*11,NUMBER(1)*3,
     1   PATFIL*20,CHARSUB*3,SUBID*11,SUBIDPREV*11,SUBARRAY(1)*11,
     3   PATH*61,TMPFILE*32,PATHFILE*93,ERRFIL*20

      COMMON/ERROR/ERRFIL
C  COMMON/ERROR/ IS SUPPLIED TO ALL THE ROUTINES WHICH COULD WRITE TO
C  ERRFIL.

    1   FORMAT(A1000)


C  SET MAXSUB = 1 SINCE ONLY 1 SUBJECT WILL BE CREATED BY THIS ROUTINE.


        MAXSUB = 1



C  INITIALIZE NDRUG (THE NO. OF DRUGS IN THE PATIENT DATA SET) TO BE
C  0. EVERY TIME IDRUGNO IS READ BELOW, NDRUG WILL BE SET = 
C  MAX(NDRUG,IDRUGNO).


C  SIMILARLY, INITIALIZE NOUT (THE NO. OF OUTPUT EQUATIONS IN THE

C  PATIENT DATA SET) TO BE 0. EVERY TIME IOUTEQ IS READ BELOW, 
C  NOUT WILL BE SET = MAX(NOUT,IOUTEQ).

	NDRUG = 0
        INTLIST(5) = NDRUG
	NOUT = 0

C  INITIALIZE NSST(ISUB) TO 0. IT GIVES THE NO. OF STEADY STATE DOSE
C  LINES THAT WILL BE WRITTEN TO THE DOSAGE BLOCK FOR EACH SUBJECT. 

      DO ISUB = 1,MAXSUB
       NSST(ISUB) = 0
      END DO



C  NOTE THAT ANY LINE STARTING WITH A # WILL BE IGNORED. THE FIRST LINE
C  WILL ALSO BE IGNORED - IT HAS ALREADY BEEN VERIFIED TO HAVE THE
C  REQUIRED CODE IN IT.


	READ(66,*)

C  READ THE 2ND LINE, WHICH MUST HAVE A # AS THE FIRST CHARACTER. IT HAS
C  THE NAMES OF THE COLUMNS. COUNT THE NO. OF COMMAS ON THE LINE. THE 
C  NO. OF COVARIATES WILL BE THE NO. OF COMMAS - 11 (SINCE THERE ARE 12
C  FIXED ENTRIES WHICH POTENTIALLY SHOW UP ON EACH LINE: PATIENT ID, 

C  EVENT ID, TIME, INFUSION DURATION, TOTAL DOSE, INPUT DRUG NO.,
C  OUTPUT VALUE, OUTPUT EQ., AND 4 SPOTS FOR ASSAY COEFFICIENTS WHICH 
C  ONLY SHOW UP ON OUTPUT LINES). NOTE THAT THIS VALUE WILL BE CALLED
C  NCOVA, WHICH MEANS NO. OF ADDITION COVARIATES (IN ADDITION TO THE 4

C  PERMANENT ONES AT THE TOP OF EACH PATIENT'S WORKING COPY FILE (AGE,
C  SEX, HEIGHT, ETHNICITY FLAG), ... TO BE CONSISTENT WITH THE NAME 
C  USED IN NPAG100.FOR.

	  READ(66,1) READLINE


	NCOMMA = 0

	DO ISTART = 1,1000

	 IF(READLINE(ISTART:ISTART) .EQ. ',') THEN
	  NCOMMA = NCOMMA + 1
	 ENDIF

	END DO	    

	NCOVA = NCOMMA - 11


	IF(NCOVA .GT. 0) THEN

C  READ THE NAMES OF THE NCOVA COVARIATES FROM THE LINE STARTING WITH
C  #ID OR "#ID. 

C  NOTE THAT AFTERCOMMA OPENS AND PUTS INTO FILE 57 THE PART OF READLINE
C  WHICH IS BETWEEN COMMA C AND COMMA C+1, WHERE C IS THE 3RD ARGUMENT.
C  ALSO,NOTE THAT NCOVA MUST BE PROVIDED TO AFTERCOMMA SO IT WILL KNOW
C  THE TOTAL NO. OF COMMAS IN READLINE (WHICH = 11 + NCOVA).

	REWIND(66)
  120	READ(66,1) READLINE
	IF(READLINE(1:3) .NE. '#ID' .AND. READLINE(1:4).NE. '"#ID' 
     1  .AND. READLINE(1:3) .NE. '#id' .AND. READLINE(1:4).NE. '"#id')
     2   GO TO 120

	 DO ICOV = 1,NCOVA
	  CALL AFTERCOMMA(NCOVA,READLINE,11+ICOV)
	  BACKSPACE(57)
	  READ(57,2) COVNAME(ICOV)
    2     FORMAT(A11)
	  CLOSE(57)
	 END DO


	ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(NCOVA .GT. 0)  CONDITION.


C  CALL SUBROUTINE GETMAXTIM TO GET THE MAXIMUM TIME OVER ALL THE
C  SUBJECTS IN FILE 66. THIS INCLUDES THE ENDING TIME OVER ALL IV
C  EVENTS. THEN SET TIMADD = THIS TIME + 1. FOR EACH SUBJECT BELOW,
C  EACH TIME WILL HAVE TIMADD*NRESET ADDED TO IT, WHERE NRESET IS THE 
C  NO. OF TIME RESETS (FOR THAT SUBJECT) UP TO AND INCLUDING THAT TIME. 
C  THIS WILL MAKE EACH TIME A UNIQUE TIME (I.E., WITH TIME RESETS IN
C  THE BLOCK FORMAT FILE, THERE COULD BE MANY TIMES WITH THE SAME 
C  VALUE).

	CALL GETMAXTIM(NCOVA,TIMAX)



C  VERIFY THAT TIMAX WAS CALCULATED CORRECTLY - I.E., THAT IT IS NOT
C  STILL THE INITIALIZED NEGATIVE VALUE IN GETMAXTIM.

	IF(TIMAX .LT. 0) THEN



	 WRITE(*,11) 
   11    FORMAT(/' THERE IS SOMETHING WRONG WITH YOUR BLOCK FORMAT'/


     1' FILE. THE TIMES IN COLUMN 3 AND/OR THE TIME DURATIONS'/
     2' IN COLUMN 4 ARE BAD. PLEASE CHECK YOUR VALUES. '//
     3' THE PROGRAM STOPS.')

        OPEN(42,FILE=ERRFIL)
         WRITE(42,11)
        CLOSE(42)



	 CALL PAUSE
	 STOP



	ENDIF

   	TIMADD = TIMAX + 1.D0


C  REWIND FILE 66, READ PAST THE FIRST LINE WHICH HAS THE CODE, AND 
C  THE SECOND LINE, WHICH HAS THE COVARIATE INFORMATION ON IT, AND
C  THEN READ ALL LINES, EXCEPT THOSE THAT START WITH # OR "#.
C  GO THROUGH EACH SUCCEEDING LINE IN FILE 66 AND EXTRACT ALL THE 
C  INFORMATION. NOTE THAT EACH LINE CAN CONTAIN OUTPUT INFO OR DOSAGE
C  INFO (INCLUDING COVARIATE VALUES), DEPENDING ON THE VALUE FOR IDEVENT
C  (THE 2ND ENTRY IN EACH LINE), BUT NOT BOTH. IN PARTICULAR, IF
C  IDEVENT = 0 --> THE ROW HAS OUTPUT EQUATION INFO.
C  IDEVENT = 1 --> THE ROW HAS DOSAGE/COVARIATE INFO.
C  IDEVENT = 4 --> SAME AS IDEVENT = 1, EXCEPT THIS ROW REPRESENTS A 
C                  TIME RESET.

	REWIND(66)
	READ(66,1)
	READ(66,1)

C  INITIALIZE SUBIDPREV (THE PREVIOUS SUBJECT ID) TO BE '%^&*' SO THE 
C  FIRST SUJBECT ID READ IN BELOW WILL BE DIFFERENT THAN THIS, AND SO 

C  START THE SUBJECT ID LOGIC. ALSO, INITIALIZE THE SUBJECT NO. TO 0.

	SUBIDPREV = '%^&*'
	NSUB = 0

C  NOTE THAT IEND .LT. 0 --> END OF FILE REACHED.	

   10	READ(66,1,IOSTAT=IEND) READLINE

	IF(IEND .LT. 0) GO TO 100
	IF(READLINE(1:1) .EQ. '#' .OR. READLINE(1:2) .EQ. '"#') GO TO 10

C  THE FIRST VALUE (I.E., AFTER COMMA NO. 0) IS THE SUBJECT ID.

	CALL AFTERCOMMA(NCOVA,READLINE,0)
	BACKSPACE(57)
	READ(57,2) SUBID

	CLOSE(57)

C  NOTE THAT SUBID CONTAINS THE 1ST 11 CHARACTERS OF THE LINE, BUT THE
C  SUBJECT ID IS JUST THE SET OF CHARACTERS PRIOR TO THE 1ST COMMA.
C  CALL SUBROUTINE GETID TO CORRECT THE VALUE OF SUBID.

	CALL GETID(SUBID)

C  IF SUBID = SUBIDPREV, THIS IS ANOTHER LINE FOR THE CURRENT SUBJECT. 
C  IF SUBID .NE. SUBIDPREV, THIS IS THE 1ST EVENT FOR A NEW SUBJECT, SO 
C  INCREASE NSUB, AND SET THE NO. OF INFUSIONS (FOR EACH DRUG), BOLI, 
C  OBSERVATION, AND COVARIATE TIMES FOR THIS SUBJECT TO 0 (THEY WILL 
C  BE UPDATED BELOW AS REQUIRED). SIMILARY SET THE TOTAL NO. OF DOSE 
C  EVENTS = 0. 

C  ALSO, SINCE THIS IS A NEW SUBJECT, DEFAULT THE ASSAY COEFFICIENTS FOR
C  OUTPUT EQ. IEQ TO [C0(IEQ),C1(IEQ),C2(IEQ),C3(IEQ)], 
C  IEQ = 1,MAXNUMEQ (MAXNUMEQ IS THE MAXIMUM THAT NUMEQT CAN BE). THEN,
C  AS THIS SUBJECT'S INFO IS BEING READ BELOW, ANY ASSAY C'S SPECIFIED
C  FOR THIS SUBJECT WILL OVERWRITE THE DEFAULT VALUES. AND NOTE THAT IF
C  A SUBJECT HAS MORE THAN ONE SET OF ASSAY C'S FOR A GIVEN OUTPUT EQ.,
C  THE LAST SET WILL BE USED.

C  NOTE THAT AFTER READBLOCK2 HAS FINISHED READING THE PATIENT INFO,
C  CSUB(I,J,K), J=1,4 WILL BE ASSAY C'S [C0 C1 C2 C3] FOR SUBJECT I
C  AND OUTPUT EQ. K. 
 


	IF(SUBID .NE. SUBIDPREV) THEN

	 SUBIDPREV = SUBID
	 NSUB = NSUB + 1

C  FASTFORWARD THE LOGIC TO THE END OF THE ROUTINE IF NSUB = 2, SINCE
C  THE INFO FOR THE FIRST SUBJECT WILL ALREADY HAVE BEEN READ IN. AND 
C  RESET NSUB = 1 AT THAT POINT SINCE ONLY THE FIRST SUBJECT'S DATA WILL
C  BE NEEDED.

        IF(NSUB .EQ. 2) GO TO 100


	 WRITE(*,8888) NSUB
 8888    FORMAT('+ ',' NOW WORKING ON SUBJECT NO. ',I4)

	 SUBARRAY(NSUB) = SUBID

	 NTIMALL(NSUB) = 0

	 DO K = 1,7
	  NTIMIV(NSUB,K) = 0
	  NTIMBOL(NSUB,K) = 0
	 END DO

	 DO K = 1,26
	  NTIMCOV(NSUB,K) = 0
	 END DO

        DO K = 1,MAXNUMEQ
         NTIMOUT(NSUB,K) = 0
         CSUB(NSUB,1,K) = C0(K)
         CSUB(NSUB,2,K) = C1(K)
         CSUB(NSUB,3,K) = C2(K)
         CSUB(NSUB,4,K) = C3(K)
        END DO


C  SEE LOGIC BELOW. IF THIS ROW REPRESENTS A TIME RESET, THEN AN
C  EXTRA VALUE (-99) AT AN EXTRA TIME (0) WILL BE ADDED TO EACH OUTPUT
C  EQUATION ARRAY. BUT THIS NEEDS TO BE DONE JUST ONCE FOR EACH TIME

C  RESET, NOT FOR EACH DOSAGE LINE THAT HAS A RESET. I.E., IF THERE
C  ARE 5 DRUGS, THEN THERE COULD BE AS MANY AS 5 DOSE LINES WITH A
C  RESET VALUE. ALSO, WITHIN EACH LINE, A DOSE AND/OR A COVARIATE
C  COULD HAVE A RESET TIME OF 0. THEREFORE EACH BLOCK OF CODE BELOW,
C  FOR EACH DRUG NO. AND EACH COVARIATE, IS TESTED FOR A TIME RESET,
C  AND IN EACH CASE, EXTRA LINES ARE POTENTIALLY ADDED TO THE OUPUT 
C  ARRAYS. TO PREVENT MORE EXTRA LINES (OF OUTPUT VALUES = -99 AT
C  TIMES = 0) THAN ARE NECESSARY, INITIALIZE NRESETADD = 0. THIS 
C  TELLS THE PROGRAM THAT NO EXTRA LINES HAVE BEEN ADDED TO THE OUTPUT
C  ARRAYS SINCE THE LAST ACTUAL OUTPUT VALUE WAS PUT INTO ONE OF THE
C  ARRAYS. NRESETADD WILL BE CHANGED TO 1 WHENEVER EXTRA LINES HAVE
C  BEEN ADDED TO THE OUTPUT ARRAYS, AND THEN BACK TO 0 WHENEVER ANOTHER
C  ACTUAL OUTPUT VALUE HAS BEEN PUT INTO AN ARRAY.

	NRESETADD = 0

C  INITIALIZE NRESET TO 0. IT WILL BE THE NO. OF TIME RESETS THAT
C  HAVE OCCURRED UP TO ANY TIME. ALSO INITIALIZE TIMERESET = 0; THIS 
C  WILL BE THE RUNNING TIME TO BE ADDED TO EACH ACTUAL TIME. IT WILL
C  ALWAYS BE SET = TIMADD*NRESET BELOW.

	NRESET = 0	
	TIMERESET = TIMADD*NRESET

C  ALSO INITIALIZE NRESETLAST = -1 (SEE CODE BELOW).

       NRESETLAST = -1
       DOSELINEST(NSUB,1,100) = -99

C  DOSELINE(NSUB,1,100) IS INITIALIZED TO BE -99. IF IT CHANGES BELOW
C  TO BE .GE. 0, IT MEANS THAT THERE IS AT LEAST ONE STEADY STATE DOSE
C  SET, AND THE FIRST ONE OCCURS AT THE VALUE OF NRESET =
C  DOSELINEST(NSUB,1,100).


C  VERIFY THAT THE 2ND VALUE (I.E., AFTER COMMA NO. 1), WHICH IS THE 
C  EVENT ID, IDEVENT, IS 1 SINCE THE FIRST EVENT FOR EACH SUBJECT

C  SHOULD BE 1 (A NON-TIME-RESET DOSE EVENT).

	CALL AFTERCOMMA(NCOVA,READLINE,1)
	BACKSPACE(57)
	READ(57,*) IDEVENT
	CLOSE(57)

	IF(IDEVENT .NE. 1) THEN



	 WRITE(*,402) SUBARRAY(NSUB),IDEVENT
  402    FORMAT(/' THERE IS AN ERROR IN THE BLOCK FORMAT. FOR SUBJECT '/
     1 1X,A11,', THE FIRST EVENT ID IS NOT 1 AS REQUIRED. IT IS ',I3/
     3' THE PROGRAM STOPS.'/)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,402) SUBARRAY(NSUB),IDEVENT
        CLOSE(42)

	 CALL PAUSE
	 STOP



	ENDIF


	ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(SUBID .NE. SUBIDPREV)  CONDITION.


C  THE 2ND VALUE (I.E., AFTER COMMA NO. 1) IS THE EVENT ID, IDEVENT 

C  (SEE ABOVE).               
	
	CALL AFTERCOMMA(NCOVA,READLINE,1)
	BACKSPACE(57)
	READ(57,*) IDEVENT
	CLOSE(57)

C  IF THE ID OF THIS EVENT IS NO. 4, IT IS A TIME RESET EVENT. IN THIS
C  CASE, INCREASE NRESET AND TIMERESET AS INDICATED ABOVE.


	IF(IDEVENT .EQ. 4) THEN
	 NRESET = NRESET + 1
	 TIMERESET = TIMADD*NRESET
	ENDIF


C  THE 3RD VALUE (I.E., AFTER COMMA NO. 2) IS THE TIME OF THE EVENT.
C  READ THIS VALUE NOW.
	

	CALL AFTERCOMMA(NCOVA,READLINE,2)
	BACKSPACE(57)
	READ(57,*) TIMEVENT
	CLOSE(57)


      IF(TIMEVENT .LT. 0.D0) THEN

C  STORE INTO DOSELINEST(.,.,.) ALL THE INFO FOR THE WORKING COPY FILE
C  FOR THIS STEADY STATE DOSE SET.



C  COMPARE NRESET WITH THE PREVIOUS VALUE OF NRESET WHEN THIS PART OF
C  THE CODE WAS USED: IF THEY ARE THE SAME, THIS LINE WILL PROVIDES
C  MORE INFO (FOR A DIFFERENT DRUG NO.) FOR THE SAME STEADY STATE DOSE
C  EVENT TO BE PUT INTO THE WORKING COPY FILE. IF THEY ARE DIFFERENT,
C  THIS LINE IS THE FIRST LINE OF A NEW STEADY STATE DOSE SET.


       IF(NRESET .GT. NRESETLAST) THEN

C  PUT IN NEW INFO FOR A NEW LINE (FOR A NEW STEADY STATE DOSE SET).
C  THIS LINE IS THE FIRST LINE WITH INFO ON A NEW STEADY STATE DOSE SET.
C  STORE ALL THE INFO FROM THIS LINE, INCLUDING NRESET, SO SUBROUTINE
C  WRITEDOS CAN WRITE THE INFO FOR THIS LINE SEPARATELY. NOTE THAT THIS
C  LINE WILL NOT BE A PART OF THE LOGIC BELOW WHICH STORES ALL DOSE 
C  INFO, AND THEN SORTS IT BY TIME. NOTE THAT NRESET IS STORED INTO
C  ENTRY 100 FOR THIS LINE.

        NSST(NSUB) = NSST(NSUB) + 1

        IF(NSST(NSUB) .GT. 99) THEN



         WRITE(*,172) NSUB
  172    FORMAT(/' FOR SUBJECT NO. ',I5,' THE NO. OF STEADY STATE DOSE'/
     1' SETS IS MORE THAN 99, THE MAXIMUM ALLOWED. PLEASE RERUN THE'/
     2' PROGRAM AFTER REDUCING THE NO. OF STEADY STATE DOSE SETS TO'/
     3' NO MORE THAN 99.'//
     4' THE PROGRAM STOPS.'/)
	  WRITE(*,401) NSUB,SUBARRAY(NSUB)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,172) NSUB                  
        CLOSE(42)



         CALL PAUSE
         STOP



        ENDIF


        DOSELINEST(NSUB,NSST(NSUB),100) = NRESET

C  TIMEVENT IS THE NEGATIVE OF THE INTERDOSE INTERVAL, WHICH WILL SHOW
C  UP IN THE TIME COLUMN OF THE WORKING COPY FILE.

        DOSELINEST(NSUB,NSST(NSUB),1) = TIMEVENT

C  ZERO OUT ALL THE IV AND BOLUS ENTRIES FOR ALL POSSIBLE DRUGS
C  (I.E., THERE COULD BE AS MANY AS 7 DRUGS).

        DO I = 1,7
         DOSELINEST(NSUB,NSST(NSUB),2*I) = 0.D0
         DOSELINEST(NSUB,NSST(NSUB),2*I+1) = 0.D0
        END DO


C  STORE ANY COVARIATE INFO INTO THE COVARIATE ENTRIES. NOTE IT IS NOT
C  KNOWN AT THIS POINT HOW MANY TOTAL DRUGS ARE USED IN THE MODEL SINCE
C  THE VALUE FOR NDRUG HAS NOT YET FINISHED UPDATING (IN THE CODE BELOW,
C  IT IS SET = IDRUGNO IF NDRUG .LT. IDRUGNO). SO, THE COVARIATE VALUES
C  WILL BE STORED FAR ENOUGH OUT IN THE DOSELINEST(.,.,.) ARRAY TO NOT
C  INTERFERE WITH THE ENTRIES FOR THE MAXIMUM NO. OF POSSIBLE DRUGS.
C  SINCE THERE ARE AT MOST 7 POSSIBLE DRUGS, ENTRIES 2,3,...,14,15 WILL
C  BE RESERVED FOR THESE DRUG VALUES, AND THE COVARIATE VALUES WILL
C  START WITH ENTRY NO. 20.


        IF(NCOVA .GT. 0) THEN
         
         DO 110 ICOV = 1,NCOVA
          CALL AFTERCOMMA(NCOVA,READLINE,11+ICOV)
          BACKSPACE(57)
 	    READ(57,*,ERR=95) COVVAL
	    CLOSE(57)
          DOSELINEST(NSUB,NSST(NSUB),19+ICOV) = COVVAL

          GO TO 110
   95     DOSELINEST(NSUB,NSST(NSUB),19+ICOV) = -99.D0
  110    CONTINUE

        ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(NCOVA .GT. 0)  CONDITION.


C  THIS IS EITHER A TIME RESET EVENT, OR THE TOP OF THE PATIENT'S FILE.
C  IF IT IS THE TOP OF THE PATIENT'S FILE, NRESET WILL = 0. IF IT IS A 
C  TIME RESET EVENT, NRESET WILL BE > 0, AND IN THIS CASE, MUST STORE 
C  VALUES INTO THE OUPUT ARRAYS (SEE LOGIC BELOW) WHICH INDICATE THAT

C  SUBSEQUENT OUTPUT TIMES ARE BASED ON THIS TIME RESET.

       IF(NRESET .GT. 0) THEN
        DO IOUTEQ = 1,MAXNUMEQ
         NTIMOUT(NSUB,IOUTEQ) = NTIMOUT(NSUB,IOUTEQ) + 1
         TIMOUT(NSUB,IOUTEQ,NTIMOUT(NSUB,IOUTEQ)) = TIMERESET
         OUT(NSUB,IOUTEQ,NTIMOUT(NSUB,IOUTEQ)) = -99.D0
        END DO
       ENDIF


       ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(NRESET .GT. NRESETLAST)  CONDITION.


C  ESTABLISH THE DURATION, (4TH VALUE, AFTER THE 3RD COMMA), DOSE (5TH
C  VALUE, AFTER THE 4TH COMMA), AND DRUG NO. (6TH VALUE, AFTER THE 5TH

C  COMMA) FOR THIS LINE.

        CALL AFTERCOMMA(NCOVA,READLINE,3)
        BACKSPACE(57)
        READ(57,*,ERR=170) DUR
        CLOSE(57)


        CALL AFTERCOMMA(NCOVA,READLINE,4)
        BACKSPACE(57)
        READ(57,*,ERR=170) TOTDOS

        CLOSE(57)

        CALL AFTERCOMMA(NCOVA,READLINE,5)
        BACKSPACE(57)
        READ(57,*,ERR=170) IDRUGNO
	  IF(NDRUG .LT. IDRUGNO) THEN
            NDRUG = IDRUGNO
            INTLIST(5) = NDRUG
          ENDIF
        CLOSE(57)

C  STORE THE IV RATE INTO THE IV ENTRY FOR DRUG NO. IDRUGNO; SIMILARLY,
C  STORE THE TOTAL DOSE INTO THE BOLUS ENTRY FOR DRUG NO. IDRUGNO.
C  NOTE THAT IF DUR = 0, THIS LINE REPRESENTS A STEADY STATE OF BOLUS 
C  VALUES. IN THIS CASE, SET THE IV RATE TO 0.

        IF(DUR .LE. 0.D0) 
     1   DOSELINEST(NSUB,NSST(NSUB),2*IDRUGNO) = 0.D0
        IF(DUR .GT. 0.D0)
     1   DOSELINEST(NSUB,NSST(NSUB),2*IDRUGNO) = TOTDOS/DUR
        DOSELINEST(NSUB,NSST(NSUB),2*IDRUGNO+1) = TOTDOS




C  NOTE THAT COVARIATE VALUES ARE ONLY READ FOR THE FIRST DOSE LINE
C  IN A STEADY STATE SET (I.E., WHEN NRESET .GT. NRESETLAST). IT IS
C  POSSIBLE THAT THE USER'S .csv FILE HAS A DIFFERENT SET OF COV. VALUES
C  FOR EACH LINE (FOR A DIFFERENT DRUG) THAT IS INCLUDED IN THE 
C  CURRENT STEADY STATE DOSE SET. BUT, THIS WOULD BE A MISTAKE SINCE
C  ONLY 1 SET OF COV. VALUES CAN BE USED FOR THE STEADY STATE SET. THE
C  FIRST SET OF VALUES WILL BE USED (AND ALL OTHERS WILL BE IGNORED).
 
C  SET NRESETLAST = NRESET SO IF ANOTHER LINE OF DOSE INFO FOR THE
C  CURRENT STEADY STATE SET FOLLOWS, THE PROGRAM WILL KNOW IT IS
C  MORE INFO ON THE CURRENT SET, AND NOT NEW INFO ON THE NEXT SET.
  
       NRESETLAST = NRESET

       GO TO 10


  170  WRITE(*,171) NSUB,READLINE(1:75)
  171  FORMAT(/' THERE IS AN ERROR IN YOUR BLOCK FORMAT FILE FOR '/
     1' SUBJECT NO. ',I5,'. EITHER THE DURATION, THE DOSE, OR THE '/
     2' DRUG NUMBER IS MISSING. THE 1ST 75 CHARACTERS OF THE LINE ARE:'/
     2A75//
     3' THE PROGRAM STOPS.'/)
	 WRITE(*,401) NSUB,SUBARRAY(NSUB)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,401) NSUB,SUBARRAY(NSUB)
        CLOSE(42)



  	 CALL PAUSE
	 STOP

      ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(TIMEVENT .LT. 0.D0)  CONDITION.




	TIMEVENT = TIMEVENT + TIMERESET




C  IF IDEVENT = 0, IT MEANS THAT THIS ROW IS AN OBSERVED VALUE ROW.
C  IN THIS CASE, READ THE OBSERVED VALUE INFO.

	IF(IDEVENT .EQ. 0) THEN

C  THE 7TH ENTRY (AFTER COMMA NO. 6) IS AN OUTPUT VALUE FOR THIS TIME 
C  IF THERE IS AN ERROR, IT IS ASSUMED THAT THE PROGRAM READ A DOT,

C  WHICH WOULD BE INCONSISTENT SINCE IDEVENT = 0 (MEANING THERE SHOULD
C  BE AN OUTPUT VALUE ON THE ROW).

	CALL AFTERCOMMA(NCOVA,READLINE,6)
	BACKSPACE(57)
	READ(57,*,ERR=30) YVAL
	CLOSE(57)

C  TO GET TO THIS POINT --> YVAL CONTAINS AN OUTPUT VALUE FOR THIS
C  LINE. BEFORE THIS VALUE CAN BE STORED, MUST READ THE OUTPUT EQUATION 
C  NO. AFTER COMMA NO. 7. 

	CALL AFTERCOMMA(NCOVA,READLINE,7)
	BACKSPACE(57)

	READ(57,*,ERR=30) IOUTEQ
	IF(NOUT .LT. IOUTEQ) NOUT = IOUTEQ 
	CLOSE(57)

C  STORE THIS VALUE. ALSO STORE THE TIME OF THIS EVENT INTO THE ARRAY 
C  WHICH STORES OUTPUT TIMES.

	NTIMOUT(NSUB,IOUTEQ) = NTIMOUT(NSUB,IOUTEQ) + 1
	TIMOUT(NSUB,IOUTEQ,NTIMOUT(NSUB,IOUTEQ)) = TIMEVENT
	OUT(NSUB,IOUTEQ,NTIMOUT(NSUB,IOUTEQ)) = YVAL
	NRESETADD = 0

C  SEE CODE ABOVE REGARDING NRESEADD.


	GO TO 20

C  REPLACE WRITING OF TIMEVENT - TIMERESET WITH XVERIFY (SEE LOGIC IN 
C  SUBROUTINE VERIFYVAL.

   30   XVERIFY(1) = TIMEVENT - TIMERESET
        CALL VERIFYVAL(1,XVERIFY)
C  30   WRITE(*,31) NSUB, TIMEVENT - TIMERESET
        WRITE(*,31) NSUB, XVERIFY(1)
   31   FORMAT(/' THERE IS AN ERROR IN THE BLOCK FORMAT. FOR SUBJECT '/
     1' NO. ',I4,' AND TIME ',F10.4, ' A LINE HAS AN EVENT ID OF 0 IN'/
     2' COL. 2, INDICATING OBSERVED VALUE INFORMATION. BUT THERE IS '/
     3' EITHER NO OBSERVED VALUE IN COL. 7, OR NO OUTPUT EQUATION NO.'/
     4' IN ENTRY 8. '//
     3' THE PROGRAM STOPS.')
	  WRITE(*,401) NSUB,SUBARRAY(NSUB)
  401   FORMAT(/' NOTE: THE ID FOR SUBJECT NO. ',I4,' IS ',A11/)

        OPEN(42,FILE=ERRFIL)
C        WRITE(42,31) NSUB, TIMEVENT - TIMERESET
         WRITE(42,31) NSUB, XVERIFY(1)
         WRITE(42,401) NSUB,SUBARRAY(NSUB)
        CLOSE(42)	

        CALL PAUSE
        STOP

   20 CONTINUE

C  THE 9TH - 12TH ENTRIES FOR THIS ROW POTENTIALLY HOLD NEW ASSAY 
C  COEFFICIENTS FOR THIS SUBJECT (NSUB) AND OUTPUT EQ. (IOUTEQ).
C  READ THESE VALUES. IF THEY ARE NOT MISSING, UPDATE THE ASSAY
C  COEFFICIENT INFO FOR THIS SUBJECT/OUTPUT EQ.

C  NOTE THAT THESE ENTRIES SHOULD ALL BE MISSING (DOTS OR n's) OR ALL
C  BE NUMBERS. IF THERE IS A COMBINATION  OF MISSING VALUES AND NUMBERS,
C  STOP THE PROGRAM AND TELL THE USER.

        IMISSC0 = 0
        IMISSC1 = 0
        IMISSC2 = 0
        IMISSC3 = 0
      
        CALL AFTERCOMMA(NCOVA,READLINE,8)
        BACKSPACE(57)
        READ(57,*,ERR=230) C00

        CLOSE(57)


        GO TO 235
  230   IMISSC0 = 1

  235   CALL AFTERCOMMA(NCOVA,READLINE,9)
        BACKSPACE(57)
        READ(57,*,ERR=240) C11
        CLOSE(57)

        GO TO 245

  240   IMISSC1 = 1

  245   CALL AFTERCOMMA(NCOVA,READLINE,10)
        BACKSPACE(57)
        READ(57,*,ERR=250) C22
        CLOSE(57)

        GO TO 255
  250   IMISSC2 = 1

  255   CALL AFTERCOMMA(NCOVA,READLINE,11)
        BACKSPACE(57)
        READ(57,*,ERR=260) C33
        CLOSE(57)

        GO TO 265
  260   IMISSC3 = 1



  265   CONTINUE

C  IF ALL IMISSCx VALUES ARE 0, UPDATE THE ASSAY C'S FOR THIS
C  SUBJECT AND OUTPUT EQ. NO. IF ALL IMISSCx VALUES ARE 1, THEY
C  ARE ALL MISSING, SO JUST CONTINUE. IF SOME OF THE IMISSCx VALUES
C  ARE 0 AND SOME ARE 1, THIS IS AN INCONSISTENCY (I.E., THE USER HAS
C  ENTERED SOME BUT NOT ALL OF THE ASSAY C'S). IN THIS CASE, STOP THE
C  PROGRAM AFTER INFORMING THE USER OF HIS ERROR.

        ISUMC = IMISSC0 + IMISSC1 + IMISSC2 + IMISSC3

        IF(ISUMC .EQ. 0) THEN
         CSUB(NSUB,1,IOUTEQ) = C00
         CSUB(NSUB,2,IOUTEQ) = C11
         CSUB(NSUB,3,IOUTEQ) = C22
         CSUB(NSUB,4,IOUTEQ) = C33
        ENDIF

        IF(ISUMC .NE. 0 .AND. ISUMC .NE. 4) THEN

C  REPLACE WRITING OF TIMEVENT - TIMERESET WITH XVERIFY (SEE LOGIC IN 
C  SUBROUTINE VERIFYVAL.

         XVERIFY(1) = TIMEVENT - TIMERESET
         CALL VERIFYVAL(1,XVERIFY)
C        WRITE(*,231) NSUB, TIMEVENT - TIMERESET,IOUTEQ
         WRITE(*,231) NSUB, XVERIFY(1),IOUTEQ
  231    FORMAT(/' THERE IS AN ERROR IN THE BLOCK FORMAT. FOR SUBJECT '/
     1' NO. ',I4,' AND TIME ',F10.4, ' A LINE HAS AN EVENT ID OF 0 IN'/
     2' COL. 2, INDICATING OBSERVED VALUE INFORMATION, BUT THIS LINE'/
     3' HAS AN INCOMPLETE SET OF ASSAY COEFFICIENTS FOR OUTPUT EQ. '/
     4' NUMBER ',I3,'. THERE MUST BE EITHER 4 ASSAY COEFFICIENTS ON'/
     5' AN OUTPUT LINE, OR NONE (IF NO OUTPUT LINES FOR A PARTICULAR'/
     6' SUBJECT x OUTPUT EQ. COMBO HAVE ASSAY COEFFICIENTS, THEN THE'/
     7' POPULATION COEFFICIENTS WILL BE USED).'//
     8' THE PROGRAM STOPS.')
         WRITE(*,401) NSUB,SUBARRAY(NSUB)

        OPEN(42,FILE=ERRFIL)
C        WRITE(42,231) NSUB, TIMEVENT - TIMERESET,IOUTEQ
         WRITE(42,231) NSUB, XVERIFY(1),IOUTEQ
         WRITE(42,401) NSUB,SUBARRAY(NSUB)
        CLOSE(42)

         CALL PAUSE
         STOP


        ENDIF


	ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(IDEVENT .EQ. 0)  CONDITION.


	IF(IDEVENT .EQ. 1 .OR. IDEVENT .EQ. 4) THEN



C  IDEVENT = 1 OR 4 --> DOSE AND/OR COVARITE INFO IS TO BE READ IN.

C  THE 4TH ENTRY (AFTER COMMA NO. 3) IS AN INFUSION DURATION, AND THE
C  5TH ENTRY (AFTER COMMA NO. 4) IS THE TOTAL DOSE ... IF THIS LINE 
C  HAS DOSE INFORMATION. NOTE THAT IF THERE IS NO DOSE, THE TOTAL DOSE
C  ENTRY WILL BE A DOT ("."). ALSO, IF THERE IS A TOTAL DOSE, BUT THE
C  INFUSION DURATION IS 0, THIS LINE REPRESENTS A BOLUS INPUT.

C  SO, 1ST TRY READING THE TOTAL DOSE AS A REAL NUMBER; IF THERE IS AN 
C  ERROR, IT IS ASSUMED THAT THE PROGRAM READ A DOT.

	CALL AFTERCOMMA(NCOVA,READLINE,4)
	BACKSPACE(57)
	READ(57,*,ERR=40) TOTDOS 
	CLOSE(57)

C  TO GET TO THIS POINT --> TOTDOS CONTAINS A TOTAL DOSE VALUE FOR THIS
C  LINE. READ THE INFUSION DURATION AFTER COMMA NO. 3 TO SEE IF THIS
C  DOSE IS AN INFUSION (WITH A POSITIVE DURATION) OR A BOLUS (WITH A
C  0 DURATION).

	CALL AFTERCOMMA(NCOVA,READLINE,3)
	BACKSPACE(57)
	READ(57,*,ERR=50) DUR
	CLOSE(57)

C  BEFORE THIS VALUE CAN BE STORED, MUST READ THE DRUG NO. AFTER COMMA
C  NO. 5.

	CALL AFTERCOMMA(NCOVA,READLINE,5)
	BACKSPACE(57)
	READ(57,*,ERR=50) IDRUGNO
	IF(NDRUG .LT. IDRUGNO) THEN
          NDRUG = IDRUGNO
          INTLIST(5) = NDRUG
        ENDIF
	CLOSE(57)

C  STORE THE ABOVE VALUES DEPENDING ON WHETHER THEY REPRESENT AN
C  INFUSION OR A BOLUS INPUT.


C  INCREASE THE NO. OF DOSAGE LINES FOR THIS SUBJECT. IF DUR > 0, THE
C  NO. OF DOSAGE LINES INCREASES BY 2 SINCE THERE WILL BE A START TIME
C  AND AN ENDING TIME. IF DUR = 0, THE NO. OF DOSAGE LINES WILL INCREASE
C  BY 1.

	IF(DUR .GT. 0) THEN


C  THE INFUSION RATE IS TOTDOS/DUR. SO THE DOSE VALUE THE 1ST DOSE
C  TIME BELOW WILL BE THIS INFUSION RATE, AND THE DOSE VALUE AT THE
C  2ND DOSE TIME BELOW WILL BE 0.

C  NOTE THAT EVERYTIME NTIMALL(NSUB) IS INCREASED, THE PROGRAM CHECKS
C  THAT IT HAS NOT GONE PAST 24000. IF SO, A MESSAGE TO THE USER IS
C  WRITTEN THAT THIS IS NOT ALLOWED AND THE PROGRAM STOPS.

	 NTIMALL(NSUB) = NTIMALL(NSUB) + 1

	 IF(NTIMALL(NSUB) .GT. 24000) THEN



	  WRITE(*,3001) NSUB
 3001     FORMAT(/' THE NO. OF LINES IN THE DOSAGE REGIMEN FOR SUBJECT'/
     1' NO. ',I5,' IS MORE THAN THE LIMIT OF 24000. PLEASE RERUN THE'/
     2' PROGRAM AFTER REDUCING THIS NO. TO BE LESS THAN 24000.'/)
	  WRITE(*,401) NSUB,SUBARRAY(NSUB)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,3001) NSUB
         WRITE(42,401) NSUB,SUBARRAY(NSUB)
        CLOSE(42)	




	  CALL PAUSE
	  STOP



	 ENDIF


	 TIMALL(NSUB,NTIMALL(NSUB)) = TIMEVENT


      IF(IDEVENT .EQ. 4) THEN

C  IF IDEVENT = 4, IT MEANS THAT THIS IS A TIME RESET POINT (I.E., A 
C  TIME IN THE DISTANT FUTURE WHICH WILL SHOW UP AS T = 0 IN THE 
C  WORKING COPY FORMAT FILE). IN THIS CASE, IF NRESETADD = 0, ADD 
C  VALUES TO NTIMOUT, TIMOUT, AND OUT FOR EACH  OF THE MAXNUMEQ POSSIBLE
C  OUTPUT EQUATIONS (THERE ARE NOUT OUTPUT EQUATIONS SO FAR, BUT IN 
C  SUBSEQUENT ROWS, NOUT COULD INCREASE TO AT MOST MAXNUMEQ) TO 
C  INDICATE THAT ANY OUTPUTS FOLLOWING THIS TIME ARE BASED ON THE TIME
C  RESET. TO DO THIS, PUT IN THE CURRENT TIME IN TIMOUT, AND A
C  CORRESPONDING VALUE OF -99 (MISSING VALUE), FOR EACH OUTPUT EQUATION.

C  STORE VALUES INTO THE OUPUT ARRAYS (TIME = 0 AND VALUE = -99) WHICH 
C  INDICATE THAT SUBSEQUENT OUTPUT TIMES ARE BASED ON THIS TIME RESET.
C  ... BUT ONLY STORE THESE EXTRA VALUES IF NRESETADD = 0. IF 
C  NRESETADD = 1, IT MEANS THAT THESE LINES HAVE ALREADY BEEN ADDED
C  SINCE THE LAST ACTUAL OUTPUT VALUE WAS PUT INTO ONE OF THE OUTPUT
C  ARRAYS.

       IF(NRESETADD .EQ. 0) THEN
        DO IOUTEQ = 1,MAXNUMEQ
         NTIMOUT(NSUB,IOUTEQ) = NTIMOUT(NSUB,IOUTEQ) + 1
         TIMOUT(NSUB,IOUTEQ,NTIMOUT(NSUB,IOUTEQ)) = TIMEVENT
   	   OUT(NSUB,IOUTEQ,NTIMOUT(NSUB,IOUTEQ)) = -99.D0
        END DO
        NRESETADD = 1
       ENDIF

	 ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(IDEVENT .EQ. 4)  CONDITION.


C  IF THE CURRENT TIME IS THE SAME AS THE ENDING TIME OF THE PREVIOUS 
C  IV, DO NOT INCREASE NTIMIV(.,.) BELOW, BECAUSE THE NEW STARTING IV 
C  RATE MUST REPLACE THE 0.0 FROM THE ENDING OF THE PREVIOUS IV.

        ISAME = 0
        IF(NTIMIV(NSUB,IDRUGNO) .GT. 0) 
     1   CALL THESAME(TIMEVENT,TIMIV(NSUB,IDRUGNO,NTIMIV(NSUB,IDRUGNO)),
     2 ISAME)

        IF(ISAME .EQ. 0) NTIMIV(NSUB,IDRUGNO) = NTIMIV(NSUB,IDRUGNO) + 1
        TIMIV(NSUB,IDRUGNO,NTIMIV(NSUB,IDRUGNO)) = TIMEVENT
        RATEIV(NSUB,IDRUGNO,NTIMIV(NSUB,IDRUGNO)) = TOTDOS/DUR

	 NTIMALL(NSUB) = NTIMALL(NSUB) + 1

	 IF(NTIMALL(NSUB) .GT. 24000) THEN

	  WRITE(*,3001) NSUB
	  WRITE(*,401) NSUB,SUBARRAY(NSUB)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,3001) NSUB
         WRITE(42,401) NSUB,SUBARRAY(NSUB)
        CLOSE(42)	



	  CALL PAUSE
	  STOP



	 ENDIF

	 TIMALL(NSUB,NTIMALL(NSUB)) = TIMEVENT + DUR
	 NTIMIV(NSUB,IDRUGNO) = NTIMIV(NSUB,IDRUGNO) + 1
	 TIMIV(NSUB,IDRUGNO,NTIMIV(NSUB,IDRUGNO)) = TIMEVENT + DUR

	 RATEIV(NSUB,IDRUGNO,NTIMIV(NSUB,IDRUGNO)) = 0.D0

	ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(DUR .GT. 0)  CONDITION.

	

	IF(DUR .LE. 0) THEN

C  STORE THE BOLUS VALUE AT THE INDICATED TIME, TIMEVENT.

	 NTIMALL(NSUB) = NTIMALL(NSUB) + 1

	 IF(NTIMALL(NSUB) .GT. 24000) THEN



	  WRITE(*,3001) NSUB
	  WRITE(*,401) NSUB,SUBARRAY(NSUB)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,3001) NSUB
         WRITE(42,401) NSUB,SUBARRAY(NSUB)
        CLOSE(42)	



	  CALL PAUSE
	  STOP



	 ENDIF

	 TIMALL(NSUB,NTIMALL(NSUB)) = TIMEVENT



      IF(IDEVENT .EQ. 4) THEN

C  SEE LOGIC ABOVE FOR TIME RESET LOGIC, AND ADDING LINES TO THE

C  OUTPUT EQUATION VALUES IN THAT CASE.

C  STORE VALUES INTO THE OUPUT ARRAYS (SEE LOGIC ABOVE) WHICH 
C  INDICATE THAT SUBSEQUENT OUTPUT TIMES ARE BASED ON THIS TIME RESET.
C  ... BUT ONLY STORE THESE EXTRA VALUES IF NRESETADD = 0. IF 
C  NRESETADD = 1, IT MEANS THAT THESE LINES HAVE ALREADY BEEN ADDED
C  SINCE THE LAST ACTUAL OUTPUT VALUE WAS PUT INTO ONE OF THE OUTPUT
C  ARRAYS.

       IF(NRESETADD .EQ. 0) THEN
        DO IOUTEQ = 1,MAXNUMEQ
         NTIMOUT(NSUB,IOUTEQ) = NTIMOUT(NSUB,IOUTEQ) + 1
         TIMOUT(NSUB,IOUTEQ,NTIMOUT(NSUB,IOUTEQ)) = TIMEVENT
   	   OUT(NSUB,IOUTEQ,NTIMOUT(NSUB,IOUTEQ)) = -99.D0
        END DO
        NRESETADD = 1
       ENDIF

	 ENDIF


C  THE ABOVE ENDIF IS FOR THE  IF(IDEVENT .EQ. 4)  CONDITION.


	 NTIMBOL(NSUB,IDRUGNO) = NTIMBOL(NSUB,IDRUGNO) + 1
	 TIMBOL(NSUB,IDRUGNO,NTIMBOL(NSUB,IDRUGNO)) = TIMEVENT
	 BOLUS(NSUB,IDRUGNO,NTIMBOL(NSUB,IDRUGNO)) = TOTDOS

	ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(DUR .LE. 0)  CONDITION.


	GO TO 40


C  REPLACE WRITING OF TIMEVENT - TIMERESET WITH XVERIFY (SEE LOGIC IN 
C  SUBROUTINE VERIFYVAL.

   50 XVERIFY(1) = TIMEVENT - TIMERESET
      CALL VERIFYVAL(1,XVERIFY)
C  50 WRITE(*,51) NSUB, TIMEVENT - TIMERESET
      WRITE(*,51) NSUB, XVERIFY(1)

   51 FORMAT(/' THERE IS AN ERROR IN THE BLOCK FORMAT. FOR SUBJECT '/
     1' NO. ',I4,' AND TIME ',F10.4,' A LINE HAS A DOSAGE AMT., BUT NO'/
     2' DURATION (EVEN A BOLUS SHOULD HAVE A DURATION OF 0) IN '/
     3' ENTRY 4., OR NO DRUG NO. IN ENTRY 5.'//
     3' THE PROGRAM STOPS.')
	WRITE(*,401) NSUB,SUBARRAY(NSUB)

        OPEN(42,FILE=ERRFIL)
C        WRITE(42,51) NSUB, TIMEVENT - TIMERESET
         WRITE(42,51) NSUB, XVERIFY(1)
         WRITE(42,401) NSUB,SUBARRAY(NSUB)
        CLOSE(42)
	
	CALL PAUSE
	STOP


   40   CONTINUE


C  READ IN ANY COVARIATE VALUES IF NCOVA .GT. 0.


	IF(NCOVA .GT. 0) THEN

         DO 60 ICOV = 1,NCOVA

	  CALL AFTERCOMMA(NCOVA,READLINE,11+ICOV)

	  BACKSPACE(57)
 	  READ(57,*,ERR=70) COVVAL
	  CLOSE(57)

C  TO GET TO THIS POINT --> COVVAL REPRESENTS THE VALUE OF COV. NO.
C  ICOV. STORE IT AT THE INDICATED TIME, TIMEVENT.

	  NTIMALL(NSUB) = NTIMALL(NSUB) + 1

	 IF(NTIMALL(NSUB) .GT. 24000) THEN



	  WRITE(*,3001) NSUB
	  WRITE(*,401) NSUB,SUBARRAY(NSUB)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,3001) NSUB
         WRITE(42,401) NSUB,SUBARRAY(NSUB)
        CLOSE(42)	



	  CALL PAUSE
	  STOP

	 ENDIF

	 TIMALL(NSUB,NTIMALL(NSUB)) = TIMEVENT



      IF(IDEVENT .EQ. 4) THEN

C  SEE LOGIC ABOVE FOR TIME RESET LOGIC, AND ADDING LINES TO THE
C  OUTPUT EQUATION VALUES IN THAT CASE.

C  STORE VALUES INTO THE OUPUT ARRAYS (TIME = 0 AND VALUE = -99) WHICH 
C  INDICATE THAT SUBSEQUENT OUTPUT TIMES ARE BASED ON THIS TIME RESET.
C  ... BUT ONLY STORE THESE EXTRA VALUES IF NRESETADD = 0. IF 
C  NRESETADD = 1, IT MEANS THAT THESE LINES HAVE ALREADY BEEN ADDED
C  SINCE THE LAST ACTUAL OUTPUT VALUE WAS PUT INTO ONE OF THE OUTPUT
C  ARRAYS.

       IF(NRESETADD .EQ. 0) THEN
        DO IOUTEQ = 1,MAXNUMEQ
         NTIMOUT(NSUB,IOUTEQ) = NTIMOUT(NSUB,IOUTEQ) + 1
         TIMOUT(NSUB,IOUTEQ,NTIMOUT(NSUB,IOUTEQ)) = TIMEVENT
   	   OUT(NSUB,IOUTEQ,NTIMOUT(NSUB,IOUTEQ)) = -99.D0
        END DO
        NRESETADD = 1
       ENDIF

	 ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(IDEVENT .EQ. 4)  CONDITION.

C  SINCE MULTIPLE DOSE LINES CAN OCCUR AT THE SAME TIME (DEFINING
C  DOSES FOR DIFFERENT DRUGS OR IV VS. BOLUS VALUES, IT IS POSSIBLE
C  THAT A COVARIATE VALUE IS BEING RESET AT THE SAME TIME AS IN A

C  PREVIOUS LINE. IF THIS IS TRUE, TELL THE USER THAT THE COVARIATE
C  VALUE FROM THE FIRST LINE WILL BE USED. THIS MUST BE CHECKED ONLY
C  IF THE INDEX OF THE NO. OF COVARIATE VALUES IS > 0 - OTHERWISE
C  THIS IS THE FIRST LINE WITH A COVARIATE VALUE ON IT).

C  BUT, ONLY WRITE THIS WARNING IF THE TWO COVARIATE VALUES ARE
C  ACTUALLY DIFFERENT, BECAUSE IF THEY ARE THE SAME, THERE IS NO
C  CONFLICT, JUST REDUNDANCY.


	  IF(NTIMCOV(NSUB,ICOV) .GT. 0) THEN

	   CALL THESAME(TIMEVENT,TIMCOV(NSUB,ICOV,NTIMCOV(NSUB,ICOV)),
     1                  ISAMETIME)

	   CALL THESAME(COVVAL,COV(NSUB,ICOV,NTIMCOV(NSUB,ICOV)),
     1                  ISAMECOV)



	   IF(ISAMETIME .EQ. 1 .AND. ISAMECOV .EQ. 1) GO TO 60

	   IF(ISAMETIME .EQ. 1 .AND. ISAMECOV .EQ. 0) THEN

C  REPLACE WRITING OF TIMEVENT - TIMERESET, ETC. WITH XVERIFY (SEE 

C  LOGIC IN SUBROUTINE VERIFYVAL.

        XVERIFY(1) = TIMEVENT - TIMERESET
        XVERIFY(2) = COV(NSUB,ICOV,NTIMCOV(NSUB,ICOV))
        XVERIFY(3) = COVVAL
        CALL VERIFYVAL(3,XVERIFY)

C        WRITE(*,41) NSUB,TIMEVENT-TIMERESET,ICOV,
C    1    COV(NSUB,ICOV,NTIMCOV(NSUB,ICOV)),COVVAL
        WRITE(*,41) NSUB,XVERIFY(1),ICOV,XVERIFY(2),XVERIFY(3)
   41   FORMAT(/' FOR SUBJECT, 'I3,' AT TIME ',G14.7,', COVARIATE'/
     1' NO. ',I2,' WAS SET TO BOTH ',G14.7,' AND ',G14.7,'. YOU SHOULD'/
     2' CHECK YOUR BLOCK FILE. FOR NOW, THE FIRST VALUE WILL BE USED.')
    
	    GO TO 60


	   ENDIF

	  ENDIF

	  NTIMCOV(NSUB,ICOV) = NTIMCOV(NSUB,ICOV) + 1


	  TIMCOV(NSUB,ICOV,NTIMCOV(NSUB,ICOV)) = TIMEVENT 
	  COV(NSUB,ICOV,NTIMCOV(NSUB,ICOV)) = COVVAL

	  GO TO 60

   70     CONTINUE

C  TO GET TO LABEL 70 --> THERE WAS NO NUMBER IN THE ENTRY FOR 
C  COVARIATE, ICOV.

   60   CONTINUE



	ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(NCOVA .EQ. 0)  CONDITION.


	ENDIF


C  THE ABOVE ENDIF IS FOR THE  IF(IDEVENT .EQ. 1 .OR. IDEVENT .EQ. 4) 
C  CONDITION.


C  RETURN TO LABEL 10 TO READ THE NEXT LINE IN THE BLOCK PATIENT
C  DATA FILE.


	GO TO 10



  100   NSUB = 1


	IF(NCOVA .GT. 0) THEN

	 WRITE(*,111) NCOVA
  111    FORMAT(/' YOUR BLOCK FORMAT PATIENT INFORMATION FILE SHOWS'/
     1' ',I2,' COVARIATES. EACH COVARIATE MUST BE SPECIFIED TO BE '/
     2' EITHER A PIECEWISE CONSTANT COVARIATE OR AN INTERPOLATED '/
     3' COVARIATE.'//
     4' A PIECEWISE CONSTANT COVARIATE WILL HAVE THE SAME VALUE FROM'/
     5' ONE EXPLICITLY CODED VALUE, THROUGH ALL INTERVEENING DOSE'/
     6' TIMES, TO THE NEXT EXPLICITLY CODED VALUE (WHEN IT WILL CHANGE).
     7 '//
     8' AN INTERPOLATED COVARIATE WILL HAVE INTERPOLATED VALUES FROM'/
     9' ONE EXPLICITY CODED VALUE, THROUGH ALL INTERVEENING DOSE '/
     1' TIMES, TO THE NEXT EXPLCITLY CODED VALUE.'//)


	 DO ICOV = 1,NCOVA


  130	  WRITE(*,112) COVNAME(ICOV)
  112     FORMAT(/' FOR COVARIATE ',A11/
     1'  ENTER 1 IF IT IS TO BE PIECEWISE CONSTANT; '/
     2'  ENTER 2 IF IT IS TO BE INTERPOLATED: ')
	  READ(*,*,ERR=130) ITYPE
	  IF(ITYPE .NE. 1 .AND. ITYPE .NE. 2) GO TO 130
	  ICOVTYPE(ICOV) = ITYPE
	 END DO

	ENDIF


C  THE ABOVE ENDIF IS FOR THE  IF(NCOVA .GT. 0)  CONDITION.


C  WRITE OUT ALL THE INFO IN THE ABOVE ARRAYS INTO A WORKING COPY
C  FORMAT. ACTUALLY, FOR NOW, JUST TRY TO CREATE THE DOSAGE AND
C  OBSERVATION PART OF A FILE SIMILAR TO 2DRUG001 (I.E., DON'T
C  WORRY NOW ABOUT THE TOP PART OF THE FILE, OR THE BOTTOM).

C  FIRST, CALL SUBROUTINE GETCHAR2 TO ESTABLISH THE NUMBER ARRAY.

	DO JSUB = 1,NSUB

	 CALL GETCHAR2(JSUB,CHARSUB)
	 NUMBER(JSUB) = CHARSUB
	END DO

	DO 1000 ISUB = 1,NSUB

C  NOTE THAT THE WORKING COPY SUBJECTS WILL BE PLACED INTO THE 
C  WORKING DIRECTORY. THE PREFIX WILL BE HARDCODED TO 'XQZPJ', AND THE 
C  SUFFIX TO 'ZMQ'.

	 PATFIL = 'XQZPJ'//NUMBER(ISUB)//'.ZMQ'

C  CALL FULLNAME WHICH CONVERTS THE FILENAME TO PATHFILE, THE COMPLETE 

C  NAME OF THE FILE, WHICH INCLUDES THE PATH (IF THE PATH IS NOT THE 
C  CURRENT DIRECTORY).

         TMPFILE = ' '
	 TMPFILE = PATFIL 
	 CALL FULLNAME(PATH,TMPFILE,PATHFILE)

	 OPEN(33,FILE=PATHFILE)


	 IF(NDRUG .GT. 7) THEN

	  WRITE(*,101) NDRUG
  101     FORMAT(/' NO. OF DRUGS IN THIS PATIENT DATA SET IS ',I2/
     1'  THIS IS MORE THAN 7, THE MAXIMUM --> PROGRAM STOPS.'/)
	  WRITE(*,401) ISUB,SUBARRAY(ISUB)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,101) NDRUG
         WRITE(42,401) ISUB,SUBARRAY(ISUB)
        CLOSE(42)	



	  CALL PAUSE
	  STOP



	 ENDIF

	 IF(NOUT .GT. MAXNUMEQ) THEN



        WRITE(*,106) NOUT,MAXNUMEQ
  106   FORMAT(/' NO. OF OUTPUT EQS. THIS PATIENT DATA SET IS ',I2/
     1' THIS IS MORE THAN THE MAX. ALLOWED VALUE OF ',I2,'. SO THE'/
     2' PROGRAM STOPS.'/)
	  WRITE(*,401) ISUB,SUBARRAY(ISUB)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,106) NOUT,MAXNUMEQ
         WRITE(42,401) ISUB,SUBARRAY(ISUB)
        CLOSE(42)
	
	  CALL PAUSE
	  STOP

	 ENDIF

	 IF(NCOVA .GT. 26) THEN



	  WRITE(*,103) NCOVA
  103     FORMAT(/' NO. OF COVARIATES IN THIS PATIENT DATA SET IS ',I3/
     1'  THIS IS MORE THAN 26, THE MAXIMUM --> PROGRAM STOPS.'/)
	  WRITE(*,401) ISUB,SUBARRAY(ISUB)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,103) NCOVA
         WRITE(42,401) ISUB,SUBARRAY(ISUB)
        CLOSE(42)	




	  CALL PAUSE
	  STOP



	 ENDIF


C  BEFORE CALLING WRITEDOS, CALL TIMESET FOR THIS SUBJECT TO 
C  ELIMINATE ALL THE DUPLICATE TIMES IN TIMALL(ISUB,.). THERE COULD BE 
C  DUPLICATE TIMES BECAUSE NTIMALL(ISUB) WAS INCREASED BY 1 FOR EACH 
C  BOLUS, IV, OR COVARIATE VALUE, AND SOME OF THESE VALUES OCCUR AT THE 
C  SAME TIME.  TIMESET ALSO ORDERS THE TIMES AND THEY COULD BE OUT OF 
C  ORDER DUE TO AN IV RATE WHOSE DURATION RESULTS IN THE ENDING TIME 
C  BEING PAST THE NEXT DOSE EVENT. 

C  TIMESET RETURNS THE COMPLETE SET OF TIMES FOR THIS SUBJECT'S DOSAGE 
C  REGIMEN IN TIMI (AND THERE ARE NTIMI OF THEM).

	 CALL TIMESET(MAXSUB,ISUB,SUBARRAY(ISUB),NTIMALL,TIMALL,NTIMI,
     1    TIMI)
	

C  CALL WRITEDOS TO WRITE THE PATIENT INFO TO PATHFILE = FILE 33.

	 CALL WRITEDOS(ISUB,NTIMIV,TIMIV,RATEIV,NTIMBOL,TIMBOL,BOLUS,
     1    NTIMCOV,TIMCOV,COV,ICOVTYPE,NDRUG,NCOVA,NOUT,NTIMOUT,
     2    TIMOUT,OUT,SUBARRAY(ISUB),COVNAME,MAXSUB,NTIMI,TIMI,TIMADD,
     3    CSUB,NSST,DOSELINEST)

 1000   CONTINUE


	RETURN
	END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
	SUBROUTINE AFTERCOMMA(NCOVA,READLINE,NCOMMA)
	CHARACTER READLINE*1000,ERRFIL*20

      COMMON/ERROR/ERRFIL
C  COMMON/ERROR/ IS SUPPLIED TO ALL THE ROUTINES WHICH COULD WRITE TO
C  ERRFIL.

C  OPEN AND WRITE INTO SCRATCH FILE 57 THE PART OF READLINE THAT 
C  IS BETWEEN COMMAS NCOMMA AND NCOMMA+1 ... UNLESS NCOMMA IS THE MAX.
C  NO. OF COMMAS (11+NCOVA). IN THIS CASE, WRITE INTO SCRATCH FILE 57 THE 
C  PART OF READLINE THAT FOLLOWS COMMA NCOMMA (SINCE THERE WILL NOT BE 
C  ANOTHER COMMA).


    1   FORMAT(A1000)

C  IF NCOMMA = 0, SET ISTART = 0 AND GO TO LABEL 10.

	
	IF(NCOMMA .EQ. 0) THEN
	 ISTART = 0
	 GO TO 10
	ENDIF


	ICOMMA = 0

	DO ISTART = 1,300
	 IF(READLINE(ISTART:ISTART) .EQ. ',') THEN
	  ICOMMA = ICOMMA + 1
	  IF(ICOMMA .EQ. NCOMMA) GO TO 10

	 ENDIF
	END DO	    


C  TO GET TO THIS POINT MEANS THAT THE NO. OF COMMAS IN LINE
C  READLINE IS LESS THAN NCOMMA. WRITE A MESSAGE AND STOP.

	WRITE(*,2) NCOMMA,ICOMMA,READLINE
    2   FORMAT(/' THE FOLLOWING LINE WAS SUPPOSED TO HAVE AT LEAST ',I3/
     1' COMMAS, BUT IT HAD ONLY ',I3,' SO THE PROGRAM STOPS.'//


     2A1000)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,2) NCOMMA,ICOMMA,READLINE
        CLOSE(42)
	


	CALL PAUSE
	STOP
	

C  TO REACH LABEL 10, ISTART IS NOW THE COLUMN NO. WHICH HAS THE
C  NCOMMAth COMMA IN LINE READLINE.  FIND IEND, WHICH IS THE COLUMN NO.
C  WHICH HAS THE NCOMMA+1 ST COMMA IN THE LINE. THEN WRITE THE PORTION
C  OF READLINE WHICH IS BETWEEN ISTART AND IEND INTO FILE57.

   10	ICOMMA = 0

	DO IEND = 1,300
	 IF(READLINE(IEND:IEND) .EQ. ',') THEN
	  ICOMMA = ICOMMA + 1
	  IF(ICOMMA .EQ. NCOMMA+1) GO TO 20
	 ENDIF
	END DO	    


C  TO GET TO THIS POINT MEANS THAT THE NO. OF COMMAS IN LINE
C  READLINE IS LESS THAN NCOMMA+1. THIS IS OK IF NCOMMA IS THE MAXIMUM
C  NO. OF COMMAS, WHICH IS 11+NCOVA. OTHERWISE, WRITE A MESSAGE AND 
C  STOP.




	IF(NCOMMA .LT. 11 + NCOVA) THEN

	 WRITE(*,2) NCOMMA+1,ICOMMA,READLINE

        OPEN(42,FILE=ERRFIL)
         WRITE(42,2) NCOMMA+1,ICOMMA,READLINE
        CLOSE(42)
	


	 CALL PAUSE
	 STOP



	ENDIF

	IF(NCOMMA .EQ. 11 + NCOVA) IEND = 301

   20	OPEN(57,STATUS='SCRATCH')

C  SEE CODE AT TOP OF MONTBG100.FOR TO SEE WHY FORMATTED WRITE 
C  STATEMENTS ARE USED (UNLESS NUMCHAR BELOW IS > 11, IN WHICH CASE

C  A FREE FORMAT WRITE STATEMENT IS STILL USED).

        NUMCHAR = IEND - ISTART - 1
	

        IF(NUMCHAR .EQ. 1) WRITE(57,101) READLINE(ISTART+1:IEND-1)
  101   FORMAT(A1)

        IF(NUMCHAR .EQ. 2) WRITE(57,102) READLINE(ISTART+1:IEND-1)
  102   FORMAT(A2)

        IF(NUMCHAR .EQ. 3) WRITE(57,103) READLINE(ISTART+1:IEND-1)
  103   FORMAT(A3)

        IF(NUMCHAR .EQ. 4) WRITE(57,104) READLINE(ISTART+1:IEND-1)
  104   FORMAT(A4)


        IF(NUMCHAR .EQ. 5) WRITE(57,105) READLINE(ISTART+1:IEND-1)
  105   FORMAT(A5)

        IF(NUMCHAR .EQ. 6) WRITE(57,106) READLINE(ISTART+1:IEND-1)
  106   FORMAT(A6)

        IF(NUMCHAR .EQ. 7) WRITE(57,107) READLINE(ISTART+1:IEND-1)

  107   FORMAT(A7)

        IF(NUMCHAR .EQ. 8) WRITE(57,108) READLINE(ISTART+1:IEND-1)
  108   FORMAT(A8)

        IF(NUMCHAR .EQ. 9) WRITE(57,109) READLINE(ISTART+1:IEND-1)
  109   FORMAT(A9)

        IF(NUMCHAR .EQ. 10) WRITE(57,110) READLINE(ISTART+1:IEND-1)
  110   FORMAT(A10)

        IF(NUMCHAR .EQ. 11) WRITE(57,111) READLINE(ISTART+1:IEND-1)
  111   FORMAT(A11)

        IF(NUMCHAR .GT. 11) WRITE(57,*) READLINE(ISTART+1:IEND-1)


	RETURN
	END
C

CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
        SUBROUTINE WRITEDOS(ISUB,NTIMIV,TIMIV,RATEIV,NTIMBOL,TIMBOL,
     1   BOLUS,NTIMCOV,TIMCOV,COV,ICOVTYPE,NDRUG,NCOVA,NOUT,NTIMOUT,
     2   TIMOUT,OUT,SUBID,COVNAME,MAXSUB,NTIMI,TIMI,TIMADD,CSUB,
     3   NSST,DOSELINEST)

        use npag_utils, only: verifyval, thesame

         IMPLICIT REAL*8(A-H,O-Z)

         PARAMETER(MAXNUMEQ=7)

      DIMENSION BOLVAL(7),COVVAL(26),XIVVAL(7),DOSELINE(5200,43),
     1 TIMOUT(MAXSUB,MAXNUMEQ,650),TIMIV(MAXSUB,7,5200),
     2 NTIMOUT(MAXSUB,MAXNUMEQ),NTIMIV(MAXSUB,7),RATEIV(MAXSUB,7,5200),
     3 BOLUS(MAXSUB,7,5200),OUT(MAXSUB,MAXNUMEQ,650),
     4 COV(MAXSUB,26,5200),ICOVTYPE(26),TIMBOL(MAXSUB,7,5200),
     5 NTIMBOL(MAXSUB,7),NTIMCOV(MAXSUB,26),TIMCOV(MAXSUB,26,5200),
     6 INDIV(7),INDBOL(7),INDCOV(26),TIMI(24000),TIMORD(3900),
     7 BLOCKOUT(3900,MAXNUMEQ),CSUB(MAXSUB,4,MAXNUMEQ),NSST(MAXSUB),
     8 DOSELINEST(MAXSUB,99,100),DOSELINES(100),XVERIFY(900)

	CHARACTER SUBID*11,COVNAME(26)*11,ERRFIL*20

      COMMON/ERROR/ERRFIL
C  COMMON/ERROR/ IS SUPPLIED TO ALL THE ROUTINES WHICH COULD WRITE TO
C  ERRFIL.

C  THIS ROUTINE WRITES THE DOSE EVENTS AND THE OBSERVATION EVENTS OF 
C  THE PATIENT DATA FILE TO FILE33. NOTE THAT A DOSE EVENT OCCURS 
C  WHENEVER THERE IS A BOLUS APPLIED, AN IV RATE CHANGE, AND/OR A
C  COVARIATE VALUE APPLIED.


C----------------- WRITE THE TOP OF FILE BELOW -------------------------

	WRITE(33,301) SUBID
  301   FORMAT('  LAST AND FIRST NAMES ARE: ',A11)
	WRITE(33,302) SUBID
  302   FORMAT(' CHART NUMBER IS: ',A11//
     1' WARD NO, PATIENT AGE (YEARS), SEX, HEIGHT (INCHES),'/
     2' ETHNICITY FLAG, AND ETHNICITY DESCRIPTION (IF ANY)   FOLLOW ON'/
     3' THE NEXT 6 LINES:'/
     4'-99'/
     5'-99'/
     6'M'/
     7'-99'/
     8'1'/
     9'Ethnicity Description'//
     1' DATE OF FIRST THERAPY IS   1   1   08'/
     2'CCR ML/MIN/    0.00 150.00'/
     3'HOURS    MG     MG/HR    MCG/ML KG       MG/DL    60  .00 ')              


C----------------- WRITE THE TOP OF FILE ABOVE -------------------------


C----------------- WRITE THE DOSE EVENTS BELOW -------------------------

	 WRITE(33,102) NDRUG
  102    FORMAT(/'     ',I1,' ... NO. OF DRUGS')

C  NOTE THAT NCOVA IS THE NO. OF COVARIATES IN THE USER'S BLOCK FORMAT
C  FILE. THIS AUTOMATICALLY BECOMES NADD, THE NO. OF "ADDITIONAL"
C  COVARIATES IN THE WORKING COPY FILE.

	 WRITE(33,104) NCOVA
  104    FORMAT('    ',I2,' ... NO. OF ADDITIONAL COVARIATES')


C  INCREASE THE NO. OF DOSE EVENTS BY THE NO. OF STEADY STATE DOSE LINES
C  THAT WILL BE IN THE FILE (THESE WERE NOT PART OF THE ARRAY EXAMINED
C  BY SUBROUTINE TIMESET).

	WRITE(33,2) NTIMI + NSST(ISUB)
    2   FORMAT('   ',I3,' ... NO. OF DOSE EVENTS'//
     1'    TIME, IV/PO FOR EACH DRUG; ADDITIONAL COVARIATES IF ANY')


C  SET THE IVs FOR EACH DRUG TO 0. EACH DRUG IV VALUE STAYS THE SAME
C  AS ITS PREVIOUS VALUE UNTIL CHANGED. ALSO INITIALIZE EACH BOLUS
C  VALUE TO 0.

	DO IDRUG = 1,NDRUG
	 XIVVAL(IDRUG) = 0.D0
	 BOLVAL(IDRUG) = 0.D0

	END DO

C  SET EACH COVARIATE VALUE TO ITS INITIAL VALUE. IT IS ASSUMED THAT
C  EACH COV. HAS ITS FIRST VALUE SET AT THE FIRST DOSE TIME (T=0).
C  IF THIS IS NOT TRUE, SEE REMARK BELOW WHERE THE COVARIATE VALUES
C  ARE SET FOR EACH TIME.

	DO ICOV = 1,NCOVA
	 COVVAL(ICOV) = COV(ISUB,ICOV,1)
	END DO


C  INITIALIZE THE INDEX OF THE NEXT TIME IN EACH TIME ARRAY TO BE 1.

	DO IDRUG = 1,NDRUG
	 INDIV(IDRUG) = 1
	 INDBOL(IDRUG) = 1
	END DO

	DO ICOV = 1,NCOVA
	 INDCOV(ICOV) = 1
	END DO

C  GO THROUGH ALL THE NTIMI DOSAGE BLOCK TIMES IN TIMI AND ESTABLISH ALL
C  IV, BOLUS, AND COV. VALUES AT EACH TIME AND WRITE THEM TO THE DOSAGE 
C  REGIMEN, BUT NOTE THAT EACH TIME MUST BE REDUCED BY TIMERESET, WHERE
C  TIMERESET = TIMADD*NRESET, WHERE NRESET IS THE NO. OF TIME RESETS 
C  THROUGH THAT TIME (SEE IN READBLOCK2 THAT TIMERESET WAS ADDED TO EACH
C  TIME).

	NRESET = 0
	TIMERESET = TIMADD*NRESET

C  INITIALIZE NSSEVENTS = 1. THIS WILL BE THE INDEX OF THE NEXT STEADY
C  STATE DOSE EVENT (IF ANY) IN THE CURRENT PATIENT'S DATA FILE. THE
C  TOTAL NO. OF SUCH EVENTS IS NSST(ISUB).


      NSSEVENTS = 1

C  AS OF MONT101F, PUT IN A STEADY STATE LINE AS THE FIRST DOSE EVENT
C  IF ONE EXISTS. 

C  DOSELINEST(ISUB,1,100) = NRESET, THE NO. OF DOSE RESETS BEFORE THE
C  1ST STEADY STATE DOSE SET. 

C  IF DOSELINST(ISUB,1,100) = 0, IT MEANS THAT THERE IS A STEADY STATE
C  DOSE SET AT THE TOP OF THE FILE (I.E., BEFORE ANY RESETS). 

C  IF DOSELINEST(ISUB,1,100) IS = -99, IT MEANS THERE ARE NO STEADY 
C  STATE LINES FOR THIS SUBJECT. 

C  IF DOSELINEST(ISUB,1,100) = N > 0, IT MEANS THE FIRST STEADY STATE
C  DOSE SET OCCURS AFTER RESET NO. N.

      CALL THESAME(DOSELINEST(ISUB,1,100),0.D0,ISAME)

      IF(ISAME .EQ. 1) THEN

C  FILL IN THE ENTRIES TO DOSELINE FOR THE STEADY STATE DOSE AT THE
C  TOP OF THE PATIENT'S FILE.


C  THE FIRST ENTRY IN DOSELINST IS TIMEVENT = THE NEGATIVE OF THE
C  INTERDOSE INTERVAL.

	 DOSELINES(1) = DOSELINEST(ISUB,1,1)
	 NENTRY = 1

C  FOR EACH DRUG, THE IV AND TOTAL VALUES ARE ALREADY STORED INTO
C  DOSELINEST(ISUB,1,2*I) AND DOSELINEST(ISUB,1,2*I+1), I=1,NDRUG.

	 DO IDRUG = 1,NDRUG
	  NENTRY = NENTRY+1
        DOSELINES(NENTRY) = DOSELINEST(ISUB,1,2*IDRUG)
	  NENTRY = NENTRY+1
	  DOSELINES(NENTRY) = DOSELINEST(ISUB,1,2*IDRUG+1)

	 END DO

C  FOR EACH COVARIATE, IF ANY, THE VALUES ARE STORED INTO
C  DOSELINEST(ISUB,1,19+ICOV), ICOV = 1,NCOVA.

       IF(NCOVA .GT. 0) THEN
	  DO ICOV = 1,NCOVA
	   NENTRY = NENTRY+1
	   DOSELINES(NENTRY) = DOSELINEST(ISUB,1,19+ICOV)
	  END DO

       ENDIF


C  REPLACE WRITING OF DOSELINES() WITH XVERIFY (SEE LOGIC IN 
C  SUBROUTINE VERIFYVAL.

        DO J = 1,NENTRY
         XVERIFY(J) = DOSELINES(J)
        END DO
        CALL VERIFYVAL(NENTRY,XVERIFY)
C       WRITE(33,1) (DOSELINES(J),J=1,NENTRY)
        WRITE(33,1) (XVERIFY(J),J=1,NENTRY)

       NSSEVENTS = NSSEVENTS + 1


      ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(ISAME .EQ. 1)  CONDITION.


	DO 1000 ITIM = 1,NTIMI

	 TIME = TIMI(ITIM)

C  IF THIS TIME = THE NEXT MULTIPLE OF TIMADD, INCREASE THE NO. OF 
C  RESETS BY 1 AND RECALCULATE TIMERESET, THE CURRENT AMOUNT THAT EACH
C  TIME MUST BE REDUCED BEFORE BEING WRITTEN INTO THE WORKING COPY 
C  FILE.

C  AS OF MONT101F.FOR, THIS TIME COULD BE PAST A TIME RESET POINT. THIS
C  WOULD HAPPEN IF A TIME RESET HAD A STEADY STATE DOSE SET ASSOCIATED
C  WITH IT, WITHOUT A NON STEADY STATE DOSE IMMEDIATELY FOLLOWING IT (IF
C  A NON STEADY STATE DOSE IMMEDIATELY FOLLOWED A STEADY STATE SET, 
C  THEN THERE WILL BE TIMI(.) ENTRY THAT = TIMADD*(NRESET+1)). IN THIS
C  CASE TOO, UPDATE NRESET AND TIMERESET.

C  CALL THESAME HERE TO ESTABLISH THE VALUE FOR ISAMERESET. IT
C  WILL USED BELOW TO SUPPRESS INTERPOLATION OF COVARIATES ACROSS A
C  TIME RESET.


       CALL THESAME(TIME,TIMADD*(NRESET+1),ISAMERESET)   


       IF(TIME .GE. TIMADD*(NRESET+1)) THEN


C  TIME IS AT OR PAST THE NEXT MULTIPLE OF TIMADD (I.E., IT IS A TIME
C  RESET POINT). IN THIS CASE, INCREASE NRESET BY 1 AND RECALCULATE
C  TIMERESET.

	  NRESET = NRESET + 1
	  TIMERESET = TIMADD*NRESET

C  FOR THIS TIME RESET, CHECK TO SEE IF THE FIRST DOSE LINE WILL BE
C  A STEADY STATE DOSE EVENT. THE NO. OF STEADY STATE DOSE EVENTS IN
C  THIS PATIENT'S FILE IS NSST(ISUB), AND THE NO. OF SUCH EVENTS THAT
C  HAVE ALREADY BEEN WRITTEN TO FILE 33 IS NSSEVENTS-1 SO FAR.

        IF(NSSEVENTS .LE. NSST(ISUB)) THEN

C  THE NEXT STEADY STATE DOSE EVENT OCCURS AFTER RESET NO.
C  DOSELINEST(ISUB,NSSEVENTS,100). CHECK TO SEE IF THIS VALUE IS
C  THE SAME AS NRESET. IF SO, THIS RESET STARTS WITH A STEADY STATE
C  LINE.

         XRESET = NRESET

         CALL THESAME(DOSELINEST(ISUB,NSSEVENTS,100),XRESET,ISAME)

         IF(ISAME .EQ. 1) THEN

C  FILL IN THE ENTRIES TO DOSELINE FOR THE STEADY STATE DOSE AT THE
C  BEGINNING OF THIS DOSE RESET.

C  THE FIRST ENTRY IN DOSELINST IS TIMEVENT = THE NEGATIVE OF THE
C  INTERDOSE INTERVAL.

          DOSELINES(1) = DOSELINEST(ISUB,NSSEVENTS,1)
          NENTRY = 1

C  FOR EACH DRUG, THE IV AND TOTAL VALUES ARE ALREADY STORED INTO

C  DOSELINEST(ISUB,NSSEVENTS,2*I) AND DOSELINEST(ISUB,NSSEVENTS,2*I+1),
C  I=1,NDRUG.

          DO IDRUG = 1,NDRUG
           NENTRY = NENTRY+1
           DOSELINES(NENTRY) = DOSELINEST(ISUB,NSSEVENTS,2*IDRUG)
           NENTRY = NENTRY+1
           DOSELINES(NENTRY) = DOSELINEST(ISUB,NSSEVENTS,2*IDRUG+1)
          END DO

C  FOR EACH COVARIATE, IF ANY, THE VALUES ARE STORED INTO
C  DOSELINEST(ISUB,NSSEVENTS,19+ICOV), ICOV = 1,NCOVA.

          IF(NCOVA .GT. 0) THEN
           DO ICOV = 1,NCOVA
            NENTRY = NENTRY+1
            DOSELINES(NENTRY) = DOSELINEST(ISUB,NSSEVENTS,19+ICOV)
           END DO
          ENDIF


C  REPLACE WRITING OF DOSELINES() WITH XVERIFY (SEE LOGIC IN 
C  SUBROUTINE VERIFYVAL.

        DO J = 1,NENTRY
         XVERIFY(J) = DOSELINES(J)
        END DO
        CALL VERIFYVAL(NENTRY,XVERIFY)
C       WRITE(33,1) (DOSELINES(J),J=1,NENTRY)
        WRITE(33,1) (XVERIFY(J),J=1,NENTRY)

          NSSEVENTS = NSSEVENTS + 1

         ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(ISAME .EQ. 1)  CONDITION.


        ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(NSSEVENTS .LE. NSST(ISUB))  CONDITION.


	 ENDIF

C  THE ABOVE ENDIF IS FOR THE IF(TIME .GE. TIMADD*(NRESET+1)) CONDITION.



C  CHECK TO SEE IF ANY BOLUS TIMES = TIME.

	DO IDRUG = 1,NDRUG

C  IF THE CURRENT INDEX FOR THIS BOLUS IS MORE THAN THE NO.
C  OF ENTRIES IN THE CORRESPONDING ARRAY, IT MEANS THAT THERE ARE NO
C  MORE BOLUS VALUES FOR THIS DRUG. IN THAT CASE, SET ITS TIME TO -99.
C  OTHERWISE, SET ITS TIME TO THE NEXT TIME IN THE ARRAY.


	 IF(INDBOL(IDRUG) .GT. NTIMBOL(ISUB,IDRUG)) TIMEB = -99.D0

	 IF(INDBOL(IDRUG) .LE. NTIMBOL(ISUB,IDRUG)) THEN
	  TIMEB = TIMBOL(ISUB,IDRUG,INDBOL(IDRUG))

	 ENDIF


	 CALL THESAME(TIME,TIMEB,ISAME)


C  IF ISAME RETURNS FROM SUBROUTINE THESAME AS 1, THE TIMES ARE THE 
C  "SAME" (I.E., WITHIN 1.D-10). IN THIS CASE, SET THE BOLUS VALUE FOR
C  THIS EVENT TO THE CORRESPONDING VALUE IN BOLUS, AND INCREASE THE 
C  INDEX OF THE NEXT TIME BY 1. IF ISAME RETURNS AS 0, SET THE BOLUS 
C  VALUE = 0.


	  IF(ISAME .EQ. 0) BOLVAL(IDRUG) = 0.D0

	  IF(ISAME .EQ. 1) THEN
	   BOLVAL(IDRUG) = BOLUS(ISUB,IDRUG,INDBOL(IDRUG))
	   INDBOL(IDRUG) = INDBOL(IDRUG) + 1
	  ENDIF


	 END DO


C  CHECK TO SEE IF ANY COVARIATE TIMES = TIME.

	DO ICOV = 1,NCOVA

C  IF THE CURRENT INDEX FOR THIS COVARIATE IS MORE THAN THE NO.
C  OF ENTRIES IN THE CORRESPONDING ARRAY, IT MEANS THAT THERE ARE NO
C  MORE COV VALUES FOR THIS COVARIATE. IN THAT CASE, SET ITS TIME TO 
C  -99. OTHERWISE, SET ITS TIME TO THE NEXT TIME IN THE ARRAY.

	 IF(INDCOV(ICOV) .GT. NTIMCOV(ISUB,ICOV)) TIMEC = -99.D0

	 IF(INDCOV(ICOV) .LE. NTIMCOV(ISUB,ICOV)) THEN
	  TIMEC = TIMCOV(ISUB,ICOV,INDCOV(ICOV))
	 ENDIF

	 CALL THESAME(TIME,TIMEC,ISAME)

	
C  IF ISAME RETURNS FROM SUBROUTINE THESAME AS 1, THE TIMES ARE THE 
C  "SAME" (I.E., WITHIN 1.D-10). IN THIS CASE, SET THE COVARIATE VALUE 
C  FOR THIS EVENT TO THE CORRESPONDING VALUE IN COV, AND INCREASE THE 
C  INDEX OF THE NEXT TIME BY 1. 

	  IF(ISAME .EQ. 1) THEN
	   COVVAL(ICOV) = COV(ISUB,ICOV,INDCOV(ICOV))
	   INDCOV(ICOV) = INDCOV(ICOV) + 1
	  ENDIF



C  IF ISAME RETURNS AS 0, THE COV. VALUE WILL BE THE SAME AS IT WAS 
C  PREVIOUSLY IF ICOVTYPE(ICOV) = 1 OR 0 (I.E., IF THIS IS A PIECEWISE
C  CONTINOUS COVARIATE). IT WILL ALSO BE THE SAME AS IT WAS PREVIOUSLY
C  IF ICOVTYPE(ICOV) = 2 (I.E., FOR A LINEARLY INTERPOLATED COVARIATE)
C  IF TIMEC = -99, OR IF ISAMERESET = 1. HERE IS WHY:

C  TIMEC = -99 --> THERE ARE NO MORE COVARIATE VALUES (SEE ABOVE).
C  IF ISAMERESET = 1, THEN THIS IS A TIME RESET POINT. AND IN THIS CASE,
C  EVEN AN INTERPOLATED COVARIATE VALUE SHOULD BE SET = ITS LAST VALUE 
C  FROM BEFORE THE RESET, SINCE NO INTERPOLATION IS POSSIBLE FOR OUT OF 
C  ORDER TIMES (E.G., (T,COV) = (24,400), FOLLOWED BY (T,COV) = 
C  (20,1000) --> INTERPOLATED VALUE AT 0 WOULD BE: 
C  (0-24)/(20-24) * (1000 - 400) + 400 = 4000, WHICH IS PREPOSTEROUS).


	IF(ISAME .EQ. 0) THEN


C  SET INTERP = 1, WHICH MEANS THAT THIS COVARIATE VALUE SHOULD BE 
C  INTERPOLATED FROM THE TWO SURROUNDING COVARIATE VALUES (WHICH HAVE
C  BEEN EXPLICITLY SPECIFIED IN THE BLOCK FORMAT FILE). CHANGE INTERP
C  TO 0 IF THIS IS NOT AN INTERPOLATED COVARIATE (ICOVTYPE(ICOV) = 1
C  OR 0) OR IF THIS IS AN INTERPOLATED COVARIATE BUT THERE ARE NO MORE
C  COVARIATE VALUES FOR THIS COVARIATE (TIMEC = -99) OR IF THIS IS A
C  TIME RESET VALUE (ISAMERESET = 1), OR IF THE CURRENT COVARIATE TIME

C  (WHICH WOULD BE USED IN THE INTERPOLATION) IS AT OR PAST THE NEXT 
C  TIME RESET.



	 INTERP = 1
	 IF(ICOVTYPE(ICOV) .EQ. 1 .OR. ICOVTYPE(ICOV) .EQ. 0) 
     1    INTERP = 0

	 IF(TIMEC .LE. -99) INTERP = 0
	 IF(ISAMERESET .EQ. 1) INTERP = 0

	 IF(TIMEC .GE. TIMERESET + TIMADD) INTERP = 0


C  IF INTERP = 1:

C  NOTE THAT INDCOV(ICOV) MUST BE .GE. 2 UNLESS THE USER HAS MADE A 
C  MISTAKE SINCE THE FIRST TIME (TIME = 0) IS SUPPOSED TO HAVE ALL 
C  COVARIATE VALUES SPECIFIED, WHICH MEANS THE FIRST TIME THROUGH THIS
C  PART OF THE CODE ABOVE, INDCOV(ICOV) WAS INCREASED BY 1 (FROM ITS
C  ORIGINAL VALUE OF 1). IF THIS IS NOT TRUE, WRITE A MESSAGE TO THE

C  USER AND STOP.



	 IF(INDCOV(ICOV) .EQ. 1) THEN



	  WRITE(*,111) ICOV
  111     FORMAT(/' THERE IS A MISTAKE IN THE BLOCK FORMAT PATIENT'/
     1' DATA FILE. THE FIRST VALUE FOR COVARIATE NO. ',I2,' WAS NOT'/
     2' SPECIFIED AT THE ORIGINAL TIME = 0, AS IS REQUIRED. PLEASE'/
     3' FIX THIS ERROR AND RERUN THE PROGRAM. '//)
	  WRITE(*,401) ISUB,SUBID
  401   FORMAT(/' NOTE: THE ID FOR SUBJECT NO. ',I4,' IS ',A11/)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,111) ICOV
         WRITE(42,401) ISUB,SUBID
        CLOSE(42)	



	  CALL PAUSE
	  STOP



	 ENDIF 


	 CLAST = COV(ISUB,ICOV,INDCOV(ICOV)-1)

	 IF(INTERP .EQ. 0) COVVAL(ICOV) = CLAST

	 IF(INTERP .EQ. 1) THEN

C  NOTE: THE LAST COV. VALUE WAS CLAST WHICH OCCURRED AT TLAST. THE NEXT
C  COV VALUE IS CNEXT WHICH OCCURS AT TNEXT. SO ESTABLISH THE 
C  LINEARLY INTERPOLATED VALUE FOR THIS TIME, TIME. NOTE THAT THE TIMES,
C  TLAST AND TNEXT, MUST BE RECAST AS THEIR ACTUAL TIMES (BY REDUCING
C  THEM BY TIMERESET) FIRST.


	  TLAST = TIMCOV(ISUB,ICOV,INDCOV(ICOV)-1) - TIMERESET
	  CNEXT = COV(ISUB,ICOV,INDCOV(ICOV))
	  TNEXT = TIMCOV(ISUB,ICOV,INDCOV(ICOV)) - TIMERESET
	  TIMEREAL = TIME - TIMERESET
	  COVVAL(ICOV) = (TIMEREAL-TLAST)/(TNEXT-TLAST) * (CNEXT-CLAST)
     1     + CLAST
	 ENDIF	  

	ENDIF


C  THE ABOVE ENDIF IS FOR THE  IF(ISAME .EQ. 0)  CONDITION.



	 END DO


C  THE ABOVE END DO IS FOR THE  DO ICOV = 1,NCOVA  LOOP.



C  CHECK TO SEE IF ANY IV TIMES = TIME.

	DO IDRUG = 1,NDRUG

C  IF THE CURRENT INDEX FOR THIS IV IS MORE THAN THE NO.
C  OF ENTRIES IN THE CORRESPONDING ARRAY, IT MEANS THAT THERE ARE NO
C  MORE IV VALUES FOR THIS DRUG. IN THAT CASE, SET ITS TIME TO -99.
C  OTHERWISE, SET ITS TIME TO THE NEXT TIME IN THE ARRAY.

	 IF(INDIV(IDRUG) .GT. NTIMIV(ISUB,IDRUG)) TIMEI = -99.D0

	 IF(INDIV(IDRUG) .LE. NTIMIV(ISUB,IDRUG)) THEN

	  TIMEI = TIMIV(ISUB,IDRUG,INDIV(IDRUG))
	 ENDIF

	 CALL THESAME(TIME,TIMEI,ISAME)

C  IF ISAME RETURNS FROM SUBROUTINE THESAME AS 1, THE TIMES ARE THE 
C  "SAME" (I.E., WITHIN 1.D-10). IN THIS CASE, SET THE IV VALUE FOR
C  THIS EVENT TO THE CORRESPONDING VALUE IN RATEIV, AND INCREASE THE 
C  INDEX OF THE NEXT TIME BY 1. IF ISAME RETURNS AS 0, THE IV VALUE
C  WILL REMAIN WHAT IT WAS PREVIOUSLY.

	  IF(ISAME .EQ. 1) THEN
	   XIVVAL(IDRUG) = RATEIV(ISUB,IDRUG,INDIV(IDRUG))
	   INDIV(IDRUG) = INDIV(IDRUG) + 1
	  ENDIF

	 END DO


C  PUT THE ACTUAL TIME (I.E., TIME - TIMERESET) INTO THE 1ST ENTRY FOR
C  THIS ROW. THEN PUT IN THE IV/BOLUS VALUES FOR EACH OF THE NDRUG DRUGS
C  IN ORDER; THEN ALL ADDITIONAL COV. VALUES.

	 DOSELINE(ITIM,1) = TIME - TIMERESET
	 NENTRY = 1


	 DO IDRUG = 1,NDRUG
	  NENTRY = NENTRY+1
	  DOSELINE(ITIM,NENTRY) = XIVVAL(IDRUG)
	  NENTRY = NENTRY+1
	  DOSELINE(ITIM,NENTRY) = BOLVAL(IDRUG)
	 END DO

	 DO ICOV = 1,NCOVA
	  NENTRY = NENTRY+1
	  DOSELINE(ITIM,NENTRY) = COVVAL(ICOV) 
	 END DO

C  REPLACE WRITING OF DOSELINES() WITH XVERIFY (SEE LOGIC IN 
C  SUBROUTINE VERIFYVAL.

        DO J = 1,NENTRY
         XVERIFY(J) = DOSELINE(ITIM,J)
        END DO
        CALL VERIFYVAL(NENTRY,XVERIFY)
C       WRITE(33,1) (DOSELINE(ITIM,J),J=1,NENTRY)
        WRITE(33,1) (XVERIFY(J),J=1,NENTRY)
    1   FORMAT(43(G19.9,1X))



 1000   CONTINUE

C  THE ABOVE LABEL IS THE END OF THE  DO 1000 ITIM = 1,NTIMI  LOOP.


C  NOW CHECK TO SEE IF THE DOSAGE REGIMEN ENDS WITH ONE OR MORE STEADY

C  STATE EVENTS. NOTE THAT THERE ARE NSST(ISUB) STEADY STATE EVENTS,
C  AND NSSEVENTS - 1 OF THESE HAVE BEEN WRITTEN TO THE WORKING COPY FILE
C  SO FAR. 

 1010   CONTINUE

        IF(NSSEVENTS .LE. NSST(ISUB)) THEN


C  THE NEXT STEADY STATE DOSE EVENT OCCURS AFTER RESET NO.
C  DOSELINEST(ISUB,NSSEVENTS,100). 

C  FILL IN THE ENTRIES TO DOSELINE FOR THE STEADY STATE DOSE AT THE
C  BEGINNING OF THIS DOSE RESET.

C  THE FIRST ENTRY IN DOSELINST IS TIMEVENT = THE NEGATIVE OF THE
C  INTERDOSE INTERVAL.

          DOSELINES(1) = DOSELINEST(ISUB,NSSEVENTS,1)
          NENTRY = 1

C  FOR EACH DRUG, THE IV AND TOTAL VALUES ARE ALREADY STORED INTO
C  DOSELINEST(ISUB,NSSEVENTS,2*I) AND DOSELINEST(ISUB,NSSEVENTS,2*I+1),

C  I=1,NDRUG.

          DO IDRUG = 1,NDRUG
           NENTRY = NENTRY+1
           DOSELINES(NENTRY) = DOSELINEST(ISUB,NSSEVENTS,2*IDRUG)

           NENTRY = NENTRY+1
           DOSELINES(NENTRY) = DOSELINEST(ISUB,NSSEVENTS,2*IDRUG+1)

          END DO

C  FOR EACH COVARIATE, IF ANY, THE VALUES ARE STORED INTO
C  DOSELINEST(ISUB,NSSEVENTS,19+ICOV), ICOV = 1,NCOVA.

          IF(NCOVA .GT. 0) THEN
           DO ICOV = 1,NCOVA
            NENTRY = NENTRY+1
            DOSELINES(NENTRY) = DOSELINEST(ISUB,NSSEVENTS,19+ICOV)
           END DO
          ENDIF

C  REPLACE WRITING OF DOSELINES() WITH XVERIFY (SEE LOGIC IN 
C  SUBROUTINE VERIFYVAL.

        DO J = 1,NENTRY
         XVERIFY(J) = DOSELINES(J)
        END DO
        CALL VERIFYVAL(NENTRY,XVERIFY)
C       WRITE(33,1) (DOSELINES(J),J=1,NENTRY)
        WRITE(33,1) (XVERIFY(J),J=1,NENTRY)

          NSSEVENTS = NSSEVENTS + 1
 
          GO TO 1010

        ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(NSSEVENTS .LE. NSST(ISUB))  CONDITION.




C----------------- WRITE THE DOSE EVENTS ABOVE -------------------------



C----------------- WRITE THE OBSERVATION EVENTS BELOW ------------------


	WRITE(33,106) NOUT
  106   FORMAT(/'     ',I1,' ... NO. OF TOTAL OUTPUT EQUATIONS')


C  EACH SET OF TIMES FOR EACH OUTPUT EQUATION, TIMOUT(ISUB,IOUT,I),
C  I = 1,NTIMOUT(ISUB,IOUT), IS IN ORDER, BUT EACH TIME HAS ADDED
C  TO IT TIMADD*NRESET, WHERE NRESET IS THE NO. OF TIME RESETS UP TO
C  AND TIME. 

C  CALL FIXOUTIM TO OBTAIN NTIMORD, TIMORD, AND BLOCKOUT, WHERE
C  NTIMORD IS THE TOTAL NO. OF UNIQUE TIMES TO BE PUT INTO THE 
C  OBSERVATION BLOCK; TIMORD(.) IS THE ORDERED ACTUAL TIMES (I.E., EACH
C  OF THE TIMES IN TIMOUT(.,.,.) HAS BEEN REDUCED BY TIMADD*NRESET - SEE
C  ABOVE), EXCEPT THAT EACH TIME OF 0 IS NOT ORDERED (IT INDICATES THE 
C  NEXT TIME RESET) FOR THE OBSERVATION BLOCK; AND BLOCKOUT IS THE 
C  CORRESPONDING ARRAY OF OBSERVED VALUES FOR THE NOUT OUTPUT EQUATIONS 
C  AT THE TIMES IN TIMORD.



	CALL FIXOUTIM(MAXSUB,ISUB,SUBID,NOUT,NTIMOUT,TIMOUT,OUT,NTIMORD,
     1   TIMORD,BLOCKOUT,TIMADD)


      	WRITE(33,62) NTIMORD
   62   FORMAT('  ',I4,' ... NO. OF OBSERVED VALUE TIMES')

C  REPLACE WRITING OF TIMORD(), BLOCKOUT() WITH XVERIFY (SEE LOGIC IN 
C  SUBROUTINE VERIFYVAL).


       DO I = 1,NTIMORD
        XVERIFY(1) = TIMORD(I)
        DO J = 1,NOUT
         XVERIFY(1+J) = BLOCKOUT(I,J)
        END DO
        CALL VERIFYVAL(1+NOUT,XVERIFY)      
C       WRITE(33,63) TIMORD(I),(BLOCKOUT(I,J),J=1,NOUT)

        WRITE(33,63) (XVERIFY(IXV),IXV=1,1+NOUT)
   63   FORMAT(7(G16.8,1X))
       END DO


C----------------- WRITE THE OBSERVATION EVENTS ABOVE ------------------


C----------------- WRITE THE BOTTOM OF FILE BELOW ----------------------

	WRITE(33,303)
  303   FORMAT(/' COVARIATE NAMES AND VALUES (1ST, LAST, AND MEAN) FOLLO

     1W:')

C  FOR NOW, THE MEAN VALUE OF EACH COV. WILL BE -99 ... UNTIL WE DECIDE
C  WHAT KIND OF MEAN WE WANT. E.G., IF A COV. = 100 AT T=0 AND
C  200 AT T = 10 AND 300 AT T = 11, WHICH IS THE LAST TIME, DO WE
C  SIMPLY AVERAGE 100,200, AND 300, OR DO WE TAKE A WEIGHTED MEAN
C  WHICH WOULD BE (100*10 + 200*1 + 300*0)/11, OR SOMETHING ELSE???

C  REPLACE WRITING OF COV(),XMEAN WITH XVERIFY (SEE LOGIC IN 
C  SUBROUTINE VERIFYVAL

      XMEAN = -99
      DO ICOV = 1,NCOVA
       XVERIFY(1) = COV(ISUB,ICOV,1)
       XVERIFY(2) = COV(ISUB,ICOV,NTIMCOV(ISUB,ICOV))
       XVERIFY(3) = XMEAN
       CALL VERIFYVAL(3,XVERIFY)
C      WRITE(33,304) COVNAME(ICOV),COV(ISUB,ICOV,1),
C    1  COV(ISUB,ICOV,NTIMCOV(ISUB,ICOV)),XMEAN
       WRITE(33,304) COVNAME(ICOV),(XVERIFY(I),I=1,3) 
      END DO
  304 FORMAT(A11,3X,3(F15.5,1X))


	WRITE(33,306)
  306   FORMAT(/'ASSAY COEFFICIENTS FOLLOW, ONE SET FOR EACH OUTPUT EQUA
     1TION:')

C  REPLACE WRITING OF CSUB() WITH XVERIFY (SEE LOGIC IN 
C  SUBROUTINE VERIFYVAL.

        DO K = 1,NOUT
         DO I=1,4
          XVERIFY(I) = CSUB(ISUB,I,K)
         END DO
         CALL VERIFYVAL(4,XVERIFY)
C        WRITE(33,3061) (CSUB(ISUB,I,K),I=1,4)
         WRITE(33,3061) (XVERIFY(I),I=1,4)
        END DO

 3061   FORMAT(4(F17.8,1X))


C----------------- WRITE THE BOTTOM OF FILE ABOVE ----------------------


	CLOSE(33)

	RETURN 
	END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
	SUBROUTINE Old_THESAME(X1,X2,ISAME)
	IMPLICIT REAL*8(A-H,O-Z)


C  THIS ROUTINE CHECKS TO SEE IF X1 AND X2 ARE VIRTUALLY THE SAME 
C  VALUES (I.E., IF THEY ARE WITHIN 1.D-10 OF EACH OTHER). IF SO,
C  ISAME RETURNS AS 1; IF NOT ISAME RETURNS AS 0.

	ISAME = 0
	XDEL = DABS(X1-X2)
	IF(XDEL .LE. 1.D-10) ISAME = 1
	
	RETURN
	END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
	SUBROUTINE GETID(SUBID)
	CHARACTER SUBID*11,SUB*11

C  THIS ROUTINE IS CALLED TO REPLACE SUBID (WHICH HAS 11 CHARACTERS IN
C  IT) WITH THE CHARACTERS UP TO BUT NOT INCLUDING THE 1ST COMMA.


	SUB = '           '
	DO I = 1,11
	 IF(SUBID(I:I) .NE. ',') SUB(I:I) = SUBID(I:I)	 
	 IF(SUBID(I:I) .EQ. ',') GO TO 10
	END DO


   10   SUBID = SUB
		
	RETURN
	END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
	SUBROUTINE TIMESET(MAXSUB,ISUB,SUBID,NTIMALL,TIMALL,NTIMI,
     1    TIMI)

       use npag_utils, only: thesame

      IMPLICIT REAL*8(A-H,O-Z)
      DIMENSION TIMALL(MAXSUB,24000),NTIMALL(MAXSUB),TIMI(24000),
     1   TIM(24000)
	CHARACTER SUBID*11


C  THIS ROUTINE IS CALLED BY READBLOCK2, TO ORDER ALL THE NTIMALL(ISUB) 
C  TIMES IN TIMALL(ISUB,.), ELIMINATING DUPLICATE TIMES.

C  RETURNED TO READBLOCK2 IS THE VECTOR TIMI, WITH NTIMI TIMES, 
C  ESTABLISHED AS INDICATED ABOVE.


C  THE FIRST TIME IS TIMALL(ISUB,1) AND SHOULD BE 0. CHECK THIS FIRST.

	CALL THESAME(TIMALL(ISUB,1),0.D0,ISAME)

C  IF ISAME RETURNS FROM SUBROUTINE THESAME AS 1, THE TIMES ARE THE 
C  "SAME" (I.E., WITHIN 1.D-10). OTHERWISE, THE TIMES ARE NOT THE 
C  SAME AND ISAME = 0.


C  STARTING WITH MONT101F.FOR, DO NOT CHECK THAT THE FIRST DOSE TIME IN
C  EACH PATIENT IS 0, SINCE THE FIRST TIME MAY BE NEGATIVE (WHICH 

C  SIGNIFIES THE DOSAGE REGIMEN BEGINS WITH A STEADY STATE OF DOSES).



C	IF(ISAME .EQ. 0) THEN
C	 WRITE(*,1) ISUB,TIMALL(ISUB,1)
C    1    FORMAT(/' THE FIRST TIME IN THE DOSAGE BLOCK FOR SUBJECT ',I5,
C     1' IS NOT 0; IT IS ',G14.5//
C     2' THIS IS NOT ALLOWED. PLEASE SET THE FIRST TIME IN THE DOSAGE'/
C     3' BLOCKS FOR ALL SUBJECTS TO BE 0, AND RERUN THE PROGRAM.')
C	 WRITE(*,401) ISUB,SUBID
C  401    FORMAT(/' NOTE: THE ID FOR SUBJECT NO. ',I4,' IS ',A11/)
C	 CALL PAUSE
C	 STOP
C	ENDIF





C  CALL SUBROUTINE PUTORDER TO ORDER THE NTIMALL(ISUB) VALUES IN 
C  TIMALL(ISUB,.).

	DO I = 1,NTIMALL(ISUB)
	 TIM(I) = TIMALL(ISUB,I)
	END DO

	CALL PUTORDER(NTIMALL(ISUB),TIM)



C  THE NTIMALL(ISUB) VALUES ARE NOW ORDERED IN TIM.


C  THE CODE BELOW BELOW WILL REMOVE DUPLICATE TIMES.

	TIMELAST = -1.D39

	NTIMI = 0

	DO I = 1,NTIMALL(ISUB)

	 TIME = TIM(I)
	 CALL THESAME(TIME,TIMELAST,ISAME)

C  IF ISAME RETURNS FROM SUBROUTINE THESAME AS 1, TIME = TIMELAST (OR AT
C  LEAST, THEY ARE WITHIN 1.D-10), AND THIS TIME CAN BE IGNORED SINCE IT
C  WAS ALREADY PUT INTO TIMI (ACTUALLY THE VALUE REDUCED BY TIMERESET)
C  BY A PREVIOUS TIME.

	 IF(ISAME .EQ. 1) GO TO 30

C  TO GET HERE, ISAME = 0, WHICH MEANS THIS IS A NEW TIME. SO PUT
C  TIME INTO TIMI. THEN SET TIMELAST = TIME AND CONTINUE THE LOOP.


	  NTIMI = NTIMI + 1
	  TIMI(NTIMI) = TIME
	  TIMELAST = TIME



   30    CONTINUE


	END DO


	RETURN
	END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
	SUBROUTINE PUTORDER(NX,XX)

C  SUBROUTINE PUTORDER IS CALLED BY SUBROUTINE TIMESET. IT INPUTS XX, A
C  VECTOR OF SIZE, NX, AND RETURNS RETURNS XX, BUT WITH THE VALUES 
C  ORDERED FROM LOW TO HIGH.

      IMPLICIT REAL*8(A-H,O-Z)
      DIMENSION XX(24000),Y(24000),IZ(24000),IZZ(24000)

C  ORDER THE NX VALUES IN X AS FOLLOWS:

C  PUT THE NX VALUES INTO VECTOR Y TO START.
C  INITIALIZE VECTOR IZ TO BE -99 IN ALL ITS NX LOCATIONS. THEN, FOR
C  EXAMPLE, IF ENTRY 17 IS THE SMALLEST VALUE IN Y, IZ(17) WILL BE 
C  SET = 0, AND THE PROGRAM WILL KNOW NOT TO CHECK THE 17TH ENTRY 
C  AGAIN (SINCE IT HAS ALREADY BEEN SELECTED). IF THE NEXT SMALLEST 
C  ENTRY HAS INDEX 37, THEN IZ(37) WILL BE SET = 0, ETC. 

C  NOTE THAT IZZ WILL BE THE ARRAY WHICH CONTAINS THE ACTUAL ORDERING.
C  IN THE EXAMPLE ABOVE, IZZ(1) = 17, IZZ(2) = 37. IT WILL BE EASY TO 
C  ASSIGN ORDERED VALUES BACK INTO XX USING IZZ. IN THE EXAMPLE ABOVE, 
C  XX(1) = Y(IZZ(1)) = Y(17), XX(2) = Y(IZZ(2)) = Y(37), ETC.

	 DO I=1,NX
	  Y(I) = XX(I)

	  IZ(I) = -99
	 END DO


	 DO IPLACE = 1,NX

C  PUT THE NEXT LOWEST VALUE OF Y INTO THE IPLACE LOCATION OF
C  IZZ.

C  TEMP IS THE RUNNING VALUE OF THE NEXT VALUE TO BE PLACED INTO Y.
C  INITIALIZE IT TO BE VERY HIGH VALUE SO THE FIRST VALUE Y WILL BE 

C  SURE TO BE LOWER THAN IT IS.

	  TEMP = 1.D50

	  DO I=1,NX

	   IF(Y(I) .LT. TEMP .AND. IZ(I) .EQ. -99) THEN
	    TEMP = Y(I)

	    IND = I
	   ENDIF
	  END DO

C  AT THIS POINT, IND IS THE INDEX OF THE SMALLEST REMAINING VALUE
C  (TEMP) IN Y. PUT THIS INFORMATION INTO IZZ. ALSO,

C  SET IZ(IND) = 0 --> THE IND LOCATION IN Y HAS BEEN USED.

	  IZZ(IPLACE) = IND
	  IZ(IND) = 0

	 END DO	

C  AT THIS POINT IZZ CONTAINS THE ORDERED INDICES (LOW TO HIGH) OF Y.
C  USE THIS TO RE-ESTABLISH X TO BE ORDERED LOW TO HIGH.
	
	 DO I = 1,NX

	  XX(I) = Y(IZZ(I))
	 END DO

	
	RETURN
	END

C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
	SUBROUTINE FIXOUTIM(MAXSUB,ISUB,SUBID,NOUT,NTIMOUT,TIMOUT,OUT,
     1   NTIMORD,TIMORD,BLOCKOUT,TIMADD)

        use npag_utils, only: thesame

	IMPLICIT REAL*8(A-H,O-Z)

	PARAMETER(MAXNUMEQ=7)

      DIMENSION TIMOUT(MAXSUB,MAXNUMEQ,650),NTIMOUT(MAXSUB,MAXNUMEQ),
     1 IENTRY(MAXNUMEQ),OUT(MAXSUB,MAXNUMEQ,650),TIMORD(3900),
     2 BLOCKOUT(3900,MAXNUMEQ)

	CHARACTER SUBID*11,ERRFIL*20



      COMMON/ERROR/ERRFIL
C  COMMON/ERROR/ IS SUPPLIED TO ALL THE ROUTINES WHICH COULD WRITE TO
C  ERRFIL.

C  FIXOUTIM IS CALLED BY WRITEDOS TO ORDER THE OUTPUT TIMES AMONG ALL 
C  THE NOUT OUTPUT EQUATIONS. NOTE THAT EACH OF THE TIMES CURRENTLY IN
C  TIMOUT HAS BEEN INCREASE BY TIMERESET = TIMADD*NRESET, WHERE NRESET
C  IS THE NO. OF TIME RESETS UP TO AND INCLUDING THAT TIME (THIS WAS 
C  DONE IN SUBROUTINE READBLOCK2).


C  RETURNED TO SUBROUTINE WRITEDOS ARE:

C  NTIMORD = NO. OF TIME VALUES IN TIMORD.

C  TIMORD(I), I=1,NTIMORD = THE ORDERED SET OF TIMES (EXCEPT FOR 0'S
C   WHICH INDICATE A TIME RESET) OVER ALL THE NOUT TIME ARRAYS.


C  BLOCKOUT(I,J) = OBSERVED VALUE FOR IOUTPUT EQUATION J, FOR THE TIME
C   VALUE, TIMORD(I), I=1,NEXT; J = I,NOUT.


C  NOTE THAT EACH OF THE TIME ARRAYS, TIMOUT(ISUB,IOUT,.) HAS ITS OWN
C  VALUES IN ORDER (THEY WERE FILLED IN ORDER IN READBLOCK2). NOW, 
C  ESTABLISH THE ARRAY, TIMORD, WHICH HAS THE ORDERED SET OF
C  TIMES OVER ALL THE NOUT TIME ARRAYS. ALSO, REDUCE EACH TIME BY 
C  TIMRESET = NRESET*TIMADD TO RETURN EACH TIME TO ITS ORIGINAL VALUE. 
C  NOTE THAT THIS WILL HAVE THE EFFECT OF SETTING TO 0 THE TIMES WHICH 
C  ARE THE TIME RESET POINTS (THEIR ACCOMPANYING OUTPUT VALUES WILL
C  OF COURSE BE SET TO -99).

C  INITIALIZE THE NEXT TIME TO BE PUT INTO TIMORD TO BE A LARGE NO.
C  AND INITIALIZE THE INDEX OF THE NEXT ENTRY IN EACH OF THE TIMOUT
C  ARRAYS TO BE 1. ALSO INITIALIZE INEXT TO BE 1. IT WILL BE THE 
C  RUNNING INDEX OF THE NEXT ENTRY TO BE PUT INTO TIMORD.



	DO IOUT = 1,NOUT

	 IENTRY(IOUT) = 1
	END DO

	INEXT = 1

   20	TIMENEXT = 1.D50

C  SET IANOTHER = 0. IF IT STAYS 0, THERE ARE NO MORE TIMES IN
C  ANY OF THE ARRAYS.

	 IANOTHER = 0


        DO IOUT	= 1,NOUT

C  FOR OUTPUT EQUATION IOUT, IF IENTRY(IOUT) .LE. THE NO. OF ENTRIES
C  IN THE TIME ARRAY FOR IOUT, THEN THIS ENTRY IS EQUATION IOUT'S
C  CANDIDATE FOR THE NEXT LOWEST TIME.

	 IF(IENTRY(IOUT) .LE. NTIMOUT(ISUB,IOUT)) THEN
	  IANOTHER = 1
	  IF(TIMOUT(ISUB,IOUT,IENTRY(IOUT)) .LE. TIMENEXT) 
     1     TIMENEXT = TIMOUT(ISUB,IOUT,IENTRY(IOUT))
	 ENDIF

	END DO

C  IF IANOTHER = 0, ALL TIME ARRAY, AND CORRESPONDING OBSERVED, VALUES 
C  HAVE BEEN STORED, SO GO TO 100 TO RECAST TIMORD BEFORE RETURNING.

	IF(IANOTHER .EQ. 0) GO TO 100


C  AT THIS POINT, TIMENEXT IS THE NEXT LOWEST TIME OVER ALL THE NOUT
C  TIMOUT ARRAYS. PUT IT INTO TIMORD, AND PUT THE CORRESPONDING ENTRIES
C  FOR EACH OF THE NOUT OUTPUT EQUATIONS INTO THE ARRAY BLOCKOUT. ALSO,
C  INCREASE THE ENTRY NO. FOR THE TIME ARRAY(S) WHICH HAD THIS TIME. 
C  BUT CHECK THAT THE NO. OF ENTRIES INTO TIMORD IS NOT > THE MAX, 3900. 
C  IF IT IS, STOP.


	IF(INEXT .GT. 3900) THEN



	 WRITE(*,1)
    1    FORMAT(/' THE TOTAL NO. OF OBSERVATION TIMES IS GREATER THAN'/
     1' THE MAXIMUM ALLOWABLE VALUE OF 3900 (SUBROUTINE FIXOUTIM).'/
     2' RERUN THE PROGRAM AFTER REDUCING THE NO. OF OBS. TIMES.'/)
	 WRITE(*,401) ISUB,SUBID
  401    FORMAT(/' NOTE: THE ID FOR SUBJECT NO. ',I4,' IS ',A11/)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,1) 
         WRITE(42,401) ISUB,SUBID
        CLOSE(42)
	


	 CALL PAUSE
	 STOP



	ENDIF

	TIMORD(INEXT) = TIMENEXT


        DO IOUT	= 1,NOUT

	  BLOCKOUT(INEXT,IOUT) = -99.D0
	  CALL THESAME(TIMENEXT,TIMOUT(ISUB,IOUT,IENTRY(IOUT)),ISAME)

	  IF(ISAME .EQ. 1) THEN
	   BLOCKOUT(INEXT,IOUT) = OUT(ISUB,IOUT,IENTRY(IOUT))
	   IENTRY(IOUT) = IENTRY(IOUT) + 1
	  ENDIF

	END DO


	INEXT = INEXT + 1	

	GO TO 20
 

  100   NTIMORD = INEXT - 1


C  NOW, RECAST TIMORD TO BE THE CORRECT TIME VALUES. RECALL THAT,
C  CURRENTLY, EACH TIME HAS NRESET*TIMADD ADDED TO ITS VALUE WHERE 
C  NRESET IS THE NO. OF TIME RESET 0'S UP TO AND INCLUDING THAT TIME 
C  VALUE.

C  INITIALIZE NRESET = 0. THIS IS THE RUNNING NUMBER OF TIME RESETS 
C  THAT HAVE OCCURED. ALSO INITIALIZE TIMERESET AS THE CURRENT AMOUNT 
C  OF TIME TO SUBTRACT TO DO THE RECASTING.

	NRESET = 0

	TIMERESET = TIMADD*NRESET

	DO I = 1,NTIMORD
	 CALL THESAME(TIMORD(I),TIMADD*(NRESET+1),ISAME)	 	
	 


	 IF(ISAME .EQ. 1) THEN
	  NRESET = NRESET + 1
	  TIMERESET = TIMADD*NRESET
	 ENDIF

	 TIMORD(I) = TIMORD(I) - TIMERESET
	END DO


	RETURN


	END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
	SUBROUTINE GETMAXTIM(NCOVA,TIMAX)

	IMPLICIT REAL*8(A-H,O-Z)

	CHARACTER READLINE*1000

C  THIS SUBROUTINE IS CALLED BY READBLOCK2 TO GET TIMAX, THE MAXIMUM TIME 
C  OVER ALL SUBJECTS IN FILE 67. THIS MAXIMUM TIME INCLUDES THE ENDING
C  TIME FOR ALL IV RATES.

C  GO THROUGH ALL THE ROWS OF THE BLOCK FORMAT FILE. READ THE EVENT 
C  TIMES IN ENTRY 3. IF THE ROW IS AN IV ROW, ADD THIS VALUE TO THE 
C  DURATION TIME IN ENTRY 4. THEN UPDATE TIMAX IF THIS TOTAL TIME IS
C  > TIMAX, WHICH IS INITIALIZED BELOW TO BE NEGATIVE.


	TIMAX = -1.D0


   10   READ(66,1,IOSTAT=IEND) READLINE
    1   FORMAT(A1000)

	IF(IEND .LT. 0) RETURN
	IF(READLINE(1:1) .EQ. '#' .OR. READLINE(1:2) .EQ. '"#') GO TO 10

	 CALL AFTERCOMMA(NCOVA,READLINE,2)
	 BACKSPACE(57)
	 READ(57,*) TIMEVENT
	 CLOSE(57)



	 CALL AFTERCOMMA(NCOVA,READLINE,3)
	 BACKSPACE(57)
	 READ(57,*,ERR=15) TIMDUR
	 GO TO 20	 	
   15    TIMDUR = 0.D0
   20    TIME = TIMEVENT + TIMDUR
	 CLOSE(57)

	 IF(TIMAX .LT. TIME) TIMAX = TIME
	 GO TO 10


	END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
	SUBROUTINE GETCHAR2(JSUB,CHARSUB)
	CHARACTER CHARSUB*3
	CHARACTER*1 B,C,D


C  THIS ROUTINE, CALLED BY READBLOCK2, INPUTS THE INTEGER JSUB
C  (BETWEEN 1 AND 999), AND OUTPUTS THE 3-CHARACTER EQUIVALENT, CHARSUB.

	ILEFT = JSUB
	I3 = ILEFT/100
	ILEFT = ILEFT - I3*100
	I2 = ILEFT/10
 	ILEFT = ILEFT - I2*10
	I1 = ILEFT

C  CONVERT THIS TO THE CHARACTER EQUIVALENT. 

	IF(I3 .EQ. 1) B='1'
	IF(I3 .EQ. 2) B='2'
	IF(I3 .EQ. 3) B='3'
	IF(I3 .EQ. 4) B='4'
	IF(I3 .EQ. 5) B='5'
	IF(I3 .EQ. 6) B='6'
	IF(I3 .EQ. 7) B='7'
	IF(I3 .EQ. 8) B='8'


	IF(I3 .EQ. 9) B='9'
	IF(I3 .EQ. 0) B='0'

	IF(I2 .EQ. 1) C='1'
	IF(I2 .EQ. 2) C='2'
	IF(I2 .EQ. 3) C='3'
	IF(I2 .EQ. 4) C='4'
	IF(I2 .EQ. 5) C='5'
	IF(I2 .EQ. 6) C='6'
	IF(I2 .EQ. 7) C='7'


	IF(I2 .EQ. 8) C='8'
	IF(I2 .EQ. 9) C='9'
	IF(I2 .EQ. 0) C='0'

	IF(I1 .EQ. 1) D='1'
	IF(I1 .EQ. 2) D='2'
	IF(I1 .EQ. 3) D='3'
	IF(I1 .EQ. 4) D='4'
	IF(I1 .EQ. 5) D='5'
	IF(I1 .EQ. 6) D='6'
	IF(I1 .EQ. 7) D='7'
	IF(I1 .EQ. 8) D='8'
	IF(I1 .EQ. 9) D='9'
	IF(I1 .EQ. 0) D='0'


	CHARSUB = B//C//D

	RETURN

	END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
        SUBROUTINE PAUSE


C  THIS ROUTINE IS USED TO REPLACE A PAUSE STATEMENT, WHICH CAUSES 
C  WARNINGS WHEN THIS PROGRAM IS COMPILED AND LINKED USING gfortran
C  (AND FORCES THE USER TO TYPE "go" INSTEAD OF SIMPLY HITTING THE
C  ENTER KEY).

        WRITE(*,1)
    1   FORMAT(' HIT ANY KEY TO CONTINUE: ')
        READ(*,*,ERR=10) IKEY
        IF(IKEY .EQ. 1) RETURN
   10   RETURN
        END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
        SUBROUTINE NEWCSV


C  NEWCSV IS CALLED BY MAIN TO CONVERT THE .CSV FILE IN FILE 77 TO
C  A NEW .CSV FILE IN FILE 67, WITH ALL MISSING VALUE DOTS CHANGED TO
C  n's. THIS CODE IS BASED ON THE STAND-A-LONE PROGRAM NEWCSV.FOR.

C  IN PARTICULAR, THE FOLLOWING SEQUENCES WILL BE REPLACED AS SHOWN:

C   ,.,  WILL BE REPLACED BY  ,n,
C   ,.   WILL BE REPLACED BY  ,n  <-- THIS OCCURS AT END OF LINES.

C  NOTE THAT THE SECOND SEQUENCE ABOVE IS COMMA/DOT/SPACE, NOT JUST
C  COMMA/DOT SINCE WE DON'T WANT ,.35  REPLACED BY ,n35, FOR EXAMPLE.

        IMPLICIT REAL*8(A-H,O-Z)
        CHARACTER READLINE*1000


C  WRITE EACH LINE OF FILE 77 TO FILE 67, BUT REPLACE ALL MISSING VALUE
C  DOTS WITH n's.       

   10   READ(77,4,IOSTAT=IEND) READLINE

    4   FORMAT(A1000)
        IF(IEND .LT. 0) GO TO 100


C  FOR THIS LINE, READLINE, FIND IENDL, THE LAST CHARACTER WHICH IS NOT
C  BLANK. THEN ONLY CHARACTERS 1:IENDL WILL BE WRITTEN TO FILEOUT.

        DO IENDL = 1000,1,-1
         IF(READLINE(IENDL:IENDL) .NE. ' ') GO TO 20
        END DO

   20   CONTINUE


C  BEFORE WRITING READLINE(1:IENDL) TO FILE 22, GO THROUGH THE LINE AND
C  REPLACE ANY DOTS WHICH REPRESENT MISSING VALUES WITH n's.

C  NOTE THAT, AS EXPLAINED ABOVE, THIS MEANS REPLACING AS FOLLOWS:
C   ,.,  WILL BE REPLACED BY  ,n,
C   ,.   WILL BE REPLACED BY  ,n  <-- THIS OCCURS AT END OF LINES.

        DO I = 1,IENDL-2
         IF(READLINE(I:I+2) .EQ. ',.,') READLINE(I:I+2) = ',n,'
        END DO

        IF(READLINE(IENDL-1:IENDL) .EQ. ',.') 
     1   READLINE(IENDL-1:IENDL) = ',n'
      

C  CANNOT USE WRITE(67,4) READLINE(1:IENDL) SINCE, FOR SOME REASON,
C  WRITING LIKE THIS "RIGHT JUSTIFIES" THE CHARACTERS AT THE END
C  OF THE A1000 FORMAT. INSTEAD MUST WRITE (67,__) READLINE, WHERE
C  THE FORMAT IS DETERMINED BY THE LAST NON-BLANK CHARACTER (IENDL)
C  IN READLINE.


	IF(IENDL .LE. 26) THEN
	 WRITE(67,26) READLINE
   26    FORMAT(A26)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 51) THEN
	 WRITE(67,51) READLINE
   51    FORMAT(A51)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 76) THEN
	 WRITE(67,76) READLINE
   76    FORMAT(A76)
	 GO TO 10
	ENDIF


	IF(IENDL .LE. 101) THEN
	 WRITE(67,101) READLINE
  101    FORMAT(A101)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 126) THEN
	 WRITE(67,126) READLINE
  126    FORMAT(A126)


	 GO TO 10
	ENDIF

	IF(IENDL .LE. 151) THEN
	 WRITE(67,151) READLINE
  151    FORMAT(A151)
	 GO TO 10
	ENDIF



	IF(IENDL .LE. 176) THEN
	 WRITE(67,176) READLINE
  176    FORMAT(A176)
	 GO TO 10
	ENDIF


	IF(IENDL .LE. 201) THEN
	 WRITE(67,201) READLINE
  201    FORMAT(A201)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 226) THEN
	 WRITE(67,226) READLINE
  226    FORMAT(A226)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 251) THEN
	 WRITE(67,251) READLINE
  251    FORMAT(A251)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 276) THEN
	 WRITE(67,276) READLINE
  276    FORMAT(A276)
	 GO TO 10

	ENDIF

	IF(IENDL .LE. 301) THEN
	 WRITE(67,301) READLINE
  301    FORMAT(A301)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 326) THEN
	 WRITE(67,326) READLINE
  326    FORMAT(A326)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 351) THEN
	 WRITE(67,351) READLINE

  351    FORMAT(A351)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 376) THEN
	 WRITE(67,376) READLINE
  376    FORMAT(A376)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 401) THEN

	 WRITE(67,401) READLINE
  401    FORMAT(A401)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 426) THEN
	 WRITE(67,426) READLINE
  426    FORMAT(A426)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 451) THEN
	 WRITE(67,451) READLINE
  451    FORMAT(A451)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 476) THEN
	 WRITE(67,476) READLINE
  476    FORMAT(A476)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 501) THEN

	 WRITE(67,501) READLINE
  501    FORMAT(A501)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 526) THEN
	 WRITE(67,526) READLINE
  526    FORMAT(A526)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 551) THEN
	 WRITE(67,551) READLINE
  551    FORMAT(A551)

	 GO TO 10
	ENDIF


	IF(IENDL .LE. 576) THEN
	 WRITE(67,576) READLINE
  576    FORMAT(A576)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 601) THEN
	 WRITE(67,601) READLINE
  601    FORMAT(A601)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 626) THEN
	 WRITE(67,626) READLINE
  626    FORMAT(A626)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 651) THEN
	 WRITE(67,651) READLINE
  651    FORMAT(A651)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 676) THEN
	 WRITE(67,676) READLINE
  676    FORMAT(A676)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 701) THEN
	 WRITE(67,701) READLINE
  701    FORMAT(A701)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 726) THEN

	 WRITE(67,726) READLINE
  726    FORMAT(A726)
	 GO TO 10
	ENDIF


	IF(IENDL .LE. 751) THEN
	 WRITE(67,751) READLINE
  751    FORMAT(A751)
	 GO TO 10

	ENDIF

	IF(IENDL .LE. 776) THEN
	 WRITE(67,776) READLINE
  776    FORMAT(A776)
	 GO TO 10
	ENDIF


	IF(IENDL .LE. 801) THEN
	 WRITE(67,801) READLINE
  801    FORMAT(A801)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 826) THEN
	 WRITE(67,826) READLINE

  826    FORMAT(A826)

	 GO TO 10
	ENDIF

	IF(IENDL .LE. 851) THEN
	 WRITE(67,851) READLINE
  851    FORMAT(A851)
	 GO TO 10

	ENDIF


	IF(IENDL .LE. 876) THEN

	 WRITE(67,876) READLINE
  876    FORMAT(A876)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 901) THEN
	 WRITE(67,901) READLINE
  901    FORMAT(A901)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 926) THEN
	 WRITE(67,926) READLINE
  926    FORMAT(A926)

	 GO TO 10
	ENDIF

	IF(IENDL .LE. 951) THEN
	 WRITE(67,951) READLINE
  951    FORMAT(A951)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 976) THEN
	 WRITE(67,976) READLINE
  976    FORMAT(A976)

	 GO TO 10
	ENDIF


	WRITE(67,4) READLINE
	GO TO 10



  100   CLOSE(77)
        REWIND(67)

        RETURN
        END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
        SUBROUTINE WORKTOCSV(NSUB,PATH,PREFIX,EXT,OUTCSVNAME,
     1    INTLIST)

C  THIS SUBROUTINE IS BASED ON THE STAND-A-LONE PROGRAM,
C  WORKCSV.FOR, BUT SOME OF THE DIMENSIONS ARE DIFFERENT TO BE
C  COMPATIBLE WITH THIS PROGRAM.
C  NO! AS OF MONT101F.FOR, THIS ROUTINE WILL CREATE THE NEW-STYLE
C      .CSV FILE, WITH CODE POPDATA DEC_11 AT THE TOP (I.E., THE TYPE
C      THAT HAS TWO EXTRA COLUMNS FOR ADDL AND II).

        PARAMETER(MAXSUB=10000,MAXNUMEQ=7)

        IMPLICIT REAL*8(A-H,O-Z)

        integer, dimension(128) :: INTLIST

      DIMENSION SIG(5000),RS(5000,34),YO(594,MAXNUMEQ),C0(MAXNUMEQ),
     1 C1(MAXNUMEQ),C2(MAXNUMEQ),C3(MAXNUMEQ),TIM(594)

        CHARACTER PREFIX*3,EXT*3,NUMBER(MAXSUB)*5,PATFIL*32,PATH*61,
     1   TMPFILE*32,PATHFILE*93,SUBID*11,DESCR(26)*20,OUTCSVNAME*32,
     2   PATHFILE2*93,TOPLINE*1000,TOP1*58,READLINE*80,CHARSUB*5,
     3   COVTIGHT*550,CODE*14

        CODE = 'POPDATA DEC_11'

C  CALL FULLNAME WHICH CONVERTS THE FILENAME TO PATHFILE2, THE COMPLETE 
C  NAME OF THE FILE, WHICH INCLUDES THE PATH (IF THE PATH IS NOT THE 
C  CURRENT DIRECTORY).

         TMPFILE = ' '
         TMPFILE = OUTCSVNAME 
         CALL FULLNAME(PATH,TMPFILE,PATHFILE2)
         OPEN(29,FILE=PATHFILE2)

C  CALL SUBROUTINE GETCHAR TO ESTABLISH THE NUMBER ARRAY.

        DO ISUB = 1,NSUB
         CALL GETCHAR(ISUB,CHARSUB)
         NUMBER(ISUB) = CHARSUB
        END DO


	DO 1000 ISUB = 1,NSUB

	 PATFIL = PREFIX//NUMBER(ISUB)//'.'//EXT

C  CALL FULLNAME WHICH CONVERTS THE FILENAME TO PATHFILE, THE COMPLETE 
C  NAME OF THE FILE, WHICH INCLUDES THE PATH (IF THE PATH IS NOT THE 
C  CURRENT DIRECTORY).

         TMPFILE = ' '
         TMPFILE = PATFIL 
         CALL FULLNAME(PATH,TMPFILE,PATHFILE)
         OPEN(33,FILE=PATHFILE)

C  FOR THIS SUBJECT, READ THE NAME. ALSO, IF IT IS THE FIRST SUBJECT,
C  READ THE NO. AND NAMES OF THE ADDITIONAL COVARIATES (BEYOND THE
C  4 PERMANENT ONES, AGE, SEX, HEIGHT, ETHNICITY FLAG, AT THE TOP
C  OF EACH WORKING COPY FILE) IF ANY, AND WRITE THE TOP LINE OF THE
C  .CSV FILE.

C  THE NAME IS ON LINE 1 IN ENTRIES 29 TO 39. 

         READ(33,9) SUBID
    9    FORMAT(T29,A11)

C  BUT SINCE ALL THE SIMULATED PATIENTS HAVE THE SAME NAME, REPLACE
C  THE READ IN VALUE OF SUBID WITH SIM00001,...

         SUBID = 'SIM'//NUMBER(ISUB)

         IF(ISUB .EQ. 1) THEN

C  WRITE THE FIRST LINE (THE ONE WITH THE CODE) INTO FILE 29.

          WRITE(29,14) CODE
   14     FORMAT(A14)
        
          CALL GETCOVNAME(NCOVA,DESCR)

          
          TOP1 = '#ID,EVID,TIME,DUR,DOSE,ADDL,II,INPUT,OUT,OUTEQ,C0,C1,C
     12,C3'

C  THE TOP LINE OF THE .CSV FILE WILL ALWAYS HAVE TOP1 IN IT, BUT IT  

C  WILL ALSO HAVE THE NAMES OF THE ADDITIONAL COVARIATES, IF ANY, ON 
C  IT. IF NCOVA > 0, CALL COVSTRING TO OBTAIN THE CHARACTER STRING OF 
C  COVARIATE NAMES (COVTIGHT), TIGHTENED TO REMOVE UNNECCESARY SPACES.
C  NCOVTIGHT RETURNS AS THE NO. OF CHARACTERS IN COVTIGHT.

          TOPLINE = TOP1  

          IF(NCOVA .GT. 0) THEN
           CALL COVSTRING(NCOVA,DESCR,COVTIGHT,NCOVTIGHT)
           TOPLINE = TOP1//COVTIGHT(1:NCOVTIGHT)
          ENDIF

          CALL CONDENSE(TOPLINE)

C  CONDENSE WRITES TOPLINE INTO FILE 29 AFTER CONDENSING IT.


         ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(ISUB .EQ. 1)  CONDITION.


C  READ THE DOSAGE INFO AFTER READING THE NO. OF DRUGS, AND THE NO.
C  OF DOSE EVENTS.

   10	   READ(33,22) READLINE
   22    FORMAT(A80)


         IF(READLINE(12:23) .NE. 'NO. OF DRUGS') GO TO 10
         BACKSPACE(33)
         READ(33,13) NDRUG
         INTLIST(5) = NDRUG
   13    FORMAT(T2,I5)

C  SKIP THE NEXT LINE. IT HAS NCOVA ON IT, WHICH IS ALREADY KNOWN.

         READ(33,*)

         NI = 2*NDRUG + NCOVA
         INTLIST(7) = NI
 
C  READ THE NO. OF DOSE EVENTS ON THE NEXT LINE.

         READ(33,13) ND
         READ(33,*)
         READ(33,*)

         IF(ND.EQ.0) GO TO 40

         DO I = 1,ND
          READ(33,*) SIG(I),(RS(I,J),J=1,NI)
         END DO

C  READ THE NO. OF OUTPUT EQUATIONS FROM THE LINE WITH 'NO. OF TOTAL'
C  AS ENTRIES 12:23. THEN READ NO. OF OBSERVED VALUE TIMES, ETC.

   40	   READ(33,22) READLINE
         IF(READLINE(12:23) .NE. 'NO. OF TOTAL') GO TO 40
         BACKSPACE(33)

         READ(33,13) NUMEQT
         READ(33,13) M
         INTLIST(9) = NUMEQT
         INTLIST(10) = M

         DO I=1,M
          READ(33,*) TIM(I),(YO(I,J),J=1,NUMEQT)
         END DO

C  AT THIS POINT, MUST SKIP THE COVARIATE INFO IN THE FILE, AND PROCEED
C  TO READ THE ASSAY NOISE COEFFICIENTS BELOW THAT, IF THEY ARE
C  INCLUDED. IF THEY ARE NOT INCLUDED, SET ALL ASSAY COEFFICIENTS TO 0.


   50	   READ(33,22) READLINE
	   IF(READLINE(1:18) .NE. 'ASSAY COEFFICIENTS') GO TO 50

         IF(READLINE(20:25) .EQ. 'FOLLOW') THEN
          DO IEQ = 1,NUMEQT

           READ(33,*) C0(IEQ),C1(IEQ),C2(IEQ),C3(IEQ)
          END DO
         ENDIF

         IF(READLINE(20:25) .NE. 'FOLLOW') THEN
          DO IEQ = 1,NUMEQT
           C0(IEQ) = 0.D0
           C1(IEQ) = 0.D0
           C2(IEQ) = 0.D0
           C3(IEQ) = 0.D0
          END DO
         ENDIF


         CLOSE(33)

C  CALL WRITECSV TO CONVERT THIS SUBJECT'S VALUES INTO A BLOCK OF
C  LINES IN THE .CSV FILE.

         CALL WRITECSV(SUBID,NDRUG,NCOVA,ND,SIG,RS,NUMEQT,M,TIM,YO,C0,
     1    C1,C2,C3)


 1000   CONTINUE

C  THE ABOVE LINE IS THE END OF THE  DO 1000  LOOP.

        CLOSE(29)

        RETURN
        END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
	SUBROUTINE GETCOVNAME(NCOVA,DESCR)
	IMPLICIT REAL*8(A-H,O-Z)
	CHARACTER READLINE*1000,DESCR(26)*20


C  THIS ROUTINE IS CALLED BY SUBROUTINE WORKTOCSV TO OBTAIN, FROM 
C  FILE 33, THE NO. OF ADDITIONAL COVARIATES (NCOVA), AND THEIR 
C  NAMES (DESCR(I),I=1,NCOVA).


    2   FORMAT(A20)
   33   FORMAT(A1000)

        REWIND(33)

C  THE NO. OF ADDITIONAL COVARIATES IS ON THE LINE HAVING
C  "NO. OF ADDITIONAL COVARIATES" STARTING IN ENTRY 12.

   10	READ(33,33) READLINE
	IF(READLINE(12:28) .NE. 'NO. OF ADDITIONAL') GO TO 10
	BACKSPACE(33)
    3 FORMAT(T2,I5)

      READ(33,3) NCOVA

C  READ THE NCOVA ADDITIONAL COVARIATE NAMES FROM BELOW THE LINE HAVING
C  "COVARIATE NAMES" STARTING IN COLUMN 2. IF NCOVA = 0, NO NAMES 
C  WILL BE READ.



   20	READ(33,33) READLINE
	IF(READLINE(2:16) .NE. 'COVARIATE NAMES') GO TO 20


        IF(NCOVA .GT. 0) THEN

         DO J = 1,NCOVA

          READ(33,33) READLINE

C  FOR THIS COVARIATE, ESTABLISH DESCR(J) AS THE PORTION OF THE
C  CURRENT READLINE UP TO THE  FIRST SPACE, WHICH WILL BE ASSUMED TO BE
C  THE END OF THE COV. NAME. IN CASE THERE IS A SPACE OR TWO AT THE
C  BEGINNING OF READLINE FOR SOME REASON, START CHECKING FOR SPACES AT
C  ENTRY 3.

          DO I = 3,20
           IF(READLINE(I:I) .EQ. ' ') GO TO 30
          END DO

   30     DESCR(J) = READLINE(1:I-1)

         END DO

        ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(NCOVA .GT. 0)  CONDITION.


	REWIND(33)

	RETURN
	END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
        SUBROUTINE WRITECSV(SUBID,NDRUG,NCOVA,ND,SIG,RS,NUMEQT,M,TIM,
     1   YO,C0,C1,C2,C3)

C  WRITECSV IS CALLED BY MAIN TO CONVERT THIS SUBJECT'S VALUES INTO
C  A BLOCK OF LINES IN THE .CSV FILE.

        use npag_utils, only: verifyval, thesame

        IMPLICIT REAL*8(A-H,O-Z)

        PARAMETER(MAXNUMEQ=7)

      DIMENSION SIG(5000),RS(5000,34),YO(594,MAXNUMEQ),C0(MAXNUMEQ),
     1 C1(MAXNUMEQ),C2(MAXNUMEQ),C3(MAXNUMEQ),TIM(594),BS(5000,7),
     2 NOIV(7),AMTIV(7,5000),DURIV(7,5000),IVDOSE(7,5000),XVERIFY(900)

        CHARACTER SUBID*11,DOSESTRING*12,OBSSTRING*52,BIGLINE*1000,
     1   SMALLLINE*1000


C  INITIALIZE IDOSENEXT TO BE 0. SEE LOGIC BELOW.

        IDOSENEXT = 0


C  ASSIGN THE VALUES IN EACH DRUG'S PO COLUMN TO THE CORRESPONDING
C  COLUMN IN ARRAY BS.

        DO IDOSE = 1,ND
         DO JDRUG = 1,NDRUG
          BS(IDOSE,JDRUG) = RS(IDOSE,2*JDRUG)
         END DO
        END DO

C  NOTE THAT, AS OF MONT101F.FOR, IF A STEADY STATE DOSE OCCURS AT

C  IDOSE, THE VALUES PUT INTO BS(.,.) ABOVE ARE NOT BOLI, BUT IT
C  DOESN'T MATTER SINCE THEY WON'T BE USED.



C  FIND THE LARGEST OBSERVATION TIME, TIMOBSMAX. IT WILL ONLY BE USED
C  IN CASE AN IV IS READ IN AS GOING ON INDEFINITELY. IN THAT CASE,
C  THIS IV, WHICH NEEDS A STOPPING TIME IN THE .CSV FILE (UNLIKE IN
C  A WORKING COPY FILE), WILL BE SHOWN AS STOPPING AT TIMOBSMAX. NOTE
C  THAT IF THERE ARE TIME RESETS, IT IS POSSIBLE THAT THE MAXIMUM
C  OBSERVATION TIME FOR THE TIME PERIOD OF THE NEVER-ENDING IV IS 
C  LESS THAN TIMOBSMAX, BUT THIS DOESN'T MATTER (SINCE THE IV WILL
C  HAVE GONE AT LEAST AS LONG AS REQUIRED IN THIS CASE).

        TIMOBSMAX = -1.D39
        DO I = 1,M
         IF(TIM(I) .GT. TIMOBSMAX) TIMOBSMAX = TIM(I)
        END DO

  
C  DETERMINE, FOR EACH DRUG, THE TOTAL AMOUNT OF IV THAT IS GIVEN,
C  AND THE TIME OVER WHICH IT IS GIVEN, FOR EACH SEPARATE IV INFUSION.

        DO JDRUG = 1,NDRUG

C  NOIV(JDRUG) WILL BE THE NO. OF IVs FOR THIS DRUG.

         NOIV(JDRUG) = 0

         IDOSE = 0

   40    IDOSE = IDOSE + 1

C  IF IDOSE IS NOW > ND, THERE ARE NO MORE POSSIBLE IVs FOR THIS DRUG.

          IF(IDOSE .GT. ND) GO TO 60


C  AS OF MONT101F.FOR, MUST CHECK EACH DOSE TIME TO SEE IF IT IS < 0.
C  IF IT IS, THE LINE REPRESENTS A STEADY STATE DOSE SET. IN THIS CASE,
C  SKIP THIS DOSE (SINCE IT CERTAINLY DOES NOT REPRESENT A REGULAR IV).

          IF(SIG(IDOSE) .LT. 0.D0) GO TO 40 


C  IF THE CURRENT DOSE IS .NE. 0, IT IS THE START OF THE NEXT IV.
    
          CALL THESAME(RS(IDOSE,2*JDRUG-1),0.D0,ISAME) 

          IF(ISAME .EQ. 0) THEN

C  FOR DRUG NO. JDRUG, AN IV STARTS WITH DOSE NO. IDOSE. ESTABLISH THE
C  TOTAL AMOUNT FOR THIS IV, AND THE TIME IT LASTS.



           PREVIV = RS(IDOSE,2*JDRUG-1)

           IIDOSE = IDOSE

   50      IIDOSE = IIDOSE + 1

C  IF THIS DOSE TIME IS 0, IT INDICATES A DOSE RESET TIME. THIS MEANS
C  THAT THE CURRENT IV WILL BE SET TO END AT TIMOBSMAX.

C  BUG CORRECTION AS OF MONT110.FOR:
C  ACTUALLY, THE CHECK SHOULD BE TO CHECK TO SEE IF THE DOSE TIME IS
C  0 OR .LE. 0, BECAUSE THE FIRST INDICATES A DOSE RESET TIME WITHOUT
C  A STEADY STATE DOSE SET, AND THE SECOND INDICATES A DOSE RESET TIME
C  WITH A STEADY STATE DOSE SET. EITHER WAY, THE CURRENT IV SHOULD BE
C  SET TO END AT TIMOBSMAX.

            IF(SIG(IIDOSE) .LE. 0.D0) THEN
C            CALL THESAME(SIG(IIDOSE),0.D0,ISAME)
C            IF(ISAME .EQ. 1) THEN
             TIMIV = TIMOBSMAX - SIG(IDOSE)
             TOTIV = TIMIV*RS(IDOSE,2*JDRUG-1)
             GO TO 30
            ENDIF


C  TO GET HERE --> THIS DOSE TIME, SIG(IIDOSE), IS NOT .LE. 0. IN THIS
C  CASE, IF THE IV FOR THIS DRUG IS .NE. PREVIV, THIS DOSE TIME IS THE
C  ENDING TIME FOR THE IV. OTHERWISE, CONTINUE THE LOOP.

            CALL THESAME(RS(IIDOSE,2*JDRUG-1),PREVIV,ISAME)
            IF(ISAME .EQ. 0) THEN
             TIMIV = SIG(IIDOSE) - SIG(IDOSE)
             TOTIV = TIMIV*RS(IDOSE,2*JDRUG-1)
             GO TO 30
            ENDIF

           IF(IIDOSE .LT. ND) GO TO 50

C  TO GET HERE --> THE IV STARTED AT DOSE NO. IDOSE WAS NEVER ENDED
C  IN THE WORKING COPY FILE, AND A TIME RESET (A DOSE TIME OF 0) WAS
C  NEVER ENCOUNTERED. THIS MEANS THE IV MUST BE SHOWN TO CONTINUE
C  UNTIL TIMOBSMAX (SEE ABOVE). 

C  ALSO NOTE THAT THIS IS THE END OF POSSIBLE IVs FOR THIS DRUG SINCE
C  THE IV THAT WAS STARTED AT IDOSE WAS NEVER TURNED OFF. SO SET
C  IIDOSE = ND + 1 SO THAT BELOW WHEN IDOSE = IIDOSE - 1, IDOSE WILL
C  = ND, WHICH MEANS AFTER THE TRANSFER BACK TO LABEL 40, IDOSE WILL
C  THEN BE SET = ND+1 --> END OF SEARCHING FOR NEW IVs FOR THIS DRUG.


            TIMIV = TIMOBSMAX - SIG(IDOSE)
            TOTIV = TIMIV*RS(IDOSE,2*JDRUG-1)
            IIDOSE = ND + 1


   30      NOIV(JDRUG) = NOIV(JDRUG) + 1
           AMTIV(JDRUG,NOIV(JDRUG)) = TOTIV 

           DURIV(JDRUG,NOIV(JDRUG)) = TIMIV
           IVDOSE(JDRUG,NOIV(JDRUG)) = IDOSE

C  THE ABOVE ARRAYS SHOW THAT FOR DRUG NO. JDRUG, IV NO. NOIV(JDRUG)
C  STARTED AT DOSE NO. IDOSE, LASTED FOR DURIV(JDRUG,NOIV(JDRUG)), AND
C  HAD A TOTAL AMOUNT OF AMTIV(JDRUG,NOIV(JDRUG)). FOR EXAMPLE, IF FOR
C  DRUG 4, THE 3RD IV STARTS AT DOSE NO. 7, THEN IVDOSE(4,3) = 7.

C  SET IDOSE TO IIDOSE - 1, SO THAT AFTER TRANSFER BACK TO 
C  LABEL 40, THE NEXT IDOSE TO BE CONSIDERED WILL BE THE CURRENT



C  IIDOSE (I.E., THE NEXT IV COULD BE STARTING WITH THE DOSE WHICH
C  ENDED THE CURRENT IV).

           IDOSE = IIDOSE - 1
           GO TO 40     
            
          ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(ISAME .EQ. 0)  CONDITION.

C  TO GET HERE MEANS THAT THE CURRENT IV IS 0, SO CONTINUE LOOKING
C  FOR THE START OF THE NEXT IV.

         GO TO 40

   60    CONTINUE

        END DO


C  THE ABOVE END DO IS FOR THE  DO JDRUG = 1,NDRUG  LOOP.


C  ESTABLISH TWO STRINGS WHICH WILL WE NEEDED IN WRITING TO FILE 25.
C  DOSESTRING CONSISTS OF THE COMMAS AND DOTS WHICH REPRESENT MISSING
C  OUTPUT AND ASSAY COEFFCIENT INFO FOR EACH DOSE LINE.
C  OBSSTRING CONSISTS OF THE COMMAS AND DOTS WHICH REPRESENT MISSING
C  COVARIATE VALUES FOR EACH DOSE LINE. 

        DOSESTRING = ',.,.,.,.,.,.'
       

C  ESTABLISH OBSSTRING TO CONTAIN NCOVA SETS OF ',.', AND ILASTOBS TO
C  BE THE NO. OF CHARACTERS IN OBSSTRING (NOT COUNTING BLANKS).

        DO I = 1,52
         OBSSTRING(I:I) = ' '
        END DO

        IF(NCOVA .GE. 1) THEN
         OBSSTRING(1:2) = ',.'
         ILASTOBS = 2
        ENDIF

        IF(NCOVA .GT. 1) THEN

         DO ICOVA = 2,NCOVA

          DO I = 52,1,-1
           IF(OBSSTRING(I:I) .NE. ' ') GO TO 65 
          END DO


   65     ILAST = I


          OBSSTRING = OBSSTRING(1:ILAST)//',.'

         END DO

         ILASTOBS = ILAST + 2

        ENDIF


C  GO THROUGH ALL THE ND DOSE EVENTS AND THE M OBSERVATION LINES AT THE
C  SAME TIME, AND PUT LINES INTO FILE 25 IN THE PROPER ORDER FOR THIS
C  SUBJECT. 
        
        IDOSE = 1
        IOBS = 1

  100   CONTINUE

C  IF IOBS > M, THERE ARE NO MORE OBSERVATION ROWS TO WRITE TO FILE 25.
C  IF IDOSE > ND, THERE ARE NO MORE DOSE EVENT ROWS TO WRITE TO FILE 25.

        IF(IOBS .GT. M .AND. IDOSE .GT. ND) RETURN

C  IF IOBS > M, ALL THAT IS LEFT ARE DOSE EVENTS.
C  IF IDOSE > ND, ALL THAT IS LEFT ARE OBSERVATION ROWS.

        IF(IOBS .GT. M) GO TO 10
        IF(IDOSE .GT. ND) GO TO 20


C  TO GET HERE MEANS THERE ARE BOTH DOSE EVENTS AND OBSERVATION ROWS

C  TO BE WRITTEN. WRITE THE NEXT DOSE IF IT OCCURS BEFORE THE NEXT
C  OBSERVATION TIME. OTHERWISE, WRITE THE NEXT OBSERVATION ROW.
C  ... BUT CHECK FIRST TO SEE IF EITHER THE DOSE TIME OR THE OBSERVATION
C  TIME REPRESENTS A TIME RESET.  


C  IF THIS IS A DOSE TIME RESET, BUT NOT AN OBSERVATION TIME RESET,
C  THEN THE OBSERVATION GOES FIRST. AND VICE-VERSA.

C  THIS IS A DOSE TIME RESET IF SIG(IDOSE) = 0 AND IDOSE > 1.

        IDOSERESET = 0
        CALL THESAME(SIG(IDOSE),0.D0,ISAME)
        IF(ISAME .EQ. 1 .AND. IDOSE .GT. 1) IDOSERESET = 1
        IF(SIG(IDOSE) .LT. 0.D0 .AND. IDOSE .GT. 1) IDOSERESET = 1

C  AS OF MONT101F.FOR, MUST ALLOW FOR THE POSSIBILITY THAT A DOSE RESET
C  OCCURS WITH A STEADY STATE DOSE SET (I.E., SIG(.) < 0) ABOVE.

        IOBSRESET = 0
        CALL THESAME(TIM(IOBS),0.D0,ISAME)
        IF(ISAME .EQ. 1 .AND. IOBS .GT. 1) IOBSRESET = 1   

        IF(IDOSERESET .EQ. 1 .AND. IOBSRESET .EQ. 1) THEN

C  THIS IS BOTH A DOSE AND AN OBSERVATION TIME RESET. IN THIS CASE,
C  GO TO 20 TO WRITE OBSERVATIONS, IF ANY ARE NOT EQUAL TO -99 FOR THIS
C  OBSERVATION TIME, AND THEN IMMEDIATELY GO TO 10 TO WRITE THE DOSE 
C  INFO. AT THIS TIME RESET. SET IDOSENEXT = 1 IN THIS CASE SO THE 
C  PROGRAM WILL KNOW TO GO DIRECTLY TO 10 AFTER DOING THE CODE AT 20,
C  WITHOUT GOING BACK TO 100 FIRST. NOTE THAT AT THE BOTTOM OF THE
C  DOSE CODE STARTING AT 10, IDOSENEXT IS RESET BACK TO 0.

         IDOSENEXT = 1
         GO TO 20

        ENDIF

        IF(IDOSERESET .EQ. 1 .AND. IOBSRESET .EQ. 0) GO TO 20
        IF(IDOSERESET .EQ. 0 .AND. IOBSRESET .EQ. 1) GO TO 10

        IF(SIG(IDOSE) .GE. TIM(IOBS)) GO TO 20


C  THE NEXT LINES TO BE WRITTEN TO FILE 25 ARE DOSE LINES.


   10    CONTINUE

C  IF THIS IS NOT A TIME RESET, THE EVENT ID IS 1; IF IT IS A TIME 
C  RESET, THE EVENT ID IS 4. IT IS A TIME RESET IF SIG(IDOSE) = .LE. 0
C  AND IDOSE > 1.

        IDEVENT = 1
        CALL THESAME(SIG(IDOSE),0.D0,ISAME)
        IF(ISAME .EQ. 1 .AND. IDOSE .GT. 1) IDEVENT = 4
        IF(SIG(IDOSE) .LT. 0.D0 .AND. IDOSE .GT. 1) IDEVENT = 4

C  AS OF MONT101F.FOR, MUST ALLOW FOR THE POSSIBILITY THAT A DOSE RESET
C  OCCURS WITH A STEADY STATE DOSE SET (I.E., SIG(.) < 0) ABOVE.   

C  AS OF MONT101F.FOR, MUST CHECK EACH DOSE TIME TO SEE IF IT IS < 0.
C  IF IT IS, THE LINE REPRESENTS A STEADY STATE DOSE SET. IN THIS CASE,
C  CALL WRITESTEADY TO WRITE THE STEADY STATE DOSE INFO TO FILE 29 IN
C  A SPECIAL WAY.


        IF(SIG(IDOSE) .LT. 0.D0) THEN
         CALL WRITESTEADY(NCOVA,NDRUG,IDOSE,SIG,RS,BS,DOSESTRING,
     1    SUBID,IDEVENT)
         IDOSE = IDOSE + 1
         IDOSENEXT = 0
         GO TO 100
        ENDIF

C  IF IDEVENT = 4 (I.E., THIS IS A DOSE TIME RESET),  ONLY THE FIRST
C  ROW RELATED TO THIS EVENT SHOULD HAVE AN IDEVENT OF 4; SUBSEQUENT
C  ROWS MUST SHOW IDEVENT = 1. FOR EXAMPLE, IF A DOSE TIME RESET OCCURS
C  WITH BOTH AN IV AND A BOLUS FOR A DRUG, OR AN IV FOR ONE DRUG AND
C  A BOLUS FOR ANOTHER, ONLY THE 1ST ROW SHOULD SHOW AN IDEVENT OF 4;
C  OTHERWISE, THE PROGRAM WILL THINK THAT THE 2ND ROW IS ANOTHER DOSE
C  TIME RESET AFTER THE ONE IN THE 1ST ROW.  

C  THE TIME OF THIS DOSE IS SIG(IDOSE). FOR EACH DRUG, DETERMINE IF
C  THIS TIME REPRESENTS THE TIME OF A NON-0 BOLUS AND/OR THE START OF
C  AN IV. 

C  INITIALIZE IDOSWRITE TO 0. IF IT REMAINS 0 AFTER THE

C  DO JDRUG = 1,NDRUG LOOP, IT MEANS THAT THIS DOSE EVENT HAS NEITHER
C  A BOLUS VALUE OR A STARTING IV FOR ANY OF THE DRUGS. IN THIS CASE,
C  A LINE WILL BE WRITTEN TO FILE 25 WITH THE COVARIATE VALUES IN 
C  THIS LINE. IF IT CHANGES TO 1, THERE IS NO NEED TO WRITE ANOTHER
C  LINE WITH THE COVARIATE VALUES FOR THIS LINE SINCE THEY HAVE ALREADY
C  BEEN INCLUDED IN AT LEAST ONE LINE ALREADY WRITTEN.

         IDOSWRITE = 0


         DO JDRUG = 1,NDRUG

C  CHECK TO SEE IF BOLUS(IDOSE,JDRUG) IS THE SAME AS 0.0. IF NOT,
C  THIS TIME HAS A BOLUS VALUE FOR THIS DRUG. IN THAT CASE, PUT IN
C  A LINE TO FILE 25 FOR THIS VALUE.

          CALL THESAME(BS(IDOSE,JDRUG),0.D0,ISAME)



          IF(ISAME .EQ. 0) THEN

           OPEN(37)

C  REPLACE WRITING OF SIG(),BS(),RS() WITH XVERIFY (SEE LOGIC IN 
C  SUBROUTINE VERIFYVAL).

           IF(NCOVA .GT. 0) THEN
            XVERIFY(1) = SIG(IDOSE)
            XVERIFY(2) = BS(IDOSE,JDRUG)
            DO K = 1,NCOVA
             XVERIFY(2+K) = RS(IDOSE,2*NDRUG+K)
            END DO
            CALL VERIFYVAL(2+NCOVA,XVERIFY)
C           WRITE(37,13) SUBID,IDEVENT,SIG(IDOSE),
C    1      BS(IDOSE,JDRUG),JDRUG,DOSESTRING,
C    2      (RS(IDOSE,2*NDRUG+K),K=1,NCOVA)
            WRITE(37,13) SUBID,IDEVENT,XVERIFY(1),XVERIFY(2),
     1      JDRUG,DOSESTRING,(XVERIFY(2+K),K=1,NCOVA)
           ENDIF

   13      FORMAT(A11,',',I1,',',G14.7,',0,',G14.7,',.,.,',I1,A12,
     1      26(',',G14.7))


           IF(NCOVA .EQ. 0) THEN
            XVERIFY(1) = SIG(IDOSE)
            XVERIFY(2) = BS(IDOSE,JDRUG)     
            CALL VERIFYVAL(2,XVERIFY)
C           WRITE(37,14) SUBID,IDEVENT,SIG(IDOSE),
C    1      BS(IDOSE,JDRUG),JDRUG,DOSESTRING
            WRITE(37,14) SUBID,IDEVENT,XVERIFY(1),XVERIFY(2),
     1      JDRUG,DOSESTRING   
           ENDIF

   14      FORMAT(A11,',',I1,',',G14.7,',0,',G14.7,',.,.,',I1,A12)

           BACKSPACE(37)
           READ(37,12) BIGLINE
           CLOSE(37)
           CALL REDUCE(BIGLINE,SMALLLINE)
           CALL CONDENSE(SMALLLINE)
           IDOSWRITE = 1
           IDEVENT = 1
C  EVEN IF IDEVENT = 4, IT SHOULD BE CHANGED AFTER THE ABOVE WRITING,
C  SINCE EACH DOSE RESET ROW SHOULD HAVE JUST ONE IDEVENT = 4 ROW
C  IN THE .CSV FILE; ALL SUBSEQUENT ROWS FOR THIS EVENT SHOULD SHOW

C  IDEVENT = 1. 
           

          ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(ISAME .EQ. 0)  CONDITION.


C  CHECK TO SEE IF DRUG JDRUG HAS AN IV WHICH STARTS AT DOSE NO. IDOSE.
C  IF SO, PUT IN A LINE TO FILE 25 FOR THIS VALUE.

          IF(NOIV(JDRUG) .GE. 1) THEN

           DO IN = 1,NOIV(JDRUG)

            IF(IVDOSE(JDRUG,IN) .EQ. IDOSE) THEN

             OPEN(37)

C  REPLACE WRITING OF SIG(),DURIV(),AMTIV(),RS() WITH XVERIFY 
C  (SEE LOGIC IN SUBROUTINE VERIFYVAL).

           IF(NCOVA .GT. 0) THEN
            XVERIFY(1) = SIG(IDOSE)
            XVERIFY(2) = DURIV(JDRUG,IN) 
            XVERIFY(3) = AMTIV(JDRUG,IN)
            DO K = 1,NCOVA
             XVERIFY(3+K) = RS(IDOSE,2*NDRUG+K)
            END DO
            CALL VERIFYVAL(3+NCOVA,XVERIFY)
C           WRITE(37,16) SUBID,IDEVENT,SIG(IDOSE),
C    1      DURIV(JDRUG,IN),AMTIV(JDRUG,IN),JDRUG,
C    2      DOSESTRING,(RS(IDOSE,2*NDRUG+K),K=1,NCOVA)
            WRITE(37,16) SUBID,IDEVENT,(XVERIFY(IXV),IXV=1,3),
     1      JDRUG,DOSESTRING,(XVERIFY(3+K),K=1,NCOVA)
           ENDIF

   16      FORMAT(A11,',',I1,',',G14.7,',',G14.7,',',G14.7,',.,.,',I1,
     1      A12,26(',',G14.7))



           IF(NCOVA .EQ. 0) THEN
            XVERIFY(1) = SIG(IDOSE)
            XVERIFY(2) = DURIV(JDRUG,IN) 
            XVERIFY(3) = AMTIV(JDRUG,IN)
            CALL VERIFYVAL(3,XVERIFY)
C           WRITE(37,17) SUBID,IDEVENT,SIG(IDOSE),
C    1       DURIV(JDRUG,IN),AMTIV(JDRUG,IN),JDRUG,
C    2       DOSESTRING
            WRITE(37,17) SUBID,IDEVENT,(XVERIFY(IXV),IXV=1,3),
     1       JDRUG,DOSESTRING 
           ENDIF

   17      FORMAT(A11,',',I1,',',G14.7,',',G14.7,',',G14.7,',.,.,',I1,
     1      A12)

             BACKSPACE(37)
             READ(37,12) BIGLINE
             CLOSE(37)
             CALL REDUCE(BIGLINE,SMALLLINE)
             CALL CONDENSE(SMALLLINE)

             IDOSWRITE = 1
             IDEVENT = 1
C  EVEN IF IDEVENT = 4, IT SHOULD BE CHANGED AFTER THE ABOVE WRITING,
C  SINCE EACH DOSE RESET ROW SHOULD HAVE JUST ONE IDEVENT = 4 ROW

C  IN THE .CSV FILE; ALL SUBSEQUENT ROWS FOR THIS EVENT SHOULD SHOW
C  IDEVENT = 1. 

             GO TO 70

            ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(IVDOSE(JDRUG,IN) .EQ. IDOSE)  
C  CONDITION.  

           END DO

C  THE ABOVE END DO IS FOR THE  DO IN = 1,NOIV(DRUG)  LOOP.


          ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(NOIV(JDRUG) .GE. 1)  CONDITION.

   70     CONTINUE

         END DO

C  THE ABOVE END DO IS FOR THE  DO JDRUG = 1,NDRUG  LOOP.



C  IF IDOSWRITE = 0, MUST PUT IN A LINE TO ESTABLISH THE COVARIATE
C  VALUES (SEE ABOVE).

         IF(IDOSWRITE .EQ. 0) THEN

          OPEN(37)


C  REPLACE WRITING OF SIG(),RS() WITH XVERIFY (SEE LOGIC IN 
C  SUBROUTINE VERIFYVAL).

          IF(NCOVA .GT. 0) THEN
           XVERIFY(1) = SIG(IDOSE)
            DO K = 1,NCOVA
             XVERIFY(1+K) = RS(IDOSE,2*NDRUG+K)
            END DO
            CALL VERIFYVAL(1+NCOVA,XVERIFY)
C          WRITE(37,18) SUBID,IDEVENT,SIG(IDOSE),
C    1     DOSESTRING,(RS(IDOSE,2*NDRUG+K),K=1,NCOVA)
           WRITE(37,18) SUBID,IDEVENT,XVERIFY(1),
     1     DOSESTRING,(XVERIFY(1+K),K=1,NCOVA)
          ENDIF

   18     FORMAT(A11,',',I1,',',G14.7,',0,0,.,.,1',A12,26(',',G14.7))

C  REPLACE WRITING OF SIG() WITH XVERIFY (SEE LOGIC IN 
C  SUBROUTINE VERIFYVAL).

          IF(NCOVA .EQ. 0) THEN
           XVERIFY(1) = SIG(IDOSE)
            CALL VERIFYVAL(1,XVERIFY)
C           WRITE(37,19) SUBID,IDEVENT,SIG(IDOSE),DOSESTRING 
            WRITE(37,19) SUBID,IDEVENT,XVERIFY(1),DOSESTRING
          ENDIF
 
   19     FORMAT(A11,',',I1,',',G14.7,',0,0,.,.,1',A12)

  
          BACKSPACE(37)
          READ(37,12) BIGLINE
          CLOSE(37)
          CALL REDUCE(BIGLINE,SMALLLINE)
          CALL CONDENSE(SMALLLINE)

         ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(IDOSWRITE .EQ. 0)  CONDITION.
 

         IDOSE = IDOSE + 1


C  SET IDOSENEXT TO 0. SEE LOGIC BELOW LABEL 20.

         IDOSENEXT = 0


         GO TO 100


C  TO GET TO 20 MEANS THAT OBSERVATION ROWS WILL BE WRITTEN.

   20   CONTINUE

C  THE NEXT LINES TO BE WRITTEN TO FILE 29 ARE OBSERVATION LINES, ONE
C  FOR EACH OUTPUT EQUATION WHICH HAS A NON-MISSING OBSERVATION AT THE

C  CURRENT TIME, TIM(IOBS).


C  ALSO NOTE THAT THE ASSAY COEFFICIENTS WILL BE WRITTEN TO EACH LINE.

         DO IEQ = 1,NUMEQT

C  CHECK TO SEE IF OBSERVATION IOBS FOR OUTPUT EQ. IEQ IS -99. IF NOT,
C  WRITE A LINE INTO FILE 25 FOR THIS VALUE. IN THIS CASE, WRITE THE
C  INFO TO SCRATCH FILE 37, READ THIS LINE AS A CHARACTER CONSTANT,
C  CALL REDUCE TO REMOVE THE SPACES IN THIS CHARACTER CONSTANT, AND THEN
C  CALL CONDENSE TO WRITE THIS REDUCED CONSTANT TO FILE 25 WITH AS 
C  SMALL A FORMAT AS POSSIBLE (WITHIN 25 CHARACTERS).

          CALL THESAME(YO(IOBS,IEQ),-99.D0,ISAME)

          IF(ISAME .EQ. 0) THEN
           OPEN(37)

C  REPLACE WRITING OF TIM(),..., C3()  WITH XVERIFY (SEE LOGIC IN 
C  SUBROUTINE VERIFYVAL).

           IF(NCOVA .GT. 0) THEN
            XVERIFY(1) = TIM(IOBS)
            XVERIFY(2) = YO(IOBS,IEQ)
            XVERIFY(3) = C0(IEQ)
            XVERIFY(4) = C1(IEQ)
            XVERIFY(5) = C2(IEQ)
            XVERIFY(6) = C3(IEQ)
            CALL VERIFYVAL(6,XVERIFY)
C           WRITE(37,11)SUBID,TIM(IOBS),YO(IOBS,IEQ),
C    1       IEQ,C0(IEQ),C1(IEQ),C2(IEQ),C3(IEQ),OBSSTRING(1:ILASTOBS)
            WRITE(37,11)SUBID,XVERIFY(1),XVERIFY(2),IEQ,
     1      (XVERIFY(K),K=3,6),OBSSTRING(1:ILASTOBS)
           ENDIF

   11       FORMAT(A11,',0,',G14.7,',.,.,.,.,.,',G14.7,',',I1,',',
     1       G14.7,',',G14.7,',',G14.7,',',G14.7,A)

           IF(NCOVA .EQ. 0) THEN
            XVERIFY(1) = TIM(IOBS)
            XVERIFY(2) = YO(IOBS,IEQ)
            XVERIFY(3) = C0(IEQ)
            XVERIFY(4) = C1(IEQ)
            XVERIFY(5) = C2(IEQ)
            XVERIFY(6) = C3(IEQ)
            CALL VERIFYVAL(6,XVERIFY)
C           WRITE(37,111)SUBID,TIM(IOBS),YO(IOBS,IEQ),
C    1       IEQ,C0(IEQ),C1(IEQ),C2(IEQ),C3(IEQ)
            WRITE(37,111)SUBID,XVERIFY(1),XVERIFY(2),IEQ,
     1      (XVERIFY(K),K=3,6)
           ENDIF

  111      FORMAT(A11,',0,',G14.7,',.,.,.,.,.,',G14.7,',',I1,',',
     1      G14.7,',',G14.7,',',G14.7,',',G14.7)

           BACKSPACE(37)
           READ(37,12) BIGLINE
   12      FORMAT(A1000)

           CLOSE(37)
           CALL REDUCE(BIGLINE,SMALLLINE)
           CALL CONDENSE(SMALLLINE)

          ENDIF

         END DO

C  THE ABOVE END DO IS FOR THE  DO IEQ = 1,NUMEQT  LOOP.

         IOBS = IOBS + 1

         IF(IDOSENEXT .EQ. 1) GO TO 10
C  NOTE THAT IF IDOSENEXT = 1, IT MEANS THAT THE CURRENT TIME
C  REPRESENTS BOTH AN OBSERVATION AND A DOSE TIME RESET. SINCE THE
C  CODE TO WRITE THE INFO FOR THE OBSERVATION HAS NOW BEEN COMPLETED,
C  CONTROL SHIFTS IMMEDIATELY TO LABEL 10 WHERE THE DOSE INFO WILL NEXT
C  BE WRITTEN.

         GO TO 100


        END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
        SUBROUTINE REDUCE(BIGLINE,SMALLLINE)
        CHARACTER BIGLINE*1000,SMALLLINE*1000

C  THIS ROUTINE, CALLED BY WRITECSV, INPUTS BIGLINE, AND OUTPUTS
C  SMALLLINE WHICH HAS ALL THE NON-BLANK CHARACTERS OF BIGLINE
C  (EXCEPT THAT THE FIRST 11 CHARACTERS, WHICH CONSTITUTE THE
C  PATIENT NAME) CAN HAVE BLANKS.

C  FIRST BLANK OUT ALL OF SMALLLINE, IN CASE IT HAS SOME "JUNK" IN 
C  SOME OF ITS ENTRIES.

        DO I = 1,1000
         SMALLLINE(I:I) = ' '
        END DO
 
        SMALLLINE(1:11) = BIGLINE(1:11)

        IENTRY = 11

        DO I = 12,1000
         IF(BIGLINE(I:I) .NE. ' ') THEN
          IENTRY = IENTRY + 1
          SMALLLINE(IENTRY:IENTRY) = BIGLINE(I:I)
         ENDIF
        END DO


C  BECAUSE OF THE FORMAT USED TO WRITE DOSES TO FILE 37 IN MAIN, IT IS
C  POSSIBLE THAT THE LAST CHARACTER COULD BE A COMMA. SO CHECK THE LAST
C  ENTRY IN SMALLLINE, AND IF IT IS A COMMA, CHANGE IT TO A BLANK.

        IF(SMALLLINE(IENTRY:IENTRY) .EQ. ',') 
     1   SMALLLINE(IENTRY:IENTRY) = ' '

        RETURN
        END
C

CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
        SUBROUTINE CONDENSE(READLINE)

        CHARACTER READLINE*1000        

C  SUBROUTINE CONDENSE IS CALLED BY WRITECSV TO WRITE READLINE WITH AS 
C  SMALL A FORMAT AS POSSIBLE (WITHIN 25 CHARACTERS) TO FILE 29.
C  FOR THIS LINE, READLINE, FIND IEND, THE LAST CHARACTER WHICH IS NOT
C  BLANK. THEN ONLY CHARACTERS 1:IEND WILL BE WRITTEN TO FILE 29.

	DO IEND = 1000,1,-1
	 IF(READLINE(IEND:IEND) .NE. ' ') GO TO 20
	END DO

   20   CONTINUE



C  CANNOT USE WRITE(29,_) READLINE(1:IEND) SINCE, FOR SOME REASON,
C  WRITING LIKE THIS "RIGHT JUSTIFIES" THE CHARACTERS AT THE END
C  OF THE A1000 FORMAT. INSTEAD MUST WRITE(29,__) READLINE, WHERE
C  THE FORMAT IS DETERMINED BY THE LAST NON-BLANK CHARACTER (IEND)
C  IN READLINE.

	IF(IEND .LE. 26) THEN
	 WRITE(29,26) READLINE
   26    FORMAT(A26)
	 RETURN
	ENDIF

	IF(IEND .LE. 51) THEN
	 WRITE(29,51) READLINE
   51    FORMAT(A51)
	 RETURN
	ENDIF

	IF(IEND .LE. 76) THEN
	 WRITE(29,76) READLINE
   76    FORMAT(A76)
	 RETURN
	ENDIF

	IF(IEND .LE. 101) THEN
	 WRITE(29,101) READLINE
  101    FORMAT(A101)
	 RETURN
	ENDIF

	IF(IEND .LE. 126) THEN

	 WRITE(29,126) READLINE
  126    FORMAT(A126)
	 RETURN
	ENDIF

	IF(IEND .LE. 151) THEN
	 WRITE(29,151) READLINE
  151    FORMAT(A151)
	 RETURN
	ENDIF


	IF(IEND .LE. 176) THEN
	 WRITE(29,176) READLINE
  176    FORMAT(A176)
	 RETURN
	ENDIF

	IF(IEND .LE. 201) THEN
	 WRITE(29,201) READLINE
  201    FORMAT(A201)
	 RETURN
	ENDIF

	IF(IEND .LE. 226) THEN
	 WRITE(29,226) READLINE
  226    FORMAT(A226)
	 RETURN
	ENDIF

	IF(IEND .LE. 251) THEN
	 WRITE(29,251) READLINE
  251    FORMAT(A251)

	 RETURN
	ENDIF

	IF(IEND .LE. 276) THEN
	 WRITE(29,276) READLINE
  276    FORMAT(A276)
	 RETURN
	ENDIF


	IF(IEND .LE. 301) THEN
	 WRITE(29,301) READLINE
  301    FORMAT(A301)
	 RETURN
	ENDIF

	IF(IEND .LE. 326) THEN
	 WRITE(29,326) READLINE
  326    FORMAT(A326)
	 RETURN
	ENDIF

	IF(IEND .LE. 351) THEN
	 WRITE(29,351) READLINE
  351    FORMAT(A351)

	 RETURN
	ENDIF

	IF(IEND .LE. 376) THEN
	 WRITE(29,376) READLINE
  376    FORMAT(A376)
	 RETURN
	ENDIF

	IF(IEND .LE. 401) THEN
	 WRITE(29,401) READLINE
  401    FORMAT(A401)
	 RETURN
	ENDIF

	IF(IEND .LE. 426) THEN
	 WRITE(29,426) READLINE

  426    FORMAT(A426)
	 RETURN
	ENDIF

	IF(IEND .LE. 451) THEN
	 WRITE(29,451) READLINE
  451    FORMAT(A451)
	 RETURN
	ENDIF

	IF(IEND .LE. 476) THEN
	 WRITE(29,476) READLINE
  476    FORMAT(A476)
	 RETURN
	ENDIF

	IF(IEND .LE. 501) THEN

	 WRITE(29,501) READLINE


  501    FORMAT(A501)
	 RETURN
	ENDIF

	IF(IEND .LE. 526) THEN
	 WRITE(29,526) READLINE
  526    FORMAT(A526)
	 RETURN
	ENDIF

	IF(IEND .LE. 551) THEN
	 WRITE(29,551) READLINE
  551    FORMAT(A551)
	 RETURN
	ENDIF

	IF(IEND .LE. 576) THEN



	 WRITE(29,576) READLINE
  576    FORMAT(A576)
	 RETURN
	ENDIF

	IF(IEND .LE. 601) THEN
	 WRITE(29,601) READLINE
  601    FORMAT(A601)
	 RETURN
	ENDIF

	IF(IEND .LE. 626) THEN
	 WRITE(29,626) READLINE
  626    FORMAT(A626)
	 RETURN
	ENDIF

	IF(IEND .LE. 651) THEN
	 WRITE(29,651) READLINE
  651    FORMAT(A651)
	 RETURN
	ENDIF

	IF(IEND .LE. 676) THEN
	 WRITE(29,676) READLINE
  676    FORMAT(A676)
	 RETURN
	ENDIF

	IF(IEND .LE. 701) THEN
	 WRITE(29,701) READLINE
  701    FORMAT(A701)
	 RETURN
	ENDIF

	IF(IEND .LE. 726) THEN
	 WRITE(29,726) READLINE
  726    FORMAT(A726)
	 RETURN
	ENDIF

	IF(IEND .LE. 751) THEN
	 WRITE(29,751) READLINE

  751    FORMAT(A751)
	 RETURN
	ENDIF



	IF(IEND .LE. 776) THEN
	 WRITE(29,776) READLINE
  776    FORMAT(A776)
	 RETURN
	ENDIF

	IF(IEND .LE. 801) THEN

	 WRITE(29,801) READLINE
  801    FORMAT(A801)
	 RETURN
	ENDIF

	IF(IEND .LE. 826) THEN
	 WRITE(29,826) READLINE
  826    FORMAT(A826)
	 RETURN
	ENDIF


	IF(IEND .LE. 851) THEN
	 WRITE(29,851) READLINE
  851    FORMAT(A851)
	 RETURN
	ENDIF

	IF(IEND .LE. 876) THEN
	 WRITE(29,876) READLINE
  876    FORMAT(A876)
	 RETURN
	ENDIF

	IF(IEND .LE. 901) THEN
	 WRITE(29,901) READLINE
  901    FORMAT(A901)
	 RETURN
	ENDIF

	IF(IEND .LE. 926) THEN
	 WRITE(29,926) READLINE
  926    FORMAT(A926)
	 RETURN
	ENDIF

	IF(IEND .LE. 951) THEN
	 WRITE(29,951) READLINE
  951    FORMAT(A951)
	 RETURN
	ENDIF

	IF(IEND .LE. 976) THEN
	 WRITE(29,976) READLINE
  976    FORMAT(A976)
	 RETURN
	ENDIF

	WRITE(29,4) READLINE
    4    FORMAT(A1000)

        RETURN

        END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
        SUBROUTINE COVSTRING(NCOVA,DESCR,COVTIGHT,NCOVTIGHT)


        CHARACTER DESCR(26)*20,COVTIGHT*550,BIGLINE*1000

C  THIS SUBROUTINE IS CALLED BY MAIN TO PLACE INTO COVTIGHT THE
C  LIST OF NCOVA COVARIATE NAMES, EACH SEPARATED BY A COMMA.
C  NCOVTIGHT RETURNS AS THE NO. OF CHARACTERS IN COVTIGHT.
        
        DO I = 1,1000
         BIGLINE(I:I) = ' '
        END DO


        BIGLINE(1:21) = ','//DESCR(1)

        IF(NCOVA .GT. 1) THEN

        DO I = 2,NCOVA

C  CALL CALCSTART TO DETERMINE THE LAST USED CHARACTER IN BIGLINE.

         CALL CALCSTART(BIGLINE,ILAST)
         BIGLINE = BIGLINE(1:ILAST)//','//DESCR(I)

        END DO

        ENDIF

C  BUG FIX AS OF MONT111.FOR (SEE COMMENTS AT THE TOP OF THIS 
C  PROGRAM TO SEE WHAT GOES WRONG IF ILAST IS NOT ESTABLISHED IN
C  THE CASE OF NCOVA = 1).

C  IN CASE NCOVA = 1, ILAST WAS NOT ESTABLISHED ABOVE. IN THIS
C  CASE, SET ILAST = 1 SINCE THE MOST ENTRIES FOR THE SINGLE COVARIATE
C  AND THE FIRST COMMA IS 1 + 20.
C  IS 20.

        IF(NCOVA .EQ. 1) ILAST = 1


C  THE NO. OF ENTRIES IN BIGLINE IS ILAST + 20 (SINCE THE LAST
C  COVARIATE, DESCR(NCOVA), HAS AT MOST 20 ENTRIES).

        NCOVTIGHT = ILAST + 20
        COVTIGHT = BIGLINE(1:NCOVTIGHT)

        RETURN 
        END               
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
        SUBROUTINE CALCSTART(BIGLINE,ILAST)
        CHARACTER BIGLINE*1000

        DO I = 1000,1,-1

         IF(BIGLINE(I:I) .NE. ' ') GO TO 10
        END DO

        ILAST = 0
        RETURN

   10   ILAST = I

        RETURN
        END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
      SUBROUTINE CONVERTCSV
      IMPLICIT REAL*8(A-H,O-Z)

      CHARACTER READLINE*1000,ERRFIL*20



      COMMON/ERROR/ERRFIL
C  COMMON/ERROR/ IS SUPPLIED TO ALL THE ROUTINES WHICH COULD WRITE TO
C  ERRFIL.

C  SUBROUTINE CONVERTCSV READS FILE 87 AND WRITES SCRATCH FILE 77.
C  IF FILE 87 IS ALREADY IN THE TYPICAL "AMERICAN" .CSV FORMAT, 
C  FILE 77 IS THE SAME AS FILE 87. 

C  IF FILE 87 IS IN THE "EUROPEAN" .CSV FORMAT, WHERE SEMICOLONS
C  ARE THE FIELD SEPARATORS, AND COMMAS ARE USED TO SEPARATE THE
C  WHOLE AND FRACTIONAL PARTS OF NUMBERS, IT WILL BE WRITTEN TO
C  FILE 77 WITH THE INDICATED CHANGES BELOW.


C  FILE 87 IS AT LINE 1. READ PAST THIS LINE TO READ LINE 2 AND CHECK
C  FOR A SEMICOLON. IF ONE IS FOUND, THEN THIS IS A "EUROPEAN" VERSION OF
C  A .CSV FILE. NOTE THAT IT IS ONLY NECESSARY TO CHECK THE FIRST FEW
C  CHARACTERS OF THIS LINE - EITHER THERE WILL BE COMMAS OR SEMICOLONS.
C  IF THERE ARE BOTH COMMAS AND SEMICOLONS, SOMETHING IS WRONG WITH THE
C  FILE; IN THIS CASE, PRINT A MESSAGE TO THE USER AND STOP.
C  NOTE THAT, EVEN IN THE "EURO" VERSION, IT WILL STILL BE ASSUMED THAT
C  A DOT REPRESENTS AN UNNEEDED VALUE.

        READ(87,*)
        READ(87,4) READLINE

        ICOMMA = 0
        ISEMICOLON = 0

        DO I = 1,20
         IF(READLINE(I:I) .EQ. ',') ICOMMA = 1
         IF(READLINE(I:I) .EQ. ';') ISEMICOLON = 1
        END DO

C  IF ICOMMA = 1 AND ISEMICOLON = 0, NO CONVERSION IS NEEDED AS THIS
C  FILE IS A TYPICAL .CSV FILE. IN THIS CASE SET ICONVERT = 0.

C  IF ICOMMA = 0 AND ISEMICOLON = 1, CONVERT THIS FILE AS FOLLOWS:
C  a. CHANGE ALL COMMAS TO PERIODS; THEN
C  b. CHANGE ALL SEMICOLONS TO COMMAS.
C  IN THIS CASE, SET ICONVERT = 1.

C  IF ICOMMA = 1 AND ISEMICOLON = 1, STOP THE PROGRAM WITH A MESSAGE TO
C  THE USER.

        IF(ICOMMA .EQ. 1 .AND. ISEMICOLON .EQ. 1) THEN



         WRITE(*,121)
  121    FORMAT(/' YOUR .CSV FILE HAS BOTH COMMAS AND SEMICOLONS IN '/
     1' THE SECOND LINE. THIS IS A CONFLICT. IF YOU ARE USING THE '/
     2' "EUROPEAN" VERSION OF A .CSV FILE, WITH SEMICOLONS AS FIELD'/
     3' SEPARATORS AND COMMAS TO SEPARATE THE WHOLE AND FRACTIONAL'/
     4' PARTS OF NUMBERS, THERE SHOULD BE NO COMMAS IN THE SECOND'/
     5' LINE.'//
     6' SIMILARLY IF YOU ARE USING THE "AMERICAN" VERSION OF A .CSV'/
     7' FILE, WITH COMMAS AS FIELD SEPARATORS, AND PERIODS TO SEPARTE'/
     8' THE WHOLE AND FRACTIONAL PARTS OF NUMBERS, THERE SHOULD BE NO'/
     9' SEMICOLONS IN THE SECOND LINE.'//
     1' PLEASE CORRECT YOUR .CSV FILE AND RERUN THE PROGRAM.'//)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,121) 
        CLOSE(42)	



         CALL PAUSE
         STOP



        ENDIF


        IF(ICOMMA .EQ. 1 .AND. ISEMICOLON .EQ. 0) ICONVERT = 0
        IF(ICOMMA .EQ. 0 .AND. ISEMICOLON .EQ. 1) ICONVERT = 1      

        REWIND(87)
        OPEN(77)


C  COPY FILE 87 TO FILE 77 BUT MAKE THE INDICATED CHANGES, IF
C  ICONVERT = 1, LINE BY LINE.

   10   READ(87,4,IOSTAT=IEND) READLINE
    4   FORMAT(A1000)
        IF(IEND .LT. 0) GO TO 100

C  FOR THIS LINE, READLINE, FIND IENDL, THE LAST CHARACTER WHICH IS NOT
C  BLANK. THEN ONLY CHARACTERS 1:IENDL WILL BE WRITTEN TO FILEOUT.

        DO IENDL = 1000,1,-1
         IF(READLINE(IENDL:IENDL) .NE. ' ') GO TO 20
        END DO

   20   CONTINUE

        DO I = 1,IENDL
         IF(ICONVERT .EQ. 1) THEN
          IF(READLINE(I:I) .EQ. ',') READLINE(I:I) = '.'
          IF(READLINE(I:I) .EQ. ';') READLINE(I:I) = ','
         ENDIF
        END DO


C  CANNOT USE WRITE(77,4) READLINE(1:IENDL) SINCE, FOR SOME REASON,
C  WRITING LIKE THIS "RIGHT JUSTIFIES" THE CHARACTERS AT THE END
C  OF THE A1000 FORMAT. INSTEAD MUST WRITE (77,__) READLINE, WHERE
C  THE FORMAT IS DETERMINED BY THE LAST NON-BLANK CHARACTER (IENDL)
C  IN READLINE.

	IF(IENDL .LE. 26) THEN
	 WRITE(77,26) READLINE
   26    FORMAT(A26)
	 GO TO 10
	ENDIF


	IF(IENDL .LE. 51) THEN
	 WRITE(77,51) READLINE
   51    FORMAT(A51)
	 GO TO 10
	ENDIF


	IF(IENDL .LE. 76) THEN
	 WRITE(77,76) READLINE
   76    FORMAT(A76)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 101) THEN

	 WRITE(77,101) READLINE
  101    FORMAT(A101)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 126) THEN
	 WRITE(77,126) READLINE
  126    FORMAT(A126)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 151) THEN
	 WRITE(77,151) READLINE
  151    FORMAT(A151)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 176) THEN

	 WRITE(77,176) READLINE
  176    FORMAT(A176)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 201) THEN

	 WRITE(77,201) READLINE
  201    FORMAT(A201)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 226) THEN
	 WRITE(77,226) READLINE
  226    FORMAT(A226)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 251) THEN
	 WRITE(77,251) READLINE
  251    FORMAT(A251)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 276) THEN

	 WRITE(77,276) READLINE
  276    FORMAT(A276)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 301) THEN
	 WRITE(77,301) READLINE
  301    FORMAT(A301)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 326) THEN
	 WRITE(77,326) READLINE
  326    FORMAT(A326)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 351) THEN
	 WRITE(77,351) READLINE
  351    FORMAT(A351)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 376) THEN
	 WRITE(77,376) READLINE
  376    FORMAT(A376)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 401) THEN
	 WRITE(77,401) READLINE
  401    FORMAT(A401)
	 GO TO 10
	ENDIF


	IF(IENDL .LE. 426) THEN
	 WRITE(77,426) READLINE
  426    FORMAT(A426)
	 GO TO 10
	ENDIF


	IF(IENDL .LE. 451) THEN
	 WRITE(77,451) READLINE
  451    FORMAT(A451)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 476) THEN

	 WRITE(77,476) READLINE
  476    FORMAT(A476)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 501) THEN
	 WRITE(77,501) READLINE
  501    FORMAT(A501)
	 GO TO 10
	ENDIF


	IF(IENDL .LE. 526) THEN
	 WRITE(77,526) READLINE
  526    FORMAT(A526)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 551) THEN
	 WRITE(77,551) READLINE
  551    FORMAT(A551)
	 GO TO 10
	ENDIF


	IF(IENDL .LE. 576) THEN
	 WRITE(77,576) READLINE
  576    FORMAT(A576)
	 GO TO 10
	ENDIF


	IF(IENDL .LE. 601) THEN
	 WRITE(77,601) READLINE
  601    FORMAT(A601)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 626) THEN
	 WRITE(77,626) READLINE
  626    FORMAT(A626)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 651) THEN
	 WRITE(77,651) READLINE
  651    FORMAT(A651)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 676) THEN
	 WRITE(77,676) READLINE
  676    FORMAT(A676)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 701) THEN
	 WRITE(77,701) READLINE
  701    FORMAT(A701)
	 GO TO 10

	ENDIF


	IF(IENDL .LE. 726) THEN
	 WRITE(77,726) READLINE
  726    FORMAT(A726)
	 GO TO 10

	ENDIF


	IF(IENDL .LE. 751) THEN
	 WRITE(77,751) READLINE
  751    FORMAT(A751)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 776) THEN
	 WRITE(77,776) READLINE

  776    FORMAT(A776)
	 GO TO 10
	ENDIF



	IF(IENDL .LE. 801) THEN
	 WRITE(77,801) READLINE
  801    FORMAT(A801)
	 GO TO 10

	ENDIF

	IF(IENDL .LE. 826) THEN
	 WRITE(77,826) READLINE

  826    FORMAT(A826)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 851) THEN
	 WRITE(77,851) READLINE
  851    FORMAT(A851)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 876) THEN
	 WRITE(77,876) READLINE

  876    FORMAT(A876)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 901) THEN
	 WRITE(77,901) READLINE
  901    FORMAT(A901)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 926) THEN
	 WRITE(77,926) READLINE
  926    FORMAT(A926)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 951) THEN
	 WRITE(77,951) READLINE
  951    FORMAT(A951)
	 GO TO 10
	ENDIF


	IF(IENDL .LE. 976) THEN
	 WRITE(77,976) READLINE
  976    FORMAT(A976)
	 GO TO 10
	ENDIF

	WRITE(77,4) READLINE
	GO TO 10




  100   CLOSE(87)
        REWIND(77)


        RETURN
        END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
      SUBROUTINE CSVCHANGE

C  SUBROUTINE CSVCHANGE IS CALLED BY MAIN AND SUBROUTINE GETNUMEQ TO
C  CHANGE .csv FILES WITH CODE OF POPDATA DEC_11 (I.E., THOSE WITH 2
C  EXTRA COLUMNS FOR ADDL AND II) TO EQUIVALENT .csv FILES WITH CODE OF
C  POPDATA APR_11 (THOSE WITHOUT THE TWO EXTRA COLUMNS). IT READS
C  FILE 67, AND WRITES THE INFORMATION TO SCRATCH FILE 66. NOTE THAT IF
C  THE .csv FILE READ IN ALREADY IS THE OLDER VERSION (WITH CODE 
C  POPDATA APR_11), THIS ROUTINE SIMPLY REWRITES IT TO FILE 66, WHICH IS
C  THEN READ BY SUBROUTINE READBLOCK.

C  THIS ROUTINE IS BASED ON THE STAND-A-LONE PROGRAM, CSVCHANGE.FOR.
C  AS OF IT2B104.FOR, THIS ROUTINE IS BASED ON CSVCHANGE2.FOR.

C  CSVCHANGE.FOR                                           12/6/11

C  THIS PROGRAM CONVERTS THE NEW-STYLE .csv FILES (WITH TWO ADDITIONAL
C  COLUMNS (ADDL AND II) TO THE PREVIOUS .csv FORMAT.

C  ADDL GIVES THE NO. OF ADDITIONAL DOSES FOR ANY DOSE EVENT, AND II
C  GIVES THE INTERDOSE INTERVAL FOR THE ADDITIONAL DOSES.

C  EX: IF TIME = 0, DUR = 2, DOSE = 1000, ADDL = 2, II = 12, THIS
C  PROGRAM WOULD PUT IN TWO EXTRA LINES AS FOLLOWS:

C  TIME    DUR    DOSE  ADDL  II    
C   0       2     1000   2    12  <-- ONLY LINE IN NEW-STYLE FILE
C  12       2     1000   <-- THESE TWO LINES ARE ADDED TO THE OLD
C  24       2     1000       STYLE FILE (WHICH DOESN'T HAVE ADDL AND
C                            II COLUMNS.

C  NOTE THAT ADDL = -1 IS A STEADY STATE DOSE INDICATOR. IN THIS CASE,
C  CHANGE THE TIME OF THE DOSE TO -II, SO SUBROUTINES READBLOCK/WRITEDOS

C  WILL RECOGNIZE THE LINE AS THE BEGINNING OF A STEADY STATE DOSE SET.


C  NOTE THAT ONCE ALL THE ADDITIONAL DOSES ARE ADDED TO THE DOSE
C  ARRAY, THEY MUST ALL BE ORDERED AMONG THEMSELVES (UNTIL THE NEXT
C  DOSE/TIME RESET) SINCE READBLOCK EXPECTS ORDERED DOSES. BUT IT IS
C  OK FOR ALL THE DOSES IN A GIVEN REGION TO COME FIRST, AND THEN ALL
C  THE OBSERVATIONS TO FOLLOW (I.E., THE DOSES SHOULD BE ORDERED AMONG
C  THEMSELVES AND THE OBSERVATIONS FOLLOW THE DOSES, ORDERED AMONG
C  THEMSELVES).

C  NOTE THAT ADDL AND II ENTRIES ARE IGNORED IF EVID = 0 (I.E.,THE
C  EVENT IS AN OBSERVATION).

C  NOTE THAT IF ADDL AND II ARE MISSING FOR A DOSE EVENT (EVID = 1 OR
C  4) THEN ADDL IS ASSUME TO BE 0 (NO ADDITIONAL DOSES) AND II IS
C  IRRELEVANT.

C  NOTE THAT THIS PROGRAM WILL OPEN AND READ THE NEW-STYLE .csv
C  FILE FROM FILE 67, AND THEN WRITE THE PREVIOUS .csv FORMAT TO FILE
C  66.

      IMPLICIT REAL*8(A-H,O-Z)
      DIMENSION TIMENTRY(99999),IDENTRY(99999)

      CHARACTER READLINE*1000,CODEPAT*15,
     1 READLINE2*1000,HOLDMAT(99999)*150,TIMCHAR*50,SUBID*11,
     2 SUBIDPREV*11,ERRFIL*20



      COMMON/ERROR/ERRFIL
C  COMMON/ERROR/ IS SUPPLIED TO ALL THE ROUTINES WHICH COULD WRITE TO
C  ERRFIL.

    1 FORMAT(A1000)
    2 FORMAT(A20)

      OPEN(66)

      ICODEPAT = 0


    6 FORMAT(A15)
      ICODEPAT = -1


      READ(67,6) CODEPAT
      IF(CODEPAT .EQ. '"POPDATA DEC_11') ICODEPAT = 1
      IF(CODEPAT(1:14) .EQ. 'POPDATA DEC_11') ICODEPAT = 1

      IF(CODEPAT .EQ. '"POPDATA APR_11') ICODEPAT = 0
      IF(CODEPAT(1:14) .EQ. 'POPDATA APR_11') ICODEPAT = 0


      IF(ICODEPAT .EQ. -1) THEN



       WRITE(*,7)


    7  FORMAT(//' YOUR PATIENT DATA BLOCK FILE IS NOT FROM THE'/
     1' ALLOWABLE SET OF SUCH FILES.'//
     2' A PATIENT DATA BLOCK FILE MUST HAVE "POPDATA XXX_XX IN'/
     3' COLUMNS 1 THROUGH 15 ON LINE 1, WHERE  XXX_XX  IS APR_11 OR A '/
     4' MORE RECENT DATE.'//)
       WRITE(*,*)' THE PROGRAM STOPS.'

        OPEN(42,FILE=ERRFIL)
         WRITE(42,7) 
         WRITE(42,*)' THE PROGRAM STOPS.'
        CLOSE(42)	



       CALL PAUSE
       STOP



      ENDIF

C  IF ICODEPAT = 0, THE INPUT .csv FILE IS ALREADY IN THE CORRECT FORM
C  TO BE READ BY SUBROUTINE READBLOCK. IN THIS CASE, JUST COPY FILE 67,
C  LINE BY LINE TO FILE 66.

      IF(ICODEPAT .EQ. 0) THEN

C  WRITE THE TOP LINE (WITH THE CODE) TO FILE 66.


       CODEPAT = 'POPDATA APR_11'
       WRITE(66,6) CODEPAT

 1020  READ(67,1,IOSTAT=IEND) READLINE
        IF(IEND .LT. 0) THEN
         CLOSE(67)
         RETURN
        ENDIF
       WRITE(66,1) READLINE
       GO TO 1020

      ENDIF


C  ICODEPAT = 1. SO WRITE THE INFO IN FILE 67 TO FILE 66 IN THE OLD
C  FORMAT (WITHOUT THE TWO COLUMNS FOR ADDL AND II).

C  WRITE THE TOP LINE (WITH THE CODE) TO FILE 66.

      CODEPAT = 'POPDATA APR_11'
      WRITE(66,6) CODEPAT

C  READ THE 2ND LINE OF FILE 67 AND WRITE THIS LINE TO FILE 66, BUT
C  WITHOUT THE ADDL AND II NAMES. 

      READ(67,1) READLINE

C  SEARCH FOR THE CHARACTER STRING  ",ADDL,II"  IN THE EARLY PART OF
C  READLINE AND ELIMINATE IT, BEFORE WRITING THE LINE TO FILE 66. IF
C  THIS STRING IS NOT FOUND, TELL THE USER HIS FILE 67 HAS AN ERROR IN 
C  IT, AND STOP

      DO I = 1,50
       IF(READLINE(I:I+7) .EQ. ',ADDL,II') THEN
        ISS = I
        GO TO 10
       ENDIF
      END DO

C  TO GET HERE MEANS THE ABOVE STRING WAS NEVER FOUND. SO WRITE A 

C  MESSAGE TO THE USER AND STOP.

       WRITE(*,8)
    8  FORMAT(//' YOUR PATIENT DATA BLOCK FILE IS NOT FROM THE '/
     1' ALLOWABLE SET OF SUCH FILES.'//
     2' A PATIENT DATA BLOCK FILE MUST HAVE ",ADDL,II" AS THE 6TH AND'/
     3' 7TH COLUMN HEADINGS ON LINE 2.'//)
       WRITE(*,*)' THE PROGRAM STOPS.'

        OPEN(42,FILE=ERRFIL)
         WRITE(42,8) 
         WRITE(42,*)' THE PROGRAM STOPS.'
        CLOSE(42)



       CALL PAUSE
       STOP


   10 CONTINUE

C  PUT ALL OF READLINE, EXCEPT ENTRIES ISS:ISS+7 INTO READLINE2,
C  AND WRITE READLINE2 INTO FILE 66.

      READLINE2(1:ISS-1) = READLINE(1:ISS-1)
      READLINE2(ISS:992) = READLINE(ISS+8:1000)

      WRITE(66,1) READLINE2


C  EACH LINE IN FILE 67, STARTING WITH LINE 3 (EXCEPT FOR LINES 
C  BEGINNING WITH #) HAS A SUBJECT ID IN THE 1ST 11 ENTRIES. THEN
C  THE ENTRIES ARE, IN ORDER, EVID, TIME, DUR, DOSE, ADDL, II, INPUT,
C  ...



C  READ EACH DOSE LINE (EVID = 1 OR 4) TO OBTAIN THE VALUES OF ADDL AND
C  II FOR THOSE. ADDL IS THE NO. OF ADDITIONAL DOSE LINES THAT ARE 

C  IDENTICAL TO THE CURRENT LINE, AND II IS THE ASSOCIATED INTERDOSE
C  INTERVAL. IF ADDL = -1, THIS REPRESENTS A STEADY STATE SET OF DOSES.

C  FOR A DOSE LINE, IF ADDL = 0 OR IS MISSING (WHICH MEANS ADDL IS
C  ASSUMED TO BE 0), WRITE THE LINE, WITHOUT THE ADDL AND II VALUES,
C  INTO HOLDMAT. 

C  FOR EACH DOSE LINE WITH AN ADDL > 0, WRITE THAT LINE
C  WITHOUT THE ADDL AND II VALUES, AND ADDL MORE SIMILAR LINES INTO THE
C  HOLDMAT, MAKING SURE THAT THE TIME FOR EACH SUCCESSIVE LINE
C  IS INCREASED BY II FROM THE PREVIOUS LINE.

C  NOTE THAT THE ABOVE PROCESS CAN CAUSE THE DOSE LINES TO BE OUT OF
C  ORDER IN HOLDMAT. EACH BLOCK OF DOSE LINES WILL BE 
C  ORDERED UP TO THE NEXT DOSE/TIME RESET LINE BELOW. AND NOTE THAT
C  ALL THE DOSES IN EACH REGION (UNTIL THE NEXT TIME RESET LINE - I.E.,
C  UNTIL THE NEXT EVID = 4) WILL BE WRITTEN TOGETHER, AND THEN BE
C  FOLLOWED BY ALL THE OBSERVATION LINES IN THAT REGION).


C  NOTE BELOW THAT AFTERCOMMA OPENS AND PUTS INTO FILE 57 THE PART OF
C  READLINE WHICH IS BETWEEN COMMA C AND COMMA C+1, WHERE C IS THE 3RD
C  ARGUMENT. ALSO,NOTE THAT NCOVA MUST BE PROVIDED TO AFTERCOMMA SO IT
C  WILL KNOW THE TOTAL NO. OF COMMAS IN READLINE, WHICH = 13 + NCOVA 

C  SINCE THIS FILE HAS 14 FIXED FIELDS (COUNTING THE 2 NEWS ONES, 
C  ADDL AND II).
C  
C  SO, FIRST FIND NCOVA FROM READLINE JUST READ IN (THE 2ND LINE OF THE
C  .csv FILE).

        NCOMMA = 0

        DO ISTART = 1,1000	 
         IF(READLINE(ISTART:ISTART) .EQ. ',') THEN
          NCOMMA = NCOMMA + 1
         ENDIF
        END DO

        NCOVA = NCOMMA - 13

C  INITIALIZE SUBIDPREV (THE PREVIOUS SUBJECT ID), AND THE CURRENT
C  SUBJECT TO BE '%^&*'.

	SUBIDPREV = '%^&*'
	SUBID = '%^&*'
      NROW = 0


C  NROW IS THE RUNNING INDEX OF THE NEXT LINE TO BE PUT INTO THE
C  HOLDMAT.



   20 READ(67,1,IOSTAT=IEND) READLINE


C  IF IEND .LT. 0, THE FILE HAS BEEN READ THROUGH COMPLETELY, SO GO TO
C  LABEL 100 TO WRITE THE LAST SUBJECT'S ROWS TO FILE 66.

	IF(IEND .LT. 0) GO TO 100


C  IF READLINE(1:1) IS #, THIS LINE IS A COMMENT LINE AND CAN BE
C  SKIPPED (I.E., NOT WRITTEN INTO HOLDMAT).

      IF(READLINE(1:1) .EQ. '#') GO TO 20


C  WILL ALSO GO TO LABEL 100 IF THIS SUBJECT ID IS DIFFERENT THAN
C  SUBIDPREV (SINCE THAT MEANS THAT THE PREVIOUS SUBJECT'S LINES ARE
C  READY TO BE WRITTEN TO FILE 66).    

C  THE FIRST VALUE (I.E., AFTER COMMA NO. 0) IS THE SUBJECT ID.

	CALL AFTERCOMMA(NCOVA,READLINE,0)
	BACKSPACE(57)
	READ(57,222) SUBID
  222 FORMAT(A11)
	CLOSE(57)


C  NOTE THAT SUBID CONTAINS THE 1ST 11 CHARACTERS OF THE LINE, BUT THE
C  SUBJECT ID IS JUST THE SET OF CHARACTERS PRIOR TO THE 1ST COMMA.
C  CALL SUBROUTINE GETID TO CORRECT THE VALUE OF SUBID.

	CALL GETID(SUBID)

      IF(SUBID .NE. SUBIDPREV) GO TO 100


C  TO GET TO THIS POINT, SUBID = SUBIDPREV, WHICH MEANS THIS IS A
C  LINE FOR THE CURRENT SUBJECT.

C  IF THE EVENT ID, IN ENTRY NO. 2 (I.E., AFTER COMMA NO. 1) IN 
C  READLINE IS 0, THE LINE REPRESENTS AN OBSERVATION AND CAN BE WRITTEN

C  INTO HOLDMAT, EXCEPT FOR ADDL AND II AS DONE ABOVE.

	CALL AFTERCOMMA(NCOVA,READLINE,1)
	BACKSPACE(57)
	READ(57,*) IDEVENT
	CLOSE(57)

      IF(IDEVENT .EQ. 0) THEN
       NROW = NROW + 1
       CALL GETCOM(NCOMMA,READLINE,I5,I7)
       HOLDMAT(NROW) = READLINE(1:I5)//READLINE(I7+1:150)
      ENDIF

C  IF THE EVENT ID IS 1 OR 4, THE LINE REPRESENTS A DOSE
C  EVENT (1 -> REGULAR DOSE; 4 -> TIME RESET EVENT WITH A DOSE). EITHER
C  WAY IF THE ENTRY FOR ADDL IS MISSING OR A 0, IT MEANS THAT THIS LINE
C  REPRESENTS A SINGLE DOSE. IF ADDL > 0, THIS LINE MUST BE COPIED
C  ADDL TIMES. NOTE THAT THE ADDL ENTRY IS NO. 6, AFTER COMMA NO. 5.

      IF(IDEVENT .EQ. 1 .OR. IDEVENT .EQ. 4) THEN

       CALL AFTERCOMMA(NCOVA,READLINE,5)
       BACKSPACE(57)
       READ(57,*,ERR=25) IADDL
       CLOSE(57)
       GO TO 30

   25  IADDL = 0

C  TO GET TO LABEL 25 MEANS IADDL TRIED TO READ A NON-NUMBER, WHICH 
C  MEANS IT IS MISSING --> IT IS EQUIVALENT TO 0. IN THIS CASE, WRITE
C  THE LINE INTO HOLDMAT, EXCEPT FOR IADDL AND II AS 
C  DONE ABOVE.

   30  CONTINUE
       
       IF(IADDL .GE. 0) THEN
        NROW = NROW + 1
        CALL GETCOM(NCOMMA,READLINE,I5,I7)
        HOLDMAT(NROW) = READLINE(1:I5)//READLINE(I7+1:150)
       ENDIF


       IF(IADDL .GT. 0) THEN

C  THIS LINE MUST BE COPIED IADDL TIMES, BUT EACH LINE MUST HAVE ITS 
C  TIME ENTRY INCREASED BY XII (THE INTERDOSE INTERVAL) FROM THE 

C  PREVIOUS LINE. FIRST FIND THE VALUE OF XII, IN THE 7TH ENTRY, AFTER
C  THE 6TH COMMA. IF XII IS MISSING, STOP THE PROGRAM TELLING THE USER
C  THAT THE .cvs FILE HAS AN ERROR; IT HAS A ROW WITH AN IADDL > 0, BUT
C  WITH AN ACCOMPANYING INTERDOSE INTERVAL WHICH IS MISSING. NOTE THAT
C  THIS LINE NO. IS 2 (THE TOP 2 LINES) + NROW + 1 = NROW + 3.

	  CALL AFTERCOMMA(NCOVA,READLINE,6)
	  BACKSPACE(57)
	  READ(57,*,ERR=35) XII
	  CLOSE(57)
        GO TO 40
        
   35   WRITE(*,36) NROW + 3
   36   FORMAT(/' THE INTERDOSE INTERVAL IS MISSING ON LINE NO. ',I6//
     1' PLEASE CORRECT YOUR .csv FILE AND RERUN THE PROGRAM.'/)


        OPEN(42,FILE=ERRFIL)
         WRITE(42,36) NROW + 3 
        CLOSE(42)	



        CALL PAUSE
        STOP





   40   CONTINUE

C  THE TIME FOR THE ORIGINAL DOSE IS IN ENTRY NO. 3, AFTER COMMA NO. 2.

	  CALL AFTERCOMMA(NCOVA,READLINE,2)
	  BACKSPACE(57)
	  READ(57,*) TIM
	  CLOSE(57)

        DO IADD = 1,IADDL

C  NOTE THAT THE ORIGINAL LINE FOR THIS DOSE HAS ALREADY BEEN WRITTEN
C  TO HOLDMAT (IN THE IF(IADDL .GE. 0) SECTION ABOVE). SO
C  NOW MUST WRITE IADDL LINES TO HOLDMAT, EACH IDENTICAL TO
C  THE CURRENT LINE, EXCEPT EACH TIM WILL BE INCREMENTED BY
C  XII. TO DO THIS, WRITE THE NEXT TIM + XII TO SCRATCH FILE 57; THEN
C  REREAD THIS VALUE AS A CHARACTER SO IT CAN BE INSERTED INTO
C  THE CHARACTER STRING READLINE AND THEN WRITTEN TO THE HOLDING
C  MATRIX.


C  FIRST RESET READLINE TO HOLDMAT(NROW), WHICH DOES NOT HAVE THE
C  ADDL AND II ENTRIES.

         READLINE(1:150) = HOLDMAT(NROW)

         OPEN(57,STATUS='SCRATCH')

         WRITE(57,*) TIM + XII*IADD
         BACKSPACE(57)
         READ(57,41) TIMCHAR



   41    FORMAT(A50)

C  TAKE OUT ALL SPACES AT THE END OF TIMCHAR.

         DO IEND = 50,1,-1
          IF(TIMCHAR(IEND:IEND) .NE. ' ') GO TO 50
         END DO

   50    CONTINUE

C  NOW TIMCHAR(1:IEND) IS THE CONDENSED FORM OF THE TIME FOR THIS
C  ROW. REPLACE WHAT IS CURRENTLY BETWEEN COMMAS 2 AND 3 OF 
C  HOLDMAT(NROW) WITH THIS, AND STORE IT INTO THE NEXT ROW OF HOLDMAT.

         ICOMMA = 0

         DO I = 1,150


          IF(READLINE(I:I) .EQ. ',') THEN
           ICOMMA = ICOMMA + 1
           IF(ICOMMA .EQ. 2) I2 = I
           IF(ICOMMA .EQ. 3) THEN
            I3 = I
            GO TO 60
           ENDIF
          ENDIF
         END DO

   60    READLINE2 =
     1    READLINE(1:I2)//TIMCHAR(1:IEND)//READLINE(I3:150)


         NROW = NROW + 1         
         HOLDMAT(NROW) = READLINE2(1:150)
         
        END DO

C  THE ABOVE END DO IS FOR THE  DO IADD = 1,IADDL  LOOP.


       ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(IADDL .GT. 0)  CONDITION.



       IF(IADDL .EQ. -1) THEN


C  WRITE JUST ONE LINE TO THE NEW .CSV FILE, EVEN THOUGH IADDL = -1
C  REPRESENTS A STEADY STATE DOSE SET OF 100 DOSES. MAKE THE TIME FOR
C  THIS EVENT = -II SO READBLOCK/WRITEDOS WILL KNOW THIS IS A LINE WITH
C  STEADY STATE DOSE INFO.

	  CALL AFTERCOMMA(NCOVA,READLINE,6)
	  BACKSPACE(57)
	  READ(57,*,ERR=65) XII
	  CLOSE(57)

        GO TO 70
        
   65   WRITE(*,36) NROW + 3

        OPEN(42,FILE=ERRFIL)
         WRITE(42,36) NROW + 3 
        CLOSE(42)	



        CALL PAUSE
        STOP

   70   CONTINUE

C  NOW ESTABLISH THE NEXT LINE OF HOLDMAT AS THE CURRENT
C  READLINE, BUT WITHOUT THE ENTRIES FOR ADDL AND II; THEN RESET
C  READLINE TO BE THIS NEW LINE.

        NROW = NROW + 1
        CALL GETCOM(NCOMMA,READLINE,I5,I7)
        HOLDMAT(NROW) = READLINE(1:I5)//READLINE(I7+1:150)
        READLINE(1:150) = HOLDMAT(NROW)


C  NOW ESTABLISH READLINE2 = READLINE, BUT WITH THE TIME VALUE RESET

C  TO BE TIME = -XII. TO DO THIS, WRITE -XII TO SCRATCH FILE 57; THEN
C  REREAD THIS VALUE AS A CHARACTER SO IT CAN BE INSERTED INTO
C  THE CHARACTER STRING READLINE AND THEN WRITTEN TO THE HOLDING
C  MATRIX.

         OPEN(57,STATUS='SCRATCH')

         WRITE(57,*) -XII
         BACKSPACE(57)
         READ(57,41) TIMCHAR

C  TAKE OUT ALL SPACES AT THE END OF TIMCHAR.

         DO IEND = 50,1,-1
          IF(TIMCHAR(IEND:IEND) .NE. ' ') GO TO 80
         END DO

   80    CONTINUE

C  NOW TIMCHAR(1:IEND) IS THE CONDENSED FORM OF THE TIME FOR THIS
C  ROW. REPLACE WHAT IS CURRENTLY BETWEEN COMMAS 2 AND 3 OF 
C  HOLDMAT(NROW) WITH THIS, AND STORE IT BACK INTO THE SAME ROW OF 
C  HOLDMAT.

         ICOMMA = 0

         DO I = 1,150
          IF(READLINE(I:I) .EQ. ',') THEN
           ICOMMA = ICOMMA + 1
           IF(ICOMMA .EQ. 2) I2 = I
           IF(ICOMMA .EQ. 3) THEN
            I3 = I
            GO TO 90
           ENDIF

          ENDIF
         END DO

   90    READLINE2 =
     1    READLINE(1:I2)//TIMCHAR(1:IEND)//READLINE(I3:150)
         HOLDMAT(NROW) = READLINE2(1:150)


       ENDIF 


C  THE ABOVE ENDIF IS FOR THE  IF(IADDL .EQ. -1)  CONDITION.


      ENDIF

C  THE ABOVE ENDIF IS FOR THE  
C   IF(IDEVENT .EQ. 1 .OR. IDEVENT .EQ. 4)  CONDITION.


      GO TO 20


  100 CONTINUE



C  THE FIRST TWO LINES OF FILE 66 WERE WRITTEN ABOVE. NOW WRITE THE 
C  REST OF THE FILE.

C  NOTE THAT IN EACH SECTION OF DOSES (I.E., UNTIL THE NEXT IDEVENT 
C  = 4), MUST ORDER THE DOSES SINCE THEY COULD BE OUT OF ORDER DUE TO
C  THE ADDL ENTRY. 


C  FOR EXAMPLE, A DOSE OF T = 0 WITH ADDL = 2 AND II = 12 --> DOSES AT
C  T = 0, 12, AND 24. THEN ANOTHER DOSE (FOR A DIFFERENT DRUG, OR THE
C  SAME DRUG WITH A DIFFERENT ROUTE) COULD OCCUR AT T = 8. THEN, FROM
C  THE ABOVE CODE, THE CURRENT DOSE TIMES WOULD BE [0 12 24 8].

C  SO GO THROUGH THE NROW ROWS OF HOLDMAT, AND ORDER THE ROWS IN EACH
C  SECTION (I.E., UNTL THE NEXT IDEVENT = 4 ROW). IN PARTICULAR, FIRST
C  ORDER THE DOSE ROWS (IDEVENT = 1). IF THESE ROWS FOLLOW AN 
C  IDEVENT = 4 ROW, THAT ROW GOES FIRST OF COURSE. THEN WRITE IN THE
C  OBSERVATION ROWS (THEY SHOULD ALREADY BE IN ORDER).

C  PUT ALL THE IDEVENT ENTRIES IN HOLDMAT INTO IDENTRY(.), AND PUT ALL
C  THE TIME ENTRIES IN HOLDMAT INTO TIMENTRY(.).

      DO I = 1,NROW

       READLINE(1:150) = HOLDMAT(I)

       CALL AFTERCOMMA(NCOVA,READLINE,1)
	 BACKSPACE(57)
	 READ(57,*) IDEVENT
       IDENTRY(I) = IDEVENT
	 CLOSE(57)

       CALL AFTERCOMMA(NCOVA,READLINE,2)
	 BACKSPACE(57)
	 READ(57,*) TIM
       TIMENTRY(I) = TIM
	 CLOSE(57)

      END DO


      NN = 0
      NFIRST = 1

C  NN IS THE RUNNING INDEX OF THE ROW IN HOLDMAT UNDER CONSIDERATION.
C  NFIRST IS THE RUNNING INDEX OF THE FIRST ROW IN THE NEXT SECTION
C  UNDER CONSIDERATION.

  150 CONTINUE

C  ORDER ALL THE ROWS UNTIL THE NEXT IDENTRY(.) = 4, OR UNTIL THE 
C  END OF THE ROWS IS ENCOUNTERED, WHICHEVER COMES FIRST.

      NN = NN + 1
      IF(NN .GT. NROW) GO TO 200

      IF(IDENTRY(NN) .NE. 4 .AND. NN .LT. NROW) GO TO 150

C  ORDER THE ENTRIES IN HOLDMAT FROM NFIRST TO EITHER NROW
C  (IF NN = NROW) OR TO NN-1 (IF IDENTRY(NN) = 4), AND THEN
C  WRITE THEM INTO FILE 66.

      IF(NN .EQ. NROW) NLAST = NROW
      IF(IDENTRY(NN) .EQ. 4) NLAST = NN - 1
      CALL ORDERHOLD(HOLDMAT,NFIRST,NLAST,IDENTRY,TIMENTRY)

  151 FORMAT(A150)


      DO I = NFIRST,NLAST
       WRITE(66,151) HOLDMAT(I)
      END DO      

      NFIRST = NLAST + 1

      GO TO 150

     
  200 CONTINUE

C  IF FILE 67 HAS BEEN COMPLETELY READ, RETURN.

	IF(IEND .LT. 0) THEN
       CLOSE(67)
       RETURN

      ENDIF


C  SINCE IEND .GE. 0, THE FILE HAS NOT BEEN COMPLETELY READ. SO, RESET

C  SUBIDPREV = SUBID AND NROW TO BE 0, AND BACKSPACE FILE 67 SINCE THE
C  FIRST LINE FOR THE NEXT SUBJECT WAS ALREADY READ (I.E., THE NEXT
C  READ OF FILE 67 SHOULD REREAD THIS FIRST LINE) AND GO BACK TO LABEL
C  20 TO CONTINUE READING THE FILE.


      SUBIDPREV = SUBID
      NROW = 0
      BACKSPACE(67)
      GO TO 20


      END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
      SUBROUTINE GETCOM(NCOMMA,READLINE,I5,I7)

      CHARACTER READLINE*1000,ERRFIL*20




      COMMON/ERROR/ERRFIL
C  COMMON/ERROR/ IS SUPPLIED TO ALL THE ROUTINES WHICH COULD WRITE TO
C  ERRFIL.

C  GETCOM IS CALLED BY CVSCHANGE TO FIND THE ENTRY NO. FOR COMMA NO. 5
C (I5), AND THE ENTRY FOR COMMA NO. 7 (I7).

    1 FORMAT(A1000)
 
      ICOMMA = 0

      DO I = 1,300
       IF(READLINE(I:I) .EQ. ',') THEN
        ICOMMA = ICOMMA + 1


         IF(ICOMMA .EQ. 5) I5 = I


          IF(ICOMMA .EQ. 7) THEN
           I7 = I
           RETURN
          ENDIF
       ENDIF
      END DO

C  TO GET TO THIS POINT MEANS THAT READLINE DOESN'T HAVE 7 COMMAS IN
C  IT. REPORT THIS ERROR TO THE USER AND STOP.

      WRITE(*,2) NCOMMA,READLINE(1:70)

    2 FORMAT(/' ONE OF THE LINES IN YOUR .cvs FILE HAS AN ERROR.'/
     1' IT IS SUPPOSED TO HAVE ',I2,' COMMAS, BUT IT HAS FEWER THAN'/
     2' 7. THE FOLLOWING LINE SHOWS THE 1ST 70 CHARACTERS OF THE LINE:'/
     3' ',A70//
     4' THE PROGRAM STOPS.'/)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,2) NCOMMA,READLINE(1:70)
        CLOSE(42)
	


      CALL PAUSE
      STOP
    
      END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
      SUBROUTINE ORDERHOLD(HOLDMAT,NFIRST,NLAST,IDENTRY,TIMENTRY)


      IMPLICIT REAL*8(A-H,O-Z)

      DIMENSION TIMENTRY(99999),IDENTRY(99999),IZ(99999),IZZ(99999),
     1 DOSTIME(99999)
      CHARACTER HOLDMAT(99999)*150,HOLDMAT2(99999)*150

C  ORDER THE ENTRIES IN HOLDMAT FROM NFIRST TO NLAST, AS FOLLOWS:


C  1. PUT ALL THE DOSE EVENTS (IDENTRY(.) = 1 OR 4) FIRST, ORDERED BY
C  INCREASING TIMENTRY(.).

C  2. PUT ALL THE OBSERVATION EVENTS (IDENTRY(.) = 0) AFTER THE DOSE
C  EVENTS (THEY SHOULD ALREADY BE ORDERED).


C  FIRST, STORE THE DOSE ROWS FROM NFIRST TO NLAST IN HOLDMAT TO 
C  HOLDMAT2, STARTING AT ROW 1 IN HOLDMAT2.

C  ALSO, PUT ALL THE DOSE EVENTS TIMES INTO DOSTIME, AND INITIALIZE

C  VECTOR IZ TO BE -99 IN ALL ITS NDOSE LOCATIONS

      NDOSE = 0

      DO I = NFIRST,NLAST
       IF(IDENTRY(I) .EQ. 1 .OR. IDENTRY(I) .EQ. 4) THEN
        NDOSE = NDOSE + 1
        HOLDMAT2(NDOSE) = HOLDMAT(I)
        DOSTIME(NDOSE) = TIMENTRY(I)
        IZ(NDOSE) = -99
       ENDIF
      END DO

C  NOW, FOR EXAMPLE, IF ENTRY 17 IS THE SMALLEST VALUE IN DOSTIME,
C  IZ(17) WILL BE SET = 0, AND THE PROGRAM WILL KNOW NOT TO CHECK THE
C  17TH ENTRY AGAIN (SINCE IT HAS ALREADY BEEN SELECTED). IF THE NEXT
C  SMALLEST ENTRY HAS INDEX 37, THEN IZ(37) WILL BE SET = 0, ETC.

C  NOTE THAT IZZ WILL BE THE ARRAY WHICH CONTAINS THE ACTUAL ORDERING.
C  IN THE EXAMPLE ABOVE, IZZ(1) = 17, IZZ(2) = 37. IT WILL BE EASY TO
C  ASSIGN ORDERED VALUES BACK INTO HOLDMAT USING IZZ. IN THE EXAMPLE
C  ABOVE, HOLDMAT(1) WILL HAVE DOSE TIME = DOSTIME(IZZ(1)) =
C  DOSTIME(17); HOLDMAT(2) WILL HAVE DOSE TIME = DOSTIME(IZZ(2)) =
C  DOSTIME(37); ETC.


C  NOW PUT THE OBSERVATION ROWS FROM NFIRST TO NLAST IN HOLDMAT TO
C  HOLDMAT2, STARTING AT ROW NDOSE + 1 IN HOLDMAT2.

      NEXT = NDOSE

      DO I = NFIRST,NLAST
       IF(IDENTRY(I) .EQ. 0) THEN
        NEXT = NEXT + 1
        HOLDMAT2(NEXT) = HOLDMAT(I)
       ENDIF
      END DO


C  NOW ORDER THE FIRST NDOSE ROWS IN HOLDMAT2 ACCORDING TO THE DOSE
C  TIMES, LOW TO HIGH.

	 DO IPLACE = 1,NDOSE

C  PUT THE NEXT LOWEST VALUE OF DOSTIME INTO THE IPLACE LOCATION OF
C  IZZ.

C  TEMP IS THE RUNNING VALUE OF THE NEXT VALUE TO BE PLACED INTO 
C  DOSTIME. INITIALIZE IT TO BE VERY HIGH VALUE SO THE FIRST VALUE 

C  OF DOSTIME WILL BE SURE TO BE LOWER THAN IT IS.

	  TEMP = 1.D50


	  DO I=1,NDOSE
	   IF(DOSTIME(I) .LT. TEMP .AND. IZ(I) .EQ. -99) THEN
	    TEMP = DOSTIME(I)
	    IND = I
	   ENDIF
	  END DO

C  AT THIS POINT, IND IS THE INDEX OF THE SMALLEST REMAINING VALUE
C  (TEMP) IN DOSTIME. PUT THIS INFORMATION INTO IZZ. ALSO, SET
C  IZ(IND) = 0 --> THE IND LOCATION IN DOSTIME HAS BEEN USED.

	  IZZ(IPLACE) = IND
	  IZ(IND) = 0

	 END DO


C  AT THIS POINT IZZ CONTAINS THE ORDERED INDICES (LOW TO HIGH) OF THE
C  NDOSE VALUES IN DOSTIME, AND SO GIVES THE ORDER THAT THE NDOSE ROWS
C  NOW IN HOLDMAT2 SHOULD BE WRITTEN.

C  WRITE THESE NDOSE DOSE ROWS IN THE CORRECT ORDER INTO HOLDMAT, AND
C  THEN WRITE THE REMAINING ROWS (OBSERVATION ROWS) INTO HOLDMAT. 

      DO IDOSE = 1,NDOSE
       HOLDMAT(NFIRST-1+IDOSE) = HOLDMAT2(IZZ(IDOSE))
      END DO

C  STORE THE OBSERVATION ROWS INTO ENTRIES NFIRST + NDOSE,..., NLAST OF
C  HOLDMAT. THEY WERE STORED INTO THE LAST NOBS ROWS OF HOLDMAT2 ABOVE. 

      NEXT = NDOSE

      DO IOBS = NFIRST + NDOSE,NLAST
       NEXT = NEXT + 1
       HOLDMAT(IOBS) = HOLDMAT2(NEXT)
      END DO
     
       
      RETURN
      END


C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C wmy2019.03 PREDLAST3 moved into npag_utils.f90
C
C
      SUBROUTINE Old_PREDLAST3(NN,NSET,XSTORE,XPRED,ICONV)

      use npag_utils, only: thesame

      IMPLICIT REAL*8(A-H,O-Z)

      DIMENSION XSTORE(100,20),XPRED(20),COMP(5,20)


C  NOTE THAT AS OF MONT109.FOR, THE DIMENSIONS OF 6 IN XSTORE, XPRED,
C  AND COMP HAVE BEEN CHANGED TO 20, WHICH IS WHAT THEY SHOULD HAVE BEEN
C  ALL ALONG (SEE SUBROUTINE FUNC2).


C  THIS SUBROUTINE IS CALLED BY SUBROUTINE FUNC WITH NSET SETS OF NN
C  COMPARTMENT  VALUES IN XSTORE. USE THE LAST 5 SETS OF VALUES TO

C  PREDICT THE FINAL (STEADY STATE) COMPARTMENT AMOUNTS AFTER THE LAST
C  (100TH) DOSE SET. NOTE THAT AS OF MONT110.FOR, THERE WILL ALSO BE AN 
C  ADDITIONAL 101ST DOSE SET APPLIED. BUT THE PREDICTION SHOULD STILL
C  BE AFTER THE 100TH SET.


C  IF THESE VALUES "CONVERGE", SET ICONV = 1, AND WRITE THE PREDICTED
C  VALUES INTO XPRED. IF THEY DON'T CONVERGE, SET ICONV = 0.

C  TOL1 AND TOL2 ARE, FOR NOW, HARDCODED TO BE .0005.

        TOL1 = .0005D0
        TOL2 = .0005D0



C  THE LAST 5 SETS OF VALUES ARE IN XSTORE(NSET-4:NSET,.). PUT THESE
C  VALUES INTO COMP(.,.).

      II = 0
    
      DO I = NSET-4,NSET
       II = II+1
       DO J = 1,NN
        COMP(II,J) = XSTORE(I,J)
       END DO
      END DO



C  FOR EACH COMPARTMENT AMOUNT, SEE IF THE FINAL STEADY STATE COMP.
C  AMOUNT CAN BE PREDICTED ACCURATELY.

      DO IN = 1,NN


       A1 = COMP(1,IN)
       A2 = COMP(2,IN)
       A3 = COMP(3,IN)
       DEL1 = A2 - A1
       DEL2 = A3 - A2

C  TEST FOR DEL1 = 0. IF SO, SEE ISAMETOT BELOW.

       CALL THESAME(DEL1,0.D0,ISAME1)

       IF(ISAME1 .EQ. 0) THEN

        F = DEL2/DEL1

C  THE UNDERLYING ASSUMPTION IS THAT THE RATIO F = DEL2/DEL1
C  IS CONTANT BETWEEN CONSECUTIVE OUTPUT DIFFERENCES. IF SO, THEN
C  THE STEADY STATE VALUE WILL BE A1 + DEL1/(1 - F) (SEE SS.EXP
C  IN \ALAN3\STEADYSTATE). CALCULATE THIS VALUE AND CALL IT PRED1.

C  BUT, IF DEL2 = DEL1, THEN F = 1. IN THIS CASE, CAN'T DO THE FOLLOWING 
C  CALCULATION FOR PRED1, AND WE WOULDN'T WANT TO DO IT SINCE 
C  DEL2 = DEL1 --> A2 - A1 = A3 - A2 --> A1, A2, AND A3 ARE IN AN 
C  ARITHMETIC PROGRESSION --> THERE OBVIOUSLY CAN BE NO CONVERGENCE

C  SINCE, AFTER 100 DOSES, THE VALUE WOULD JUST A1 + 99*DEL1 ... 
C  UNLESS DEL1 = 0, IN WHICH CASE THE VALUE WOULD CONVERGE TO A1.
C  IN THIS CASE SET ISAMEF1 = 1, AND SKIP CALC. OF PRED1. AND THEN
C  SEE THE LOGIC RELATED TO ISAMEF1 BELOW.

        CALL THESAME(F,1.D0,ISAMEF1)
        IF(ISAMEF1 .EQ. 0) PRED1 = A1 + DEL1/(1.D0 - F)

       ENDIF


C  SIMILARLY, CALCULATE PRED2 (BASED ON (A2,A3,A4)) AND PRED3 (BASED
C  ON (A3,A4,A5).

       A1 = COMP(2,IN)
       A2 = COMP(3,IN)
       A3 = COMP(4,IN)
       DEL1 = A2 - A1
       DEL2 = A3 - A2


C  TEST FOR DEL1 = 0. IF SO, SEE ISAMETOT BELOW.

       CALL THESAME(DEL1,0.D0,ISAME2)

       IF(ISAME2 .EQ. 0) THEN
        F = DEL2/DEL1


        CALL THESAME(F,1.D0,ISAMEF2)
        IF(ISAMEF2 .EQ. 0) PRED2 = A1 + DEL1/(1.D0 - F)

       ENDIF

       A1 = COMP(3,IN)
       A2 = COMP(4,IN)
       A3 = COMP(5,IN)
       DEL1 = A2 - A1
       DEL2 = A3 - A2


C  TEST FOR DEL1 = 0. IF SO, SEE ISAMETOT BELOW.

       CALL THESAME(DEL1,0.D0,ISAME3)

       IF(ISAME3 .EQ. 0) THEN

        F = DEL2/DEL1


        CALL THESAME(F,1.D0,ISAMEF3)
        IF(ISAMEF3 .EQ. 0) PRED3 = A1 + DEL1/(1.D0 - F)
       ENDIF


C  ASSUMING A NEGATIVE EXPONENTIAL PATTERN FIT (SEE SS.EXP IN 
C  \ALAN3\STEADYSTATE OR HOME NOTES, PG.2 ON 9/11/11 FOR DETAILS) ON
C (PRED1,PRED2,PRED3), CALCULATE PREDNEG.

C  BUT ONLY DO THIS CALCULATION, AND THE SUBSEQUENT 
C  CONVERGENCE DETERMINATION IF ISAME1 = ISAME2 = ISAME3 = 0, AND
C  ISAMEF1 = ISAMEF2 = ISAMEF3 = 0. OTHERWISE, AT LEAST ONE OF THE
C  PREDICTED VALUES ABOVE WAS NOT CALCULATED.

       ISAMETOT = ISAME1 + ISAME2 + ISAME3
       ISAMEFTOT = ISAMEF1 + ISAMEF2 + ISAMEF3


       IF(ISAMETOT .EQ. 0 .AND. ISAMEFTOT .EQ. 0) THEN

C EDITED CODE BELOW FOR MONT103.FOR.

C  IF PRED1 + PRED3 - 2*PRED2 = 0, PREDNEG (SEE BELOW) CANNOT BE 
C  CALCULATED. IN THIS CASE, PRED2 - PRED1 = PRED3 - PRED2 --> 
C  THE SEQUENCE (PRED1, PRED2, PRED3) IS LINEAR, WHICH CANNOT BE 
C  MODELED WITH AN EXPONENTIAL FIT (SEE COMMENTS ABOVE). SO, IF THIS
C  HAPPENS, CONVERGENCE WILL BE SATISFIED IF THESE 3 VALUES ARE 
C  VIRTUALLY THE SAME - I.E., ONLY THE REQUIREMENT INVOLVING TOL1
C  WILL BE NEEDED FOR CONVERGENCE (RECALL THE ONLY REASON FOR THE
C  EXTRA NEGATIVE EXPONENTIAL FIT, AND THE CALCULATION OF PREDNEG IS FOR
C  THOSE CASES WHERE PRED1, PRED2, AND PRED3 ARE NOT ALL VIRTUALLY THE
C  SAME VALUE).

        DEN = PRED1+PRED3-2.D0*PRED2
        CALL THESAME(DEN,0.D0,ISAMEDEN)
      

        IF(ISAMEDEN .EQ. 0)
     1   PREDNEG = (PRED1*PRED3 - PRED2*PRED2)/DEN

C  NOW CHECK FOR CONVERGENCE, WHICH HAS BEEN OBTAINED IF 
C  |PRED3/PRED2 - 1| < TOL1 AND |PREDNEG/PRED3 - 1| < TOL2. 

        ICONV = 1
        IF(DABS(PRED3/PRED2 - 1.D0) .GE. TOL1) ICONV = 0
        IF(ISAMEDEN .EQ. 0 .AND. DABS(PREDNEG/PRED3 - 1.D0) .GE. TOL2)
     1   ICONV = 0


C  IF ICONV = 1 FOR THIS COMPARTMENT, IN, STORE THE PREDICTED AMOUNT,
C  AND CONTINUE TO THE NEXT COMPARTMENT. NOTE BELOW THAT 
C  NON-CONVERGENCE IN ANY COMPARTMENT ENDS THE PROCESS SINCE TO
C  CONVERGE, ALL COMPARTMENT PREDICTIONS MUST CONVERGE.

        IF(ICONV .EQ. 1 .AND. ISAMEDEN .EQ. 1) XPRED(IN) = PRED3 
        IF(ICONV .EQ. 1 .AND. ISAMEDEN .EQ. 0) XPRED(IN) = PREDNEG


C EDITED CODE ABOVE FOR MONT103.FOR.


       ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(ISAMETOT .EQ. 0 .AND. ISAMEFTOT .EQ.0)
C  CONDITION.


C  IF ISAMETOT .GT. 0, THERE ARE TWO POSSIBILITIES (AND NOTE THAT IT
C  DOSEN'T MATTER WHAT ISAMEFTOT IS IN THIS CASE):

C   ISAMETOT = 3, IN WHICH CASE COMP(1:4,IN) ARE ALL THE SAME.
C   ISAMETOT = 1 OR 2, IN WHICH CASE SOME OF THE COMP(1:4,IN) VALUES
C     ARE THE SAME, AND SOME ARE NOT.


C  IN THE FORMER CASE, VERIFY THAT COMP(5,IN) IS THE SAME VALUE AS
C  THE COMP(1:4,IN). IF SO, SET THE PREDICTED VALUE = THIS VALUE
C  (I.E., THE PREDICTED VALUE FOR A CONSTANT FUNCTION IS THE
C  CONSTANT VALUE), AND SET ICONV = 1. OTHERWISE, SET ICONV = 0
C  SINCE THERE IS NO WAY TO FIT 4 VALUES WHICH ARE THE SAME AND ONE
C  WHICH IS NOT USING A NEGATIVE EXPONENTIAL FUNCTION.


C  IN THE LATTER CASE, SINCE SOME OF THE COMP(1:4,IN) VALUES ARE THE
C  SAME, AND SOME ARE NOT, SET ICONV = 0 FOR THE SAME REASON AS 
C  STATED IN THE PREVIOUS PARAGRAPH.

       IF(ISAMETOT .EQ. 3) THEN

        CALL THESAME(COMP(5,IN),COMP(1,IN),ISAME)

        IF(ISAME .EQ. 1) THEN
         ICONV = 1
         XPRED(IN) = COMP(1,IN)
        ENDIF

        IF(ISAME .EQ. 0) ICONV = 0
  
       ENDIF

       IF(ISAMETOT .EQ. 1 .OR. ISAMETOT .EQ. 2) ICONV = 0


C  IF ICONV = 0, CONVERGENCE WAS NOT ACHIEVED.

       IF(ICONV .EQ. 0) RETURN


      END DO

C  THE ABOVE END DO IS FOR THE  DO IN = 1,NN  LOOP.

C  TO GET TO THIS POINT, ALL COMPARTMENT AMOUNTS HAVE CONVERGED, AND
C  THEIR PREDICTED AMOUNTS HAVE BEEN STORED INTO XPRED(IN),IN=1,NN.


      RETURN
      END

C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
      SUBROUTINE NEWWORK1(INTLIST)

      use npag_utils, only: verifyval,orderdelta,thesame

      IMPLICIT REAL*8(A-H,O-Z)

	PARAMETER(MAXNUMEQ=7)

      integer, dimension(128) :: INTLIST

      DIMENSION SIG(5000),RS(5000,34),DELTAIV(7),ORDELT(7),
     1 RSS(5000,34),SIGG(5000),TIM(594),TIMM(594),YO(594,MAXNUMEQ),
     2 TIMDELAY(99),XVERIFY(900)

      CHARACTER READLINE*300,ERRFIL*20

      COMMON/ERROR/ERRFIL
C  COMMON/ERROR/ IS SUPPLIED TO ALL THE ROUTINES WHICH COULD WRITE TO
C  ERRFIL.

C  SUBROUTINE NEWWORK1 (BASED ON THE STAND-A-LONE VERSION OF THE SAME
C  NAME) READS IN A WORKING COPY PATIENT DATA FILE (IN FILE 31), AND
C  OUTPUTS ANOTHER FILE (FILE 41) WHICH IS:

C  a. EXACTLY THE SAME IF THE ORIGINAL FILE HAS NO STEADY STATE DOSE
C     INDICATORS;

C  OR

C  b. ALTERED TO HAVE THE SAME INFO AS IN THE ORIGINAL FILE, BUT ALSO
C     CONTAINING AN EXTRA 101 DOSES FOR EACH STEADY STATE DOSE 
C     INDICATOR.



C  NOTES:

C  1. A STEADY STATE DOSE INDICATOR IS A NEGATIVE VALUE IN THE TIME
C  ENTRY FOR A DOSE. THIS IS ACCOMPANIED BY INFORMATION ON THE SET OF
C  DOSES IN THE IV AND BOLUS ENTRIES, AS THE FOLLOWING EXAMPLE SHOWS:

C   Time    IV     Bolus
C   -2.0   100.0   150.0 ...

C  THE ABOVE LINE WOULD TELL THE PROGRAM:

C  a. THAT THIS WAS INFO ON 100 STEADY STATE DOSES BECAUSE OF THE 
C     NEGATIVE TIME VALUE;
C  b. THE TIME BETWEEN CONSECUTIVE IV START TIMES = 2 HOURS, BECAUSE 
C     THIS IS THE ABS. VALUE OF THE TIME;
C  C. THE IV RATE = 100MG/HOUR;
C  D. THE TOTAL DRUG AMT. FOR EACH IV DOSE IS 150MG.

C  SO THE PROGRAM WOULD THEN ADD 101 DOSES TO THE PATIENT DATA FILE,
C  STARTING AT T = 0, EACH WITH AN IV RATE = 100, AND CONTINUING FOR
C  1.5 HOURS.

C  2. IT WILL BE ASSUMED THAT EACH STEADY STATE DOSE INDICATOR ALWAYS
C  WILL BE REPLACED BY 101 IV DOSES (NOT BOLUS DOSES).
C  AS OF it2beng19.f, STEADY STATE DOSES MAY BE BOLUS DOSES. IN THIS
C  CASE, THE IV RATE WILL BE 0.0 OF COURSE.



C  3. ALL OTHER TIMES IN THE PATIENT DATA FILE (UP TO THE NEXT TIME 
C  RESET IF THERE IS ONE) WILL BE ASSUMED TO BE TIMES FROM THE END OF 
C  THE 100TH DOSE INTERVAL (NOT THE 101ST). IN THE ABOVE EXAMPLE, THE
C  100TH DOSE INTERVAL WOULD END AT T = 200 (THE 101ST IV ITSELF WOULD
C  END AT T = 201.5, BUT THE 100TH DOSE INTERVAL WOULD END AT T = 200).
C  SO ALL OTHER TIMES IN THE DOSAGE AND OBSERVATION BLOCKS WOULD HAVE
C  200 ADDED TO THEIR VALUES.


C  4. THE ABOVE EXAMPLE IS FOR ONE DRUG ONLY, BUT ANY OR ALL OF THE
C  NDRUGS IN A PATIENT'S FILE CAN HAVE STEADY STATE DOSES. ANY DRUG
C  WHICH HAS A NON-0 VALUE IN THE BOLUS COLUMN OF A STEADY STATE DOSE
C  LINE (I.E., ONE WITH TIME < 0) WILL PARTICIPATE IN A STEADY STATE
C  DOSE SET, GETTING THAT AMOUNT OF DRUG IN EACH OF THE 101 DOSES. IF
C  THE IV COLUMN IS > 0, THEN THE DRUG WILL BE GIVEN AT THE RATE 
C  SHOWN IN THE IV COLUMN. IF THE IV COLUMN IS 0, THEN THE DRUG WILL
C  BE GIVEN AS A BOLUS.

C  5. THE 101 STEADY STATE DOSES CAN BE GIVEN AS THE FIRST SET OF DOSES
C  IN A PATIENT'S FILE, AS INDICATED ABOVE, OR AT ANY TIME RESET. IF
C  THEY ARE AT A TIME RESET, ALL THE SUBSEQUENT TIMES AFTER THAT TIME
C  RESET (UP TO THE NEXT TIME RESET IF THERE IS ONE) ARE ADJUSTED AS 
C  INDICATED ABOVE TO BE TIMES AFTER THE END OF THE 100TH DOSE SET.

C-----------------------------------------------------------------------

C  BEFORE WRITING FILE 31 TO FILE 41, MUST EXAMINE FILE 31 TO SEE IF
C  IT HAS ANY STEADY STATE DOSE INDICATORS. IF IT DOES, IT MEANS THAT
C  THAT PART OF FILE 41 WILL HAVE AN EXTRA SET OF 101 DOSES FOR EACH
C  DRUG.

 1717 FORMAT(A300)

   10 READ(31,1717) READLINE
      IF(READLINE(12:23) .NE. 'NO. OF DRUGS') GO TO 10

C  READLINE NOW CONTAINS THE NO. OF DRUGS, NDRUG. BACKSPACE AND READ
C  NDRUG; THEN READ THE NO. OF ADDITIONAL COVARIATES, AND THE NO. OF
C  DOSE EVENTS. 

    3 FORMAT(T2,I5)

      BACKSPACE(31)
      READ(31,3) NDRUG
      READ(31,3) NADD
      READ(31,3) ND
      NI = 2*NDRUG + NADD
      INTLIST(5) = NDRUG
      INTLIST(6) = NADD
      INTLIST(7) = NI

C  IF THERE ARE NO DOSE EVENTS (ND = 0), THE INFO ON FILE 41 WILL BE THE
C  SAME AS ON FILE 31 (SINCE THERE CAN BE NO STEADY STATE DOSE EVENTS IF
C  THERE ARE NO DOSES). IN THIS CASE, SET ICOPY = 1 (SEE BELOW).

      IF(ND .EQ. 0) ICOPY = 1

C  IF ANY SIG(.) IS NEGATIVE, SET ICOPY = 0 SINCE A SIG(.) < 0 IS THE
C  INDICATOR FOR A STEADY STATE SET OF DOSES.


      IF(ND .GE. 1) THEN

       READ(31,*)
       READ(31,*)

       ICOPY = 1

       DO I = 1,ND
        READ(31,*) SIG(I),(RS(I,J),J=1,NI)
        IF(SIG(I) .LT. 0.D0) ICOPY = 0
       END DO


      ENDIF

  
C  IF ICOPY = 1, IT MEANS THAT THIS PATIENT DATA FILE DOES NOT HAVE
C  A STEADY STATE DOSE SET, WHICH MEANS THAT THIS PART OF FILE 31 WILL 
C  BE COPIED LINE FOR LINE TO FILE 41 BELOW.

      IF(ICOPY .EQ. 1) THEN

C  COPY FILE 31 TO FILE 41,LINE FOR LINE.

C  BACKSPACE FILE 31 TO THE FIRST LINE FOR THIS PATIENT.

 1720  BACKSPACE(31)
       BACKSPACE(31)
       READ(31,1717,IOSTAT=IEND) READLINE

	 IF(IEND .LT. 0) THEN

C  NOTE THAT IEND .LT. 0 --> END OF FILE REACHED, BUT IF IT'S REACHED
C  AT THIS POINT, NOT ALL "ACTIVE" NSUB SUBJECT DATA SETS WERE READ
C  AND WRITTEN CORRECTLY TO FILE 41. IN THIS CASE, WRITE A MESSAGE TO
C  THE USER AND STOP.

        WRITE(*,1721)
 1721   FORMAT(/' PATIENT DATA INFORMATION WAS NOT READ CORRECTLY'/
     1' FROM THE INSTRUCTION FILE - IN SUBROUTINE NEWWORK1.')

C  SINCE THE PROGRAM IS TERMINATING ABNORMALLY, WRITE THE ERROR MESSAGE
C  TO ERRFIL ALSO.

        OPEN(42,FILE=ERRFIL)
         WRITE(42,1721)
        CLOSE(42)

	  CALL PAUSE
	  STOP

	 ENDIF

       IF(READLINE(3:16) .NE. 'LAST AND FIRST') GO TO 1720

       WRITE(41,1717) READLINE
     
   30  READ(31,1717) READLINE
       WRITE(41,1717) READLINE
   
       IF(READLINE(12:23) .NE. 'NO. OF DOSE ') GO TO 30

C  THE LINE JUST WRITTEN TO FILE 41 IS THE NO. OF DOSE EVENTS LINE.

C  WRITE THE NEXT TWO LINES ALSO.

       DO I = 1,2
        READ(31,1717) READLINE
        WRITE(41,1717) READLINE
       END DO

C  IF ND = 0, SKIP TO THE OUTPUT SECTION. OTHERWISE, WRITE THE DOSAGE
C  REGIMEN TO FILE 41.


       IF(ND.EQ.0) GO TO 40

       DO I = 1,ND
        READ(31,*) SIG(I),(RS(I,J),J=1,NI)
        WRITE(41,*) SIG(I),(RS(I,J),J=1,NI)
       END DO

C  READ THE NO. OF OUTPUT EQUATIONS FROM THE LINE WITH 'NO. OF TOTAL'
C  AS ENTRIES 12:23. THEN READ NO. OF OBSERVED VALUE TIMES, ETC., AND
C  WRITE THE REST OF THE FILE 31 TO FILE 41.

   40	 READ(31,1717) READLINE
       WRITE(41,1717) READLINE
       IF(READLINE(12:23) .NE. 'NO. OF TOTAL') GO TO 40


       BACKSPACE(31)

       READ(31,3) NUMEQT
       READ(31,3) M
       INTLIST(9) = NUMEQT
       INTLIST(10) = M


C  BACKSPACE JUST ONCE TO THE LINE WITH M ON IT, SINCE THE LINE WITH

C  NUMEQT ON IT WAS ALREADY PUT INTO FILE 41. 

       BACKSPACE(31)
       READ(31,1717) READLINE
       WRITE(41,1717) READLINE

       DO I = 1,M
        READ(31,*) TIM(I),(YO(I,J),J=1,NUMEQT)
        WRITE(41,*) TIM(I),(YO(I,J),J=1,NUMEQT)
       END DO

C  NOW COPY LINE FOR LINE THE REST OF THIS PATIENT'S INFO TO FILE 41.
C  THIS PATIENT'S INFO WILL END WHEN THE END OF THE FILE IS REACHED
C  (IF THIS IS THE LAST PATIENT), OR WHEN THE START OF THE NEXT
C  PATIENT OCCURS.



   50	 READ(31,1717,IOSTAT=IEND) READLINE
       IF(IEND .LT. 0) GO TO 100
   	 IF(READLINE(3:16) .EQ. 'LAST AND FIRST') GO TO 100

       WRITE(41,1717) READLINE
       GO TO 50


  100	 CLOSE(31)

C  IN THIS PROGRAM, FILE 31 IS CLOSED HERE, SINCE IT WILL BE REOPENED

C  EACH TIME ANOTHER SUBJECT IS TO BE CREATED IN SUBROUTINE SIMBIG.


      ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(ICOPY .EQ. 1)  CONDITION.


      IF(ICOPY .EQ. 0) THEN


C  SINCE ICOPY = 0, IT MEANS THAT THERE IS AT LEAST ONE SET OF STEADY
C  STATE DOSES IN THE DOSAGE BLOCK. THE LOGIC FOR TRANSLATING THESE
C  STEADY STATE DOSES TO A REGULAR DOSAGE BLOCK (EXCEPT FOR THE NEGATIVE
C  DOSE TIME AT THE START OF EACH STEADY STATE DOSE SET) IS AS FOLLOWS:

C  EACH DOSAGE LINE WILL BE COPIED UNALTERED UNLESS IT IS PART OF A
C  STEADY STATE SET.



C  EACH STEADY STATE SET STARTS WITH A SIG(I) < 0. IN THIS CASE, 101
C  DOSES WILL BE APPLIED AT THIS POINT WITH THE STEADY STATE DOSE FOR
C  DRUG IDRUG = RS(I,2*IDRUG), WHICH WILL BE APPLIED AS A BOLUS IF
C  RS(I,2*IDRUG-1) = 0, AND AS AN IV WITH DURATION
C  RS(I,2*IDRUG)/RS(I,2*IDRUG-1) IF RS(I,2*IDRUG-1) > 0.
C  THE REST OF THE DOSE TIMES IN THIS BLOCK OF DOSES (I.E., UNTIL THE
C  NEXT TIME RESET OR STEADY STATE DOSE INDICATOR) WILL BE INCREASED
C  BY 100*DELDOSE, WHERE DELDOSE = -SIG(I) = INTERDOSE INTERVAL FOR
C  THIS SET.


C  ILINE WILL BE THE RUNNING INDEX OF THE NEXT DOSAGE LINE TO BE PUT


C  INTO THE ALTERED DOSAGE REGIMEN. SIGG(ILINE) AND RSS(ILINE,.) ARE
C  THE VALUES THAT GO INTO THIS LINE. DELDOSE IS THE CURRENT INTERDOSE
C  TIME INTERVAL FOR THE LAST STEADY STATE SET OF DOSES ALREADY PUT
C  INTO THE ALTERED DOSAGE REGIMEN (IT IS INITIALIZED TO BE 0 OF 
C  COURSE). 


C  AND NSECTION IS INITIALIZED TO BE 0. IT WILL BE THE RUNNING NO. OF
C  DOSAGE SECTIONS. EACH SECTION BEGINS WITH EITHER A 0.0 (BEGINNING
C  LINE OR TIME RESET) OR A NEGATIVE NO. (STEADY STATE DOSE SET 
C  INDICATOR). THE TIME DELAY ASSOCIATED WITH EACH DOSE SECTION (WHICH
C  WILL BE 0 IF THAT SECTION IS NOT A STEADY STATE DOSE SET), MUST BE 
C  STORED TO BE APPLIED TO THE CORRESPONDING SET OF OBSERVED VALUES
C  BELOW.

      ILINE = 0
      DELDOSE = 0.D0
      NSECTION = 0

      DO ID = 1,ND


       IF(SIG(ID) .GE. 0.D0) THEN

        CALL THESAME(SIG(ID),0.D0,ISAME)

        IF(ISAME .EQ. 1) THEN
         DELDOSE = 0.D0
         NSECTION = NSECTION + 1
         TIMDELAY(NSECTION) = 0.0
        ENDIF   



C  NOTE THAT IF SIG(ID) = 0, THIS LINE IS A TIME RESET LINE, OR THE
C  FIRST LINE IN THE DOSAGE REGIMEN. IF IT'S THE FIRST LINE IN THE
C  DOSAGE REGIMEN, THERE ARE OBVIOUSLY NO PREVIOUS STEADY STATE DOSE
C  SETS. IF ITS A TIME RESET LINE, A PREVIOUS SET OF 101 STEADY STATE
C  DOSES HAS NO EFFECT ON IT. THAT'S WHY DELDOSE IS SET = 0, WHICH 
C  MEANS, BELOW, THAT SIGG(ILINE) WILL = SIG(ID) = 0. ALSO, THE TIME


C  DELAY STORED IN TIMDELAY ABOVE IS 0 SINCE SIG(ID) .GE. 0 --> THIS
C  IS NOT A STEADY STATE DOSE SET.
        
        ILINE = ILINE + 1
        SIGG(ILINE) = SIG(ID) + 100.D0*DELDOSE

        DO J = 1,NI
         RSS(ILINE,J) = RS(ID,J)
        END DO
       
       ENDIF


       IF(SIG(ID) .LT. 0.D0) THEN




C  THIS LINE GIVES INFO ON A STEADY STATE SET OF 101 DOSES WHICH IS
C  TO APPLIED AT THIS POINT.

        DO IDRUG = 1,NDRUG

C  FOR DRUG, IDRUG, THE AMOUNT OF DRUG FOR DRUG NO. IDRUG IN EACH OF THE
C  101 DOSES WILL BE RS(ID,2*IDRUG). IF RS(ID,2*IDRUG) > 0, DRUG, IDRUG,
C  PARTICIPATES IN THE STEADY STATE DOSING. IF THIS VALUE = 0, DRUG,
C  IDRUG, DOES NOT PARTICIPATE. NOTE THAT IF A DRUG PARTICIPATES, THE
C  ROUTE WILL BE AS AN IV, WITH RATE RS(ID,2*IDRUG-1), IF 
C  RS(ID,2*IDRUG-1) > 0. BUT IF THIS VALUE IS 0, THE DRUG WILL BE GIVEN
C  AS A BOLUS. NOTE THAT THE INTERVAL BETWEEN DOSES IS -SIG(ID).

C  IF DRUG, IDRUG, PARTICIPATES IN THE 101 STEADY STATE DOSE SET, PUT 
C  THE DURATION OF IV INTO DELTAIV(IDRUG) IF RS(ID,2*IDRUG-1) > 0;
C  OTHERWISE PUT 0 INTO DELTAIV(IDRUG) SINCE IN THIS CASE, THE DRUG IS
C  GIVEN AS A BOLUS.


         DELTAIV(IDRUG) = 0.D0 
         IF(RS(ID,2*IDRUG) .GT. 0.D0 .AND. RS(ID,2*IDRUG-1) .GT. 0.D0) 
     1    DELTAIV(IDRUG) = RS(ID,2*IDRUG)/RS(ID,2*IDRUG-1) 

C  IT SHOULD NOT BE POSSIBLE FOR THE IV OF THIS DRUG TO BE > 0 AT THE
C  SAME TIME THAT THE BOLUS ENTRY = 0. THIS WOULD MEAN THAT AN IV
C  WAS TO BE GIVEN AT A SPECIFIED RATE, BUT WITH A TOTAL DOSE OF 0,
C  AND THIS MAKES NO SENSE. IF, SOMEHOW, THIS HAS OCCURRED, REPORT IT
C  TO THE USER AS AN ERROR, AND STOP.


C  REPLACE WRITING OF SIG(),RS() WITH XVERIFY (SEE LOGIC IN 
C  SUBROUTINE VERIFYVAL).

         IF(RS(ID,2*IDRUG) .LE. 0.D0 .AND. RS(ID,2*IDRUG-1) .GT. 0) THEN
          XVERIFY(1) = SIG(ID)
          XVERIFY(2) = RS(ID,2*IDRUG-1)
          XVERIFY(2) = RS(ID,2*IDRUG) 
          CALL VERIFYVAL(3,XVERIFY)
C         WRITE(*,101) ID,SIG(ID),IDRUG,RS(ID,2*IDRUG-1),RS(ID,2*IDRUG)
          WRITE(*,101) ID,XVERIFY(1),IDRUG,XVERIFY(2),XVERIFY(3)

  101     FORMAT(//' THERE IS AN ERROR IN YOUR INSTRUCTION FILE, AS'/
     1' DETERMINED BY SUBROUTINE NEWWORK1.'//
     2' ONE OF THE SUBJECTS HAS A STEADY STATE DOSE SET WITH A '/
     3' POSITIVE IV RATE, BUT WITH A TOTAL DOSE AMOUNT .LE. 0.'//
     4' IN PARTICULAR, FOR DOSE EVENT ',I4,' AND TIME ',G19.9,/
     5' FOR DRUG ',I2,', THE IV VALUE IS ',G19.9,' WHILE THE TOTAL'/
     6' DOSE AMOUNT IS ',G19.9//
     7' THE PROGRAM STOPS. PLEASE CORRECT THE ERROR BEFORE RERUNNING.'/)

C  SINCE THE PROGRAM IS TERMINATING ABNORMALLY, WRITE THE ERROR MESSAGE
C  TO ERRFIL ALSO.

        OPEN(42,FILE=ERRFIL)
C        WRITE(42,101) ID,SIG(ID),IDRUG,RS(ID,2*IDRUG-1),RS(ID,2*IDRUG)
         WRITE(42,101) ID,XVERIFY(1),IDRUG,XVERIFY(2),XVERIFY(3)


        CLOSE(42)

          CALL PAUSE
          STOP

         ENDIF
 
        END DO

        
C  CALL SUBROUTINE ORDERDELTA TO OBTAIN NDELTA, THE NO. OF UNIQUE
C  NON-0 VALUES IN THE DELTAIV(.) ARRAY JUST ESTABLISHED ABOVE, AND TO
C  PUT THE ORDERED SET OF THESE NDELTA VALUES INTO ORDELT(.).

C  NOTE THAT IF DELTAIV(IDRUG) = 0, IT MEANS THAT DRUG, IDRUG, DOES NOT
C  PARTICIPATE IN THE STEADY STATE DOSE SET, OR IF IT DOES, IT IS GIVEN
C  AS A BOLUS RATHER THAN AN IV.

        CALL ORDERDELTA(NDRUG,DELTAIV,NDELTA,ORDELT)

C  NOW ESTABLISH THE LINES WITH SIGG(.) AND RSS(.,.) AS FOLLOWS:

C  1. THE NEXT 101*(NDELTA + 1) ROWS WILL BE FOR THE STEADY STATE
C  DOSE SET (I.E., EACH OF THE 101 REPEATED DOSES HAS A START TIME,
C  AND THEN NDELTA ENDING TIMES AMONG ALL NDRUG DRUGS). NOTE THAT
C  NDELTA WILL BE 0 IF ALL THE PARTICIPATING DRUGS ARE BOLUSES SINCE
C  THEY WOULDN'T NEED AN ENDING TIME THEN.

C  2. EVERY ROW OF THE ORIGINAL DOSAGE REGIMEN AFTER LINE ID
C  WILL HAVE THE SAME VALUES IN RSS(.,.) AS IN RS(.,.), BUT THE
C  TIMES IN SIGG(.) WILL ALL BE INCREASED BY 100*DELDOSE OVER THOSE
C  IN SIG(.) ... UP TO BUT NOT INCLUDING THE NEXT TIME RESET EVENT
C  OR NEXT STEADY STATE DOSE INDICATOR LINE, WHERE DELDOSE IS THE TIME
C  INCREMENT BETWEEN CONSECUTIVE DOSES IN THE 101 STEADY STATE DOSE SET.
C  NOTE THAT DELDOSE IS THE NEGATIVE OF SIG(ID).

        DELDOSE = -SIG(ID)        
        NSECTION = NSECTION + 1
        TIMDELAY(NSECTION) = 100.D0*DELDOSE

C  NOTE THAT THE TIME DELAY ASSOCIATED WITH THIS STEADY STATE SET IS
C  STORED INTO TIMDELAY ABOVE SO THAT IT CAN BE APPLIED TO THE 
C  CORRESPONDING SET OF OBSERVED VALUES BELOW.


        DO ISET = 1,101

C  FOR EACH SET, ESTABLISH NDELTA + 1 ROWS (DOSE EVENT LINES).

C  THE FIRST ROW IN THIS SET HAS EACH DRUG IV SET = RS(ID,2*IDRUG-1),
C  AND, FOR EACH DRUG IV WHICH IS 0, THE BOLUS VALUE WILL BE SET =
C  RS(ID,2*IDRUG). NOTE THAT IF A DRUG IV > 0, THE BOLUS VALUE WILL BE
C  SET = 0 SINCE IN THIS CASE, THE VALUE IN THE BOLUS COLUMN IS THE
C  TOTAL AMOUNT OF IV (NOT A BOLUS AMOUNT).

         ILINE = ILINE + 1

         DO IDRUG = 1,NDRUG
          RSS(ILINE,2*IDRUG-1) = RS(ID,2*IDRUG-1)
          RSS(ILINE,2*IDRUG) = RS(ID,2*IDRUG)
          IF(RS(ID,2*IDRUG-1) .GT. 0.D0) RSS(ILINE,2*IDRUG) = 0.D0
         END DO

C  SET ALL THE COVARIATE VALUES = TO THOSE IN LINE ID OF RS OF COURSE.

         DO IADD = 1,NADD
          RSS(ILINE,2*NDRUG+IADD) = RS(ID,2*NDRUG+IADD)
         END DO

C  THE TIME FOR THIS ROW IS (ISET-1)*DELDOSE, EXCEPT FOR THE FIRST
C  LINE, WHICH MUST HAVE THE SAME NEGATIVE VALUE AS IN SIG, SINCE
C  THE ID ROUTINES MUST READ THE NEGATIVE SIG VALUE TO KNOW THAT A
C  STEADY STATE DOSE SET IS STARTING.

         IF(ISET .EQ. 1) THEN
          SIGG(ILINE) = SIG(ID)
          DOSESTART = 0.D0
         ENDIF

         IF(ISET .GT. 1) THEN
          SIGG(ILINE) = (ISET-1)*DELDOSE
          DOSESTART = SIGG(ILINE)
         ENDIF

C  THE NEXT NDELTA ROWS ARE THE IV TURN OFF ROWS FOR THE VARIOUS DRUGS,
C  IF NDELTA > 0. NOTE THAT NDELTA COULD = 0 IF ALL PARTICIPATING DRUGS
C  ARE GIVEN VIA A BOLUS, SINCE THEN NONE WOULD NEED A TURN OFF ROW.

        IF(NDELTA .GT. 0) THEN

         DO INDEL = 1,NDELTA

          ILINE = ILINE + 1

C  THE NEXT TURN OFF TIME IS DOSESTART + ORDELT(INDEL). EACH IV WILL BE
C  OFF UNLESS ITS DELTAIV(.) IS .GT ORDELT(INDEL). AND EACH BOLUS VALUE
C  WILL BE 0 OF COURSE (I.E., EACH BOLUS IS GIVEN JUST ONE TIME AT THE
C  START OF EACH SET).

          DO IDRUG = 1,NDRUG
           RSS(ILINE,2*IDRUG-1) = 0.D0
           IF(DELTAIV(IDRUG) .GT. ORDELT(INDEL))
     1      RSS(ILINE,2*IDRUG-1) = RS(ID,2*IDRUG-1)        
           RSS(ILINE,2*IDRUG) = 0.D0
          END DO

C  SET ALL THE COVARIATE VALUES = TO THOSE IN LINE ID OF RS AGAIN.

          DO IADD = 1,NADD
           RSS(ILINE,2*NDRUG+IADD) = RS(ID,2*NDRUG+IADD)
          END DO

C  THE TIME FOR THIS ROW IS DOSESTART + ORDELT(INDEL)

          SIGG(ILINE) = DOSESTART + ORDELT(INDEL)

         END DO   

C  THE ABOVE END DO IS FOR THE  DO INDEL = 1,NDELTA  LOOP.  

        ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(NDELTA .GT. 0)  CONDITION.

 
        END DO

C  THE ABOVE END DO IS FOR  DO ISET = 1,101  LOOP.



       ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(SIG(ID) .LT. 0.D0)  CONDITION.


      END DO

C  THE ABOVE END DO IS FOR THE  DO ID = 1,ND  LOOP.


C  THIS COMPLETES THE ESTABLISHMENT OF RSS(.,.) AND SIGG(.) ABOVE.


C  NOW ALTER THE OBSERVED VALUE TIMES BY ADDING THE APPROPRIATE VALUE
C  IN TIMDELAY(.) TO EACH OBSERVED VALUE TIME BELOW. NOTE THAT
C  TIMDELAY(1) APPLIES TO ALL TIMES BEFORE THE FIRST TIME RESET,
C  TIMDELAY(2) APPLIES TO THE NEXT SET OF TIMES AFTER THE FIRST 
C  TIME RESET BUT BEFORE THE 2ND, ETC. IF THERE ARE NO TIME RESETS,
C  ALL TIMES WILL HAVE TIMDELAY(1) ADDED TO THEM, AND THIS VALUE WILL
C  BE 0.0 (SEE DOSAGE BLOCK CODE ABOVE - IF THERE ARE NO TIME RESETS
C  OR STEADY STATE DOSE SETS, TIMDELAY(1) IS SET = 0).


   20  READ(31,1717) READLINE

       IF(READLINE(12:23) .NE. 'NO. OF TOTAL') GO TO 20
       BACKSPACE(31)
       READ(31,3) NUMEQT
       READ(31,3) M
       INTLIST(9) = NUMEQT
       INTLIST(10) = M


       NSECTION = 1

       DO I = 1,M
        READ(31,*) TIM(I),(YO(I,J),J=1,NUMEQT)
        CALL THESAME(TIM(I),0.D0,ISAME)
        IF(ISAME .EQ. 1 .AND. I .GT. 1) NSECTION = NSECTION + 1

        IF(ISAME .EQ. 1) TIMM(I) = 0.D0   
        IF(ISAME .EQ. 0) TIMM(I) = TIM(I) + TIMDELAY(NSECTION)
       END DO


C  NOW COPY THIS PART OF FILE 31 TO FILE 41 WITH THE FOLLOWING
C  EXCEPTIONS:
C   1. ND WILL BE REPLACED BY ILINE (THE TOTAL NO. OF DOSAGE LINES IN
C      THE ALTERED DOSAGE REGIMEN).
C   2. SIG(.) WILL BE REPLACED BY SIGG(.).
C   3. RS(.,.) WILL BE REPLACED BY RSS(.,.)
C   4. TIM(.) WILL BE REPLACED BY TIMM(.)
C   NOTE THAT YO(.,.) WILL BE UNCHANGED.

C  BACKSPACE FILE 31 TO THE FIRST LINE FOR THIS PATIENT.

 1820  BACKSPACE(31)
       BACKSPACE(31)
       READ(31,1717,IOSTAT=IEND) READLINE

	 IF(IEND .LT. 0) THEN

C  NOTE THAT IEND .LT. 0 --> END OF FILE REACHED, BUT IF IT'S REACHED

C  AT THIS POINT, NOT ALL "ACTIVE" NSUB SUBJECT DATA SETS WERE READ
C  AND WRITTEN CORRECTLY TO FILE 41. IN THIS CASE, WRITE A MESSAGE TO
C  THE USER AND STOP.

        WRITE(*,1721)

C  SINCE THE PROGRAM IS TERMINATING ABNORMALLY, WRITE THE ERROR MESSAGE
C  TO ERRFIL ALSO.

        OPEN(42,FILE=ERRFIL)
         WRITE(42,1721) 
        CLOSE(42)

	  CALL PAUSE
	  STOP

	 ENDIF

       IF(READLINE(3:16) .NE. 'LAST AND FIRST') GO TO 1820


       WRITE(41,1717) READLINE

   60  READ(31,1717) READLINE
       WRITE(41,1717) READLINE
   
       IF(READLINE(12:23) .NE. 'NO. OF ADDIT') GO TO 60

C  THE LINE JUST WRITTEN TO FILE 41 IS THE NO. OF ADDITIONAL COVARIATES
C  LINE. WRITE THE NEXT LINE BUT CHANGE FROM ND TO ILINE AS THE NO.
C  OF DOSE EVENTS.

       READ(31,1717) READLINE
       WRITE(41,133) ILINE
  133  FORMAT(I6,' ... NO. OF DOSE EVENTS')

C  WRITE THE NEXT TWO LINES TO FILE 41 (INCLUDING THE HEADER LINE FOR
C  THE DOSAGE BLOCK).

       DO I = 1,2
        READ(31,1717) READLINE
        WRITE(41,1717) READLINE
       END DO

C  WRITE THE NEW DOSAGE BLOCK.

       SIGLAST = -999999.D0



       DO I = 1,ILINE

        WRITE(41,*) SIGG(I),(RSS(I,J),J=1,NI)

C  AS OF MONT110.FOR, MAKE SURE THAT NO TWO TIMES ARE THE SAME SINCE
C  IF THEY ARE, IT CAN CONFUSE SUBROUTINE SHIFT (CAUSING IT TO GO INTO
C  AN INFINITE LOOP - SEE NPAG115.EXP, TESTCASE 5).

        CALL THESAME(SIGLAST,SIGG(I),ISAME)

        IF(ISAME .EQ. 1) THEN

C  REPLACE WRITING OF SIGLAST WITH XVERIFY (SEE LOGIC IN 
C  SUBROUTINE VERIFYVAL).

         XVERIFY(1) = SIGLAST
         CALL VERIFYVAL(1,XVERIFY)

C        WRITE(*,4031) SIGLAST
         WRITE(*,4031) XVERIFY(1)
 4031    FORMAT(/' IN SUBROUTINE NEWWORK1, TWO CONSECUTIVE DOSE TIMES'/
     1' HAVE THE SAME VALUE IN WORKING COPY FORMAT, ',F20.8//
     2' THIS COULD CAUSE UNEXPECTED RESULTS IF THE PROGRAM WERE TO '/
     3' CONTINUE. SO THE PROGRAM NOW STOPS. PLEASE CHECK YOUR PATIENT '/
     4' INFORMATION AND CORRECT (NOTE THAT THIS CAN HAPPEN IF THE '/
     5' FIRST DOSE FOLLOWING A STEADY STATE DOSE SET HAS THE SAME'/
     6' STARTING TIME AS THE ENDING TIME OF THE LAST STEADY STATE '/
     7' DOSE SET.)'//)

C  SINCE THE PROGRAM IS TERMINATING ABNORMALLY, WRITE THE ERROR MESSAGE
C  TO ERRFIL ALSO.

        OPEN(42,FILE=ERRFIL)
C        WRITE(42,4031) SIGLAST
         WRITE(42,4031) XVERIFY(1)

        CLOSE(42)

	  CALL PAUSE


	  STOP

	 ENDIF

       SIGLAST = SIGG(I)





       END DO
C??? ABOVE END DO IS FOR THE  DO I = 1,ILINE  LOOP.




C  READ THROUGH FILE 31 DOWN TO THE END OF THE DOSAGE BLOCK


       DO I = 1,ND
        READ(31,*) SIG(I),(RS(I,J),J=1,NI)
       END DO
 
C  PUT THE BLANK LINE BETWEEN THE DOSAGE BLOCK AND THE OBSERVATION
C  BLOCK TO FILE 41, ALONG WITH THE TWO LINES WHICH GIVE THE NO. OF
C  OUTPUT EQS. AND THE NO. OF OBSERVED VALUE TIMES.


       DO I = 1,3
        READ(31,1717) READLINE
        WRITE(41,1717) READLINE
       END DO

C  WRITE THE OBSERVED BLOCK TO FILE 41, AND READ THROUGH IT IN FILE 31.

      DO I = 1,M
       WRITE(41,*) TIMM(I),(YO(I,J),J=1,NUMEQT)
       READ(31,*) TIM(I),(YO(I,J),J=1,NUMEQT)
      END DO
 
C  NOW COPY LINE FOR LINE THE REST OF THIS SUBJECT'S INFO TO FILE 41.
C  THIS PATIENT'S INFO WILL END WHEN THE END OF THE FILE IS REACHED
C  (IF THIS IS THE LAST PATIENT), OR WHEN THE START OF THE NEXT
C  PATIENT OCCURS.

   70	 READ(31,1717,IOSTAT=IEND) READLINE
       IF(IEND .LT. 0) GO TO 200
   	 IF(READLINE(3:16) .EQ. 'LAST AND FIRST') GO TO 200
       WRITE(41,1717) READLINE
       GO TO 70
  200	 CLOSE(31)

C  IN THIS PROGRAM, FILE 31 IS CLOSED HERE, SINCE IT WILL BE REOPENED
C  EACH TIME ANOTHER SUBJECT IS TO BE CREATED IN SUBROUTINE SIMBIG.


      ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(ICOPY .EQ. 0)  CONDITION.


      RETURN
      END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
      SUBROUTINE Old_ORDERDELTA(NDRUG,DELTAIV,NDELTA,ORDELT)

      use npag_utils, only: thesame

      IMPLICIT REAL*8(A-H,O-Z)
      DIMENSION DELTAIV(7),ORDELT(7),X(7)

C  SUBROUTINE ORDERDELTA IS CALLED BY NEWWORK1 TO OBTAIN NDELTA, THE NO.
C  OF UNIQUE NON-0 VALUES IN THE DELTAIV(.) ARRAY. THEN THE ORDERED SET
C  OF THESE NDELTA VALUES IS PUT INTO ORDELT(.). NOTE THAT
C  NDELTA WILL BE 0 IF ALL THE PARTICIPATING DRUGS ARE BOLUSES SINCE
C  THEY WOULDN'T NEED AN ENDING TIME THEN.


C  FIRST STORE ALL THE VALUES IN DELTAIV INTO X SO THAT DELTAIV WILL
C  NOT BE CHANGED.

      DO IDRUG = 1,NDRUG
       X(IDRUG) = DELTAIV(IDRUG)
      END DO


C  THE LOGIC OF THIS ROUTINE IS BASED ON \PERSONAL\FINANCE\ORDER.FOR.
C  TO DO THIS, EACH VALUE IN X(.) WILL BE COMPARED TO THE
C  PREVIOUS ONE. IF IT IS < THE PREVIOUS ONE, THE VALUE WILL EXCHANGE
C  PLACES WITH THE PREVIOUS ONE, AND THE TESTING WILL CONTINUE. THE
C  TESTING WILL STOP FOR A VALUE WHEN IT IS COMPARED TO A PREVIOUS
C  VALUE WHICH IS .LE. ITS VALUE.

      DO IDRUG = 2, NDRUG

C  COMPARE VALUE FOR IDRUG WITH EACH PREVIOUS VALUE, AND HAVE IT 
C  EXCHANGE PLACES WITH THAT VALUE, UNTIL IT REACHES ONE WHICH HAS A 
C  SMALLER VALUE. FIRST SET IDRUGNEW = IDRUG; AFTER THE FOLLOWING
C  CODE, IDRUGNEW WILL BE THE INDEX NO. FOR VALUE AT THE OLD IDRUG
C  POSITION.

       IDRUGNEW = IDRUG

       ICOMP = IDRUG 

  110  ICOMP = ICOMP - 1

C  NOW COMPARE VALUE IN LOCATION ICOMP WITH THE VALUE IN LOCATION
C  IDRUGNEW. IF THE LATTER IS .LT. THE FORMER, INTERCHANGE THE RECORDS.

       IF(X(IDRUGNEW) .LT. X(ICOMP)) THEN

        VALUE = X(IDRUGNEW)
        X(IDRUGNEW) = X(ICOMP)         
        X(ICOMP) = VALUE
        IDRUGNEW = ICOMP


C  IF IDRUGNEW = 1, IT HAS BEEN CHECKED AGAINST ALL RECORDS (AND IS
C  THE SMALLEST VALUE); IF IS IS > 1, CONTINUE THE PROCESS.

        IF(IDRUGNEW .EQ. 1) GO TO 150
        IF(IDRUGNEW .GT. 1) GO TO 110

       ENDIF

C  THE ABOVE ENDIF IS FOR THE 
C   IF(X(IDRUGNEW) .LT. X(ICOMP))  CONDITION.


  150 END DO

C  THE ABOVE END DO IS FOR THE  DO IDRUG = 2, NDRUG LOOP.


C  NOW THE NDRUG VALUES ARE ORDERED, FROM SMALL TO LARGE IN X.
C  REWRITE THEM INTO ORDELT, BUT PUT ONLY THE NON-0 AND
C  UNIQUE VALUES INTO ORDELT, AND KEEP TRACK OF NOW MANY OF THESE
C  UNIQUE NON O VALUES THERE ARE - IT WILL BE NDELTA AT THE END OF
C  THE FOLLOWING LOOP.

      NDELTA = 0 

      DO IDRUG = 1,NDRUG

C  FOR THIS VALUE TO BE COUNTED, IT CANNOT = THE PREVIOUS VALUE, AND
C  IT CANNOT = 0.

       IF(IDRUG .EQ. 1 .AND. X(IDRUG) .GT. 0) THEN
        NDELTA = NDELTA + 1
        ORDELT(NDELTA) = X(IDRUG)
       ENDIF


       IF(IDRUG .GE. 2) THEN

        CALL THESAME(X(IDRUG),X(IDRUG-1),ISAME)

        IF(ISAME .EQ. 0) THEN
         NDELTA = NDELTA + 1
         ORDELT(NDELTA) = X(IDRUG)
        ENDIF

       ENDIF

      END DO 

C  THE ABOVE END DO IS FOR THE  DO IDRUG = 1,NDRUG  LOOP.


      RETURN
      END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C

	SUBROUTINE STOREOBSER(INTLIST)
	IMPLICIT REAL*8(A-H,O-Z)

	PARAMETER(MAXNUMEQ=7)

      DIMENSION TIM(594),SIG(5000),RS(5000,34),YO(594,MAXNUMEQ),
     1 BS(5000,7)

        integer, dimension(128) :: INTLIST

	CHARACTER SEX*1,READLINE*300,ERRFIL*20



      COMMON/ERROR/ERRFIL
C  COMMON/ERROR/ IS SUPPLIED TO ALL THE ROUTINES WHICH COULD WRITE TO
C  ERRFIL.


C  THIS ROUTINE IS CALLED BY SIMBIG JUST TO READ ALREADY OPENED 
C  SCRATCH FILE 41 AND PUT THE INFO FROM THAT WORKING COPY FILE (WHICH
C  IS THE IN THE FORM EXPECTED BY SUBROUTINE FUNC2, AFTER BEING CREATED
C  BY SUBROUTINE NEWWORK1) INTO THE ARRAYS THAT FUNC2 NEEDS.

	COMMON/OBSER/ TIM,SIG,RS,YO,BS
	COMMON/CNST/ N,ND,NI,NUP,NUIC,NP
	COMMON/CNST2/ NPL,NUMEQT,NDRUG,NADD

	COMMON/SUM2/ M,NPNL
	COMMON/DESCR/AGE,HEIGHT,ISEX,IETHFLG

C  AGE, SEX, HEIGHT, AND ETHNICITY FLAG ARE ON LINES 8-11.

	DO I=1,7
	 READ(41,*)
	END DO
	 
	READ(41,*) AGE
	READ(41,2) SEX
    2   FORMAT(A1)
	ISEX=1
	IF(SEX .EQ. 'F') ISEX=2

	READ(41,*) HEIGHT
	READ(41,*) IETHFLG

        INTLIST(1) = int(AGE)
        INTLIST(2) = ISEX
        INTLIST(3) = int(HEIGHT)
        INTLIST(4) = IETHFLG

C  READ THE NO. OF DRUGS FROM THE LINE WITH 'NO. OF DRUGS' AS ENTRIES
C  12:23. THEN READ NO. OF ADDITIONAL COVARIATES, AND THE NO. OF DOSE 
C  EVENTS, ETC.

    1   FORMAT(A300)
   10	READ(41,1) READLINE

	IF(READLINE(12:23) .NE. 'NO. OF DRUGS') GO TO 10
	BACKSPACE(41)

    3   FORMAT(T2,I5)
        READ(41,3) NDRUG
        INTLIST(5) = NDRUG

	IF(NDRUG .GT. 7) THEN

	 WRITE(*,124)
  124  FORMAT(' YOUR PATIENT DATA FILES CANNOT HAVE MORE THAN 7'/
     1' DRUGS. THE PROGRAM IS NOW STOPPING. '/)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,124) 
        CLOSE(42)



       CALL PAUSE
	 STOP



	ENDIF

        READ(41,3) NADD
        INTLIST(6) = NADD


C  NOTE THAT THE NO. OF "RATES" INCLUDES 2 FOR EACH DRUG (THE IV AND
C  THE PO COLUMNS) + NADD (1 COLUMN FOR EACH ADDITIONAL COVARIATE 
C  BEYOND THE FIRST 4 ABOVE, AGE, SEX, HEIGHT, AND ETHNICITY FLAG).

	NI = 2*NDRUG + NADD
        INTLIST(7) = NI
	IF(NI .GT. 34) THEN

  	 WRITE(*,123)
  123    FORMAT(/' YOUR PATIENT DATA FILES HAVE TOO MANY COLUMNS IN '/
     1' THE DOSAGE REGIMEN BLOCK. THE NO. OF ADDITIONAL COVARIATES '/
     2' PLUS TWICE THE NO. OF DRUGS CANNOT EXCEED 34. THE PROGRAM IS'/
     3' NOW STOPPING. '/)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,123) 
        CLOSE(42)

	 CALL PAUSE
	 STOP

	ENDIF

        READ(41,3) ND
        INTLIST(8) = ND

	IF(ND .GT. 5000) THEN



	 WRITE(*,125)
  125  FORMAT(' YOUR PATIENT DATA FILES CANNOT HAVE MORE THAN 5000'/
     1' DOSE EVENTS. THE PROGRAM IS NOW STOPPING. '/)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,125) 
        CLOSE(42)



       CALL PAUSE
	 STOP



	ENDIF

	READ(41,*)
	READ(41,*)

        IF(ND.EQ.0) GO TO 40

	DO I = 1,ND
         READ(41,*) SIG(I),(RS(I,J),J=1,NI)
	END DO	 

C  ASSIGN THE VALUES IN EACH DRUG'S PO COLUMN TO THE CORRESPONDING
C  COLUMN IN ARRAY BS.

        DO I=1,ND
         DO J=1,NDRUG
          BS(I,J) = RS(I,2*J)
	 END DO
	END DO

C  READ THE NO. OF OUTPUT EQUATIONS FROM THE LINE WITH 'NO. OF TOTAL'
C  AS ENTRIES 12:23. THEN READ NO. OF OBSERVED VALUE TIMES, ETC.

   40	READ(41,1) READLINE
	IF(READLINE(12:23) .NE. 'NO. OF TOTAL') GO TO 40
	BACKSPACE(41)

        READ(41,3) NUMEQT
        READ(41,3) M
        INTLIST(9) = NUMEQT
        INTLIST(10) = M

	IF(M .GT. 594) THEN
	 WRITE(*,*) 'NO. OF OBSERVATIONS MUST BE .LE. 594'
	 WRITE(*,*) 'ONLY THE 1ST 594 OBSERVATION TIMES ARE USED.'
	 M=594
	ENDIF


	IF(NUMEQT .GT. MAXNUMEQ) THEN



  	 WRITE(*,127) NUMEQT,MAXNUMEQ 
  127    FORMAT(/' YOUR PATIENT DATA FILE HAS ',I3,' OUTPUT EQ.'/
     1' COLUMNS, WHICH IS MORE THAN ',I3,', THE MAX. ALLOWABLE NO. '/
     2' THE PROGRAM IS NOW STOPPING. '/)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,127) NUMEQT,MAXNUMEQ 
        CLOSE(42)



       CALL PAUSE
	 STOP



	ENDIF

      DO I=1,M
       READ(41,*) TIM(I),(YO(I,J),J=1,NUMEQT)
      END DO



      CLOSE(41)


	RETURN
	END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
      SUBROUTINE WRITESTEADY(NCOVA,NDRUG,IDOSE,SIG,RS,BS,DOSESTRING,
     1 SUBID,IDEVENT)

      use npag_utils, only: verifyval

      IMPLICIT REAL*8(A-H,O-Z)

      DIMENSION SIG(5000),RS(5000,34),BS(5000,7),XVERIFY(900)



      CHARACTER SUBID*11,DOSESTRING*12,BIGLINE*1000,SMALLLINE*1000,
     1  ERRFIL*20


      COMMON/ERROR/ERRFIL
C  COMMON/ERROR/ IS SUPPLIED TO ALL THE ROUTINES WHICH COULD WRITE TO
C  ERRFIL.

C  THIS ROUTINE, CALLED BY SUBROUTINE WRITECSV, WRITES INTO FILE 29 
C  STEADY STATE DOSE INFO FOR THE CURRENT LINE, ONE LINE FOR EACH

C  DRUG WHICH PARTICIPATES IN THE STEADY STATE DOSING.


C  IF IDEVENT = 4 (I.E., THIS IS A DOSE TIME RESET),  ONLY THE FIRST
C  ROW RELATED TO THIS EVENT SHOULD HAVE AN IDEVENT OF 4; SUBSEQUENT
C  ROWS MUST SHOW IDEVENT = 1. OTHERWISE, THE PROGRAM WILL THINK THAT 
C  THE 2ND ROW IS ANOTHER DOSE TIME RESET AFTER THE ONE IN THE 1ST ROW
C  (SEE CODE BELOW WHERE IDEVENT IS SET = 1 AFTER THE LINE FOR THE
C  FIRST PARTICIPATING DRUG IS WRITTEN).
  
C  THE TIME OF THIS DOSE IS SIG(IDOSE). DETERMINE WHICH DRUGS ARE
C  PARTIPATING IN THIS STEADY STATE DOSE SET. A DRUG PARTICIPATES IF
C  IT HAS AN ENTRY IN THE BOLUS COLUMN FOR THAT DRUG. NOTE THAT
C  IF A DRUG HAS AN ENTRY IN THE IV BUT NOT THE BOLUS COLUMN, IT IS AN
C  ERROR (SINCE FOR EACH OF THE 101 DOSES OF THE STEADY STATE SET, IT
C  MAKES NO SENSE TO HAVE A STEADY STATE IV WITHOUT KNOWING HOW MUCH
C  TOTAL DRUG IS ADMINISTERED).


      DO JDRUG = 1,NDRUG


C  FIRST VERIFY THAT DRUG, JDRUG, HAS POSITIVE ENTRIES IN ITS BOLUS
C  COLUMN IF IT HAS A POSTIVE ENTRY IN ITS IV COLUMN. IF THIS IS NOT 
C  TRUE, STOP THE PROGRAM AFTER WRITING AN ERROR MESSAGE.

       RIV = RS(IDOSE,2*JDRUG-1)

       RBOL = RS(IDOSE,2*JDRUG)

       IF(RIV .GT. 0.D0 .AND. RBOL .LE. 0.D0) THEN



        WRITE(*,1) SUBID,IDOSE,JDRUG
    1   FORMAT(/' ERROR IN SUBROUTINE WRITESTEADY.'//
     1' SUBJECT ',A11,' HAS AN ERROR IN ITS DOSAGE REGIMEN ...'/
     1' FOR DOSE NO. ',I5,' DRUG NO. ',I2,' HAS AN IV RATE WHICH MEANS'/
     2' IT IS SUPPOSED TO PARTICIPATE IN THE STEADY STATE DOSE SET,'/
     3' BUT THE ENTRY IN ITS "BOLUS" COLUMN, WHERE THE TOTAL DRUG AMT.'/


     4' FOR EACH IV OF THE STEADY STATE DOSE SET IS SUPPOSED TO BE '/
     5' IS .LE. 0.'//
     6' TO SEE THE PROBLEM, TAKE A LOOK AT THE WORKING COPY FILE THAT'/
     7' WAS SIMULATED. IF YOU DID NOT HAVE WORKING COPY FILES CREATED'/
     8' IN THIS RUN, RERUN THE PROGRAM, SELECT TO HAVE WORKING COPY '/
     9' FILES CREATED, AND THEN TAKE A LOOK AT THE PROBLEMATIC'/
     1' SUBJECT.'//
     2' THE PROGRAM STOPS.'//)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,1) SUBID,IDOSE,JDRUG 
        CLOSE(42) 



        CALL PAUSE
        STOP



       ENDIF



C  FOR DRUG, JDRUG, THE IV RATE WAS STORED INTO RIV, AND THE TOTAL
C  AMOUNT FOR EACH STEADY STATE DOSE WAS STORED INTO RBOL ABOVE.
C  IF RBOL > 0, THIS DRUG PARTICIPATES IN THE STEADY STATE DOSE SET.
C  IN THIS CASE, ESTABLISH ALL THE ENTRIES FOR THE LINE WHICH WILL BE 
C  WRITTEN TO THE .CSV FILE FOR THIS DRUG, AND THEN WRITE THE LINE TO
C  FILE 29.

       IF(RBOL .GT. 0.D0) THEN

C  THE DURATION FOR EACH IV FOR THIS DRUG IS THE QUOTIENT OF RBOL
C  DIVIDED BY RIV IF RIV > 0; AND IT = 0 IF RIV = 0 (SINCE THAT 
C  MEANS THE DOSE IS A BOLUS).

        DURATION = 0.D0
        IF(RIV .GT. 0.D0) DURATION = RBOL/RIV

C  THE STEADY STATE DOSE INFORMATION FOR THIS DRUG THAT WILL GO ON
C  THE NEXT LINE OF THE .CSV FILE IS:
C  SUBID; EVID = IDEVENT (IF IT IS 1, IT WILL BE 1 FOR ALL 
C  PARTICIPATING DRUGS; IF IT IS 4, IT WILL BE 4 FOR THE 1ST 
C  PARTICIPATING DRUG, BUT 1 FOR ANY OTHER PARTICIPATING DRUGS);
C  TIME = 0; DURATION, DOSE = RBOL; ADDL = -1; II = -SIG(IDOSE);
C  INPUT = JDRUG; OUTPUT AND ASSAY C INFO = DOSESTRING; AND COV. INFO
C   = (RS(IDOSE,2*NDRUG+K),K=1,NCOVA).

C  WRITE ALL THE ABOVE INFO TO SCRATCH FILE 37 SO IT CAN BE READ AS
C  BIGLINE AND THEN "REDUCED" (WRITTEN WITHOUT BLANKS) INTO SMALLLINE

C  BY SUBROUTINE REDUCE.

        OPEN(37)

C  REPLACE WRITING OF RBOL,...,RS() WITH XVERIFY (SEE LOGIC IN 
C  SUBROUTINE VERIFYVAL).

        IF(NCOVA .GT. 0) THEN
         XVERIFY(1) = DURATION
         XVERIFY(2) = RBOL
         XVERIFY(3) = -SIG(IDOSE) 
         DO K = 1,NCOVA
          XVERIFY(3+K) = RS(IDOSE,2*NDRUG+K)
         END DO
         CALL VERIFYVAL(3+NCOVA,XVERIFY)
C        WRITE(37,16) SUBID,IDEVENT,'0.0',DURATION,
C    1   RBOL,'-1',-SIG(IDOSE),JDRUG,DOSESTRING,
C    2   (RS(IDOSE,2*NDRUG+K),K=1,NCOVA)
         WRITE(37,16) SUBID,IDEVENT,'0.0',XVERIFY(1),
     1   XVERIFY(2),'-1',XVERIFY(3),JDRUG,DOSESTRING,
     2   (XVERIFY(3+K),K=1,NCOVA)
        ENDIF

   16   FORMAT(A11,',',I1,',',A3,',',G14.7,',',G14.7,',',A2,',',
     1   G14.7,',',I1,A12,26(',',G14.7))


        IF(NCOVA .EQ. 0) THEN
         XVERIFY(1) = DURATION
         XVERIFY(2) = RBOL
         XVERIFY(3) = -SIG(IDOSE) 
         CALL VERIFYVAL(3,XVERIFY)
C        WRITE(37,17) SUBID,IDEVENT,'0.0',DURATION,
C    1   RBOL,'-1',-SIG(IDOSE),JDRUG,DOSESTRING
         WRITE(37,17) SUBID,IDEVENT,'0.0',XVERIFY(1),
     1   XVERIFY(2),'-1',XVERIFY(3),JDRUG,DOSESTRING
        ENDIF

   17   FORMAT(A11,',',I1,',',A3,',',G14.7,',',G14.7,',',A2,',',
     1   G14.7,',',I1,A12)

        BACKSPACE(37)
        READ(37,12) BIGLINE
   12   FORMAT(A1000)
        CLOSE(37)
        CALL REDUCE(BIGLINE,SMALLLINE)
        CALL CONDENSE(SMALLLINE)
        IDEVENT = 1
C  EVEN IF IDEVENT = 4, IT SHOULD BE CHANGED AFTER THE ABOVE WRITING,
C  SINCE EACH DOSE RESET ROW SHOULD HAVE JUST ONE IDEVENT = 4 ROW
C  IN THE .CSV FILE; ALL SUBSEQUENT ROWS FOR THIS EVENT SHOULD SHOW
C  IDEVENT = 1. 

          ENDIF

C THE ABOVE ENDIF IS FOR THE  IF(RIV .GT. 0.D0) CONDITION.


           
         END DO

C  THE ABOVE END DO IS FOR THE  DO JDRUG = 1,NDRUG  LOOP.



      RETURN
      END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C wmy20190315 Moved to npag_utils.f90
C
C Validated w/Pmetrics Examples 30 and 1
C
      SUBROUTINE Old_VERIFYVAL(N,X)
      IMPLICIT REAL*8(A-H,O-Z)
      DIMENSION X(200)

C  THIS ROUTINE INPUTS X(I),I=1,N.

C  ON OUTPUT, EACH X(.) WHICH IS INSIDE [-1.D-99, 1.D-99] IS REPLACED
C  BY 0. THIS PREVENTS THIS VALUE FROM BEING WRITTEN OUT IMPROPERLY,
C  E.G., AS .934-106, RATHER THAN .934E-106.
C  ANY X(.) VALUE NOT INSIDE THE ABOVE RANGE WILL BE UNCHANGED ON
C  OUTPUT.

      DO I = 1,N
       IF(X(I) .GE. -1.D-99 .AND. X(I) .LE. 1.D-99) X(I) = 0.D0
      END DO

      RETURN
      END




