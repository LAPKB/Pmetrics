% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/PM_sim.R
\name{PM_sim}
\alias{PM_sim}
\title{Object to contain results of simulation}
\description{
\ifelse{html}{\href{https://lifecycle.r-lib.org/articles/stages.html#stable}{\figure{lifecycle-stable.svg}{options: alt='[Stable]'}}}{\strong{[Stable]}}

This object is created after a successful run of the simulator.
}
\details{
There are two methods of creating a PM_sim object.
\itemize{
\item \strong{PM_result$sim()}
\item \strong{PM_sim$new()}
}

They return fully parsed simulator output as \link{PM_sim} objects in R. Details
can be found in the documentation for \verb{$new} method below.
}
\examples{

## ------------------------------------------------
## Method `PM_sim$new`
## ------------------------------------------------

\dontrun{
# Load results of NPAG run
run1 <- PM_load(1)

# Two methods to simulate
# The first uses the population prior, data, and model in run1, with "..."
# as additional parameters passed to the simulator, e.g. limits, nsim, etc.

sim1 <- run1$sim(...)

# The second uses the population prior and model in run1, and a new template
# data file in the working directory

sim2 <- PM_sim$new(poppar = run1, data = "newfile.csv", ...)

# These methods are entirely interchangeable. The first can accept a different
# data template. The difference is that poppar must be explicitly
# declared when using PM_sim$new. This makes it the method to use when poppar
# is derived from the literature.

# An example of a manual prior
# make 1 lognormal distribution for each parameter
weights <- 1
mean <- log(c(0.7, 0.05, 100))
cov <- matrix(rep(0, length(mean)**2), ncol = length(mean))
diag(cov) <- (c(0.15, 0.15, 0.15) * mean)**2
# make the prior for the simulation
poppar <- list(weights, mean, cov)

# run simulation, assuming temp1.csv and model.txt are in working directory

sim1 <- PM_sim$new(poppar, "temp1.csv",
  nsim = 15, model = "model.txt", include = 1:4, limits = NA,
  obsNoise = c(0.02, 0.1, 0, 0)
)
}

}
\author{
Michael Neely
}
\keyword{internal}
\section{Public fields}{
\if{html}{\out{<div class="r6-fields">}}
\describe{
\item{\code{data}}{A list of class \emph{PM_sim} that contains the following elements.
\itemize{
\item \strong{obs} Observations for all simulated templates as a data frame with these columns:
\itemize{
\item \emph{id} Template ID, corresponding to the ID in the template data file
\item \emph{nsim} The simulated profile number, from 1 to the value for \code{nsim}
specified when the simulation was run.
\item \emph{time} Time of the simulated observation.
\item \emph{out} The simulated observation.
\item \emph{outeq} The output equation number.
}
\item \strong{amt} Compartment amounts for each simulated template as a data frame with these columns:
\itemize{
\item \emph{id} As for \code{obs}.
\item \emph{nsim} As for \code{obs}.
\item \emph{time} As for \code{obs}.
\item \emph{out} The simulated amount.
\item \emph{comp} The compartment number that contains the \code{out} amount.
}
\item \strong{parValues}  A data frame with retained simulated parameter
values after discarding any due to truncation limits. The data frame has these columns:
\itemize{
\item \emph{id} This column is only present if \code{usePost = TRUE}, since in that case
the \code{nsim} profiles for each template are created by sampling from a different prior
joint parameter probability distribution for each template. When \code{usePost = FALSE},
the same prior is used for every template, so there is no \code{id} column.
\item \emph{nsim} The simulation number, from 1 to the value for \code{nsim} specified when the simulation was run.
\item a column for each random parameter in the model with the simulated values
}
\item \strong{totalSets} When \code{usePost = FALSE}, the number of all simulated parameter values needed to obtain the
requested number of simulated sets within any \code{limits} specified. When \code{usePost = TRUE},
a data frame with the same number for each template in the \code{data} file, since each template
is simulated from a different prior distribution (see \code{parValues:id} above).
\item \strong{totalMeans} If \code{usePost = FALSE}, this is a vector with the means of
all simulated parameter values, including those discarded for being outside
\code{limits}. If \code{usePost = TRUE}, this is a data frame of vectors, one for each template in the \code{data} file,
and an \code{id} column to identify the template in the \code{data} source.
This can be useful to check against the original means in \code{poppar}, since the
mean of the \code{parValues} may be different due to truncation.
\item \strong{totalCov} Similar to \code{totalMeans}, either a single covariance matrix
for all simulated parameter values when \code{usePost = FALSE} . If \code{usePost = TRUE},
this is a data frame of such matrices, one for each template in the \code{data} file,
and an \code{id} column to identify the template in the \code{data} source.
Again, this can be useful as a check against the original covariance in \code{poppar}.
}}
}
\if{html}{\out{</div>}}
}
\section{Active bindings}{
\if{html}{\out{<div class="r6-active-bindings">}}
\describe{
\item{\code{obs}}{Same as \code{obs} element in the \code{data} field.}

\item{\code{amt}}{Same as \code{amt} element in the \code{data} field.}

\item{\code{parValues}}{Same as \code{parValues} element in the \code{data} field.}

\item{\code{totalSets}}{Same as \code{totalSets} element in the \code{data} field.}

\item{\code{totalMeans}}{Same as \code{totalMeans} element in the \code{data} field.}

\item{\code{totalCov}}{Same as \code{totalCov} element in the \code{data} field.}
}
\if{html}{\out{</div>}}
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-PM_sim-new}{\code{PM_sim$new()}}
\item \href{#method-PM_sim-save}{\code{PM_sim$save()}}
\item \href{#method-PM_sim-plot}{\code{PM_sim$plot()}}
\item \href{#method-PM_sim-pta}{\code{PM_sim$pta()}}
\item \href{#method-PM_sim-auc}{\code{PM_sim$auc()}}
\item \href{#method-PM_sim-summary}{\code{PM_sim$summary()}}
\item \href{#method-PM_sim-run}{\code{PM_sim$run()}}
\item \href{#method-PM_sim-load}{\code{PM_sim$load()}}
\item \href{#method-PM_sim-clone}{\code{PM_sim$clone()}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-PM_sim-new"></a>}}
\if{latex}{\out{\hypertarget{method-PM_sim-new}{}}}
\subsection{Method \code{new()}}{
This function simulates outputs from given inputs and a model.
It can be called directly
or via the \verb{$sim} method for \link{PM_result} objects.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{PM_sim$new(
  poppar,
  model,
  data,
  limits = NULL,
  split = NULL,
  include = NULL,
  exclude = NULL,
  nsim = 1000,
  predInt = 0,
  covariate = NULL,
  usePost = FALSE,
  seed = -17,
  obsNoise = NULL,
  obsTimeNoise = NULL,
  doseNoise = NULL,
  doseTimeNoise = NULL,
  noise = NULL,
  makecsv = NULL,
  quiet = FALSE,
  combine = FALSE,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{poppar}}{One of four things:
\itemize{
\item Population prior parameters as a \link{PM_final} object found in
\code{PM_result$final}. Normally these would be supplied by calling the
\verb{$sim} method for a \link{PM_result} object, e.g. \code{NPex$sim(...)}.
\item The name of a previously saved simulation via the \verb{$save} method. The
file will be loaded. This filename should have the ".rds" extension, e.g. "sim.rds".
\item A manually specified prior as a list containing three items in this order,
but of any name: 1) vector of weights; 2) vector of mean parameter values;
and 3) a covariance matrix. If only one distribution is to be specified the
\code{weights} vector should be of length 1 and contain a 1. If multiple
distributions are to be sampled, the \code{weights} vector should be of
length equal to the number of distributions and its values should sum to 1,
e.g. \code{c(0.25,0.05,0.7)}.  The means element may be a vector for a
single distribution, or a matrix with \code{length(weights)} rows and
number of columns equal to the number of parameters. The
covariance matrix will be divided by \code{length(weights)} and applied to
each distribution. For example:
\verb{poppar = list(wt = c(0.25, 0.75), mean = matrix(c(0.5, 1, 100, 200), cov = diag(c(0.25, 2500)))}
indicates two distributions with weights 0.25 and 0.75. There are two parameters,
and the means of the first distribution are 0.5 and 100. The means of the
second distribution are 1 and 200. The covariance matrix has diagonal values
of 0.25 and 2500 and off-diagonal values of zero.
}}

\item{\code{model}}{Name of a suitable \link{PM_model} object or a model file template
in the working directory. If missing, and \code{poppar} is a \link{PM_result},
the model within the \verb{$model} field of the \link{PM_result} object will be used.
If \code{model} is missing and \code{poppar} is not a \link{PM_result}, then
Pmetrics will attempt to load a model file in the working directory
called "model.txt" as the default name.}

\item{\code{data}}{Either a \link{PM_data} object or a character vector
with the file name of a Pmetrics data file in the working directory
that contains \strong{template} regimens and observation times.
The value for outputs can be coded as any number(s) other than -99.  The
number(s) will be replaced in the simulator output with the simulated
values. Outputs equal to -99 will be simulated as missing. If \code{data} is
missing, and \code{poppar} is a \link{PM_result},
the data within the \verb{$data} field of the \link{PM_result} object will be used.
If \code{data} is missing and \code{poppar} is not a \link{PM_result}, then
Pmetrics will attempt to load a data template file in the working directory
called "data.csv" as the default name.}

\item{\code{limits}}{If limits are specified, each simulated parameter set that
contains a value outside of the limits will be ignored and another set will
be generated.  Four options exist for limits.
\itemize{
\item The default \code{NULL} indicates that no limits are to be applied to simulated parameters.
\item The second option is to set \code{limits} to \code{NA}. This will use the
parameter limits on the primary parameters that are specified in the \link{PM_model} object.
\item The third option is a numeric vector of length 1 or 2, e.g. \code{limits = 3} or
\code{limits = c(0.5, 4)}, which specifies what to multiply the columns of the limits in the
model file.  If length 1, then the lower limits will be the same as in the
model file, and the upper limits will be multiplied by value specified.  If
length 2, then the lower and upper limits will be multiplied by the
specified values.  If this option is used, \code{poppar} must be a
\code{PM_final} object.
\item The fourth option for limits is a fully
customized matrix of limits for simulated values for each parameter which
will overwrite any limits in the model file.  If specified, it should be a
data frame or matrix with number of rows equal to the number of random
paramters and 2 columns, corresponding to the minimum and maximum values.
For example, a final$ab object, or a directly coded matrix, e.g.
\code{matrix(c(0, 5, 0, 5, 0.01, 100), nrow = 3,ncol = 2, byrow = T)} for 3 parameters with
limits of (0, 5), (0, 5) and (0.01, 100), respectively.  It is possible to
convert a parameter to fixed by omitting the second limit. Means and
covariances of the total number of simulated sets will be returned to
verify the simulation, but only those sets within the specified limits will
be used to generate output(s) and the means and covariances of the retained
sets may (and likely will be) different than those specified by
\code{poppar}.
}}

\item{\code{split}}{Boolean operator controlling whether to split an NPAG
\link{PM_final} object into one distribution per support point, with means
equal to the vector of parameter values for that point, and covariance
equal to the population covariance divided by the number of support points.
Default for NPAG \link{PM_final} objects is \code{TRUE}, otherwise
\code{FALSE}.}

\item{\code{include}}{A vector of subject IDs in the \code{data} to iterate
through, with each subject serving as the source of an independent
simulation.  Default is \code{NA} and all subjects in the data file will be used.}

\item{\code{exclude}}{A vector of subject IDs to exclude in the simulation, e.g.
\code{exclude = c(4, 6:14, 16:20)}. Default is \code{NA} and
all subjects in the data file will be used, i.e. none excluded.
Using both \code{include} and \code{exclude} criteria may result in conflicts.}

\item{\code{nsim}}{The number of simulated profiles to create, per subject.  Default
is 1000.  Entering 0 will result in one profile being simulated from each
point in the non-parametric prior (for NPAG final objects only).}

\item{\code{predInt}}{The interval in fractional hours for simulated predicted
outputs at times other than those specified in the template \code{data}.
The default is 0, which means there will be simulated outputs only at times
specified in the data file (see below).  Values greater than 0 result in
simulated outputs at the specified value, e.g. every 15 minutes
for \code{predInt = 0.25} from time 0 up to the maximal time in the template file,
per subject if nsub > 1.  You may also specify \code{predInt} as a vector
of 3 values, e.g. \code{predInt = c(1, 4, 1)}, similar to the R command
\link{seq}, where the first value is the start time, the second is
the stop time, and the third is the step value.  Finally, you can have
multiple such intervals by specifying \code{predInt} as a list of such
vectors, e.g. \code{predInt = list(c(0, 24, 1), c(72, 96, 1))}.  Outputs for times
specified in the template file will also be simulated. To simulate outputs
\emph{only} at the output times in the template data (i.e. EVID=0 events),
use \code{predInt = 0}, which is the default. Note that the maximum number of
predictions is 594, so the prediction interval must be sufficiently long to
accommodate this for a given number of output equations and total time to
simulate over.  If \code{predInt} is set so that this cap is exceeded,
predictions will be truncated.}

\item{\code{covariate}}{If you are using a \link{PM_result} or \link{PM_final} object
as \code{poppar}, then you can also
simulate with covariates. This argument is a list with the following names.
\itemize{
\item \code{cov} If \code{poppar} is a \link{PM_result}, Pmetrics will use the \verb{$cov} field
within that object to obtain covariate information and you can skip this
element of the \code{covariate} list. If \code{poppar} is
a \link{PM_final}, you will need to supply the name of a \link{PM_result}
or \link{PM_cov} object as the value for this element.
Pmetrics will use this covariate object to calculate the correlation
matrix between all covariates and Bayesian posterior parameter values.
\item \code{mean} A named list that allows you to specify a different mean
for one or more of the covariates. Each named item in the list is the name
of a covariate in your data that is to have a different mean. If this
argument is missing then the mean covariate values in the population will
be used for simulation. The same applies to any covariates that are not
named in this list.  Example:
\verb{run1 <- PM_load(1); covariate = list(mean = list(wt = 50))}.
\item \code{sd} This functions just as the mean list argument does - allowing you to
specify different standard deviations for covariates in the simulation. If
it, or any covariate in the sd list is missing, then the standard
deviations of the covariates in the population are used. Example:
\code{covariate = list(sd = list(wt = 10))}.
\item \code{limits} This is a bit different than the limits for population
parameters above. Here,
\code{limits} is similar to \code{mean} and \code{sd} for covariates in
that it is a named list with the minimum and maximum allowable simulated
values for each covariate.  If it is missing altogether, then no limits
will apply.  If it is specified, then named covariates will have the
indicated limits, and covariates not in the list will have limits that are
the same as in the original population.  If you want some to be limited and
some to be unlimited, then specify the unlimited ones as items in this list
with very large ranges.  Example:
\code{covariate = list(limits = list( wt = c(10, 70)))}.
\item \code{fix} A character vector (not a list) of covariates to fix and not simulate.  In
this case values in the template data file will be used and not simulated.
Example: \code{fix = c("wt", "age")}.  Whether you use the means and
standard deviations in the population or specify your own, the covariance
matrix in \code{poppar} will be augmented by the covariate covariances for any
non-fixed covariates. The parameter plus covariate means and this augmented
covariance matrix will be used for simulations. In effect, all non-fixed
covariates are moved into the \strong{#Primary} block of the model file to become
parameters that are simulated. In fact, a copy of your model file is made
with a "c" prepended to the model name (e.g. "model.txt" ->
"c_model.txt").
}}

\item{\code{usePost}}{Boolean, default \code{FALSE}. Only applicable when \code{poppar} contains an
NPAG \link{PM_final} object. If \code{TRUE}, the mean
posterior parameter values and covariances for each subject,
modified by \code{include} or \code{exclude},
in \code{poppar} will be used to simulate rather than the population prior.
The number of subjects in the template \code{data} file must be the same.
Normally one uses the same data file as used to make the model final
parameter distribution in \code{poppar}, but if different templates are
desired, the number must be equivalent to the number of included subjects
from whom the posteriors are obtained.}

\item{\code{seed}}{The seed for the random number generator.  For \code{nsub} > 1,
should be a vector of length equal to \code{nsub}. Shorter vectors will be
recycled as necessary.  Default is -17.}

\item{\code{obsNoise}}{= \ifelse{html}{\href{https://lifecycle.r-lib.org/articles/stages.html#deprecated}{\figure{lifecycle-deprecated.svg}{options: alt='[Deprecated]'}}}{\strong{[Deprecated]}}. Use \code{noise} instead.}

\item{\code{obsTimeNoise}}{= \ifelse{html}{\href{https://lifecycle.r-lib.org/articles/stages.html#deprecated}{\figure{lifecycle-deprecated.svg}{options: alt='[Deprecated]'}}}{\strong{[Deprecated]}}. Use \code{noise} instead.}

\item{\code{doseNoise}}{= \ifelse{html}{\href{https://lifecycle.r-lib.org/articles/stages.html#deprecated}{\figure{lifecycle-deprecated.svg}{options: alt='[Deprecated]'}}}{\strong{[Deprecated]}}. Use \code{noise} instead.}

\item{\code{doseTimeNoise}}{= \ifelse{html}{\href{https://lifecycle.r-lib.org/articles/stages.html#deprecated}{\figure{lifecycle-deprecated.svg}{options: alt='[Deprecated]'}}}{\strong{[Deprecated]}}. Use \code{noise} instead.}

\item{\code{noise}}{A named list to add noise to most template data fields,
including covariates.
The default is \code{NULL}, which means no noise will be added.
The name of each element in the list should correspond to
a column in the data to which you wish to add noise, typically
\code{time}, \code{dose}, or \code{out}. Note that noise is added to the \code{out} column
\emph{after} simulation but \emph{before} simulation for all other columns. Noise
on the \code{out} column is best thought of as measurement error on the true,
simulated value. Thus, in the simulated output, the \code{amt} values for a given
template id, simulation number, time, and output equation will no longer be
exactly related to the corresponding \code{out} value by the volume term in the model.

These columns may not have noise added: \code{id}, \code{evid}, \code{addl}, \code{ii}, \code{input}, \code{outeq}, \code{c0},
\code{c1}, \code{c2}, and \code{c3}. See \link{PM_data} for further details on these columns.

Each element in the \code{noise} list should be another list with the following arguments.
The \code{coeff} argument is mandatory, and should be the first argument. It can be named or
unnamed. The \code{filter} and \code{mode} arguments are optional and should always be named
in the list.
\itemize{
\item \strong{coeff} Mandatory. A vector of up to 4 coefficients for the noise model. They
correspond to \emph{C0}, \emph{C1}, \emph{C2}, and \emph{C3} for the assay noise model (as in \link{PM_model}).
See the 'mode' argument for details on how these values are used to generate noise.
Examples:
\verb{noise = list(out = list(coeff = c(0.1, 0.1))} or \code{noise = list(dose = list(coeff = c(5, 0.15, -0.01, 0.003)))}.
\item \strong{filter} Optional. A quoted expression to filter the data. For example,
\code{noise = list(dose = list(c(0.1, 0.1), filter = "dose > 0.1"))} or
\code{noise = list(out = list(c(0.05, 0.15), filter = "outeq == 1 & time < 120"))}.
\item \strong{mode} Optional. The mode (method) of the noise. Default is \code{add}. Options are \code{add} or \code{exp}.
\itemize{
\item \code{add} An additive noise model. The new value is generated as
\code{value + noise}, where noise is a random number from a normal distribution,
with mean of 0 and \code{SD = C0 + C1*value + C2*value^2 + C3*value^3}, and \emph{value} is the
original value in each row of the target column.
\item \code{exp} An exponential noise model. The new values is generated as
\code{value * exp(noise)}, where noise is a random number from a normal distribution,
with mean of 0 and \code{SD = C0 + C1*value + C2*value^2 + C3*value^3}, and \emph{value} is the
original value in each row of the target column.
@examples
\dontrun{
 exDat$makeNoise(list(dose = list(coeff = c(0.1, 0.1), filter = "dose > 100 & time < 200", mode = "add"),
 out = list(c(0.1, 0.001), mode = "exp")))
 }
}
}}

\item{\code{makecsv}}{A character vector for the name of the single .csv file to be
made for all simulated "subjects".  If no file extension is included, ".csv"
will be added, e.g. "simout" will become "simout.csv". If an extension is included,
Pmetrics will use it, e.g. "simout.ssv" will save under that name.
If missing, no file will be
made. If a \code{makecsv} filename is supplied, ID numbers will
be of the form \emph{id_nsim}, e.g. 1_1 through 1_10 through for the first
data template id,
2_1 through 2_10 for the second template id, etc. if 10 simulations are made
from each subject in the data template.}

\item{\code{quiet}}{Boolean operator controlling whether a model summary report is
given.  Default is \code{FALSE}.}

\item{\code{combine}}{When there are multiple subjects in the template \code{data},
combine the simulated results into a single object. Default is \code{FALSE}.}

\item{\code{...}}{Catch deprecated arguments.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
The Monte Carlo simulator in Pmetrics generates randomly sampled sets of
parameters from the \emph{PRIMARY} block of
a model according to a prior distribution and calculates outputs based upon
a template data file. It is a powerful tool for parametric or
semi-parametric sampling.  There are two ways to execute the simulator.
\itemize{
\item \strong{PM_result$sim()}
\item \strong{PM_sim$new()}
}

They return fully parsed simulator output as \link{PM_sim} objects in R.
NPAG or IT2B final objects can easily be used as
the prior distributions for sampling. Prior distributions
may be manually
specified.  Prior distributions may be unimodal-multivariate (parametric
sampling), or multimodal-multivariate (semi-parametric sampling). For priors
from NPAG, this can be accomplished with the \code{split} argument.

It is also possible to simulate with covariates if they are included as part
of the model. By specifying a covariate list argument, Pmetrics will first
calculate the correlation matrix between the covariates and the Bayesian
posterior parameter values for each subject in the population model.  Using
either the mean and standard deviation of each covariate in the population,
or a user-specified mean and/or standard deviation, Pmetrics will then
calculate an augmented covariance matrix to be used in simulations.  Pmetrics
will make a copy of the model file with all covariates moved into the primary
block as parameters to be simulated.

Noise can be applied to most columns in the data template, typically
simulated observations, observation times, dose times, or dose amounts.

Limits on the simulated parameter sets can also be specified using the limits
on primary parameters in the model file or by specifying them manually as an
argument. Limits can also be applied to simulated covariates.

It is permissible to fix a parameter for simulation that was a random
parameter in the model prior by changing the range in the model file to a
single value for that parameter.

The same model and data structures are used for the simulator as for any
other Pmetrics functions.  In this case, the data object will serve as the
template for the information regarding dosing, covariate values, and
observations.  Template data may have more than one subject in them, in
which case the simulator will use each subject specified by the
\code{include} argument (default is all subjects) to generate \code{nsim}
parameter sets and corresponding observations.

Simulator output is directed to text files prefixed according to the
\code{outfile} value (default "simout"), one for each template subject,
which are read back into R to populate the \link{PM_sim} object.
Output may also be directed to a new Pmetrics .csv data file
using the \code{makecsv} argument.
}

\subsection{Returns}{
A \link{PM_sim} object.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
# Load results of NPAG run
run1 <- PM_load(1)

# Two methods to simulate
# The first uses the population prior, data, and model in run1, with "..."
# as additional parameters passed to the simulator, e.g. limits, nsim, etc.

sim1 <- run1$sim(...)

# The second uses the population prior and model in run1, and a new template
# data file in the working directory

sim2 <- PM_sim$new(poppar = run1, data = "newfile.csv", ...)

# These methods are entirely interchangeable. The first can accept a different
# data template. The difference is that poppar must be explicitly
# declared when using PM_sim$new. This makes it the method to use when poppar
# is derived from the literature.

# An example of a manual prior
# make 1 lognormal distribution for each parameter
weights <- 1
mean <- log(c(0.7, 0.05, 100))
cov <- matrix(rep(0, length(mean)**2), ncol = length(mean))
diag(cov) <- (c(0.15, 0.15, 0.15) * mean)**2
# make the prior for the simulation
poppar <- list(weights, mean, cov)

# run simulation, assuming temp1.csv and model.txt are in working directory

sim1 <- PM_sim$new(poppar, "temp1.csv",
  nsim = 15, model = "model.txt", include = 1:4, limits = NA,
  obsNoise = c(0.02, 0.1, 0, 0)
)
}

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-PM_sim-save"></a>}}
\if{latex}{\out{\hypertarget{method-PM_sim-save}{}}}
\subsection{Method \code{save()}}{
\ifelse{html}{\href{https://lifecycle.r-lib.org/articles/stages.html#stable}{\figure{lifecycle-stable.svg}{options: alt='[Stable]'}}}{\strong{[Stable]}}
Save the current PM_sim object into a .rds file.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{PM_sim$save(file_name = "PMsim.rds")}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{file_name}}{Name of the file to be created, the default is PMsim.rds}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-PM_sim-plot"></a>}}
\if{latex}{\out{\hypertarget{method-PM_sim-plot}{}}}
\subsection{Method \code{plot()}}{
\ifelse{html}{\href{https://lifecycle.r-lib.org/articles/stages.html#stable}{\figure{lifecycle-stable.svg}{options: alt='[Stable]'}}}{\strong{[Stable]}}
Plot \code{PM_sim} object.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{PM_sim$plot(...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{...}}{Arguments passed to \link{plot.PM_sim}.}

\item{\code{at}}{Index of the PM_sim object to be plotted. Default is 1.
result.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-PM_sim-pta"></a>}}
\if{latex}{\out{\hypertarget{method-PM_sim-pta}{}}}
\subsection{Method \code{pta()}}{
\ifelse{html}{\href{https://lifecycle.r-lib.org/articles/stages.html#stable}{\figure{lifecycle-stable.svg}{options: alt='[Stable]'}}}{\strong{[Stable]}}
Estimates the Probability of Target Attaintment (PTA), based on the results
of the current Simulation.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{PM_sim$pta(...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{...}}{Additional parameters, refer to \link{makePTA}}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-PM_sim-auc"></a>}}
\if{latex}{\out{\hypertarget{method-PM_sim-auc}{}}}
\subsection{Method \code{auc()}}{
\ifelse{html}{\href{https://lifecycle.r-lib.org/articles/stages.html#stable}{\figure{lifecycle-stable.svg}{options: alt='[Stable]'}}}{\strong{[Stable]}}
Calculates the AUC of the specified simulation
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{PM_sim$auc(...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{...}}{Arguments passed to \link{makeAUC}.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-PM_sim-summary"></a>}}
\if{latex}{\out{\hypertarget{method-PM_sim-summary}{}}}
\subsection{Method \code{summary()}}{
\ifelse{html}{\href{https://lifecycle.r-lib.org/articles/stages.html#stable}{\figure{lifecycle-stable.svg}{options: alt='[Stable]'}}}{\strong{[Stable]}}
Summarize simulation
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{PM_sim$summary(...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{...}}{Parameters passed to \link{summary.PM_sim}.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-PM_sim-run"></a>}}
\if{latex}{\out{\hypertarget{method-PM_sim-run}{}}}
\subsection{Method \code{run()}}{
\ifelse{html}{\href{https://lifecycle.r-lib.org/articles/stages.html#deprecated}{\figure{lifecycle-deprecated.svg}{options: alt='[Deprecated]'}}}{\strong{[Deprecated]}}
Deprecated method to run a simulation. Replaced by \code{PM_sim$new()} to be
consistent with R6.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{PM_sim$run(...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{...}}{Not used.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-PM_sim-load"></a>}}
\if{latex}{\out{\hypertarget{method-PM_sim-load}{}}}
\subsection{Method \code{load()}}{
\ifelse{html}{\href{https://lifecycle.r-lib.org/articles/stages.html#deprecated}{\figure{lifecycle-deprecated.svg}{options: alt='[Deprecated]'}}}{\strong{[Deprecated]}}
Deprecated method to load a prior simulation. Replaced by \code{PM_sim$new()} to be
consistent with R6.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{PM_sim$load(...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{...}}{Not used.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-PM_sim-clone"></a>}}
\if{latex}{\out{\hypertarget{method-PM_sim-clone}{}}}
\subsection{Method \code{clone()}}{
The objects of this class are cloneable with this method.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{PM_sim$clone(deep = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{deep}}{Whether to make a deep clone.}
}
\if{html}{\out{</div>}}
}
}
}
