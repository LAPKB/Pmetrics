C  DOPT7.FOR                                               2/22/16

C  DOPT7 HAS THE FOLLOWING CHANGES FROM DOPT6:

C  1. IF THE USER DECIDES TO USE A DIFFERENT PATIENT DATA FILE TO 
C  DEFINE THE DOSAGE REGIMENT, OBS. TIMES, ETC. FOR THE D-OPTIMAL
C  DESIGN (FROM THE FIRST ONE IN THE NPAG OUTPUT FILE HE ENTERS),
C  PREVIOUSLY HE HAD TO USE A WORKING COPY PATIENT FILE. NOW, HE MAY 
C  ALSO USE A .CSV BLOCK FORMAT FILE (IN WHICH CASE THE DATA FOR THE 
C  FIRST PATIENT IN THAT FILE WILL BE USED).

C  NOTE THAT THIS REQUIRED COPYING/EDITING VERSIONS OF SUBROUTINES 
C  CONVERTCSV, NEWCSV, CSVCHANGE, READBLOCK2, AND ALL THE ROUTINES
C  THEY CALL FROM MONT113.FOR.

C  2. FORMAT 151 IS CORRECTED TO REFER TO MODELQZPX.FOR, RATHER
C  THAN MODELQZPX.001.

C  3. THE "ENGINE" IS UPDATED FROM dopteng5.f TO dopteng6.f. THE CHANGE
C  IN dopteng6.f IS THAT THE MINIMUM D-OPTIMAL TIME NOW WILL BE THE
C  MINIMUM OBSERVED VALUE TIME IN THE SUPPLIED PATIENT DATA FILE,
C  RATHER THAN 0.

C  NOTE THAT THIS SERIES OF PROGRAMS IS NOT COMPATIBLE WITH PATIENTS
C  WHICH HAVE STEADY STATE DOSING.

C-----------------------------------------------------------------------

C  DOPT6.FOR                                               2/09/16

C  DOPT6 HAS THE FOLLOWING CHANGES FROM DOPT5:

C  1.  CODE IS INCLUDED TO MAKE COMPATIBLE WITH UNIX, LINUX AND WINDOWS
C  FOR COPYING, BASED ON WALTER YAMADA'S CODE IN NPAGXXX.FOR


C  THESE CHANGES WERE MADE BY MICHAEL NEELY.

C-----------------------------------------------------------------------

C  DOPT5.FOR                                               11/30/15

C  DOPT5 HAS THE FOLLOWING CHANGES FROM DOPT4:

C  1. IT IS BROUGHT UP TO THE LEVEL OF NPAG119.FOR/npagranfix5.f, WHICH
C  ALLOW RANFIX PARAMETERS (I.E., THOSE THAT ARE ESTIMATED, BUT ARE THE
C  SAME FOR ALL SUBJECTS). THIS MEANS THAT NOW THE DENSITY PART OF THE
C  OUTPUT FILE FROM AN NPAG RUN WILL BE READ IN ONE OF TWO WAYS - THE
C  OLDER VERSIONS WILL NOT HAVE RANFIX PARAMETERS; THE NEW VERSION WILL.

C  BUT NOTE THAT ONCE ANY RANFIX PARAMETERS ARE READ IN, THEY WILL BE 
C  ADDED TO THE FIXED PARAMETER LIST. I.E., ONCE A RANFIX PARAMETER HAS
C  BEEN ESTIMATED IN NPAG, IT IS THE SAME TO THIS PROGRAM AS IF THAT 
C  PARAMETER HAD BEEN FIXED ALL ALONG. 

C  2. THE "ENGINE" IS UPDATED FROM dopteng4x.f TO dopteng5.f. THE CHANGE
C  IN dopteng5.f IS THAT (BASED ON DOPTIMAL3.EXP AND 11/9/15 NOTES) IT 
C  WILL NOW BE A REQUIREMENT THAT NOBSER BE .GE. NVAR (SINCE IF NOBSER
C  .LT. NVAR, IN THEORY |MALF| IS ALWAYS 0 --> I.E., THERE IS NO WAY TO
C  MAXIMIZE  |MALF|). SO, AFTER dopteng5.f READS IN THE 4 *QZPX*, IF 
C  NOBSER .LT. NVAR, IT WILL ARBITRARILY SET NOBSER = NVAR. NOTE THAT
C  THE ACTUAL OBSERVED VALUE TIMES IN PATQZPZ.001 ARE UNIMPORTANT 
C  (SINCE THE PREPROCESSING CODE IN dopteng5.f SEARCHES FOR THE BEST 
C  OBSERVATION TIMES (I.E., THE INITIAL GUESSES) TO BE SUPPLIED TO 
C  ELDERY.

C-----------------------------------------------------------------------

C  DOPT4.FOR                                               10/26/15

C  DOPT4 IS THE SAME AS DOPT3, EXCEPT THAT IT REFERS TO dopteng4x.f
C  RATHER THAN dopteng3.f IN FORMAT 1.

C-----------------------------------------------------------------------  
 
C  DOPT3.FOR                                               8/11/15

C  DOPT3 IS THE SAME AS DOPT2, EXCEPT THAT IT REFERS TO dopteng3.f
C  RATHER THAN dopteng1.f IN FORMAT 1.

C-----------------------------------------------------------------------  

C  DOPT2.FOR                                               7/25/15

C  DOPT2 HAS AN EXTENSION TO DOPT1. IT CREATES AN ADDITIONAL FILE,
C  DATAQZPX.DAT, WHICH STORES RTOL (THE TOL. PARAMETER USED BY THE
C  DIFFERENTIAL EQ. SOLVER (VODE), IERRMOD, GAMLAM, AND IRAN(I),
C  I = 1,NVAR+NOFIX, WHICH WILL BE READ OR ESTABLISHED FROM THE 
C  OUTPUT FILE OF THE NPAG RUN.

C-----------------------------------------------------------------------

C  DOPT1.FOR                                               6/25/15

C  DOPT1 IS A PROGRAM WHICH PREPARES FILES SO ITS "ENGINE" MODULE,
C  dopteng1.f., CAN CALCULATE THE D-OPTIMAL DESIGN BASED ON THE
C  RESULTS OF AN NPAG RUN. IN PARTICULAR, THE OUTPUT FILE FOR AN NPAG 
C  RUN IS READ TO GET:

C  1. THE FINAL CYCLE JOINT DENSITY, WHICH HAS NACTVE GRID PTS. AND 
C     ASSOCIATED PROBABILITIES, AS WELL AS THE FIXED PARAMETER VALUES.
C     THIS INFO WILL BE STORED INTO FILE DENQZPX.DAT.
C  2. THE FIRST PATIENT'S DATA, TO GET THE DOSAGE REGIMEN, THE 
C     OBSERVATION TIMES (WHICH WILL BE THE INITIAL GUESSES FOR THE 
C     D-OPTIMAL DESIGN), AND THE ASSAY COEFFICIENTS. THIS INFO WILL
C     BE STORED INTO FILE PATQZPX.001.
C  3. THE MODEL FILE, WHICH WILL BE STORED INTO MODELQZPX.FOR SO
C     IT CAN BE COMPILED WITH THE "ENGINE", dopteng1.f, WHICH CAN THEN
C     CALCULATE THE D-OTPIMAL DESIGN. 

C  THE D-OPTIMAL DESIGN IS THE ONE WHICH MINIMIZES - |MALF|, WHERE 
C  MALF = PMAT' * RINV * PMAT, WHERE 

C  ' INDICATES TRANSPOSE;

C  PMAT = NOB x NVAR MATRIX, WITH THE (I,J) ELEMENT = PARTIAL 
C  DERIVATIVE OF THE ITH IN THE Y MATRIX  W.R.T. THE JTH COORDINATE 
C  OF THE PARAMETER VECTOR, AT THE TIME OF THAT OBSERVATION, ASSUMING
C  ALL THE PARAMETERS = THEIR GRID PT. COORDINATES. NOTE THAT THE ITH 
C  VALUE IN Y IS COUNTED "COLUMN-WISE". I.E., THE ORDERING OF THE 
C  NOB VALUES IN Y IS: (1,1),(2,1),...,(NOBSER,1), (1,2), (2,2),
C  ...,(NOBSER,2), ... (1,NUMEQT),(2,NUMEQT),...,(NOBSER,NUMEQT);

C  RINV = NOB x NOB DIAGONAL MATRIX WITH 1/S(I)**2 AS THE 
C  (I,I) ELEMENT, WHERE S(I) IS THE SIG(.,.) ELEMENT WHICH 
C  CORRESPONDS TO THE ITH VALUE IN Y (SEE ABOVE DEFN. OF PMAT). NOTE 
C  THAT EACH SIG() IS CALCULATED AS 
C  SIG(I,IEQ) = C0(IEQ)+C1(IEQ)*Y+C2(IEQ)*Y*Y+C3(IEQ)*Y**3, WHERE 
C  Y = Y(I,IEQ) IS THE PREDICTED VALUE AT TIME I FOR EQ. IEQ.

C  ALSO, THE "ENGINE" PROGRAM WILL THEN GIVE THE WEIGHTED D-OPTIMAL 
C  DESIGN OVER ALL NACTVE GRID PTS, EACH WEIGHTED ACCORDING TO ITS 
C  ASSOCIATED PROBABILITY.

C  NOTE THAT THERE IS NO REFERENCE TO MISSING VALUES SINCE RINV WILL BE 
C  BASED ON THE PREDICTED VALUES, NOT THE OBSERVED VALUES AND THERE IS 
C  NO REASON NOT TO PREDICT ALL VALUES FOR ALL OUTPUT EQS.

C  NOTE THAT THE VALUES IN THE NPAG OUTPUT FILE WILL BE THE DEFAULT
C  VALUES TO BE USED IN CALCULATING THE D-OPTIMAL DESIGN, BUT THE USER 
C  CAN CHANGE EACH OF THESE AS DESIRED.

C-----------------------------------------------------------------------


      IMPLICIT REAL*8(A-H,O-Z)
      PARAMETER(MAXDIM=30,MAXGRD=1500,MAXNUMEQ=7) 
      DIMENSION CORDEN(MAXGRD,MAXDIM+1),VALFIX(20),SIG(5000),
     2 RS(5000,34),YOI(MAXNUMEQ),IRAN(32),RANFIXEST(20)


      CHARACTER NPAGOUT*20,READLINE*72,DENFILE*20,PATFILE*20,COMARG*50,
     1 MODELFILE*20,PAR(30)*11,PARFIX(20)*11,PSYM(32)*11,
     2 RANNAM*11,FIXNAM*11,PSYMNAME*11,CODE*14,PARRANFIX(20)*11
   
         
C ------------------------------------------------------------
C Neely 2/9/16, based on code by Yamada 5/5/2010 in NPAGxxx.FOR file
C
C Initialize system calls here, e.g.:
C 1. CopyFile = COPY or cp
C 2. DeleteFile = DEL or rm
C
C NOTE the use of INDEX; be careful what substrings are allowed
C    for the ID of an operating system
C NOTE the extra space after each command; this makes it easier
C    to concatenate arguments to the system command.

      CHARACTER(LEN=20) :: OSName
      CHARACTER(LEN=5) :: CopyFile
      CHARACTER(LEN=4) :: DeleteFile
      CHARACTER(LEN=6) :: ClearScreen
      CHARACTER(LEN=10) :: ListDir


       CALL GET_COMMAND_ARGUMENT(1,OSName)
       IF ((INDEX(OSName,"MacOSX",.TRUE.).EQ.1)
     $ .OR.(INDEX(OSName,"Darwin",.TRUE.).EQ.1)
     $ .OR.(INDEX(OSName,"BSD",.TRUE.).EQ.1)) THEN
          PRINT *,"Requested OS is ", OSName
          OSName="UNIX"
          PRINT *,"Setting OS to ", OSName

          PRINT *,""
          CopyFile="cp "
          DeleteFile="rm "
          ClearScreen="clear "
          ListDir="ls -tp "
       ELSE IF ((INDEX(OSName,"DOS",.TRUE.).EQ.1)
     $ .OR.(INDEX(OSName,"WinXP",.TRUE.).EQ.1)
     $ .OR.(INDEX(OSName,"XP",.TRUE.).EQ.1)

     $ .OR.(INDEX(OSName,"WinXP",.TRUE.).EQ.1)
     $ .OR.(INDEX(OSName,"Vista",.TRUE.).EQ.1)
     $ .OR.(INDEX(OSName,"Win7",.TRUE.).EQ.1)) THEN
          PRINT *,"Requested OS is ", OSName
          OSName="DOS"
          PRINT *,"Setting OS to ", OSName
          CopyFile="COPY "
          DeleteFile="DEL "
          ClearScreen="CLS "
          ListDir="DIR /OD "
       ELSE
          PRINT *,"WARNING: Operating system not declared."
          PRINT *,"WARNING: Can not initialize system calls."
          PRINT *,""

          PRINT *,"Possible command line error, try:"
          PRINT *,"C:\> npbig.exe <DOS,Win,XP,Vista,or Win7>"
          PRINT *,"unix$ npbig <MacOSX,Darwin,BSD>"
          PRINT *,""
          PRINT *,"NPAG Exiting with status 2"


          PRINT *,""
          CALL EXIT(2)
       END IF
C ------------------------------------------------------------
C End Neely 2/9/16 code

      GO TO 10

   15 WRITE(*,14) NPAGOUT
   14 FORMAT(/' THE FILE ',A20,' DOES NOT EXIST.')

    2 FORMAT(A20)



   10 WRITE(*,1)
    1 FORMAT(/' THIS PROGRAM PREPARES FILES SO ITS "ENGINE" MODULE,'/
     1' dopteng5.f, CAN CALCULATE THE D-OPTIMAL DESIGN BASED ON THE'/
     2' RESULTS OF AN NPAG RUN. IN PARTICULAR, THE OUTPUT FILE FOR AN'/
     3' NPAG RUN IS READ TO GET:'//
     4' 1. THE FINAL CYCLE JOINT DENSITY, AS WELL AS THE FIXED '/
     6'    PARAMETER VALUES. THIS INFO WILL BE STORED INTO THE FILE '/
     7'    DENQZPX.DAT.'/
     7' 2. THE DATA FROM PATIENT 1, TO GET THE DOSAGE REGIMEN, THE'/
     8'    OBS. TIMES (WHICH WILL BE THE INITIAL GUESSES FOR THE '/
     9'    D-OPTIMAL DESIGN), AND THE ASSAY COEFFICIENTS. THIS INFO'/
     1'    WILL BE STORED INTO FILE PATQZPX.001.'/
     2' 3. ADDITIONAL INFO, NAMELY THE TOL. PARAMETER USED BY VODE;'/
     3'    WHICH OF THE PARAMETERS ARE RANDOM AND WHICH ARE FIXED; '/
     4'    AND IERRMOD AND GAMLAM, WHICH WILL BE USED TO ESTABLISH'/
     5'    THE ASSAY ERRORS FOR THE OBSERVATIONS. THESE VALUES WILL '/
     6'    BE STORED INTO DATAQZPX.DAT.'/
     2' 4. THE MODEL FILE, WHICH WILL BE STORED INTO MODELQZPX.FOR SO'/
     3'    IT CAN BE COMPILED WITH THE "ENGINE", dopteng5.f, WHICH'/
     4'    CAN THEN CALCULATE THE D-OTPIMAL DESIGN. '//
     8' NOTE THAT YOU WILL BE ABLE TO CHANGE ANY OF THESE VALUES/FILES'/
     9' BELOW IF YOU DESIRE.'//
     9' ENTER THE NAME OF THE OUTPUT FILE FROM YOUR NPAG RUN: ')

      READ(*,2) NPAGOUT
      OPEN(21,FILE=NPAGOUT,ERR=15,STATUS='OLD')

C  READ IN RTOL NEAR THE TOP OF THE OUTPUT FILE.

  270 READ(21,3) READLINE
      IF(READLINE(2:24) .NE. 'THE TOLERANCE PARAMETER') GO TO 270
      READ(21,*)
      READ(21,*) RTOL


C  READ IN IERRMOD AND THE FINAL ESTIMATE FOR GAMLAM AT THE END
C  OF THE CYCLE CALCULATIONS.

      IERRMOD = -99

  210  READ(21,3) READLINE
       IF(READLINE(2:32) .NE. 'THIS RUN STOPPED WITH ICONVERGE') 
     1  GO TO 210

C  BACKSPACE A FEW LINES AND READ THE ESTIMATE FOR GAMLAM BELOW
C  THE LINE WITH "AND THE ESTIMATE FOR GAMLAM" ON IT.

  220  BACKSPACE(21)
       BACKSPACE(21)
       READ(21,3) READLINE
       IF(READLINE(10:36) .NE. 'AND THE ESTIMATE FOR GAMLAM') GO TO 220
       READ(21,*) IERRMOD,GAMLAM

C  VERIFY THAT IERRMOD WAS SET. OTHERWISE STOP THE PROGRAM.

      IF(IERRMOD .EQ. -99) THEN
       WRITE(*,211)
  211  FORMAT(/' THE PROGRAM COULD NOT READ THE ASSAY ERROR FUNCTION'/
     1' INFORMATION AT THE END OF THE CYCLE CALCULATIONS (I.E., '/
     2' IERRMOD AND GAMLAM.'//
     3' THE PROGRAM STOPS. IF YOU HAVE NOT EDITED YOUR OUTPUT FILE,'/
     4' PLEASE SEND IT TO THE LAPK.'/)
       CALL PAUSE
      ENDIF   


C  READ THE DENSITY PART OF THE OUTPUT FILE TO GET THE FINAL CYCLE
C  NACTVE GRID PTS. AND ASSOCIATED PROBABILITIES.

   20 READ(21,3) READLINE
    3 FORMAT(A72)
      IF(READLINE(19:43) .NE. 'START OF THE DENSITY FILE') GO TO 20

      READ(21,*)
      READ(21,7123) CODE
 7123 FORMAT(A14)

C  THE ALLOWABLE CODES ARE DENSITY FEB_97, DENSITY JUN_09, 
C  DENSITY APR_10, AND DENSITY OCT_15. THE LAST ONE DIFFERS FROM THE 
C  FIRST 3 IN THAT IT CONTAINS INFO ON THE RANFIX PARAMETERS.

C  IF THE PRIOR DENSITY FILE DOES NOT HAVE ONE OF THESE 4 CODES, TELL
C  THE USER THE FILE IS DISALLOWED.

      ICODEPRI = 0
      IF(CODE .EQ. 'DENSITY FEB_97') ICODEPRI = 1
      IF(CODE .EQ. 'DENSITY JUN_09') ICODEPRI = 1
      IF(CODE .EQ. 'DENSITY APR_10') ICODEPRI = 1
      IF(CODE .EQ. 'DENSITY OCT_15') ICODEPRI = 2

      IF(ICODEPRI .EQ. 0) THEN

       WRITE(*,8181)
 8181  FORMAT(//' THE DENSITY FILE IN THE COMBINED OUTPUT FILE YOU '/
     1' ENTERED IS OBSOLETE.'//
     2' THIS DENSITY FILE MUST HAVE DENSITY XXX_XX ON LINE 1, WHERE'/
     3' XXX_XX IS FEB_97, JUN_09, APR_10, OR OCT_15.'//
     4' THE PROGRAM STOPS. '/)

       CALL PAUSE
       STOP

      ENDIF


      DO I = 1,2
       READ(21,*)
      END DO

      READ(21,*) NACTVE
	READ(21,*) NVAR

      DO I = 1,NVAR
       READ(21,2227) PAR(I)
      END DO
 2227 FORMAT(A11)

	READ(21,*) NOFIX
      IF(NOFIX .EQ. 0) READ(21,*)
      
      IF(NOFIX .GT. 0) THEN
       DO I = 1,NOFIX
        READ(21,2227) PARFIX(I)
       END DO
      ENDIF
 
      IF(ICODEPRI .EQ. 2) THEN

       READ(21,*) NRANFIX
       IF(NRANFIX .EQ. 0) READ(21,*)

       IF(NRANFIX .GT. 0) THEN
        DO I = 1,NRANFIX
         READ(21,2227) PARRANFIX(I)
        END DO
       ENDIF

      ENDIF
C  ABOVE ENDIF IS FOR THE  IF(ICODEPRI .EQ. 2)  CONDITION.


      DO I=1,NVAR
       READ(21,*)
      END DO
 
      IF(NOFIX .EQ. 0) READ(21,*)
      IF(NOFIX .GT. 0) READ(21,*) (VALFIX(I),I=1,NOFIX)

      IF(ICODEPRI .EQ. 2) THEN
       IF(NRANFIX .EQ. 0) READ(21,*)
       IF(NRANFIX .GT. 0) READ(21,*) (RANFIXEST(I),I=1,NRANFIX)
      ENDIF

C  NOTE THAT FOR THE PURPOSES OF THIS PROGRAM, THERE IS NO DIFFERENCE
C  BETWEEN A FIXED PARAMETER, WHOSE VALUE IS IN VALFIX(), AND A 
C  RANFIX PARAMETER, WHOSE VALUE IS IN RANFIXEST(). I.E., ONCE A 
C  RANFIX PARAMETER HAS BEEN ESTIMATED IN NPAG, IT IS THE SAME TO THIS
C  PROGRAM AS IF THAT PARAMETER HAD BEEN FIXED ALL ALONG. SO WE CAN
C  CONCATENATE ANY RANFIX PARAMETER NAMES AND VALUES TO THE END OF
C  PARFIX AND VALFIX AND TREAT THEM AS FIXED PARAMETERS FROM THIS POINT
C  ON.

      IF(ICODEPRI .EQ. 2 .AND. NRANFIX .GT. 0) THEN
       DO I = 1, NRANFIX
        PARFIX(NOFIX+I) = PARRANFIX(I)
        VALFIX(NOFIX+I) = RANFIXEST(I)
       END DO
       NOFIX = NOFIX + NRANFIX
      ENDIF

	
      READ(21,*)
      READ(21,*) 
      READ(21,*) 
 
      DO I = 1,NACTVE
       READ(21,*) (CORDEN(I,J),J=1,NVAR+1)
      END DO


C  STORE THIS INFO TO FILE, DENQZPX.DAT. 

      OPEN(25,FILE='DENQZPX.DAT',ERR=190,STATUS='NEW')
      GO TO 180

  190 WRITE(*,191)
  191 FORMAT(/' FILE "DENQZPX.DAT" ALREADY EXISTS, AND IS ABOUT TO'/
     1' BE OVERWRITTEN WITH THE INFO FROM THE NPAG OUTPUT FILE YOU'/
     2' ENTERED ABOVE. '//
     3' IF YOU DO NOT WANT THIS TO HAPPEN, STOP THIS PROGRAM NOW,'/
     4' COPY DENQZPX.DAT TO ANOTHER FILE, AND THEN RERUN. '/)
      CALL PAUSE

      OPEN(25,FILE='DENQZPX.DAT')

  180  WRITE(25,*) NVAR
       WRITE(25,*) NACTVE
       DO I = 1,NACTVE
        WRITE(25,*) (CORDEN(I,J),J=1,NVAR+1)
       END DO

       WRITE(25,*) NOFIX

       IF(NOFIX .GT. 0) THEN
        DO I = 1,NOFIX
         WRITE(25,*) VALFIX(I)
        END DO
       ENDIF

       CLOSE(25)



C  STORE THE FIRST PATIENT DATA FILE INTO PATQZPX.001. THIS WILL GIVE
C  THE PROGRAM THE DOSAGE REGIMEN, THE OBSERVED VALUE TIMES, AND 
C  THE ASSAY COEFFICIENTS.

      OPEN(25,FILE='PATQZPX.001',ERR=30,STATUS='NEW')
      GO TO 40


   30 WRITE(*,31)
   31 FORMAT(/' FILE "PATQZPX.001" ALREADY EXISTS, AND IS ABOUT TO'/
     1' BE OVERWRITTEN WITH THE FIRST PATIENT DATA INFO FROM THE '/
     2' NPAG OUTPUT FILE YOU ENTERED ABOVE. '//
     3' IF YOU DO NOT WANT THIS TO HAPPEN, STOP THIS PROGRAM NOW,'/
     4' COPY PATQZPX.001 TO ANOTHER FILE, AND THEN RERUN. '/)

      CALL PAUSE

      OPEN(25,FILE='PATQZPX.001')
   40 READ(21,3) READLINE
      IF(READLINE(19:43) .NE. 'START OF THE PATIENT DATA') GO TO 40
      READ(21,3) READLINE

C  WRITE THE INFO FOR THE FIRST SUBJECT TO FILE 25. START BY WRITING
C  ALL THE LINES DOWN TO THE ONE WHICH HAS THE NO. OF DRUGS ON IT
C  EXACTLY AS IN FILE 21. AFTER THAT, THE DOSAGE AND OBSERVATION INFO 
C  WILL BE READ AND WRITTEN IN ARRAYS, TO MAKE SURE THERE IS NO PROBLEM 
C  WITH WORD WRAP FOR LINES WHICH ARE EXTRA LONG.

   50 READ(21,3) READLINE
      WRITE(25,3) READLINE
      IF(READLINE(12:23) .NE. 'NO. OF DRUGS') GO TO 50

      BACKSPACE(21)
      READ(21,4) NDRUG
    4 FORMAT(T2,I5)

      READ(21,3) READLINE
      WRITE(25,3) READLINE
      BACKSPACE(21)
      READ(21,4) NADD

      NI = 2*NDRUG + NADD

      READ(21,3) READLINE
      WRITE(25,3) READLINE
      BACKSPACE(21)
      READ(21,4) ND

      READ(21,3) READLINE
      WRITE(25,3) READLINE
      READ(21,3) READLINE
      WRITE(25,3) READLINE

      IF(ND .EQ. 0) GO TO 60

      DO I = 1,ND
       READ(21,*) SIG(I),(RS(I,J),J=1,NI)
       WRITE(25,*) SIG(I),(RS(I,J),J=1,NI)     
      END DO


   60 READ(21,3) READLINE
      WRITE(25,3) READLINE
      IF(READLINE(12:30) .NE. 'NO. OF TOTAL OUTPUT') GO TO 60

      BACKSPACE(21)
      READ(21,4) NUMEQT

      READ(21,3) READLINE
      WRITE(25,3) READLINE
      BACKSPACE(21)
      READ(21,4) NOBSER

      DO I=1,NOBSER
       READ(21,*) T,(YOI(J),J=1,NUMEQT)
       WRITE(25,*) T,(YOI(J),J=1,NUMEQT)
      END DO

C  NOW WRITE THE REST OF THE PATIENT INFO TO FILE 25. THIS WILL BE 
C  EVERY LINE UNTIL "LAST AND FIRST" OCCURS IN COLUMNS 3:16 (IF THERE
C  IS AT LEAST ONE MORE PATIENT IN THE OUTPUT FILE), OR UNTIL 

C  "END OF PATIENT DATA" OCCURS IN COLUMNS 19:41 (IF THERE IS ONLY
C  THE ONE PATIENT IN THE OUTPUT FILE).

   70 READ(21,3) READLINE
      IF((READLINE(3:16) .NE. 'LAST AND FIRST') .AND.
     1   (READLINE(19:41) .NE. 'END OF THE PATIENT DATA')) THEN
       WRITE(25,3) READLINE
       GO TO 70
      ENDIF

C  TO GET HERE MEANS THAT ALL THE PATIENT DATA HAS BEEN WRITEN
C  TO FILE 25. SO CLOSE FILE 25.

      CLOSE(25)



C  STORE THE MODEL FILE INFORMATION INTO MODELQZPX.FOR, SO THIS
C  FILE CAN BE COMPILED WITH THE "ENGINE" (dopteng3.f, OR A UPDATED
C  VERSION).

      OPEN(25,FILE='MODELQZPX.FOR',ERR=80,STATUS='NEW')
      GO TO 90

   80 WRITE(*,81)
   81 FORMAT(/' FILE "MODELQZPX.FOR" ALREADY EXISTS, AND IS ABOUT TO'/
     1' BE OVERWRITTEN WITH THE MODEL FILE INFO FROM THE '/
     2' NPAG OUTPUT FILE YOU ENTERED ABOVE. '//
     3' IF YOU DO NOT WANT THIS TO HAPPEN, STOP THIS PROGRAM NOW,'/

 
     4' COPY MODELQZPX.FOR TO ANOTHER FILE, AND THEN RERUN. '/)
      CALL PAUSE

      OPEN(25,FILE='MODELQZPX.FOR')
     
C  SEARCH FOR THE LINE WITH "SUBROUTINE DIFFEQ(..."; THEN COPY THIS 
C  LINE AND ALL LINES TO THE LAST LINE IN THE FILE, WHICH HAS
C  " ... *** END OF npagdriv.f FILE *** ..." IN IT. 

   90 READ(21,3) READLINE
      CALL CHECKMOD(READLINE,IYES)
      IF(IYES .EQ. 0) GO TO 90

C  TO GET HERE MEANS THE CURRENT LINE, READLINE, CONTAINS THE FIRST
C  LINE OF SUBROUTINE DIFFEQ. BACKSPACE ONE LINE AND THEN WRITE THE
C  REST OF THE FILE 21, UP TO BUT NOT INCLUDING THE LINE WITH
C  "****** ... END OF THE npagdriv.f FILE *****..." ON IT, TO FILE 25.     

      BACKSPACE(21)

C  SET INDP = 0; IT WILL BE THE RUNNING NO. OF PARAMETERS WHOSE NAMES
C  HAVE BEEN ESTABLISHED IN THE PSYM(.) ARRAY (WHICH IS IN SUBROUTINE
C  SYMBOL OF THE MODEL FILE) BELOW.

      INDP = 0

  100 READ(21,3) READLINE

      IF(READLINE(19:37) .NE. 'END OF THE npagdriv') THEN
       WRITE(25,3) READLINE

C  ALSO, ESTABLISH PSYM(I),I=1,NVAR, FROM THE CODE IN SUBROUTINE SYMBOL
C  OF THE MODEL FILE. THIS INFO STARTS IN COLUMN 8. NOTE THAT THE 
C  PARAMETER NAME STARTS IN ENTRY 17 IF INDP .LE. 9, AND IN ENTRY 18
C  IF INDP .GE. 10. AND NOTE THAT A FULL 11 CHARACTERS WILL BE PUT INTO
C  EACH PSYM(.). THIS MEANS IF THE NAME IS ONLY, E.G., 7 CHARACTERS 
C  LONG, PSYM(.) WILL INCLUDE THE ENDING SINGLE QUOTE AND SOME EXTRA
C  SPACES. 
 
       IF(READLINE(8:12) .EQ. 'PSYM(') THEN
        INDP = INDP + 1
        IF(INDP .LE. 9)  PSYM(INDP) = READLINE(17:27)
        IF(INDP .GE. 10) PSYM(INDP) = READLINE(18:28)
       ENDIF
                
       GO TO 100

      ENDIF
C  THE ABOVE ENDIF IS FOR THE IF(READLINE(19:37 .NE. ...)  CONDITION.


      CLOSE(25)


C  ESTABLISH IRAN(I), I=1,NVAR+NOFIX, WHERE IRAN(I) = 1 IF THE
C  CORRESPONDING PARAMETER IN PSYM(.) IS RANDOM, AND = 0 IF IT IS
C  FIXED. RECALL THAT PAR(I), I=1,NVAR, CONTAINS THE NAMES OF THE
C  RANDOM VARIABLES, AND PARFIX(I), I=1,NOFIX, CONTAINS THE NAMES OF
C  THE FIXED PARAMETERS.

C  AND NOTE THAT IF THERE WERE ANY RANFIX PARAMETERS IN THE NPAG RUN,
C  THEY ARE NOW TREATED AS FIXED PARAMETERS, AND HAVE ALREADY HAD THEIR
C  VALUES CONCATENATED ONTO THE END OF PARFIX() AND VALFIX(), AND NOFIX
C  HAS BEEN INCREASED BY NRANFIX.


      NRAN = 1
      NFIX = 1

      DO I = 1,NVAR+NOFIX
       
C  ESTABLISH THE NEXT PARAMETER NAME IN PSYM, ALONG WITH THE NEXT
C  RANDOM VARIABLE CANDIDATE AND THE NEXT FIXED PARAMETER CANDIDATE, 
C  ALONG WITH THE NO. OF CHARACTERS IN EACH.

       PSYMNAME = PSYM(I)


       IF(NRAN .LE. NVAR) THEN

        RANNAM = PAR(NRAN)
        DO IR = 1,11
         IF(RANNAM(IR:IR) .EQ. ' ') GO TO 230
        END DO
        IR = 12

  230   IR = IR-1

        IF(RANNAM(1:IR) .EQ. PSYMNAME(1:IR)) THEN
         IRAN(I) = 1
         NRAN = NRAN + 1
        ENDIF
      
        ENDIF
C  THE ABOVE ENDIF IS FOR THE  IF(NRAN .LE. NVAR)  CONDITION.


       IF(NFIX .LE. NOFIX) THEN

        FIXNAM = PARFIX(NFIX)
        DO IF = 1,11
         IF(FIXNAM(IF:IF) .EQ. ' ') GO TO 240
        END DO
        IF = 12

  240   IF = IF-1

        IF(FIXNAM(1:IF) .EQ. PSYMNAME(1:IF)) THEN
         IRAN(I) = 0
         NFIX = NFIX + 1
        ENDIF


        ENDIF
C  THE ABOVE ENDIF IS FOR THE  IF(NRAN .LE. NVAR)  CONDITION.



      END DO
C  THE ABOVE END DO IS FOR THE  DO I = 1,NVAR+NOFIX  LOOP.



C  OPEN DATAXQPZ.DAT AND WRITE IN IRAN(.), IERRMOD, AND GAMLAM.

      OPEN(25,FILE='DATAQZPX.DAT',ERR=250,STATUS='NEW')
      GO TO 260

  250 WRITE(*,251)
  251 FORMAT(/' FILE "DATAQZPX.DAT" ALREADY EXISTS, AND IS ABOUT TO'/
     1' BE OVERWRITTEN WITH THE INFO FROM THE NPAG OUTPUT FILE YOU'/
     2' ENTERED ABOVE. '//
     3' IF YOU DO NOT WANT THIS TO HAPPEN, STOP THIS PROGRAM NOW,'/
     4' COPY DATAQZPX.DAT TO ANOTHER FILE, AND THEN RERUN. '/)
      CALL PAUSE

      OPEN(25,FILE='DATAQZPX.DAT')

  260 WRITE(25,*) RTOL
      WRITE(25,*) IERRMOD,GAMLAM
      DO I = 1,NVAR+NOFIX
       WRITE(25,*) IRAN(I)
      END DO

      CLOSE(25)



C  ALLOW THE USER TO CHANGE THE VALUES/FILES JUST READ IN IF HE WANTS
C  TO. BUT THE VALUES IN DATAQZPX.DAT WILL NOT BE CHANGEABLE SINCE THEY
C  ARE INTRINSIC TO THE OUTPUT FILE - I.E., IRAN(.) CAN'T BE CHANGED 
C  SINCE IT WOULDN'T MAKE SENSE TO INTERCHANGE RANDOM AND FIXED
C  DESIGNATIONS; AND IERRMOD AND GAMLAM SHOULDN'T BE CHANGED SINCE THE
C  THE DENSITY FILE WAS CALCULATED BASED ON THESE VALUES. 

  110 WRITE(*,101)
  101 FORMAT(//' ENTER 0 IF YOU WOULD LIKE TO CHANGE THE JOINT '/
     1'         DENSITY OR THE FIXED PARAMETER VALUES (WHICH NOW '/
     2'         INCLUDE ANY RANFIX ESTIMATED PARAMETER VALUES) TO BE'/
     3'         USED IN THE D-OPTIMAL CALCULATIONS FROM THE VALUES'/
     4'         READ IN. FROM YOUR NPAG OUTPUT FILE (THESE VALUES ARE'/
     5'         CURRENTLY STORED IN FILE, DENQZPX.DAT);'/
     6' ENTER 1 OTHERWISE: ')

      READ(*,*,ERR= 110) ICHANGE
      IF(ICHANGE .NE. 0 .AND. ICHANGE .NE. 1) GO TO 110

      IF(ICHANGE .EQ. 0) THEN
  
       GO TO 120

  115  WRITE(*,14) DENFILE

  120  WRITE(*,102) NVAR,NOFIX,NOFIX 
  102  FORMAT(/' ENTER THE NAME OF THE FILE WHICH HAS THE JOINT '/
     1' DENSITY AND FIXED VALUES TO BE USED. THIS FILE MUST HAVE ',I2/
     2' ON LINE 1 (NO. OF RANDOM VARIABLES); NACTVE (THE NO. OF ACTIVE'/
     3' GRID POINTS ON LINE 2; NACTVE LINES, EACH WITH THE GRID PT. '/
     4' VALUES, IN THE SAME ORDER AS IN YOUR NPAG RUN, FOLLOWED BY'/
     5' THE ASSOCIATED DENSITY; ',I2,' ON THE NEXT LINE (NO. OF FIXED'/
     6' PARAMETER VALUES, WHICH NOW ALSO INCLUDES ANY RANFIX ESTIMATED'/
     7' VALUES); AND THEN ',I2,' LINES, ONE FOR EACH FIXED PARAMETER'/
     8' VALUE IN THE SAME ORDER AS IN YOUR NPAG RUN.'//
     9' ENTER THE NAME OF THIS FILE: ')  


       READ(*,2) DENFILE
        OPEN(24,FILE=DENFILE,ERR=115,STATUS='OLD') 
       CLOSE(24)

       WRITE(*,173) DENFILE
  173  FORMAT(/' THE FILE, ',A20,' IS ABOUT TO BE COPIED TO'/
     1' DENQZPX.DAT ... SO IF YOU WISH TO SAVE DENQZPX.DAT AS IT'/
     2' WAS MADE FROM YOUR NPAG OUTPUT FILE, COPY IT TO ANOTHER FILE'/
     3' BEFORE CONTINUING.'/)
       CALL PAUSE

        COMARG = CopyFile//DENFILE//' '//'DENQZPX.DAT' 
        CALL SYSTEM(COMARG)

      ENDIF
C  THE ABOVE ENDIF IS FOR THE  IF(ICHANGE .EQ. 0)  CONDITION.


  130 WRITE(*,131)
  131 FORMAT(/' ENTER 0 IF YOU WOULD LIKE TO CHANGE THE PATIENT'/
     1'         DATA FILE FROM PATQZPX.001, WHICH WAS READ IN FROM'/
     2'         YOUR NPAG OUTPUT FILE;'/
     3' ENTER 1 OTHERWISE: ')
      READ(*,*,ERR=130) ICHANGE
      IF(ICHANGE .NE. 0 .AND. ICHANGE .NE. 1) GO TO 130


      IF(ICHANGE .EQ. 0) THEN

       GO TO 140 

  135  WRITE(*,14) PATFILE 

  140  WRITE(*,132)


  132  FORMAT(/' ENTER THE NAME OF THE PATIENT DATA FILE. THIS FILE'/
     1' CAN BE A (MULTIPLE DRUG) WORKING COPY PATIENT DATA FILE OR'/
     2' A BLOCK MATRIX .CSV FILE (THE INFO WILL COME FROM THE DATA OF '/
     3' THE FIRST SUBJECT IN THIS CASE ... AND NOTE THAT THIS SUBJECT'/
     4' MUST HAVE ASSAY COEFFICIENTS SPECIFIED - OTHERWISE THE '/
     5' ASSAY COEFS. WILL ALL BE DEFAULTED TO 1.0).'//
     4' ENTER 1 TO ENTER INFO USING A .CSV FILE; '/
     5' ENTER 0 TO ENTER INFO USING A WORKING COPY PATIENT DATA FILE: ')
        READ(*,*,ERR=140) ICSVFILE
        IF(ICSVFILE .NE. 1 .AND. ICSVFILE .NE. 0) GO TO 140


        IF(ICSVFILE .EQ. 0) THEN

         WRITE(*,1021)
 1021    FORMAT(/' ENTER THE NAME OF THE WORKING COPY FILE: ')
         READ(*,2) PATFILE
         OPEN(24,FILE=PATFILE,ERR=135,STATUS='OLD')
         CLOSE(24)

         WRITE(*,133) PATFILE
  133    FORMAT(/' THE FILE, ',A20,' IS ABOUT TO BE COPIED TO'/
     1' PATQZPX.001 ... SO IF YOU WISH TO SAVE PATQZPX.001 AS IT WAS'/
     2' MADE FROM YOUR NPAG OUTPUT FILE, COPY IT TO ANOTHER FILE'/
     3' BEFORE CONTINUING.'/)
         CALL PAUSE

         COMARG = CopyFile//PATFILE//' '//'PATQZPX.001'
         CALL SYSTEM(COMARG)


        ENDIF



        IF(ICSVFILE .EQ. 1) THEN


         WRITE(*,3021)
 3021    FORMAT(/' ENTER THE NAME OF THE BLOCK MATRIX .CSV FILE (BE'/
     1' SURE THAT THIS FILE DOES NOT INCLUDE STEADY STATE DOSING: ')
         READ(*,2) PATFILE

         WRITE(*,233) PATFILE
  233    FORMAT(/' THE DATA FROM THE FIRST SUBJECT IN FILE, ',A20,' IS'/
     1' ABOUT TO BE COPIED TO PATQZPX.001 ... SO IF YOU WISH TO SAVE'/
     2' PATQZPX.001 AS IT WAS MADE FROM YOUR NPAG OUTPUT FILE, COPY IT'/
     3' TO ANOTHER FILE BEFORE CONTINUING.'/)
         CALL PAUSE


         OPEN(87,FILE=PATFILE,ERR=135,STATUS='OLD')

C  BEFORE CALLING NEWCSV, MUST CALL CONVERTCSV, WHICH CONVERTS A 
C  "EUROPEAN" .CSV FILE TO THE TYPICAL "AMERICAN" VERSION. IF THE .CSV 
C  FILE IS ALREADY IN THE "AMERICAN" FORMAT, CONVERTCSV SIMPLY REWRITES
C  FILE 87 TO SCRATCH FILE 77. NOTE THAT NEWCSV CONVERTS FILE 77 TO 
C  FILE 67.

         CALL CONVERTCSV

C  CALL SUBROUTINE NEWCSV WHICH CONVERTS THE .CSV FILE IN FILE 77 TO
C  A NEW .CSV FILE IN FILE 67, WITH ALL MISSING VALUE DOTS CHANGED TO
C  n's. THEN CALL CSVCHANGE WHICH CHANGES .csv FILES WITH CODE OF
C  POPDATA DEC_11 (I.E., THOSE WITH 2 EXTRA COLUMNS FOR ADDL AND II)
C  TO EQUIVALENT .csv FILES WITH CODE OF POPDATA APR_11 (THOSE WITHOUT
C  THE TWO EXTRA COLUMNS). CSVCHANGE READS FILE 67, AND WRITES THE 
C  INFORMATION TO SCRATCH FILE 66. NOTE THAT IF THE .csv FILE READ IN
C  ALREADY IS THE OLDER VERSION (WITH CODE POPDATA APR_11), CSVCHANGE
C  SIMPLY REWRITES IT TO FILE 66, WHICH IS THEN READ BY SUBROUTINE
C  READBLOCK3.

         OPEN(67)
         CALL NEWCSV
         CALL CSVCHANGE
         REWIND(66)
         CALL READBLOCK3
C  NOTE THAT READBLOCK3 DIFFERS FROM READBLOCK2 IN MONT113.FOR IN 
C  THAT THE PATH IS NOT NEEDED (SINCE THE INPUT FILE MUST BE IN THE
C  CURRENT DIRECTORY; THE POPULATION ASSAY COEFFICIENTS ARE NOT 
C  SUPPLIED, SINCE THEY ARE ASSUMED TO BE IN THE .CSV FILE; AND THE
C  FILE CREATED IS 'PATQZPX.001', RATHER THAN 'XQZPJ001.ZMQ').
         CLOSE(66)


C  NOW OPEN THE JUST MADE WORKING COPY PATIENT DATA FILE.

         OPEN(24,FILE='PATQZPX.001',ERR=5465,STATUS='OLD')
         GO TO 5470
 5465    WRITE(*,5466) 'PATQZPX.001',PATFILE
 5466    FORMAT(//' THE FOLLOWING FILE DOES NOT EXIST ... '/
     1' ',A93/
     2' WHICH MEANS THAT YOUR .CSV FILE, ',A20,' WAS NOT READ '/
     3' PROPERLY. PLEASE CHECK THIS FILE TO MAKE SURE IT IS CORRECT.'//)
         GO TO 140

 5470    CLOSE(24)

        ENDIF


C  THE ABOVE ENDIF IS FOR THE  IF(ICSVFILE .EQ. 1) CONDITION.


      ENDIF
C  THE ABOVE ENDIF IS FOR THE  IF(ICHANGE .EQ. 0)  CONDITION.


  150 WRITE(*,151)
  151 FORMAT(/' ENTER 0 IF YOU WOULD LIKE TO CHANGE THE MODEL FILE'/
     1'         FROM MODELQZPX.FOR, WHICH WAS READ IN FROM'/
     2'         YOUR NPAG OUTPUT FILE;'/
     3' ENTER 1 OTHERWISE: ')
      READ(*,*,ERR=150) ICHANGE
      IF(ICHANGE .NE. 0 .AND. ICHANGE .NE. 1) GO TO 150


      IF(ICHANGE .EQ. 0) THEN

       GO TO 160 

  155  WRITE(*,14) PATFILE 

  160  WRITE(*,152)
  152  FORMAT(/' ENTER THE NAME OF THE MODEL. NOTE THAT THIS FILE'/
     1' SHOULD BE BASED ON THE TEMPLATE FILE, TSTMULTN.FOR, AND'/

     2' THE PARAMETERS IN SUBROUTINE SYMBOL SHOULD BE THE SAME AS'/
     3' THOSE LISTED IN THE NPAG OUTPUT FILE YOU ENTERED ABOVE: ')
       READ(*,2) MODELFILE
        OPEN(24,FILE=MODELFILE,ERR=155,STATUS='OLD')
       CLOSE(24)

       WRITE(*,153) MODELFILE
  153  FORMAT(/' THE FILE, ',A20,' IS ABOUT TO BE COPIED TO'/
     1' MODELQZPX.FOR ... SO IF YOU WISH TO SAVE MODELQZPX.FOR AS IT'/
     2' WAS MADE FROM YOUR NPAG OUTPUT FILE, COPY IT TO ANOTHER FILE'/
     3' BEFORE CONTINUING.'/)
       CALL PAUSE

       COMARG = CopyFile//MODELFILE//' '//'MODELQZPX.FOR'
       CALL SYSTEM(COMARG)

      ENDIF
C  THE ABOVE ENDIF IS FOR THE  IF(ICHANGE .EQ. 0)  CONDITION.


      STOP
      END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
      SUBROUTINE CHECKMOD(READLINE,IYES)
      CHARACTER READLINE*72

C  THIS ROUTINE INPUTS READLINE, AND OUTPUTS IYES, WHICH IS
C  0 IF "SUBROUTINE DIFFEQ(NDIM" DOES NOT APPEAR ANYWHERE IN READLINE;
C  1 IF "SUBROUTINE DIFFEQ(NDIM" DOES APPEAR IN READLINE.

      IYES = 0
C
      DO I = 1,51
       IF(READLINE(I:I+21) .EQ. 'SUBROUTINE DIFFEQ(NDIM') THEN
        IYES = 1
        RETURN
       ENDIF
      END DO

      RETURN
      END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
        SUBROUTINE PAUSE

C  THIS ROUTINE IS USED TO REPLACE A PAUSE STATEMENT, WHICH CAUSES
C  WARNINGS WHEN THIS PROGRAM IS COMPILED AND LINKED USING gfortran
C  (AND FORCES THE USER TO TYPE "go" INSTEAD OF SIMPLY HITTING THE
C  ENTER KEY).

        WRITE(*,1)
    1   FORMAT(' HIT ANY KEY TO CONTINUE: ')
        READ(*,*,ERR=10) IKEY
        IF(IKEY .EQ. 1) RETURN
   10   RETURN
        END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
      SUBROUTINE CONVERTCSV
      IMPLICIT REAL*8(A-H,O-Z)

      CHARACTER READLINE*1000,ERRFIL*20

      COMMON/ERROR/ERRFIL
C  COMMON/ERROR/ IS SUPPLIED TO ALL THE ROUTINES WHICH COULD WRITE TO
C  ERRFIL.

C  SUBROUTINE CONVERTCSV READS FILE 87 AND WRITES SCRATCH FILE 77.
C  IF FILE 87 IS ALREADY IN THE TYPICAL "AMERICAN" .CSV FORMAT, 
C  FILE 77 IS THE SAME AS FILE 87. 

C  IF FILE 87 IS IN THE "EUROPEAN" .CSV FORMAT, WHERE SEMICOLONS
C  ARE THE FIELD SEPARATORS, AND COMMAS ARE USED TO SEPARATE THE
C  WHOLE AND FRACTIONAL PARTS OF NUMBERS, IT WILL BE WRITTEN TO
C  FILE 77 WITH THE INDICATED CHANGES BELOW.


C  FILE 87 IS AT LINE 1. READ PAST THIS LINE TO READ LINE 2 AND CHECK
C  FOR A SEMICOLON. IF ONE IS FOUND, THEN THIS IS A "EUROPEAN" VERSION OF
C  A .CSV FILE. NOTE THAT IT IS ONLY NECESSARY TO CHECK THE FIRST FEW
C  CHARACTERS OF THIS LINE - EITHER THERE WILL BE COMMAS OR SEMICOLONS.
C  IF THERE ARE BOTH COMMAS AND SEMICOLONS, SOMETHING IS WRONG WITH THE
C  FILE; IN THIS CASE, PRINT A MESSAGE TO THE USER AND STOP.
C  NOTE THAT, EVEN IN THE "EURO" VERSION, IT WILL STILL BE ASSUMED THAT
C  A DOT REPRESENTS AN UNNEEDED VALUE.

        READ(87,*)
        READ(87,4) READLINE

        ICOMMA = 0
        ISEMICOLON = 0

        DO I = 1,20
         IF(READLINE(I:I) .EQ. ',') ICOMMA = 1
         IF(READLINE(I:I) .EQ. ';') ISEMICOLON = 1
        END DO

C  IF ICOMMA = 1 AND ISEMICOLON = 0, NO CONVERSION IS NEEDED AS THIS
C  FILE IS A TYPICAL .CSV FILE. IN THIS CASE SET ICONVERT = 0.

C  IF ICOMMA = 0 AND ISEMICOLON = 1, CONVERT THIS FILE AS FOLLOWS:
C  a. CHANGE ALL COMMAS TO PERIODS; THEN
C  b. CHANGE ALL SEMICOLONS TO COMMAS.
C  IN THIS CASE, SET ICONVERT = 1.

C  IF ICOMMA = 1 AND ISEMICOLON = 1, STOP THE PROGRAM WITH A MESSAGE TO
C  THE USER.

        IF(ICOMMA .EQ. 1 .AND. ISEMICOLON .EQ. 1) THEN



         WRITE(*,121)
  121    FORMAT(/' YOUR .CSV FILE HAS BOTH COMMAS AND SEMICOLONS IN '/
     1' THE SECOND LINE. THIS IS A CONFLICT. IF YOU ARE USING THE '/
     2' "EUROPEAN" VERSION OF A .CSV FILE, WITH SEMICOLONS AS FIELD'/
     3' SEPARATORS AND COMMAS TO SEPARATE THE WHOLE AND FRACTIONAL'/
     4' PARTS OF NUMBERS, THERE SHOULD BE NO COMMAS IN THE SECOND'/
     5' LINE.'//
     6' SIMILARLY IF YOU ARE USING THE "AMERICAN" VERSION OF A .CSV'/
     7' FILE, WITH COMMAS AS FIELD SEPARATORS, AND PERIODS TO SEPARTE'/
     8' THE WHOLE AND FRACTIONAL PARTS OF NUMBERS, THERE SHOULD BE NO'/
     9' SEMICOLONS IN THE SECOND LINE.'//
     1' PLEASE CORRECT YOUR .CSV FILE AND RERUN THE PROGRAM.'//)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,121) 
        CLOSE(42)	



         CALL PAUSE
         STOP



        ENDIF


        IF(ICOMMA .EQ. 1 .AND. ISEMICOLON .EQ. 0) ICONVERT = 0
        IF(ICOMMA .EQ. 0 .AND. ISEMICOLON .EQ. 1) ICONVERT = 1      

        REWIND(87)
        OPEN(77)


C  COPY FILE 87 TO FILE 77 BUT MAKE THE INDICATED CHANGES, IF
C  ICONVERT = 1, LINE BY LINE.

   10   READ(87,4,IOSTAT=IEND) READLINE
    4   FORMAT(A1000)
        IF(IEND .LT. 0) GO TO 100

C  FOR THIS LINE, READLINE, FIND IENDL, THE LAST CHARACTER WHICH IS NOT
C  BLANK. THEN ONLY CHARACTERS 1:IENDL WILL BE WRITTEN TO FILEOUT.

        DO IENDL = 1000,1,-1
         IF(READLINE(IENDL:IENDL) .NE. ' ') GO TO 20
        END DO

   20   CONTINUE

        DO I = 1,IENDL
         IF(ICONVERT .EQ. 1) THEN
          IF(READLINE(I:I) .EQ. ',') READLINE(I:I) = '.'
          IF(READLINE(I:I) .EQ. ';') READLINE(I:I) = ','
         ENDIF
        END DO


C  CANNOT USE WRITE(77,4) READLINE(1:IENDL) SINCE, FOR SOME REASON,
C  WRITING LIKE THIS "RIGHT JUSTIFIES" THE CHARACTERS AT THE END
C  OF THE A1000 FORMAT. INSTEAD MUST WRITE (77,__) READLINE, WHERE
C  THE FORMAT IS DETERMINED BY THE LAST NON-BLANK CHARACTER (IENDL)
C  IN READLINE.

	IF(IENDL .LE. 26) THEN
	 WRITE(77,26) READLINE
   26    FORMAT(A26)
	 GO TO 10
	ENDIF


	IF(IENDL .LE. 51) THEN
	 WRITE(77,51) READLINE
   51    FORMAT(A51)
	 GO TO 10
	ENDIF


	IF(IENDL .LE. 76) THEN
	 WRITE(77,76) READLINE
   76    FORMAT(A76)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 101) THEN

	 WRITE(77,101) READLINE
  101    FORMAT(A101)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 126) THEN
	 WRITE(77,126) READLINE
  126    FORMAT(A126)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 151) THEN
	 WRITE(77,151) READLINE
  151    FORMAT(A151)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 176) THEN

	 WRITE(77,176) READLINE
  176    FORMAT(A176)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 201) THEN

	 WRITE(77,201) READLINE
  201    FORMAT(A201)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 226) THEN
	 WRITE(77,226) READLINE
  226    FORMAT(A226)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 251) THEN
	 WRITE(77,251) READLINE
  251    FORMAT(A251)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 276) THEN

	 WRITE(77,276) READLINE
  276    FORMAT(A276)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 301) THEN
	 WRITE(77,301) READLINE
  301    FORMAT(A301)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 326) THEN
	 WRITE(77,326) READLINE
  326    FORMAT(A326)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 351) THEN
	 WRITE(77,351) READLINE
  351    FORMAT(A351)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 376) THEN
	 WRITE(77,376) READLINE
  376    FORMAT(A376)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 401) THEN
	 WRITE(77,401) READLINE
  401    FORMAT(A401)
	 GO TO 10
	ENDIF


	IF(IENDL .LE. 426) THEN
	 WRITE(77,426) READLINE
  426    FORMAT(A426)
	 GO TO 10
	ENDIF


	IF(IENDL .LE. 451) THEN
	 WRITE(77,451) READLINE
  451    FORMAT(A451)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 476) THEN

	 WRITE(77,476) READLINE
  476    FORMAT(A476)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 501) THEN
	 WRITE(77,501) READLINE
  501    FORMAT(A501)
	 GO TO 10
	ENDIF


	IF(IENDL .LE. 526) THEN
	 WRITE(77,526) READLINE
  526    FORMAT(A526)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 551) THEN
	 WRITE(77,551) READLINE
  551    FORMAT(A551)
	 GO TO 10
	ENDIF


	IF(IENDL .LE. 576) THEN
	 WRITE(77,576) READLINE
  576    FORMAT(A576)
	 GO TO 10
	ENDIF


	IF(IENDL .LE. 601) THEN
	 WRITE(77,601) READLINE
  601    FORMAT(A601)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 626) THEN
	 WRITE(77,626) READLINE
  626    FORMAT(A626)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 651) THEN
	 WRITE(77,651) READLINE
  651    FORMAT(A651)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 676) THEN
	 WRITE(77,676) READLINE
  676    FORMAT(A676)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 701) THEN
	 WRITE(77,701) READLINE
  701    FORMAT(A701)
	 GO TO 10

	ENDIF


	IF(IENDL .LE. 726) THEN
	 WRITE(77,726) READLINE
  726    FORMAT(A726)
	 GO TO 10

	ENDIF


	IF(IENDL .LE. 751) THEN
	 WRITE(77,751) READLINE
  751    FORMAT(A751)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 776) THEN
	 WRITE(77,776) READLINE

  776    FORMAT(A776)
	 GO TO 10
	ENDIF



	IF(IENDL .LE. 801) THEN
	 WRITE(77,801) READLINE
  801    FORMAT(A801)
	 GO TO 10

	ENDIF

	IF(IENDL .LE. 826) THEN
	 WRITE(77,826) READLINE

  826    FORMAT(A826)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 851) THEN
	 WRITE(77,851) READLINE
  851    FORMAT(A851)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 876) THEN
	 WRITE(77,876) READLINE

  876    FORMAT(A876)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 901) THEN
	 WRITE(77,901) READLINE
  901    FORMAT(A901)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 926) THEN
	 WRITE(77,926) READLINE
  926    FORMAT(A926)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 951) THEN
	 WRITE(77,951) READLINE
  951    FORMAT(A951)
	 GO TO 10
	ENDIF


	IF(IENDL .LE. 976) THEN
	 WRITE(77,976) READLINE
  976    FORMAT(A976)
	 GO TO 10
	ENDIF

	WRITE(77,4) READLINE
	GO TO 10




  100   CLOSE(87)
        REWIND(77)


        RETURN
        END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
      SUBROUTINE CSVCHANGE

C  SUBROUTINE CSVCHANGE IS CALLED BY MAIN AND SUBROUTINE GETNUMEQ TO
C  CHANGE .csv FILES WITH CODE OF POPDATA DEC_11 (I.E., THOSE WITH 2
C  EXTRA COLUMNS FOR ADDL AND II) TO EQUIVALENT .csv FILES WITH CODE OF
C  POPDATA APR_11 (THOSE WITHOUT THE TWO EXTRA COLUMNS). IT READS
C  FILE 67, AND WRITES THE INFORMATION TO SCRATCH FILE 66. NOTE THAT IF
C  THE .csv FILE READ IN ALREADY IS THE OLDER VERSION (WITH CODE 
C  POPDATA APR_11), THIS ROUTINE SIMPLY REWRITES IT TO FILE 66, WHICH IS
C  THEN READ BY SUBROUTINE READBLOCK.

C  THIS ROUTINE IS BASED ON THE STAND-A-LONE PROGRAM, CSVCHANGE.FOR.
C  AS OF IT2B104.FOR, THIS ROUTINE IS BASED ON CSVCHANGE2.FOR.

C  CSVCHANGE.FOR                                           12/6/11

C  THIS PROGRAM CONVERTS THE NEW-STYLE .csv FILES (WITH TWO ADDITIONAL
C  COLUMNS (ADDL AND II) TO THE PREVIOUS .csv FORMAT.

C  ADDL GIVES THE NO. OF ADDITIONAL DOSES FOR ANY DOSE EVENT, AND II
C  GIVES THE INTERDOSE INTERVAL FOR THE ADDITIONAL DOSES.

C  EX: IF TIME = 0, DUR = 2, DOSE = 1000, ADDL = 2, II = 12, THIS
C  PROGRAM WOULD PUT IN TWO EXTRA LINES AS FOLLOWS:

C  TIME    DUR    DOSE  ADDL  II    
C   0       2     1000   2    12  <-- ONLY LINE IN NEW-STYLE FILE
C  12       2     1000   <-- THESE TWO LINES ARE ADDED TO THE OLD
C  24       2     1000       STYLE FILE (WHICH DOESN'T HAVE ADDL AND
C                            II COLUMNS.

C  NOTE THAT ADDL = -1 IS A STEADY STATE DOSE INDICATOR. IN THIS CASE,
C  CHANGE THE TIME OF THE DOSE TO -II, SO SUBROUTINES READBLOCK/WRITEDOS

C  WILL RECOGNIZE THE LINE AS THE BEGINNING OF A STEADY STATE DOSE SET.


C  NOTE THAT ONCE ALL THE ADDITIONAL DOSES ARE ADDED TO THE DOSE
C  ARRAY, THEY MUST ALL BE ORDERED AMONG THEMSELVES (UNTIL THE NEXT
C  DOSE/TIME RESET) SINCE READBLOCK EXPECTS ORDERED DOSES. BUT IT IS
C  OK FOR ALL THE DOSES IN A GIVEN REGION TO COME FIRST, AND THEN ALL
C  THE OBSERVATIONS TO FOLLOW (I.E., THE DOSES SHOULD BE ORDERED AMONG
C  THEMSELVES AND THE OBSERVATIONS FOLLOW THE DOSES, ORDERED AMONG
C  THEMSELVES).

C  NOTE THAT ADDL AND II ENTRIES ARE IGNORED IF EVID = 0 (I.E.,THE
C  EVENT IS AN OBSERVATION).

C  NOTE THAT IF ADDL AND II ARE MISSING FOR A DOSE EVENT (EVID = 1 OR
C  4) THEN ADDL IS ASSUME TO BE 0 (NO ADDITIONAL DOSES) AND II IS
C  IRRELEVANT.

C  NOTE THAT THIS PROGRAM WILL OPEN AND READ THE NEW-STYLE .csv
C  FILE FROM FILE 67, AND THEN WRITE THE PREVIOUS .csv FORMAT TO FILE
C  66.

      IMPLICIT REAL*8(A-H,O-Z)
      DIMENSION TIMENTRY(99999),IDENTRY(99999)

      CHARACTER READLINE*1000,CODEPAT*15,
     1 READLINE2*1000,HOLDMAT(99999)*150,TIMCHAR*50,SUBID*11,
     2 SUBIDPREV*11,ERRFIL*20



      COMMON/ERROR/ERRFIL
C  COMMON/ERROR/ IS SUPPLIED TO ALL THE ROUTINES WHICH COULD WRITE TO
C  ERRFIL.

    1 FORMAT(A1000)
    2 FORMAT(A20)

      OPEN(66)

      ICODEPAT = 0


    6 FORMAT(A15)
      ICODEPAT = -1


      READ(67,6) CODEPAT
      IF(CODEPAT .EQ. '"POPDATA DEC_11') ICODEPAT = 1
      IF(CODEPAT(1:14) .EQ. 'POPDATA DEC_11') ICODEPAT = 1

      IF(CODEPAT .EQ. '"POPDATA APR_11') ICODEPAT = 0
      IF(CODEPAT(1:14) .EQ. 'POPDATA APR_11') ICODEPAT = 0


      IF(ICODEPAT .EQ. -1) THEN



       WRITE(*,7)


    7  FORMAT(//' YOUR PATIENT DATA BLOCK FILE IS NOT FROM THE'/
     1' ALLOWABLE SET OF SUCH FILES.'//
     2' A PATIENT DATA BLOCK FILE MUST HAVE "POPDATA XXX_XX IN'/
     3' COLUMNS 1 THROUGH 15 ON LINE 1, WHERE  XXX_XX  IS APR_11 OR A '/
     4' MORE RECENT DATE.'//)
       WRITE(*,*)' THE PROGRAM STOPS.'

        OPEN(42,FILE=ERRFIL)
         WRITE(42,7) 
         WRITE(42,*)' THE PROGRAM STOPS.'
        CLOSE(42)	



       CALL PAUSE
       STOP



      ENDIF

C  IF ICODEPAT = 0, THE INPUT .csv FILE IS ALREADY IN THE CORRECT FORM
C  TO BE READ BY SUBROUTINE READBLOCK. IN THIS CASE, JUST COPY FILE 67,
C  LINE BY LINE TO FILE 66.

      IF(ICODEPAT .EQ. 0) THEN

C  WRITE THE TOP LINE (WITH THE CODE) TO FILE 66.


       CODEPAT = 'POPDATA APR_11'
       WRITE(66,6) CODEPAT

 1020  READ(67,1,IOSTAT=IEND) READLINE
        IF(IEND .LT. 0) THEN
         CLOSE(67)
         RETURN
        ENDIF
       WRITE(66,1) READLINE
       GO TO 1020

      ENDIF


C  ICODEPAT = 1. SO WRITE THE INFO IN FILE 67 TO FILE 66 IN THE OLD
C  FORMAT (WITHOUT THE TWO COLUMNS FOR ADDL AND II).

C  WRITE THE TOP LINE (WITH THE CODE) TO FILE 66.

      CODEPAT = 'POPDATA APR_11'
      WRITE(66,6) CODEPAT

C  READ THE 2ND LINE OF FILE 67 AND WRITE THIS LINE TO FILE 66, BUT
C  WITHOUT THE ADDL AND II NAMES. 

      READ(67,1) READLINE

C  SEARCH FOR THE CHARACTER STRING  ",ADDL,II"  IN THE EARLY PART OF
C  READLINE AND ELIMINATE IT, BEFORE WRITING THE LINE TO FILE 66. IF
C  THIS STRING IS NOT FOUND, TELL THE USER HIS FILE 67 HAS AN ERROR IN 
C  IT, AND STOP

      DO I = 1,50
       IF(READLINE(I:I+7) .EQ. ',ADDL,II') THEN
        ISS = I
        GO TO 10
       ENDIF
      END DO

C  TO GET HERE MEANS THE ABOVE STRING WAS NEVER FOUND. SO WRITE A 

C  MESSAGE TO THE USER AND STOP.

       WRITE(*,8)
    8  FORMAT(//' YOUR PATIENT DATA BLOCK FILE IS NOT FROM THE '/
     1' ALLOWABLE SET OF SUCH FILES.'//
     2' A PATIENT DATA BLOCK FILE MUST HAVE ",ADDL,II" AS THE 6TH AND'/
     3' 7TH COLUMN HEADINGS ON LINE 2.'//)
       WRITE(*,*)' THE PROGRAM STOPS.'

        OPEN(42,FILE=ERRFIL)
         WRITE(42,8) 
         WRITE(42,*)' THE PROGRAM STOPS.'
        CLOSE(42)



       CALL PAUSE
       STOP


   10 CONTINUE

C  PUT ALL OF READLINE, EXCEPT ENTRIES ISS:ISS+7 INTO READLINE2,
C  AND WRITE READLINE2 INTO FILE 66.

      READLINE2(1:ISS-1) = READLINE(1:ISS-1)
      READLINE2(ISS:992) = READLINE(ISS+8:1000)

      WRITE(66,1) READLINE2


C  EACH LINE IN FILE 67, STARTING WITH LINE 3 (EXCEPT FOR LINES 
C  BEGINNING WITH #) HAS A SUBJECT ID IN THE 1ST 11 ENTRIES. THEN
C  THE ENTRIES ARE, IN ORDER, EVID, TIME, DUR, DOSE, ADDL, II, INPUT,
C  ...



C  READ EACH DOSE LINE (EVID = 1 OR 4) TO OBTAIN THE VALUES OF ADDL AND
C  II FOR THOSE. ADDL IS THE NO. OF ADDITIONAL DOSE LINES THAT ARE 

C  IDENTICAL TO THE CURRENT LINE, AND II IS THE ASSOCIATED INTERDOSE
C  INTERVAL. IF ADDL = -1, THIS REPRESENTS A STEADY STATE SET OF DOSES.

C  FOR A DOSE LINE, IF ADDL = 0 OR IS MISSING (WHICH MEANS ADDL IS
C  ASSUMED TO BE 0), WRITE THE LINE, WITHOUT THE ADDL AND II VALUES,
C  INTO HOLDMAT. 

C  FOR EACH DOSE LINE WITH AN ADDL > 0, WRITE THAT LINE
C  WITHOUT THE ADDL AND II VALUES, AND ADDL MORE SIMILAR LINES INTO THE
C  HOLDMAT, MAKING SURE THAT THE TIME FOR EACH SUCCESSIVE LINE
C  IS INCREASED BY II FROM THE PREVIOUS LINE.

C  NOTE THAT THE ABOVE PROCESS CAN CAUSE THE DOSE LINES TO BE OUT OF
C  ORDER IN HOLDMAT. EACH BLOCK OF DOSE LINES WILL BE 
C  ORDERED UP TO THE NEXT DOSE/TIME RESET LINE BELOW. AND NOTE THAT
C  ALL THE DOSES IN EACH REGION (UNTIL THE NEXT TIME RESET LINE - I.E.,
C  UNTIL THE NEXT EVID = 4) WILL BE WRITTEN TOGETHER, AND THEN BE
C  FOLLOWED BY ALL THE OBSERVATION LINES IN THAT REGION).


C  NOTE BELOW THAT AFTERCOMMA OPENS AND PUTS INTO FILE 57 THE PART OF
C  READLINE WHICH IS BETWEEN COMMA C AND COMMA C+1, WHERE C IS THE 3RD
C  ARGUMENT. ALSO,NOTE THAT NCOVA MUST BE PROVIDED TO AFTERCOMMA SO IT
C  WILL KNOW THE TOTAL NO. OF COMMAS IN READLINE, WHICH = 13 + NCOVA 

C  SINCE THIS FILE HAS 14 FIXED FIELDS (COUNTING THE 2 NEWS ONES, 
C  ADDL AND II).
C  
C  SO, FIRST FIND NCOVA FROM READLINE JUST READ IN (THE 2ND LINE OF THE
C  .csv FILE).

        NCOMMA = 0

        DO ISTART = 1,1000	 
         IF(READLINE(ISTART:ISTART) .EQ. ',') THEN
          NCOMMA = NCOMMA + 1
         ENDIF
        END DO

        NCOVA = NCOMMA - 13

C  INITIALIZE SUBIDPREV (THE PREVIOUS SUBJECT ID), AND THE CURRENT
C  SUBJECT TO BE '%^&*'.

	SUBIDPREV = '%^&*'
	SUBID = '%^&*'
      NROW = 0


C  NROW IS THE RUNNING INDEX OF THE NEXT LINE TO BE PUT INTO THE
C  HOLDMAT.



   20 READ(67,1,IOSTAT=IEND) READLINE


C  IF IEND .LT. 0, THE FILE HAS BEEN READ THROUGH COMPLETELY, SO GO TO
C  LABEL 100 TO WRITE THE LAST SUBJECT'S ROWS TO FILE 66.

	IF(IEND .LT. 0) GO TO 100


C  IF READLINE(1:1) IS #, THIS LINE IS A COMMENT LINE AND CAN BE
C  SKIPPED (I.E., NOT WRITTEN INTO HOLDMAT).

      IF(READLINE(1:1) .EQ. '#') GO TO 20


C  WILL ALSO GO TO LABEL 100 IF THIS SUBJECT ID IS DIFFERENT THAN
C  SUBIDPREV (SINCE THAT MEANS THAT THE PREVIOUS SUBJECT'S LINES ARE
C  READY TO BE WRITTEN TO FILE 66).    

C  THE FIRST VALUE (I.E., AFTER COMMA NO. 0) IS THE SUBJECT ID.

	CALL AFTERCOMMA(NCOVA,READLINE,0)
	BACKSPACE(57)
	READ(57,222) SUBID
  222 FORMAT(A11)
	CLOSE(57)


C  NOTE THAT SUBID CONTAINS THE 1ST 11 CHARACTERS OF THE LINE, BUT THE
C  SUBJECT ID IS JUST THE SET OF CHARACTERS PRIOR TO THE 1ST COMMA.
C  CALL SUBROUTINE GETID TO CORRECT THE VALUE OF SUBID.

	CALL GETID(SUBID)

      IF(SUBID .NE. SUBIDPREV) GO TO 100


C  TO GET TO THIS POINT, SUBID = SUBIDPREV, WHICH MEANS THIS IS A
C  LINE FOR THE CURRENT SUBJECT.

C  IF THE EVENT ID, IN ENTRY NO. 2 (I.E., AFTER COMMA NO. 1) IN 
C  READLINE IS 0, THE LINE REPRESENTS AN OBSERVATION AND CAN BE WRITTEN

C  INTO HOLDMAT, EXCEPT FOR ADDL AND II AS DONE ABOVE.

	CALL AFTERCOMMA(NCOVA,READLINE,1)
	BACKSPACE(57)
	READ(57,*) IDEVENT
	CLOSE(57)

      IF(IDEVENT .EQ. 0) THEN
       NROW = NROW + 1
       CALL GETCOM(NCOMMA,READLINE,I5,I7)
       HOLDMAT(NROW) = READLINE(1:I5)//READLINE(I7+1:150)
      ENDIF

C  IF THE EVENT ID IS 1 OR 4, THE LINE REPRESENTS A DOSE
C  EVENT (1 -> REGULAR DOSE; 4 -> TIME RESET EVENT WITH A DOSE). EITHER
C  WAY IF THE ENTRY FOR ADDL IS MISSING OR A 0, IT MEANS THAT THIS LINE
C  REPRESENTS A SINGLE DOSE. IF ADDL > 0, THIS LINE MUST BE COPIED
C  ADDL TIMES. NOTE THAT THE ADDL ENTRY IS NO. 6, AFTER COMMA NO. 5.

      IF(IDEVENT .EQ. 1 .OR. IDEVENT .EQ. 4) THEN

       CALL AFTERCOMMA(NCOVA,READLINE,5)
       BACKSPACE(57)
       READ(57,*,ERR=25) IADDL
       CLOSE(57)
       GO TO 30

   25  IADDL = 0

C  TO GET TO LABEL 25 MEANS IADDL TRIED TO READ A NON-NUMBER, WHICH 
C  MEANS IT IS MISSING --> IT IS EQUIVALENT TO 0. IN THIS CASE, WRITE
C  THE LINE INTO HOLDMAT, EXCEPT FOR IADDL AND II AS 
C  DONE ABOVE.

   30  CONTINUE
       
       IF(IADDL .GE. 0) THEN
        NROW = NROW + 1
        CALL GETCOM(NCOMMA,READLINE,I5,I7)
        HOLDMAT(NROW) = READLINE(1:I5)//READLINE(I7+1:150)
       ENDIF


       IF(IADDL .GT. 0) THEN

C  THIS LINE MUST BE COPIED IADDL TIMES, BUT EACH LINE MUST HAVE ITS 
C  TIME ENTRY INCREASED BY XII (THE INTERDOSE INTERVAL) FROM THE 

C  PREVIOUS LINE. FIRST FIND THE VALUE OF XII, IN THE 7TH ENTRY, AFTER
C  THE 6TH COMMA. IF XII IS MISSING, STOP THE PROGRAM TELLING THE USER
C  THAT THE .cvs FILE HAS AN ERROR; IT HAS A ROW WITH AN IADDL > 0, BUT
C  WITH AN ACCOMPANYING INTERDOSE INTERVAL WHICH IS MISSING. NOTE THAT
C  THIS LINE NO. IS 2 (THE TOP 2 LINES) + NROW + 1 = NROW + 3.

	  CALL AFTERCOMMA(NCOVA,READLINE,6)
	  BACKSPACE(57)
	  READ(57,*,ERR=35) XII
	  CLOSE(57)
        GO TO 40
        
   35   WRITE(*,36) NROW + 3
   36   FORMAT(/' THE INTERDOSE INTERVAL IS MISSING ON LINE NO. ',I6//
     1' PLEASE CORRECT YOUR .csv FILE AND RERUN THE PROGRAM.'/)


        OPEN(42,FILE=ERRFIL)
         WRITE(42,36) NROW + 3 
        CLOSE(42)	



        CALL PAUSE
        STOP


   40   CONTINUE

C  THE TIME FOR THE ORIGINAL DOSE IS IN ENTRY NO. 3, AFTER COMMA NO. 2.

	  CALL AFTERCOMMA(NCOVA,READLINE,2)
	  BACKSPACE(57)
	  READ(57,*) TIM
	  CLOSE(57)

        DO IADD = 1,IADDL

C  NOTE THAT THE ORIGINAL LINE FOR THIS DOSE HAS ALREADY BEEN WRITTEN
C  TO HOLDMAT (IN THE IF(IADDL .GE. 0) SECTION ABOVE). SO
C  NOW MUST WRITE IADDL LINES TO HOLDMAT, EACH IDENTICAL TO
C  THE CURRENT LINE, EXCEPT EACH TIM WILL BE INCREMENTED BY
C  XII. TO DO THIS, WRITE THE NEXT TIM + XII TO SCRATCH FILE 57; THEN
C  REREAD THIS VALUE AS A CHARACTER SO IT CAN BE INSERTED INTO
C  THE CHARACTER STRING READLINE AND THEN WRITTEN TO THE HOLDING
C  MATRIX.


C  FIRST RESET READLINE TO HOLDMAT(NROW), WHICH DOES NOT HAVE THE
C  ADDL AND II ENTRIES.

         READLINE(1:150) = HOLDMAT(NROW)

         OPEN(57,STATUS='SCRATCH')

         WRITE(57,*) TIM + XII*IADD
         BACKSPACE(57)
         READ(57,41) TIMCHAR



   41    FORMAT(A50)

C  TAKE OUT ALL SPACES AT THE END OF TIMCHAR.

         DO IEND = 50,1,-1
          IF(TIMCHAR(IEND:IEND) .NE. ' ') GO TO 50
         END DO

   50    CONTINUE

C  NOW TIMCHAR(1:IEND) IS THE CONDENSED FORM OF THE TIME FOR THIS
C  ROW. REPLACE WHAT IS CURRENTLY BETWEEN COMMAS 2 AND 3 OF 
C  HOLDMAT(NROW) WITH THIS, AND STORE IT INTO THE NEXT ROW OF HOLDMAT.

         ICOMMA = 0

         DO I = 1,150


          IF(READLINE(I:I) .EQ. ',') THEN
           ICOMMA = ICOMMA + 1
           IF(ICOMMA .EQ. 2) I2 = I
           IF(ICOMMA .EQ. 3) THEN
            I3 = I
            GO TO 60
           ENDIF
          ENDIF
         END DO

   60    READLINE2 =
     1    READLINE(1:I2)//TIMCHAR(1:IEND)//READLINE(I3:150)


         NROW = NROW + 1         
         HOLDMAT(NROW) = READLINE2(1:150)
         
        END DO

C  THE ABOVE END DO IS FOR THE  DO IADD = 1,IADDL  LOOP.


       ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(IADDL .GT. 0)  CONDITION.



       IF(IADDL .EQ. -1) THEN


C  WRITE JUST ONE LINE TO THE NEW .CSV FILE, EVEN THOUGH IADDL = -1
C  REPRESENTS A STEADY STATE DOSE SET OF 100 DOSES. MAKE THE TIME FOR
C  THIS EVENT = -II SO READBLOCK/WRITEDOS WILL KNOW THIS IS A LINE WITH
C  STEADY STATE DOSE INFO.

	  CALL AFTERCOMMA(NCOVA,READLINE,6)
	  BACKSPACE(57)
	  READ(57,*,ERR=65) XII
	  CLOSE(57)

        GO TO 70
        
   65   WRITE(*,36) NROW + 3

        OPEN(42,FILE=ERRFIL)
         WRITE(42,36) NROW + 3 
        CLOSE(42)	



        CALL PAUSE
        STOP

   70   CONTINUE

C  NOW ESTABLISH THE NEXT LINE OF HOLDMAT AS THE CURRENT
C  READLINE, BUT WITHOUT THE ENTRIES FOR ADDL AND II; THEN RESET
C  READLINE TO BE THIS NEW LINE.

        NROW = NROW + 1
        CALL GETCOM(NCOMMA,READLINE,I5,I7)
        HOLDMAT(NROW) = READLINE(1:I5)//READLINE(I7+1:150)
        READLINE(1:150) = HOLDMAT(NROW)


C  NOW ESTABLISH READLINE2 = READLINE, BUT WITH THE TIME VALUE RESET

C  TO BE TIME = -XII. TO DO THIS, WRITE -XII TO SCRATCH FILE 57; THEN
C  REREAD THIS VALUE AS A CHARACTER SO IT CAN BE INSERTED INTO
C  THE CHARACTER STRING READLINE AND THEN WRITTEN TO THE HOLDING
C  MATRIX.

         OPEN(57,STATUS='SCRATCH')

         WRITE(57,*) -XII
         BACKSPACE(57)
         READ(57,41) TIMCHAR

C  TAKE OUT ALL SPACES AT THE END OF TIMCHAR.

         DO IEND = 50,1,-1
          IF(TIMCHAR(IEND:IEND) .NE. ' ') GO TO 80
         END DO

   80    CONTINUE

C  NOW TIMCHAR(1:IEND) IS THE CONDENSED FORM OF THE TIME FOR THIS
C  ROW. REPLACE WHAT IS CURRENTLY BETWEEN COMMAS 2 AND 3 OF 
C  HOLDMAT(NROW) WITH THIS, AND STORE IT BACK INTO THE SAME ROW OF 
C  HOLDMAT.

         ICOMMA = 0

         DO I = 1,150
          IF(READLINE(I:I) .EQ. ',') THEN
           ICOMMA = ICOMMA + 1
           IF(ICOMMA .EQ. 2) I2 = I
           IF(ICOMMA .EQ. 3) THEN
            I3 = I
            GO TO 90
           ENDIF

          ENDIF
         END DO

   90    READLINE2 =
     1    READLINE(1:I2)//TIMCHAR(1:IEND)//READLINE(I3:150)
         HOLDMAT(NROW) = READLINE2(1:150)


       ENDIF 


C  THE ABOVE ENDIF IS FOR THE  IF(IADDL .EQ. -1)  CONDITION.


      ENDIF

C  THE ABOVE ENDIF IS FOR THE  
C   IF(IDEVENT .EQ. 1 .OR. IDEVENT .EQ. 4)  CONDITION.


      GO TO 20


  100 CONTINUE



C  THE FIRST TWO LINES OF FILE 66 WERE WRITTEN ABOVE. NOW WRITE THE 
C  REST OF THE FILE.

C  NOTE THAT IN EACH SECTION OF DOSES (I.E., UNTIL THE NEXT IDEVENT 
C  = 4), MUST ORDER THE DOSES SINCE THEY COULD BE OUT OF ORDER DUE TO
C  THE ADDL ENTRY. 


C  FOR EXAMPLE, A DOSE OF T = 0 WITH ADDL = 2 AND II = 12 --> DOSES AT
C  T = 0, 12, AND 24. THEN ANOTHER DOSE (FOR A DIFFERENT DRUG, OR THE
C  SAME DRUG WITH A DIFFERENT ROUTE) COULD OCCUR AT T = 8. THEN, FROM
C  THE ABOVE CODE, THE CURRENT DOSE TIMES WOULD BE [0 12 24 8].

C  SO GO THROUGH THE NROW ROWS OF HOLDMAT, AND ORDER THE ROWS IN EACH
C  SECTION (I.E., UNTL THE NEXT IDEVENT = 4 ROW). IN PARTICULAR, FIRST
C  ORDER THE DOSE ROWS (IDEVENT = 1). IF THESE ROWS FOLLOW AN 
C  IDEVENT = 4 ROW, THAT ROW GOES FIRST OF COURSE. THEN WRITE IN THE
C  OBSERVATION ROWS (THEY SHOULD ALREADY BE IN ORDER).

C  PUT ALL THE IDEVENT ENTRIES IN HOLDMAT INTO IDENTRY(.), AND PUT ALL
C  THE TIME ENTRIES IN HOLDMAT INTO TIMENTRY(.).

      DO I = 1,NROW

       READLINE(1:150) = HOLDMAT(I)

       CALL AFTERCOMMA(NCOVA,READLINE,1)
	 BACKSPACE(57)
	 READ(57,*) IDEVENT
       IDENTRY(I) = IDEVENT
	 CLOSE(57)

       CALL AFTERCOMMA(NCOVA,READLINE,2)
	 BACKSPACE(57)
	 READ(57,*) TIM
       TIMENTRY(I) = TIM
	 CLOSE(57)

      END DO


      NN = 0
      NFIRST = 1

C  NN IS THE RUNNING INDEX OF THE ROW IN HOLDMAT UNDER CONSIDERATION.
C  NFIRST IS THE RUNNING INDEX OF THE FIRST ROW IN THE NEXT SECTION
C  UNDER CONSIDERATION.

  150 CONTINUE

C  ORDER ALL THE ROWS UNTIL THE NEXT IDENTRY(.) = 4, OR UNTIL THE 
C  END OF THE ROWS IS ENCOUNTERED, WHICHEVER COMES FIRST.

      NN = NN + 1
      IF(NN .GT. NROW) GO TO 200

      IF(IDENTRY(NN) .NE. 4 .AND. NN .LT. NROW) GO TO 150

C  ORDER THE ENTRIES IN HOLDMAT FROM NFIRST TO EITHER NROW
C  (IF NN = NROW) OR TO NN-1 (IF IDENTRY(NN) = 4), AND THEN
C  WRITE THEM INTO FILE 66.

      IF(NN .EQ. NROW) NLAST = NROW
      IF(IDENTRY(NN) .EQ. 4) NLAST = NN - 1
      CALL ORDERHOLD(HOLDMAT,NFIRST,NLAST,IDENTRY,TIMENTRY)

  151 FORMAT(A150)


      DO I = NFIRST,NLAST
       WRITE(66,151) HOLDMAT(I)
      END DO      

      NFIRST = NLAST + 1

      GO TO 150

     
  200 CONTINUE

C  IF FILE 67 HAS BEEN COMPLETELY READ, RETURN.

	IF(IEND .LT. 0) THEN
       CLOSE(67)
       RETURN

      ENDIF


C  SINCE IEND .GE. 0, THE FILE HAS NOT BEEN COMPLETELY READ. SO, RESET

C  SUBIDPREV = SUBID AND NROW TO BE 0, AND BACKSPACE FILE 67 SINCE THE
C  FIRST LINE FOR THE NEXT SUBJECT WAS ALREADY READ (I.E., THE NEXT
C  READ OF FILE 67 SHOULD REREAD THIS FIRST LINE) AND GO BACK TO LABEL
C  20 TO CONTINUE READING THE FILE.


      SUBIDPREV = SUBID
      NROW = 0
      BACKSPACE(67)
      GO TO 20


      END

C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
        SUBROUTINE NEWCSV

C  NEWCSV IS CALLED BY MAIN TO CONVERT THE .CSV FILE IN FILE 77 TO
C  A NEW .CSV FILE IN FILE 67, WITH ALL MISSING VALUE DOTS CHANGED TO
C  n's. THIS CODE IS BASED ON THE STAND-A-LONE PROGRAM NEWCSV.FOR.

C  IN PARTICULAR, THE FOLLOWING SEQUENCES WILL BE REPLACED AS SHOWN:

C   ,.,  WILL BE REPLACED BY  ,n,
C   ,.   WILL BE REPLACED BY  ,n  <-- THIS OCCURS AT END OF LINES.

C  NOTE THAT THE SECOND SEQUENCE ABOVE IS COMMA/DOT/SPACE, NOT JUST
C  COMMA/DOT SINCE WE DON'T WANT ,.35  REPLACED BY ,n35, FOR EXAMPLE.

        IMPLICIT REAL*8(A-H,O-Z)
        CHARACTER READLINE*1000


C  WRITE EACH LINE OF FILE 77 TO FILE 67, BUT REPLACE ALL MISSING VALUE
C  DOTS WITH n's.       

   10   READ(77,4,IOSTAT=IEND) READLINE

    4   FORMAT(A1000)
        IF(IEND .LT. 0) GO TO 100


C  FOR THIS LINE, READLINE, FIND IENDL, THE LAST CHARACTER WHICH IS NOT
C  BLANK. THEN ONLY CHARACTERS 1:IENDL WILL BE WRITTEN TO FILEOUT.

        DO IENDL = 1000,1,-1
         IF(READLINE(IENDL:IENDL) .NE. ' ') GO TO 20
        END DO

   20   CONTINUE


C  BEFORE WRITING READLINE(1:IENDL) TO FILE 22, GO THROUGH THE LINE AND
C  REPLACE ANY DOTS WHICH REPRESENT MISSING VALUES WITH n's.

C  NOTE THAT, AS EXPLAINED ABOVE, THIS MEANS REPLACING AS FOLLOWS:
C   ,.,  WILL BE REPLACED BY  ,n,
C   ,.   WILL BE REPLACED BY  ,n  <-- THIS OCCURS AT END OF LINES.

        DO I = 1,IENDL-2
         IF(READLINE(I:I+2) .EQ. ',.,') READLINE(I:I+2) = ',n,'
        END DO

        IF(READLINE(IENDL-1:IENDL) .EQ. ',.') 
     1   READLINE(IENDL-1:IENDL) = ',n'
      

C  CANNOT USE WRITE(67,4) READLINE(1:IENDL) SINCE, FOR SOME REASON,
C  WRITING LIKE THIS "RIGHT JUSTIFIES" THE CHARACTERS AT THE END
C  OF THE A1000 FORMAT. INSTEAD MUST WRITE (67,__) READLINE, WHERE
C  THE FORMAT IS DETERMINED BY THE LAST NON-BLANK CHARACTER (IENDL)
C  IN READLINE.


	IF(IENDL .LE. 26) THEN
	 WRITE(67,26) READLINE
   26    FORMAT(A26)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 51) THEN
	 WRITE(67,51) READLINE
   51    FORMAT(A51)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 76) THEN
	 WRITE(67,76) READLINE
   76    FORMAT(A76)
	 GO TO 10
	ENDIF


	IF(IENDL .LE. 101) THEN
	 WRITE(67,101) READLINE
  101    FORMAT(A101)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 126) THEN
	 WRITE(67,126) READLINE
  126    FORMAT(A126)


	 GO TO 10
	ENDIF

	IF(IENDL .LE. 151) THEN
	 WRITE(67,151) READLINE
  151    FORMAT(A151)
	 GO TO 10
	ENDIF



	IF(IENDL .LE. 176) THEN
	 WRITE(67,176) READLINE
  176    FORMAT(A176)
	 GO TO 10
	ENDIF


	IF(IENDL .LE. 201) THEN
	 WRITE(67,201) READLINE
  201    FORMAT(A201)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 226) THEN
	 WRITE(67,226) READLINE
  226    FORMAT(A226)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 251) THEN
	 WRITE(67,251) READLINE
  251    FORMAT(A251)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 276) THEN
	 WRITE(67,276) READLINE
  276    FORMAT(A276)
	 GO TO 10

	ENDIF

	IF(IENDL .LE. 301) THEN
	 WRITE(67,301) READLINE
  301    FORMAT(A301)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 326) THEN
	 WRITE(67,326) READLINE
  326    FORMAT(A326)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 351) THEN
	 WRITE(67,351) READLINE

  351    FORMAT(A351)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 376) THEN
	 WRITE(67,376) READLINE
  376    FORMAT(A376)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 401) THEN

	 WRITE(67,401) READLINE
  401    FORMAT(A401)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 426) THEN
	 WRITE(67,426) READLINE
  426    FORMAT(A426)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 451) THEN
	 WRITE(67,451) READLINE
  451    FORMAT(A451)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 476) THEN
	 WRITE(67,476) READLINE
  476    FORMAT(A476)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 501) THEN

	 WRITE(67,501) READLINE
  501    FORMAT(A501)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 526) THEN
	 WRITE(67,526) READLINE
  526    FORMAT(A526)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 551) THEN
	 WRITE(67,551) READLINE
  551    FORMAT(A551)

	 GO TO 10
	ENDIF


	IF(IENDL .LE. 576) THEN
	 WRITE(67,576) READLINE
  576    FORMAT(A576)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 601) THEN
	 WRITE(67,601) READLINE
  601    FORMAT(A601)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 626) THEN
	 WRITE(67,626) READLINE
  626    FORMAT(A626)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 651) THEN
	 WRITE(67,651) READLINE
  651    FORMAT(A651)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 676) THEN
	 WRITE(67,676) READLINE
  676    FORMAT(A676)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 701) THEN
	 WRITE(67,701) READLINE
  701    FORMAT(A701)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 726) THEN

	 WRITE(67,726) READLINE
  726    FORMAT(A726)
	 GO TO 10
	ENDIF


	IF(IENDL .LE. 751) THEN
	 WRITE(67,751) READLINE
  751    FORMAT(A751)
	 GO TO 10

	ENDIF

	IF(IENDL .LE. 776) THEN
	 WRITE(67,776) READLINE
  776    FORMAT(A776)
	 GO TO 10
	ENDIF


	IF(IENDL .LE. 801) THEN
	 WRITE(67,801) READLINE
  801    FORMAT(A801)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 826) THEN
	 WRITE(67,826) READLINE

  826    FORMAT(A826)

	 GO TO 10
	ENDIF

	IF(IENDL .LE. 851) THEN
	 WRITE(67,851) READLINE
  851    FORMAT(A851)
	 GO TO 10

	ENDIF


	IF(IENDL .LE. 876) THEN

	 WRITE(67,876) READLINE
  876    FORMAT(A876)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 901) THEN
	 WRITE(67,901) READLINE
  901    FORMAT(A901)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 926) THEN
	 WRITE(67,926) READLINE
  926    FORMAT(A926)

	 GO TO 10
	ENDIF

	IF(IENDL .LE. 951) THEN
	 WRITE(67,951) READLINE
  951    FORMAT(A951)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 976) THEN
	 WRITE(67,976) READLINE
  976    FORMAT(A976)

	 GO TO 10
	ENDIF


	WRITE(67,4) READLINE
	GO TO 10



  100   CLOSE(77)
        REWIND(67)

        RETURN
        END

C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C	
      SUBROUTINE READBLOCK3
	IMPLICIT REAL*8(A-H,O-Z)

      PARAMETER(MAXNUMEQ=7)

C  THIS ROUTINE IS BASED ON SUBROUTINE READBLOCK2 IN MONT113.FOR, BUT
C  INSTEAD OF CREATING 'XQZPJ001.ZMQ', IT CREATES 'PATQZPX.001'. ALSO,
C  THE PATH IS ASSUMED TO BE BLANK (I.E., THE CURRENT DIRECTORY). AND
C  THE POPULATION ASSAY COEFFICIENTS ARE NOT SUPPLIED AS THE DEFAULT
C  VALUES. IF THE INCOMING .CSV FILE IN FILE 66 DOES NOT INCLUDE
C  ASSAY VALUES FOR C0(),...,C3(), THESE VALUES ARE DEFAULTED TO BE 1.0
C  (THE USER HAS BEEN WARNED ABOUT THIS IN A WRITE STATEMENT IN MAIN).



        DIMENSION TIMOUT(1,MAXNUMEQ,650),TIMIV(1,7,5200),
     1   NTIMOUT(1,MAXNUMEQ),NTIMIV(1,7),RATEIV(1,7,5200),
     2   BOLUS(1,7,5200),OUT(1,MAXNUMEQ,650),COV(1,26,5200),
     3   ICOVTYPE(26),TIMBOL(1,7,5200),NTIMBOL(1,7),NTIMCOV(1,26),
     4   TIMCOV(1,26,5200),TIMALL(1,24000),NTIMALL(1),TIMI(24000),
     5   CSUB(1,4,MAXNUMEQ),NSST(1),DOSELINEST(1,99,100),XVERIFY(900)

        CHARACTER READLINE*1000,COVNAME(26)*11,NUMBER(1)*3,
     1   PATFIL*20,CHARSUB*3,SUBID*11,SUBIDPREV*11,SUBARRAY(1)*11,
     3   ERRFIL*20

      COMMON/ERROR/ERRFIL
C  COMMON/ERROR/ IS SUPPLIED TO ALL THE ROUTINES WHICH COULD WRITE TO
C  ERRFIL.

    1   FORMAT(A1000)


C  SET MAXSUB = 1 SINCE ONLY 1 SUBJECT WILL BE CREATED BY THIS ROUTINE.


        MAXSUB = 1


C  INITIALIZE NDRUG (THE NO. OF DRUGS IN THE PATIENT DATA SET) TO BE
C  0. EVERY TIME IDRUGNO IS READ BELOW, NDRUG WILL BE SET = 
C  MAX(NDRUG,IDRUGNO).


C  SIMILARLY, INITIALIZE NOUT (THE NO. OF OUTPUT EQUATIONS IN THE

C  PATIENT DATA SET) TO BE 0. EVERY TIME IOUTEQ IS READ BELOW, 
C  NOUT WILL BE SET = MAX(NOUT,IOUTEQ).

	NDRUG = 0
	NOUT = 0

C  INITIALIZE NSST(ISUB) TO 0. IT GIVES THE NO. OF STEADY STATE DOSE
C  LINES THAT WILL BE WRITTEN TO THE DOSAGE BLOCK FOR EACH SUBJECT. 

      DO ISUB = 1,MAXSUB
       NSST(ISUB) = 0
      END DO



C  NOTE THAT ANY LINE STARTING WITH A # WILL BE IGNORED. THE FIRST LINE
C  WILL ALSO BE IGNORED - IT HAS ALREADY BEEN VERIFIED TO HAVE THE
C  REQUIRED CODE IN IT.


	READ(66,*)

C  READ THE 2ND LINE, WHICH MUST HAVE A # AS THE FIRST CHARACTER. IT HAS
C  THE NAMES OF THE COLUMNS. COUNT THE NO. OF COMMAS ON THE LINE. THE 
C  NO. OF COVARIATES WILL BE THE NO. OF COMMAS - 11 (SINCE THERE ARE 12
C  FIXED ENTRIES WHICH POTENTIALLY SHOW UP ON EACH LINE: PATIENT ID, 

C  EVENT ID, TIME, INFUSION DURATION, TOTAL DOSE, INPUT DRUG NO.,
C  OUTPUT VALUE, OUTPUT EQ., AND 4 SPOTS FOR ASSAY COEFFICIENTS WHICH 
C  ONLY SHOW UP ON OUTPUT LINES). NOTE THAT THIS VALUE WILL BE CALLED
C  NCOVA, WHICH MEANS NO. OF ADDITION COVARIATES (IN ADDITION TO THE 4

C  PERMANENT ONES AT THE TOP OF EACH PATIENT'S WORKING COPY FILE (AGE,
C  SEX, HEIGHT, ETHNICITY FLAG), ... TO BE CONSISTENT WITH THE NAME 
C  USED IN NPAG100.FOR.

	  READ(66,1) READLINE


	NCOMMA = 0

	DO ISTART = 1,1000

	 IF(READLINE(ISTART:ISTART) .EQ. ',') THEN
	  NCOMMA = NCOMMA + 1
	 ENDIF

	END DO	    

	NCOVA = NCOMMA - 11


	IF(NCOVA .GT. 0) THEN

C  READ THE NAMES OF THE NCOVA COVARIATES FROM THE LINE STARTING WITH
C  #ID OR "#ID. 

C  NOTE THAT AFTERCOMMA OPENS AND PUTS INTO FILE 57 THE PART OF READLINE
C  WHICH IS BETWEEN COMMA C AND COMMA C+1, WHERE C IS THE 3RD ARGUMENT.
C  ALSO,NOTE THAT NCOVA MUST BE PROVIDED TO AFTERCOMMA SO IT WILL KNOW
C  THE TOTAL NO. OF COMMAS IN READLINE (WHICH = 11 + NCOVA).

	REWIND(66)
  120	READ(66,1) READLINE
	IF(READLINE(1:3) .NE. '#ID' .AND. READLINE(1:4).NE. '"#ID' 
     1  .AND. READLINE(1:3) .NE. '#id' .AND. READLINE(1:4).NE. '"#id')
     2   GO TO 120

	 DO ICOV = 1,NCOVA
	  CALL AFTERCOMMA(NCOVA,READLINE,11+ICOV)
	  BACKSPACE(57)
	  READ(57,2) COVNAME(ICOV)
    2     FORMAT(A11)
	  CLOSE(57)
	 END DO


	ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(NCOVA .GT. 0)  CONDITION.


C  CALL SUBROUTINE GETMAXTIM TO GET THE MAXIMUM TIME OVER ALL THE
C  SUBJECTS IN FILE 66. THIS INCLUDES THE ENDING TIME OVER ALL IV
C  EVENTS. THEN SET TIMADD = THIS TIME + 1. FOR EACH SUBJECT BELOW,
C  EACH TIME WILL HAVE TIMADD*NRESET ADDED TO IT, WHERE NRESET IS THE 
C  NO. OF TIME RESETS (FOR THAT SUBJECT) UP TO AND INCLUDING THAT TIME. 
C  THIS WILL MAKE EACH TIME A UNIQUE TIME (I.E., WITH TIME RESETS IN
C  THE BLOCK FORMAT FILE, THERE COULD BE MANY TIMES WITH THE SAME 
C  VALUE).

	CALL GETMAXTIM(NCOVA,TIMAX)


C  VERIFY THAT TIMAX WAS CALCULATED CORRECTLY - I.E., THAT IT IS NOT
C  STILL THE INITIALIZED NEGATIVE VALUE IN GETMAXTIM.

	IF(TIMAX .LT. 0) THEN

	 WRITE(*,11) 
   11  FORMAT(/' THERE IS SOMETHING WRONG WITH YOUR BLOCK FORMAT'/
     1' FILE. THE TIMES IN COLUMN 3 AND/OR THE TIME DURATIONS'/
     2' IN COLUMN 4 ARE BAD. PLEASE CHECK YOUR VALUES. '//
     3' THE PROGRAM STOPS.')

        OPEN(42,FILE=ERRFIL)
         WRITE(42,11)
        CLOSE(42)

	 CALL PAUSE
	 STOP

	ENDIF

   	TIMADD = TIMAX + 1.D0


C  REWIND FILE 66, READ PAST THE FIRST LINE WHICH HAS THE CODE, AND 
C  THE SECOND LINE, WHICH HAS THE COVARIATE INFORMATION ON IT, AND
C  THEN READ ALL LINES, EXCEPT THOSE THAT START WITH # OR "#.
C  GO THROUGH EACH SUCCEEDING LINE IN FILE 66 AND EXTRACT ALL THE 
C  INFORMATION. NOTE THAT EACH LINE CAN CONTAIN OUTPUT INFO OR DOSAGE
C  INFO (INCLUDING COVARIATE VALUES), DEPENDING ON THE VALUE FOR IDEVENT
C  (THE 2ND ENTRY IN EACH LINE), BUT NOT BOTH. IN PARTICULAR, IF
C  IDEVENT = 0 --> THE ROW HAS OUTPUT EQUATION INFO.
C  IDEVENT = 1 --> THE ROW HAS DOSAGE/COVARIATE INFO.
C  IDEVENT = 4 --> SAME AS IDEVENT = 1, EXCEPT THIS ROW REPRESENTS A 
C                  TIME RESET.

	REWIND(66)
	READ(66,1)
	READ(66,1)

C  INITIALIZE SUBIDPREV (THE PREVIOUS SUBJECT ID) TO BE '%^&*' SO THE 
C  FIRST SUJBECT ID READ IN BELOW WILL BE DIFFERENT THAN THIS, AND SO 

C  START THE SUBJECT ID LOGIC. ALSO, INITIALIZE THE SUBJECT NO. TO 0.

	SUBIDPREV = '%^&*'
	NSUB = 0

C  NOTE THAT IEND .LT. 0 --> END OF FILE REACHED.	

   10	READ(66,1,IOSTAT=IEND) READLINE

	IF(IEND .LT. 0) GO TO 100
	IF(READLINE(1:1) .EQ. '#' .OR. READLINE(1:2) .EQ. '"#') GO TO 10

C  THE FIRST VALUE (I.E., AFTER COMMA NO. 0) IS THE SUBJECT ID.

	CALL AFTERCOMMA(NCOVA,READLINE,0)
	BACKSPACE(57)
	READ(57,2) SUBID

	CLOSE(57)

C  NOTE THAT SUBID CONTAINS THE 1ST 11 CHARACTERS OF THE LINE, BUT THE
C  SUBJECT ID IS JUST THE SET OF CHARACTERS PRIOR TO THE 1ST COMMA.
C  CALL SUBROUTINE GETID TO CORRECT THE VALUE OF SUBID.

	CALL GETID(SUBID)

C  IF SUBID = SUBIDPREV, THIS IS ANOTHER LINE FOR THE CURRENT SUBJECT. 
C  IF SUBID .NE. SUBIDPREV, THIS IS THE 1ST EVENT FOR A NEW SUBJECT, SO 
C  INCREASE NSUB, AND SET THE NO. OF INFUSIONS (FOR EACH DRUG), BOLI, 
C  OBSERVATION, AND COVARIATE TIMES FOR THIS SUBJECT TO 0 (THEY WILL 
C  BE UPDATED BELOW AS REQUIRED). SIMILARY SET THE TOTAL NO. OF DOSE 
C  EVENTS = 0. 

C  ALSO, SINCE THIS IS A NEW SUBJECT, DEFAULT THE ASSAY COEFFICIENTS FOR
C  OUTPUT EQ. IEQ TO 1.D0, IEQ = 1,MAXNUMEQ (MAXNUMEQ IS THE MAXIMUM 
C  THAT NUMEQT CAN BE). THEN, AS THIS SUBJECT'S INFO IS BEING READ 
C  BELOW, ANY ASSAY C'S SPECIFIED FOR THIS SUBJECT WILL OVERWRITE THE 
C  DEFAULT VALUES. AND NOTE THAT IF A SUBJECT HAS MORE THAN ONE SET OF 
C  ASSAY C'S FOR A GIVEN OUTPUT EQ., THE LAST SET WILL BE USED.

C  NOTE THAT AFTER READBLOCK2 HAS FINISHED READING THE PATIENT INFO,
C  CSUB(I,J,K), J=1,4 WILL BE ASSAY C'S [C0 C1 C2 C3] FOR SUBJECT I
C  AND OUTPUT EQ. K. 
 


	IF(SUBID .NE. SUBIDPREV) THEN

	 SUBIDPREV = SUBID
	 NSUB = NSUB + 1

C  FASTFORWARD THE LOGIC TO THE END OF THE ROUTINE IF NSUB = 2, SINCE
C  THE INFO FOR THE FIRST SUBJECT WILL ALREADY HAVE BEEN READ IN. AND 
C  RESET NSUB = 1 AT THAT POINT SINCE ONLY THE FIRST SUBJECT'S DATA WILL
C  BE NEEDED.

        IF(NSUB .EQ. 2) GO TO 100


	 WRITE(*,8888) NSUB
 8888    FORMAT('+ ',' NOW WORKING ON SUBJECT NO. ',I4)

	 SUBARRAY(NSUB) = SUBID

	 NTIMALL(NSUB) = 0

	 DO K = 1,7
	  NTIMIV(NSUB,K) = 0
	  NTIMBOL(NSUB,K) = 0
	 END DO

	 DO K = 1,26
	  NTIMCOV(NSUB,K) = 0
	 END DO

        DO K = 1,MAXNUMEQ
         NTIMOUT(NSUB,K) = 0
         CSUB(NSUB,1,K) = 1.D0
         CSUB(NSUB,2,K) = 1.D0
         CSUB(NSUB,3,K) = 1.D0
         CSUB(NSUB,4,K) = 1.D0
        END DO


C  SEE LOGIC BELOW. IF THIS ROW REPRESENTS A TIME RESET, THEN AN
C  EXTRA VALUE (-99) AT AN EXTRA TIME (0) WILL BE ADDED TO EACH OUTPUT
C  EQUATION ARRAY. BUT THIS NEEDS TO BE DONE JUST ONCE FOR EACH TIME

C  RESET, NOT FOR EACH DOSAGE LINE THAT HAS A RESET. I.E., IF THERE
C  ARE 5 DRUGS, THEN THERE COULD BE AS MANY AS 5 DOSE LINES WITH A
C  RESET VALUE. ALSO, WITHIN EACH LINE, A DOSE AND/OR A COVARIATE
C  COULD HAVE A RESET TIME OF 0. THEREFORE EACH BLOCK OF CODE BELOW,
C  FOR EACH DRUG NO. AND EACH COVARIATE, IS TESTED FOR A TIME RESET,
C  AND IN EACH CASE, EXTRA LINES ARE POTENTIALLY ADDED TO THE OUPUT 
C  ARRAYS. TO PREVENT MORE EXTRA LINES (OF OUTPUT VALUES = -99 AT
C  TIMES = 0) THAN ARE NECESSARY, INITIALIZE NRESETADD = 0. THIS 
C  TELLS THE PROGRAM THAT NO EXTRA LINES HAVE BEEN ADDED TO THE OUTPUT
C  ARRAYS SINCE THE LAST ACTUAL OUTPUT VALUE WAS PUT INTO ONE OF THE
C  ARRAYS. NRESETADD WILL BE CHANGED TO 1 WHENEVER EXTRA LINES HAVE
C  BEEN ADDED TO THE OUTPUT ARRAYS, AND THEN BACK TO 0 WHENEVER ANOTHER
C  ACTUAL OUTPUT VALUE HAS BEEN PUT INTO AN ARRAY.

	NRESETADD = 0

C  INITIALIZE NRESET TO 0. IT WILL BE THE NO. OF TIME RESETS THAT
C  HAVE OCCURRED UP TO ANY TIME. ALSO INITIALIZE TIMERESET = 0; THIS 
C  WILL BE THE RUNNING TIME TO BE ADDED TO EACH ACTUAL TIME. IT WILL
C  ALWAYS BE SET = TIMADD*NRESET BELOW.

	NRESET = 0	
	TIMERESET = TIMADD*NRESET

C  ALSO INITIALIZE NRESETLAST = -1 (SEE CODE BELOW).

       NRESETLAST = -1
       DOSELINEST(NSUB,1,100) = -99

C  DOSELINE(NSUB,1,100) IS INITIALIZED TO BE -99. IF IT CHANGES BELOW
C  TO BE .GE. 0, IT MEANS THAT THERE IS AT LEAST ONE STEADY STATE DOSE
C  SET, AND THE FIRST ONE OCCURS AT THE VALUE OF NRESET =
C  DOSELINEST(NSUB,1,100).


C  VERIFY THAT THE 2ND VALUE (I.E., AFTER COMMA NO. 1), WHICH IS THE 
C  EVENT ID, IDEVENT, IS 1 SINCE THE FIRST EVENT FOR EACH SUBJECT

C  SHOULD BE 1 (A NON-TIME-RESET DOSE EVENT).

	CALL AFTERCOMMA(NCOVA,READLINE,1)
	BACKSPACE(57)
	READ(57,*) IDEVENT
	CLOSE(57)

	IF(IDEVENT .NE. 1) THEN



	 WRITE(*,402) SUBARRAY(NSUB),IDEVENT
  402    FORMAT(/' THERE IS AN ERROR IN THE BLOCK FORMAT. FOR SUBJECT '/
     1 1X,A11,', THE FIRST EVENT ID IS NOT 1 AS REQUIRED. IT IS ',I3/
     3' THE PROGRAM STOPS.'/)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,402) SUBARRAY(NSUB),IDEVENT
        CLOSE(42)

	 CALL PAUSE
	 STOP



	ENDIF


	ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(SUBID .NE. SUBIDPREV)  CONDITION.


C  THE 2ND VALUE (I.E., AFTER COMMA NO. 1) IS THE EVENT ID, IDEVENT 

C  (SEE ABOVE).               
	
	CALL AFTERCOMMA(NCOVA,READLINE,1)
	BACKSPACE(57)
	READ(57,*) IDEVENT
	CLOSE(57)

C  IF THE ID OF THIS EVENT IS NO. 4, IT IS A TIME RESET EVENT. IN THIS
C  CASE, INCREASE NRESET AND TIMERESET AS INDICATED ABOVE.


	IF(IDEVENT .EQ. 4) THEN
	 NRESET = NRESET + 1
	 TIMERESET = TIMADD*NRESET
	ENDIF


C  THE 3RD VALUE (I.E., AFTER COMMA NO. 2) IS THE TIME OF THE EVENT.
C  READ THIS VALUE NOW.
	

	CALL AFTERCOMMA(NCOVA,READLINE,2)
	BACKSPACE(57)
	READ(57,*) TIMEVENT
	CLOSE(57)


      IF(TIMEVENT .LT. 0.D0) THEN

C  STORE INTO DOSELINEST(.,.,.) ALL THE INFO FOR THE WORKING COPY FILE
C  FOR THIS STEADY STATE DOSE SET.



C  COMPARE NRESET WITH THE PREVIOUS VALUE OF NRESET WHEN THIS PART OF
C  THE CODE WAS USED: IF THEY ARE THE SAME, THIS LINE WILL PROVIDES
C  MORE INFO (FOR A DIFFERENT DRUG NO.) FOR THE SAME STEADY STATE DOSE
C  EVENT TO BE PUT INTO THE WORKING COPY FILE. IF THEY ARE DIFFERENT,
C  THIS LINE IS THE FIRST LINE OF A NEW STEADY STATE DOSE SET.


       IF(NRESET .GT. NRESETLAST) THEN

C  PUT IN NEW INFO FOR A NEW LINE (FOR A NEW STEADY STATE DOSE SET).
C  THIS LINE IS THE FIRST LINE WITH INFO ON A NEW STEADY STATE DOSE SET.
C  STORE ALL THE INFO FROM THIS LINE, INCLUDING NRESET, SO SUBROUTINE
C  WRITEDOS CAN WRITE THE INFO FOR THIS LINE SEPARATELY. NOTE THAT THIS
C  LINE WILL NOT BE A PART OF THE LOGIC BELOW WHICH STORES ALL DOSE 
C  INFO, AND THEN SORTS IT BY TIME. NOTE THAT NRESET IS STORED INTO
C  ENTRY 100 FOR THIS LINE.

        NSST(NSUB) = NSST(NSUB) + 1

        IF(NSST(NSUB) .GT. 99) THEN



         WRITE(*,172) NSUB
  172    FORMAT(/' FOR SUBJECT NO. ',I5,' THE NO. OF STEADY STATE DOSE'/
     1' SETS IS MORE THAN 99, THE MAXIMUM ALLOWED. PLEASE RERUN THE'/
     2' PROGRAM AFTER REDUCING THE NO. OF STEADY STATE DOSE SETS TO'/
     3' NO MORE THAN 99.'//
     4' THE PROGRAM STOPS.'/)
	  WRITE(*,401) NSUB,SUBARRAY(NSUB)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,172) NSUB                  
        CLOSE(42)



         CALL PAUSE
         STOP



        ENDIF


        DOSELINEST(NSUB,NSST(NSUB),100) = NRESET

C  TIMEVENT IS THE NEGATIVE OF THE INTERDOSE INTERVAL, WHICH WILL SHOW
C  UP IN THE TIME COLUMN OF THE WORKING COPY FILE.

        DOSELINEST(NSUB,NSST(NSUB),1) = TIMEVENT

C  ZERO OUT ALL THE IV AND BOLUS ENTRIES FOR ALL POSSIBLE DRUGS
C  (I.E., THERE COULD BE AS MANY AS 7 DRUGS).

        DO I = 1,7
         DOSELINEST(NSUB,NSST(NSUB),2*I) = 0.D0
         DOSELINEST(NSUB,NSST(NSUB),2*I+1) = 0.D0
        END DO


C  STORE ANY COVARIATE INFO INTO THE COVARIATE ENTRIES. NOTE IT IS NOT
C  KNOWN AT THIS POINT HOW MANY TOTAL DRUGS ARE USED IN THE MODEL SINCE
C  THE VALUE FOR NDRUG HAS NOT YET FINISHED UPDATING (IN THE CODE BELOW,
C  IT IS SET = IDRUGNO IF NDRUG .LT. IDRUGNO). SO, THE COVARIATE VALUES
C  WILL BE STORED FAR ENOUGH OUT IN THE DOSELINEST(.,.,.) ARRAY TO NOT
C  INTERFERE WITH THE ENTRIES FOR THE MAXIMUM NO. OF POSSIBLE DRUGS.
C  SINCE THERE ARE AT MOST 7 POSSIBLE DRUGS, ENTRIES 2,3,...,14,15 WILL
C  BE RESERVED FOR THESE DRUG VALUES, AND THE COVARIATE VALUES WILL
C  START WITH ENTRY NO. 20.


        IF(NCOVA .GT. 0) THEN
         
         DO 110 ICOV = 1,NCOVA
          CALL AFTERCOMMA(NCOVA,READLINE,11+ICOV)
          BACKSPACE(57)
 	    READ(57,*,ERR=95) COVVAL
	    CLOSE(57)
          DOSELINEST(NSUB,NSST(NSUB),19+ICOV) = COVVAL

          GO TO 110
   95     DOSELINEST(NSUB,NSST(NSUB),19+ICOV) = -99.D0
  110    CONTINUE

        ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(NCOVA .GT. 0)  CONDITION.


C  THIS IS EITHER A TIME RESET EVENT, OR THE TOP OF THE PATIENT'S FILE.
C  IF IT IS THE TOP OF THE PATIENT'S FILE, NRESET WILL = 0. IF IT IS A 
C  TIME RESET EVENT, NRESET WILL BE > 0, AND IN THIS CASE, MUST STORE 
C  VALUES INTO THE OUPUT ARRAYS (SEE LOGIC BELOW) WHICH INDICATE THAT

C  SUBSEQUENT OUTPUT TIMES ARE BASED ON THIS TIME RESET.

       IF(NRESET .GT. 0) THEN
        DO IOUTEQ = 1,MAXNUMEQ
         NTIMOUT(NSUB,IOUTEQ) = NTIMOUT(NSUB,IOUTEQ) + 1
         TIMOUT(NSUB,IOUTEQ,NTIMOUT(NSUB,IOUTEQ)) = TIMERESET
         OUT(NSUB,IOUTEQ,NTIMOUT(NSUB,IOUTEQ)) = -99.D0
        END DO
       ENDIF


       ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(NRESET .GT. NRESETLAST)  CONDITION.


C  ESTABLISH THE DURATION, (4TH VALUE, AFTER THE 3RD COMMA), DOSE (5TH
C  VALUE, AFTER THE 4TH COMMA), AND DRUG NO. (6TH VALUE, AFTER THE 5TH

C  COMMA) FOR THIS LINE.

        CALL AFTERCOMMA(NCOVA,READLINE,3)
        BACKSPACE(57)
        READ(57,*,ERR=170) DUR
        CLOSE(57)


        CALL AFTERCOMMA(NCOVA,READLINE,4)
        BACKSPACE(57)
        READ(57,*,ERR=170) TOTDOS

        CLOSE(57)

        CALL AFTERCOMMA(NCOVA,READLINE,5)
        BACKSPACE(57)
        READ(57,*,ERR=170) IDRUGNO
	  IF(NDRUG .LT. IDRUGNO) NDRUG = IDRUGNO


        CLOSE(57)

C  STORE THE IV RATE INTO THE IV ENTRY FOR DRUG NO. IDRUGNO; SIMILARLY,
C  STORE THE TOTAL DOSE INTO THE BOLUS ENTRY FOR DRUG NO. IDRUGNO.
C  NOTE THAT IF DUR = 0, THIS LINE REPRESENTS A STEADY STATE OF BOLUS 
C  VALUES. IN THIS CASE, SET THE IV RATE TO 0.

        IF(DUR .LE. 0.D0) 
     1   DOSELINEST(NSUB,NSST(NSUB),2*IDRUGNO) = 0.D0
        IF(DUR .GT. 0.D0)
     1   DOSELINEST(NSUB,NSST(NSUB),2*IDRUGNO) = TOTDOS/DUR
        DOSELINEST(NSUB,NSST(NSUB),2*IDRUGNO+1) = TOTDOS




C  NOTE THAT COVARIATE VALUES ARE ONLY READ FOR THE FIRST DOSE LINE
C  IN A STEADY STATE SET (I.E., WHEN NRESET .GT. NRESETLAST). IT IS
C  POSSIBLE THAT THE USER'S .csv FILE HAS A DIFFERENT SET OF COV. VALUES
C  FOR EACH LINE (FOR A DIFFERENT DRUG) THAT IS INCLUDED IN THE 
C  CURRENT STEADY STATE DOSE SET. BUT, THIS WOULD BE A MISTAKE SINCE
C  ONLY 1 SET OF COV. VALUES CAN BE USED FOR THE STEADY STATE SET. THE
C  FIRST SET OF VALUES WILL BE USED (AND ALL OTHERS WILL BE IGNORED).
 
C  SET NRESETLAST = NRESET SO IF ANOTHER LINE OF DOSE INFO FOR THE
C  CURRENT STEADY STATE SET FOLLOWS, THE PROGRAM WILL KNOW IT IS
C  MORE INFO ON THE CURRENT SET, AND NOT NEW INFO ON THE NEXT SET.
  
       NRESETLAST = NRESET

       GO TO 10


  170  WRITE(*,171) NSUB,READLINE(1:75)
  171  FORMAT(/' THERE IS AN ERROR IN YOUR BLOCK FORMAT FILE FOR '/
     1' SUBJECT NO. ',I5,'. EITHER THE DURATION, THE DOSE, OR THE '/
     2' DRUG NUMBER IS MISSING. THE 1ST 75 CHARACTERS OF THE LINE ARE:'/
     2A75//
     3' THE PROGRAM STOPS.'/)
	 WRITE(*,401) NSUB,SUBARRAY(NSUB)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,401) NSUB,SUBARRAY(NSUB)
        CLOSE(42)



  	 CALL PAUSE
	 STOP

      ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(TIMEVENT .LT. 0.D0)  CONDITION.




	TIMEVENT = TIMEVENT + TIMERESET




C  IF IDEVENT = 0, IT MEANS THAT THIS ROW IS AN OBSERVED VALUE ROW.
C  IN THIS CASE, READ THE OBSERVED VALUE INFO.

	IF(IDEVENT .EQ. 0) THEN

C  THE 7TH ENTRY (AFTER COMMA NO. 6) IS AN OUTPUT VALUE FOR THIS TIME 
C  IF THERE IS AN ERROR, IT IS ASSUMED THAT THE PROGRAM READ A DOT,

C  WHICH WOULD BE INCONSISTENT SINCE IDEVENT = 0 (MEANING THERE SHOULD
C  BE AN OUTPUT VALUE ON THE ROW).

	CALL AFTERCOMMA(NCOVA,READLINE,6)
	BACKSPACE(57)
	READ(57,*,ERR=30) YVAL
	CLOSE(57)

C  TO GET TO THIS POINT --> YVAL CONTAINS AN OUTPUT VALUE FOR THIS
C  LINE. BEFORE THIS VALUE CAN BE STORED, MUST READ THE OUTPUT EQUATION 
C  NO. AFTER COMMA NO. 7. 

	CALL AFTERCOMMA(NCOVA,READLINE,7)
	BACKSPACE(57)

	READ(57,*,ERR=30) IOUTEQ
	IF(NOUT .LT. IOUTEQ) NOUT = IOUTEQ 
	CLOSE(57)

C  STORE THIS VALUE. ALSO STORE THE TIME OF THIS EVENT INTO THE ARRAY 
C  WHICH STORES OUTPUT TIMES.

	NTIMOUT(NSUB,IOUTEQ) = NTIMOUT(NSUB,IOUTEQ) + 1
	TIMOUT(NSUB,IOUTEQ,NTIMOUT(NSUB,IOUTEQ)) = TIMEVENT
	OUT(NSUB,IOUTEQ,NTIMOUT(NSUB,IOUTEQ)) = YVAL
	NRESETADD = 0

C  SEE CODE ABOVE REGARDING NRESEADD.


	GO TO 20

C  REPLACE WRITING OF TIMEVENT - TIMERESET WITH XVERIFY (SEE LOGIC IN 
C  SUBROUTINE VERIFYVAL.

   30   XVERIFY(1) = TIMEVENT - TIMERESET
        CALL VERIFYVAL(1,XVERIFY)
C  30   WRITE(*,31) NSUB, TIMEVENT - TIMERESET
        WRITE(*,31) NSUB, XVERIFY(1)
   31   FORMAT(/' THERE IS AN ERROR IN THE BLOCK FORMAT. FOR SUBJECT '/
     1' NO. ',I4,' AND TIME ',F10.4, ' A LINE HAS AN EVENT ID OF 0 IN'/
     2' COL. 2, INDICATING OBSERVED VALUE INFORMATION. BUT THERE IS '/
     3' EITHER NO OBSERVED VALUE IN COL. 7, OR NO OUTPUT EQUATION NO.'/
     4' IN ENTRY 8. '//
     3' THE PROGRAM STOPS.')
	  WRITE(*,401) NSUB,SUBARRAY(NSUB)
  401   FORMAT(/' NOTE: THE ID FOR SUBJECT NO. ',I4,' IS ',A11/)

        OPEN(42,FILE=ERRFIL)
C        WRITE(42,31) NSUB, TIMEVENT - TIMERESET
         WRITE(42,31) NSUB, XVERIFY(1)
         WRITE(42,401) NSUB,SUBARRAY(NSUB)
        CLOSE(42)	

        CALL PAUSE
        STOP

   20 CONTINUE

C  THE 9TH - 12TH ENTRIES FOR THIS ROW POTENTIALLY HOLD NEW ASSAY 
C  COEFFICIENTS FOR THIS SUBJECT (NSUB) AND OUTPUT EQ. (IOUTEQ).
C  READ THESE VALUES. IF THEY ARE NOT MISSING, UPDATE THE ASSAY
C  COEFFICIENT INFO FOR THIS SUBJECT/OUTPUT EQ.

C  NOTE THAT THESE ENTRIES SHOULD ALL BE MISSING (DOTS OR n's) OR ALL
C  BE NUMBERS. IF THERE IS A COMBINATION  OF MISSING VALUES AND NUMBERS,
C  STOP THE PROGRAM AND TELL THE USER.

        IMISSC0 = 0
        IMISSC1 = 0
        IMISSC2 = 0
        IMISSC3 = 0
      
        CALL AFTERCOMMA(NCOVA,READLINE,8)
        BACKSPACE(57)
        READ(57,*,ERR=230) C00

        CLOSE(57)


        GO TO 235
  230   IMISSC0 = 1

  235   CALL AFTERCOMMA(NCOVA,READLINE,9)
        BACKSPACE(57)
        READ(57,*,ERR=240) C11
        CLOSE(57)

        GO TO 245

  240   IMISSC1 = 1

  245   CALL AFTERCOMMA(NCOVA,READLINE,10)
        BACKSPACE(57)
        READ(57,*,ERR=250) C22
        CLOSE(57)

        GO TO 255
  250   IMISSC2 = 1

  255   CALL AFTERCOMMA(NCOVA,READLINE,11)
        BACKSPACE(57)
        READ(57,*,ERR=260) C33
        CLOSE(57)

        GO TO 265
  260   IMISSC3 = 1



  265   CONTINUE

C  IF ALL IMISSCx VALUES ARE 0, UPDATE THE ASSAY C'S FOR THIS
C  SUBJECT AND OUTPUT EQ. NO. IF ALL IMISSCx VALUES ARE 1, THEY
C  ARE ALL MISSING, SO JUST CONTINUE. IF SOME OF THE IMISSCx VALUES
C  ARE 0 AND SOME ARE 1, THIS IS AN INCONSISTENCY (I.E., THE USER HAS
C  ENTERED SOME BUT NOT ALL OF THE ASSAY C'S). IN THIS CASE, STOP THE
C  PROGRAM AFTER INFORMING THE USER OF HIS ERROR.

        ISUMC = IMISSC0 + IMISSC1 + IMISSC2 + IMISSC3

        IF(ISUMC .EQ. 0) THEN
         CSUB(NSUB,1,IOUTEQ) = C00
         CSUB(NSUB,2,IOUTEQ) = C11
         CSUB(NSUB,3,IOUTEQ) = C22
         CSUB(NSUB,4,IOUTEQ) = C33
        ENDIF

        IF(ISUMC .NE. 0 .AND. ISUMC .NE. 4) THEN

C  REPLACE WRITING OF TIMEVENT - TIMERESET WITH XVERIFY (SEE LOGIC IN 
C  SUBROUTINE VERIFYVAL.

         XVERIFY(1) = TIMEVENT - TIMERESET
         CALL VERIFYVAL(1,XVERIFY)
C        WRITE(*,231) NSUB, TIMEVENT - TIMERESET,IOUTEQ
         WRITE(*,231) NSUB, XVERIFY(1),IOUTEQ
  231    FORMAT(/' THERE IS AN ERROR IN THE BLOCK FORMAT. FOR SUBJECT '/
     1' NO. ',I4,' AND TIME ',F10.4, ' A LINE HAS AN EVENT ID OF 0 IN'/
     2' COL. 2, INDICATING OBSERVED VALUE INFORMATION, BUT THIS LINE'/
     3' HAS AN INCOMPLETE SET OF ASSAY COEFFICIENTS FOR OUTPUT EQ. '/
     4' NUMBER ',I3,'. THERE MUST BE EITHER 4 ASSAY COEFFICIENTS ON'/
     5' AN OUTPUT LINE, OR NONE (IF NO OUTPUT LINES FOR A PARTICULAR'/
     6' SUBJECT x OUTPUT EQ. COMBO HAVE ASSAY COEFFICIENTS, THEN THE'/
     7' POPULATION COEFFICIENTS WILL BE USED).'//
     8' THE PROGRAM STOPS.')
         WRITE(*,401) NSUB,SUBARRAY(NSUB)

        OPEN(42,FILE=ERRFIL)
C        WRITE(42,231) NSUB, TIMEVENT - TIMERESET,IOUTEQ
         WRITE(42,231) NSUB, XVERIFY(1),IOUTEQ
         WRITE(42,401) NSUB,SUBARRAY(NSUB)
        CLOSE(42)

         CALL PAUSE
         STOP


        ENDIF


	ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(IDEVENT .EQ. 0)  CONDITION.


	IF(IDEVENT .EQ. 1 .OR. IDEVENT .EQ. 4) THEN



C  IDEVENT = 1 OR 4 --> DOSE AND/OR COVARITE INFO IS TO BE READ IN.

C  THE 4TH ENTRY (AFTER COMMA NO. 3) IS AN INFUSION DURATION, AND THE
C  5TH ENTRY (AFTER COMMA NO. 4) IS THE TOTAL DOSE ... IF THIS LINE 
C  HAS DOSE INFORMATION. NOTE THAT IF THERE IS NO DOSE, THE TOTAL DOSE
C  ENTRY WILL BE A DOT ("."). ALSO, IF THERE IS A TOTAL DOSE, BUT THE
C  INFUSION DURATION IS 0, THIS LINE REPRESENTS A BOLUS INPUT.

C  SO, 1ST TRY READING THE TOTAL DOSE AS A REAL NUMBER; IF THERE IS AN 
C  ERROR, IT IS ASSUMED THAT THE PROGRAM READ A DOT.

	CALL AFTERCOMMA(NCOVA,READLINE,4)
	BACKSPACE(57)
	READ(57,*,ERR=40) TOTDOS 
	CLOSE(57)

C  TO GET TO THIS POINT --> TOTDOS CONTAINS A TOTAL DOSE VALUE FOR THIS
C  LINE. READ THE INFUSION DURATION AFTER COMMA NO. 3 TO SEE IF THIS
C  DOSE IS AN INFUSION (WITH A POSITIVE DURATION) OR A BOLUS (WITH A
C  0 DURATION).

	CALL AFTERCOMMA(NCOVA,READLINE,3)
	BACKSPACE(57)
	READ(57,*,ERR=50) DUR
	CLOSE(57)

C  BEFORE THIS VALUE CAN BE STORED, MUST READ THE DRUG NO. AFTER COMMA
C  NO. 5.

	CALL AFTERCOMMA(NCOVA,READLINE,5)
	BACKSPACE(57)
	READ(57,*,ERR=50) IDRUGNO
	IF(NDRUG .LT. IDRUGNO) NDRUG = IDRUGNO
	CLOSE(57)

C  STORE THE ABOVE VALUES DEPENDING ON WHETHER THEY REPRESENT AN
C  INFUSION OR A BOLUS INPUT.


C  INCREASE THE NO. OF DOSAGE LINES FOR THIS SUBJECT. IF DUR > 0, THE
C  NO. OF DOSAGE LINES INCREASES BY 2 SINCE THERE WILL BE A START TIME
C  AND AN ENDING TIME. IF DUR = 0, THE NO. OF DOSAGE LINES WILL INCREASE
C  BY 1.

	IF(DUR .GT. 0) THEN


C  THE INFUSION RATE IS TOTDOS/DUR. SO THE DOSE VALUE THE 1ST DOSE
C  TIME BELOW WILL BE THIS INFUSION RATE, AND THE DOSE VALUE AT THE
C  2ND DOSE TIME BELOW WILL BE 0.

C  NOTE THAT EVERYTIME NTIMALL(NSUB) IS INCREASED, THE PROGRAM CHECKS
C  THAT IT HAS NOT GONE PAST 24000. IF SO, A MESSAGE TO THE USER IS
C  WRITTEN THAT THIS IS NOT ALLOWED AND THE PROGRAM STOPS.

	 NTIMALL(NSUB) = NTIMALL(NSUB) + 1

	 IF(NTIMALL(NSUB) .GT. 24000) THEN



	  WRITE(*,3001) NSUB
 3001     FORMAT(/' THE NO. OF LINES IN THE DOSAGE REGIMEN FOR SUBJECT'/
     1' NO. ',I5,' IS MORE THAN THE LIMIT OF 24000. PLEASE RERUN THE'/
     2' PROGRAM AFTER REDUCING THIS NO. TO BE LESS THAN 24000.'/)
	  WRITE(*,401) NSUB,SUBARRAY(NSUB)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,3001) NSUB
         WRITE(42,401) NSUB,SUBARRAY(NSUB)
        CLOSE(42)	


	  CALL PAUSE
	  STOP


	 ENDIF


	 TIMALL(NSUB,NTIMALL(NSUB)) = TIMEVENT


      IF(IDEVENT .EQ. 4) THEN

C  IF IDEVENT = 4, IT MEANS THAT THIS IS A TIME RESET POINT (I.E., A 
C  TIME IN THE DISTANT FUTURE WHICH WILL SHOW UP AS T = 0 IN THE 
C  WORKING COPY FORMAT FILE). IN THIS CASE, IF NRESETADD = 0, ADD 
C  VALUES TO NTIMOUT, TIMOUT, AND OUT FOR EACH  OF THE MAXNUMEQ POSSIBLE
C  OUTPUT EQUATIONS (THERE ARE NOUT OUTPUT EQUATIONS SO FAR, BUT IN 
C  SUBSEQUENT ROWS, NOUT COULD INCREASE TO AT MOST MAXNUMEQ) TO 
C  INDICATE THAT ANY OUTPUTS FOLLOWING THIS TIME ARE BASED ON THE TIME
C  RESET. TO DO THIS, PUT IN THE CURRENT TIME IN TIMOUT, AND A
C  CORRESPONDING VALUE OF -99 (MISSING VALUE), FOR EACH OUTPUT EQUATION.

C  STORE VALUES INTO THE OUPUT ARRAYS (TIME = 0 AND VALUE = -99) WHICH 
C  INDICATE THAT SUBSEQUENT OUTPUT TIMES ARE BASED ON THIS TIME RESET.
C  ... BUT ONLY STORE THESE EXTRA VALUES IF NRESETADD = 0. IF 
C  NRESETADD = 1, IT MEANS THAT THESE LINES HAVE ALREADY BEEN ADDED
C  SINCE THE LAST ACTUAL OUTPUT VALUE WAS PUT INTO ONE OF THE OUTPUT
C  ARRAYS.

       IF(NRESETADD .EQ. 0) THEN
        DO IOUTEQ = 1,MAXNUMEQ
         NTIMOUT(NSUB,IOUTEQ) = NTIMOUT(NSUB,IOUTEQ) + 1
         TIMOUT(NSUB,IOUTEQ,NTIMOUT(NSUB,IOUTEQ)) = TIMEVENT
   	   OUT(NSUB,IOUTEQ,NTIMOUT(NSUB,IOUTEQ)) = -99.D0
        END DO
        NRESETADD = 1
       ENDIF

	 ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(IDEVENT .EQ. 4)  CONDITION.


C  IF THE CURRENT TIME IS THE SAME AS THE ENDING TIME OF THE PREVIOUS 
C  IV, DO NOT INCREASE NTIMIV(.,.) BELOW, BECAUSE THE NEW STARTING IV 
C  RATE MUST REPLACE THE 0.0 FROM THE ENDING OF THE PREVIOUS IV.

        ISAME = 0
        IF(NTIMIV(NSUB,IDRUGNO) .GT. 0) 
     1   CALL THESAME(TIMEVENT,TIMIV(NSUB,IDRUGNO,NTIMIV(NSUB,IDRUGNO)),
     2 ISAME)

        IF(ISAME .EQ. 0) NTIMIV(NSUB,IDRUGNO) = NTIMIV(NSUB,IDRUGNO) + 1
        TIMIV(NSUB,IDRUGNO,NTIMIV(NSUB,IDRUGNO)) = TIMEVENT
        RATEIV(NSUB,IDRUGNO,NTIMIV(NSUB,IDRUGNO)) = TOTDOS/DUR

	 NTIMALL(NSUB) = NTIMALL(NSUB) + 1

	 IF(NTIMALL(NSUB) .GT. 24000) THEN

	  WRITE(*,3001) NSUB
	  WRITE(*,401) NSUB,SUBARRAY(NSUB)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,3001) NSUB
         WRITE(42,401) NSUB,SUBARRAY(NSUB)
        CLOSE(42)	



	  CALL PAUSE
	  STOP



	 ENDIF

	 TIMALL(NSUB,NTIMALL(NSUB)) = TIMEVENT + DUR
	 NTIMIV(NSUB,IDRUGNO) = NTIMIV(NSUB,IDRUGNO) + 1
	 TIMIV(NSUB,IDRUGNO,NTIMIV(NSUB,IDRUGNO)) = TIMEVENT + DUR

	 RATEIV(NSUB,IDRUGNO,NTIMIV(NSUB,IDRUGNO)) = 0.D0

	ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(DUR .GT. 0)  CONDITION.

	

	IF(DUR .LE. 0) THEN

C  STORE THE BOLUS VALUE AT THE INDICATED TIME, TIMEVENT.

	 NTIMALL(NSUB) = NTIMALL(NSUB) + 1

	 IF(NTIMALL(NSUB) .GT. 24000) THEN

	  WRITE(*,3001) NSUB
	  WRITE(*,401) NSUB,SUBARRAY(NSUB)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,3001) NSUB
         WRITE(42,401) NSUB,SUBARRAY(NSUB)
        CLOSE(42)	

	  CALL PAUSE
	  STOP



	 ENDIF

	 TIMALL(NSUB,NTIMALL(NSUB)) = TIMEVENT



      IF(IDEVENT .EQ. 4) THEN

C  SEE LOGIC ABOVE FOR TIME RESET LOGIC, AND ADDING LINES TO THE

C  OUTPUT EQUATION VALUES IN THAT CASE.

C  STORE VALUES INTO THE OUPUT ARRAYS (SEE LOGIC ABOVE) WHICH 
C  INDICATE THAT SUBSEQUENT OUTPUT TIMES ARE BASED ON THIS TIME RESET.
C  ... BUT ONLY STORE THESE EXTRA VALUES IF NRESETADD = 0. IF 
C  NRESETADD = 1, IT MEANS THAT THESE LINES HAVE ALREADY BEEN ADDED
C  SINCE THE LAST ACTUAL OUTPUT VALUE WAS PUT INTO ONE OF THE OUTPUT
C  ARRAYS.

       IF(NRESETADD .EQ. 0) THEN
        DO IOUTEQ = 1,MAXNUMEQ
         NTIMOUT(NSUB,IOUTEQ) = NTIMOUT(NSUB,IOUTEQ) + 1
         TIMOUT(NSUB,IOUTEQ,NTIMOUT(NSUB,IOUTEQ)) = TIMEVENT
   	   OUT(NSUB,IOUTEQ,NTIMOUT(NSUB,IOUTEQ)) = -99.D0
        END DO
        NRESETADD = 1
       ENDIF

	 ENDIF


C  THE ABOVE ENDIF IS FOR THE  IF(IDEVENT .EQ. 4)  CONDITION.


	 NTIMBOL(NSUB,IDRUGNO) = NTIMBOL(NSUB,IDRUGNO) + 1
	 TIMBOL(NSUB,IDRUGNO,NTIMBOL(NSUB,IDRUGNO)) = TIMEVENT
	 BOLUS(NSUB,IDRUGNO,NTIMBOL(NSUB,IDRUGNO)) = TOTDOS

	ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(DUR .LE. 0)  CONDITION.


	GO TO 40


C  REPLACE WRITING OF TIMEVENT - TIMERESET WITH XVERIFY (SEE LOGIC IN 
C  SUBROUTINE VERIFYVAL.

   50 XVERIFY(1) = TIMEVENT - TIMERESET
      CALL VERIFYVAL(1,XVERIFY)
C  50 WRITE(*,51) NSUB, TIMEVENT - TIMERESET
      WRITE(*,51) NSUB, XVERIFY(1)

   51 FORMAT(/' THERE IS AN ERROR IN THE BLOCK FORMAT. FOR SUBJECT '/
     1' NO. ',I4,' AND TIME ',F10.4,' A LINE HAS A DOSAGE AMT., BUT NO'/
     2' DURATION (EVEN A BOLUS SHOULD HAVE A DURATION OF 0) IN '/
     3' ENTRY 4., OR NO DRUG NO. IN ENTRY 5.'//
     3' THE PROGRAM STOPS.')
	WRITE(*,401) NSUB,SUBARRAY(NSUB)

        OPEN(42,FILE=ERRFIL)
C        WRITE(42,51) NSUB, TIMEVENT - TIMERESET
         WRITE(42,51) NSUB, XVERIFY(1)
         WRITE(42,401) NSUB,SUBARRAY(NSUB)
        CLOSE(42)
	
	CALL PAUSE
	STOP


   40   CONTINUE


C  READ IN ANY COVARIATE VALUES IF NCOVA .GT. 0.


	IF(NCOVA .GT. 0) THEN

         DO 60 ICOV = 1,NCOVA

	  CALL AFTERCOMMA(NCOVA,READLINE,11+ICOV)

	  BACKSPACE(57)
 	  READ(57,*,ERR=70) COVVAL
	  CLOSE(57)

C  TO GET TO THIS POINT --> COVVAL REPRESENTS THE VALUE OF COV. NO.
C  ICOV. STORE IT AT THE INDICATED TIME, TIMEVENT.

	  NTIMALL(NSUB) = NTIMALL(NSUB) + 1

	 IF(NTIMALL(NSUB) .GT. 24000) THEN



	  WRITE(*,3001) NSUB
	  WRITE(*,401) NSUB,SUBARRAY(NSUB)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,3001) NSUB
         WRITE(42,401) NSUB,SUBARRAY(NSUB)
        CLOSE(42)	



	  CALL PAUSE
	  STOP

	 ENDIF

	 TIMALL(NSUB,NTIMALL(NSUB)) = TIMEVENT



      IF(IDEVENT .EQ. 4) THEN

C  SEE LOGIC ABOVE FOR TIME RESET LOGIC, AND ADDING LINES TO THE
C  OUTPUT EQUATION VALUES IN THAT CASE.

C  STORE VALUES INTO THE OUPUT ARRAYS (TIME = 0 AND VALUE = -99) WHICH 
C  INDICATE THAT SUBSEQUENT OUTPUT TIMES ARE BASED ON THIS TIME RESET.
C  ... BUT ONLY STORE THESE EXTRA VALUES IF NRESETADD = 0. IF 
C  NRESETADD = 1, IT MEANS THAT THESE LINES HAVE ALREADY BEEN ADDED
C  SINCE THE LAST ACTUAL OUTPUT VALUE WAS PUT INTO ONE OF THE OUTPUT
C  ARRAYS.

       IF(NRESETADD .EQ. 0) THEN
        DO IOUTEQ = 1,MAXNUMEQ
         NTIMOUT(NSUB,IOUTEQ) = NTIMOUT(NSUB,IOUTEQ) + 1
         TIMOUT(NSUB,IOUTEQ,NTIMOUT(NSUB,IOUTEQ)) = TIMEVENT
   	   OUT(NSUB,IOUTEQ,NTIMOUT(NSUB,IOUTEQ)) = -99.D0
        END DO
        NRESETADD = 1
       ENDIF

	 ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(IDEVENT .EQ. 4)  CONDITION.

C  SINCE MULTIPLE DOSE LINES CAN OCCUR AT THE SAME TIME (DEFINING
C  DOSES FOR DIFFERENT DRUGS OR IV VS. BOLUS VALUES, IT IS POSSIBLE
C  THAT A COVARIATE VALUE IS BEING RESET AT THE SAME TIME AS IN A

C  PREVIOUS LINE. IF THIS IS TRUE, TELL THE USER THAT THE COVARIATE
C  VALUE FROM THE FIRST LINE WILL BE USED. THIS MUST BE CHECKED ONLY
C  IF THE INDEX OF THE NO. OF COVARIATE VALUES IS > 0 - OTHERWISE
C  THIS IS THE FIRST LINE WITH A COVARIATE VALUE ON IT).

C  BUT, ONLY WRITE THIS WARNING IF THE TWO COVARIATE VALUES ARE
C  ACTUALLY DIFFERENT, BECAUSE IF THEY ARE THE SAME, THERE IS NO
C  CONFLICT, JUST REDUNDANCY.


	  IF(NTIMCOV(NSUB,ICOV) .GT. 0) THEN

	   CALL THESAME(TIMEVENT,TIMCOV(NSUB,ICOV,NTIMCOV(NSUB,ICOV)),
     1                  ISAMETIME)

	   CALL THESAME(COVVAL,COV(NSUB,ICOV,NTIMCOV(NSUB,ICOV)),
     1                  ISAMECOV)



	   IF(ISAMETIME .EQ. 1 .AND. ISAMECOV .EQ. 1) GO TO 60

	   IF(ISAMETIME .EQ. 1 .AND. ISAMECOV .EQ. 0) THEN

C  REPLACE WRITING OF TIMEVENT - TIMERESET, ETC. WITH XVERIFY (SEE 

C  LOGIC IN SUBROUTINE VERIFYVAL.

        XVERIFY(1) = TIMEVENT - TIMERESET
        XVERIFY(2) = COV(NSUB,ICOV,NTIMCOV(NSUB,ICOV))
        XVERIFY(3) = COVVAL
        CALL VERIFYVAL(3,XVERIFY)

C        WRITE(*,41) NSUB,TIMEVENT-TIMERESET,ICOV,
C    1    COV(NSUB,ICOV,NTIMCOV(NSUB,ICOV)),COVVAL
        WRITE(*,41) NSUB,XVERIFY(1),ICOV,XVERIFY(2),XVERIFY(3)
   41   FORMAT(/' FOR SUBJECT, 'I3,' AT TIME ',G14.7,', COVARIATE'/
     1' NO. ',I2,' WAS SET TO BOTH ',G14.7,' AND ',G14.7,'. YOU SHOULD'/
     2' CHECK YOUR BLOCK FILE. FOR NOW, THE FIRST VALUE WILL BE USED.')
    
	    GO TO 60


	   ENDIF

	  ENDIF

	  NTIMCOV(NSUB,ICOV) = NTIMCOV(NSUB,ICOV) + 1


	  TIMCOV(NSUB,ICOV,NTIMCOV(NSUB,ICOV)) = TIMEVENT 
	  COV(NSUB,ICOV,NTIMCOV(NSUB,ICOV)) = COVVAL

	  GO TO 60

   70     CONTINUE

C  TO GET TO LABEL 70 --> THERE WAS NO NUMBER IN THE ENTRY FOR 
C  COVARIATE, ICOV.

   60   CONTINUE



	ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(NCOVA .EQ. 0)  CONDITION.


	ENDIF


C  THE ABOVE ENDIF IS FOR THE  IF(IDEVENT .EQ. 1 .OR. IDEVENT .EQ. 4) 
C  CONDITION.


C  RETURN TO LABEL 10 TO READ THE NEXT LINE IN THE BLOCK PATIENT
C  DATA FILE.


	GO TO 10



  100   NSUB = 1


	IF(NCOVA .GT. 0) THEN

	 WRITE(*,111) NCOVA
  111    FORMAT(/' YOUR BLOCK FORMAT PATIENT INFORMATION FILE SHOWS'/
     1' ',I2,' COVARIATES. EACH COVARIATE MUST BE SPECIFIED TO BE '/
     2' EITHER A PIECEWISE CONSTANT COVARIATE OR AN INTERPOLATED '/
     3' COVARIATE.'//
     4' A PIECEWISE CONSTANT COVARIATE WILL HAVE THE SAME VALUE FROM'/
     5' ONE EXPLICITLY CODED VALUE, THROUGH ALL INTERVEENING DOSE'/
     6' TIMES, TO THE NEXT EXPLICITLY CODED VALUE (WHEN IT WILL CHANGE).
     7 '//
     8' AN INTERPOLATED COVARIATE WILL HAVE INTERPOLATED VALUES FROM'/
     9' ONE EXPLICITY CODED VALUE, THROUGH ALL INTERVEENING DOSE '/
     1' TIMES, TO THE NEXT EXPLCITLY CODED VALUE.'//)


	 DO ICOV = 1,NCOVA


  130	  WRITE(*,112) COVNAME(ICOV)
  112     FORMAT(/' FOR COVARIATE ',A11/
     1'  ENTER 1 IF IT IS TO BE PIECEWISE CONSTANT; '/
     2'  ENTER 2 IF IT IS TO BE INTERPOLATED: ')
	  READ(*,*,ERR=130) ITYPE
	  IF(ITYPE .NE. 1 .AND. ITYPE .NE. 2) GO TO 130
	  ICOVTYPE(ICOV) = ITYPE
	 END DO

	ENDIF


C  THE ABOVE ENDIF IS FOR THE  IF(NCOVA .GT. 0)  CONDITION.


C  WRITE OUT ALL THE INFO IN THE ABOVE ARRAYS INTO A WORKING COPY
C  FORMAT. ACTUALLY, FOR NOW, JUST TRY TO CREATE THE DOSAGE AND
C  OBSERVATION PART OF A FILE SIMILAR TO 2DRUG001 (I.E., DON'T
C  WORRY NOW ABOUT THE TOP PART OF THE FILE, OR THE BOTTOM).

C  FIRST, CALL SUBROUTINE GETCHAR2 TO ESTABLISH THE NUMBER ARRAY.

	DO JSUB = 1,NSUB

	 CALL GETCHAR2(JSUB,CHARSUB)
	 NUMBER(JSUB) = CHARSUB
	END DO

	DO 1000 ISUB = 1,NSUB

C  NOTE THAT THE WORKING COPY SUBJECTS WILL BE PLACED INTO THE 
C  WORKING DIRECTORY. THE PREFIX WILL BE HARDCODED TO 'XQZPJ', AND THE 
C  SUFFIX TO 'ZMQ'.

	 PATFIL = 'PATQZPX.001'
	 OPEN(33,FILE=PATFIL)


	 IF(NDRUG .GT. 7) THEN

	  WRITE(*,101) NDRUG
  101     FORMAT(/' NO. OF DRUGS IN THIS PATIENT DATA SET IS ',I2/
     1'  THIS IS MORE THAN 7, THE MAXIMUM --> PROGRAM STOPS.'/)
	  WRITE(*,401) ISUB,SUBARRAY(ISUB)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,101) NDRUG
         WRITE(42,401) ISUB,SUBARRAY(ISUB)
        CLOSE(42)	

	  CALL PAUSE
	  STOP



	 ENDIF

	 IF(NOUT .GT. MAXNUMEQ) THEN

        WRITE(*,106) NOUT,MAXNUMEQ
  106   FORMAT(/' NO. OF OUTPUT EQS. THIS PATIENT DATA SET IS ',I2/
     1' THIS IS MORE THAN THE MAX. ALLOWED VALUE OF ',I2,'. SO THE'/
     2' PROGRAM STOPS.'/)
	  WRITE(*,401) ISUB,SUBARRAY(ISUB)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,106) NOUT,MAXNUMEQ
         WRITE(42,401) ISUB,SUBARRAY(ISUB)
        CLOSE(42)
	
	  CALL PAUSE
	  STOP

	 ENDIF

	 IF(NCOVA .GT. 26) THEN

	  WRITE(*,103) NCOVA
  103     FORMAT(/' NO. OF COVARIATES IN THIS PATIENT DATA SET IS ',I3/
     1'  THIS IS MORE THAN 26, THE MAXIMUM --> PROGRAM STOPS.'/)
	  WRITE(*,401) ISUB,SUBARRAY(ISUB)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,103) NCOVA
         WRITE(42,401) ISUB,SUBARRAY(ISUB)
        CLOSE(42)	

	  CALL PAUSE
	  STOP

	 ENDIF


C  BEFORE CALLING WRITEDOS, CALL TIMESET FOR THIS SUBJECT TO 
C  ELIMINATE ALL THE DUPLICATE TIMES IN TIMALL(ISUB,.). THERE COULD BE 
C  DUPLICATE TIMES BECAUSE NTIMALL(ISUB) WAS INCREASED BY 1 FOR EACH 
C  BOLUS, IV, OR COVARIATE VALUE, AND SOME OF THESE VALUES OCCUR AT THE 
C  SAME TIME.  TIMESET ALSO ORDERS THE TIMES AND THEY COULD BE OUT OF 
C  ORDER DUE TO AN IV RATE WHOSE DURATION RESULTS IN THE ENDING TIME 
C  BEING PAST THE NEXT DOSE EVENT. 

C  TIMESET RETURNS THE COMPLETE SET OF TIMES FOR THIS SUBJECT'S DOSAGE 
C  REGIMEN IN TIMI (AND THERE ARE NTIMI OF THEM).

	 CALL TIMESET(MAXSUB,ISUB,SUBARRAY(ISUB),NTIMALL,TIMALL,NTIMI,
     1    TIMI)
	

C  CALL WRITEDOS TO WRITE THE PATIENT INFO TO PATHFILE = FILE 33.

	 CALL WRITEDOS(ISUB,NTIMIV,TIMIV,RATEIV,NTIMBOL,TIMBOL,BOLUS,
     1    NTIMCOV,TIMCOV,COV,ICOVTYPE,NDRUG,NCOVA,NOUT,NTIMOUT,
     2    TIMOUT,OUT,SUBARRAY(ISUB),COVNAME,MAXSUB,NTIMI,TIMI,TIMADD,
     3    CSUB,NSST,DOSELINEST)

 1000   CONTINUE


	RETURN
	END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
	SUBROUTINE AFTERCOMMA(NCOVA,READLINE,NCOMMA)
	CHARACTER READLINE*1000,ERRFIL*20

      COMMON/ERROR/ERRFIL
C  COMMON/ERROR/ IS SUPPLIED TO ALL THE ROUTINES WHICH COULD WRITE TO
C  ERRFIL.

C  OPEN AND WRITE INTO SCRATCH FILE 57 THE PART OF READLINE THAT 
C  IS BETWEEN COMMAS NCOMMA AND NCOMMA+1 ... UNLESS NCOMMA IS THE MAX.
C  NO. OF COMMAS (11+NCOVA). IN THIS CASE, WRITE INTO SCRATCH FILE 57 
C  THE PART OF READLINE THAT FOLLOWS COMMA NCOMMA (SINCE THERE WILL NOT
C  BE ANOTHER COMMA).


    1   FORMAT(A1000)

C  IF NCOMMA = 0, SET ISTART = 0 AND GO TO LABEL 10.

	
	IF(NCOMMA .EQ. 0) THEN
	 ISTART = 0
	 GO TO 10
	ENDIF


	ICOMMA = 0

	DO ISTART = 1,300
	 IF(READLINE(ISTART:ISTART) .EQ. ',') THEN
	  ICOMMA = ICOMMA + 1
	  IF(ICOMMA .EQ. NCOMMA) GO TO 10

	 ENDIF
	END DO	    


C  TO GET TO THIS POINT MEANS THAT THE NO. OF COMMAS IN LINE
C  READLINE IS LESS THAN NCOMMA. WRITE A MESSAGE AND STOP.

	WRITE(*,2) NCOMMA,ICOMMA,READLINE
    2   FORMAT(/' THE FOLLOWING LINE WAS SUPPOSED TO HAVE AT LEAST ',I3/
     1' COMMAS, BUT IT HAD ONLY ',I3,' SO THE PROGRAM STOPS.'//
     2A1000)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,2) NCOMMA,ICOMMA,READLINE
        CLOSE(42)

	CALL PAUSE
	STOP
	

C  TO REACH LABEL 10, ISTART IS NOW THE COLUMN NO. WHICH HAS THE
C  NCOMMAth COMMA IN LINE READLINE.  FIND IEND, WHICH IS THE COLUMN NO.
C  WHICH HAS THE NCOMMA+1 ST COMMA IN THE LINE. THEN WRITE THE PORTION
C  OF READLINE WHICH IS BETWEEN ISTART AND IEND INTO FILE57.

   10	ICOMMA = 0

	DO IEND = 1,300
	 IF(READLINE(IEND:IEND) .EQ. ',') THEN
	  ICOMMA = ICOMMA + 1
	  IF(ICOMMA .EQ. NCOMMA+1) GO TO 20
	 ENDIF
	END DO	    


C  TO GET TO THIS POINT MEANS THAT THE NO. OF COMMAS IN LINE
C  READLINE IS LESS THAN NCOMMA+1. THIS IS OK IF NCOMMA IS THE MAXIMUM
C  NO. OF COMMAS, WHICH IS 11+NCOVA. OTHERWISE, WRITE A MESSAGE AND 
C  STOP.




	IF(NCOMMA .LT. 11 + NCOVA) THEN

	 WRITE(*,2) NCOMMA+1,ICOMMA,READLINE

        OPEN(42,FILE=ERRFIL)
         WRITE(42,2) NCOMMA+1,ICOMMA,READLINE
        CLOSE(42)
	


	 CALL PAUSE
	 STOP



	ENDIF

	IF(NCOMMA .EQ. 11 + NCOVA) IEND = 301

   20	OPEN(57,STATUS='SCRATCH')

C  SEE CODE AT TOP OF MONTBG100.FOR TO SEE WHY FORMATTED WRITE 
C  STATEMENTS ARE USED (UNLESS NUMCHAR BELOW IS > 11, IN WHICH CASE

C  A FREE FORMAT WRITE STATEMENT IS STILL USED).

        NUMCHAR = IEND - ISTART - 1
	

        IF(NUMCHAR .EQ. 1) WRITE(57,101) READLINE(ISTART+1:IEND-1)
  101   FORMAT(A1)

        IF(NUMCHAR .EQ. 2) WRITE(57,102) READLINE(ISTART+1:IEND-1)
  102   FORMAT(A2)

        IF(NUMCHAR .EQ. 3) WRITE(57,103) READLINE(ISTART+1:IEND-1)
  103   FORMAT(A3)

        IF(NUMCHAR .EQ. 4) WRITE(57,104) READLINE(ISTART+1:IEND-1)
  104   FORMAT(A4)


        IF(NUMCHAR .EQ. 5) WRITE(57,105) READLINE(ISTART+1:IEND-1)
  105   FORMAT(A5)

        IF(NUMCHAR .EQ. 6) WRITE(57,106) READLINE(ISTART+1:IEND-1)
  106   FORMAT(A6)

        IF(NUMCHAR .EQ. 7) WRITE(57,107) READLINE(ISTART+1:IEND-1)

  107   FORMAT(A7)

        IF(NUMCHAR .EQ. 8) WRITE(57,108) READLINE(ISTART+1:IEND-1)
  108   FORMAT(A8)

        IF(NUMCHAR .EQ. 9) WRITE(57,109) READLINE(ISTART+1:IEND-1)
  109   FORMAT(A9)

        IF(NUMCHAR .EQ. 10) WRITE(57,110) READLINE(ISTART+1:IEND-1)
  110   FORMAT(A10)

        IF(NUMCHAR .EQ. 11) WRITE(57,111) READLINE(ISTART+1:IEND-1)
  111   FORMAT(A11)

        IF(NUMCHAR .GT. 11) WRITE(57,*) READLINE(ISTART+1:IEND-1)


	RETURN
	END
C

CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
        SUBROUTINE WRITEDOS(ISUB,NTIMIV,TIMIV,RATEIV,NTIMBOL,TIMBOL,
     1   BOLUS,NTIMCOV,TIMCOV,COV,ICOVTYPE,NDRUG,NCOVA,NOUT,NTIMOUT,
     2   TIMOUT,OUT,SUBID,COVNAME,MAXSUB,NTIMI,TIMI,TIMADD,CSUB,
     3   NSST,DOSELINEST)

         IMPLICIT REAL*8(A-H,O-Z)

         PARAMETER(MAXNUMEQ=7)

      DIMENSION BOLVAL(7),COVVAL(26),XIVVAL(7),DOSELINE(5200,43),
     1 TIMOUT(MAXSUB,MAXNUMEQ,650),TIMIV(MAXSUB,7,5200),
     2 NTIMOUT(MAXSUB,MAXNUMEQ),NTIMIV(MAXSUB,7),RATEIV(MAXSUB,7,5200),
     3 BOLUS(MAXSUB,7,5200),OUT(MAXSUB,MAXNUMEQ,650),
     4 COV(MAXSUB,26,5200),ICOVTYPE(26),TIMBOL(MAXSUB,7,5200),
     5 NTIMBOL(MAXSUB,7),NTIMCOV(MAXSUB,26),TIMCOV(MAXSUB,26,5200),
     6 INDIV(7),INDBOL(7),INDCOV(26),TIMI(24000),TIMORD(3900),
     7 BLOCKOUT(3900,MAXNUMEQ),CSUB(MAXSUB,4,MAXNUMEQ),NSST(MAXSUB),
     8 DOSELINEST(MAXSUB,99,100),DOSELINES(100),XVERIFY(900)

	CHARACTER SUBID*11,COVNAME(26)*11,ERRFIL*20

      COMMON/ERROR/ERRFIL
C  COMMON/ERROR/ IS SUPPLIED TO ALL THE ROUTINES WHICH COULD WRITE TO
C  ERRFIL.

C  THIS ROUTINE WRITES THE DOSE EVENTS AND THE OBSERVATION EVENTS OF 
C  THE PATIENT DATA FILE TO FILE33. NOTE THAT A DOSE EVENT OCCURS 
C  WHENEVER THERE IS A BOLUS APPLIED, AN IV RATE CHANGE, AND/OR A
C  COVARIATE VALUE APPLIED.


C----------------- WRITE THE TOP OF FILE BELOW -------------------------

	WRITE(33,301) SUBID
  301   FORMAT('  LAST AND FIRST NAMES ARE: ',A11)
	WRITE(33,302) SUBID
  302   FORMAT(' CHART NUMBER IS: ',A11//
     1' WARD NO, PATIENT AGE (YEARS), SEX, HEIGHT (INCHES),'/
     2' ETHNICITY FLAG, AND ETHNICITY DESCRIPTION (IF ANY)   FOLLOW ON'/
     3' THE NEXT 6 LINES:'/
     4'-99'/
     5'-99'/
     6'M'/
     7'-99'/
     8'1'/
     9'Ethnicity Description'//
     1' DATE OF FIRST THERAPY IS   1   1   08'/
     2'CCR ML/MIN/    0.00 150.00'/
     3'HOURS    MG     MG/HR    MCG/ML KG       MG/DL    60  .00 ')              


C----------------- WRITE THE TOP OF FILE ABOVE -------------------------


C----------------- WRITE THE DOSE EVENTS BELOW -------------------------

	 WRITE(33,102) NDRUG
  102    FORMAT(/'     ',I1,' ... NO. OF DRUGS')

C  NOTE THAT NCOVA IS THE NO. OF COVARIATES IN THE USER'S BLOCK FORMAT
C  FILE. THIS AUTOMATICALLY BECOMES NADD, THE NO. OF "ADDITIONAL"
C  COVARIATES IN THE WORKING COPY FILE.

	 WRITE(33,104) NCOVA
  104    FORMAT('    ',I2,' ... NO. OF ADDITIONAL COVARIATES')


C  INCREASE THE NO. OF DOSE EVENTS BY THE NO. OF STEADY STATE DOSE LINES
C  THAT WILL BE IN THE FILE (THESE WERE NOT PART OF THE ARRAY EXAMINED
C  BY SUBROUTINE TIMESET).

	WRITE(33,2) NTIMI + NSST(ISUB)
    2   FORMAT('   ',I3,' ... NO. OF DOSE EVENTS'//
     1'    TIME, IV/PO FOR EACH DRUG; ADDITIONAL COVARIATES IF ANY')


C  SET THE IVs FOR EACH DRUG TO 0. EACH DRUG IV VALUE STAYS THE SAME
C  AS ITS PREVIOUS VALUE UNTIL CHANGED. ALSO INITIALIZE EACH BOLUS
C  VALUE TO 0.

	DO IDRUG = 1,NDRUG
	 XIVVAL(IDRUG) = 0.D0
	 BOLVAL(IDRUG) = 0.D0

	END DO

C  SET EACH COVARIATE VALUE TO ITS INITIAL VALUE. IT IS ASSUMED THAT
C  EACH COV. HAS ITS FIRST VALUE SET AT THE FIRST DOSE TIME (T=0).
C  IF THIS IS NOT TRUE, SEE REMARK BELOW WHERE THE COVARIATE VALUES
C  ARE SET FOR EACH TIME.

	DO ICOV = 1,NCOVA
	 COVVAL(ICOV) = COV(ISUB,ICOV,1)
	END DO


C  INITIALIZE THE INDEX OF THE NEXT TIME IN EACH TIME ARRAY TO BE 1.

	DO IDRUG = 1,NDRUG
	 INDIV(IDRUG) = 1
	 INDBOL(IDRUG) = 1
	END DO

	DO ICOV = 1,NCOVA
	 INDCOV(ICOV) = 1
	END DO

C  GO THROUGH ALL THE NTIMI DOSAGE BLOCK TIMES IN TIMI AND ESTABLISH ALL
C  IV, BOLUS, AND COV. VALUES AT EACH TIME AND WRITE THEM TO THE DOSAGE 
C  REGIMEN, BUT NOTE THAT EACH TIME MUST BE REDUCED BY TIMERESET, WHERE
C  TIMERESET = TIMADD*NRESET, WHERE NRESET IS THE NO. OF TIME RESETS 
C  THROUGH THAT TIME (SEE IN READBLOCK2 THAT TIMERESET WAS ADDED TO EACH
C  TIME).

	NRESET = 0
	TIMERESET = TIMADD*NRESET

C  INITIALIZE NSSEVENTS = 1. THIS WILL BE THE INDEX OF THE NEXT STEADY
C  STATE DOSE EVENT (IF ANY) IN THE CURRENT PATIENT'S DATA FILE. THE
C  TOTAL NO. OF SUCH EVENTS IS NSST(ISUB).


      NSSEVENTS = 1

C  AS OF MONT101F, PUT IN A STEADY STATE LINE AS THE FIRST DOSE EVENT
C  IF ONE EXISTS. 

C  DOSELINEST(ISUB,1,100) = NRESET, THE NO. OF DOSE RESETS BEFORE THE
C  1ST STEADY STATE DOSE SET. 

C  IF DOSELINST(ISUB,1,100) = 0, IT MEANS THAT THERE IS A STEADY STATE
C  DOSE SET AT THE TOP OF THE FILE (I.E., BEFORE ANY RESETS). 

C  IF DOSELINEST(ISUB,1,100) IS = -99, IT MEANS THERE ARE NO STEADY 
C  STATE LINES FOR THIS SUBJECT. 

C  IF DOSELINEST(ISUB,1,100) = N > 0, IT MEANS THE FIRST STEADY STATE
C  DOSE SET OCCURS AFTER RESET NO. N.

      CALL THESAME(DOSELINEST(ISUB,1,100),0.D0,ISAME)

      IF(ISAME .EQ. 1) THEN

C  FILL IN THE ENTRIES TO DOSELINE FOR THE STEADY STATE DOSE AT THE
C  TOP OF THE PATIENT'S FILE.


C  THE FIRST ENTRY IN DOSELINST IS TIMEVENT = THE NEGATIVE OF THE
C  INTERDOSE INTERVAL.

	 DOSELINES(1) = DOSELINEST(ISUB,1,1)
	 NENTRY = 1

C  FOR EACH DRUG, THE IV AND TOTAL VALUES ARE ALREADY STORED INTO
C  DOSELINEST(ISUB,1,2*I) AND DOSELINEST(ISUB,1,2*I+1), I=1,NDRUG.

	 DO IDRUG = 1,NDRUG
	  NENTRY = NENTRY+1
        DOSELINES(NENTRY) = DOSELINEST(ISUB,1,2*IDRUG)
	  NENTRY = NENTRY+1
	  DOSELINES(NENTRY) = DOSELINEST(ISUB,1,2*IDRUG+1)

	 END DO

C  FOR EACH COVARIATE, IF ANY, THE VALUES ARE STORED INTO
C  DOSELINEST(ISUB,1,19+ICOV), ICOV = 1,NCOVA.

       IF(NCOVA .GT. 0) THEN
	  DO ICOV = 1,NCOVA
	   NENTRY = NENTRY+1
	   DOSELINES(NENTRY) = DOSELINEST(ISUB,1,19+ICOV)
	  END DO

       ENDIF


C  REPLACE WRITING OF DOSELINES() WITH XVERIFY (SEE LOGIC IN 
C  SUBROUTINE VERIFYVAL.

        DO J = 1,NENTRY
         XVERIFY(J) = DOSELINES(J)
        END DO
        CALL VERIFYVAL(NENTRY,XVERIFY)
C       WRITE(33,1) (DOSELINES(J),J=1,NENTRY)
        WRITE(33,1) (XVERIFY(J),J=1,NENTRY)

       NSSEVENTS = NSSEVENTS + 1


      ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(ISAME .EQ. 1)  CONDITION.


	DO 1000 ITIM = 1,NTIMI

	 TIME = TIMI(ITIM)

C  IF THIS TIME = THE NEXT MULTIPLE OF TIMADD, INCREASE THE NO. OF 
C  RESETS BY 1 AND RECALCULATE TIMERESET, THE CURRENT AMOUNT THAT EACH
C  TIME MUST BE REDUCED BEFORE BEING WRITTEN INTO THE WORKING COPY 
C  FILE.

C  AS OF MONT101F.FOR, THIS TIME COULD BE PAST A TIME RESET POINT. THIS
C  WOULD HAPPEN IF A TIME RESET HAD A STEADY STATE DOSE SET ASSOCIATED
C  WITH IT, WITHOUT A NON STEADY STATE DOSE IMMEDIATELY FOLLOWING IT (IF
C  A NON STEADY STATE DOSE IMMEDIATELY FOLLOWED A STEADY STATE SET, 
C  THEN THERE WILL BE TIMI(.) ENTRY THAT = TIMADD*(NRESET+1)). IN THIS
C  CASE TOO, UPDATE NRESET AND TIMERESET.

C  CALL THESAME HERE TO ESTABLISH THE VALUE FOR ISAMERESET. IT
C  WILL USED BELOW TO SUPPRESS INTERPOLATION OF COVARIATES ACROSS A
C  TIME RESET.


       CALL THESAME(TIME,TIMADD*(NRESET+1),ISAMERESET)   


       IF(TIME .GE. TIMADD*(NRESET+1)) THEN


C  TIME IS AT OR PAST THE NEXT MULTIPLE OF TIMADD (I.E., IT IS A TIME
C  RESET POINT). IN THIS CASE, INCREASE NRESET BY 1 AND RECALCULATE
C  TIMERESET.

	  NRESET = NRESET + 1
	  TIMERESET = TIMADD*NRESET

C  FOR THIS TIME RESET, CHECK TO SEE IF THE FIRST DOSE LINE WILL BE
C  A STEADY STATE DOSE EVENT. THE NO. OF STEADY STATE DOSE EVENTS IN
C  THIS PATIENT'S FILE IS NSST(ISUB), AND THE NO. OF SUCH EVENTS THAT
C  HAVE ALREADY BEEN WRITTEN TO FILE 33 IS NSSEVENTS-1 SO FAR.

        IF(NSSEVENTS .LE. NSST(ISUB)) THEN

C  THE NEXT STEADY STATE DOSE EVENT OCCURS AFTER RESET NO.
C  DOSELINEST(ISUB,NSSEVENTS,100). CHECK TO SEE IF THIS VALUE IS
C  THE SAME AS NRESET. IF SO, THIS RESET STARTS WITH A STEADY STATE
C  LINE.

         XRESET = NRESET

         CALL THESAME(DOSELINEST(ISUB,NSSEVENTS,100),XRESET,ISAME)

         IF(ISAME .EQ. 1) THEN

C  FILL IN THE ENTRIES TO DOSELINE FOR THE STEADY STATE DOSE AT THE
C  BEGINNING OF THIS DOSE RESET.

C  THE FIRST ENTRY IN DOSELINST IS TIMEVENT = THE NEGATIVE OF THE
C  INTERDOSE INTERVAL.

          DOSELINES(1) = DOSELINEST(ISUB,NSSEVENTS,1)
          NENTRY = 1

C  FOR EACH DRUG, THE IV AND TOTAL VALUES ARE ALREADY STORED INTO

C  DOSELINEST(ISUB,NSSEVENTS,2*I) AND DOSELINEST(ISUB,NSSEVENTS,2*I+1),
C  I=1,NDRUG.

          DO IDRUG = 1,NDRUG
           NENTRY = NENTRY+1
           DOSELINES(NENTRY) = DOSELINEST(ISUB,NSSEVENTS,2*IDRUG)
           NENTRY = NENTRY+1
           DOSELINES(NENTRY) = DOSELINEST(ISUB,NSSEVENTS,2*IDRUG+1)
          END DO

C  FOR EACH COVARIATE, IF ANY, THE VALUES ARE STORED INTO
C  DOSELINEST(ISUB,NSSEVENTS,19+ICOV), ICOV = 1,NCOVA.

          IF(NCOVA .GT. 0) THEN
           DO ICOV = 1,NCOVA
            NENTRY = NENTRY+1
            DOSELINES(NENTRY) = DOSELINEST(ISUB,NSSEVENTS,19+ICOV)
           END DO
          ENDIF


C  REPLACE WRITING OF DOSELINES() WITH XVERIFY (SEE LOGIC IN 
C  SUBROUTINE VERIFYVAL.

        DO J = 1,NENTRY
         XVERIFY(J) = DOSELINES(J)
        END DO
        CALL VERIFYVAL(NENTRY,XVERIFY)
C       WRITE(33,1) (DOSELINES(J),J=1,NENTRY)
        WRITE(33,1) (XVERIFY(J),J=1,NENTRY)

          NSSEVENTS = NSSEVENTS + 1

         ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(ISAME .EQ. 1)  CONDITION.


        ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(NSSEVENTS .LE. NSST(ISUB))  CONDITION.


	 ENDIF

C  THE ABOVE ENDIF IS FOR THE IF(TIME .GE. TIMADD*(NRESET+1)) CONDITION.



C  CHECK TO SEE IF ANY BOLUS TIMES = TIME.

	DO IDRUG = 1,NDRUG

C  IF THE CURRENT INDEX FOR THIS BOLUS IS MORE THAN THE NO.
C  OF ENTRIES IN THE CORRESPONDING ARRAY, IT MEANS THAT THERE ARE NO
C  MORE BOLUS VALUES FOR THIS DRUG. IN THAT CASE, SET ITS TIME TO -99.
C  OTHERWISE, SET ITS TIME TO THE NEXT TIME IN THE ARRAY.


	 IF(INDBOL(IDRUG) .GT. NTIMBOL(ISUB,IDRUG)) TIMEB = -99.D0

	 IF(INDBOL(IDRUG) .LE. NTIMBOL(ISUB,IDRUG)) THEN
	  TIMEB = TIMBOL(ISUB,IDRUG,INDBOL(IDRUG))

	 ENDIF


	 CALL THESAME(TIME,TIMEB,ISAME)


C  IF ISAME RETURNS FROM SUBROUTINE THESAME AS 1, THE TIMES ARE THE 
C  "SAME" (I.E., WITHIN 1.D-10). IN THIS CASE, SET THE BOLUS VALUE FOR
C  THIS EVENT TO THE CORRESPONDING VALUE IN BOLUS, AND INCREASE THE 
C  INDEX OF THE NEXT TIME BY 1. IF ISAME RETURNS AS 0, SET THE BOLUS 
C  VALUE = 0.


	  IF(ISAME .EQ. 0) BOLVAL(IDRUG) = 0.D0

	  IF(ISAME .EQ. 1) THEN
	   BOLVAL(IDRUG) = BOLUS(ISUB,IDRUG,INDBOL(IDRUG))
	   INDBOL(IDRUG) = INDBOL(IDRUG) + 1
	  ENDIF


	 END DO


C  CHECK TO SEE IF ANY COVARIATE TIMES = TIME.

	DO ICOV = 1,NCOVA

C  IF THE CURRENT INDEX FOR THIS COVARIATE IS MORE THAN THE NO.
C  OF ENTRIES IN THE CORRESPONDING ARRAY, IT MEANS THAT THERE ARE NO
C  MORE COV VALUES FOR THIS COVARIATE. IN THAT CASE, SET ITS TIME TO 
C  -99. OTHERWISE, SET ITS TIME TO THE NEXT TIME IN THE ARRAY.

	 IF(INDCOV(ICOV) .GT. NTIMCOV(ISUB,ICOV)) TIMEC = -99.D0

	 IF(INDCOV(ICOV) .LE. NTIMCOV(ISUB,ICOV)) THEN
	  TIMEC = TIMCOV(ISUB,ICOV,INDCOV(ICOV))
	 ENDIF

	 CALL THESAME(TIME,TIMEC,ISAME)

	
C  IF ISAME RETURNS FROM SUBROUTINE THESAME AS 1, THE TIMES ARE THE 
C  "SAME" (I.E., WITHIN 1.D-10). IN THIS CASE, SET THE COVARIATE VALUE 
C  FOR THIS EVENT TO THE CORRESPONDING VALUE IN COV, AND INCREASE THE 
C  INDEX OF THE NEXT TIME BY 1. 

	  IF(ISAME .EQ. 1) THEN
	   COVVAL(ICOV) = COV(ISUB,ICOV,INDCOV(ICOV))
	   INDCOV(ICOV) = INDCOV(ICOV) + 1
	  ENDIF



C  IF ISAME RETURNS AS 0, THE COV. VALUE WILL BE THE SAME AS IT WAS 
C  PREVIOUSLY IF ICOVTYPE(ICOV) = 1 OR 0 (I.E., IF THIS IS A PIECEWISE
C  CONTINOUS COVARIATE). IT WILL ALSO BE THE SAME AS IT WAS PREVIOUSLY
C  IF ICOVTYPE(ICOV) = 2 (I.E., FOR A LINEARLY INTERPOLATED COVARIATE)
C  IF TIMEC = -99, OR IF ISAMERESET = 1. HERE IS WHY:

C  TIMEC = -99 --> THERE ARE NO MORE COVARIATE VALUES (SEE ABOVE).
C  IF ISAMERESET = 1, THEN THIS IS A TIME RESET POINT. AND IN THIS CASE,
C  EVEN AN INTERPOLATED COVARIATE VALUE SHOULD BE SET = ITS LAST VALUE 
C  FROM BEFORE THE RESET, SINCE NO INTERPOLATION IS POSSIBLE FOR OUT OF 
C  ORDER TIMES (E.G., (T,COV) = (24,400), FOLLOWED BY (T,COV) = 
C  (20,1000) --> INTERPOLATED VALUE AT 0 WOULD BE: 
C  (0-24)/(20-24) * (1000 - 400) + 400 = 4000, WHICH IS PREPOSTEROUS).


	IF(ISAME .EQ. 0) THEN


C  SET INTERP = 1, WHICH MEANS THAT THIS COVARIATE VALUE SHOULD BE 
C  INTERPOLATED FROM THE TWO SURROUNDING COVARIATE VALUES (WHICH HAVE
C  BEEN EXPLICITLY SPECIFIED IN THE BLOCK FORMAT FILE). CHANGE INTERP
C  TO 0 IF THIS IS NOT AN INTERPOLATED COVARIATE (ICOVTYPE(ICOV) = 1
C  OR 0) OR IF THIS IS AN INTERPOLATED COVARIATE BUT THERE ARE NO MORE
C  COVARIATE VALUES FOR THIS COVARIATE (TIMEC = -99) OR IF THIS IS A
C  TIME RESET VALUE (ISAMERESET = 1), OR IF THE CURRENT COVARIATE TIME

C  (WHICH WOULD BE USED IN THE INTERPOLATION) IS AT OR PAST THE NEXT 
C  TIME RESET.



	 INTERP = 1
	 IF(ICOVTYPE(ICOV) .EQ. 1 .OR. ICOVTYPE(ICOV) .EQ. 0) 
     1    INTERP = 0

	 IF(TIMEC .LE. -99) INTERP = 0
	 IF(ISAMERESET .EQ. 1) INTERP = 0

	 IF(TIMEC .GE. TIMERESET + TIMADD) INTERP = 0


C  IF INTERP = 1:

C  NOTE THAT INDCOV(ICOV) MUST BE .GE. 2 UNLESS THE USER HAS MADE A 
C  MISTAKE SINCE THE FIRST TIME (TIME = 0) IS SUPPOSED TO HAVE ALL 
C  COVARIATE VALUES SPECIFIED, WHICH MEANS THE FIRST TIME THROUGH THIS
C  PART OF THE CODE ABOVE, INDCOV(ICOV) WAS INCREASED BY 1 (FROM ITS
C  ORIGINAL VALUE OF 1). IF THIS IS NOT TRUE, WRITE A MESSAGE TO THE

C  USER AND STOP.



	 IF(INDCOV(ICOV) .EQ. 1) THEN



	  WRITE(*,111) ICOV
  111     FORMAT(/' THERE IS A MISTAKE IN THE BLOCK FORMAT PATIENT'/
     1' DATA FILE. THE FIRST VALUE FOR COVARIATE NO. ',I2,' WAS NOT'/
     2' SPECIFIED AT THE ORIGINAL TIME = 0, AS IS REQUIRED. PLEASE'/
     3' FIX THIS ERROR AND RERUN THE PROGRAM. '//)
	  WRITE(*,401) ISUB,SUBID
  401   FORMAT(/' NOTE: THE ID FOR SUBJECT NO. ',I4,' IS ',A11/)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,111) ICOV
         WRITE(42,401) ISUB,SUBID
        CLOSE(42)	



	  CALL PAUSE
	  STOP



	 ENDIF 


	 CLAST = COV(ISUB,ICOV,INDCOV(ICOV)-1)

	 IF(INTERP .EQ. 0) COVVAL(ICOV) = CLAST

	 IF(INTERP .EQ. 1) THEN

C  NOTE: THE LAST COV. VALUE WAS CLAST WHICH OCCURRED AT TLAST. THE NEXT
C  COV VALUE IS CNEXT WHICH OCCURS AT TNEXT. SO ESTABLISH THE 
C  LINEARLY INTERPOLATED VALUE FOR THIS TIME, TIME. NOTE THAT THE TIMES,
C  TLAST AND TNEXT, MUST BE RECAST AS THEIR ACTUAL TIMES (BY REDUCING
C  THEM BY TIMERESET) FIRST.


	  TLAST = TIMCOV(ISUB,ICOV,INDCOV(ICOV)-1) - TIMERESET
	  CNEXT = COV(ISUB,ICOV,INDCOV(ICOV))
	  TNEXT = TIMCOV(ISUB,ICOV,INDCOV(ICOV)) - TIMERESET
	  TIMEREAL = TIME - TIMERESET
	  COVVAL(ICOV) = (TIMEREAL-TLAST)/(TNEXT-TLAST) * (CNEXT-CLAST)
     1     + CLAST
	 ENDIF	  

	ENDIF


C  THE ABOVE ENDIF IS FOR THE  IF(ISAME .EQ. 0)  CONDITION.



	 END DO


C  THE ABOVE END DO IS FOR THE  DO ICOV = 1,NCOVA  LOOP.



C  CHECK TO SEE IF ANY IV TIMES = TIME.

	DO IDRUG = 1,NDRUG

C  IF THE CURRENT INDEX FOR THIS IV IS MORE THAN THE NO.
C  OF ENTRIES IN THE CORRESPONDING ARRAY, IT MEANS THAT THERE ARE NO
C  MORE IV VALUES FOR THIS DRUG. IN THAT CASE, SET ITS TIME TO -99.
C  OTHERWISE, SET ITS TIME TO THE NEXT TIME IN THE ARRAY.

	 IF(INDIV(IDRUG) .GT. NTIMIV(ISUB,IDRUG)) TIMEI = -99.D0

	 IF(INDIV(IDRUG) .LE. NTIMIV(ISUB,IDRUG)) THEN

	  TIMEI = TIMIV(ISUB,IDRUG,INDIV(IDRUG))
	 ENDIF

	 CALL THESAME(TIME,TIMEI,ISAME)

C  IF ISAME RETURNS FROM SUBROUTINE THESAME AS 1, THE TIMES ARE THE 
C  "SAME" (I.E., WITHIN 1.D-10). IN THIS CASE, SET THE IV VALUE FOR
C  THIS EVENT TO THE CORRESPONDING VALUE IN RATEIV, AND INCREASE THE 
C  INDEX OF THE NEXT TIME BY 1. IF ISAME RETURNS AS 0, THE IV VALUE
C  WILL REMAIN WHAT IT WAS PREVIOUSLY.

	  IF(ISAME .EQ. 1) THEN
	   XIVVAL(IDRUG) = RATEIV(ISUB,IDRUG,INDIV(IDRUG))
	   INDIV(IDRUG) = INDIV(IDRUG) + 1
	  ENDIF

	 END DO


C  PUT THE ACTUAL TIME (I.E., TIME - TIMERESET) INTO THE 1ST ENTRY FOR
C  THIS ROW. THEN PUT IN THE IV/BOLUS VALUES FOR EACH OF THE NDRUG DRUGS
C  IN ORDER; THEN ALL ADDITIONAL COV. VALUES.

	 DOSELINE(ITIM,1) = TIME - TIMERESET
	 NENTRY = 1


	 DO IDRUG = 1,NDRUG
	  NENTRY = NENTRY+1
	  DOSELINE(ITIM,NENTRY) = XIVVAL(IDRUG)
	  NENTRY = NENTRY+1
	  DOSELINE(ITIM,NENTRY) = BOLVAL(IDRUG)
	 END DO

	 DO ICOV = 1,NCOVA
	  NENTRY = NENTRY+1
	  DOSELINE(ITIM,NENTRY) = COVVAL(ICOV) 
	 END DO

C  REPLACE WRITING OF DOSELINES() WITH XVERIFY (SEE LOGIC IN 
C  SUBROUTINE VERIFYVAL.

        DO J = 1,NENTRY
         XVERIFY(J) = DOSELINE(ITIM,J)
        END DO
        CALL VERIFYVAL(NENTRY,XVERIFY)
C       WRITE(33,1) (DOSELINE(ITIM,J),J=1,NENTRY)
        WRITE(33,1) (XVERIFY(J),J=1,NENTRY)
    1   FORMAT(43(G19.9,1X))



 1000   CONTINUE

C  THE ABOVE LABEL IS THE END OF THE  DO 1000 ITIM = 1,NTIMI  LOOP.


C  NOW CHECK TO SEE IF THE DOSAGE REGIMEN ENDS WITH ONE OR MORE STEADY

C  STATE EVENTS. NOTE THAT THERE ARE NSST(ISUB) STEADY STATE EVENTS,
C  AND NSSEVENTS - 1 OF THESE HAVE BEEN WRITTEN TO THE WORKING COPY FILE
C  SO FAR. 

 1010   CONTINUE

        IF(NSSEVENTS .LE. NSST(ISUB)) THEN


C  THE NEXT STEADY STATE DOSE EVENT OCCURS AFTER RESET NO.
C  DOSELINEST(ISUB,NSSEVENTS,100). 

C  FILL IN THE ENTRIES TO DOSELINE FOR THE STEADY STATE DOSE AT THE
C  BEGINNING OF THIS DOSE RESET.

C  THE FIRST ENTRY IN DOSELINST IS TIMEVENT = THE NEGATIVE OF THE
C  INTERDOSE INTERVAL.

          DOSELINES(1) = DOSELINEST(ISUB,NSSEVENTS,1)
          NENTRY = 1

C  FOR EACH DRUG, THE IV AND TOTAL VALUES ARE ALREADY STORED INTO
C  DOSELINEST(ISUB,NSSEVENTS,2*I) AND DOSELINEST(ISUB,NSSEVENTS,2*I+1),

C  I=1,NDRUG.

          DO IDRUG = 1,NDRUG
           NENTRY = NENTRY+1
           DOSELINES(NENTRY) = DOSELINEST(ISUB,NSSEVENTS,2*IDRUG)

           NENTRY = NENTRY+1
           DOSELINES(NENTRY) = DOSELINEST(ISUB,NSSEVENTS,2*IDRUG+1)

          END DO

C  FOR EACH COVARIATE, IF ANY, THE VALUES ARE STORED INTO
C  DOSELINEST(ISUB,NSSEVENTS,19+ICOV), ICOV = 1,NCOVA.

          IF(NCOVA .GT. 0) THEN
           DO ICOV = 1,NCOVA
            NENTRY = NENTRY+1
            DOSELINES(NENTRY) = DOSELINEST(ISUB,NSSEVENTS,19+ICOV)
           END DO
          ENDIF

C  REPLACE WRITING OF DOSELINES() WITH XVERIFY (SEE LOGIC IN 
C  SUBROUTINE VERIFYVAL.

        DO J = 1,NENTRY
         XVERIFY(J) = DOSELINES(J)
        END DO
        CALL VERIFYVAL(NENTRY,XVERIFY)
C       WRITE(33,1) (DOSELINES(J),J=1,NENTRY)
        WRITE(33,1) (XVERIFY(J),J=1,NENTRY)

          NSSEVENTS = NSSEVENTS + 1
 
          GO TO 1010

        ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(NSSEVENTS .LE. NSST(ISUB))  CONDITION.




C----------------- WRITE THE DOSE EVENTS ABOVE -------------------------



C----------------- WRITE THE OBSERVATION EVENTS BELOW ------------------


	WRITE(33,106) NOUT
  106   FORMAT(/'     ',I1,' ... NO. OF TOTAL OUTPUT EQUATIONS')


C  EACH SET OF TIMES FOR EACH OUTPUT EQUATION, TIMOUT(ISUB,IOUT,I),
C  I = 1,NTIMOUT(ISUB,IOUT), IS IN ORDER, BUT EACH TIME HAS ADDED
C  TO IT TIMADD*NRESET, WHERE NRESET IS THE NO. OF TIME RESETS UP TO
C  AND TIME. 

C  CALL FIXOUTIM TO OBTAIN NTIMORD, TIMORD, AND BLOCKOUT, WHERE
C  NTIMORD IS THE TOTAL NO. OF UNIQUE TIMES TO BE PUT INTO THE 
C  OBSERVATION BLOCK; TIMORD(.) IS THE ORDERED ACTUAL TIMES (I.E., EACH
C  OF THE TIMES IN TIMOUT(.,.,.) HAS BEEN REDUCED BY TIMADD*NRESET - SEE
C  ABOVE), EXCEPT THAT EACH TIME OF 0 IS NOT ORDERED (IT INDICATES THE 
C  NEXT TIME RESET) FOR THE OBSERVATION BLOCK; AND BLOCKOUT IS THE 
C  CORRESPONDING ARRAY OF OBSERVED VALUES FOR THE NOUT OUTPUT EQUATIONS 
C  AT THE TIMES IN TIMORD.



	CALL FIXOUTIM(MAXSUB,ISUB,SUBID,NOUT,NTIMOUT,TIMOUT,OUT,NTIMORD,
     1   TIMORD,BLOCKOUT,TIMADD)


      	WRITE(33,62) NTIMORD
   62   FORMAT('  ',I4,' ... NO. OF OBSERVED VALUE TIMES')

C  REPLACE WRITING OF TIMORD(), BLOCKOUT() WITH XVERIFY (SEE LOGIC IN 
C  SUBROUTINE VERIFYVAL).


       DO I = 1,NTIMORD
        XVERIFY(1) = TIMORD(I)
        DO J = 1,NOUT
         XVERIFY(1+J) = BLOCKOUT(I,J)
        END DO
        CALL VERIFYVAL(1+NOUT,XVERIFY)      
C       WRITE(33,63) TIMORD(I),(BLOCKOUT(I,J),J=1,NOUT)

        WRITE(33,63) (XVERIFY(IXV),IXV=1,1+NOUT)
   63   FORMAT(7(G16.8,1X))
       END DO


C----------------- WRITE THE OBSERVATION EVENTS ABOVE ------------------


C----------------- WRITE THE BOTTOM OF FILE BELOW ----------------------

	WRITE(33,303)
  303   FORMAT(/' COVARIATE NAMES AND VALUES (1ST, LAST, AND MEAN) FOLLO

     1W:')

C  FOR NOW, THE MEAN VALUE OF EACH COV. WILL BE -99 ... UNTIL WE DECIDE
C  WHAT KIND OF MEAN WE WANT. E.G., IF A COV. = 100 AT T=0 AND
C  200 AT T = 10 AND 300 AT T = 11, WHICH IS THE LAST TIME, DO WE
C  SIMPLY AVERAGE 100,200, AND 300, OR DO WE TAKE A WEIGHTED MEAN
C  WHICH WOULD BE (100*10 + 200*1 + 300*0)/11, OR SOMETHING ELSE???

C  REPLACE WRITING OF COV(),XMEAN WITH XVERIFY (SEE LOGIC IN 
C  SUBROUTINE VERIFYVAL

      XMEAN = -99
      DO ICOV = 1,NCOVA
       XVERIFY(1) = COV(ISUB,ICOV,1)
       XVERIFY(2) = COV(ISUB,ICOV,NTIMCOV(ISUB,ICOV))
       XVERIFY(3) = XMEAN
       CALL VERIFYVAL(3,XVERIFY)
C      WRITE(33,304) COVNAME(ICOV),COV(ISUB,ICOV,1),
C    1  COV(ISUB,ICOV,NTIMCOV(ISUB,ICOV)),XMEAN
       WRITE(33,304) COVNAME(ICOV),(XVERIFY(I),I=1,3) 
      END DO
  304 FORMAT(A11,3X,3(F15.5,1X))


	WRITE(33,306)
  306   FORMAT(/'ASSAY COEFFICIENTS FOLLOW, ONE SET FOR EACH OUTPUT EQUA
     1TION:')

C  REPLACE WRITING OF CSUB() WITH XVERIFY (SEE LOGIC IN 
C  SUBROUTINE VERIFYVAL.

        DO K = 1,NOUT
         DO I=1,4
          XVERIFY(I) = CSUB(ISUB,I,K)
         END DO
         CALL VERIFYVAL(4,XVERIFY)
C        WRITE(33,3061) (CSUB(ISUB,I,K),I=1,4)
         WRITE(33,3061) (XVERIFY(I),I=1,4)
        END DO

 3061   FORMAT(4(F17.8,1X))


C----------------- WRITE THE BOTTOM OF FILE ABOVE ----------------------


	CLOSE(33)

	RETURN 
	END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
	SUBROUTINE GETMAXTIM(NCOVA,TIMAX)

	IMPLICIT REAL*8(A-H,O-Z)

	CHARACTER READLINE*1000

C  THIS SUBROUTINE IS CALLED BY READBLOCK2 TO GET TIMAX, THE MAXIMUM TIME 
C  OVER ALL SUBJECTS IN FILE 67. THIS MAXIMUM TIME INCLUDES THE ENDING
C  TIME FOR ALL IV RATES.

C  GO THROUGH ALL THE ROWS OF THE BLOCK FORMAT FILE. READ THE EVENT 
C  TIMES IN ENTRY 3. IF THE ROW IS AN IV ROW, ADD THIS VALUE TO THE 
C  DURATION TIME IN ENTRY 4. THEN UPDATE TIMAX IF THIS TOTAL TIME IS
C  > TIMAX, WHICH IS INITIALIZED BELOW TO BE NEGATIVE.


	TIMAX = -1.D0


   10   READ(66,1,IOSTAT=IEND) READLINE
    1   FORMAT(A1000)

	IF(IEND .LT. 0) RETURN
	IF(READLINE(1:1) .EQ. '#' .OR. READLINE(1:2) .EQ. '"#') GO TO 10

	 CALL AFTERCOMMA(NCOVA,READLINE,2)
	 BACKSPACE(57)
	 READ(57,*) TIMEVENT
	 CLOSE(57)



	 CALL AFTERCOMMA(NCOVA,READLINE,3)
	 BACKSPACE(57)
	 READ(57,*,ERR=15) TIMDUR
	 GO TO 20	 	
   15    TIMDUR = 0.D0
   20    TIME = TIMEVENT + TIMDUR
	 CLOSE(57)

	 IF(TIMAX .LT. TIME) TIMAX = TIME
	 GO TO 10


	END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
	SUBROUTINE GETCHAR2(JSUB,CHARSUB)
	CHARACTER CHARSUB*3
	CHARACTER*1 B,C,D


C  THIS ROUTINE, CALLED BY READBLOCK2, INPUTS THE INTEGER JSUB
C  (BETWEEN 1 AND 999), AND OUTPUTS THE 3-CHARACTER EQUIVALENT, CHARSUB.

	ILEFT = JSUB
	I3 = ILEFT/100
	ILEFT = ILEFT - I3*100
	I2 = ILEFT/10
 	ILEFT = ILEFT - I2*10
	I1 = ILEFT

C  CONVERT THIS TO THE CHARACTER EQUIVALENT. 

	IF(I3 .EQ. 1) B='1'
	IF(I3 .EQ. 2) B='2'
	IF(I3 .EQ. 3) B='3'
	IF(I3 .EQ. 4) B='4'
	IF(I3 .EQ. 5) B='5'
	IF(I3 .EQ. 6) B='6'
	IF(I3 .EQ. 7) B='7'
	IF(I3 .EQ. 8) B='8'


	IF(I3 .EQ. 9) B='9'
	IF(I3 .EQ. 0) B='0'

	IF(I2 .EQ. 1) C='1'
	IF(I2 .EQ. 2) C='2'
	IF(I2 .EQ. 3) C='3'
	IF(I2 .EQ. 4) C='4'
	IF(I2 .EQ. 5) C='5'
	IF(I2 .EQ. 6) C='6'
	IF(I2 .EQ. 7) C='7'


	IF(I2 .EQ. 8) C='8'
	IF(I2 .EQ. 9) C='9'
	IF(I2 .EQ. 0) C='0'

	IF(I1 .EQ. 1) D='1'
	IF(I1 .EQ. 2) D='2'
	IF(I1 .EQ. 3) D='3'
	IF(I1 .EQ. 4) D='4'
	IF(I1 .EQ. 5) D='5'
	IF(I1 .EQ. 6) D='6'
	IF(I1 .EQ. 7) D='7'
	IF(I1 .EQ. 8) D='8'
	IF(I1 .EQ. 9) D='9'
	IF(I1 .EQ. 0) D='0'


	CHARSUB = B//C//D

	RETURN

	END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
	SUBROUTINE GETID(SUBID)
	CHARACTER SUBID*11,SUB*11

C  THIS ROUTINE IS CALLED TO REPLACE SUBID (WHICH HAS 11 CHARACTERS IN
C  IT) WITH THE CHARACTERS UP TO BUT NOT INCLUDING THE 1ST COMMA.


	SUB = '           '
	DO I = 1,11
	 IF(SUBID(I:I) .NE. ',') SUB(I:I) = SUBID(I:I)	 
	 IF(SUBID(I:I) .EQ. ',') GO TO 10
	END DO


   10   SUBID = SUB
		
	RETURN
	END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
	SUBROUTINE TIMESET(MAXSUB,ISUB,SUBID,NTIMALL,TIMALL,NTIMI,
     1    TIMI)

      IMPLICIT REAL*8(A-H,O-Z)
      DIMENSION TIMALL(MAXSUB,24000),NTIMALL(MAXSUB),TIMI(24000),
     1   TIM(24000)
	CHARACTER SUBID*11


C  THIS ROUTINE IS CALLED BY READBLOCK2, TO ORDER ALL THE NTIMALL(ISUB) 
C  TIMES IN TIMALL(ISUB,.), ELIMINATING DUPLICATE TIMES.

C  RETURNED TO READBLOCK2 IS THE VECTOR TIMI, WITH NTIMI TIMES, 
C  ESTABLISHED AS INDICATED ABOVE.


C  THE FIRST TIME IS TIMALL(ISUB,1) AND SHOULD BE 0. CHECK THIS FIRST.

	CALL THESAME(TIMALL(ISUB,1),0.D0,ISAME)

C  IF ISAME RETURNS FROM SUBROUTINE THESAME AS 1, THE TIMES ARE THE 
C  "SAME" (I.E., WITHIN 1.D-10). OTHERWISE, THE TIMES ARE NOT THE 
C  SAME AND ISAME = 0.


C  STARTING WITH MONT101F.FOR, DO NOT CHECK THAT THE FIRST DOSE TIME IN
C  EACH PATIENT IS 0, SINCE THE FIRST TIME MAY BE NEGATIVE (WHICH 

C  SIGNIFIES THE DOSAGE REGIMEN BEGINS WITH A STEADY STATE OF DOSES).


C	IF(ISAME .EQ. 0) THEN
C	 WRITE(*,1) ISUB,TIMALL(ISUB,1)
C    1    FORMAT(/' THE FIRST TIME IN THE DOSAGE BLOCK FOR SUBJECT ',I5,
C     1' IS NOT 0; IT IS ',G14.5//
C     2' THIS IS NOT ALLOWED. PLEASE SET THE FIRST TIME IN THE DOSAGE'/
C     3' BLOCKS FOR ALL SUBJECTS TO BE 0, AND RERUN THE PROGRAM.')
C	 WRITE(*,401) ISUB,SUBID
C  401    FORMAT(/' NOTE: THE ID FOR SUBJECT NO. ',I4,' IS ',A11/)
C	 CALL PAUSE
C	 STOP
C	ENDIF



C  CALL SUBROUTINE PUTORDER TO ORDER THE NTIMALL(ISUB) VALUES IN 
C  TIMALL(ISUB,.).

	DO I = 1,NTIMALL(ISUB)
	 TIM(I) = TIMALL(ISUB,I)
	END DO

	CALL PUTORDER(NTIMALL(ISUB),TIM)



C  THE NTIMALL(ISUB) VALUES ARE NOW ORDERED IN TIM.


C  THE CODE BELOW BELOW WILL REMOVE DUPLICATE TIMES.

	TIMELAST = -1.D39

	NTIMI = 0

	DO I = 1,NTIMALL(ISUB)

	 TIME = TIM(I)
	 CALL THESAME(TIME,TIMELAST,ISAME)

C  IF ISAME RETURNS FROM SUBROUTINE THESAME AS 1, TIME = TIMELAST (OR AT
C  LEAST, THEY ARE WITHIN 1.D-10), AND THIS TIME CAN BE IGNORED SINCE IT
C  WAS ALREADY PUT INTO TIMI (ACTUALLY THE VALUE REDUCED BY TIMERESET)
C  BY A PREVIOUS TIME.

	 IF(ISAME .EQ. 1) GO TO 30

C  TO GET HERE, ISAME = 0, WHICH MEANS THIS IS A NEW TIME. SO PUT
C  TIME INTO TIMI. THEN SET TIMELAST = TIME AND CONTINUE THE LOOP.


	  NTIMI = NTIMI + 1
	  TIMI(NTIMI) = TIME
	  TIMELAST = TIME


   30    CONTINUE


	END DO


	RETURN
	END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
	SUBROUTINE PUTORDER(NX,XX)

C  SUBROUTINE PUTORDER IS CALLED BY SUBROUTINE TIMESET. IT INPUTS XX, A
C  VECTOR OF SIZE, NX, AND RETURNS RETURNS XX, BUT WITH THE VALUES 
C  ORDERED FROM LOW TO HIGH.

      IMPLICIT REAL*8(A-H,O-Z)
      DIMENSION XX(24000),Y(24000),IZ(24000),IZZ(24000)

C  ORDER THE NX VALUES IN X AS FOLLOWS:

C  PUT THE NX VALUES INTO VECTOR Y TO START.
C  INITIALIZE VECTOR IZ TO BE -99 IN ALL ITS NX LOCATIONS. THEN, FOR
C  EXAMPLE, IF ENTRY 17 IS THE SMALLEST VALUE IN Y, IZ(17) WILL BE 
C  SET = 0, AND THE PROGRAM WILL KNOW NOT TO CHECK THE 17TH ENTRY 
C  AGAIN (SINCE IT HAS ALREADY BEEN SELECTED). IF THE NEXT SMALLEST 
C  ENTRY HAS INDEX 37, THEN IZ(37) WILL BE SET = 0, ETC. 

C  NOTE THAT IZZ WILL BE THE ARRAY WHICH CONTAINS THE ACTUAL ORDERING.
C  IN THE EXAMPLE ABOVE, IZZ(1) = 17, IZZ(2) = 37. IT WILL BE EASY TO 
C  ASSIGN ORDERED VALUES BACK INTO XX USING IZZ. IN THE EXAMPLE ABOVE, 
C  XX(1) = Y(IZZ(1)) = Y(17), XX(2) = Y(IZZ(2)) = Y(37), ETC.

	 DO I=1,NX
	  Y(I) = XX(I)

	  IZ(I) = -99
	 END DO


	 DO IPLACE = 1,NX

C  PUT THE NEXT LOWEST VALUE OF Y INTO THE IPLACE LOCATION OF
C  IZZ.

C  TEMP IS THE RUNNING VALUE OF THE NEXT VALUE TO BE PLACED INTO Y.
C  INITIALIZE IT TO BE VERY HIGH VALUE SO THE FIRST VALUE Y WILL BE 

C  SURE TO BE LOWER THAN IT IS.

	  TEMP = 1.D50

	  DO I=1,NX

	   IF(Y(I) .LT. TEMP .AND. IZ(I) .EQ. -99) THEN
	    TEMP = Y(I)

	    IND = I
	   ENDIF
	  END DO

C  AT THIS POINT, IND IS THE INDEX OF THE SMALLEST REMAINING VALUE
C  (TEMP) IN Y. PUT THIS INFORMATION INTO IZZ. ALSO,

C  SET IZ(IND) = 0 --> THE IND LOCATION IN Y HAS BEEN USED.

	  IZZ(IPLACE) = IND
	  IZ(IND) = 0

	 END DO	

C  AT THIS POINT IZZ CONTAINS THE ORDERED INDICES (LOW TO HIGH) OF Y.
C  USE THIS TO RE-ESTABLISH X TO BE ORDERED LOW TO HIGH.
	
	 DO I = 1,NX

	  XX(I) = Y(IZZ(I))
	 END DO

	
	RETURN
	END

C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
	SUBROUTINE FIXOUTIM(MAXSUB,ISUB,SUBID,NOUT,NTIMOUT,TIMOUT,OUT,
     1   NTIMORD,TIMORD,BLOCKOUT,TIMADD)

	IMPLICIT REAL*8(A-H,O-Z)

	PARAMETER(MAXNUMEQ=7)

      DIMENSION TIMOUT(MAXSUB,MAXNUMEQ,650),NTIMOUT(MAXSUB,MAXNUMEQ),
     1 IENTRY(MAXNUMEQ),OUT(MAXSUB,MAXNUMEQ,650),TIMORD(3900),
     2 BLOCKOUT(3900,MAXNUMEQ)

	CHARACTER SUBID*11,ERRFIL*20

      COMMON/ERROR/ERRFIL
C  COMMON/ERROR/ IS SUPPLIED TO ALL THE ROUTINES WHICH COULD WRITE TO
C  ERRFIL.

C  FIXOUTIM IS CALLED BY WRITEDOS TO ORDER THE OUTPUT TIMES AMONG ALL 
C  THE NOUT OUTPUT EQUATIONS. NOTE THAT EACH OF THE TIMES CURRENTLY IN
C  TIMOUT HAS BEEN INCREASE BY TIMERESET = TIMADD*NRESET, WHERE NRESET
C  IS THE NO. OF TIME RESETS UP TO AND INCLUDING THAT TIME (THIS WAS 
C  DONE IN SUBROUTINE READBLOCK2).


C  RETURNED TO SUBROUTINE WRITEDOS ARE:

C  NTIMORD = NO. OF TIME VALUES IN TIMORD.

C  TIMORD(I), I=1,NTIMORD = THE ORDERED SET OF TIMES (EXCEPT FOR 0'S
C   WHICH INDICATE A TIME RESET) OVER ALL THE NOUT TIME ARRAYS.


C  BLOCKOUT(I,J) = OBSERVED VALUE FOR IOUTPUT EQUATION J, FOR THE TIME
C   VALUE, TIMORD(I), I=1,NEXT; J = I,NOUT.


C  NOTE THAT EACH OF THE TIME ARRAYS, TIMOUT(ISUB,IOUT,.) HAS ITS OWN
C  VALUES IN ORDER (THEY WERE FILLED IN ORDER IN READBLOCK2). NOW, 
C  ESTABLISH THE ARRAY, TIMORD, WHICH HAS THE ORDERED SET OF
C  TIMES OVER ALL THE NOUT TIME ARRAYS. ALSO, REDUCE EACH TIME BY 
C  TIMRESET = NRESET*TIMADD TO RETURN EACH TIME TO ITS ORIGINAL VALUE. 
C  NOTE THAT THIS WILL HAVE THE EFFECT OF SETTING TO 0 THE TIMES WHICH 
C  ARE THE TIME RESET POINTS (THEIR ACCOMPANYING OUTPUT VALUES WILL
C  OF COURSE BE SET TO -99).

C  INITIALIZE THE NEXT TIME TO BE PUT INTO TIMORD TO BE A LARGE NO.
C  AND INITIALIZE THE INDEX OF THE NEXT ENTRY IN EACH OF THE TIMOUT
C  ARRAYS TO BE 1. ALSO INITIALIZE INEXT TO BE 1. IT WILL BE THE 
C  RUNNING INDEX OF THE NEXT ENTRY TO BE PUT INTO TIMORD.



	DO IOUT = 1,NOUT

	 IENTRY(IOUT) = 1
	END DO

	INEXT = 1

   20	TIMENEXT = 1.D50

C  SET IANOTHER = 0. IF IT STAYS 0, THERE ARE NO MORE TIMES IN
C  ANY OF THE ARRAYS.

	 IANOTHER = 0


        DO IOUT	= 1,NOUT

C  FOR OUTPUT EQUATION IOUT, IF IENTRY(IOUT) .LE. THE NO. OF ENTRIES
C  IN THE TIME ARRAY FOR IOUT, THEN THIS ENTRY IS EQUATION IOUT'S
C  CANDIDATE FOR THE NEXT LOWEST TIME.

	 IF(IENTRY(IOUT) .LE. NTIMOUT(ISUB,IOUT)) THEN
	  IANOTHER = 1
	  IF(TIMOUT(ISUB,IOUT,IENTRY(IOUT)) .LE. TIMENEXT) 
     1     TIMENEXT = TIMOUT(ISUB,IOUT,IENTRY(IOUT))
	 ENDIF

	END DO

C  IF IANOTHER = 0, ALL TIME ARRAY, AND CORRESPONDING OBSERVED, VALUES 
C  HAVE BEEN STORED, SO GO TO 100 TO RECAST TIMORD BEFORE RETURNING.

	IF(IANOTHER .EQ. 0) GO TO 100


C  AT THIS POINT, TIMENEXT IS THE NEXT LOWEST TIME OVER ALL THE NOUT
C  TIMOUT ARRAYS. PUT IT INTO TIMORD, AND PUT THE CORRESPONDING ENTRIES
C  FOR EACH OF THE NOUT OUTPUT EQUATIONS INTO THE ARRAY BLOCKOUT. ALSO,
C  INCREASE THE ENTRY NO. FOR THE TIME ARRAY(S) WHICH HAD THIS TIME. 
C  BUT CHECK THAT THE NO. OF ENTRIES INTO TIMORD IS NOT > THE MAX, 3900. 
C  IF IT IS, STOP.


	IF(INEXT .GT. 3900) THEN



	 WRITE(*,1)
    1    FORMAT(/' THE TOTAL NO. OF OBSERVATION TIMES IS GREATER THAN'/
     1' THE MAXIMUM ALLOWABLE VALUE OF 3900 (SUBROUTINE FIXOUTIM).'/
     2' RERUN THE PROGRAM AFTER REDUCING THE NO. OF OBS. TIMES.'/)
	 WRITE(*,401) ISUB,SUBID
  401    FORMAT(/' NOTE: THE ID FOR SUBJECT NO. ',I4,' IS ',A11/)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,1) 
         WRITE(42,401) ISUB,SUBID
        CLOSE(42)
	


	 CALL PAUSE
	 STOP



	ENDIF

	TIMORD(INEXT) = TIMENEXT


        DO IOUT	= 1,NOUT

	  BLOCKOUT(INEXT,IOUT) = -99.D0
	  CALL THESAME(TIMENEXT,TIMOUT(ISUB,IOUT,IENTRY(IOUT)),ISAME)

	  IF(ISAME .EQ. 1) THEN
	   BLOCKOUT(INEXT,IOUT) = OUT(ISUB,IOUT,IENTRY(IOUT))
	   IENTRY(IOUT) = IENTRY(IOUT) + 1
	  ENDIF

	END DO


	INEXT = INEXT + 1	

	GO TO 20
 

  100   NTIMORD = INEXT - 1


C  NOW, RECAST TIMORD TO BE THE CORRECT TIME VALUES. RECALL THAT,
C  CURRENTLY, EACH TIME HAS NRESET*TIMADD ADDED TO ITS VALUE WHERE 
C  NRESET IS THE NO. OF TIME RESET 0'S UP TO AND INCLUDING THAT TIME 
C  VALUE.

C  INITIALIZE NRESET = 0. THIS IS THE RUNNING NUMBER OF TIME RESETS 
C  THAT HAVE OCCURED. ALSO INITIALIZE TIMERESET AS THE CURRENT AMOUNT 
C  OF TIME TO SUBTRACT TO DO THE RECASTING.

	NRESET = 0

	TIMERESET = TIMADD*NRESET

	DO I = 1,NTIMORD
	 CALL THESAME(TIMORD(I),TIMADD*(NRESET+1),ISAME)	 	
	 


	 IF(ISAME .EQ. 1) THEN
	  NRESET = NRESET + 1
	  TIMERESET = TIMADD*NRESET
	 ENDIF

	 TIMORD(I) = TIMORD(I) - TIMERESET
	END DO


	RETURN


      END

C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
      SUBROUTINE VERIFYVAL(N,X)
      IMPLICIT REAL*8(A-H,O-Z)
      DIMENSION X(200)

C  THIS ROUTINE INPUTS X(I),I=1,N.

C  ON OUTPUT, EACH X(.) WHICH IS INSIDE [-1.D-99, 1.D-99] IS REPLACED
C  BY 0. THIS PREVENTS THIS VALUE FROM BEING WRITTEN OUT IMPROPERLY,
C  E.G., AS .934-106, RATHER THAN .934E-106.
C  ANY X(.) VALUE NOT INSIDE THE ABOVE RANGE WILL BE UNCHANGED ON
C  OUTPUT.

      DO I = 1,N
       IF(X(I) .GE. -1.D-99 .AND. X(I) .LE. 1.D-99) X(I) = 0.D0
      END DO

      RETURN
      END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
	SUBROUTINE THESAME(X1,X2,ISAME)
	IMPLICIT REAL*8(A-H,O-Z)


C  THIS ROUTINE CHECKS TO SEE IF X1 AND X2 ARE VIRTUALLY THE SAME 
C  VALUES (I.E., IF THEY ARE WITHIN 1.D-10 OF EACH OTHER). IF SO,
C  ISAME RETURNS AS 1; IF NOT ISAME RETURNS AS 0.

	ISAME = 0
	XDEL = DABS(X1-X2)
	IF(XDEL .LE. 1.D-10) ISAME = 1
	
	RETURN
	END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
      SUBROUTINE GETCOM(NCOMMA,READLINE,I5,I7)

      CHARACTER READLINE*1000,ERRFIL*20

      COMMON/ERROR/ERRFIL
C  COMMON/ERROR/ IS SUPPLIED TO ALL THE ROUTINES WHICH COULD WRITE TO
C  ERRFIL.

C  GETCOM IS CALLED BY CVSCHANGE TO FIND THE ENTRY NO. FOR COMMA NO. 5
C (I5), AND THE ENTRY FOR COMMA NO. 7 (I7).

    1 FORMAT(A1000)
 
      ICOMMA = 0

      DO I = 1,300
       IF(READLINE(I:I) .EQ. ',') THEN
        ICOMMA = ICOMMA + 1


         IF(ICOMMA .EQ. 5) I5 = I


          IF(ICOMMA .EQ. 7) THEN
           I7 = I
           RETURN
          ENDIF
       ENDIF
      END DO

C  TO GET TO THIS POINT MEANS THAT READLINE DOESN'T HAVE 7 COMMAS IN
C  IT. REPORT THIS ERROR TO THE USER AND STOP.

      WRITE(*,2) NCOMMA,READLINE(1:70)

    2 FORMAT(/' ONE OF THE LINES IN YOUR .cvs FILE HAS AN ERROR.'/
     1' IT IS SUPPOSED TO HAVE ',I2,' COMMAS, BUT IT HAS FEWER THAN'/
     2' 7. THE FOLLOWING LINE SHOWS THE 1ST 70 CHARACTERS OF THE LINE:'/
     3' ',A70//
     4' THE PROGRAM STOPS.'/)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,2) NCOMMA,READLINE(1:70)
        CLOSE(42)
	


      CALL PAUSE
      STOP
    
      END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
      SUBROUTINE ORDERHOLD(HOLDMAT,NFIRST,NLAST,IDENTRY,TIMENTRY)

      IMPLICIT REAL*8(A-H,O-Z)

      DIMENSION TIMENTRY(99999),IDENTRY(99999),IZ(99999),IZZ(99999),
     1 DOSTIME(99999)
      CHARACTER HOLDMAT(99999)*150,HOLDMAT2(99999)*150

C  ORDER THE ENTRIES IN HOLDMAT FROM NFIRST TO NLAST, AS FOLLOWS:


C  1. PUT ALL THE DOSE EVENTS (IDENTRY(.) = 1 OR 4) FIRST, ORDERED BY
C  INCREASING TIMENTRY(.).

C  2. PUT ALL THE OBSERVATION EVENTS (IDENTRY(.) = 0) AFTER THE DOSE
C  EVENTS (THEY SHOULD ALREADY BE ORDERED).


C  FIRST, STORE THE DOSE ROWS FROM NFIRST TO NLAST IN HOLDMAT TO 
C  HOLDMAT2, STARTING AT ROW 1 IN HOLDMAT2.

C  ALSO, PUT ALL THE DOSE EVENTS TIMES INTO DOSTIME, AND INITIALIZE

C  VECTOR IZ TO BE -99 IN ALL ITS NDOSE LOCATIONS

      NDOSE = 0

      DO I = NFIRST,NLAST
       IF(IDENTRY(I) .EQ. 1 .OR. IDENTRY(I) .EQ. 4) THEN
        NDOSE = NDOSE + 1
        HOLDMAT2(NDOSE) = HOLDMAT(I)
        DOSTIME(NDOSE) = TIMENTRY(I)
        IZ(NDOSE) = -99
       ENDIF
      END DO

C  NOW, FOR EXAMPLE, IF ENTRY 17 IS THE SMALLEST VALUE IN DOSTIME,
C  IZ(17) WILL BE SET = 0, AND THE PROGRAM WILL KNOW NOT TO CHECK THE
C  17TH ENTRY AGAIN (SINCE IT HAS ALREADY BEEN SELECTED). IF THE NEXT
C  SMALLEST ENTRY HAS INDEX 37, THEN IZ(37) WILL BE SET = 0, ETC.

C  NOTE THAT IZZ WILL BE THE ARRAY WHICH CONTAINS THE ACTUAL ORDERING.
C  IN THE EXAMPLE ABOVE, IZZ(1) = 17, IZZ(2) = 37. IT WILL BE EASY TO
C  ASSIGN ORDERED VALUES BACK INTO HOLDMAT USING IZZ. IN THE EXAMPLE
C  ABOVE, HOLDMAT(1) WILL HAVE DOSE TIME = DOSTIME(IZZ(1)) =
C  DOSTIME(17); HOLDMAT(2) WILL HAVE DOSE TIME = DOSTIME(IZZ(2)) =
C  DOSTIME(37); ETC.


C  NOW PUT THE OBSERVATION ROWS FROM NFIRST TO NLAST IN HOLDMAT TO
C  HOLDMAT2, STARTING AT ROW NDOSE + 1 IN HOLDMAT2.

      NEXT = NDOSE

      DO I = NFIRST,NLAST
       IF(IDENTRY(I) .EQ. 0) THEN
        NEXT = NEXT + 1
        HOLDMAT2(NEXT) = HOLDMAT(I)
       ENDIF
      END DO


C  NOW ORDER THE FIRST NDOSE ROWS IN HOLDMAT2 ACCORDING TO THE DOSE
C  TIMES, LOW TO HIGH.

	 DO IPLACE = 1,NDOSE

C  PUT THE NEXT LOWEST VALUE OF DOSTIME INTO THE IPLACE LOCATION OF
C  IZZ.

C  TEMP IS THE RUNNING VALUE OF THE NEXT VALUE TO BE PLACED INTO 
C  DOSTIME. INITIALIZE IT TO BE VERY HIGH VALUE SO THE FIRST VALUE 

C  OF DOSTIME WILL BE SURE TO BE LOWER THAN IT IS.

	  TEMP = 1.D50


	  DO I=1,NDOSE
	   IF(DOSTIME(I) .LT. TEMP .AND. IZ(I) .EQ. -99) THEN
	    TEMP = DOSTIME(I)
	    IND = I
	   ENDIF
	  END DO

C  AT THIS POINT, IND IS THE INDEX OF THE SMALLEST REMAINING VALUE
C  (TEMP) IN DOSTIME. PUT THIS INFORMATION INTO IZZ. ALSO, SET
C  IZ(IND) = 0 --> THE IND LOCATION IN DOSTIME HAS BEEN USED.

	  IZZ(IPLACE) = IND
	  IZ(IND) = 0

	 END DO


C  AT THIS POINT IZZ CONTAINS THE ORDERED INDICES (LOW TO HIGH) OF THE
C  NDOSE VALUES IN DOSTIME, AND SO GIVES THE ORDER THAT THE NDOSE ROWS
C  NOW IN HOLDMAT2 SHOULD BE WRITTEN.

C  WRITE THESE NDOSE DOSE ROWS IN THE CORRECT ORDER INTO HOLDMAT, AND
C  THEN WRITE THE REMAINING ROWS (OBSERVATION ROWS) INTO HOLDMAT. 

      DO IDOSE = 1,NDOSE
       HOLDMAT(NFIRST-1+IDOSE) = HOLDMAT2(IZZ(IDOSE))
      END DO

C  STORE THE OBSERVATION ROWS INTO ENTRIES NFIRST + NDOSE,..., NLAST OF
C  HOLDMAT. THEY WERE STORED INTO THE LAST NOBS ROWS OF HOLDMAT2 ABOVE. 

      NEXT = NDOSE

      DO IOBS = NFIRST + NDOSE,NLAST
       NEXT = NEXT + 1
       HOLDMAT(IOBS) = HOLDMAT2(NEXT)
      END DO
     
       
      RETURN
      END


