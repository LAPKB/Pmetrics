C  MONT114.FOR                                             3/25/16

C  MONT114 HAS THE FOLLOWING CHANGES FROM MONT113:

C  1. SUBROUTINE GETNUMEQ IS MADE MORE EFFICIENT. THE CODE THERE TO READ
C  NUMEQT WAS A VERSION OF OTHER CODE WHICH NEEDED TO READ MORE VALUES
C  IN THE PATIENT'S DATA FILE IN ADDITION TO JUST NUMEQT. NOW THE 
C  UNNEEDED CODE IS REMOVED. THIS ALSO REMOVES A SUBTLE POTENTIAL "BUG" 
C  BECAUSE ARRAY XX() IS NO LONGER ESTABLISHED (WHICH IS GOOD SINCE 
C  XX(14) COULD HAVE BEEN ASKED TO STORE AS MANY AS 34 VALUES FOR 
C  PATIENT DATA FILES WITH LOTS OF COVARIATES AND/OR DRUGS).

C  2. SUBROUTINE INOUT IS CHANGED SO THAT THE PATIENT NAME OF EACH
C  SUBJECT HAS THE SUBJECT NO. IN IT. PREVIOUSLY, ALL SIMULATED
C  SUBJECTS HAD THE SAME NAME, "WhoopteeDo Yowza". THIS CAUSES A 
C  PROBLEM IF A WORKTOCSV PROGRAM MAKES A .CSV FILE FROM THESE 
C  SIMULATED SUBJECTS, SINCE THEN THE .CSV FILE LOOKS LIKE IT
C  CONSISTS OF JUST 1 SUBJECT. THIS HAPPENED WHEN QMZJPZQX.CSV WAS MADE
C  BY IT2B114.FOR BY SUBROUTINE WORKTOCSV AND ALL THE PATIENT NAMES WERE
C  THE SAME, "WhoopteeDo Yowza"... AND THEN THIS FILE WAS PUT INTO
C  FROMxxxx, WHICH WAS NOT READ PROPERLY BY NPAG120.FOR BECAUSE IT
C  LOOKED AS IF IT CONSISTED OF JUST 1 PATIENT).

C-----------------------------------------------------------------------

C  MONT113.FOR                                             12/16/15

C  MONT113 HAS THE FOLLOWING CHANGES FROM MONT112:

C  1. THIS PROGRAM IS NOW COMPATIBLE WITH THE NEW VERSION 43 OUTPUT FILE
C  MADE BY THE NEW NPAG PROGRAM (NPAG119.FOR/npagranfix5.f), WHICH HAS
C  NRANFIX PARAMETERS.

C  2. XVERIFY IS DIMENSIONED 900 INSTEAD OF 200 (IN 10 ROUTINES). 
C  ACTUALLY, IT ONLY NEEDS TO BE DIMENSIONED THE LARGEST DIMENSION OF 
C  ANY ARRAY IT STORES, WHICH IS 594. THIS BUG WAS NOT DISCOVERED 
C  UNTIL THIS PROGRAM WAS RUN WITH A TEMPLATE PATIENT FILE WHICH HAD
C  311 OBSERVED VALUES. 

C-----------------------------------------------------------------------

C  MONT112.FOR                                             4/27/15

C  MONT112 HAS THE FOLLOWING CHANGES FROM MONT111:

C  1. ALL NUMBERS WRITTEN OUT IN F OR G FORMAT ARE NOT TESTED TO SEE IF
C  THEY ARE INSIDE [-1.D-99, 1.D-99]. IF SO, THEY ARE CHANGED TO BE 0.
C  THE REASON IS THAT OTHERWISE THEY WILL BE PRINTED OUT WITHOUT THE
C  ACCOMPANYING D OR E (E.G., AS .934-106, RATHER THAN .934E=106).

C  NOTE THAT A NEW SUBROUTINE VERIFYVAL IS ADDED TO THE CODE TO DO THE
C  INDICATED TESTING ABOVE.

C  2. A SLIGHT BUG IS CORRECTED IN FORMAT 5001. "TSTMULTI.FOR" IS 
C  CHANGED TO BE "TSTMULTM.FOR". NOTE THAT THIS PROGRAM IS NOT LINKED 
C  WITH TSTMULTN.FOR SINCE IT WON'T BE RUN IN PARALLEL. 

C  3. BELOW FORMAT 38 IN MAIN, ERR=145 IS ADDED, SO THE PROGRAM WILL
C  REPEAT THE WRITING OF FORMAT 38 IF THE USER ENTERS A NON-NUMBER.
C  THIS IS AN IMPROVEMENT OVER BOMBING, WHICH WOULD OCCUR OTHERWISE.

C-----------------------------------------------------------------------

C  MONT111.FOR                                             9/14/14

C  MONT111 HAS A BUG FIX TO MONT110. PREVIOUSLY, IN SUBROUTINE 
C  COVSTRING, THE PARAMETER ILAST WAS NOT ESTABLISHED IF NCOVA = 1. THE
C  RESULT WAS THAT IT WOULD REMAIN SET TO A RANDOM NUMBER IN THIS CASE.
C  AND CAUSED THE PROGRAM TO RETURN A RANDOM VALUE FOR THE PARAMETER
C  NCOVTIGHT TO SUBROUTINE WORKTOCSV, WHICH THEN WOULD STORE SPURIOUS
C  CHARACTERS TO TOPLINE. THIS DID NOT AFFECT THIS PROGRAM, BUT COULD
C  CAUSE THE IT2B OR NPAG PROGRAM WHICH READS THE RESULTANT .CSV FILE
C  TO READ JUNK CHARACTERS AND BOMB.

C  THE FIX IS TO SET ILAST = 1 IF NCOVA = 1 IN SUBROUTINE COVSTRING.

C-----------------------------------------------------------------------

C  MONT110.FOR                                             8/28/14

C  MONT110 HAS THE FOLLOWING CHANGES FROM MONT109:

C  1. SUBROUTINE NEWWORK1 IS MODIFIED SO THAT A STEADY STATE REGIMEN 
C  NOW TRANSLATES TO 101 DOSE SETS, RATHER THAN 100. THE EFFECT IS 
C  THAT IF, FOR EXAMPLE, A PATIENT HAS AN OBSERVATION AT TIME T = 2 HRS.
C  AFTER A STEADY STATE REGIMEN WITH AN INTER-DOSE INTERVAL (II) OF
C  24 HOURS, THIS OBSERVATION WILL NOW BE 2 HOURS AFTER THE BEGINNING OF
C  THE LAST (THE 101ST) DOSE SET, AS OPPOSED TO 26 HOURS (AFTER THE 
C  100TH DOSE SET IN THE PREVIOUS PROGRAM).

C  ALSO NOTE THAT AN EXTRA CHECK IS PUT INTO SUBROUTINE NEWWORK1 TO
C  MAKE SURE THAT NO TWO DOSE TIMES ARE THE SAME. THIS COULD HAPPEN,
C  FOR EXAMPLE, IF THE 101ST DOSE SET OF A STEADY STATE DOSE REGIMEN
C  HAD AN ENDING IV TIME OF 3 HOURS, AND THE FIRST NON-STEADY-STATE
C  IV DOSE FOLLOWING STARTED AT T = 3 HOURS. HAVING TWO DOSE TIMES WHICH
C  ARE THE SAME CAN CONFUSE THE LOGIC IN SUBROUTINE SHIFT, AND CAUSE
C  IT TO GET INTO AN INFINITE LOOP (see NPAG115.EXP, TESTCASE 5).

C  2. AN BUG IS FIXED IN SUBROUTINE READBLOCK2. FORMAT 106 IS CORRECTED
C  TO HAVE NOUT WRITTEN, INSTEAD OF NOU.

C  3. A BUG IS FIXED IN SUBROUTINE FUNC2. THE CLOSE(42) LINE IS MOVED
C  BELOW THE DO I = 1,ND LOOP (SINCE FILE 42 IS STILL BEING ACCESSED
C  IN THAT LOOP).

C  4. A SUBTLE BUG IS FIXED IN SUBROUTINE WRITECSV. IT OCCURRED WHEN A
C  STEADY STATE DOSE SET FOLLOWED A DOSE WITH AN IV WHICH WAS NOT
C  TURNED OFF. SEE NPAG115.EXT FOR DETAILS ON THE TESTCASE WHICH
C  REVEALED THE BUG. 

C  NOTE THAT TEST109.FOR IS THE VERSION OF MONT109.FOR WITH THE CODE
C  CORRECTED IN SUBROUTINE WRITECSV.

C  5. FORMATS 919 AND 5001 HAVE BEEN CHANGED TO REFLECT THAT THE
C  TEMPLATE MODEL FILE IS NOW TSTMULTM.FOR, RATHER THAN TSTMULTI.FOR.

C-----------------------------------------------------------------------

C  MONT109.FOR                                             6/4/14

C  MONT109 HAS THE FOLLOWING CHANGES TO MONT108:

C  1. THE SAME CHANGE THAT WAS MADE PREVIOUSLY SO THAT ANY PREDICTED
C  VALUE LESS THAN 1.D-8 WAS CHANGED TO BE 1.D-8 (SEE CHANGE NO. 5.
C  IN MONT100.FOR) IS NOW MADE ALSO FOR THE COMPARTMENT AMOUNTS. THE
C  REASON IS THE SAME AS BEFORE. ONE EXAMPLE I SAW SHOWED A COMPARTMENT
C  AMOUNT OF 0.8628658D-138 WRITTEN TO THE OUTPUT FILE AS 0.8628658-138.

C  2. A NEW FILE, "ERRORLOG" WILL BE WRITTEN IF THIS PROGRAM STOPS
C  WITHOUT COMPLETING. ESSENTIALLY AT EVERY PLACE THE PROGRAM HAS A
C  CALL PAUSE COMMAND BEFORE STOPPING, WHATEVER COMMENT IS WRITTEN TO
C  THE SCREEN WILL ALSO BE PLACED INTO "ERRORLOG". NOTE THAT
C  "ERRORLOG" IS PASSED TO SUBROUTINES VIA COMMON/ERROR/ERRFIL,
C  WHERE ERRFIL IS SET = 'ERRORLOG'.

C  3. THE MAXIMUM NO. OF OUTPUT EQUATIONS WILL BE CHANGED FROM 6 TO 7,
C  AND TO FACILITATE ANY FUTURE SUCH CHANGES, THIS NUMBER WILL BE SET
C  = MAXNUMEQ (SO ONLY THE PARAMETER STATEMENT WILL HAVE TO BE CHANGED
C  IN THE FUTURE). RATHER THAN PASS MAXNUMEQ TO ALL THE RELEVANT 
C  SUBROUTINES (AS IS DONE IN NPAG113.FOR AND IT2B110.FOR), THIS 
C  PROGRAM WILL JUST HAVE MAXNUMEQ SET IN A PARAMETER STATEMENT IN ALL
C  THESE ROUTINES. AND NOTE THAT IN THOSE SUBROUTINES, ANY 6
C  REFERRING TO THE MAX. NO. OF OUTPUT EQUATIONS WILL BE CHANGED TO
C  MAXNUMEQ.

C-----------------------------------------------------------------------

C  MONT108.FOR                                             1/29/14

C  1. MONT108 HAS A CHANGE FROM MONT107, RELATED TO CHANGE NO. 1 IN 
C  MONT107. IN THE 3RD WAY THE USER HAS TO ENTER PARAMETER 
C  DISTRIBUTIONS, VIA THE RESULTS OF AN NPAG RUN, THERE WILL NOW BE
C  3 OPTIONS RATHER THAN JUST 1 (ENTERING THE NAME OF THE NPAG OUTPUT
C  FILE). THE OTHER TWO OPTIONS WILL BE: ENTERING THE GRID PTS. 
C  MANUALLY; AND ENTERING THE GRID PTS. VIA A SIMPLE TEXT FILE.
C  THE CHANGES WILL BE MOSTLY IN SUBROUTINES GETDIST AND READNPAG.

C  2. THERE IS A CORRECTION IN SUBROUTINE READNPAG. PREVIOUSLY, AN NPAG
C  OUTPUT FILE HAD TO HAVE A VERSION BETWEEN 36 AND 40 TO BE ACCEPTABLE.
C  BUT, THIS HAS BEEN CORRECTED TO BE A VERSION BETWEEN 36 AND 42.

C-----------------------------------------------------------------------

C  MONT107.FOR                                             1/17/14

C  MONT107 HAS THE FOLLOWING CHANGES TO MONT106:

C  1. IN MONT106, THE USER HAD TWO WAYS TO ENTER THE PARAMETER
C  DISTRIBUTIONS: WITH A SPECIFIED MIXTURE OF NORMAL OR LOGNORMAL
C  DISTRIBUTIONS; OR USING THE FINAL CYCLE DENSITY GRID PTS. FROM AN
C  NPAG RUN (WITH EACH COVARIANCE BEING THE FINAL CYCLE COVARIANCE 
C  DIVIDED THE NO. OF ACTIVE GRID PTS). NOW, THERE WILL BE A THIRD WAY:
C  THIS WILL ALSO USE THE FINAL CYCLE DENSITY FROM AN NPAG RUN, BUT 
C  IN THIS CASE, EACH GRID PT. IN THAT DENSITY WILL BE THE PARAMETER 
C  SET OF A SIMULATED SUBJECT. 

C  THE MAIN DIFFERENCE FOR THIS THIRD WAY VS. THE SECOND WAY IS 
C  SHOWN IN THE FOLLOWING EXAMPLE. SUPPOSE THERE ARE 5 GRID PTS. IN THE 
C  FINAL CYCLE DENSITY FROM A PREVIOUS NPAG RUN, AND THERE ARE NOW 100 
C  SUBJECTS TO BE SIMULATED. IN THE 2ND WAY, FOR EACH SUBJECT, ONE OF
C  THE 5 GRID PTS. WOULD BE SELECTED AT RANDOM (THE HIGHER A PROB. 
C  ASSOCIATED WITH A GRID PT., THE MORE LIKELY THAT GRID PT. WOULD BE
C  TO BE SELECTED). BUT IN THIS 3RD WAY, THE NO. OF GRID PTS. IN THE
C  FINAL CYCLE DENSITY IS AUTOMATICALLY THE NO. OF SUBJECTS TO BE
C  SIMULATED, AND EACH SIMULATED SUBJECT HAS EXACTLY THE PARAMETER SET
C  OF ONE OF THE 5 GRID PTS (I.E., THE COVARIANCES FOR EACH DISTRIBUTION
C  WILL BE ALL 0'S).

C  NOTE THAT FOR BOTH THE 2ND AND 3RD WAYS, THE USER WILL ENTER A
C  COMBINED OUTPUT FILE (OUTxxxx) FROM AN NPAG RUN. BUT IN THE 3RD 
C  WAY, THE FINAL CYCLE COVARIANCE MATRIX FROM THE OUTPUT FILE WILL
C  NOT BE NEEDED, JUST THE FINAL CYCLE DENSITY.

C  NOTE THAT THE MAXIMUM NO. OF DISTRIBUTIONS HAS BEEN RAISED FROM
C  30 TO 150. THIS OF COURSE IS ALSO THE MAXIMUM NO. OF GRID PTS.
C  WHICH CAN BE READ IN FROM THE FINAL CYCLE DENSITY OF A PREVIOUS
C  NPAG RUN FOR THE THIRD WAY ABOVE (I.E., EACH GRID PT. IS EQUIVALENT
C  TO A DISTRIBUTION (WITH 0 COVARIANCES) IN THIS CASE).
 

C  2. OPEN(57) IS REPLACED BY OPEN(57,STATUS='SCRATCH') IN 3 LOCATIONS.
C  THE REASON IS THE SAME AS FOR CHANGE 5. IN NPAG111.FOR (WITHOUT
C  A 'SCRATCH' SPECIFIER WHEN OPENING SCRATCH FILES, SOMETIMES THE
C  PROGRAM OBJECTS WITH A " ... CANNOT WRITE TO FILE OPENED FOR READ"
C  ERROR.

C  3. IN 3 FORMATS, F10.5 IS REPLACED BY G10.3. OTHERWISE ANY VALUES
C  GREATER THAN 9999 ARE PRINTED AS *'S. (REF: \ALAN3\ANDERS\SIM.EXP).

C-----------------------------------------------------------------------


C  MONT106.FOR                                             10/02/12

C  MONT106 HAS THE FOLLOWING CHANGES TO MONT105.FOR:

C  1. IN SUBROUTINE FUNC2, BEFORE THE FIRST CALL TO GETFA, THE R(.) ARE
C  SET = RSN(.,.) IN CASE ANY OF THE FA(.) ARE FUNCTIONS OF THE 
C  COVARIATES WHICH ARE ESTABLISHED FROM THE R(.) VALUES IN  GETFA. IN
C  ADDITION, PRIOR TO THE 2 SECTIONS WHERE THE FA(.) ARE USED, GETFA IS
C  CALLED SO THAT THE FA(.) ARE UPDATED TO CURRENT VALUES, BASED ON THE
C  MOST RECENT COVARIATE VALUES IN THE PATIENT'S DATA FILE. IN PREVIOUS
C  PROGRAMS, IT WAS SIMPLY ASSUMED THAT THE FA(.) WERE FUNCTIONS OF THE
C  PARAMETERS, BUT NOT THE COVARIATES, AND SO THIS WASN'T NECESSARY. 
C  BUT THE CODE IN TSTMULTI.FOR (AND NOW TSTMULTK.FOR) IMPLIES THAT THE
C  FA(.) COULD BE FUNCTIONS OF THE COVARIATES, AND SO THIS CHANGE IS 
C  NECESSARY.

C  NOTE THAT SETTING THE R(.) TO RSN(.,.) BEFORE THE FIRST CALL TO
C  GETFA ALSO MEANS THE R(.) WILL BE SET BEFORE GETIX AND GETTLAG ARE
C  FIRST CALLED, WHICH AGAIN IS REQUIRED IN CASE THEY ESTABLISH VALUES
C  AS FUNCTIONS OF THE COVARIATES IN THE PATIENT DATA FILE.

C  ALSO, THE R(.) ARE ALSO RESET = RSN(.,.) BEFORE GETIX IS CALLED
C  IN THE TIME RESET SECTION OF SUBROUTINE FUNC2. NOT DOING THIS WOULD
C  MEAN THAT IF THE INITIAL CONDITIONS FOR THE X(.) ARE FUNCTIONS OF 
C  THE COVARIATES (ESTABLISHED IN GETIX FROM THE R(.) VALUES), THEY
C  WOULD BE ASSIGNED VALUES BASED ON COVARIATES FROM A PREVIOUS
C  DOSAGE LINE IN THE PATIENT'S DATA FILE, RATHER THAN THE LINE
C  WHICH IS THE DOSE RESET LINE.

C  2. SUBROUTINE SHIFT HAS NEW CHANGES, BASED ON shift9.f (UPDATED FROM
C  shift8.f). THE CHANGE IS SUBTLE - SEE CODE IN shift9.f AND
C  SUBROUTINE SHIFT.

C-----------------------------------------------------------------------


C  MONT105.FOR                                             9/13/12

C  MONT105 HAS THE FOLLOWING CHANGES FROM MONT104:

C  1. CHANGES ARE MADE IN STEP 4 OF SUBROUTINE SHIFT TO CORRECT THE 
C  CODE. BOLUSES HAVE BEEN ALLOWED IN STEADY STATE DOSE SETS SINCE 
C  MONT102.FOR, BUT THEY WERE NOT TESTED IN THE PRESENCE OF TIMELAGS,
C  AND THAT COMBINATION OF FACTORS WAS FOUND TO NOT WORK PROPERLY. THIS
C  BUG HAS NOW BEEN CORRECTED (SEE DETAILS IN STEP 4 OF SHIFT).

C  2. BS IS DIMENSIONED IN SUBROUTINE WRITESTEADY, AND VALFIX IS 
C  DIMENSIONED IN SUBROUTINE SIMBIG. THESE TWO DIMENSIONS SHOULD HAVE
C  BEEN DONE PREIVOUSLY (THEY CAUSE WARNINGS IN THE NEW gfortran
C  COMPILER, BUT NO ERRORS).

C-----------------------------------------------------------------------

C  MONT104.FOR                                             6/14/12

C  MONT104 HAS THE FOLLOWING TWO CHANGES FROM MONT103:

C  1. SUBROUTINE FUNC2 HAS A BUG CORRECTION AT LABEL 20, WHICH IS 
C  CHANGED FROM:

C  20    IF(TIMN(KNT) .GT. SIGN(KNS) .AND. SIGN(KNS) .NE. 0) GO TO 25

C  TO

C  20    IF(TIMN(KNT) .GT. SIGN(KNS) .AND. SIGN(KNS) .GT. 0) GO TO 25

C  THE CODE IS NOW CONSISTENT WITH idm1x11.f (IN THE npageng17.f 
C  PROGRAM) AND RECOGNIZES STEADY STATE DOSE SETS.

C  EXAMPLE: SUPPOSED SIGN(KNS) = -4 WHICH SIGNIFIES THE NEXT DOSE
C  EVENT IS THE START OF A STEADY STATE DOSE SET; AND TIMN(KNT) = 10,
C  WHICH MEANS THE PROGRAM SHOULD STILL INTEGRATE THROUGH T = 10 TO
C  GET THE OBSERVATION AT THIS POINT FROM THE CURRENT SECTION.

C  IN THE OLD CODE, SINCE 10 > -4 AND -4 .NE. 0, CONTROL WOULD SHIFT
C  TO LABEL 25 WHERE ID WOULD BE SET = 1 AND TOUT SET = -4. I.E., THE
C  PROGRAM WOULD FASTFORWARD TO THE STEADY STATE DOSE SET IN THE NEXT
C  SECTION WITHOUT COMPLETING OBS. VALUES IN THE CURRENT SECTION. AND
C  THIS WOULD SCREW UP THE PROGRAM COMPLETELY SINCE THE PROGRAM WOULD
C  START INTEGRATING THROUGH THE STEADY STATE DOSE SET WITHOUT EVER
C  SEEING THE CORRESPONDING TIMN(.) = 0 (WHICH WOULD HAVE FOLLOWED THE
C  TIMN(I) = 10 AT SOME POINT).


C  NOW, SINCE SIGN(KNS) = -4 WHICH IS NOT .GT. 0, CONTROL WILL DROP
C  DOWN TO LABEL 15, SET ID = 0 AND TOUT = 10 AND OBTAIN THE OBS.
C  VALUE AT T = 10 AS DESIRED.


C  2. ALL TIMES REPORTED IN THE OUTPUT FILE WILL NOW BE RELATIVE TIMES.
C  IN THE EXAMPLE ABOVE, IF II = 24, AND AN OBSERVATION OCCURRED AT A
C  RELATIVE TIME OF 1.5, THIS RELATIVE TIME OF 1.5 WOULD BE WRITTEN 
C  CORRECTLY IN THE SIMULATED .CSV AND WORKING COPY FILES; BUT IN THE 
C  OUTPUT FILE, THE OBSERVATION WOULD HAVE A TIME OF 2401.5. NOW, THE
C  OBSERVATION TIMES IN THE OUTPUT FILE WILL ALSO BE RELATIVE TIMES.

C  THIS CHANGE IS MADE BY WRITING TIMORIG(I), RATHER THAN TIM(I) TO
C  FILE 23 (FORMAT 7008) 3 PLACES IN SUBROUTINE SIMBIG.


C  NOTES: SEE MONT104.EXP, REMARKS 6, 7, 8:

C  1. THE USER SHOULD NEVER SPECIFY AN OBS. TIME OF 0 IN A .CSV FILE. 
C     AND IN A WORKING COPY FILE, THE USER SHOULD SPECIFY AN OBS. TIME
C     OF 0 ONLY IF THAT LINE REPRESENT A TIME RESET LINE.
C  2. THE USER SHOULD NOT SPECIFY A DOSE TIME OF 0 UNLESS IT IS TO 
C     REPRESENT A DOSE RESET LINE. I.E., IF IT FOLLOWS A STEADY STATE
C     DOSE SET, THE PROGRAM WILL INTERPRET IT, NOT AS A DOSE AT EXACTLY
C     THE END OF THAT STEADY STATE DOSE SET, BUT RATHER AS THE FIRST
C     DOSE IN A NEW SECTION AFTER A DOSE RESET.

C-----------------------------------------------------------------------

C  MONT103.FOR                                             5/24/12

C  MONT103 HAS THE FOLLOWING CHANGE TO MONT102:

C  IT HAS CODE CHANGES IN SUBROUTINE PREDLAST3 TO HANDLE THE CASE WHERE
C  PRED1 + PRED3 - 2*PRED2 = 0 --> PREDNEG SHOULD NOT BE CALCULATED. 
C  USUALLY THIS WILL HAPPEN WHEN THE MODEL/DOSAGE REGIMEN IS SO "EASY"
C  TO PREDICT THAT THE 3 PREDICTED VALUES ARE VERY CLOSE TO EACH OTHER,
C  AND BY "BAD LUCK" COULD BE IN A LINEAR PROGRESSION. I.E., IF
C  PRED1 + DEL = PRED2, AND PRED2 + DEL = PRED3, THEN 
C  PRED1 + PRED3 - 2*PRED2 = 0.

C  IN THIS CASE, OF COURSE, PREDNEG SHOULD NOT BE CALCULATED SINCE THAT
C  WILL RESULT IN A DIVIDE BY 0, OR A NaN IF THE PROGRAM DOES NOT STOP.

C  WHEN THIS HAPPENS (SEE CODE IN PREDLAST3), WHETHER OR NOT CONVERGENCE
C  IS ACHIEVED WILL DEPEND SOLELY ON THE TOL1 CRITERION (I.E., THE TOL2
C  CRITERION CANNOT BE USED, AND IS UNNEEDED).

C-----------------------------------------------------------------------

C  MONT102.FOR                                             4/26/12

C  MONT102 HAS THE FOLLOWING CHANGES TO MONT101G:

C  IT NO LONGER RESTRICTS STEADY STATE DOSES TO BE IVs. NOW THEY CAN
C  BE BOLUSES TOO. BUT, FOR EACH DRUG IN A STEADY STATE SET CAN HAVE 
C  EITHER AN IV OR A BOLUS, BUT NOT BOTH. THE REASON IS THAT THE DOSE 
C  COLUMN IN THE .CSV FILE IS USED FOR THE TOTAL AMOUNT OF DRUG GIVEN.
C  IF THE CORRESPONDING DURATION IS 0, THIS REPRESENTS A BOLUS; IF THE
C  CORRESPONDING DURATION > 0, THIS REPRESENTS THE TOTAL AMOUNT OF THE
C  IV (WITH THE INDICATED DURATION). IF THERE WERE TO BE BOTH AN IV AND
C  A BOLUS, THERE WOULD BE NO WAY TO IMPART THIS INFORMATION IN THE TWO
C  ENTRIES (DUR AND DOSE).

C  TO DO THIS, THE FOLLOWING CHANGES ARE IMPLEMENTED:


C  1. IN SUBROUTINE READBLOCK2, THE IV RATE IS SET = 0 IF DUR = 0.

C  2. SEVERAL CODE CHANGES ARE MADE TO SUBROUTINE NEWWORK1.

C  3. IN SUBROUTINE FUNC2, AN ADDITIONAL PARAMETER, ISKIPBOL, IS USED
C  SO WHEN CONVERGENCE OCCURS IN A STEADY STATE DOSE SET, THE LAST
C  BOLUS FROM THAT SET WILL NOT BE REAPPLIED BELOW LABEL 83.

C  4. SEVERAL CHANGES HAVE BEEN MADE TO SUBROUTINE WRITESTEADY BECAUSE
C  NOW RIV, THE IV RATE FOR A STEADY STATE DOSE, MAY BE 0. IF RBOL IS
C  > 0 AND RIV = 0, THIS IS NO LONGER AN ERROR. IN THIS CASE, THE
C  DURATION OF EACH DOSE IS, OF COURSE, 0.

C  5. THE G15.6 FORMAT IN FORMAT 1 IN SUBROUTINE WRITEDOS IS CHANGED
C  TO BE G19.9 (TO GIVE A LITTLE MORE PRECISION).

C  6. SOME UNNEEDED ARRAYS AND VARIABLES HAVE BEEN REMOVED.

C-----------------------------------------------------------------------

C  MONT101G.FOR                                            3/26/12

C  MONT101G HAS THE FOLLOWING CHANGES FROM MONT101F:

C  1. THE USER IS NOW ALLOWED TO PUT IN SPECIFIED BOUNDARIES FOR EACH
C  RANDOM VARIABLE. THEN, IF A SIMULATED PARAMETER SET HAS A R.V.
C  OUTSIDE ITS BOUNDARIES, THAT SET WILL NOT BE USED TO SIMULATE A 

C  SUBJECT. BUT ITS VALUES WILL BE PART OF THE OVERALL SUMMARY 
C  STATISTICS IN THE OUTPUT FILE. IN THIS CASE, THE SUMMARY STATISTICS
C  SECTION OF THE OUTPUT FILE WILL HAVE SAMPLE MEANS, COV. MATRIX, AND
C  CORR. MATRIX FOR BOTH THE OVERALL PARAMETER SETS, AND THOSE SETS 
C  WHICH WERE USED TO SIMULATE SUBJECTS. IF ALL SIMULATED SETS HAVE
C  ACCEPTABLE VALUES WITHIN THEIR SPECIFIED BOUNDARIES, THEN THE OUTPUT
C  FILE SUMMARY STATISTICS SECTION WILL SHOW JUST ONE SET OF SAMPLE
C  MEANS, COV. MATRIX, AND CORR. MATRIX.

C  2. OSname and ListDir ARE ADDED AS ARGUMENTS TO GETDIST, SO THAT
C  THEY CAN BE PASSED TO READNPAG. THIS SHOULD HAVE BEEN DONE BEFORE.
C  IT SHOWED UP AS A WARNING IN THE COMPILER, RATHER THAN AN ERROR.

C  3. JUST BELOW THE START OF LOOP 1000 IN SUBROUTINE WRITEDOS, 
C  SUBROUTINE THESAME IS CALLED TO ESTABLISH THE VALUE FOR ISAMERESET.
C  THIS CALL HAD BEEN REMOVED IN MONT101F.FOR SINCE NRESET AND 
C  TIMERESET WERE SET IN THE  IF(TIME .GE. TIMADD*(NRESET+1))
C  BLOCK. BUT IT IS NECESSARY FOR ISAMERESET TO BE SET = 1 WHEN
C  TIME = TIMADD*(NRESET+1) ... SINCE IT IS USED BELOW TO PREVENT
C  INTERPOLATION OF COVARIATES ACROSS A TIME RESET.

C-----------------------------------------------------------------------


C  MONT101F.FOR                                            3/17/12

C  MONT101F HAS THE FOLLOWING CHANGE FROM MONT101E:        

C  1. IT ALLOWS A NEW VERSION OF THE .csv FILE. THIS FILE WILL HAVE
C  THE CODE,"POPDATA DEC_11" AT THE TOP, RATHER THAN "POPDATA APR_11".
C  THIS NEW .csv FILE WILL HAVE TWO EXTRA COLUMNS, ADDL AND II, WHICH
C  ALLOW THE USER TO SPECIFY THAT THE CURRENT DOSE LINE IS TO BE
C  REPLICATED ADDL TIMES AT AN INTERDOSE INTERVAL OF II. IF ADDL IS

C  MISSING, IT IS ASSUMED TO BE 0 (WHICH MEANS THE LINE IS NOT TO BE
C  REPLICATED). IF ADDL = -1, IT INDICATES A STEADY STATE DOSE SET IS 
C  BEGINNING WITH THAT LINE.

C  TO HANDLE THE NEW .csv FILE, A NEW SUBROUTINE, CSVCHANGE, WILL BE
C  CALLED (AFTER SUBROUTINE NEWCSV IS CALLED AND BEFORE READBLOCK IS
C  CALLED) TO CHANGE THE NEW .csv FILE INTO THE CORRESPONDING ONE
C  WITH THE OLD FORMAT. THIS WILL MINIMIZE THE CHANGES TO SUBROUTINE
C  READBLOCK, WHICH WILL STILL NEED TO BE CHANGED TO DEAL WITH 
C  NEGATIVE DOSE TIMES (WHICH WILL NOW INDICATE THE BEGINNING OF A 
C  STEADY STATE DOSE SET) - SEE CODE IN READBLOCK.

C  ALSO NOTE THAT CSVCHANGE CONVERTS SCRATCH FILE 67 TO SCRATCH FILE
C  66, WHICH MEANS THAT ALL THE READ(67,..) STATEMENTS IN READBLOCK ARE
C  NOW CHANGED TO READ(66,...) STATEMENTS. SIMILARLY, THE READ(67,...)
C  IN SUBROUTINE GETMAXTIM IS CHANGED TO READ(66,...).

C  SOME NOTES REGARDING THE NEW .csv FORMAT:

C  a. THE COLUMNS WILL NOW BE:
C  ID,EVID,TIME,DUR,DOSE,ADDL,II,INPUT,OUT,OUTEQ,C0,C1,C2,C3,Covs if any

C  b. ADDL AND II ARE ONLY RELEVANT FOR EVID=1 AND EVID=4. FOR EVID=0,
C  (OBSERVATIONS) THEY ARE IGNORED.

C  c. ADDL CONTAINS THE NO. OF ADDITIONAL DOSES TO GIVE, AT THE 
C  INTERDOSE INTERVAL OF II.

C  d. If ADDL IS MISSING FOR AN EVID=1 OR EVID=4 EVENT, IT IS ASSUMED 
C  TO BE 0 --> NO ADDITIONAL DOSES ARE GIVEN. IN THIS CASE, II IS
C  IRRELEVANT.

C  e. IF ADDL > 0, THEN ADDL ADDITIONAL DOSES ARE GIVEN (I.E., A TOTAL
C  OF ADDL + 1) AT INTERVAL II. A MISSING II IN THIS CASE WILL RESULT
C  IN THE PROGRAM STOPPING WITH AN ERROR MESSAGE TO THE USER.

C  f. ADDL > 0 CAN OCCUR ON ANY DOSE EVENT, BUT ADDL = -1 (A STEADY
C  STATE DOSE INDICATOR) CAN ONLY OCCUR AT T = 0 AT THE BEGINNING OF
C  A PATIENT'S FILE, OR AT A DOSE RESET TIME.

C  NOTE THAT A NEW ROUTINE, NEWWORK1, IS CALLED BEFORE SIMBIG CALLS
C  IDCALCY TO CONVERT A WORKING COPY FILE, WHICH MAY HAVE STEADY STATE
C  DOSE INDICATORS (I.E., NEGATIVE DOSE TIMES) TO A WORKING COPY FILE
C  WITH EACH STEADY STATE DOSE INDICATOR LINE REPLACED BY 100 STEADY
C  STATE DOSE SETS, IN THE FORMAT THAT CAN THEN BE READ BY SUBROUTINE
C  FUNC2. ALSO, A NEW SUBROUTINE STOREOBSER IS USED TO READ THIS NEW
C  WORKING COPY FILE IN ORDER TO STORE THE PROPER VALUES INTO THE 
C  ARRAYS OF THE COMMONS SUPPLIED TO SUBROUTINE FUNC2.
 
C  2. IN SUBROUTINE TIMESET, THE FIRST TIME IN THE DOSAGE BLOCK FOR EACH
C  SUBJECT IS NO LONGER TESTED TO MAKE SURE IT IS 0. THE REASON, OF
C  COURSE, IS THAT NOW THE FIRST TIME MAY BE NEGATIVE (WHICH SIGNIFIES
C  THAT THE DOSAGE REGIMEN BEGINS WITH A STEADY STATE OF DOSES).

C  3. A NEW SUBROUTINE CONVERTCSV IS CALLED BEFORE EACH CALL TO
C  SUBROUTINE NEWCSV TO CONVERT, IF NECESSARY, A "EUROPEAN" VERSION OF
C  A .CSV FILE TO THE FORM READBLOCK EXPECTS. IN THE "EURO" VERSION, THE
C  FIELD SEPARATORS ARE SEMICOLONS, RATHER THAN COMMAS, AND THE 
C  CHARACTER USED TO SEPARATE THE WHOLE PART OF A NUMBER FROM THE
C  FRACTIONAL PART IS A COMMA, RATHER THAN A PERIOD. TO DO THIS REQUIRES
C  READING THE SECONDS LINE OF THE .CSV FILE (THE FIRST LINE HAS THE
C  VERSION CODE) AND CHECKING FOR SEMICOLONS. IF THERE ARE ANY, THEN THE
C  FILE IS CHANGED SO THAT, IN ORDER, ALL COMMAS ARE CHANGED TO PERIODS,
C  AND THEN ALL SEMICOLONS ARE CHANGED TO COMMAS. NOTE THAT, EVEN IN THE
C  "EURO" VERSION, IT WILL STILL BE ASSUMED THAT A DOT REPRESENTS
C  A MISSING (OR UNNEEDED) VALUE.

C  NOTE THAT BLOCKPAT IS NOW OPENED AS SCRATCH FILE 87. THEN CONVERTCSV
C  WRITES THIS FILE AS THE CORRECTED VERSION TO SCRATCH FILE 77. THEN,
C  ROUTINE NEWCSV CONVERTS THIS FILE TO SCRATCH FILE 67. THEN ROUTINE
C  CSVCHANGE CONVERTS THIS FILE TO SCRATCH FILE 66, WHICH IS READ BY
C  ROUTINE READBLOCK2.

C  4. SUBROUTINE IDCALCY IS NOW BASED ON idm2x9f (SEE NPAG105.EXP),
C  UPDATED FROM idm2x5.f. THIS MEANS IT HAS CORRESPONDING CHANGES TO
C  THOSE LISTED ABOVE; THE MAIN CHANGE IS THAT IT NOW ACCOMMODATES
C  STEADY STATE DOSING.

C  5. SUBROUTINE FUNC2 IS CHANGED TO BE SIMILAR TO THE CHANGES IN
C  IN idm2x9.f (WHICH ACCOMMODATE STEADY STATE DOSING). ALSO, 
C  SUBROUTINE PREDLAST3 (WHICH IS IN THE idm1x9.f MODULE IN THE
C  NPAG AND IT2B PROGRAMS) IS COPIED INTO THIS PROGRAM.

C  6. ALL ARRAYS RELATED TO DOSES (SIG,SIGO,RS,RSO,BS,ETC.) IN

C  SUBROUTINES FUNC2, SIMBIG, INOUT, SHIFT, WORKTOCSV, AND WRITECSV HAVE
C  THEIR 4000's CHANGED TO 5000's. SIMILARLY, THE PROGRAM VERIFIES THAT
C  THE NO. OF DOSES DOES NOT EXCEED 5000, RATHER THAN 4000, IN SEVERAL 
C  PLACES.

C  7. SUBROUTINE SHIFT IS NOW BASED ON shift7.f (WHICH ACCOMMODATES
C  STEADY STATE DOSING).

C  8. FORMAT 1 IN SUBROUTINE WRITEDOS IS CHANGED FROM G15.6 TO G15.9
C  SO THE DOSES WILL HAVE MORE PRECISION.

C  9. CHANGES ARE MADE IN SUBROUTINES WORKTOCSV AND WRITECSV, AND A NEW
C  SUBROUTINE, WRITESTEADY, IS ADDED, TO ENABLE THE PROGRAM TO CREATE
C  THE NEW-STYLE (WITH CODE = 'POPDATA DEC_11') .CSV FILES, WITH THE TWO
C  EXTRA COLUMNS FOR ADDL AND II, FROM THE SIMULATED DATA.

C-----------------------------------------------------------------------

C  MONT101E.FOR                                            8/4/11

C  MONT101E HAS THE FOLLOWING CHANGE FROM MONT101D:

C  IT CORRECTS A BUG IN SUBROUTINE FUNC2 WHICH OCCURS WHEN TIME RESETS
C  ARE USED, IN THE ESTABLISHMENT OF THE NOISY DOSE AND OBSERVATION


C  TIMES. NOW, EACH DOSE AND OBSERVATION TIME PAST THE FIRST ONE IS
C  CHECKED TO SEE IF IT IS = 0.0. IF IT IS, IT IS IDENTIFIED AS A
C  TIME RESET 0, AND IS HARDCODED TO BE 0 (WITH NO NOISE APPLIED SO THAT

C  THE REST OF THE CODE WILL KNOW IT IS A TIME RESET). PREVIOUSLY, WHEN
C  A TIME RESET OCCURRED, IT MEANT THAT A TIME WAS LESS THAN THE 

C  PREVIOUS VALUE (BEFORE NOISE WAS APPLIED), AND THIS SCREWED UP THE
C  LOGIC THAT ASSUMED THAT TIMES WERE MONOTONICALLY INCREASING.


C-----------------------------------------------------------------------
C  MONT101D.FOR                                            7/20/11

C  MONT101D HAS THE FOLLOWING CHANGES TO MONT101C:

C  1. IN SUBROUTINE INOUT, THE NAME OF THE PATIENT FILE IS CHANGED FROM

C  WhoopteeDo, Yowza  TO  WhoopteeDo Yowza. I.E., THE COMMA IS TAKEN
C  OUT. THE REASON IS THAT IF THESE SIMULATED PATIENT FILES ARE LATER
C  CONVERTED TO .CSV FORMAT, THE .CSV FILE COULD BE SCREWED UP BY 

C  HAVING COMMAS IN THE SUBJECT ID (BECAUSE COMMAS IN A .CSV FILE

C  ARE USED TO SEPARATE FIELDS).

C  2. IN SUBROUTINE WRITECSV, THE DIMENSION OF Y0 IS CHANGED FROM
C  Y0(150,6) TO YO(594,6) TO BE CONSISTENT WITH THE REST OF THE PROGRAM.

C-----------------------------------------------------------------------

C  MONT101C.FOR                                            6/14/11

C  MONT101C IS THE SAME CODE AS MONT101A, EXCEPT FOR THE ADDITION OF
C  WALTER'S CHANGES TO ALLOW THIS PROGRAM TO OPERATE UNDER UNIX AS
C  WELL AS DOS. SEE CODE BELOW MARKED WITH "Yamada".

C-----------------------------------------------------------------------

C  MONT101A.FOR                                            6/13/11

C  MONT101A HAS A COUPLE OF SMALL FORMATCHANGES TO REMOVE THE POSSIBILITY
C  THAT OUTPUT INFO RUNS TOGETHER (IN THE OUTPUT FILE).

C  FORMAT 7007 HAS AN EXTRA "1X" TO ENSURE THAT THE SUBJECT NO. IS
C  SEPARATED FROM THE BEGINNING OF THE PARAMETER VALUES. A SIMILAR
C  CHANGE TO FORMAT 9012 SERVES THE SAME PURPOSE.

C-----------------------------------------------------------------------

C  MONT101.FOR                                             5/25/11

C  MONT101 HAS THE FOLLOWING CHANGES FROM MONT100:

C  1. THE SIMULATED PATIENT INFO, WHICH PREVIOUSLY WAS OUTPUT AS A SET
C  OF WORKING COPY PATIENT FILES, CAN NOW BE OUTPUT AS EITHER A SET OF
C  WORKING COPY PATIENT FILES, A BLOCK .CSV FILE, OR BOTH. OF COURSE,
C  THE OPTION REMAINS TO DO NEITHER, WHICH IS WHAT USERS WHO ONLY NEED
C  THE OUTPUT FILE ITSELF WILL SELECT.


C  TO MAKE A .CSV FILE FROM THE SIMULATED SUBJECTS REQUIRES A NEW
C  SET OF SUBROUTINES, BASED ON THE STAND-A-LONE PROGRAM, WORKCSV.FOR.

C  NOTE THAT BECAUSE OF THE NEW INFO REGARDING THE ABOVE SELECTION,
C  THE INSTRUCTION FILE WILL HAVE A NEW CODE, 'MONTBIG JUN_11'.


C  2. UNLIKE PREVIOUS PROGRAMS, THE CORRECT ASSAY COEFFICIENTS (I.E.,
C  THOSE WHICH WERE USED TO SIMULATE THE SUBJECTS) WILL BE WRITTEN TO
C  THE SIMULATED PATIENT DATA FILES, IF THEY ARE CREATED (PREVIOUSLY,
C  THE ASSAY C'S WHICH WERE WRITTEN WERE THOSE IN THE TEMPLATE WORKING
C  COPY FILE). SIMILARLY, IF A .CSV FILE IS TO BE CREATED, IT WILL ALSO
C  CONTAIN THESE CORRECT ASSAY C'S.

C  3. THE FORMAT IS CHANGED SO THAT VERY LARGE OUTPUT TIMES NO LONGER
C  ARE TRUNCATED AFTER 4 SIGNIFICANT DIGITS. IN PARTICULAR, IN FORMATS
C  7007, 7008, 9012 IN SUBROUTINE SIMBIG, AND IN FORMAT 41 IN 
C  SUBROUTINE READBLOCK2, G12.4 IS REPLACED BY G14.7. (SEE TEST46.FOR
C  WHICH SHOWS THAT A G12.4 FORMAT REPORTS 1.234567 AS SIMPLY 1.235.

C  NOTE THAT FORMAT 7006 IS CHANGED ACCORDINGLY SO THE PARAMETER
C  NAMES ARE ABOVE THEIR VALUES. 

C-----------------------------------------------------------------------

C  MONT100.FOR (REVISED)                                  5/17/11

C  MONT100.FOR (REVISED) HAS THE FOLLOWING CHANGES FROM MONT100.FOR:

C  1. ALL FORMATS RELATED TO THE NO. OF DOSE EVENTS ARE CHANGED TO
C     I5 FROM I4, AND NOTE THAT THE I3 IN FORMAT 2 OF WRITEDOS,
C     WHICH HAD BEEN CHANGED TO I4 IN MONTBG21, BUT SOMEHOW CHANGED
C     BACK TO I3, IS ALSO NOW I5.
C  2. ALL FORMATS RELATED TO THE NO. OF OBSERVED VALUE TIMES ARE 
C     CHANGED TO I4 FROM I3.

C  SEE NOTES IN MONTBG21.FOR AND MONTBG22.FOR; THE MAX. NO. OF DOSE
C  EVENTS IS 4000, AND THE MAX. NO. OF OBSERVED VALUE TIMES IS 594,
C  BUT THE ABOVE CHANGES ALLOW FOR MORE DOSES AND OBSERVED VALUES IN

C  THE FUTURE (IF DIMENSIONS ARE CHANGED).

C-----------------------------------------------------------------------

C  MONT100.FOR                                             5/6/11

C  MONT100 HAS THE FOLLOWING CHANGES FROM MONTBG22:

C  1 MANY CHANGES ARE MADE IN SUBROUTINES READBLOCK2, WRITEDOS, ETC. 
C  SO THAT WT. AND CCR. ARE NO LONGER PUT IN AS DUMMY COVARIATES WHEN
C  THE WORKING COPY FILES ARE MADE FROM THE .CSV FILE. FROM NOW ON,
C  THE ONLY COVARIATES PUT INTO THE WORKING COPY FILES ARE THE ONES
C  SPECIFIED IN THE .CSV FILE. THIS WILL REQUIRE A NEW TEMPLATE MODEL
C  FILE (TSTMULTI.FOR, UPDATED FROM TSTMULTH.FOR) WHICH WILL NO LONGER
C  HAVE THE WARNINGS THAT THE USER SHOULDN'T REFER TO CV(1) AND CV(2)
C  IF THE PATIENT DATA INFO WAS INPUT VIA A .CSV FILE. ALSO THE DO 

C  LOOPS IN THAT FILE THAT WERE OVER I = 1,2+NADD WILL NOW BE OVER
C  I = 1,NADD (SINCE WT. AND CCR. WILL NOW BE INCLUDED AMONG THE NADD
C  ADDITIONAL COVARIATES).

C  ALSO NOTE THAT "NCOV" IN SUBROUTINES READBLOCK2 THROUGH THE REST OF
C  THE FILE HAS BEEN CHANGED TO "NCOVA". THIS STANDS FOR NO. OF 
C  ADDITIONAL COVARIATES - NOT INCLUDING THE 4 PERMANENT ONES AT THE
C  TOP OF ALL WORKING COPY FILES (AGE, SEX, HEIGHT, ETHNICITY FLAG).
C  THIS WAS DONE TO BE CONSISTENT WITH THE NAME USED IN NPAG100.FOR.

C  2. THE FORMAT OF THE .CSV FILE READ BY READBLOCK IS CHANGED. THERE

C  WILL BE 4 ADDITIONAL COLUMNS (COL. NOS. 9 - 12) TO CONTAIN THE
C  ASSAY COEFFICIENTS FOR EACH PATIENT/OUTPUT EQ. SO NOW THE 12
C  PERMANENT COLUMNS WILL BE, IN ORDER, #ID, EVENT ID, TIME,
C  INFUSION DURATION, TOTAL DOSE, INPUT (DRUG) NO., OUTPUT VALUE,
C  OUTPUT EQUATION, C0, C1, C2, C3. ANY ADDITIONAL COVARIATES (BEYOND
C  THE 4 AT THE TOP OF EACH WORKING COPY FILE (AGE, SEX, HEIGHT, 
C  ETHNICITY FLAG) WILL HAVE THEIR COLUMNS AFTER THE PERMANENT 12
C  ABOVE.


C  NOTE THAT EACH PATIENT NEEDS ONE SET OF ASSAY COEFFICIENTS FOR EACH
C  OF THE NUMEQT OUTPUT EQUATIONS. IF ANY OF THESE NUMEQT SETS IS
C  MISSING, THE CORRESPONDING POPULATION SET OF ASSAY C'S FOR THAT
C  OUPUT EQUATION WILL BE ASSIGNED TO THAT PATIENT. FOR THIS REASON,
C  THE ARGUMENT LIST FOR READBLOCK WILL BE EXPANDED TO CONTAIN
C  C0P,C1P,C2P, AND C3P (NOTE THAT THE ARRAYS C0, C1, C2, C3 ARE
C  RENAMED TO BE C0P, C1P, C2P, C3P, TO DISTINGUISH THEM FROM THE
C  SCALARS C0, C1, C2, C3 IN SUBROUTINE READBLOCK2.


C  NOTE THAT EACH ROW IN THE .CSV FILE WHICH HAS EVENT ID = 0 (I.E., IS
C  AN OUPUT VALUE ROW) CAN HAVE ASSAY COEFFICIENT INFO. IF THIS INFO
C  IS SUPPLIED FOR THE SAME SUBJECT AND OUTPUT EQ. MORE THAN ONCE, THE
C  LAST SUCH ROW OF VALUES WILL BE USED. ALSO NOTE THAT IF ANY SET OF
C  ASSAY C'S IS INCOMPLETE (I.E., IT HAS AT LEAST ONE VALUE BUT NOT ALL
C  4), THE PROGRAM WILL STOP WITH A MESSAGE TO THE USER THAT THIS TYPE
C  OF INCOMPLETE ASSAY INFO LINE IS IMPERMISSABLE.

C  BECAUSE OF THE NEW .CSV FORMAT, THERE WILL BE NO BACKWARDS 

C  COMPATIBILITY TO .CSV FILES WITH THE OLD FORMAT.

C  3. THERE WILL BE A NEW CODE FOR THE INSTRUCTION FILE, 
C  'MONTBIG MAY_11', WITH ICODE = 07. THE DIFFERENCE IS THAT NOW THE
C  INSTRUCTION FILE WILL ALSO HAVE TEXT DESCRIBING WHAT INFO IS INPUT.


C  4. IN SUBROUTINE AFTERCOMMA, THE FREE FROMAT WRITE STATEMENT TO 
C  FILE 57 IS REPLACED BY A SERIES OF FORMATTED WRITE STATEMENTS,
C  BASED ON THE NO. OF CHARACTERS TO BE WRITTEN (1 - 11). IF THE NO. OF 
C  CHARACTERS IS > 11, A FREE FORMAT IS STILL USED. THE REASON IS THAT
C  WHEN THIS PROGRAM IS COMPILED AND LINKED UNDER gfortran, A FREE 

C  FORMAT WRITE HAS AN EXTRA SPACE INSERTED AT THE BEGINNING OF THE 
C  LINE. THIS MEANT THAT, WHEN A .CSV FILE HAD AN 11 CHARACTER 
C  SUBJECT ID, ONLY THE 1ST 11 WOULD BE WRITTEN TO FILE 57. THEN, IN
C  READBLOCK, WHEN FILE 57 WAS READ, TWO OR MORE SUBJECTS WHOSE FIRST
C  10 CHARACTERS WERE THE SAME (I.E., THEY HAD DIFFERENCES ONLY IN THE
C  11TH CHARACTER) WOULD HAVE THEIR DATA COMBINED INTO THE SAME WORKING
C  COPY PATIENT DATA FILE. THIS PROBLEM DOES NOT OCCUR WHEN THIS PROGRAM
C  IS COMPILED UNDER LAHEY F90. 


C  5. THE CODE WHICH CHANGED ANY PREDICTED VALUE < 0 TO BE 1.D-8 IS 
C  CHANGED TO CHANGE ANY PREDICTED VALUE < 1.D-8 TO BE 1.D-8. THE 

C  REASON IS THAT VALUES LOWER THAN 1.D-99 ARE WRITTEN IMPROPERLY TO
C  THE PATIENT DATA FILES AND THE OUTPUT FILE. EX: A VALUE OF 1.D-123
C  GETS WRITTEN AS .1-122 = -121.9.

C  6. SEVERAL STOP STATEMENTS WERE NOT PRECEDED BY A CALL PAUSE 
C  STATEMENT PREVIOUSLY (AS THEY SHOULD HAVE BEEN). THIS HAS NOW BEEN
C  CORRECTED.

C-----------------------------------------------------------------------

C  MONTBG22.FOR                                            3/20/11

C  MONTBG22 HAS THE FOLLOWING CHANGES FROM MONTBG21:

C  1. IT CORRECTS INCONSISTENCIES IN DIMENSION STATEMENTS. SPECIFICALLY,
C  SEVERAL 150s HAVE BEEN CHANGED TO 594s IN SUBROUTINES SIMBIG, GNRAT,
C  NOSGEN, AND SQROOT (E.G., AS1, AS, ASUB, AMEANC, COVC, ALF - THE LAST
C  3 ONLY NEED THE LARGER DIMENSION TO BE COMPATIBLE WITH THE DUMMY
C  ARGUMENTS IN CALLED ROUTINES).


C  2. THE G15.6 IN FORMAT 1 IN SUBROUTINE WRITEDOS WAS CHANGED TO G19.10 
C  BECAUSE A TIME OF 10000.01 IN G15.6 IS ROUNDED TO 10000.0, AND THIS
C  CAUSED A PROBLEM WHEN A SHORT TERM IV OF .01 THEN LOOKED LIKE IT WAS
C  TURNED ON AND OFF AT THE SAME TIME.

C-----------------------------------------------------------------------


C  MONTBG21.FOR                                            3/16/11


C  MONTBG21 IS THE SAME AS MONTBG20 EXCEPT FOR THE FOLLOWING:

C  1. THE MAXIMUM NO. OF  DOSE EVENTS IS INCREASED FROM 500 TO 4000. 
C  SO ALL DIMENSIONS OF 500 RELATED TO THE NO. OF DOSES ARE CHANGED TO
C  4000. IN ADDITION, THE 650 DIMENSIONS WHICH REFER TO DOSE-RELATED
C  DIMENSIONS ARE ALL CHANGED ACCORDINGLY (MULTIPLIED BY 8) TO BE 5200.
C  AND THE TOTAL NO. OF DOSE LINES ALLOWED IS CHANGED FROM 3000 TO 
C  24000.

C  ALSO FORMAT 1013 IN SUBROUTINE INOUT IS CHANGED TO ACCOMODATE UP TO
C  A 4-DIGIT NO. OF DOSE EVENTS. AND A SIMILAR CHANGE IS MADE TO FORMAT 
C  2 OF SUBROUTINE WRITEDOS.

C  2. SEVERAL VARIABLES WHICH WERE NOT USED ARE NOW REMOVED FROM
C  THE DECLARATION STATEMENTS IN READLBLOCK2 (AGE, ETHNIC, DATE,
C  HEIGHT, WEIGHT, CCR, PATNAME, SEXI, PAT, SEX)

C  3. A SMALL BUG IS REMOVED IN SUBROUTINE READBLOCK2. IN FORMAT 11,
C  FILEIN IS NO LONGER REFERENCED - IT IS NOT PASSED TO THE ROUTINE,
C  AND SO WOULD BE PRINTED AS BLANKS IF FORMAT 11 WAS WRITTEN.

C  4. A SMALL BUG IS FIXED IN VERIF1. WHEN READING IN FILEIN, THE FORMAT
C  IS CHANGED FROM 2 TO 212.

C-----------------------------------------------------------------------

C  MONTBG20.FOR                                            1/21/11

C  MONTBG20 HAS THE FOLLOWING CHANGES TO MONTBG19:

C  1. IT CORRECTS A SUBTLE BUG IN SUBROUTINE READBLOCK2. PREVIOUSLY IF
C  AN IV STARTED AT EXACTLY THE ENDING TIME OF THE PREVIOUS IV, THIS
C  WOULD RESULT IN BOTH 0.0 AND THE NEW IV RATE BEING ASSIGNED TO THE
C  SAME TIME. THE RESULT, IN WRITEDOS, WOULD BE THAT 0.0 WOULD BE 
C  ASSIGNED TO THIS TIME (I.E., THE NEW IV RATE WOULD BE LOST). NOW,
C  THIS BUG IS CORRECTED IN SUBROUTINE READBLOCK2, WHERE THE BEGINNING
C  TIME OF EACH IV IS TESTED AGAINST THE ENDING TIME OF THE PREVIOUS 
C  (IF THERE IS A PREVIOUS ONE), AND IF THEY ARE THE SAME, THEN THE NEW
C  IV RATE OVERWRITES THE 0.0 WHICH WOULD HAVE BEEN THE NEW IV RATE IF
C  THERE HADN'T BEEN ANOTHER STARTING IV AT THAT TIME.

C  2. IN FORMAT 5001, ONE OF THE 'TSTMULTG.FOR's WAS NOT CHANGED TO 
C  'TSTMULTH.FOR' IN MONTBG19.FOR. THIS HAS NOW BEEN CORRECTED.

C-----------------------------------------------------------------------
 
C  MONTBG19.FOR                                             1/7/10

C  MONTBG19 HAS THE FOLLOWING CHANGES TO MONTBG18:

C  1. BEFORE THE THREE CALLS TO SUBROUTINE READBLOCK2, NEW CODE IS PUT
C  IN TO CALL NEW SUBROUTINE NEWCSV (BASED ON THE STAND-A-LONG PROGRAM,  
C  NEWCSV.FOR) WHICH CONVERTS THE .CSV FILE INTO A SCRATCH FILE WITH 
C  EACH MISSING VALUE DOT REPLACED BY AN n. THIS IS NECESSARY SINCE, 
C  WHEN THIS PROGRAM IS COMPILED/LINKED WITH gfortran, IT INTERPRETS
C  A DOT AS A 0 (I.E., A NUMBER RATHER THAN A NON-NUMBER). THE RESULT
C  IS THAT THE STATEMENT ...
C    READ(57,*,ERR=70) COVVAL
C  IS IMPROPERLY EVALUATED WHEN A DOT IS READ. I.E., RATHER THAN 
C  BRANCHING TO LABEL 70, THE PROGRAM SETS COVVAL = 0 AND CONTINUES.

C  SINCE THERE ARE OTHER SIMILAR READ STATEMENTS, RATHER THAN TRY TO


C  ADDRESS EACH ONE INDIVIDUALLY, READBLOCK2 WILL READ THE SCRATCH FILE
C  INSTEAD OF THE ORIGINAL .CSV FILE. SINCE gfortran SEES AN n AS A
C  NON-NUMBER, THE CODE WILL NOW BE EXECUTED CORRECTLY.

C  NOTE THAT THE .CSV FILE WILL NOW BE OPENED AS FILE 77, AND THE 
C  SCRATCH FILE WILL BE FILE 67.



C  2. THE TEMPLATE MODEL FILE WILL NOW BE TSTMULTH.FOR, RATHER THAN
C  TSTMULTG.FOR. TSTMULTH.FOR ALLOWS N=-1 IN SUBROUTINE SYMBOL, WHICH
C  TELLS THE PROGRAM THAT THE MODEL IS THE STANDARD 3-COMP. LINEAR
C  MODEL, AND THE BASIC 5 PARAMETERS ARE CODED IN SUBROUTINE ANAL3 BY
C  THE USER. THE USER ALSO CODES THE OTHER ROUTINES IN TSTMULTH.FOR, 
C  AS INDICATED IN THE COMMENTS IN THAT TEMPLATE MODEL FILE.

C  NOTE THAT CHANGES ARE MADE IN SUBROUTINE FUNC2 TO BE COMPATIBLE WITH
C  THE NEW TSTMULTH.FOR MODEL FILE, AND THE POSSIBILITY THAT N=-1. IN 
C  PARTICULAR, IF N .EQ. -1, SUBROUTINE ANAL3 IS CALLED RATHER THAN 
C  SUBROUTINE USERANAL. ALSO, THE CODE TO RESET X(I),I=1,N TO 0 WHERE 
C  THERE IS A TIME RESET NOW INCLUDES EXTRA CODE TO SET X(I),I=1,3 TO 0

C  IF N .EQ. -1. SIMILARLY, TWO OTHER TIMES IN FUNC2, WHEN A
C  DO ICOMPART = 1,N IS USED TO SET XPRED, THE CODE IS CHANGED TO BE 
C  DO ICOMPART = 1,3 IF N .EQ. -1.

C  NOTE THAT 2 DO LOOPS INVOLVING NDIM ARE CHANGED TO 3 IF NDIM = -1

C  SINCE THERE REALLY ARE 3 COMPARTMENTS (-1 IS JUST A CODE FOR THE
C  PROGRAM TO KNOW TO USE ANALYTIC SOLUTIONS).

C  3. SEVERAL BUGS ARE FIXED RELATED TO SUBROUTINE READBLOCK2, WHICH WAS 
C  INTRODUCTED IN MONTBG18.FOR. 

C   a. WHEN INOPT = 1, READBLOCK2 WAS NOT CALLED, AND SO XQZPJ001.ZMQ 
C      WAS NOT MADE IN THIS CASE. THIS HAS BEEN CORRECTED.
C   b. IN READBLOCK2, CALL GETCHAR IS REPLACED BY CALL GETCHAR2, WHICH
C      IS THE ROUTINE ADDED FROM SCAT72X1.FOR WHICH RETURNS A 
C      3-CHARACTER CHARSUB RATHER THAN A 5-CHARACTER CHARSUB (WHICH 
C      IS WHAT GETCHAR RETURNS). 
C   c. THE SIZE OF PATH, TMPFILE, AND PATHFILE IN READBLOCK2 HAVE BEEN
C      CHANGED FROM 60, 13, AND 73, RESPECTIVELY, TO 61, 32, AND 93,
C      RESPECTIVELY (TO BE CONSISTENT WITH THE REST OF THIS PROGRAM).
C      ALSO, IN SUBROUTINE READNPAG (WHICH WAS NEW IN MONTBG18.FOR), 
C      THE SIZES OF THESE CHARACTER VARIABLES ARE SIMILARLY CORRECTED.
C   d. THE CALL TO READBLOCK2 IN THE INOPT = 1 SECTION IS NOW ONLY MADE
C      IF ICSVFILE = 1 (OBVIOUSLY READBLOCK2 IS UNNEEDED IF FILEIN IS
C      ALREADY A WORKING COPY FILE).
C   e. IN MAIN AND VERIF1, AT LABEL 5470, A CONTINUE STATEMENT REPLACES
C      THE FORMER OPEN(21 ... STATEMENT. TO GET TO THIS POINT, FILE 21
C      WAS ALREADY OPENED, AND OPENED CORRECTLY WITH FILE=PATHFILE, NOT
C      THE NON-PATH XQZPJ001.ZMQ.

C  4. A CALL TO NEW SUBROUTINE PAUSE REPLACES EACH PAUSE STATEMENT. 
C  THIS IS BECAUSE A PAUSE STATEMENT CAUSES A WARNING WHEN THE PROGRAM
C  IS COMPILED AND LINKED USING gfortran (AND IT FORCES THE USER TO 
C  TYPE "go" INSTEAD OF SIMPLY HITTING THE ENTER KEY. 

    
C-----------------------------------------------------------------------

C  MONTBG18.FOR                                                9/3/10

C  MONTBG18 HAS THE FOLLOWING CHANGES FROM MONTBG17:

C  1. THE USER WILL NOW HAVE THE EXTRA OPTION TO INPUT THE MIXTURE OF 
C  DISTRIBUTIONS FROM WHICH THE PATIENTS WILL BE SIMULATED FROM THE 
C  OUTPUT OF A BIG NPAG RUN. IN THIS CASE, EACH DISTRIBUTION WILL 
C  CORRESPOND TO ONE OF THE ACTIVE GRID POINTS FROM THE FINAL CYCLE.
C  THE MEAN OF THE DIST. WILL BE THE COORDINATES OF THE GRID PT., THE
C  WEIGHT WILL BE THE PROBABILITY OF THE GRID PT., AND THE COV. MATRIX
C  WILL BE THE FINAL CYCLE COV. MATRIX FROM THE RUN, DIVIDED BY THE NO.
C  OF ACTIVE GRID POINTS ... IN THE IDEAL SETTING. BUT IF THE BIG NPAG
C  RUN HAS A FINAL CYCLE COV. MATRIX WHICH WAS NOT WRITTEN (BECAUSE ONE
C  OF THE ASSOCIATED VARIANCES WAS NUMERICALLY .LE. 0), THEN THE COV.
C  MATRIX FOR EACH DISTRIBUTION/GRID PT. WILL AUTOMATICALLY BE DIAGONAL
C  WITH EACH STD. DEV. = .25 * THE CORRESPONDING MEAN. ALSO, IF THE NO.
C  OF ACTIVE GRID POINTS IS > 30 (THE MAXIMUM VALUE FOR NGAUS), THE 
C  USER WILL BE ABLE TO STOP THE PROGRAM, OR HAVE IT CONTINUE USING JUST
C  THE FIRST 30 GRID POINTS.

C  TO AFFECT THE ABOVE OPTION, SUBROUTINE GETDIST HAS SEVERAL CHANGES,
C  AND IT CALLS NEW SUBROUTINE READNPAG (WHICH DOES THE ACTUAL READING
C  OF THE BIG NPAG OUTPUT FILE.

C  2. SUBROUTINE READBLOCK2 (BASED ON READBLOCK IN NPBG15E1.FOR) AND ALL
C  THE ROUTINES IT CALLS ARE ADDED TO THIS PROGRAM SO THAT THE USER MAY 
C  ENTER DOSE/COVARIATE AND OBS. TIME VALUES FOR THE SIMULATED PATIENTS
C  VIA A .CSV FILE, AS WELL AS THE OLD WAY (VIA A MULTIPLE DRUG WORKING
C  COPY PATIENT DATA FILE). IF THE USER CHOOSES THE NEW WAY, READBLOCK2
C  IS CALLED TO READ THE .CSV FILE AND CREATE A MULTIPLE DRUG WORKING

C  COPY PATIENT DATA FILE FROM THE INFO OF THE FIRST SUBJECT'S DATA

C  IN THE .CSV FILE. THIS FILE WILL THEN BE READ AND USED AS USUAL.

C  3. FUNCTIONS GASDEV AND RAN1 HAVE BEEN CHANGED BY WALTER YAMADA TO
C  FIX A COMPILER ISSUE RELATED TO GFORTRAN VS. G95. IN ADDITION, WALTER
C  HAS INCLUDED A NEW SUBROUTINE, INIT_RANDOM_SEED, WHICH IS CALLED BY 
C  THE NEW RAN1 (SEE COMMENTS IN THE CODE FOR THOSE FUNCTIONS/ROUTINE).
C  NOTE THAT THE NEW CODE WAS ORIGINALLY PART OF WALTER'S MCB17ALP.FOR
C  PROGRAM WHICH WAS TESTED AGAINST MONTBG17.FOR FOR THE FIRST TESTCASE
C  IN MONTBG17.EXP, AND GAVE THE SAME RESULTS.

C-----------------------------------------------------------------------

C  MONTBG17.FOR                                                8/1/10

C  MONTBG17 HAS TWO BUG CORRECTIONS TO MONTBG16, BOTH IN SUBROUTINE 
C  FUNC2:

C  1. IN THE   IF(TIMN(KNT) .EQ. 0.D0 .AND. SIGN(KNS) .EQ. 0.D0) BLOCK,
C  THE TIME, T, IS ALSO RESET = 0 SINCE THE INTEGRATION WILL AGAIN
C  START FROM TIME 0. WHEN THIS WASN'T DONE, THE RESULTS WERE
C  UNPREDICTABLE (DEPENDING ON HOW THE DVODE INTEGRATION ROUTINES
C  TREATED A (T,TOUT) PAIR WHICH DECREASED RATHER THAN INCREASED.

C  THIS IS THE SAME CHANGE THAT idm2x5.f MADE TO idm2x4.f.

C  2. THE BSN(.,.) VALUES ARE ESTABLISHED BELOW THE IF(NTL .EQ. 1)
C  BLOCK, RATHER THAN INSIDE IT, SINCE THESE VALUES MUST BE SET
C  REGARDLESS OF WHETHER OR NOT NTL = 1.

C-----------------------------------------------------------------------

C  MONTBG16.FOR							3/7/10

C  MONTBG16 IS AN EXTENSION TO MONTBG15. IT ALLOWS SIMULATION OF 
C  PATIENTS WITH MULTIPLE DRUGS (MONTBG15 WAS LIMITED TO SIMULATING

C  PATIENTS WITH A SINGLE DRUG). THE SPECIFIC CHANGES ARE:

C  1. THE TEMPLATE MODEL FILE WILL NOW BE TSTMULTG.FOR, RATHER THAN
C  INITCN22.FOR.

C  2. LOTS OF CHANGES ARE MADE IN THE IDCALCY/FUNC2/EVAL2 PART OFS
C  THE CODE, WHICH IS NOW BASED ON idm2x4.f (OF THE bigmlt5.f MULTIPLE
C  DRUG PROGRAM), RATHER THAN idcy_53f.f (OF THE big26.f SINGLE DRUG 
C  PROGRAM).

C  3. CHANGES ARE MADE THROUGHOUT THE PROGRAM WHEREVER THE WORKING COPY 
C  PATIENT DATA FILES OCCURS, SINCE THE MULTIPLE DRUG STRUCTURE IS
C  DIFFERENT THAN THE SINGLE DRUG STRUCTURE.

C-----------------------------------------------------------------------

C  MONTBG15.FOR						1/8/09

C  MONTBG15 HAS THE FOLLOWING IMPROVEMENT TO MONTBG14:

C  FILES MAY NOW BE UP TO 32 CHARACTERS IN LENGTH, RATHER THAN JUST
C  12. I.E., TMPFILE HAS BEEN CHANGED TO *32 FROM *12. IN FACT, ALL
C  FILES ARE ALSO CHANGED FROM *20 TO *32.


C  ALSO, SINCE PATHFILE IS THE CONCATENATION OF PATH + FILENAME, AND
C  PATH REMAINS *61, PATHFILE WILL NOW BE *93 INSTEAD OF *73.

C  NOTE THAT ALL A20 FORMATS ARE NOW CHANGED TO A32, AND ALL A73 FORMATS
C  ARE NOW A93.

C  NOTE ALSO THAT IN SUBROUTINE FULLNAME, THE DO I=1,73 IS CHANGED TO
C  DO I=1,93.

C-----------------------------------------------------------------------

C  SEE THE COMMENTS FOR PROGRAMS MONTBG14.FOR ... MONT5CL.FOR IN
C  MONTBG15.FOR, IF NEEDED.


C***********************************************************************

      IMPLICIT REAL*8(A-H,O-Z)

      PARAMETER(MAXDIM=30,MAXNUMEQ=7)

      DIMENSION VALFIX(20),AMEAN(150,30),COF(150),COV(150,30,30),


     1 IRAN(32),ATOL(20),C0(MAXNUMEQ),C1(MAXNUMEQ),C2(MAXNUMEQ),
     2 C3(MAXNUMEQ),CORR(30,30),BOUND(32,2),ILIMIT(32),XVERIFY(900)

      CHARACTER FILNFO*32,PREFIX*3,EXT*3,PAR(30)*11,PARFIX(20)*11,
     1   SAVFIL*32,FILOUT*32,FILEIN*32,PATH*61,TMPFILE*32,
     2   PATHFILE*93,CODE*14,FORFILE*32,OUTNPAG*20,OUTCSVNAME*32,
     3   TEXTFILE*20,ERRFIL*20

      COMMON/TOUSER/NDIM,MF,RTOL,ATOL
      COMMON/NOISE/ C0DT,C1DT,C2DT,C3DT,C0DA,C1DA,C2DA,C3DA,
     1   C0OT,C1OT,C2OT,C3OT

      COMMON/ERROR/ERRFIL
C  COMMON/ERROR/ IS SUPPLIED TO ALL THE ROUTINES WHICH COULD WRITE TO
C  ERRFIL. NOTE THAT ERRFIL IS SET = 'ERRORLOG' BELOW.

C Yamada 5/5/2010
C NOTE length of char array should be at least max expected + 1
C
      CHARACTER(LEN=20) :: OSName
      CHARACTER(LEN=5) :: CopyFile
      CHARACTER(LEN=4) :: DeleteFile
      CHARACTER(LEN=6) :: ClearScreen
      CHARACTER(LEN=10) :: ListDir
C
C Yamada 5/5/2010 ... The above are used for distinguishing

C    the Operating System and creating appropriate system calls.
C
C ------------------------------------------------------------
C Yamada 5/5/2010
C
C Initialize system calls here, e.g.:
C 1. CopyFile = COPY or cp
C 2. DeleteFile = DEL or rm
C
C NOTE the use of INDEX; be careful what substrings are allowed
C    for the ID of an operating system
C NOTE the extra space after each command; this makes it easier
C    to concatenate arguments to the system command.
C

      ERRFIL = 'ERRORLOG'


       CALL GET_COMMAND_ARGUMENT(1,OSName)
       IF ((INDEX(OSName,"MacOSX",.TRUE.).EQ.1)
     $ .OR.(INDEX(OSName,"Darwin",.TRUE.).EQ.1)
     $ .OR.(INDEX(OSName,"BSD",.TRUE.).EQ.1)) THEN
          PRINT *,"Requested OS is ", OSName
          OSName="UNIX"
          PRINT *,"Setting OS to ", OSName
          PRINT *,""
          CopyFile="cp "

          DeleteFile="rm "
          ClearScreen="clear "
          ListDir="ls -tp "
       ELSE IF ((INDEX(OSName,"DOS",.TRUE.).EQ.1)
     $ .OR.(INDEX(OSName,"WinXP",.TRUE.).EQ.1)
     $ .OR.(INDEX(OSName,"XP",.TRUE.).EQ.1)
     $ .OR.(INDEX(OSName,"WinXP",.TRUE.).EQ.1)
     $ .OR.(INDEX(OSName,"Vista",.TRUE.).EQ.1)
     $ .OR.(INDEX(OSName,"Win7",.TRUE.).EQ.1)) THEN
          PRINT *,"Requested OS is ", OSName
          OSName="DOS"
          PRINT *,"Setting OS to ", OSName
          CopyFile="COPY "
          DeleteFile="DEL "
          ClearScreen="CLS "
          ListDir="DIR /OD "
       ELSE
          PRINT *,"WARNING: Operating system not declared."
          PRINT *,"WARNING: Can not initialize system calls."
          PRINT *,""

          PRINT *,"Possible command line error, try:"
          PRINT *,"C:\> npbig.exe <DOS,Win,XP,Vista,or Win7>"
          PRINT *,"unix$ npbig <MacOSX,Darwin,BSD>"
          PRINT *,""
          PRINT *,"NPAG Exiting with status 2"
          PRINT *,""
          CALL EXIT(2)
       END IF
C ------------------------------------------------------------

C  COMMON/TOUSER IS SUPPLIED TO SUBROUTINE USERANAL.
C  COMMON/NOISE IS SUPPLIED TO SUBROUTINE FUNC2.

C  INPUT DATA FROM THE USER DIRECTLY, OR FROM AN INPUT FILE. THE 
C  FOLLOWING WILL BE ENTERED:

C  PREFIX = 3-CHARACTER PREFIX FOR ALL SUBJECT FILENAMES. THEN 
C           001, 002,... UP TO 10000  WILL COMPLETE THE 1ST NAMES OF THE 
C           INDIVIDUAL FILENAMES WHICH ARE READ IN.

C  EXT = AN OPTIONAL 3-CHARACTER EXTENSION (AFTER DECIMAL POINT) 


C	 FOR THE INPUT FILENAMES. 

C  ICSVFILE = 0 IF THE DOSAGE REGIMEN AND OBSERVATION TIMES FOR THE
C               SIMULATED SUBJECTS WILL BE INPUT USING A (MULTIPLE DRUG)
C               WORKING COPY PATIENT DATA FILE.
C           = 1 IF THIS INFO WILL BE INPUT USING A .CSV FILE. IN THIS
C               CASE, THE INFO WILL BE TAKEN FROM THE FIRST SUBJECT'S
C               DATA IN THE .CSV FILE.

C  FILEIN = THE NAME OF THE FILE WHICH HAS THE PATIENT DOSAGE REGIMEN
C           AND OBS. TIMES. IF ICSVFILE = 0, IT WILL BE A (WORKING COPY)
C           PATIENT DATA FILE; IF ICSVFILE = 1, IT WILL BE A .CSV FILE.


   
C  NSUB = NO. OF SUBJECT DATA FILES TO BE GENERATED. (MAX NO. = 999).

C  NVAR = NO. OF R.V.'S (1 .LE. NVAR .LE. MAXDIM).

C  NOFIX = NO. OF NON-RANDOM PARAMETERS WHOSE FIXED VALUES ARE TO BE SET
C	   BY THE USER. NOFIX MUST BE LESS THAN OR EQUAL TO 20.

C  VALFIX(I) = VALUE OF FIXED PARAMETER I, I=1,NOFIX.

C  C0(J),C1(J),C2(J),C3(J) = THE COEFFICIENTS FOR THE ASSAY STD. DEV. 
C   OF OUTPUT EQUATION J OF THE OUTPUT VALUES (THE C(J)'S ARE THE SAME 

C   FOR ALL SUBJECTS), J=1,NOS.

C  AF = ACTIVE (SALT) FRACTION OF THE DRUG.

C  INFO ON THE DISTRIBUTION OF THE SUBJECT VECTORS TO BE GENERATED. 
C  ASSUME EACH SUBJECT VECTOR COMES FROM A GAUSSIAN MIXTURE 
C  DISTRIBUTION, SUM[COF(I)*N(I)], I=1,NGAUS. WHERE THE SUM OF THE   
C  COEFFICIENTS, COF(I), IS 1.0, AND EACH N(I) IS AN NP-VARIATE NORMAL
C  DISTRIBUTION.

C  SO THE USER WILL ENTER NGAUS, COF(I), I=1,NGAUS, AND NGAUS SETS OF
C  MEAN VECTORS AND COVARIANCE MATRICES. OR THE USER MAY ENTER THE 
C  OUTPUT FILE FROM A BIG NPAG RUN, AND THE MIXTURE WILL BE TAKEN FROM
C  THE NACTVE FINAL CYCLE GRID PTS, AND THE FINAL CYCLE COV. MATRIX 
C  (IF IT EXISTS) - SEE CODE BELOW. 

C  AS OF MONTBIG2.FOR, THE USER WILL BE ABLE TO SIMULATE LOGNORMAL
C  VECTORS AS WELL AS NORMAL VECTORS. SEE CODE BELOW.

C  FILOUT = NAME OF FILE TO HOLD THE SUMMARY INFO FROM THE SIMULATION.
C
C-----------------------------------------------------------------------

  138   FORMAT(/' PLEASE ENTER ONE OF THE REQUESTED VALUES: ') 


    2 FORMAT(A32)
  222 FORMAT(A3)
 2222 FORMAT(A3)

C  CALL GETPATH TO GET FROM THE USER THE PATH WHERE THE INPUT FILES ARE
C  LOCATED (AND WHERE THE OUTPUT FILES WILL GO). NOTE THAT PATH IS THE
C  PATH WITH A TRAILING BACKSLASH, AND NOB IS THE NO. OF THE ENTRY WITH
C  THE LAST NON-BLANK ENTRY.

     	CALL GETPATH(PATH,NOB)



C  SET OUTNPAG TO ALL BLANKS. IF IT CHANGES AFTER A CALL TO GETDIST, IT
C  MEANS THAT IT CONTAINS THE NAME OF THE BIG NPAG OUTPUT FILE FROM 
C  WHICH THE NGAUS DISTRIBUTIONS WERE ESTABLISHED. SIMILARLY FOR
C  TEXTFILE WHICH, IF NOT ALL BLANKS, CONTAINS THE NAME OF THE TEXT FILE
C  WHICH HAS THE NGAUS DISTRIBUTIONS MEANS.

        OUTNPAG(1:20) = '                    '
        TEXTFILE(1:20) = '                    '

 
  145	WRITE(*,38)
   38   FORMAT(/' ENTER 0 IF INPUT IS TO BE FROM THE KEYBOARD; '/
     1' ENTER 1 IF INPUT IS TO BE FROM A FILE: ')
	READ(*,*,ERR=145) INOPT
      
	IF(INOPT .NE. 0 .AND. INOPT .NE. 1) THEN
	   WRITE(*,138)
	   GO TO 145 
	ENDIF

	IF(INOPT .EQ. 1) THEN

	 WRITE(*,39)
   39 	 FORMAT(/' ENTER THE NAME OF THE INSTRUCTION FILE; '/
     1' ENTER -99 TO SEE ALL OR A PART OF YOUR DIRECTORY: ')

	 READ(*,2) FILNFO
	 IF(FILNFO(1:3) .EQ. '-99') CALL SEEDIR(PATH,NOB,FILNFO,
     1      OSname,ListDir)

C  CALL FULLNAME WHICH CONVERTS THE FILENAME TO PATHFILE, THE COMPLETE 
C  NAME OF THE FILE, WHICH INCLUDES THE PATH (IF THE PATH IS NOT THE 
C  CURRENT DIRECTORY).

	 TMPFILE = ' '
	 TMPFILE = FILNFO
	 CALL FULLNAME(PATH,TMPFILE,PATHFILE)
	 OPEN(23,FILE=PATHFILE,ERR=6330,STATUS='OLD')
	 GO TO 6335
 6330    WRITE(*,5316) PATHFILE
 5316    FORMAT(//' THE FOLLOWING FILE DOES NOT EXIST ... '/
     1' ',A93)
	 GO TO 145
 6335    CONTINUE

C  READ ALL INPUT DATA FROM FILE FILNFO, WHICH WAS FILLED FROM A
C  PREVIOUS RUNNING OF THIS PROGRAM.

C  THE 1ST LINE IN FILNFO IS THE CODE WHICH GIVES THE VERSION NO. OF 

C  THE PROGRAM. 

	 READ(23,7123) CODE
 7123    FORMAT(A14)

	 ICODE = 0
	 IF(CODE .EQ. 'MONTBIG APR_04') ICODE = 01
	 IF(CODE .EQ. 'MONTBIG MAR_07') ICODE = 02
	 IF(CODE .EQ. 'MONTBIG JUN_08') ICODE = 03
	 IF(CODE .EQ. 'MONTBIG JUL_08') ICODE = 04
	 IF(CODE .EQ. 'MONTBIG AUG_08') ICODE = 05
       IF(CODE .EQ. 'MONTBIG SEP_10') ICODE = 06
       IF(CODE .EQ. 'MONTBIG MAY_11') ICODE = 07
       IF(CODE .EQ. 'MONTBIG JUN_11') ICODE = 08
       IF(CODE .EQ. 'MONTBIG MAR_12') ICODE = 09

	 IF(ICODE .LT. 5) THEN
	  WRITE(*,7124)

 7124   FORMAT(/' THIS FILE IS NOT AN UP-TO-DATE INSTRUCTION FILE'/
     1' FOR THIS PROGRAM. '//
     2' YOU HAVE THE FOLLOWING 2 OPTIONS:'//
     3' YOU MAY USE A SAVED INSTRUCTION FILE FROM A PREVIOUS RUNNING '/
     4' OF THIS PROGRAM. THE 1ST LINE OF THE SAVED FILE MUST HAVE '/
     5' MONTBIG XXX_XX, WHERE XXX_XX IS AUG_08 OR A MORE RECENT DATE.'//
     6' OR YOU MAY SIMPLY ENTER DATA FROM THE KEYBOARD.'/)
	  CALL PAUSE
	  GO TO 145
	 ENDIF



        IF(ICODE .GE. 7) THEN

C  SKIP THIS LINE. IT CONTAINS 'MODEL FILENAME '
         READ(23,*)

        ENDIF


	READ(23,2) FORFILE
	WRITE(*,919) FORFILE
  919   FORMAT(/' YOUR MODEL FILE, ',A32,' MUST BE AN EDITED VERSION'/
     1' OF THE TEMPLATE FILE, TSTMULTM.FOR. AND IT MUST ALREADY HAVE'/
     2' BEEN COMPILED AND LINKED WITH THIS PROGRAM. IF THIS IS NOT'/
     3' THE CASE, STOP NOW, AND THEN RERUN THE PROGRAM. '//
     4' NOTE THAT IF YOU USE A MODEL FILE BASED ON A PREVIOUS '/
     5' TEMPLATE FILE, YOUR RESULTS WILL BE UNPREDICTABLE.'///)

	CALL PAUSE


C  CALL FULLNAME WHICH CONVERTS THE FILENAME TO PATHFILE, THE COMPLETE 
C  NAME OF THE FILE, WHICH INCLUDES THE PATH (IF THE PATH IS NOT THE 
C  CURRENT DIRECTORY).


 5010	TMPFILE = ' '
	TMPFILE = FORFILE
	CALL FULLNAME(PATH,TMPFILE,PATHFILE)
        OPEN(28,FILE=PATHFILE,ERR=50,STATUS='OLD',POSITION='APPEND')
	GO TO 30
   50   WRITE(*,4406) FORFILE
 4406    FORMAT(//' THE FOLLOWING FILE DOES NOT EXIST ... '/

     1'    ',A93/
     2' ENTER THE CORRECT FILENAME OR ... '/
     2' ENTER -99 TO SEE ALL OR A PART OF YOUR DIRECTORY: ') 

	READ(*,2) FORFILE
	IF(FORFILE(1:3) .EQ. '-99') CALL SEEDIR(PATH,NOB,FORFILE,
     1     OSname,ListDir)

	GO TO 5010

   30	CALL USERPREP(NDIM,NP,NVAR,MAXDIM,PAR,NOFIX,PARFIX,IRAN,INOPT,
     1  ICODE,ILIMIT,BOUND)

	CLOSE(28)


C  THE ABOVE CALL OBTAINS THE FOLLOWING VALUES:


C  NDIM = NO. OF STATES FOR THE O.D.E.
C  NP = TOTAL NO. OF PARAMETERS = NVAR + NOFIX.
C  NVAR = NO. OF R.V.'S (1 .LE. NVAR .LE. MAXDIM).
C  PAR(I),I=1,NVAR = NAMES OF THE RANDOM VARIABLES FOR THIS RUN.

C  NOFIX = NO. OF NON-RANDOM (FIXED) PARAMETERS WHOSE FIXED VALUES ARE 

C          TO BE SET BY THE USER. 
C  PARFIX(I),I=1,NOFIX = NAMES OF FIXED PARAMETERS FOR THIS RUN.
C  IRAN(I) = 1 IF PARAMATER I IS RANDOM;
C	     0 IF PARAMETER I IS FIXED; I = 1,NVAR+NOFIX.
C  ILIMIT(I),I=1,NVAR = 1 IF VARIABLE I IS UNLIMITED IN ITS ALLOWED
C   SIMULATION VALUE; = 0 IF ITS SIMULATED VALUES ARE TO BE LIMITED.
C  BOUND(I,J),J=1,2; I=1,NVAR. IF LIMIT(I) = 0, THEN THE SIMULATED
C   VALUES FOR R.V. I (TO SIMULATE A SUBJECT) MUST BE WITHIN THE
C   BOUNDS, [BOUND(I,1), BOUND(I,2)].


        IF(ICODE .GE. 7) THEN


         IF(ICODE .EQ. 7) THEN
C  SKIP THIS LINE. IT CONTAINS 'PREFIX'
          READ(23,*)
          READ(23,2222) PREFIX
C  SKIP THIS LINE. IT CONTAINS 'EXT'.
          READ(23,*)
          READ(23,222) EXT
         ENDIF

C  SKIP THIS LINE. IT CONTAINS 'ICSVFILE'
         READ(23,*)
         READ(23,*) ICSVFILE

C  SKIP THIS LINE. IT CONTAINS 'FILEIN'
         READ(23,*)
         READ(23,2) FILEIN

C  CHECK THAT THIS IS AN EXISTING FILE.

C  CALL FULLNAME WHICH CONVERTS THE FILENAME TO PATHFILE, THE COMPLETE 
C  NAME OF THE FILE, WHICH INCLUDES THE PATH (IF THE PATH IS NOT THE 
C  CURRENT DIRECTORY).

        IF(ICSVFILE .EQ. 0) THEN


         TMPFILE = ' '
         TMPFILE = FILEIN
         CALL FULLNAME(PATH,TMPFILE,PATHFILE)
         OPEN(67,FILE=PATHFILE,ERR=8440,STATUS='OLD')
         GO TO 8455
 8440    WRITE(*,5316) PATHFILE

        OPEN(42,FILE=ERRFIL)
         WRITE(42,5316) PATHFILE 
        CLOSE(42)



         CALL PAUSE
         STOP
 8455    CLOSE(67)



        ENDIF

C  IF ICSVFILE = 1, CREATE THE MULTIPLE DRUG WORKING COPY FILE 
C  XQZPJ001.ZMQ IN THE WORKING COPY DIRECTORY FROM THE DATA OF THE 
C  FIRST SUBJECT IN PATHFILE. NOTE THAT READBLOCK2 BELOW IS BASED ON
C  READBLOCK IN THE NPAG PC PREP PROGRAM, BUT ONLY CREATES A WORKING
C  COPY FILE FOR THE FIRST SUBJECT.

        IF(ICSVFILE .EQ. 1) THEN

         TMPFILE = ' '
         TMPFILE = FILEIN
         CALL FULLNAME(PATH,TMPFILE,PATHFILE)
         OPEN(87,FILE=PATHFILE,STATUS='OLD')

C  AS OF MONT101F.FOR, BEFORE CALLING NEWCSV, MUST CALL CONVERTCSV,
C  WHICH CONVERTS A "EUROPEAN" .CSV FILE TO THE TYPICAL "AMERICAN"
C  VERSION. IF THE .CSV FILE IS ALREADY IN THE "AMERICAN" FORMAT,
C  CONVERTCSV SIMPLY REWRITES FILE 87 TO SCRATCH FILE 77. NOTE THAT
C  NEWCSV CONVERTS FILE 77 TO FILE 67.

        CALL CONVERTCSV

C  CALL SUBROUTINE NEWCSV WHICH CONVERTS THE .CSV FILE IN FILE 77 TO
C  A NEW .CSV FILE IN FILE 67, WITH ALL MISSING VALUE DOTS CHANGED TO
C  n's. THEN CALL CSVCHANGE WHICH CHANGES .csv FILES WITH CODE OF
C  POPDATA DEC_11 (I.E., THOSE WITH 2 EXTRA COLUMNS FOR ADDL AND II)
C  TO EQUIVALENT .csv FILES WITH CODE OF POPDATA APR_11 (THOSE WITHOUT
C  THE TWO EXTRA COLUMNS). CSVCHANGE READS FILE 67, AND WRITES THE 
C  INFORMATION TO SCRATCH FILE 66. NOTE THAT IF THE .csv FILE READ IN

C  ALREADY IS THE OLDER VERSION (WITH CODE POPDATA APR_11), CSVCHANGE


C  SIMPLY REWRITES IT TO FILE 66, WHICH IS THEN READ BY SUBROUTINE
C  READBLOCK2.


         OPEN(67)
         CALL NEWCSV
         CALL CSVCHANGE
         REWIND(66)
         CALL READBLOCK2(PATH,C0,C1,C2,C3)
         CLOSE(66)

C  NOW OPEN THE JUST MADE WORKING COPY PATIENT DATA FILE.

         TMPFILE = ' '
         TMPFILE = 'XQZPJ001.ZMQ'
         CALL FULLNAME(PATH,TMPFILE,PATHFILE)
         OPEN(21,FILE=PATHFILE,ERR=8465,STATUS='OLD')
         GO TO 8470
 8465    WRITE(*,5466) PATHFILE,FILEIN

        OPEN(42,FILE=ERRFIL)
         WRITE(42,5466) PATHFILE,FILEIN
        CLOSE(42)



         CALL PAUSE
         STOP

 8470    CONTINUE
         CLOSE(21)

        ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(ICSVFILE .EQ. 1) CONDITION.



C  SKIP THIS LINE. IT CONTAINS 'NSUB'.
         READ(23,*)
         READ(23,*) NSUB

C  NOTE THAT NOFIX WAS OBTAINED ABOVE IN THE CALL TO USERPREP, BUT IT
C  MUST BE READ IN BELOW SO MAURICE'S GUI WILL KNOW WHETHER THE 
C  FOLLOWING LINE CONTAINS FIXED VALUES OR NOT (AS OF MONTBIG7.FOR).
C  NOTE THAT MAURICE'S GUI IS NO LONGER UP TO DATE.

C  SKIP THIS LINE. IT CONTAINS 'NOFIX'.

         READ(23,*)
         READ(23,*) NOFIX

C  SKIP THIS LINE. IT CONTAINS 'VALFIX ARRAY IF NOFIX > 0'.
         READ(23,*)
         IF(NOFIX .GT. 0) READ(23,*) (VALFIX(I),I=1,NOFIX)

C  CHECK THAT NOFIX .LE. 20. IF NOT, PRINT MESSAGE TO USER AND STOP.

	 IF(NOFIX .GT. 20) THEN

	  WRITE(*,3177) NOFIX
 3177     FORMAT(/' NOFIX WAS READ IN FROM THE INSTRUCTION FILE TO '/
     1' BE ', I3,'. THIS IS > 20, THE MAXIMUM ALLOWED VALUE.'//
     2' PLEASE RERUN THE PROGRAM WITH KEYBOARD ENTRY, OR USE AN '/
     3' INSTRUCTION FILE HAVING NOFIX .LE. 20.')

        OPEN(42,FILE=ERRFIL)
         WRITE(42,3177) NOFIX
        CLOSE(42)



	  CALL PAUSE
	  STOP

	 ENDIF


C  SEE NOTES BELOW REGARDING MF,RTOL,ATOL.


C  SKIP THIS LINE. IT CONTAINS 'TOLER'.
         READ(23,*)
         READ(23,*) TOLER
	   RTOL = TOLER

         DO I=1,NDIM
          ATOL(I) = TOLER
         END DO

         MF = 22


C  SKIP THIS LINE. IT CONTAINS 'NUMEQT'.
         READ(23,*)
         READ(23,*) NUMEQT

C  SKIP THIS LINE. IT CONTAINS 'NUMEQT LINES OF ASSAY COEFFICIENTS'.
         READ(23,*)

         DO IEQ=1,NUMEQT
          READ(23,*) C0(IEQ),C1(IEQ),C2(IEQ),C3(IEQ)
         END DO

C  SKIP THIS LINE. IT CONTAINS 'ERROR COEFFS. FOR DOSE TIMES'.
         READ(23,*)
         READ(23,*) C0DT,C1DT,C2DT,C3DT
	
C  SKIP THIS LINE. IT CONTAINS 'ERROR COEFFS. FOR DOSE AMOUNTS'.
         READ(23,*)
         READ(23,*) C0DA,C1DA,C2DA,C3DA


C  SKIP THIS LINE. IT CONTAINS 'ERROR COEFFS. FOR OBSEVATION TIMES'.
         READ(23,*)
         READ(23,*) C0OT,C1OT,C2OT,C3OT

C  SKIP THIS LINE. IT CONTAINS 'IDIST'.

         READ(23,*)
         READ(23,*) IDIST


C  SKIP THIS LINE. IT CONTAINS 'NGAUS'
         READ(23,*)
         READ(23,*) NGAUS



C  SKIP THIS LINE. IT CONTAINS 
C   'NGAUS SETS OF COF(.), AMEAN(.,.), COV(.,.,.)'.
         READ(23,*)

         DO IGAUS=1,NGAUS
          READ(23,*) COF(IGAUS)

          READ(23,*) (AMEAN(IGAUS,I),I=1,NVAR)
           DO I=1,NVAR
            READ(23,*) (COV(IGAUS,I,J),J=1,I)
           END DO
         END DO

C  SKIP THIS LINE. IT CONTAINS 'FILOUT'.
         READ(23,*)
         READ(23,2) FILOUT


C  READ IN IPRNPAT.
C  IPRNPAT = 0 --> PATIENT FILES WILL NOT BE CREATED. THIS OPTION IS FOR
C   THOSE USERS WHO JUST WANT TO USE THE INFO WRITTEN TO THE OUPUT FILE.
C  IPRNPAT = 1 --> PATIENT INFO WILL BE WRITTEN TO A .CSV FILE OF THE
C                  USER'S CHOICE. THE PATIENT DATA FILES WHICH ARE
C                  CREATED WILL BE ERASED AFTER THE .CSV FILE IS MADE. 
C  IPRNPAT = 2 --> PATIENT FILES WILL BE CREATED, BUT A .CSV FILE WILL
C                  NOT BE MADE.
C  IPRNPAT = 3 --> PATIENT INFO WILL BE WRITTEN TO A .CSV FILE OF THE
C                  USER'S CHOICE, AND PATIENT FILES WILL ALSO BE
C                  CREATED.



C  SKIP THIS LINE. IT CONTAINS 'IPRNPAT'.
         READ(23,*)
         READ(23,*) IPRNPAT


         IF(ICODE .EQ. 7) THEN
          IF(IPRNPAT .EQ. 1) IPRNPAT = 2
         ENDIF

         IF(ICODE .GE. 8) THEN

C  SKIP THIS LINE. IT CONTAINS 'OUTCSVNAME'
          READ(23,*)
          READ(23,2) OUTCSVNAME
C  NOTE THAT OUTCSVNAME WILL NOT BE USED UNLESS IPRNPAT = 1 OR 3.


C  SKIP THIS LINE. IT CONTAINS 'PREFIX'
          READ(23,*)

 
          READ(23,2222) PREFIX
C  SKIP THIS LINE. IT CONTAINS 'EXT'.
          READ(23,*)
          READ(23,222) EXT
C  NOTE THAT PREFIX AND EXT WILL NOT BE USED UNLESS IPRNPAT = 2 OR 3.

         ENDIF

C  SKIP THIS LINE. IT CONTAINS 'ISEEDIND'.


         READ(23,*)
         READ(23,*) ISEEDIND

C  AS OF MONTBIG9.FOR, THE SEED INDICATOR, ISEEDIND IS READ IN. IF
C  ISEEDIND = 1, THIS PROGRAM WILL USE THE DEFAULT SEED = -17;

C  ISEEDIND = 0, THIS PROGRAM WILL USE THE SEED NO. STORED INTO
C    SEEDTO.MON (AND UPDATE THE VALUE IN THAT FILE BY -123 FOR THE
C    NEXT RUN).




         CLOSE(23)

         GO TO 7300

        ENDIF 


C  THE ABOVE ENDIF IS FOR THE  IF(ICODE .GE. 7)  CONDITION


C THE CODE BELOW IS FOR THE ICODE .LT. 7 CASE.

        READ(23,2222) PREFIX

        READ(23,222) EXT

        IF(ICODE .LT. 6) ICSVFILE = 0
        IF(ICODE .GE. 6) READ(23,*) ICSVFILE

	 READ(23,2) FILEIN


C  CHECK THAT THIS IS AN EXISTING FILE.

C  CALL FULLNAME WHICH CONVERTS THE FILENAME TO PATHFILE, THE COMPLETE 

C  NAME OF THE FILE, WHICH INCLUDES THE PATH (IF THE PATH IS NOT THE 
C  CURRENT DIRECTORY).

        IF(ICSVFILE .EQ. 0) THEN
         TMPFILE = ' '
         TMPFILE = FILEIN
         CALL FULLNAME(PATH,TMPFILE,PATHFILE)
         OPEN(67,FILE=PATHFILE,ERR=7440,STATUS='OLD')
         GO TO 7455

 7440    WRITE(*,5316) PATHFILE

        OPEN(42,FILE=ERRFIL)
         WRITE(42,5316) PATHFILE 
        CLOSE(42)



         CALL PAUSE
         STOP

 7455    CLOSE(67)



        ENDIF

C  IF ICSVFILE = 1, CREATE THE MULTIPLE DRUG WORKING COPY FILE 
C  XQZPJ001.ZMQ IN THE WORKING COPY DIRECTORY FROM THE DATA OF THE 
C  FIRST SUBJECT IN PATHFILE. NOTE THAT READBLOCK2 BELOW IS BASED ON
C  READBLOCK IN THE NPAG PC PREP PROGRAM, BUT ONLY CREATES A WORKING
C  COPY FILE FOR THE FIRST SUBJECT.


        IF(ICSVFILE .EQ. 1) THEN


         TMPFILE = ' '
         TMPFILE = FILEIN
         CALL FULLNAME(PATH,TMPFILE,PATHFILE)
         OPEN(87,FILE=PATHFILE,STATUS='OLD')


C  AS OF MONT101F.FOR, BEFORE CALLING NEWCSV, MUST CALL CONVERTCSV,
C  WHICH CONVERTS A "EUROPEAN" .CSV FILE TO THE TYPICAL "AMERICAN"
C  VERSION. IF THE .CSV FILE IS ALREADY IN THE "AMERICAN" FORMAT,
C  CONVERTCSV SIMPLY REWRITES FILE 87 TO SCRATCH FILE 77. NOTE THAT
C  NEWCSV CONVERTS FILE 77 TO FILE 67.

        CALL CONVERTCSV

C  CALL SUBROUTINE NEWCSV WHICH CONVERTS THE .CSV FILE IN FILE 77 TO
C  A NEW .CSV FILE IN FILE 67, WITH ALL MISSING VALUE DOTS CHANGED TO
C  n's. THEN CALL CSVCHANGE WHICH CHANGES .csv FILES WITH CODE OF
C  POPDATA DEC_11 (I.E., THOSE WITH 2 EXTRA COLUMNS FOR ADDL AND II)
C  TO EQUIVALENT .csv FILES WITH CODE OF POPDATA APR_11 (THOSE WITHOUT
C  THE TWO EXTRA COLUMNS). CSVCHANGE READS FILE 67, AND WRITES THE 
C  INFORMATION TO SCRATCH FILE 66. NOTE THAT IF THE .csv FILE READ IN
C  ALREADY IS THE OLDER VERSION (WITH CODE POPDATA APR_11), CSVCHANGE
C  SIMPLY REWRITES IT TO FILE 66, WHICH IS THEN READ BY SUBROUTINE
C  READBLOCK2.

         OPEN(67)
         CALL NEWCSV
         CALL CSVCHANGE
         REWIND(66)
         CALL READBLOCK2(PATH,C0,C1,C2,C3)
         CLOSE(66)

C  NOW OPEN THE JUST MADE WORKING COPY PATIENT DATA FILE.

         TMPFILE = ' '
         TMPFILE = 'XQZPJ001.ZMQ'
         CALL FULLNAME(PATH,TMPFILE,PATHFILE)
         OPEN(21,FILE=PATHFILE,ERR=7465,STATUS='OLD')
         GO TO 7470

 7465    WRITE(*,5466) PATHFILE,FILEIN

        OPEN(42,FILE=ERRFIL)
         WRITE(42,5466) PATHFILE,FILEIN
        CLOSE(42)



         CALL PAUSE

         STOP

 7470    CONTINUE
         CLOSE(21)

        ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(ICSVFILE .EQ. 1) CONDITION.

	 READ(23,*) NSUB

C  NOTE THAT NOFIX WAS OBTAINED ABOVE IN THE CALL TO USERPREP, BUT IT
C  MUST BE READ IN BELOW SO MAURICE'S GUI WILL KNOW WHETHER THE 
C  FOLLOWING LINE CONTAINS FIXED VALUES OR NOT (AS OF MONTBIG7.FOR).

	 READ(23,*) NOFIX
	 IF(NOFIX .GT. 0) READ(23,*) (VALFIX(I),I=1,NOFIX)

C  CHECK THAT NOFIX .LE. 20. IF NOT, PRINT MESSAGE TO USER AND STOP.

	 IF(NOFIX .GT. 20) THEN



	  WRITE(*,3177) NOFIX

        OPEN(42,FILE=ERRFIL)
         WRITE(42,3177) NOFIX    
        CLOSE(42)



	  CALL PAUSE
	  STOP



	 ENDIF


C  READ IN VALUES FOR MF, RTOL, AND ATOL, WHICH ARE NEEDED FOR THE 
C  O.D.E. SOLVER USED BY ROUTINE USERANAL (IN MODULE SIMBIG.FOR).

C MF     = Method flag.  Standard values are..
C          10 for nonstiff (Adams) method, no Jacobian used.
C          21 for stiff (BDF) method, user-supplied full Jacobian.


C          22 for stiff method, internally generated full Jacobian.

C	   FOR NOW MF = 22 WILL BE HARDCODED (SINCE THERE IS NO
C	   JACOBIAN SUBROUTINE (JACOB HAS BEEN TAKEN OUT FOR NOW).


C          24 for stiff method, user-supplied banded Jacobian.

C          25 for stiff method, internally generated banded Jacobian.
C RTOL   = Relative tolerance parameter (scalar).
C ATOL   = Absolute tolerance parameter.

C          The estimated local error in X(i) will be controlled so as
C          to be roughly less (in magnitude) than
C             EWT(i) = RTOL*abs(X(i)) + ATOL(i)  SINCE ITOL = 2.
C          Thus the local error test passes if, in each component,

C          either the absolute error is less than ATOL (or ATOL(i)),
C          or the relative error is less than RTOL.
C          Use RTOL = 0.0 for pure absolute error control, and
C          use ATOL = 0.0 (or ATOL(i) = 0.0) for pure relative error
C          control.  Caution.. Actual (global) errors may exceed these

C          local tolerances, so choose them conservatively.


	 READ(23,*) TOLER
	
	 RTOL = TOLER


	 DO I=1,NDIM
	  ATOL(I) = TOLER
	 END DO

	 MF = 22

	 READ(23,*) NUMEQT



	 DO IEQ=1,NUMEQT
	  READ(23,*) C0(IEQ),C1(IEQ),C2(IEQ),C3(IEQ)

	 END DO

	 READ(23,*) C0DT,C1DT,C2DT,C3DT
	 READ(23,*) C0DA,C1DA,C2DA,C3DA
	 READ(23,*) C0OT,C1OT,C2OT,C3OT

	 READ(23,*) IDIST
	 READ(23,*) NGAUS


	 DO IGAUS=1,NGAUS

	  READ(23,*) COF(IGAUS)
	  READ(23,*) (AMEAN(IGAUS,I),I=1,NVAR)
	   DO I=1,NVAR
          READ(23,*) (COV(IGAUS,I,J),J=1,I)
	   END DO
	 END DO

	 READ(23,2) FILOUT

C  READ IN IPRNPAT - SEE ABOVE.

	 READ(23,*) IPRNPAT
       IF(IPRNPAT .EQ. 1) IPRNPAT = 2

	 READ(23,*) ISEEDIND

C  AS OF MONTBIG9.FOR, THE SEED INDICATOR, ISEEDIND IS READ IN. IF


C  ISEEDIND = 1, THIS PROGRAM WILL USE THE DEFAULT SEED = -17;
C  ISEEDIND = 0, THIS PROGRAM WILL USE THE SEED NO. STORED INTO
C    SEEDTO.MON (AND UPDATE THE VALUE IN THAT FILE BY -123 FOR THE
C    NEXT RUN).

	 CLOSE(23)


	ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(INOPT .EQ. 1)  CONDITION.


	IF(INOPT .EQ. 0) THEN


C  INPUT THE NAME OF THE FORTRAN FILE WHICH HAS ALREADY BEEN LINKED
C  INTO THIS PROGRAM (SEE FORMAT 919 ABOVE). THIS FILE, IDENTIFIES THE 
C  MODEL AND THE PARAMETERS FOR THE USER'S ANALYSIS. THEN CALL 
C  SUBROUTINE USERPREP TO INPUT VALUES FROM THIS FILE.

        WRITE(*,5001)
 5001   FORMAT(/' ENTER THE NAME OF THE FORTRAN FILE WHICH HAS BEEN'/
     1' LINKED WITH THIS PROGRAM. NOTE THAT IT MUST BE AN EDITED '/
     2' VERSION OF THE TEMPLATE FILE, TSTMULTM.FOR. IF THIS IS NOT'/
     3' THE CASE, STOP NOW, AND THEN RERUN THE PROGRAM. '//
     4' NOTE THAT IF YOU USE A MODEL FILE BASED ON A PREVIOUS '/
     5' TEMPLATE FILE, YOUR RESLTS WILL BE UNPREDICTABLE.'///
     6' ENTER YOUR MODEL FILE NOW IF IT IS AN EDITED VERSION OF '/
     7' TSTMULTM.FOR: ')

     	  READ(*,2) FORFILE

C  CALL FULLNAME WHICH CONVERTS THE FILENAME TO PATHFILE, THE COMPLETE 
C  NAME OF THE FILE, WHICH INCLUDES THE PATH (IF THE PATH IS NOT THE 

C  CURRENT DIRECTORY).



 9010	TMPFILE = ' '
	TMPFILE = FORFILE
	CALL FULLNAME(PATH,TMPFILE,PATHFILE)
        OPEN(28,FILE=PATHFILE,ERR=950,STATUS='OLD',POSITION='APPEND')
	GO TO 930
  950   WRITE(*,4406) FORFILE
	READ(*,2) FORFILE
	IF(FORFILE(1:3) .EQ. '-99') CALL SEEDIR(PATH,NOB,FORFILE,
     1     OSname,ListDir)
	GO TO 9010


  930	CALL USERPREP(NDIM,NP,NVAR,MAXDIM,PAR,NOFIX,PARFIX,IRAN,INOPT,
     1  ICODE,ILIMIT,BOUND)

	CLOSE(28)

C  THE ABOVE CALL OBTAINS THE FOLLOWING VALUES:

C  NDIM = NO. OF STATES FOR THE O.D.E.
C  NP = TOTAL NO. OF PARAMETERS = NVAR + NOFIX.
C  NVAR = NO. OF R.V.'S (1 .LE. NVAR .LE. MAXDIM).
C  PAR(I),I=1,NVAR = NAMES OF THE RANDOM VARIABLES FOR THIS RUN.

C  NOFIX = NO. OF NON-RANDOM (FIXED) PARAMETERS WHOSE FIXED VALUES ARE 
C          TO BE SET BY THE USER. 
C  PARFIX(I),I=1,NOFIX = NAMES OF FIXED PARAMETERS FOR THIS RUN.

C  IRAN(I) = 1 IF PARAMATER I IS RANDOM;
C	     0 IF PARAMETER I IS FIXED; I = 1,NVAR+NOFIX.
C  ILIMIT(I),I=1,NVAR = 1 IF VARIABLE I IS UNLIMITED IN ITS ALLOWED
C   SIMULATION VALUE; = 0 IF ITS SIMULATED VALUES ARE TO BE LIMITED.
C  BOUND(I,J),J=1,2; I=1,NVAR. IF LIMIT(I) = 0, THEN THE SIMULATED
C   VALUES FOR R.V. I (TO SIMULATE A SUBJECT) MUST BE WITHIN THE
C   BOUNDS, [BOUND(I,1), BOUND(I,2)].



 5020   WRITE(*,5002)
 5002   FORMAT(/' THE DOSE/COVARIATE AND OBSERVATION TIME INFORMATION'/
     1' WHICH WILL BE USED TO SIMULATE THE PATIENT DATA FILES CAN BE'/
     2' INPUT VIA A (MULTIPLE DRUG) WORKING COPY PATIENT DATA FILE OR'/
     3' VIA A BLOCK MATRIX .CSV FILE (THE INFO WILL COME FROM THE '/
     4' DATE OF THE FIRST SUBJECT IN THIS CASE).'//
     5' ENTER 1 TO ENTER INFO USING A .CSV FILE; '/

     6' ENTER 0 TO ENTER INFO USING A WORKING COPY PATIENT DATA FILE: ')
        READ(*,*,ERR=5020) ICSVFILE
        IF(ICSVFILE .NE. 1 .AND. ICSVFILE .NE. 0) GO TO 5020



        IF(ICSVFILE .EQ. 0) THEN


        WRITE(*,1021)
 1021   FORMAT(/' ENTER THE NAME OF THE WORKING COPY PATIENT DATA FILE'/
     1' WHICH CONTAINS THE DOSE/COVARIATE INFORMATION WHICH WILL BE'/
     2' USED TO SIMULATE THE PATIENT DATA FILES.'//
     3' BE SURE THAT THIS IS A MULTI-DRUG WORKING COPY DATA FILE.'//
     1' ENTER -99 TO SEE ALL OR A PART OF YOUR DIRECTORY: ')
     	  READ(*,2) FILEIN
        IF(FILEIN(1:3) .EQ. '-99') CALL SEEDIR(PATH,NOB,FILEIN,
     1     OSname,ListDir)


C  CHECK THAT THIS IS AN EXISTING FILE.

C  CALL FULLNAME WHICH CONVERTS THE FILENAME TO PATHFILE, THE COMPLETE 
C  NAME OF THE FILE, WHICH INCLUDES THE PATH (IF THE PATH IS NOT THE 
C  CURRENT DIRECTORY).

	TMPFILE = ' '
	TMPFILE = FILEIN
	CALL FULLNAME(PATH,TMPFILE,PATHFILE)

	OPEN(21,FILE=PATHFILE,ERR=6440,STATUS='OLD')
	GO TO 6455
 6440   WRITE(*,5316) PATHFILE
	GO TO 5020
 6455   CONTINUE

        ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(ICSVFILE .EQ. 0) CONDITION.


        IF(ICSVFILE .EQ. 1) THEN


        WRITE(*,3021)
 3021   FORMAT(/' ENTER THE NAME OF THE BLOCK MATRIX .CSV FILE. ONLY'/
     1' THE DATA FROM THE FIRST SUBJECT IN THIS FILE WILL BE READ TO'/
     2' OBTAIN THE DOSE/COVARIATE INFORMATION WHICH WILL BE USED TO'/
     3' TO SIMULATE THE PATIENT DATA FILES.'//
     1' ENTER -99 TO SEE ALL OR A PART OF YOUR DIRECTORY: ')
     	  READ(*,2) FILEIN
        IF(FILEIN(1:3) .EQ. '-99') CALL SEEDIR(PATH,NOB,FILEIN,
     1     OSname,ListDir)

C  CHECK THAT THIS IS AN EXISTING FILE.


C  CALL FULLNAME WHICH CONVERTS THE FILENAME TO PATHFILE, THE COMPLETE 
C  NAME OF THE FILE, WHICH INCLUDES THE PATH (IF THE PATH IS NOT THE 
C  CURRENT DIRECTORY).

        TMPFILE = ' '
        TMPFILE = FILEIN
        CALL FULLNAME(PATH,TMPFILE,PATHFILE)
        OPEN(87,FILE=PATHFILE,ERR=5440,STATUS='OLD')
        GO TO 5455
 5440   WRITE(*,5316) PATHFILE
        GO TO 5020
 5455   CONTINUE

C  AS OF MONT101F.FOR, BEFORE CALLING NEWCSV, MUST CALL CONVERTCSV,
C  WHICH CONVERTS A "EUROPEAN" .CSV FILE TO THE TYPICAL "AMERICAN"
C  VERSION. IF THE .CSV FILE IS ALREADY IN THE "AMERICAN" FORMAT,
C  CONVERTCSV SIMPLY REWRITES FILE 87 TO SCRATCH FILE 77. NOTE THAT
C  NEWCSV CONVERTS FILE 77 TO FILE 67.

        CALL CONVERTCSV


C  CALL SUBROUTINE NEWCSV WHICH CONVERTS THE .CSV FILE IN FILE 77 TO
C  A NEW .CSV FILE IN FILE 67, WITH ALL MISSING VALUE DOTS CHANGED TO
C  n's. THEN CALL CSVCHANGE WHICH CHANGES .csv FILES WITH CODE OF
C  POPDATA DEC_11 (I.E., THOSE WITH 2 EXTRA COLUMNS FOR ADDL AND II)
C  TO EQUIVALENT .csv FILES WITH CODE OF POPDATA APR_11 (THOSE WITHOUT
C  THE TWO EXTRA COLUMNS). CSVCHANGE READS FILE 67, AND WRITES THE 
C  INFORMATION TO SCRATCH FILE 66. NOTE THAT IF THE .csv FILE READ IN
C  ALREADY IS THE OLDER VERSION (WITH CODE POPDATA APR_11), CSVCHANGE
C  SIMPLY REWRITES IT TO FILE 66, WHICH IS THEN READ BY SUBROUTINE
C  READBLOCK2.

         OPEN(67)
         CALL NEWCSV
         CALL CSVCHANGE
         REWIND(66)
         CALL READBLOCK2(PATH,C0,C1,C2,C3)
         CLOSE(66)


C  NOW OPEN THE JUST MADE WORKING COPY PATIENT DATA FILE.

        TMPFILE = ' '
        TMPFILE = 'XQZPJ001.ZMQ'
        CALL FULLNAME(PATH,TMPFILE,PATHFILE)
        OPEN(21,FILE=PATHFILE,ERR=5465,STATUS='OLD')
        GO TO 5470
 5465   WRITE(*,5466) PATHFILE,FILEIN
 5466   FORMAT(//' THE FOLLOWING FILE DOES NOT EXIST ... '/
     1' ',A93/
     2' WHICH MEANS THAT YOUR .CSV FILE, ',A20,' WAS NOT READ '/
     3' PROPERLY. PLEASE CHECK THIS FILE TO MAKE SURE IT IS CORRECT.'//)
        GO TO 5020

 5470   CONTINUE

        ENDIF


C  THE ABOVE ENDIF IS FOR THE  IF(ICSVFILE .EQ. 1) CONDITION.



C  CALL SUBROUTINE GETNUMEQ, WHICH READS FILE 21 OPENED ABOVE TO GET
C  THE NO. OF OUTPUT EQUATIONS (NUMEQT). 

	CALL GETNUMEQ(NUMEQT)
	CLOSE(21)


        WRITE(*,21) 
   21   FORMAT(/' ENTER THE NO. OF SUBJECTS TO BE SIMULATED. THIS '/
     1' NUMBER MUST BE LESS THAN OR EQUAL TO 10000.'//
     2' NOTE THAT IF YOU SELECT TO HAVE ONE SUBJECT SIMULATED WITH'/
     3' EXACTLY THE PARAMETER VALUES OF EACH GRID PT. FROM THE LAST'/
     4' CYCLE OF AN NPAG RUN, THIS VALUE WILL BE IRRELEVANT: ')

 4070	READ(*,*,ERR=4075) NSUB
        GO TO 4078
 4075	WRITE(*,4076)
 4076	FORMAT(/' SEE ABOVE; ENTER AN INTEGER BETWEEN 1 AND 10000: ')
	GO TO 4070



 4078	IF(NSUB .LE. 0 .OR. NSUB .GT. 10000) GO TO 4075


	IF(NOFIX .GT. 0) THEN
	  WRITE(*,4836) NOFIX
 4836     FORMAT(/' ENTER, THE ',I2,' FIXED PARAMETER VALUES: ')
	  DO 9190 I=1,NOFIX
	  WRITE(*,2112) PARFIX(I)
 2112     FORMAT(/' ',A11,': ')
 7110     READ(*,*,ERR=7115) VALFIX(I)
	  GO TO 9190
 7115     WRITE(*,7116)
 7116     FORMAT(/' SEE ABOVE; ENTER A NON-NEGATIVE NUMBER: ')
	  GO TO 7110
 9190     CONTINUE
	ENDIF


  915   WRITE(*,913)
  913   FORMAT(/' ENTER 1 TO SET ALL TOLERANCES (FOR THE O.D.E. '/
     1'         SOLVER) TO THE DEFAULT VALUE ... 1.D-4.'/
     2' ENTER 0 TO SELECT A DIFFERENT VALUE FOR THE TOLERANCES: ')
	READ(*,*,ERR=915) ITOL
	IF(ITOL .NE. 0 .AND. ITOL .NE. 1) GO TO 915



	TOLER=1.D-4

	IF(ITOL .EQ. 0) THEN

  910	WRITE(*,914) 
  914  FORMAT(/' ENTER A POSITIVE VALUE FOR THE TOLERANCE PARAMETERS: ')
	READ(*,*,ERR=910) TOLER
	IF(TOLER .LE. 0.D0) GO TO 910

	ENDIF

	RTOL = TOLER
	DO I=1,NDIM
	 ATOL(I) = TOLER
	END DO


	MF = 22


	WRITE(*,19) 
   19 FORMAT(//' FOR EACH OUTPUT EQUATION, ENTER, IN ORDER, '/
     1' C0,C1,C2,C3, WHERE, FOR EACH OBSERVED VALUE, Y, THE ASSAY'/
     3' STANDARD DEVIATION IS SD = C0+C1*Y+C2*Y**2+C3*Y**3):')

	DO IEQ = 1,NUMEQT
	 WRITE(*,1119) IEQ
 1119    FORMAT(/' ENTER THE VALUES FOR [C0,C1,C2,C3] FOR OUTPUT'/
     1'  EQUATION ',I1,': ')
 4140    READ(*,*,ERR=4145) C0(IEQ),C1(IEQ),C2(IEQ),C3(IEQ)
   	 GO TO 2120
 4145    WRITE(*,4146)
 4146    FORMAT(/' SEE ABOVE; PLEASE ENTER FOUR REAL NUMBERS: ')
	 GO TO 4140
 2120	 CONTINUE
	END DO


 2020	WRITE(*,219)
  219 FORMAT(//' THE DOSE TIMES, THE DOSE AMOUNTS (INCLUDING ALL BOLUS'/
     1' VALUES AND THE IV RATE WHICH IS ASSUMED TO BE THE 2ND ENTRY'/
     2' IN EACH DOSE ROW), AND THE OBSERVATION TIMES WHICH THE PROGRAM'/
     3' HAS READ FROM THE WORKING COPY PATIENT DATA FILE ABOVE WILL '/
     4' ALL BE ASSUMED TO BE "NOISY" VALUES.'//
     5' ENTER 0 FOR AN EXPLANATION OF HOW THE "NOISY" VALUES ARE OBTAINE

     1D.'/
     6' ENTER 1 TO CONTINUE: ')
	READ(*,*,ERR= 2020) ICONT

	IF(ICONT .NE. 0 .AND. ICONT .NE. 1) GO TO 2020

	IF(ICONT .EQ. 0) CALL EXPLAINOISE

	WRITE(*,6223)
 6223   FORMAT(/' ENTER C0,C1,C2,C3 FOR THE DOSE TIMES: ')
 6140   READ(*,*,ERR=6145) C0DT,C1DT,C2DT,C3DT
   	GO TO 6120
 6145   WRITE(*,4146)
	GO TO 6140
 6120	CONTINUE

	WRITE(*,7223)
 7223   FORMAT(/' ENTER C0,C1,C2,C3 FOR THE DOSE AMOUNTS: ')
 7140   READ(*,*,ERR=7145) C0DA,C1DA,C2DA,C3DA
   	GO TO 7120
 7145   WRITE(*,4146)
	GO TO 7140
 7120	CONTINUE

	WRITE(*,8223)
 8223   FORMAT(/' ENTER C0,C1,C2,C3 FOR THE OBSERVATION TIMES: ')
 8140   READ(*,*,ERR=8145) C0OT,C1OT,C2OT,C3OT
   	GO TO 8120
 8145   WRITE(*,4146)
	GO TO 8140


 8120	CONTINUE



C  CALL GETDIST TO OBTAIN THE DESIRED DISTRIBUTION DETAILS FROM THE 
C  USER.

	CALL GETDIST(IDIST,NGAUS,NVAR,COF,AMEAN,COV,PATH,NOB,OUTNPAG,
     1 TEXTFILE,OSname,ListDir)

      WRITE(*,1117)
 1117 FORMAT(/,' ENTER THE OUTPUT FILENAME WHICH WILL CONTAIN ALL THE'/
     1' GENERATED DATA OF THIS PROGRAM: ')

      READ(*,2) FILOUT

C  FILOUT WILL CONTAIN, FOR EACH OF THE NSUB PATIENTS:

C      ALF(I),I=1,NP, THE GENERATED PARAMETER VALUES. 
C      AS(J,K), J=1,M; K=1,NOS THE N(0,1) VALUES USED IN 
C             ESTABLISHING THE ASSAY NOISE VALUES (M = NO. OF 
C             OBSERVATION TIMES; K = NO. OF OUTPUT EQUATIONS; THEY

C	      ARE INPUT IN SUBROUTINE INOUT). 
C      Y(J,K), J=1,M; K=1,NOS = THE OUTPUT CONCENTRATIONS (WHICH HAVE
C             BEEN 'CORRUPTED' WITH THE ASSAY NOISE.


C  READ IN IPRNPAT ... SEE COMMENTS ABOVE.

 1230	  WRITE(*,1234) NSUB,NSUB
 1234   FORMAT(/' ENTER 1 IF YOU WOULD LIKE THE INFORMATION FROM '/
     1'         THE ',I5,' SIMULATED PATIENT DATA FILES TO BE SAVED'/
     2'         IN BLOCK FORMAT TO A .CSV FILE; '/
     3' ENTER 2 IF YOU WOULD LIKE TO CREATE THE ',I5,' SIMULATED '/
     4'         PATIENT DATA FILES IN WORKING COPY FORMAT; '/
     5' ENTER 3 IF YOU WOULD LIKE BOTH A .CSV FILE AND A SET OF '/


     6'         WORKING COPY FILES TO BE MADE;'/
     7' ENTER 0 IF YOU DO NOT NEED A .CSV FILE OR A SET OF WORKING '/
     8'         COPY FILES (I.E., YOU ONLY NEED THE INFO THAT IS '/
     9'         SUPPLIED IN THE OUTPUT FILE): ')
        READ(*,*,ERR=1230) IPRNPAT
        IF(IPRNPAT .LT. 0 .OR. IPRNPAT .GT. 3) GO TO 1230

        IF(IPRNPAT .EQ. 1 .OR. IPRNPAT .EQ. 3) THEN

 1390    WRITE(*,1236)
 1236    FORMAT(/' ENTER THE NAME OF THE FILE WHICH WILL STORE THE'/
     1' SIMULATED INFO IN .CSV FORMAT: ')
         
         READ(*,2) OUTCSVNAME

C  CALL FULLNAME WHICH CONVERTS THE FILENAME TO PATHFILE, THE COMPLETE 
C  NAME OF THE FILE, WHICH INCLUDES THE PATH (IF THE PATH IS NOT THE 
C  CURRENT DIRECTORY).

 1380	   TMPFILE = ' '
         TMPFILE = OUTCSVNAME
         CALL FULLNAME(PATH,TMPFILE,PATHFILE)
         OPEN(29,FILE=PATHFILE,ERR=1370,STATUS='NEW')
         GO TO 1375
 1370    WRITE(*,9826) PATHFILE
         READ(*,*,ERR=1370) IFILE
         IF(IFILE .NE. 0 .AND. IFILE .NE. 1) GO TO 1370

         IF(IFILE .EQ. 0) GO TO 1390
         IF(IFILE .EQ. 1) OPEN(29,FILE=PATHFILE)


 1375    CLOSE(29)


        ENDIF

        
        IF(IPRNPAT .EQ. 2 .OR. IPRNPAT .EQ. 3) THEN

         WRITE(*,4041)
 4041    FORMAT(/' ENTER THE 3-CHAR PREFIX FOR THE SIMULATED PATIENT'/
     1' FILENAMES : ')
         READ(*,2222) PREFIX

         WRITE(*,4043)
 4043	   FORMAT(/' IF THERE IS A 3-CHAR EXTENSION FOR THE PATIENT '/
     1' FILENAMES, ENTER IT NOW; OTHERWISE, PRESS ENTER: ')
         READ(*,222) EXT


        ENDIF

    
 1240	WRITE(*,1231)
 1231   FORMAT(/' ENTER 1 IF YOU WISH THE STARTING SEED NO. FOR THE'/
     1' 	SIMULATOR TO BE THE DEFAULT VALUE OF -17;'/

     2' ENTER 0 IF YOU WISH THE STARTING SEED NO. TO BE READ FROM'/
     3'		THE FILE, "SEEDTO.MON" (IN THIS CASE THIS FILE WILL'/
     4'		HAVE ITS SEED NO. DECREASED BY 123 FOR THE NEXT RUN): ')
	READ(*,*,ERR=1240) ISEEDIND
	IF(ISEEDIND .NE. 1 .AND. ISEEDIND .NE. 0) GO TO 1240	

C  AS OF MONTBIG9.FOR, THE SEED INDICATOR, ISEEDIND IS READ IN. IF
C  ISEEDIND = 1, THIS PROGRAM WILL USE THE DEFAULT SEED = -17;
C  ISEEDIND = 0, THIS PROGRAM WILL USE THE SEED NO. STORED INTO
C    SEEDTO.MON (AND UPDATE THE VALUE IN THAT FILE BY -123 FOR THE
C    NEXT RUN).


	ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(INOPT .EQ. 0)  CONDITION.


 7300    CONTINUE




C  PRINT TO THE SCREEN ALL INPUT INFO FOR VERIFICATION.

	CALL VERIF1(PREFIX,EXT,NSUB,NVAR,C0,C1,C2,C3,NOFIX,VALFIX,
     1   PARFIX,FILEIN,IDIST,NGAUS,COF,AMEAN,COV,FILOUT,PATH,NOB,
     2   NUMEQT,IPRNPAT,C0DT,C1DT,C2DT,C3DT,C0DA,C1DA,C2DA,C3DA,
     3   C0OT,C1OT,C2OT,C3OT,ISEEDIND,PAR,ICSVFILE,OUTNPAG,TEXTFILE,
     4   OUTCSVNAME,OSname,ListDir,ILIMIT,BOUND)

C  AS OF MONT107, IF IDIST = 0, NSUB MUST = NGAUS.

       IF(IDIST .EQ. 0) NSUB = NGAUS


C  CHECK THAT FILOUT DOES NOT ALREADY EXIST; IF IT DOES, GIVE USER 
C  CHANCE TO CHANGE IT.

C  CALL FULLNAME WHICH CONVERTS THE FILENAME TO PATHFILE, THE COMPLETE 
C  NAME OF THE FILE, WHICH INCLUDES THE PATH (IF THE PATH IS NOT THE 
C  CURRENT DIRECTORY).

 1980	TMPFILE = ' '
	TMPFILE = FILOUT
	CALL FULLNAME(PATH,TMPFILE,PATHFILE)
     	OPEN(23,FILE=PATHFILE,ERR=1970,STATUS='NEW')
	GO TO 1975
 1970   WRITE(*,9826) PATHFILE
 9826   FORMAT(/' THE FOLLOWING FILE ALREADY EXISTS ....'/
     1'    ',A93/
     1' ENTER 0 TO ENTER A NEW FILENAME;'/
     2' ENTER 1 TO OVERWRITE THIS FILE: ')

	READ(*,*,ERR=1970) IFILE
	IF(IFILE .NE. 0 .AND. IFILE .NE. 1) GO TO 1970

	IF(IFILE .EQ. 0) THEN
	 WRITE(*,*)' ENTER THE NAME OF THE OUTPUT FILE. ALL OUTPUT FROM'
	 WRITE(*,*)' THE PROGRAM WILL BE PUT INTO THIS FILE: '
	 READ(*,2) FILOUT
	 GO TO 1980
	ENDIF

	IF(IFILE .EQ. 1) OPEN(23,FILE=PATHFILE)

 1975   CLOSE(23)


C  GIVE USER OPTION TO SAVE INPUT DATA TO AN INPUT FILE (FOR ANOTHER
C  RUNNING OF THE PROGRAM).

	WRITE(*,1118)
 1118   FORMAT(//' ENTER 1 TO SAVE THE INPUT DATA INTO AN INPUT FILE;'/

     1' ENTER 0 OTHERWISE : ')
 1120   READ(*,*,ERR=1125) ISAVFL
	IF(ISAVFL .EQ. 0 .OR. ISAVFL .EQ. 1) GO TO 1130
 1125   WRITE(*,1126)
 1126   FORMAT(/' SEE ABOVE; ENTER 0 OR 1: ')
	GO TO 1120

 1130   IF(ISAVFL .EQ. 1) THEN

	 WRITE(*,1131)
 1131	 FORMAT(/' ENTER NAME OF FILE TO SAVE INPUT DATA : ')
	 READ(*,2) SAVFIL


C  CALL FULLNAME WHICH CONVERTS THE FILENAME TO PATHFILE, THE COMPLETE 

C  NAME OF THE FILE, WHICH INCLUDES THE PATH (IF THE PATH IS NOT THE 
C  CURRENT DIRECTORY).

 1180	TMPFILE = ' '

	TMPFILE = SAVFIL

	CALL FULLNAME(PATH,TMPFILE,PATHFILE)
     	OPEN(24,FILE=PATHFILE,ERR=1170,STATUS='NEW')
	GO TO 1175
 1170   WRITE(*,9826) PATHFILE
	READ(*,*,ERR=1170) IFILE
	IF(IFILE .NE. 0 .AND. IFILE .NE. 1) GO TO 1170

	IF(IFILE .EQ. 0) THEN
	 WRITE(*,*)' ENTER THE NAME OF THE FILE TO SAVE INPUT DATA: '   
	 READ(*,2) SAVFIL
	 GO TO 1180
	ENDIF

	IF(IFILE .EQ. 1) OPEN(24,FILE=PATHFILE)

 1175   CONTINUE

	 CODE = 'MONTBIG MAR_12'
       WRITE(24,7123) CODE

       WRITE(24,8111) 
 8111  FORMAT(' MODEL FILENAME')
	 WRITE(24,2) FORFILE

       WRITE(24,8112)
 8112  FORMAT(' IRAN INDICES')
	 WRITE(24,*) (IRAN(I),I=1,NP)


       WRITE(24,8151)
 8151  FORMAT(' BOUNDARIES FOR RANDOM VARIABLES')

       DO I = 1,NVAR

        IF(ILIMIT(I) .EQ. 1) THEN
         BOUND(I,1) = -99
         BOUND(I,2) = -99
        ENDIF

C  REPLACE WRITING OF BOUND() WITH XVERIFY (SEE LOGIC IN SUBROUTINE
C  VERIFYVAL). SIMIARLY FOR ALL CALLS TO VERIFYVAL.

        XVERIFY(1) = BOUND(I,1)
        XVERIFY(2) = BOUND(I,2)
        CALL VERIFYVAL(2,XVERIFY)

C        WRITE(24,8152) ILIMIT(I),BOUND(I,1),BOUND(I,2)
         WRITE(24,8152) ILIMIT(I),XVERIFY(1),XVERIFY(2)
 8152   FORMAT(5X,I1,2X,2(G19.9,1X))

       END DO

       WRITE(24,8116)
 8116  FORMAT(' ICSVFILE')
       WRITE(24,*) ICSVFILE

       WRITE(24,8117)
 8117  FORMAT(' FILEIN')
	 WRITE(24,2) FILEIN

       WRITE(24,8118) 
 8118  FORMAT(' NSUB')
	 WRITE(24,*) NSUB

 2416  FORMAT(30(G14.7,1X))

       WRITE(24,8119)
 8119  FORMAT(' NOFIX')
	 WRITE(24,*) NOFIX

C  REPLACE WRITING OF VALFIX() WITH XVERIFY (SEE LOGIC IN SUBROUTINE
C  VERIFYVAL). 

      IF(NOFIX .GT. 0) THEN
       DO I=1,NOFIX
        XVERIFY(I) = VALFIX(I)
       END DO
       CALL VERIFYVAL(NOFIX,XVERIFY)
      ENDIF

       WRITE(24,8121)
 8121  FORMAT(' VALFIX ARRAY IF NOFIX > 0')
C	 IF(NOFIX .GT. 0) WRITE(24,2416) (VALFIX(I),I=1,NOFIX)
       IF(NOFIX .GT. 0) WRITE(24,2416) (XVERIFY(I),I=1,NOFIX)

       WRITE(24,8122)
 8122  FORMAT(' TOLER')
	 WRITE(24,*) TOLER

       WRITE(24,8123)
 8123  FORMAT(' NUMEQT')
	 WRITE(24,*) NUMEQT


C  REPLACE WRITING OF C0(),...,C3() WITH XVERIFY (SEE LOGIC IN 
C  SUBROUTINE VERIFYVAL).

       WRITE(24,8124)
 8124  FORMAT(' NUMEQT LINES OF ASSAY COEFFICIENTS')
       DO IEQ=1,NUMEQT
        XVERIFY(1) = C0(IEQ)
        XVERIFY(2) = C1(IEQ)
        XVERIFY(3) = C2(IEQ)
        XVERIFY(4) = C3(IEQ)
        CALL VERIFYVAL(4,XVERIFY)
C	  WRITE(24,2416) C0(IEQ),C1(IEQ),C2(IEQ),C3(IEQ)
        WRITE(24,2416) (XVERIFY(IXV),IXV=1,4)
	 END DO

C  REPLACE WRITING OF C0DT,...,C3DT WITH XVERIFY (SEE LOGIC IN 
C  SUBROUTINE VERIFYVAL).

       WRITE(24,8126)
 8126  FORMAT(' ERROR COEFFS. FOR DOSE TIMES')
        XVERIFY(1) = C0DT
        XVERIFY(2) = C1DT
        XVERIFY(3) = C2DT
        XVERIFY(4) = C3DT
        CALL VERIFYVAL(4,XVERIFY)
C	  WRITE(24,2416) C0DT,C1DT,C2DT,C3DT
        WRITE(24,2416) (XVERIFY(IXV),IXV=1,4)


C  REPLACE WRITING OF C0DT,...,C3DT WITH XVERIFY (SEE LOGIC IN 
C  SUBROUTINE VERIFYVAL).

       WRITE(24,8127)
 8127  FORMAT(' ERROR COEFFS. FOR DOSE AMOUNTS')
        XVERIFY(1) = C0DA
        XVERIFY(2) = C1DA
        XVERIFY(3) = C2DA
        XVERIFY(4) = C3DA
        CALL VERIFYVAL(4,XVERIFY)
C	  WRITE(24,2416) C0DA,C1DA,C2DA,C3DA
        WRITE(24,2416) (XVERIFY(IXV),IXV=1,4)


C  REPLACE WRITING OF C0OT,...,C3OT WITH XVERIFY (SEE LOGIC IN 
C  SUBROUTINE VERIFYVAL).

       WRITE(24,8128)
 8128  FORMAT(' ERROR COEFFS. FOR OBSERVATION TIMES')
        XVERIFY(1) = C0OT
        XVERIFY(2) = C1OT
        XVERIFY(3) = C2OT
        XVERIFY(4) = C3OT
        CALL VERIFYVAL(4,XVERIFY)
C	  WRITE(24,2416) C0OT,C1OT,C2OT,C3OT
        WRITE(24,2416) (XVERIFY(IXV),IXV=1,4)


       WRITE(24,8129)
 8129  FORMAT(' IDIST')
	 WRITE(24,*) IDIST

       WRITE(24,8131)
 8131  FORMAT(' NGAUS')
	 WRITE(24,*) NGAUS

C  REPLACE WRITING OF AMEAN(),COV() WITH XVERIFY (SEE LOGIC IN 
C  SUBROUTINE VERIFYVAL).

       WRITE(24,8132)
 8132  FORMAT(' NGAUS SETS OF COF(.), AMEAN(.,.), COV(.,.,.)')

       DO IGAUS = 1,NGAUS

	  WRITE(24,*) COF(IGAUS)

        DO I = 1,NVAR
         XVERIFY(I) = AMEAN(IGAUS,I)
        END DO
        CALL VERIFYVAL(NVAR,XVERIFY)      

C	  WRITE(24,2416) (AMEAN(IGAUS,I),I=1,NVAR)
        WRITE(24,2416) (XVERIFY(I),I=1,NVAR)

        DO I = 1,NVAR
         DO J = 1,I
          XVERIFY(J) = COV(IGAUS,I,J)
         END DO
         CALL VERIFYVAL(I,XVERIFY)
C        WRITE(24,2416) (COV(IGAUS,I,J),J=1,I)
         WRITE(24,2416) (XVERIFY(J),J=1,I) 
        END DO
	 
       END DO
C  END OF DO IGAUS = 1,NGAUS LOOP.


       WRITE(24,8133)
 8133  FORMAT(' FILOUT')
	 WRITE(24,2) FILOUT



       WRITE(24,8134)
 8134  FORMAT(' IPRNPAT')
	 WRITE(24,*) IPRNPAT

       WRITE(24,8139)
 8139  FORMAT(' OUTCSVNAME')
       IF(IPRNPAT .EQ. 0 .OR. IPRNPAT .EQ. 2) WRITE(24,8141)
 8141  FORMAT(' NOT APPLICABLE')
       IF(IPRNPAT .EQ. 1 .OR. IPRNPAT .EQ. 3) WRITE(24,2) OUTCSVNAME


       WRITE(24,8142)
 8142  FORMAT(' PREFIX')
       IF(IPRNPAT .EQ. 0 .OR. IPRNPAT .EQ. 1) WRITE(24,8141)
       IF(IPRNPAT .EQ. 2 .OR. IPRNPAT .EQ. 3) WRITE(24,2222) PREFIX

       WRITE(24,8143)
 8143  FORMAT(' EXT')

       IF(IPRNPAT .EQ. 0 .OR. IPRNPAT .EQ. 1) WRITE(24,8141)
       IF(IPRNPAT .EQ. 2 .OR. IPRNPAT .EQ. 3) WRITE(24,222) EXT


       WRITE(24,8136)
 8136  FORMAT(' ISEEDIND')
	 WRITE(24,*) ISEEDIND

	 CLOSE(24)

	ENDIF

C  THE ABOVE ENDIF ENDS THE SAVING INFO TO INPUT FILE OPTION. 


C  ESTABLISH THE FULL NAME OF THE OUTPUT FILE AND PUT IN ALL THE
C  USER-INPUT INSTRUCTIONS AT THE TOP OF IT.

      TMPFILE = ' '
	TMPFILE = FILOUT
	CALL FULLNAME(PATH,TMPFILE,PATHFILE)

	OPEN(23,FILE=PATHFILE)

        WRITE(23,231)
  231   FORMAT(/' THE USER-INPUT INSTRUCTIONS FOR THIS RUN FOLLOW: ')
	

        WRITE(23,233) FORFILE
  233   FORMAT(/' THE FORTRAN MODEL FILE USED WAS ',A32)

        WRITE(23,234) 
  234   FORMAT(/' THE IRAN VECTOR IS SHOWN BELOW, WHERE IRAN(I)= 1'/
     1' IF PARAMATER I WAS RANDOM; 0 IF PARAMETER I WAS FIXED.')
        WRITE(23,*) (IRAN(I),I=1,NP)

        WRITE(23,2234)
 2234   FORMAT(/' THE REQUIRED BOUNDARIES FOR THE RANDOM VARIABLES'/
     1' WHICH ARE USED TO SIMULATE SUBJECTS ARE AS FOLLOWS: ')

        DO I = 1,NVAR
         IF(ILIMIT(I) .EQ. 1) WRITE(23,2236) PAR(I)
 2236     FORMAT(1X,A11,' <-- NO RESTRICTIONS ON PARAMETER VALUES ')
         IF(ILIMIT(I) .EQ. 0) WRITE(23,2237) PAR(I),BOUND(I,1),
     1    BOUND(I,2)
 2237     FORMAT(1X,A11,2X,G19.9,'  TO  ',G19.9)
        END DO


        IF(ICSVFILE .EQ. 0) THEN
         WRITE(23,238)
  238    FORMAT(/' THE NAME OF THE WORKING COPY PATIENT DATA FILE'/
     1' WHICH CONTAINS THE DOSE/COVARIATE INFORMATION WHICH WILL BE'/
     2' USED TO SIMULATE THE PATIENT DATA FILES IS: ')
         WRITE(23,2) FILEIN


        ENDIF


        IF(ICSVFILE .EQ. 1) THEN
         WRITE(23,1238) 
 1238    FORMAT(/' THE NAME OF THE .CSV FILE WHICH CONTAINS THE DOSE/'/
     1' COVARIATE INFORMATION (IN ITS FIRST SUBJECT BLOCK) WHICH WILL '/
     2' BE USED TO SIMULATE THE PATIENT DATA FILES IS: ')
         WRITE(23,2) FILEIN
        ENDIF

        WRITE(23,239) NSUB
  239   FORMAT(/' THE NO. OF SIMULATED SUBJECTS WAS ',I6)

        IF(NOFIX .EQ. 0) WRITE(23,241) 
  241   FORMAT(/' THERE WERE NO FIXED PARAMETERS IN THIS RUN.')


C  REPLACE WRITING OF VALFIX() WITH XVERIFY (SEE LOGIC IN SUBROUTINE
C  VERIFYVAL).

        IF(NOFIX .GT. 0) THEN

         DO I=1,NOFIX
          XVERIFY(I) = VALFIX(I)
         END DO
         CALL VERIFYVAL(NOFIX,XVERIFY)

         WRITE(23,242)
  242    FORMAT(/' THE FIXED PARAMETER VALUES, IN ORDER, WERE: ')
C         WRITE(23,2416) (VALFIX(I),I=1,NOFIX)
          WRITE(23,2416) (XVERIFY(I),I=1,NOFIX)

        ENDIF

        WRITE(23,243) 
  243   FORMAT(/' THE TOLERANCES FOR THE O.D.E. SOLVER WERE ALL ')
        WRITE(23,*) TOLER

        WRITE(23,244) NUMEQT
  244   FORMAT(/' THE NO. OF OUTPUT EQUATIONS WAS ',I3)

C  REPLACE WRITING OF C0(),...,C3() WITH XVERIFY (SEE LOGIC IN 
C  SUBROUTINE VERIFYVAL).

        WRITE(23,246)
  246   FORMAT(/' THE ASSAY COEFFICIENTS FOR EACH OF THE OUTPUT '/
     1' EQUATIONS, IN ORDER, WERE: ')

        DO IEQ = 1,NUMEQT
         XVERIFY(1) = C0(IEQ)
         XVERIFY(2) = C1(IEQ)
         XVERIFY(3) = C2(IEQ)
         XVERIFY(4) = C3(IEQ)
         CALL VERIFYVAL(4,XVERIFY)
C	   WRITE(23,2416) C0(IEQ),C1(IEQ),C2(IEQ),C3(IEQ)
         WRITE(23,2416) (XVERIFY(IXV),IXV=1,4)
        END DO

       WRITE(23,247)
  247  FORMAT(/' THE DOSE TIMES, THE DOSE AMOUNTS (INCLUDING ALL BOLUS'/
     1' VALUES AND THE IV RATES), AND THE OBSERVATION TIMES WHICH THE'/
     2' PROGRAM READ FROM THE WORKING COPY PATIENT DATA FILE ABOVE'/
     3' WERE ALL ASSUMED TO BE "NOISY" VALUES.'//
     5' EACH DOSE TIME IS MADE "NOISY" AS FOLLOWS:'/
     1' THE FIRST DOSE TIME, WITH A TRUE VALUE OF VTRUE, WILL BE '/
     2' CHANGED TO BE VNOISY, WHERE VNOISY = VTRUE + Ei, WHERE'/
     3' Ei ~ N(0,STDI**2), WHERE '/
     4' STDI = C0 + C1*VTRUE + C2*VTRUE**2 + C3*VTRUE**3'//
     5' FOR SUBSEQUENT DOSE TIMES, THE NOISY DOSE TIME IS '/
     6' DETERMINED AS FOLLOWS:'/
     7' a. SET DUR = NOMINAL DURATION BETWEEN THE PREVIOUS DOSE TIME '/
     8'    AND THE CURRENT DOSE TIME.'/
     3' b. CALC. THE NOISY DURATION, DURNOISY, AS '/
     4'    DURNOISY = DUR + Ei, Ei ~ N(0,STDI**2), WHERE '/
     7'    STDI = C0 + C1*DUR + C2*DUR**2 + C3*DUR**3'/
     8' c. ... BUT LIMIT DURNOISY TO BE .GE. .5*DUR AND .LE. 2*DUR.'/
     9' d. SET THE CURRENT NOISY DOSE TIME = PREVIOUS NOISY DOSE TIME'/
     1'    + DURNOISY.'//
     2' THE SAME LOGIC APPLIES FOR OBS. TIMES. '//
     3' NOTE THIS LOGIC --> TIMES CANNOT BE OUT OF ORDER.'//

     4' EACH IV RATE AND EACH BOLUS VALUE WHICH = 0 WILL NOT'/
     1' BE MADE NOISY. I.E., IT IS ASSUMED THAT IF A RATE OR BOLUS IS'/
     2' INTENDED TO BE 0, IT WILL BE ACHIEVED WITHOUT ERROR.'
     2/
     3' A NON-ZERO IV OR BOLUS VALUE, WITH A TRUE VALUE OF VTRUE, '/
     4' WILL BE CHANGED TO BE VNOISY, WHERE VNOISY = VTRUE + Ei, WHERE'/
     6' Ei ~ N(0,STDI**2), WHERE '/
     7' STDI = C0 + C1*VTRUE + C2*VTRUE**2 + C3*VTRUE**3')


C  REPLACE WRITING OF C0DT,...,C3DT; C0DA,...,C3DA; AND
C  C0OT,...C3OT; WITH XVERIFY (SEE LOGIC IN SUBROUTINE VERIFYVAL).

        WRITE(23,248)
  248   FORMAT(/' C0,C1,C2,C3 FOR THE DOSE TIMES WERE: ')
        XVERIFY(1) = C0DT
        XVERIFY(2) = C1DT
        XVERIFY(3) = C2DT
        XVERIFY(4) = C3DT
        CALL VERIFYVAL(4,XVERIFY)
C       WRITE(23,2416) C0DT,C1DT,C2DT,C3DT
        WRITE(23,2416) (XVERIFY(IXV),IXV=1,4)

        WRITE(23,249)
  249   FORMAT(/' C0,C1,C2,C3 FOR THE DOSE AMOUNTS WERE: ')
        XVERIFY(1) = C0DA
        XVERIFY(2) = C1DA
        XVERIFY(3) = C2DA
        XVERIFY(4) = C3DA
        CALL VERIFYVAL(4,XVERIFY)
C	  WRITE(23,2416) C0DA,C1DA,C2DA,C3DA
        WRITE(23,2416) (XVERIFY(IXV),IXV=1,4)


        WRITE(23,251)
  251   FORMAT(/' C0,C1,C2,C3 FOR THE OBSERVATION TIMES WERE: ')
        XVERIFY(1) = C0OT
        XVERIFY(2) = C1OT
        XVERIFY(3) = C2OT
        XVERIFY(4) = C3OT
        CALL VERIFYVAL(4,XVERIFY)
C	  WRITE(23,2416) C0OT,C1OT,C2OT,C3OT
        WRITE(23,2416) (XVERIFY(IXV),IXV=1,4)


C  IF OUTNPAG IS NOT ALL BLANKS, IT MEANS THAT THE NGAUS DISTRIBUTIONS
C  CAME FROM THE OUTPUT FILE IN OUTNPAG. WRITE THIS INTO OUTPUT FILE.
C  SIMILARLY, IF TEXTFILE IS NOT ALL BLANKS, THE NGAUS MEANS CAME 
C  FROM THIS TEXT FILE.

        IF(OUTNPAG(1:10) .NE. '          ') WRITE(23,351) NGAUS,OUTNPAG
  351    FORMAT(/' THE MIXTURE OF ',I3,' DISTRIBUTION(S) DESCRIBED '/
     1' BELOW CAME FROM THE BIG NPAG OUTPUT FILE, ',A20)

       IF(TEXTFILE(1:10) .NE. '          ') WRITE(23,751) NGAUS,TEXTFILE
  751  FORMAT(/' THE MIXTURE OF ',I3,' DISTRIBUTION(S) DESCRIBED '/
     1' BELOW CAME FROM THE TEXT FILE, ',A20)



      IF(IDIST .EQ. 0) THEN

        WRITE(23,254) NGAUS
  254   FORMAT(/' THE OBSERVATIONS FOR EACH OF THE ',I3,' SUBJECT'/
     1' VECTORS WERE GENERATED BY ASSUMING EACH SUBJECT HAD EXACTLY'/
     2' THE PARAMETER VALUES OF ONE OF THE GRID PTS. IN THE FINAL'/
     3' CYCLE DENSITY FROM THE INPUT NPAG RUN. THESE GRID PTS. ARE: '/)


C  REPLACE WRITING OF AMEAN() WITH XVERIFY (SEE LOGIC IN 
C  SUBROUTINE VERIFYVAL).

       DO IGAUS = 1,NGAUS
        WRITE(23,9004) IGAUS
 9004   FORMAT(//' GRID PT. NO: ',I3)
        DO I = 1,NVAR
         XVERIFY(I) = AMEAN(IGAUS,I)
        END DO
        CALL VERIFYVAL(NVAR,XVERIFY)      
C       WRITE(23,9007) (AMEAN(IGAUS,I),I=1,NVAR)
        WRITE(23,9007) (XVERIFY(I),I=1,NVAR)
 9007   FORMAT(/' PAR. VALUES: ',150G10.3)
       END DO

      ENDIF
C  THE ABOVE ENDIF IS FOR THE  IF(IDIST .EQ. 0)  CONDITION.

 
        IF(IDIST .EQ. 1) WRITE(23,252) NGAUS
  252   FORMAT(/' THE SUBJECT VECTORS WERE GENERATED FROM A MIXTURE'/
     1' OF ',I3,' GAUSSIAN DISTRIBUTIONS. THE FOLLOWING DESCRIBES '/
     2' THESE DISTRIBUTIONS: ')

        IF(IDIST .EQ. 2) WRITE(23,253) NGAUS
  253   FORMAT(/' THE SUBJECT VECTORS WERE GENERATED FROM A MIXTURE'/
     1' OF ',I3,' LOGNORMAL DISTRIBUTIONS. THE FOLLOWING DESCRIBES '/
     2' THESE DISTRIBUTIONS: ')




      IF(IDIST .NE. 0) THEN

C  REPLACE WRITING OF AMEAN(),COV(),COF(), AND CORR() WITH XVERIFY 
C (SEE LOGIC IN SUBROUTINE VERIFYVAL).

	DO 8020 IGAUS=1,NGAUS

	WRITE(23,8004) IGAUS
 8004 FORMAT(//' DISTRIBUTION NO: ',I3)
      XVERIFY(1) = COF(IGAUS)
      CALL VERIFYVAL(1,XVERIFY)
C	WRITE(23,8006) COF(IGAUS) 
      WRITE(23,8006) XVERIFY(1)
 8006 FORMAT(/' WEIGHTING COEFFICIENT: ',F10.3)

       DO I = 1,NVAR
        XVERIFY(I) = AMEAN(IGAUS,I)
       END DO
       CALL VERIFYVAL(NVAR,XVERIFY)
C	 WRITE(23,8007) (AMEAN(IGAUS,I),I=1,NVAR)
       WRITE(23,8007) (XVERIFY(I),I=1,NVAR)
 8007  FORMAT(/' MEAN VECTOR: ',150G10.3)
       WRITE(23,8008) 
 8008   FORMAT(/' THE COVARIANCE MATRIX, IN LOWER-TRIANGULAR FORM IS: ')

        DO I=1,NVAR
         DO J = 1,I
          XVERIFY(J) = COV(IGAUS,I,J)
         END DO
         CALL VERIFYVAL(I,XVERIFY)
C        WRITE(23,2416) (COV(IGAUS,I,J),J=1,I)
         WRITE(23,2416) (XVERIFY(J),J=1,I)
        END DO

C  ESTABLISH THE LOWER-TRIANGULAR CORRELATION MATRIX.

	DO I = 1,NVAR
	 DO J = 1,I
	  CORR(I,J)= COV(IGAUS,I,J)/DSQRT(COV(IGAUS,I,I)*COV(IGAUS,J,J))
	 END DO
	END DO

      WRITE(23,8009)
 8009 FORMAT(/' THE CORRELATION MATRIX, IN LOWER-TRIANGULAR FORM IS:')

        DO I = 1,NVAR
         DO J = 1,I
          XVERIFY(J) = CORR(I,J)
         END DO
         CALL VERIFYVAL(I,XVERIFY)
C        WRITE(23,2416) (CORR(I,J),J=1,I)
         WRITE(23,2416) (XVERIFY(J),J=1,I)
        END DO

 8020   CONTINUE

      ENDIF
C  THE ABOVE ENDIF IS FOR THE  IF(IDIST .NE. 0)  CONDITION.


        IF(IPRNPAT .EQ. 1 .OR. IPRNPAT .EQ. 3) 
     1   WRITE(23,9013) NSUB,OUTCSVNAME
 9013   FORMAT(/' THE INFORMATION FROM THE ',I5,' SIMULATED PATIENT'/
     1' DATA FILES WAS SAVED IN BLOCK FORMAT TO '/
     2' FILE ',A32)

        IF(IPRNPAT .EQ. 2 .OR. IPRNPAT .EQ. 3) 
     1   WRITE(23,8013) NSUB,PREFIX,EXT
 8013   FORMAT(/' THIS RUN CREATED ',I5,' SIMULATED PATIENT DATA '/
     1' FILES, WITH PREFIX ',A3,' AND EXTENSION ',A3) 
       
        IF(IPRNPAT .EQ. 0) WRITE(23,8014) NSUB
 8014   FORMAT(/' THE INFORMATION FROM THE ',I5,' SIMULATED PATIENT'/
     1' DATA FILES WAS NOT SAVED IN BLOCK FORMAT TO A .CSV FILE, AND'/
     2' NO SIMULATED PATIENT DATA FILES WERE CREATED')



	IF(ISEEDIND .EQ. 1) WRITE(23,257)
  257   FORMAT(/' THIS RUN USED THE DEFAULT SEED NO. -17.')

	IF(ISEEDIND .EQ. 0) WRITE(23,258)
  258   FORMAT(/' THIS RUN USED THE SEED NO. STORED IN "SEEDTO.MON" '/
     1' (SEE BELOW) AND UPDATED THE VALUE IN THAT FILE BY -123 FOR THE'/
     2' NEXT RUN.')



	WRITE(23,232)
  232   FORMAT(/' THE USER-INPUT INSTRUCTIONS FOR THIS RUN ARE ABOVE.'/
     1/

     2'*************************************************************'/
     3'*************************************************************'//
     4'********** THE FOLLOWING ARE THE RESULTS OF THIS RUN ********'//)


	CALL SIMBIG(PREFIX,EXT,FILEIN,NSUB,NVAR,NOFIX,IRAN,VALFIX,
     1   C0,C1,C2,C3,IDIST,NGAUS,COF,AMEAN,COV,PATH,NDIM,PAR,
     2   IPRNPAT,ISEEDIND,ICSVFILE,OUTCSVNAME,OSname,DeleteFile,
     3   ListDir,ILIMIT,BOUND)


      STOP
      END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
      SUBROUTINE GNRAT(N,MEAN,COV,VEC,IDUM)
      IMPLICIT REAL*8(A-H,O-Z)
      DIMENSION MEAN(594),COV(594,594),VEC(594),SIG(594,594),RVEC(594),
     1 ID(594),A(594,594),R(594)
      DOUBLE PRECISION MEAN
C
C  THIS SUBROUTINE, CALLED BY SIMBIG, INPUTS N,MEAN, COV, AND IDUM, AND 
C  RETURNS VEC, A NORMAL VECTOR (OF LENGTH N)--N(MEAN,COV), WHERE COV IS

C  THE LOWER TRI FORM OF THE DESIRED COVARIANCE MATRIX.
C
C  IDUM IS THE DUMMY INDEX USED BY THE RANDOM NUMBER GENERATOR, RAN1; IT
C  IS INITIALIZED TO BE A NEGATIVE NO. THE 1ST CALL, AND THEN, FOREVER 
C  MORE, IS POSITIVE.
C
C  FIRST, OBTAIN THE 'SQUARE ROOT' OF COV (I.E., THE LOWER-TRI MATRIX,
C  A, WHERE A*A'=COV.

C
C  COV SHOULD BE A SYMMETRIC POS-DEF. MATRIX (SINCE IT IS A COV MATRIX),
C  BUT IN A TEST CASE, SOME OF THE ROWS MIGHT BE ALL 0, INDICATING THAT
C  THAT COMPONENT OF VEC IS TO = ITS MEAN. SINCE SUBROUTINE SQROOT,
C  WHICH CALCULATES A, REQUIRES A POS-DEF. MATRIX, SUBSTITUTE .0001 FOR
C  ALL DIAGONAL ELEMENTS WHICH ARE 0; THEN, BEFORE RETURNING VEC, SIMPLY
C  SET VEC(I)=MEAN(I) FOR EACH I WHERE COV(I,I) WAS ORIGINALLY = 0.
C

C  LET ID(I)=0 IF THE (I,I) ELEMENT OF COV = 0. SET SIG(I,J)= COV(I,J)
C  UNLESS COV(I,I)=0 (IN WHICH CASE, SET SIG(I,I)=.0001).

C
C  NOTE: IF A VARIANCE = 0, ALL COVARIANCES FOR THAT R.V. WOULD ALSO BE
C  0, SO THE ARBITRARY VALUE (.0001) USED IS UNIMPORTANT; IT WON'T      
C  AFFECT OTHER VALUES IN VEC.

      DO 10 I=1,N
   10 ID(I)=1
C
      DO 30 I=1,N
      DO 20 J=1,I
   20 SIG(I,J)=COV(I,J)
      IF(SIG(I,I) .EQ. 0.D0) THEN
         SIG(I,I)=1.D-4
         ID(I)=0
         ENDIF
   30 CONTINUE
C
      CALL SQROOT(N,SIG,A)
C
C  NOW OBTAIN N INDEPENDENT N(0,1) VARIATES.
C
      DO 40 I=1,N
   40 R(I)=GASDEV(IDUM)

C
C  NOW R--IID--N(0,I); CALCULATE RVEC = A*R--IID--N(0,AA'=SIG).
C
      DO 60 I=1,N

      SUM=0.D0
      DO 50 J=1,I
C
C  RECALL A IS A LOWER-TRI MATRIX, SO A(I,J)=0 IF J.GT. I.
C
   50 SUM=SUM+A(I,J)*R(J)
   60 RVEC(I)=SUM
C
C  NOW, CONVERT TO VEC WHICH HAS MEAN=MEAN. SO, FOR ANY VARIABLE I, 
C  WHICH HAD VARIANCEC = 0.0 ORIGINALLY, SET VEC(I)=MEAN(I); OTHERWISE, 
C  SET VEC(I) = RVEC(I)+MEAN(I) TO GET (VEC(1),...,VEC(N))--N(MEAN,COV).
C
      DO 70 I=1,N
      VEC(I)=RVEC(I)+MEAN(I)
   70 IF(ID(I) .EQ. 0) VEC(I)=MEAN(I)
C
C
      RETURN
      END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
      SUBROUTINE SQROOT(N,SIG,A)
      IMPLICIT REAL*8(A-H,O-Z)
      DIMENSION SIG(594,594),A(594,594)

      CHARACTER ERRFIL*20

      COMMON/ERROR/ERRFIL
C  COMMON/ERROR/ IS SUPPLIED TO ALL THE ROUTINES WHICH COULD WRITE TO
C  ERRFIL.

C  THIS SUBROUTINE INPUTS AN N x N SYMMETRIC, POSITIVE-DEFINITE MATRIX,
C  SIG, AND OUTPUTS THE LOWER-TRIANGULAR MATRIX, A, WHERE  A*A'= SIG.
C
C  SQROOT IS CALLED BY SUBROUTINE GNRAT.
C
C  SET UPPER-TRI PART OF A = 0. 

      DO 10 I=1,N
      DO 10 J=I+1,N
   10 A(I,J)=0.D0
C
C  SOLVE FOR A(I,J) IN THE ORDER (((I,J),J=1,I),I=1,N).
C
      DO 100 I=1,N
      DO 100 J=1,I
C
C  IF I=J, FIND THE DIAGONAL ELEMENT A(I,I), AND, AT THE SAME TIME,
C  CHECK THAT THE UPPER LEFT  I x I  PORTION OF MATRIX SIG HAS A 
C  POSITIVE DETERMINANT (AS IS REQUIRED OF SIG, SINCE IT IS SUPPOSED
C  TO BE POSITIVE-DEFINITE).
C
      IF(I .EQ. J) THEN
	SUM=0.D0
	DO 20 K=1,I-1
   20 	SUM=SUM+A(I,K)*A(I,K)		
	RAD=SIG(I,I)-SUM

	IF(RAD .LE. 0.D0) THEN



	  WRITE(*,101)
  101   FORMAT(/' COV MATRIX IS NOT POS-DEF; PROGRAM STOPS. ')
	  WRITE(23,101)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,101) 
        CLOSE(42)



        CALL PAUSE
	  STOP



	 ENDIF



C  RAD .GT. 0, SO CALCULATE A(I,I) AND PROCEED.

	A(I,I)=DSQRT(RAD)
C
	ELSE
C
C  I .NE. J (ACTUALLY I .GT. J), SO FIND THE LOWER-TRI ELT, A(I,J).
C
	SUM=0.D0
	DO 30 K=1,J-1
   30   SUM=SUM+A(I,K)*A(J,K)
	A(I,J)=(SIG(I,J)-SUM)/A(J,J)
C
C  NOTE: A(J,J) IN DENOMINATOR ABOVE IS .NE. 0, SINCE ALL THE A(I,I)
C	 PREVIOUSLY CALCULATED ARE .GT. 0 (I.E., A(I,I) =DSQRT(RAD)
C 	 WHERE RAD MUST BE .GT. 0, OR PROGRAM WOULD HAVE STOPPED).
C
	ENDIF
C
  100 CONTINUE
      RETURN
      END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C      REAL*8 FUNCTION GASDEV(IDUM)

C	IMPLICIT REAL*8 (A-H,O-Z)

C      DATA ISET/0/
C      IF (ISET.EQ.0) THEN
C1       V1=2.*RAN1(IDUM)-1.
C        V2=2.*RAN1(IDUM)-1.
C        R=V1**2+V2**2
C        IF(R.GE.1.)GO TO 1
C        FAC=SQRT(-2.*LOG(R)/R)
C        GSET=V1*FAC
C        GASDEV=V2*FAC
C        ISET=1
C      ELSE
C        GASDEV=GSET
C        ISET=0
C      ENDIF
C      RETURN
C      END
C

C
C Yamada replaced above w/the following:
C
C    This was necessary to fix a compiler issue. In gfortran
C we need to explicitely set variables to static state -- unlike

C g95, which is backwards compatible to FORTRAN90, and uses a
C compiler flag to set (? all ?) local variables to static.

      REAL*8 FUNCTION GASDEV(IDUM)
        IMPLICIT REAL*8 (A-H,O-Z)
      DATA ISET/0/
C
C YAMADA 4/14/2010
C      REAL*8, SAVE :: GSET
      double precision, save :: GSET
C
      IF (ISET.EQ.0) THEN

1       V1=2.*RAN1(IDUM)-1.
        V2=2.*RAN1(IDUM)-1.
        R=V1**2+V2**2
        IF(R.GE.1.)GO TO 1
        FAC=SQRT(-2.*LOG(R)/R)

        GSET=V1*FAC
        GASDEV=V2*FAC
        ISET=1
      ELSE
        GASDEV=GSET
        ISET=0
      ENDIF
      RETURN
      END
C
C END Yamada.
C

C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C      REAL*8 FUNCTION RAN1(IDUM)
C	IMPLICIT REAL*8 (A-H,O-Z)
C      DIMENSION R(97)
C      PARAMETER (M1=259200,IA1=7141,IC1=54773,RM1=3.8580247E-6)

C      PARAMETER (M2=134456,IA2=8121,IC2=28411,RM2=7.4373773E-6)
C      PARAMETER (M3=243000,IA3=4561,IC3=51349)
C      DATA IFF /0/
C      IF (IDUM.LT.0.OR.IFF.EQ.0) THEN
C        IFF=1
C        IX1=MOD(IC1-IDUM,M1)
C        IX1=MOD(IA1*IX1+IC1,M1)
C        IX2=MOD(IX1,M2)
C        IX1=MOD(IA1*IX1+IC1,M1)
C        IX3=MOD(IX1,M3)
C        DO 11 J=1,97
C          IX1=MOD(IA1*IX1+IC1,M1)
C          IX2=MOD(IA2*IX2+IC2,M2)
C          R(J)=(FLOAT(IX1)+FLOAT(IX2)*RM2)*RM1
C11      CONTINUE
C        IDUM=1
C      ENDIF
C      IX1=MOD(IA1*IX1+IC1,M1)
C      IX2=MOD(IA2*IX2+IC2,M2)
C      IX3=MOD(IA3*IX3+IC3,M3)
C      J=1+(97*IX3)/M3

C      IF(J.GT.97.OR.J.LT.1) CALL PAUSE
C      RAN1=R(J)
C      R(J)=(FLOAT(IX1)+FLOAT(IX2)*RM2)*RM1
C      RETURN
C      END
C
C Yamada replaced the above w/the code below ... the same issue
C as for  SUBROUTINE GNRAT() ... we need a static variable, and must
C explicitely declare it so.
C

      DOUBLE PRECISION FUNCTION RAN1(IDUM)
C
        IMPLICIT REAL*8 (A-H,O-Z)
      DIMENSION R(97)
C
C YAMADA 16 Mar 2010; 4/14/2010
C
C      REAL*8 :: rrr(1,1)
C      REAL*8, SAVE :: zzz(1,97)

C      INTEGER*4, SAVE :: IX1
C      INTEGER*4, SAVE :: IX2
C      INTEGER*4, SAVE :: IX3
C      DOUBLE PRECISION,SAVE :: zzz(1,97)
      DOUBLE PRECISION,SAVE :: rrr
      DOUBLE PRECISION,DIMENSION(97),SAVE :: zzz
      INTEGER*4 IX1
      INTEGER*4 IX2
      INTEGER*4 IX3
      SAVE :: IX1, IX2, IX3
C
C end YAMADA 16 Mar 2010
C
      PARAMETER (M1=259200,IA1=7141,IC1=54773,RM1=3.8580247E-6)
      PARAMETER (M2=134456,IA2=8121,IC2=28411,RM2=7.4373773E-6)
      PARAMETER (M3=243000,IA3=4561,IC3=51349)
      DATA IFF /0/
      IF (IDUM.LT.0.OR.IFF.EQ.0) THEN
        IFF=1


        IX1=MOD(IC1-IDUM,M1)
        IX1=MOD(IA1*IX1+IC1,M1)
        IX2=MOD(IX1,M2)
        IX1=MOD(IA1*IX1+IC1,M1)
        IX3=MOD(IX1,M3)

        DO 11 J=1,97
          IX1=MOD(IA1*IX1+IC1,M1)
          IX2=MOD(IA2*IX2+IC2,M2)
          R(J)=(FLOAT(IX1)+FLOAT(IX2)*RM2)*RM1
          zzz(J) = R(J)
11      CONTINUE
        IDUM=1
      ENDIF
      IX1=MOD(IA1*IX1+IC1,M1)
      IX2=MOD(IA2*IX2+IC2,M2)
      IX3=MOD(IA3*IX3+IC3,M3)
      J=1+(97*IX3)/M3
      IF(J.GT.97.OR.J.LT.1) THEN
C
C YAMADA 12/30/09
C Rather than just hanging or crashing w/a PAUSE: try to recover
C by choosing a random J. But note: this IF block should never ever
C get called ... if you are here you are in major doodoo ... and
C recovering will likely not get you anything better than a safer
C exit from the program.
C
        CALL init_random_seed(J)
        CALL RANDOM_NUMBER(rrr)
        PRINT *, 'In RAN1() old J corresponds to: ', J, IX1, IX2, IX3
        J = 97*rrr


        IF(J.LT.1) J=J+1

        write(*,FMT = 1112) J
 1112   FORMAT( 'WARNING: Increment into rvec went out of range: ', I5 )
      ENDIF
      RAN1=zzz(J)
      R(J)=(FLOAT(IX1)+FLOAT(IX2)*RM2)*RM1
      zzz(J)=R(J)

      RETURN
      END
C
C End Yamada.
C

C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C YAMADA 1/7/2010
C
C This routine is to initialize RANDOM_NUMBER() based on the current 
C time. Call this routine prior to calling RANDOM_NUMBER(). Note that
C this routine should never need to be called -- unless there is a
C serious error in the random number generator and we are trying to
C recover -- but in that case, we might just rather crash! (Or generate
C bogus output ... this routine is the tail end of a series of edits to
C fix random number generation in UNIX, which is not at all backwards
C compatible w/FORTRAN90.




       SUBROUTINE init_random_seed()
          INTEGER :: i, n, clock
          INTEGER, DIMENSION(:), ALLOCATABLE :: seed

          CALL RANDOM_SEED(size = n)
          ALLOCATE(seed(n))

          CALL SYSTEM_CLOCK(COUNT=clock)

          seed = clock + 37 * (/ (i - 1, i = 1, n) /)
          CALL RANDOM_SEED(PUT = seed)

          DEALLOCATE(seed)
       END SUBROUTINE

C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
      SUBROUTINE NOSGEN(M,VAR,IDUM,AS1)

      IMPLICIT REAL*8(A-H,O-Z)

      DIMENSION AS1(594),AM(594),COV(594,594)

CHANGE ALL SIZES FROM 150 TO 594, I THINK.

C  THIS SUBROUTINE, CALLED BY SIMBIG, INPUTS M AND VAR (AND IDUM), AND
C  RETURNS THE M x 1 VECTOR, AS1--IID--N(0,COV), WHERE COV REPRESENTS 
C  THE COVARIANCE MATRIX HAVING VAR ON THE DIAGONAL, AND 0 ON THE 
C  OFF-DIAGONAL, ELEMENTS. 



C  IDUM IS THE DUMMY INDEX NEEDED BY THE RANDOM NO. GENERATOR, RAN1.

C  SUBROUTINE GNRAT IS USED. 

C  ESTABLISH THE MEAN VECTOR, AM, AND THE COV VECTOR, COV.

      DO 10 I=1,M
   10 AM(I)=0.D0

      DO 20 I=1,M
      DO 20 J=1,I
   20 COV(I,J)=0.D0

      DO 30 I=1,M
   30 COV(I,I)=VAR

      CALL GNRAT(M,AM,COV,AS1,IDUM)

      RETURN
      END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
      SUBROUTINE STATT(NSUB,NP,V,SAMMEN,SAMCOV)
      IMPLICIT REAL*8(A-H,O-Z)
      DIMENSION V(100000,30),SAMMEN(30),SAMCOV(30,30),SUM(30),
     1SUMPRD(30,30)

C  THIS SUBROUTINE, CALLED BY SIMBIG, INPUTS NSUB,NP, AND V. V IS
C  AN NSUB x NP MATRIX.
C


C  IT OUTPUTS:
C
C  SAMMEN(I) = MEAN OF COLUMN I IN V, I=1,NP.


C  SAMCOV(I,J) = COVARIANCE BETWEEN VALUES IN COLS I AND J OF MATRIX
C                V (NOTE: NSUB, NOT NSUB-1 IS USED IN DENOMINATORS).
C
C  CALCULATE THE MEANS OF THE NP COLUMNS.

C
      DO 10 J=1,NP
   10 SUM(J)=0.D0
C
      DO 30 J=1,NP
      DO 20 I=1,NSUB
   20 SUM(J)=SUM(J)+V(I,J)

   30 SAMMEN(J)=SUM(J)/NSUB
C
C  CALCULATE THE COVARIANCES FOR EACH PAIR OF COLUMNS.
C
      DO 40 J=1,NP
      DO 40 K=1,J
   40 SUMPRD(J,K)=0.D0
C
      DO 60 J=1,NP
      DO 60 K=1,J
C
      DO 50 I=1,NSUB

   50 SUMPRD(J,K)=SUMPRD(J,K)+V(I,J)*V(I,K)
C
   60 SAMCOV(J,K)=(SUMPRD(J,K)-NSUB*SAMMEN(J)*SAMMEN(K))/NSUB
C
      RETURN
      END

C

CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
	SUBROUTINE VERIF1(PREFIX,EXT,NSUB,NVAR,C0,C1,C2,C3,
     1   NOFIX,VALFIX,PARFIX,FILEIN,IDIST,NGAUS,COF,AMEAN,COV,FILOUT,
     2   PATH,NOB,NUMEQT,IPRNPAT,C0DT,C1DT,C2DT,C3DT,
     3   C0DA,C1DA,C2DA,C3DA,C0OT,C1OT,C2OT,C3OT,ISEEDIND,PAR,ICSVFILE,
     4   OUTNPAG,TEXTFILE,OUTCSVNAME,OSname,ListDir,ILIMIT,BOUND)


	IMPLICIT REAL*8(A-H,O-Z)

	PARAMETER(MAXNUMEQ=7)

	DIMENSION VALFIX(20),COF(150),AMEAN(150,30),COV(150,30,30),
     1 C0(MAXNUMEQ),C1(MAXNUMEQ),C2(MAXNUMEQ),C3(MAXNUMEQ),
     2 CORR(30,30),ILIMIT(32),BOUND(32,2),XVERIFY(900)

	CHARACTER PREFIX*3,EXT*3,PARFIX(20)*11,PAR(30)*11,
     1   FILOUT*32,FILEIN*32,PATH*61,TMPFILE*32,PATHFILE*93,OUTNPAG*20,
     2   OUTCSVNAME*32,OSname*20,ListDir*10,TEXTFILE*20

C  SUBROUTINE VERIF1 IS CALLED BY MAIN TO PRINT TO THE SCREEN THE INPUT
C  INFO, SO THE USER CAN VERIFY THAT THE VALUES WERE ENTERED CORRECTLY.
C  IF NOT, THE USER MAY CHANGE THESE VALUES.

C  NOTE: SUBROUTINE CHANGE BELOW IS CALLED SEVERAL TIMES. ITS ARGUMENT,
C        ICHANG, RETURNS AS 1 IF THE PREVIOUS INFORMATION PRINTED TO THE
C        SCREEN IS VALIDATED BY THE USER; IT RETURNS AS 0 IF THE USER
C        WANTS TO CHANGE SOMETHING. 

  102   FORMAT(A32)
  103   FORMAT(A3)
  104   FORMAT(A3)

 8040   WRITE(*,1)
    1   FORMAT(///' THE FOLLOWING INFO WAS READ IN; IF ANY OF IT IS '/
     1' INCORRECT, MAKE THE DESIRED CHANGES.')
C
C  
C
        IF(ICSVFILE .EQ. 0) WRITE(*,8002) FILEIN

 8002   FORMAT(/' THE PATIENT DOSE/COVARIATE AND OBS. TIME INFO WILL '/
     1' BE INPUT FROM THE WORKING COPY PATIENT FILE: ',A32)

        IF(ICSVFILE .EQ. 1) WRITE(*,8023) FILEIN
 8023   FORMAT(/' THE PATIENT DOSE/COVARIATE AND OBS. TIME INFO WILL '/
     1' BE FROM THE DATA OF THE FIRST SUBJECT IN THE BLOCK MATRIX '/
     2' .CSV FILE: ',A32) 
C
C 
C

	CALL CHANGE(ICHANG)

	IF(ICHANG .EQ. 0) THEN
C
C
C
 5020   WRITE(*,5002)
 5002   FORMAT(/' THE DOSE/COVARIATE AND OBSERVATION TIME INFORMATION'/
     1' WHICH WILL BE USED TO SIMULATE THE PATIENT DATA FILES CAN BE'/
     2' INPUT VIA A (MULTIPLE DRUG) WORKING COPY PATIENT DATA FILE OR'/

     3' VIA A BLOCK MATRIX .CSV FILE (THE INFO WILL COME FROM THE '/
     4' DATE OF THE FIRST SUBJECT IN THIS CASE).'//
     5' ENTER 1 TO ENTER INFO USING A .CSV FILE; '/
     6' ENTER 0 TO ENTER INFO USING A WORKING COPY PATIENT DATA FILE: ')
        READ(*,*,ERR=5020) ICSVFILE
        IF(ICSVFILE .NE. 1 .AND. ICSVFILE .NE. 0) GO TO 5020

        IF(ICSVFILE .EQ. 0) THEN

        WRITE(*,1021)
 1021   FORMAT(/' ENTER THE NAME OF THE WORKING COPY PATIENT DATA FILE'/
     1' WHICH CONTAINS THE DOSE/COVARIATE INFORMATION WHICH WILL BE'/
     2' USED TO SIMULATE THE PATIENT DATA FILES.'//
     3' BE SURE THAT THIS IS A MULTI-DRUG WORKING COPY DATA FILE.'//
     1' ENTER -99 TO SEE ALL OR A PART OF YOUR DIRECTORY: ')
        READ(*,212) FILEIN

        IF(FILEIN(1:3) .EQ. '-99') CALL SEEDIR(PATH,NOB,FILEIN,
     1     OSname,ListDir)

C  CHECK THAT THIS IS AN EXISTING FILE.

C  CALL FULLNAME WHICH CONVERTS THE FILENAME TO PATHFILE, THE COMPLETE 
C  NAME OF THE FILE, WHICH INCLUDES THE PATH (IF THE PATH IS NOT THE 
C  CURRENT DIRECTORY).

	TMPFILE = ' '
	TMPFILE = FILEIN
	CALL FULLNAME(PATH,TMPFILE,PATHFILE)
	OPEN(21,FILE=PATHFILE,ERR=6440,STATUS='OLD')
	GO TO 6455
 6440 WRITE(*,5316) PATHFILE
 5316 FORMAT(//' THE FOLLOWING FILE DOES NOT EXIST ... '/
     1' ',A93)

	GO TO 5020
 6455 CONTINUE

        ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(ICSVFILE .EQ. 0) CONDITION.


        IF(ICSVFILE .EQ. 1) THEN

        WRITE(*,3021)
 3021   FORMAT(/' ENTER THE NAME OF THE BLOCK MATRIX .CSV FILE. ONLY'/
     1' THE DATA FROM THE FIRST SUBJECT IN THIS FILE WILL BE READ TO'/
     2' OBTAIN THE DOSE/COVARIATE INFORMATION WHICH WILL BE USED TO'/
     3' TO SIMULATE THE PATIENT DATA FILES.'//
     1' ENTER -99 TO SEE ALL OR A PART OF YOUR DIRECTORY: ')
     	  READ(*,212) FILEIN
  212   FORMAT(A32)
        IF(FILEIN(1:3) .EQ. '-99') CALL SEEDIR(PATH,NOB,FILEIN,
     1     OSname,ListDir)

C  CHECK THAT THIS IS AN EXISTING FILE.

C  CALL FULLNAME WHICH CONVERTS THE FILENAME TO PATHFILE, THE COMPLETE 
C  NAME OF THE FILE, WHICH INCLUDES THE PATH (IF THE PATH IS NOT THE 
C  CURRENT DIRECTORY).

        TMPFILE = ' '
        TMPFILE = FILEIN
        CALL FULLNAME(PATH,TMPFILE,PATHFILE)
        OPEN(87,FILE=PATHFILE,ERR=5440,STATUS='OLD')


        GO TO 5455
 5440   WRITE(*,5316) PATHFILE
        GO TO 5020

 5455   CONTINUE



C  AS OF MONT101F.FOR, BEFORE CALLING NEWCSV, MUST CALL CONVERTCSV,
C  WHICH CONVERTS A "EUROPEAN" .CSV FILE TO THE TYPICAL "AMERICAN"
C  VERSION. IF THE .CSV FILE IS ALREADY IN THE "AMERICAN" FORMAT,
C  CONVERTCSV SIMPLY REWRITES FILE 87 TO SCRATCH FILE 77. NOTE THAT
C  NEWCSV CONVERTS FILE 77 TO FILE 67.

        CALL CONVERTCSV

C  CALL SUBROUTINE NEWCSV WHICH CONVERTS THE .CSV FILE IN FILE 77 TO
C  A NEW .CSV FILE IN FILE 67, WITH ALL MISSING VALUE DOTS CHANGED TO

C  n's. THEN CALL CSVCHANGE WHICH CHANGES .csv FILES WITH CODE OF
C  POPDATA DEC_11 (I.E., THOSE WITH 2 EXTRA COLUMNS FOR ADDL AND II)
C  TO EQUIVALENT .csv FILES WITH CODE OF POPDATA APR_11 (THOSE WITHOUT
C  THE TWO EXTRA COLUMNS). CSVCHANGE READS FILE 67, AND WRITES THE 

C  INFORMATION TO SCRATCH FILE 66. NOTE THAT IF THE .csv FILE READ IN
C  ALREADY IS THE OLDER VERSION (WITH CODE POPDATA APR_11), CSVCHANGE
C  SIMPLY REWRITES IT TO FILE 66, WHICH IS THEN READ BY SUBROUTINE
C  READBLOCK2.

         OPEN(67)
         CALL NEWCSV
         CALL CSVCHANGE 
         REWIND(66)

C  CREATE THE MULTIPLE DRUG WORKING COPY FILE XQZPJ001.ZMQ IN THE
C  WORKING COPY DIRECTORY FROM THE DATA OF THE FIRST SUBJECT IN 
C  PATHFILE. NOTE THAT READBLOCK2 BELOW IS BASED ON
C  READBLOCK IN THE NPAG PC PREP PROGRAM, BUT ONLY CREATES A WORKING
C  COPY FILE FOR THE FIRST SUBJECT.

         CALL READBLOCK2(PATH,C0,C1,C2,C3)
         CLOSE(66)

C  NOW OPEN THE JUST MADE WORKING COPY PATIENT DATA FILE.

        TMPFILE = ' '
        TMPFILE = 'XQZPJ001.ZMQ'
        CALL FULLNAME(PATH,TMPFILE,PATHFILE)
        OPEN(21,FILE=PATHFILE,ERR=5465,STATUS='OLD')
        GO TO 5470
 5465   WRITE(*,5466) PATHFILE,FILEIN

 5466   FORMAT(//' THE FOLLOWING FILE DOES NOT EXIST ... '/
     1' ',A93/
     2' WHICH MEANS THAT YOUR .CSV FILE, ',A20,' WAS NOT READ '/
     3' PROPERLY. PLEASE CHECK THIS FILE TO MAKE SURE IT IS CORRECT.'//)
        GO TO 5020
        
 5470   CONTINUE

        ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(ICSVFILE .EQ. 1) CONDITION.


C  CHECK THAT NUMEQT FOR THIS NEW WORKING COPY FILE IS THE SAME AS 
C  NUMEQT FOR THE OLD FILE. IF NOT CHANGE NUMEQT AND TELL THE USER.

C  CALL SUBROUTINE GETNUMEQ, WHICH READS FILE 21 OPENED  ABOVE TO GET
C  THE NO. OF OUTPUT EQUATIONS (NUMEQT2). 

	CALL GETNUMEQ(NUMEQT2)
	CLOSE(21)

	IF(NUMEQT .NE. NUMEQT2) THEN

	 WRITE(*,7512) NUMEQT2,NUMEQT
 7512    FORMAT(//' YOUR NEW WORKING COPY FILE HAS ',I4,' OUTPUT'/
     1' EQUATION(S), RATHER THAN THE ',I4,' OUTPUT EQUATION(S) THAT '/
     2' YOUR ORIGINAL WORKING COPY FILE HAD. BE SURE TO CHANGE THE '/
     3' ASSAY COEFFICIENT INFORMATION BELOW, IF NEEDED.')


C  IF NUMEQT (OLD) < NUMEQT2 (NEW), PUT 1'S IN ALL NEW ENTRIES OF
C  C0,...,C3. THEY CAN BE CHANGED BY USER BELOW.

	 IF(NUMEQT .LT. NUMEQT2) THEN
	  DO IEQ = NUMEQT+1,NUMEQT2
	   C0(IEQ) = 1
	   C1(IEQ) = 1


	   C2(IEQ) = 1
	   C3(IEQ) = 1
	  END DO
	 ENDIF


	NUMEQT = NUMEQT2


	ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(NUMEQT .NE. NUMEQT2)  CONDITION.
C
C
C
	ENDIF
C
C 
C
	WRITE(*,6) NSUB
    6   FORMAT(/' THE NO. OF PATIENT FILES TO BE SIMULATED IS: ',I5)
C
C

	CALL CHANGE(ICHANG)
	IF(ICHANG .EQ. 0) THEN
C
C
 4070   WRITE(*,121) 
  121   FORMAT(/' ENTER THE NO. OF SUBJECTS TO BE SIMULATED (LESS THAN'/
     1'		10000): ')
	READ(*,*,ERR=4070) NSUB
	IF(NSUB .LE. 0 .OR. NSUB .GT. 10000) GO TO 4070
C
C
        ENDIF
C
C
	WRITE(*,5183)
 5183   FORMAT(//' IF YOU WOULD LIKE TO CHANGE YOUR FORTRAN MODEL'/
     1' FILE OR THE DESIGNATION OF WHICH PARAMETERS ARE TO BE RANDOM'/
     2' AND WHICH FIXED, PLEASE STOP THIS PROGRAM NOW, AND THEN '/
     3' RERUN IT.'//
     4' YOU WILL, HOWEVER, BE ABLE TO CHANGE THE FIXED PARAMETER'/
     5' VALUES, AS WELL AS THE DISTRIBUTION OF THE RANDOM PARAMETERS,'/
     6' AND THEIR BOUNDARIES, BELOW.'//)

	CALL PAUSE

	WRITE(*,201)
  201   FORMAT(/' THE USER-ENTERED FIXED PARAMETER VALUE(S) IS (ARE):')

	IF(NOFIX .EQ. 0) WRITE(*,*)' ... NONE SELECTED.'

	IF(NOFIX .GT. 0) THEN
	  DO 210 I=1,NOFIX
  210     WRITE(*,211) PARFIX(I),VALFIX(I)
	ENDIF

  211   FORMAT(/' ',A11,': ',G17.10)



C  REPLACE WRITING OF C0(),...,C3() WITH XVERIFY (SEE LOGIC IN 
C  SUBROUTINE VERIFYVAL.

	WRITE(*,12)
   12   FORMAT(/' THE ASSAY S.D. COEFFICIENTS, [C0,C1,C2,C3] ARE, FOR'/
     1' EACH OUPUT EQUATION, AS FOLLOWS: ')
       DO IEQ = 1,NUMEQT
        XVERIFY(1) = C0(IEQ)
        XVERIFY(2) = C1(IEQ)
        XVERIFY(3) = C2(IEQ)
        XVERIFY(4) = C3(IEQ)
        CALL VERIFYVAL(4,XVERIFY)
C	  WRITE(*,162) IEQ,C0(IEQ),C1(IEQ),C2(IEQ),C3(IEQ)
        WRITE(*,162) IEQ,(XVERIFY(IXV),IXV=1,4)
	  CALL PAUSE
       END DO

  162   FORMAT(' EQ. ',I2,': ',4(G16.10,1X))
C


C
	CALL CHANGE(ICHANG)
	IF(ICHANG .EQ. 0) THEN

C
C
	WRITE(*,119) 
  119 FORMAT(//' FOR EACH OUTPUT EQUATION, ENTER, IN ORDER, '/
     1' C0,C1,C2,C3, WHERE, FOR EACH OBSERVED VALUE, Y, THE ASSAY'/
     3' STANDARD DEVIATION IS SD = C0+C1*Y+C2*Y**2+C3*Y**3):')

	DO IEQ = 1,NUMEQT
	 WRITE(*,1119) IEQ
 1119    FORMAT(/' ENTER THE VALUES FOR [C0,C1,C2,C3] FOR OUTPUT'/
     1'  EQUATION ',I1,': ')
 4140    READ(*,*,ERR=4145) C0(IEQ),C1(IEQ),C2(IEQ),C3(IEQ)
   	 GO TO 2120
 4145    WRITE(*,4146)
 4146    FORMAT(/' SEE ABOVE; PLEASE ENTER FOUR REAL NUMBERS: ')
	 GO TO 4140
 2120	 CONTINUE
	END DO
C
C
	ENDIF 
C
C
 2020	WRITE(*,2219)
 2219 FORMAT(//' THE DOSE TIMES, THE DOSE AMOUNTS (INCLUDING ALL IV'/
     1' RATES AND BOLUS VALUES), AND THE OBSERVATION TIMES WHICH THE'/ 
     2' PROGRAM HAS READ FROM THE WORKING COPY PATIENT DATA FILE '/
     3' ABOVE WILL ALL BE ASSUMED TO BE "NOISY" VALUES.'//
     5' ENTER 0 FOR AN EXPLANATION OF HOW THE "NOISY" VALUES ARE OBTAINE
     1D.'/
     6' ENTER 1 TO CONTINUE: ')
	READ(*,*,ERR= 2020) ICONT
	IF(ICONT .NE. 0 .AND. ICONT .NE. 1) GO TO 2020

	IF(ICONT .EQ. 0) CALL EXPLAINOISE

C  REPLACE WRITING OF C0DT,...,C3DT WITH XVERIFY (SEE LOGIC IN 
C  SUBROUTINE VERIFYVAL. SIMILARLY, FOR C0DA...; C0OT...

        XVERIFY(1) = C0DT
        XVERIFY(2) = C1DT
        XVERIFY(3) = C2DT
        XVERIFY(4) = C3DT
        CALL VERIFYVAL(4,XVERIFY)
C	  WRITE(*,2221) C0DT,C1DT,C2DT,C3DT
        WRITE(*,2221) (XVERIFY(IXV),IXV=1,4)
 2221   FORMAT(/' FOR THE DOSE TIMES, THE Cs ARE ',4(G14.8,1X))

        XVERIFY(1) = C0DA
        XVERIFY(2) = C1DA
        XVERIFY(3) = C2DA
        XVERIFY(4) = C3DA
        CALL VERIFYVAL(4,XVERIFY)
C       WRITE(*,2222) C0DA,C1DA,C2DA,C3DA
        WRITE(*,2222) (XVERIFY(IXV),IXV=1,4)

 2222   FORMAT(/' FOR THE DOSE AMOUNTS, THE Cs ARE ',4(G14.8,1X))

        XVERIFY(1) = C0OT
        XVERIFY(2) = C1OT
        XVERIFY(3) = C2OT
        XVERIFY(4) = C3OT
        CALL VERIFYVAL(4,XVERIFY)
C       WRITE(*,2223) C0OT,C1OT,C2OT,C3OT
        WRITE(*,2223) (XVERIFY(IXV),IXV=1,4)


 2223   FORMAT(/' FOR THE OBS. TIMES, THE Cs ARE ',4(G14.8,1X))

C
C
	CALL CHANGE(ICHANG)
	IF(ICHANG .EQ. 0) THEN
C

C
	WRITE(*,6223)
 6223   FORMAT(/' ENTER C0,C1,C2,C3 FOR THE DOSE TIMES: ')
 6140   READ(*,*,ERR=6145) C0DT,C1DT,C2DT,C3DT

   	GO TO 6120
 6145   WRITE(*,4146)
	GO TO 6140
 6120	CONTINUE

	WRITE(*,7223)
 7223   FORMAT(/' ENTER C0,C1,C2,C3 FOR THE DOSE AMOUNTS: ')
 7140   READ(*,*,ERR=7145) C0DA,C1DA,C2DA,C3DA
   	GO TO 7120
 7145   WRITE(*,4146)
	GO TO 7140

 7120	CONTINUE

	WRITE(*,8223)
 8223   FORMAT(/' ENTER C0,C1,C2,C3 FOR THE OBSERVATION TIMES: ')
 8140   READ(*,*,ERR=8145) C0OT,C1OT,C2OT,C3OT
   	GO TO 8120
 8145   WRITE(*,4146)
	GO TO 8140
 8120	CONTINUE
C
C
	ENDIF 
C
C

      IF(IDIST .EQ. 0) THEN

        WRITE(*,254) NGAUS
  254   FORMAT(/' THE OBSERVATIONS FOR EACH OF THE ',I3,' SUBJECT'/
     1' VECTORS WILL BE GENERATED BY ASSUMING EACH SUBJECT HAS EXACTLY'/
     2' THE PARAMETER VALUES OF ONE OF THE GRID PTS. IN THE FINAL'/
     3' CYCLE DENSITY FROM THE INPUT NPAG RUN. THESE GRID PTS. ARE: '/)

        CALL PAUSE
C  CALL PAUSE ADDED HERE (IN MONT108.FOR) BECAUSE IF NGAUS IS LARGER 
C  THAN ABOUT 5, THE ABOVE STATEMENT WILL SCROLL OFF THE SCREEN.

C  REPLACE WRITING OF AMEAN(),COV() WITH XVERIFY (SEE LOGIC IN 
C  SUBROUTINE VERIFYVAL).

       DO IGAUS = 1,NGAUS
        WRITE(*,9004) IGAUS
 9004   FORMAT(//' GRID PT. NO: ',I3)
        DO I = 1,NVAR
         XVERIFY(I) = AMEAN(IGAUS,I)
        END DO
        CALL VERIFYVAL(NVAR,XVERIFY)
C       WRITE(*,9007) (AMEAN(IGAUS,I),I=1,NVAR)     
        WRITE(*,9007) (XVERIFY(I),I=1,NVAR)
 9007   FORMAT(/' PAR. VALUES: ',30G10.3)
       END DO

      ENDIF
C  THE ABOVE ENDIF IS FOR THE  IF(IDIST .EQ. 0)  CONDITION.


	IF(IDIST .EQ. 1) WRITE(*,8003) NGAUS
 8003   FORMAT(/' THE SUBJECT VECTORS WILL BE GENERATED FROM A MIXTURE'/
     1' OF ',I3,' GAUSSIAN DISTRIBUTIONS. THE FOLLOWING DESCRIBES '/
     2' THESE DISTRIBUTIONS: ')

	IF(IDIST .EQ. 2) WRITE(*,9003) NGAUS
 9003   FORMAT(/' THE SUBJECT VECTORS WILL BE GENERATED FROM A MIXTURE'/
     1' OF ',I3,' LOGNORMAL DISTRIBUTIONS. THE FOLLOWING DESCRIBES '/
     2' THESE DISTRIBUTIONS: ')


      IF(IDIST .NE. 0) THEN

 4320	WRITE(*,4321)
 4321   FORMAT(/' ENTER 1 TO SEE INFO IN TERMS OF CORRELATIONS; '/
     1' ENTER 0 TO SEE INFO IN TERMS OF COVARIANCES: ')
	READ(*,*,ERR=4320) ICORR
	IF(ICORR .NE. 1 .AND. ICORR .NE. 0) GO TO 4320

	DO 8020 IGAUS=1,NGAUS

C  REPLACE WRITING OF AMEAN(),COF() WITH XVERIFY (SEE LOGIC IN 
C  SUBROUTINE VERIFYVAL).

        WRITE(*,8004) IGAUS
 8004   FORMAT(//' DISTRIBUTION NO: ',I3)
        XVERIFY(1) = COF(IGAUS)
        CALL VERIFYVAL(1,XVERIFY)      
C       WRITE(*,8006) COF(IGAUS)
        WRITE(*,8006) XVERIFY(1)
 8006   FORMAT(/' WEIGHTING COEFFICIENT: ',F10.3)

        IF(ICORR .EQ. 0) THEN
         DO I = 1,NVAR
          XVERIFY(I) = AMEAN(IGAUS,I)
         END DO
         CALL VERIFYVAL(NVAR,XVERIFY)      
C        WRITE(*,8007) (AMEAN(IGAUS,I),I=1,NVAR)
         WRITE(*,8007) (XVERIFY(I),I=1,NVAR)
 8007    FORMAT(/' MEAN VECTOR: ',30G10.3)
         WRITE(*,8008) 
 8008    FORMAT(/' THE COVARIANCE MATRIX, IN LOWER-TRIANGULAR FORM IS:')
         DO I=1,NVAR
          WRITE(*,*) (COV(IGAUS,I,J),J=1,I)
         END DO
	  ENDIF

        IF(ICORR .EQ. 1) THEN

         DO I = 1,NVAR

C  REPLACE WRITING OF AMEAN(),DSQRT() WITH XVERIFY (SEE LOGIC IN 
C  SUBROUTINE VERIFYVAL).

         XVERIFY(1) = AMEAN(IGAUS,I)
         XVERIFY(2) = DSQRT(COV(IGAUS,I,I))
         CALL VERIFYVAL(2,XVERIFY)      
C        WRITE(*,4323) PAR(I),AMEAN(IGAUS,I),DSQRT(COV(IGAUS,I,I))
         WRITE(*,4323) PAR(I),(XVERIFY(IXV),IXV=1,2) 

 4323   FORMAT(/' THE MEAN AND STD. DEV. FOR ',A30,' ARE ',2(G10.3,2X)
     1) 

         END DO

         WRITE(*,4324)
 4324    FORMAT(/' THE CORR. MATRIX IN LOWER-TRIANGULAR FORM IS: ')
	
C  ESTABLISH THE LOWER-TRIANGULAR CORRELATION MATRIX.

	 DO I = 1,NVAR
	  DO J = 1,I
	   CORR(I,J)=COV(IGAUS,I,J)/DSQRT(COV(IGAUS,I,I)*COV(IGAUS,J,J))

	  END DO
	 END DO

	 DO I = 1,NVAR
	  WRITE(*,*) (CORR(I,J),J=1,I)
	 END DO

        ENDIF


C  THE ABOVE ENDIF IS FOR THE  IF(ICORR .EQ. 1) THEN  CONDITION.


	CALL PAUSE

 8020   CONTINUE

C  AS OF MONTBIG7.FOR, 8020 HAS BEEN CHANGED TO BE A CONTINUE STMT SINCE
C  SOME COMPILERS "COMPLAIN" ABOUT ENDING A DO LOOP WITH A PAUSE 
C  COMMAND.

      ENDIF
C  THE ABOVE ENDIF IS FOR THE  IF(IDIST .NE. 0)  CONDITION.

C
C
      CALL CHANGE(ICHANG)
      IF(ICHANG .EQ. 0) THEN

C  SET OUTNPAG TO ALL BLANKS. IF IT CHANGES AFTER A CALL TO GETDIST, IT
C  MEANS THAT IT CONTAINS THE NAME OF THE BIG NPAG OUTPUT FILE FROM 
C  WHICH THE NGAUS DISTRIBUTIONS WERE ESTABLISHED. SIMILARLY FOR
C  TEXTFILE WHICH, IF NOT ALL BLANKS, CONTAINS THE NAME OF THE TEXT FILE
C  WHICH HAS THE NGAUS DISTRIBUTIONS MEANS.

        OUTNPAG(1:20) = '                    '
        TEXTFILE(1:20) = '                    '



C  CALL GETDIST TO OBTAIN THE DESIRED DISTRIBUTION DETAILS FROM THE 
C  USER.

       CALL GETDIST(IDIST,NGAUS,NVAR,COF,AMEAN,COV,PATH,NOB,OUTNPAG,
     1  TEXTFILE,OSname,ListDir)

      ENDIF


C  IF IDIST = 0, SET ALL ILIMIT(.) VALUES TO BE 1.

      IF(IDIST .EQ. 0) THEN
       DO I =1,NVAR
        ILIMIT(I) = 1
       END DO
      ENDIF


      IF(IDIST .NE. 0) THEN

      WRITE(*,143)
  143 FORMAT(/' THE ALLOWABLE BOUNDARIES FOR EACH R.V. ARE SHOWN'/
     1' BELOW. IF A SIMULATED R.V. IS OUTSIDE ITS ALLOWABLE'/
     2' BOUNDARIES, THE CORRESPONDING PARAMETER SET WILL NOT BE USED'/
     3' TO SIMULATE A SUBJECT, BUT WILL BE INCLUDED IN THE CALCULATION'/
     4' OF THE OVERALL SUMMARY STATISTICS IN THE OUTPUT FILE.'//)

C  REPLACE WRITING OF BOUND() WITH XVERIFY (SEE LOGIC IN SUBROUTINE
C  VERIFYVAL). SIMIARLY FOR ALL CALLS TO VERIFYVAL.

       DO I = 1,NVAR
        IF(ILIMIT(I) .EQ. 1) WRITE(*,141) PAR(I)
  141   FORMAT(/1X,A11,' HAS NO RESTRICTIONS ON ITS SIMULATED VALUES')

        XVERIFY(1) = BOUND(I,1)
        XVERIFY(2) = BOUND(I,2)
        CALL VERIFYVAL(2,XVERIFY)
C       IF(ILIMIT(I) .EQ. 0) WRITE(*,142) PAR(I),BOUND(I,1),BOUND(I,2)
        IF(ILIMIT(I) .EQ. 0) WRITE(*,142) PAR(I),(XVERIFY(IXV),IXV=1,2)
  142   FORMAT(/1X,A11,' HAS BOUNDARIES: ',G19.9,'  TO  ',G19.9)   
       END DO 

	 CALL CHANGE(ICHANG)
       IF(ICHANG .EQ. 0) THEN

       DO I = 1,NVAR


  160   WRITE(*,146) PAR(I)
  146   FORMAT(//' FOR ',A11/
     1/' ENTER 1 IF THERE ARE TO BE NO RESTRICTIONS ON ITS SIMULATED VAL
     2UES;'/
     3' ENTER 0 IF THE SIMULATED VALUES ARE TO BE RESTRICTED: ')
        READ(*,*,ERR=160) ILIMIT(I)
        IF(ILIMIT(I) .NE. 1 .AND. ILIMIT(I) .NE. 0) GO TO 160


        IF(ILIMIT(I) .EQ. 0) THEN
  170    WRITE(*,144)
  144    FORMAT(/' ENTER THE DESIRED BOUNDARIES [L,U], WHERE L < U: ')
         READ(*,*,ERR=170) BOUND(I,1),BOUND(I,2)
         IF(BOUND(I,1) .GE. BOUND(I,2)) GO TO 170
        ENDIF

        END DO 

C  THE ABOVE END DO IS FOR THE  DO I = 1,NVAR  LOOP.

       ENDIF

      ENDIF
C  THE ABOVE ENDIF IS FOR THE  IF(IDIST .NE. 0)  CONDITION.

C
C------------------------------------
C

	WRITE(*,8011) FILOUT
 8011   FORMAT(/' THE OUTPUT FILE, WHICH WILL CONTAIN ALL THE'/

     1' GENERATED DATA OF THE PROGRAM IS: ',A32)
C
C
	CALL CHANGE(ICHANG)
	IF(ICHANG .EQ. 0) THEN
C
C
      WRITE(*,1117)
 1117 FORMAT(/,' ENTER THE OUTPUT FILENAME WHICH WILL CONTAIN ALL THE'/
     1' GENERATED DATA OF THIS PROGRAM: ')
      READ(*,102) FILOUT
C
C
	ENDIF

C
C------------------------------------
C
        IF(IPRNPAT .EQ. 1 .OR. IPRNPAT .EQ. 3) 
     1   WRITE(*,9013) NSUB,OUTCSVNAME

 9013   FORMAT(/' THE INFORMATION FROM THE ',I5,' SIMULATED PATIENT'/
     1' DATA FILES WILL BE SAVED IN BLOCK FORMAT TO '/
     2' FILE ',A32)

        IF(IPRNPAT .EQ. 2 .OR. IPRNPAT .EQ. 3) 
     1   WRITE(*,8013) NSUB,PREFIX,EXT
 8013   FORMAT(/' THIS RUN WILL CREATE ',I5,' SIMULATED PATIENT DATA '/
     1' FILES, WITH PREFIX ',A3,' AND EXTENSION ',A3) 
       
        IF(IPRNPAT .EQ. 0) WRITE(*,8014)
 8014   FORMAT(/' THE INFORMATION FROM THIS RUN WILL NOT BE SAVED IN'/
     1' BLOCK FORMAT TO A .CSV FILE, AND NO SIMULATED PATIENT DATA '/
     2' FILES WILL BE CREATED. THIS MEANS THAT YOU ARE ONLY INTERESTED'/
     3' IN THE INFORMATION WRITTEN TO THE OUTPUT FILE.')


        CALL CHANGE(ICHANG)

        IF(ICHANG .EQ. 0) THEN

 1230	  WRITE(*,1234) NSUB,NSUB
 1234   FORMAT(/' ENTER 1 IF YOU WOULD LIKE THE INFORMATION FROM '/

     1'         THE ',I5,' SIMULATED PATIENT DATA FILES TO BE SAVED'/
     2'         IN BLOCK FORMAT TO A .CSV FILE; '/
     3' ENTER 2 IF YOU WOULD LIKE TO CREATE THE ',I5,' SIMULATED '/
     4'         PATIENT DATA FILES IN WORKING COPY FORMAT; '/
     5' ENTER 3 IF YOU WOULD LIKE BOTH A .CSV FILE AND A SET OF '/
     6'         WORKING COPY FILES TO BE MADE;'/
     7' ENTER 0 IF YOU DO NOT NEED A .CSV FILE OR A SET OF WORKING '/
     8'         COPY FILES (I.E., YOU ONLY NEED THE INFO THAT IS '/

     9'         SUPPLIED IN THE OUTPUT FILE): ')
        READ(*,*,ERR=1230) IPRNPAT
        IF(IPRNPAT .LT. 0 .OR. IPRNPAT .GT. 3) GO TO 1230

        IF(IPRNPAT .EQ. 1 .OR. IPRNPAT .EQ. 3) THEN

 1390    WRITE(*,1236)
 1236    FORMAT(/' ENTER THE NAME OF THE FILE WHICH WILL STORE THE'/
     1' SIMULATED INFO IN .CSV FORMAT: ')
         
         READ(*,102) OUTCSVNAME

C  CALL FULLNAME WHICH CONVERTS THE FILENAME TO PATHFILE, THE COMPLETE 
C  NAME OF THE FILE, WHICH INCLUDES THE PATH (IF THE PATH IS NOT THE 
C  CURRENT DIRECTORY).

 1380	   TMPFILE = ' '
         TMPFILE = OUTCSVNAME
         CALL FULLNAME(PATH,TMPFILE,PATHFILE)
         OPEN(29,FILE=PATHFILE,ERR=1370,STATUS='NEW')
         GO TO 1375
 1370    WRITE(*,9826) PATHFILE
 9826    FORMAT(/' THE FOLLOWING FILE ALREADY EXISTS ....'/
     1'    ',A93/
     1' ENTER 0 TO ENTER A NEW FILENAME;'/
     2' ENTER 1 TO OVERWRITE THIS FILE: ')
         READ(*,*,ERR=1370) IFILE
         IF(IFILE .NE. 0 .AND. IFILE .NE. 1) GO TO 1370

         IF(IFILE .EQ. 0) GO TO 1390
         IF(IFILE .EQ. 1) OPEN(29,FILE=PATHFILE)

 1375    CLOSE(29)

        ENDIF

        
        IF(IPRNPAT .EQ. 2 .OR. IPRNPAT .EQ. 3) THEN

         WRITE(*,4041)
 4041    FORMAT(/' ENTER THE 3-CHAR PREFIX FOR THE SIMULATED PATIENT'/
     1' FILENAMES : ')
         READ(*,104) PREFIX
         WRITE(*,4043)
 4043	   FORMAT(/' IF THERE IS A 3-CHAR EXTENSION FOR THE PATIENT '/
     1' FILENAMES, ENTER IT NOW; OTHERWISE, PRESS ENTER: ')
         READ(*,103) EXT

        ENDIF


        ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(ICHANG .EQ. 0)  CONDITION.

C
C------------------------------------
C
	
	IF(ISEEDIND .EQ. 1) WRITE(*,1251)
 1251   FORMAT(/' THE STARTING SEED NO. FOR THE SIMULATOR WILL BE THE'/
     1' DEFAULT VALUE OF -17.')

	IF(ISEEDIND .EQ. 0) WRITE(*,1252)
 1252   FORMAT(/' THE STARTING SEED NO. FOR THE SIMULATOR WILL BE READ'/
     1' FROM THE FILE, "SEEDTO.MON", AND THIS FILE WILL THEN HAVE ITS '/
     2' SEED NO. DECREASED BY 123 FOR THE NEXT RUN.')

	CALL CHANGE(ICHANG)
	IF(ICHANG .EQ. 0) THEN

 1240	WRITE(*,1231)
 1231   FORMAT(/' ENTER 1 IF YOU WISH THE STARTING SEED NO. FOR THE'/
     1' 	SIMULATOR TO BE THE DEFAULT VALUE OF -17;'/
     2' ENTER 0 IF YOU WISH THE STARTING SEED NO. TO BE READ FROM'/
     3'		THE FILE, "SEEDTO.MON" (IN THIS CASE THIS FILE WILL'/
     4'		HAVE ITS SEED NO. DECREASED BY 123 FOR THE NEXT RUN): ')

	READ(*,*,ERR=1240) ISEEDIND
	IF(ISEEDIND .NE. 1 .AND. ISEEDIND .NE. 0) GO TO 1240	

	ENDIF
C
C------------------------------------
C

 5005   WRITE(*,5001)
 5001   FORMAT(///' ENTER 1 IF ALL INSTRUCTIONS ARE NOW CORRECT;'/
     2' ENTER 0 OTHERWISE: ') 
        READ(*,*,ERR=5005) ICHANG
	IF(ICHANG .NE. 0 .AND. ICHANG .NE. 1) GO TO 5005
	IF(ICHANG .EQ. 0) GO TO 8040


	RETURN


	END


C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
	SUBROUTINE CHANGE(ICHANG)
C
C  THIS SUBROUTINE IS CALLED BY SUBROUTINE VERIF1 TO HAVE THE USER CHECK
C  WHETHER HIS INPUT INFO IS CORRECT OR NEEDS TO BE CHANGED.

C
C  INPUT: NOTHING
C
C  OUTPUT:
C
C  ICHANG = 1 IF INFO PRINTED PREVIOUSLY TO THE SCREEN IS CORRECT.
C         = 0 IF INFO PRINTED PREVIOUSLY TO THE SCREEN SHOULD BE 
C             CHANGED.

C
   10   WRITE(*,1)
    1   FORMAT(//' ENTER 1 IF THE ABOVE INFORMATION IS CORRECT;'/
     1' ENTER 0 IF IT SHOULD BE CHANGED: ') 
	READ(*,*,ERR=10) ICHANG
	IF(ICHANG .NE. 0 .AND. ICHANG .NE. 1) GO TO 10
	RETURN
	END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
	SUBROUTINE OldSEEDIR(PATH,NOB,FILENAME)

	CHARACTER FILENAME*32,PATH*61,PRTDIR*47,TEMP*72,PRTDIR2*47

C  NOTE THAT PATH(1:NOB) IS THE CONDENSED (WITHOUT BLANKS) PATH.

   10	PRTDIR = ' '

	WRITE(*,6)
    6   FORMAT(/' PRESS THE ENTER KEY TO SEE YOUR ENTIRE DIRECTORY;'//
     1' ENTER A PARTIAL FILENAME (WITH THE * WILDCARD) TO SEE A '/
     2'       PARTICULAR SUBSET OF FILENAMES IN YOUR DIRECTORY. '/
     3'       e.g., ENTER  "TO*.INS TO SEE A LIST OF ALL FILES WHICH'/
     4'       BEGIN WITH "TO" AND HAVE A .INS SUFFIX '//
     5' NOTE THAT THE FILES WILL AUTOMATICALLY BE TIME-ORDERED FROM '/
     6' OLDEST TO NEWEST.'//
     7' ENTER YOUR CHOICE NOW: ')
	READ(*,1) PRTDIR
    1   FORMAT(A47)

C  REMOVE ANY BLANKS FROM PRTDIR SINCE THERE CAN BE NO BLANKS BETWEEN
C  THE END OF THE PATH AND THE BEGINNING OF THE "OBJECT" OF THE 
C  DIR COMMAND FOR SUBDIRECTORIES. PRTDIR, WITHOUT BLANKS, WILL BE 

C  PRTDIR2.

	IF(PRTDIR .EQ. ' ') TEMP = 'DIR/OD '//PATH(1:NOB)//' |MORE'

	IF(PRTDIR .NE. ' ') THEN
	 PRTDIR2 = ' '
	 J = 0
	 DO I=1,47
	  IF(PRTDIR(I:I) .NE. ' ') THEN
	   J = J+1
	   PRTDIR2(J:J) = PRTDIR(I:I)
	  ENDIF

	 END DO
	 TEMP = 'DIR/OD '//PATH(1:NOB)//PRTDIR2(1:J)//' |MORE'
	ENDIF

        CALL SYSTEM(TEMP)

     	WRITE(*,3)
    3   FORMAT(/' ENTER THE NAME OF THE DESIRED FILE (WITHOUT THE PATH);
     1'/
     2' ENTER -99 TO ENTER A DIFFERENT FILE SPECIFICATION: ')

	READ(*,2) FILENAME

    2   FORMAT(A32)
	IF(FILENAME(1:3) .EQ. '-99') GO TO 10

	RETURN

	END
C
C NEW SEEDIR() for UNIX by Yamada.

C
        SUBROUTINE SEEDIR(PATH,NOB,FILENAME,OSName,ListDir)
        CHARACTER FILENAME*20,PATH*60,PRTDIR*47,TEMP*72,PRTDIR2*47,
     1  OSName*20,ListDir*10

C  NOTE THAT PATH(1:NOB) IS THE CONDENSED (WITHOUT BLANKS) PATH.

   10   PRTDIR = ' '
        IF (INDEX(OSName,"UNIX",.TRUE.).eq.1) THEN
          WRITE(*,7)
        ELSE IF (INDEX(OSName,"DOS",.TRUE.).eq.1) THEN
          WRITE(*,6)
        END IF

    7   FORMAT(/' Press the ENTER key to call system(ls -t). '//
     1' Or type a partial filename (use the * wildcard) to call '/
     2'       system(ls -t arg_1), '/
     3'       e.g., type "to*.f ENTER" to see a list of all files '/
     4'       that begin with "to" and have a .f suffix. '//
     5' ENTER YOUR CHOICE NOW: ')

    6   FORMAT(/' PRESS THE ENTER KEY TO SEE YOUR ENTIRE DIRECTORY;'//
     1' ENTER A PARTIAL FILENAME (WITH THE * WILDCARD) TO SEE A '/
     2'       PARTICULAR SUBSET OF FILENAMES IN YOUR DIRECTORY. '/
     3'       e.g., ENTER  "TO*.INS TO SEE A LIST OF ALL FILES WHICH'/
     4'       BEGIN WITH "TO" AND HAVE A .INS SUFFIX '//
     5' NOTE THAT THE FILES WILL AUTOMATICALLY BE TIME-ORDERED FROM '/
     6' OLDEST TO NEWEST.'//
     7' ENTER YOUR CHOICE NOW: ')
        READ(*,1) PRTDIR
    1   FORMAT(A47)

C  REMOVE ANY BLANKS FROM PRTDIR SINCE THERE CAN BE NO BLANKS BETWEEN
C  THE END OF THE PATH AND THE BEGINNING OF THE "OBJECT" OF THE
C  DIR COMMAND FOR SUBDIRECTORIES. PRTDIR, WITHOUT BLANKS, WILL BE

C  PRTDIR2.

        IF (INDEX(OSName,"UNIX",.TRUE.).eq.1) THEN
           IF(PRTDIR .EQ. ' ') THEN
             TEMP = ListDir//PATH(1:NOB)
           ENDIF
        ELSE IF (INDEX(OSName,"DOS",.TRUE.).eq.1) THEN
           IF(PRTDIR .EQ. ' ') THEN
             TEMP = ListDir//PATH(1:NOB)//' |MORE'
           ENDIF
        ENDIF

        IF(PRTDIR .NE. ' ') THEN
         PRTDIR2 = ' '
         J = 0
         DO I=1,47
          IF(PRTDIR(I:I) .NE. ' ') THEN
           J = J+1
           PRTDIR2(J:J) = PRTDIR(I:I)
          ENDIF
         END DO

         IF (INDEX(OSName,"UNIX",.TRUE.).eq.1) THEN
           TEMP = ListDir//PATH(1:NOB)//PRTDIR2(1:J)
         ELSE IF (INDEX(OSName,"DOS",.TRUE.).eq.1) THEN
           TEMP = ListDir//PATH(1:NOB)//PRTDIR2(1:J)//' |MORE'
         ENDIF

        ENDIF

        CALL SYSTEM(TEMP)

        WRITE(*,3)
    3   FORMAT(/' ENTER THE NAME OF THE DESIRED FILE (WITHOUT THE PATH);
     1'/
     2' ENTER -99 TO ENTER A DIFFERENT FILE SPECIFICATION,'/
     3' OR TO VIEW THE DIRECTORY LISTING AGAIN ')
        READ(*,2) FILENAME
    2   FORMAT(A20)

        IF(FILENAME(1:3) .EQ. '-99') GO TO 10

        RETURN
        END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
	SUBROUTINE FULLNAME(PATH,FILE,FILE2)

C  FULLNAME CONVERTS FILE TO FILE2, THE COMPLETE NAME OF
C  THE FILE, WHICH INCLUDES THE PATH (IF THE PATH IS NOT THE CURRENT
C  DIRECTORY).

	CHARACTER PATH*61,FILE2*93,FILE*32,FILE1*93

C  INITIALIZE FILE1 AND FILE2 AS ALL BLANKS, IN CASE THE USER IS 
C  RE-ENTERING HIS FILENAME (SO THERE WON'T BE SOMETHING ALREADY IN 
C  THESE FILENAMES).

	FILE2 = ' '
	FILE1 = ' '
	FILE1 = PATH//FILE

C  ESTABLISH FILE2 AS FILE1 WITHOUT ANY BLANKS.

	J = 0
        DO I=1,93
	 IF(FILE1(I:I) .NE. ' ') THEN
	  J= J+1
	  FILE2(J:J) = FILE1(I:I)
	 ENDIF
	END DO

	RETURN
	END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C

	SUBROUTINE GETPATH(PATH,NOB)

C  THIS ROUTINE OBTAINS FROM THE USER THE PATH WHERE THE INPUT FILES 

C  ARE LOCATED (AND WHERE THE OUTPUT FILES WILL BE SENT). NOTE THAT
C  PATH RETURNS AS THE PATH WITH A TRAILING BACKSLASH.

C  NOB RETURNS AS THE NO. OF THE LAST NON-BLANK ENTRY IN PATH.

	CHARACTER PATH*61

   10	WRITE(*,1)
    1   FORMAT(/' ENTER 1 IF THE FILES FOR THIS RUN ARE IN THE CURRENT D
     1IRECTORY; '/
     1' ENTER 0 OTHERWISE: ')
	READ(*,*,ERR=10) IPATH
	IF(IPATH .NE. 0 .AND. IPATH .NE. 1) GO TO 10

	IF(IPATH .EQ. 1) PATH = ' '
	NOB = 0

C  IF THE USER ENTERS A NON-NULL PATH BELOW, NOB WILL BE THE NO. OF
C  CHARACTERS IN THE PATH. IF HE ENTERS NOTHING, NOB STAYS 0, WHICH IS

C  THE CORRECT NO. OF CHARACTERS IN A NULL PATH.

	IF(IPATH .EQ. 0) THEN

	 WRITE(*,3)
    3    FORMAT(/' ENTER THE LOCATION (PATH) OF YOUR INPUT FILES. NOTE'/
     1' THAT THE PATH IS LIMITED TO 60 CHARACTERS AND THAT EACH SUB-DIRE
     2CTORY'/
     3' CAN HAVE AT MOST 8 CHARACTERS (E.G, INSTEAD OF " \DIRECTORY ", U
     4SE '/
     5' THE DOS-EQUIVALENT NAME, WHICH MIGHT BE " \DIRECT~1 "). '//
     6' ENTER THE PATH NOW: ')

	 READ(*,2) PATH


    2    FORMAT(A60)

C  IF THE USER DIDN'T END HIS PATH WITH A '\', PUT ONE IN FOR PATH.

C  NOTE THAT IF THE USER ENTERED A BLANK PATH, IT WILL BE ASSUMED THAT
C  HE WANTS THE CURRENT (WORKING) DIRECTORY.

	 DO I=1,60
	  J = 60 + 1 - I
	  IF(PATH(J:J) .NE. ' ') THEN
	   NOB = J
	   IF(PATH(J:J) .NE. '\') THEN
	    PATH(J+1:J+1) = '\'
	    NOB = J+1
	   ENDIF
	   RETURN
	  ENDIF
	 END DO


	ENDIF

	
	RETURN
	END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
	SUBROUTINE USERPREP(NDIM,NP,NVAR,MAXDIM,PAR,NOFIX,
     1  PARFIX,IRAN,INOPT,ICODE,ILIMIT,BOUND)

C  THIS SUBROUTINE, CALLED BY MAIN, READS THE FORTRAN FILE, FORFILE,
C  OPENED IN MAIN (FILE 28), WHICH WAS CREATED BY A 'BOXES'- TYPE 
C  PROGRAM, AND RETURNS THE VALUES IN THE ABOVE ARGUMENT LIST. 

C ???
C  NOTE: WHEN THIS PROGRAM STARTS READING THE NEW BOXES PROGRAM, MAKE
C      SURE THAT THE MICHAELIS-MENTIN EQUATION IS CORRECT - IT SHOULD
C	 BE  (SEE PAGE *1 OF M2_7/m2_7calc.f NOTES OR NOTES FROM PG. 5.
C  	 OF PHARMACOKINETICS AND PHARMACODYNAMICS, VOL 2).

C	 dX/dT = (VM x X) / (KM x V1 + X), WHERE VM = V1 * Vmax, AND
C	  THE UNITS ARE: X --> grams; T --> hours; VM --> grams/hour;

C			 V1 --> liters; KM --> grams/liter;
C			 Vmax --> grams/(liter * hour)

C  NOTE: THE ABOVE EQUATION IS EXACTLY THE SAME AS
C	 dC/dT = (Vmax * C)/(KM + C), WHERE C = X/V1, WHICH IS
C	  EQUATION 3 ON PG. 5 OF PHARMACOKINETICS AND PHARMACODYNAMICS, 
C         VOL 2, WHERE:
C	  Vmax = dC/dT AS C--> infinity;
C	  KM = C WHEN dC/dT = Vmax/2.

C	  ABOVE COMMENTS WERE IMPROVED 7/27/99 AFTER 
C         CONVERSATION WITH ROGER AND DARRYL CLARDY.
C ???

        IMPLICIT REAL*8(A-H,O-Z)
	DIMENSION IRAN(32),BOUND(32,2),ILIMIT(32)

        CHARACTER PAR(30)*11,PARFIX(20)*11,READLINE*78,PSYM(32)*11,
     1  RR*1,TEMP*11,C*1,ERRFIL*20



      COMMON/ERROR/ERRFIL
C  COMMON/ERROR/ IS SUPPLIED TO ALL THE ROUTINES WHICH COULD WRITE TO
C  ERRFIL.



C  FILE 28 WAS OPENED (IN MAIN) AT THE END OF THE FILE. BACKSPACE AND 
C  THEN READ IN NDIM, NP AND PSYM(I),I=1,NP.

    2   FORMAT(A78)

   30	BACKSPACE(28)


	BACKSPACE(28)
	READ(28,2) READLINE
	IF(READLINE(8:9) .NE. 'N=') GO TO 30
	BACKSPACE(28)
	READ(28,3) NDIM
    3   FORMAT(T10,I3)

   40	READ(28,2) READLINE
	IF(READLINE(8:9) .NE. 'NP') GO TO 40
	BACKSPACE(28)
	READ(28,4) NP
    4   FORMAT(T11,I3)

   50	READ(28,2) READLINE
	IF(READLINE(8:11) .NE. 'PSYM') GO TO 50


	BACKSPACE(28)

	DO 70 I=1,NP

	IF(I .LE. 9) READ(28,14) TEMP
	IF(I .GE. 10 .AND. I .LE. 99) READ(28,6) TEMP

C  WRITE TEMP INTO PSYM, STRIPPING OFF THE ENDING QUOTE MARK, IF ONE


C  IS THERE.

	C = ''''
	PSYM(I) = TEMP

	DO J=1,11

	 IF(TEMP(J:J) .EQ. C) THEN
	  PSYM(I) = TEMP(1:J-1)
	  GO TO 70
	 ENDIF	  


	END DO


   70   CONTINUE

   14   FORMAT(T17,A11)
    6   FORMAT(T18,A11)



C  IF INOPT .EQ. 1 (MEANING THE PROGRAM HAS ALREADY
C  OPENED AN INSTRUCTION FILE) THE NEXT LINE IN THE INSTRUCTION FILE HAS
C  THE VALUES FOR IRAN(I),I=1,NP. READ THIS LINE AND PRESENT THE INFO TO
C  THE USER.

        IF(INOPT .EQ. 1) THEN

        IF(ICODE .GE. 7) READ(23,*)
C  SKIP THIS LINE. IT CONTAINS 'IRAN INDICES' IF ICODE .GE. 7.
        
	 READ(23,*) (IRAN(I),I=1,NP)
	 WRITE(*,201)
  201    FORMAT(/' YOU HAVE SELECTED YOUR PARAMETERS TO BE RANDOM'/
     1' OR FIXED AS INDICATED BELOW. IF YOU WANT TO CHANGE THIS, YOU'/
     2' WILL HAVE TO RERUN THIS PROGRAM WITHOUT AN INSTRUCTION FILE'/
     3' SINCE THE REST OF THIS INSTRUCTION FILE (BOUNDARIES AND/OR'/
     4' FIXED VALUES WILL NOT BE COMPATIBLE WITH YOUR CHANGED '/
     5' DESIGNATIONS.'/)


	 CALL PAUSE


	 NVAR = 0
	 NOFIX = 0
	

	 DO I = 1,NP

	  IF(IRAN(I) .EQ. 1) THEN
	   TEMP = 'RANDOM'
	   NVAR = NVAR+1
	   PAR(NVAR) = PSYM(I)
	  ENDIF

	  IF(IRAN(I) .EQ. 0) THEN
	   TEMP = 'FIXED'

	   NOFIX = NOFIX + 1
	   PARFIX(NOFIX) = PSYM(I)
	  ENDIF

	  WRITE(*,202) PSYM(I),TEMP
  202     FORMAT(2X,A11,2X,A11)

	 END DO

  210	 WRITE(*,203)
  203    FORMAT(/' ENTER 1 IF THE ABOVE DESIGNATIONS ARE CORRECT;'/
     1' ENTER 0 OTHERWISE: ')
	 READ(*,*,ERR=210) ICORRECT
	 IF(ICORRECT .NE. 1 .AND. ICORRECT .NE. 0) GO TO 210
	 

	 IF(ICORRECT .EQ. 0) THEN



	  WRITE(*,204)
  204     FORMAT(//' PLEASE RERUN THE PROGRAM WITH KEYBOARD ENTRY.'/)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,204) 

        CLOSE(42)




        CALL PAUSE
	  STOP



	 ENDIF

C  IF NVAR .GT. MAXDIM, PRINT MESSAGE TO USER AND HAVE HIM TRY AGAIN.
C  SIMILARLY IF NOFIX .GT. 20, OR IF NVAR + NOFIX .GT. 32.



  	IF(NVAR .GT. MAXDIM) THEN



	 WRITE(*,207) NVAR,MAXDIM
  207    FORMAT(//' SOMEHOW, YOUR INSTRUCTION FILE HAS ',I2,/
     1' PARAMETERS DESIGNATED TO BE RANDOM VARIABLES. THE LIMIT IS '/
     2' CURRENTLY ',I2,'. PLEASE USE A CURRENT INSTRUCTION FILE OR'/
     3' RERUN THE PROGRAM WITH KEYBOARD ENTRY.'//)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,207) NVAR,MAXDIM
        CLOSE(42)




	 CALL PAUSE
	 STOP



	ENDIF

	IF(NOFIX .GT. 20) THEN



	 WRITE(*,208) NOFIX
  208    FORMAT(//' SOMEHOW, YOUR INSTRUCTION FILE HAS ',I2,/
     1' PARAMETERS DESIGNATED TO BE FIXED. THE LIMIT IS CURRENTLY 20.'/
     2' PLEASE USE A CURRENT INSTRUCTION FILE OR RERUN THE PROGRAM'/
     3' WITH KEYBOARD ENTRY.'//)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,208) NOFIX    
        CLOSE(42)




	 CALL PAUSE
	 STOP



	ENDIF

	IF(NVAR + NOFIX .GT. 32) THEN

	 WRITE(*,209) NVAR + NOFIX
  209    FORMAT(//' SOMEHOW, YOUR INSTRUCTION FILE HAS ',I2,' TOTAL'/
     1' PARAMETERS. THE LIMIT IS CURRENTLY 32. PLEASE USE A CURRENT '/
     2' INSTRUCTION FILE OR RERUN THE PROGRAM WITH KEYBOARD ENTRY.'//)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,209) NVAR + NOFIX
        CLOSE(42)



	 CALL PAUSE
	 STOP



	ENDIF


      IF(ICODE .GE. 9) READ(23,*)
C  SKIP THIS LINE. IT CONTAINS 'BOUNDARIES FOR RANDOM VARIABLES'

C  READ IN ILIMIT(I) FOR EACH RANDOM VARIABLE, AND THE CORRESPONDING

C  DESIRED BOUNDARIES FOR THAT R.V. NOTE THAT IF LIMIT(I) = 1, THE
C  CORRESPONDING BOUNDARIES (WHICH WILL BE = -99  -99), WILL NOT BE
C  USED. NOTE THAT IF ICODE < 7, ALL THE ILIMIT(.) VALUES WILL BE
C  DEFAULTED TO 1.


C  NOTE THAT THESE RESTRICTED BOUNDARIES MAY BE CHANGED BY THE USER 
C  WHEN SUBROUTINE VERIF1 IS CALLED.

       NVAR = 0

       DO I = 1,NP
        IF(IRAN(I) .EQ. 1) THEN
         NVAR = NVAR+1
         IF(ICODE .LE. 8) ILIMIT(NVAR) = 1
         IF(ICODE .GE. 9) READ(23,*) ILIMIT(NVAR),BOUND(NVAR,1),
     1    BOUND(NVAR,2)
        ENDIF
       END DO 


      ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(INOPT .EQ. 1) CONDITION.



C  THE CODE BELOW IS FOR THE INOPT .EQ. 0 CASE. 

	IF(INOPT .EQ. 0) THEN

C  NOW QUIZ THE USER TO SEE WHICH PARAMETERS ARE FIXED, AND WHICH ARE
C  RANDOM. 

C  SET IRAN(I) = 1 IF PSYM(I) = RANDOM;
C		 0 IF PSYM(I) = FIXED.

   80	WRITE(*,7) NP
    7   FORMAT(/' FOR EACH OF THE ',I2,' PARAMETERS, '//
     1' ENTER "R" IF IT IS TO BE A RANDOM VARIABLE;'/
     2' ENTER "F" IF IT IS TO BE A FIXED PARAMETER.'//)

	NVAR = 0
	NOFIX = 0

	DO I=1,NP

   8     FORMAT(1X,A11,':  ')
   60	 WRITE(*,8) PSYM(I)
	 READ(*,9) RR
    9    FORMAT(A1)
	 IF(RR .NE. 'R' .AND. RR .NE. 'r' .AND. RR .NE. 'F' 
     1      .AND. RR .NE. 'f') GO TO 60

	 IF(RR .EQ. 'R' .OR. RR .EQ. 'r') THEN


	  NVAR = NVAR+1
	  PAR(NVAR) = PSYM(I)
	  IRAN(I) = 1


  120 WRITE(*,119)
  119 FORMAT(/' ENTER 1 IF THE SIMULATED VALUES FOR THIS VARIABLE'/
     1'         WILL BE SOLELY DETERMINED BY THE PARAMETERS OF ITS'/
     2'         DISTRIBUTION (AS SPECIFIED BELOW);'/
     3' ENTER 0 IF THE SIMULATED VALUES FOR THIS VARIABLE WILL BE'/
     4'         DETERMINED BY THE PARAMETERS OF ITS DISTRIBUTION ...'/
     5'         SUBJECT TO THE ADDITIONAL CONTRAINT THAT THESE VALUES'/
     6'         BE WITHIN A SPECIFIED INTERVAL THAT YOU ENTER BELOW: '//
     7)
      READ(*,*,ERR=120) ILIMIT(NVAR)
      IF(ILIMIT(NVAR) .NE. 1 .AND. ILIMIT(NVAR) .NE. 0) GO TO 120



      IF(ILIMIT(NVAR) .EQ. 0) THEN

  130  WRITE(*,131)
  131  FORMAT(/' ENTER THE ALLOWABLE BOUNDS (LOWER,UPPER) FOR THE'/
     1' SIMULATED VALUES FOR THIS VARIABLE: ')
       READ(*,*,ERR=130) (BOUND(NVAR,J),J=1,2)

       IF(BOUND(NVAR,1) .GE. BOUND(NVAR,2)) THEN
        WRITE(*,132)
  132   FORMAT(/' THE LOWER BOUNDARY MUST BE < THE UPPER BOUNDARY.')
        GO TO 130
       ENDIF

      ENDIF



      ENDIF

C  THE ABOVE ENDIF IS FOR THE  
C   IF(RR .EQ. 'R' .OR. RR .EQ. 'r')  CONDITION.


	 IF(RR .EQ. 'F' .OR. RR .EQ. 'f') THEN
	  NOFIX = NOFIX+1
        PARFIX(NOFIX) = PSYM(I)
	  IRAN(I) = 0
	 ENDIF

	END DO

C  IF NVAR .GT. MAXDIM, PRINT MESSAGE TO USER AND HAVE HIM TRY AGAIN.
C  SIMILARLY IF NOFIX .GT. 20, OR IF NVAR + NOFIX .GT. 32.

  	IF(NVAR .GT. MAXDIM) THEN
	 WRITE(*,111) NVAR,MAXDIM
  111    FORMAT(//' YOU HAVE SELECTED ',I2,' PARAMETERS TO BE RANDOM'/
     1' VARIABLES. THE LIMIT IS CURRENTLY ',I2,'. PLEASE RESELECT YOUR'/
     2' RANDOM VARIABLES WITH THIS LIMIT IN MIND.'//)
	 GO TO 80
	ENDIF

	IF(NOFIX .GT. 20) THEN
	 WRITE(*,112) NOFIX
  112    FORMAT(//' YOU HAVE SELECTED ',I2,' PARAMETERS TO BE FIXED'/
     1' PARAMETERS. THE LIMIT IS CURRENTLY 20. PLEASE RESELECT YOUR'/
     2' RANDOM VARIABLES WITH THIS LIMIT IN MIND.'//)
	 GO TO 80
	ENDIF

	IF(NVAR + NOFIX .GT. 32) THEN



	 WRITE(*,113) NVAR + NOFIX
  113    FORMAT(//' YOUR MODEL FILE HAS A TOTAL OF ',I2,' PARAMETERS.'/
     1' THE LIMIT IS CURRENTLY 32. PLEASE EDIT YOUR MODEL FILE SO '/
     2' THAT IT HAS .LE. 32 PARAMETERS. '//)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,113) NVAR + NOFIX
        CLOSE(42)



	 CALL PAUSE
	 STOP



	ENDIF


	ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(INOPT .EQ. 0)  CONDITION.


C  THIS COMMENT CORRECTED IN MONTBIG9.FOR. FA IS NO LONGER 

C  NECESSARILY 1.0 (SEE INITCN22.FOR, THE TEMPLATE MODEL FILE).

	RETURN
	END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C  SIMBIG.FOR							4-02-04

C  SIMBIG IS A SIGNIFICANT VARIATION TO SIMALL. SIMALL WAS LINKED TO
C  MONTALL WHICH ALLOWED THE SIMULATION OF PATIENTS HAVING A 
C  3-COMPARTMENT LINEAR MODEL WITH ANY PARAMETERS FROM MENUS 1 OR 2 
C  (SEE COMMENTS BELOW), SIMBIG WILL BE A PART OF MONTBIG WHICH WILL
C  SIMULATE PATIENTS HAVING ANY MODEL WHICH CAN BE CODED INTO THE
C  THE USER-COMPLETED MODULE MONTMOD.FOR, WHICH HAS ROUTINES DIFFEQ, 
C  OUTPUT, AND SYMBOL (THIS MODULE MAY BE MADE BY A BOXES-TYPE PROGRAM 

C  IN THE FUTURE).

C  NEW SUBROUTINES INCLUDE IDCALCY, FUNC2, EVAL2 (FROM idm2x4.f),
C  USERANAL, JACOB (FROM idm1x4.f), ALL THOSE OF MODULE VODTOT.FOR 

C  AND MAKEVEC (FROM bigmlt5.f), SHIFT (FROM SHIFT5.F).

C  SUBROUTINES DELETED INCLUDE ANAL3,CASE1,CASE2,CASE3,CASE4,OUTPUT,
C  GETCOVAR, PRINTMENU, GETIND, PRINCOV, WRITDESC, PARNAM, PARNAM2, 

C  AND PARDEF.


C  SEVERAL DIMENSIONS HAVE BEEN CHANGED (E.G., YPRED IS NOW 2-DIM
C  RATHER THAN 1-DIM). COMMON STATEMENTS HAVE BEEN ADDED; OTHERS 
C  DELETED. 

C-----------------------------------------------------------------------


C  SIMALL.FOR							3-28-01


C  SIMALL HAS THE CHANGES TO SIM5CL TO MAKE IT COMPATIBLE WITH THE
C  MONTALL.FOR PROGRAM (SIM5CL IS PART OF THE MONT5CL.FOR PROGRAM).
C  THE CHANGE IS THAT INSTEAD OF THE PARAMETER SELECTION BEING LIMITED 
C  TO 5 PARAMETERS (CL,VS,KA,KCP,KPC), IT WILL NOW BE EXTENDED TO THE 
C  ENTIRE MENU LIST FROM MENUS 1 AND 2 OF THE LITTLE NPEM PROGRAMS.

C  THIS WILL REQUIRE THE SAME LOGIC AS IN LITTLE NPEM REGARDING THE
C  IDENTIFYING OF COVARIATE INFORMATION, AS WELL AS USING SUBROUTINE
C  PARDEF (CURRENTLY IN PARADP17.FOR).

C  NOTE THAT NPAR, NOFIX, NFIX, AND VALFIX WILL NO LONGER BE PASSED
C  TO SUBROUTINE SIMMN2 (SINCE THESE VALUES WILL BE PASSED DIRECTLY TO
C  SUBROUTINE PARDEF VIA COMMON/TOPAR).

C  NOTE THAT MODULES MOD4CL.FOR AND ANALAXLA.FOR HAVE BEEN REMOVED, AND

C  THEIR SUBROUTINES (OR VERSIONS THEREOF) HAVE BEEN RELOCATED INTO 
C  THIS MODULE (WHICH REPLACES SIM5CL.FOR).
  
C  NOTE THAT LOTS OF CODE PREVIOUSLY IN THE MAIN OF THIS MODULE HAS

C  BEEN RELOCATED TO IDCALCY AND THE ROUTINES IT CALLS. ALSO, THERE HAVE 

C  BEEN EXTENSIVE CHANGES (MOSTLY SIMPLIFICATIONS) IN SUBROUTINE INOUT.

C-----------------------------------------------------------------------

C  FOR COMMENTS ON PREVIOUS PROGRAMS, SEE SIMALL.FOR CODE.

C***********************************************************************

        SUBROUTINE SIMBIG(PREFIX,EXT,FILEIN,NSUB,NVAR,NOFIX,IRAN,VALFIX,
     1   C0,C1,C2,C3,IDIST,NGAUS,COF,AMEAN,COV,PATH,NDIM,PAR,
     2   IPRNPAT,ISEEDIND,ICSVFILE,OUTCSVNAME,OSname,DeleteFile,Listdir,
     3   ILIMIT,BOUND)

        IMPLICIT REAL*8(A-H,O-Z)


	PARAMETER(MAXNUMEQ=7)


        DIMENSION TIM(594),SIG(5000),Y(594,MAXNUMEQ),RS(5000,34),
     1   BS(5000,7),AMEAN(150,30),COV(150,30,30),ALF(594),
     2   AS(594,MAXNUMEQ),AMEANC(594),
     2   COVC(594,594),VALALF(100000,30),SAMMEN(30),SAMCOV(30,30),
     3   COF(150),YPRED(594,MAXNUMEQ),IRAN(32),AS1(594),PX(32),
     4   C0(MAXNUMEQ),C1(MAXNUMEQ),C2(MAXNUMEQ),C3(MAXNUMEQ),
     5   YPREDSUB(10000,594,MAXNUMEQ),YMEAN(594,MAXNUMEQ),
     1   YMIN(594,MAXNUMEQ),YMAX(594,MAXNUMEQ),YSD(594,MAXNUMEQ),
     2   Y025(594,MAXNUMEQ),Y25(594,MAXNUMEQ),Y50(594,MAXNUMEQ),
     3   Y75(594,MAXNUMEQ),Y975(594,MAXNUMEQ),ASUB(10000,594,MAXNUMEQ),
     3   XPRED(594,20),XPREDSUB(10000,594,20),SAMCOR(30,30),
     4   TIMORIG(594),ILIMIT(32),BOUND(32,2),OVERALF(100000,30),
     5   VALFIX(20),XVERIFY(900)

C  NOTE THAT AMEANC, COVC, AND ALF MUST HAVE DIMENSIONS OF 594 TO BE
C  COMPATIBLE WITH THEIR BEING CALLING ARGUMENTS TO SUBROUTINE GNRAT,
C  EVEN THOUGH THEY WILL CONTAIN NO MORE THAN NVAR ENTRIES IN EACH OF
C  THEIR DIMENSIONS.


	CHARACTER PREFIX*3,EXT*3,FILEIN*32,NUMBER(99999)*5,
     1   PATFIL*32,PATH*61,TMPFILE*32,PATHFILE*93,PATHFIL2*93,
     2   PATHFIL3*93,PAR(30)*11,CHARSUB*5,READBOT(99)*72,OUTCSVNAME*32,
     3   READBOTL*72,OSname*20,Deletefile*4,ListDir*10,ERRFIL*20


      COMMON/ERROR/ERRFIL
C  COMMON/ERROR/ IS SUPPLIED TO ALL THE ROUTINES WHICH COULD WRITE TO
C  ERRFIL.

	COMMON/OBSER/ TIM,SIG,RS,Y,BS
	COMMON/SUM2/ M,NPNL
        COMMON/CNST2/ NPL,NOS,NDRUG,NADD
	COMMON/COMAMT/XPRED
	COMMON/BOTPART/NBOTLINE,READBOT

C  COMMON/BOTPART IS PROVIDED FROM INOUT TO WRITE THE BOTTOM PART OF
C  THE WORKING COPY FILE TO EACH SIMULATED PATIENT DATA FILE.


C  CALL SUBROUTINE GETCHAR TO ESTABLISH THE NUMBER ARRAY.

	DO JSUB = 1,NSUB
	 CALL GETCHAR(JSUB,CHARSUB)
	 NUMBER(JSUB) = CHARSUB
	END DO


C*****INITIALIZE PROGRAM*****


C  FOR MONT101F.FOR, IJUMP IS REMOVED. SEE COMMENTS BELOW.


C  AS OF MONTBIG9.FOR, SEEDTO.MON IS ONLY ACCESSED IF ISEEDIND = 0.
C  OTHERWISE, THE INITIAL SEED NO., IDUM, IS SET = -17.

	IDUM = -17

	IF(ISEEDIND .EQ. 0) THEN

C  READ IDUM FROM THE FILE, 'SEEDTO.MON'

C  AS OF MONTBIG7.FOR, SEEDTO.MON IS NOW PART OF A BIGGER FILE WITH THE
C  PATH INCLUDED. 

C  CALL FULLNAME WHICH CONVERTS THE FILENAME TO PATHFILE, THE COMPLETE 
C  NAME OF THE FILE, WHICH INCLUDES THE PATH (IF THE PATH IS NOT THE 
C  CURRENT DIRECTORY).


        TMPFILE = ' '

	TMPFILE = 'SEEDTO.MON'
	CALL FULLNAME(PATH,TMPFILE,PATHFILE)

     	OPEN(25,FILE=PATHFILE,ERR=1200,STATUS='OLD')
	GO TO 1210
 1200   WRITE(*,1201)
 1201   FORMAT(/' PLEASE PUT THE SEED NO. FOR THE RANDOM NO. GENERATOR'/
     1' INTO THE TOP LINE OF THE FILE SEEDTO.MON, AND THEN RERUN THE '/
     2' PROGRAM.'//
     3' THE FILE, SEEDTO.MON, MUST BE IN THE SAME DIRECTORY AS THE'/
     4' WORKING DIRECTORY FOR THIS RUN. '//)
	WRITE(23,1201)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,1201) 
        CLOSE(42)



      CALL PAUSE
	STOP

 1210   READ(25,*) IDUM


C  REPLACE THE NO. IN 'SEEDTO.MON' BY IDUM-123

	JDUM = IDUM - 123
	BACKSPACE(25)
	WRITE(25,*) JDUM
	CLOSE(25)

	ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(ISEEDIND .EQ. 0)  CONDITION.



C  IDUM IS FED TO SUBROUTINES GNRAT AND NOSGEN, WHICH CALL RAN1 THE
C  UNIFORM [-1,1] GENERATOR. IT SHOULD BE INITIALIZED TO A NEGATIVE
C  NUMBER, BUT IS THEN, FOR EACH ADDITIONAL CALL, 1 (THIS TELLS RAN1
C  NOT TO REINITIALIZE).

C***********************************************************************

C  THE FOLOWING INFO WAS OBTAINED FROM THE USER, AND PASSED AS ARGUMENTS


C  FROM MONTALL/MAIN.

C  PREFIX+EXT WHICH DEFINES THE OUTPUT PATIENT FILENAMES (SEE BELOW). 


C  ICSVFILE = 0 IF THE DOSAGE REGIMEN AND OBSERVATION TIMES FOR THE
C               SIMULATED SUBJECTS WILL BE INPUT USING A (MULTIPLE DRUG)
C               WORKING COPY PATIENT DATA FILE.
C           = 1 IF THIS INFO WILL BE INPUT USING A .CSV FILE. IN THIS
C               CASE, THE INFO WILL BE TAKEN FROM THE FIRST SUBJECT'S

C               DATA IN THE .CSV FILE.

C  FILEIN = THE NAME OF THE FILE WHICH HAS THE PATIENT DOSAGE REGIMEN
C           AND OBS. TIMES. IF ICSVFILE = 0, IT WILL BE A (WORKING COPY)
C           PATIENT DATA FILE; IF ICSVFILE = 1, IT WILL BE A .CSV FILE.

C  NSUB = NO. OF SUBJECTS = NO. OF VECTORS (ALF(I),I=1,NVAR) TO BE 
C         GENERATED BELOW. (1 .LE. NSUB .LE. 999). 

C  NVAR = NO. OF VARIABLES FOR THIS SIMULATION.


C  C0(J),C1(J),C2(J),C3(J) = THE COEFFICIENTS FOR THE ASSAY STD. DEV. 
C   OF OUTPUT EQUATION J OF THE OUTPUT VALUES.

C  INFO ON THE DISTRIBUTION OF THE SUBJECT VECTORS TO BE GENERATED. 
C  ASSUME EACH SUBJECT VECTOR COMES FROM A GAUSSIAN MIXTURE (IF 
C  IDIST = 1) OR A LOGNORMAL MIXTURE (IF IDIST = 2). THIS MIXTURE WILL
C  BE SUM[COF(I)*D(I)], I=1,NGAUS, WHERE THE SUM OF THE   
C  COEFFICIENTS, COF(I), IS 1.0, AND EACH D(I) IS AN NVAR-VARIATE NORMAL
C  OR LOGNORMAL DISTRIBUTION.

C  SO THE USER ENTERED NGAUS, COF(I), I=1,NGAUS, AND NGAUS SETS OF
C  MEAN VECTORS, AMEAN(I,J), J=1,NVAR, I=1,NGAUS; AND COVARIANCE 
C  MATRICES, COV(I,J,K), K=1,J, J=1,NVAR, I=1,NGAUS.

C  AS OF MONT107.FOR, THE IDIST = 0 CASE --> SUBJECT I WILL HAVE EXACTLY
C  THE PARAMETER VALUES IN THE CORRESPONDING MEAN VECTOR AND, OF COURSE,
C  THE NO. OF SUBJECTS SIMULATED WILL BE = NGAUS, THE NO. OF GRID PTS.
C  IN THE INPUT NPAG OUTPUT FILE.


C  THE FOLLOWING IS OUTPUT BY THE PROGRAM:

C  FOR EACH OF THE NSUB PATIENTS:

C      ALF(I),I=1,NVAR, THE GENERATED PARAMETER VALUES. 
C      AS(J,K), J=1,M; K=1,NOS = THE N(0,1) VALUES USED IN 
C             ESTABLISHING THE ASSAY NOISE VALUES (M = NO. OF 
C             OBSERVATION TIMES; K= NO. OF OUTPUT EQUATIONS; THEY ARE
C             READ IN VIA SUBROUTINE INOUT). 
C      YPRED(J,K),J=1,M; K=1,NOS = THE OUTPUT CONCENTRATIONS (WHICH 
C             HAVE BEEN 'CORRUPTED' WITH THE ASSAY NOISE).
C      SIMULATED AMOUNTS IN ALL COMPARTMENTS.

C      SUMMARY STATISTICS ON THE PARAMETERS (ALF) AND THE CONCENTRATIONS
C             (YPRED).

C***********************************************************************

C  THE OUTPUT FILE (FILE 23) HAS ALREADY BEEN OPENED IN MAIN AND FILLED 
C  WITH THE USER-INPUT INSTRUCTIONS AT THE TOP. WRITE IDUM TO THIS FILE,
C  AND LEAVE IT OPEN (IT WILL BE FILLED WITH ALL THE SIMULATED VALUES
C  AS THEY ARE GENERATED).


     	WRITE(23,1202) IDUM
 1202   FORMAT(I9,' <-- SEED NO. FOR THE FOLLOWING SIMULATION. '/)


C  IF ICSVFILE = 0, FILEIN IS THE WORKING COPY FILE FROM WHICH THE
C   DOSAGE AND OBS. TIME INFO TO BE USED IN THE SIMULATIONS WILL BE 
C   READ.

C  IF ICSVFILE = 1, 'XQZPJ001.ZMQ' WAS CREATED IN MAIN TO BE THE WORKING
C   COPY FILE FROM WHICH THE DOSAGE AND OBS. TIME INFO TO BE USED IN THE
C   SIMULATIONS WILL BE READ.

        IF(ICSVFILE .EQ. 0) TMPFILE = FILEIN
        IF(ICSVFILE .EQ. 1) TMPFILE = 'XQZPJ001.ZMQ'

C  CONVERT FILEIN TO PATHFIL2, WHICH WILL INCLUDE THE PATH.
	
	 CALL FULLNAME(PATH,TMPFILE,PATHFIL2)

C  THE FILES TO BE MADE DEPEND ON IPRNPAT AS FOLLOWS:


C  IF IPRNPAT .GE. 1 --> MAKE WORKING COPY PATIENT FILES.
C   IPRNPAT .EQ. 1 --> CONVERT THESE PATIENT FILES TO BLOCK FORMAT
C                      INFO AND PUT INTO OUTCSVNAME.
C                      THEN, DELETE WORKING COPY PATIENT FILES.
C   IF IPRNPAT .EQ. 2 --> NOTHING ELSE TO BE DONE.
C   IF IPRNPAT .EQ. 3 --> CONVERT THESE PATIENTS TO BLOCK FORMAT INFO
C                         AND PUT INTO OUTCSVNAME.

C  BUT NOTE THAT IF IPRNPAT = 1, CHANGE PREFIX AND EXT FROM
C  WHATEVER THEY WERE BEFORE (THEY COULD HAVE BEEN READ IN IF
C  IPRNPAT WAS ORIGINALLY 2 OR 3 IN THE INSTRUCTION FILE) TO
C  PREFIX = '7Q9' AND EXT = 'Z3Q'. THE CHANCES THAT
C  THESE WOULD MATCH OTHER FILENAMES ARE 1/36^6 < 1 OUT OF 2 BILLION.
C  OTHERWISE, THERE IS A CHANCE THAT PATIENT DATA FILES WHICH
C  ALREADY EXIST WITH THE SAME NAME WILL BE OVERWRITTEN, AND 
C  THEN ERASED.

        IF(IPRNPAT .EQ. 1) THEN
         PREFIX = '7Q9'
         EXT = 'Z3Q'
        ENDIF
 
C  GENERATE NSUB PATIENT DATA FILES IF IPRNPAT .GE. 1.


C  INITIALIZE ITOTSETS = 0. THIS WILL BE THE RUNNING NO. OF TOTAL
C  PARAMETER SETS SIMULATED BELOW. IF EVERY PARAMETER SET HAS ALL ITS
C  PARAMETER VALUES WITHIN THE REQUIRED BOUNDARIES (SEE CODE/COMMENTS
C  AROUND THE GO TO 9800 STATEMENT BELOW), THEN ITOTSETS WILL BE THE
C  SAME AS NSUB AT THE END OF THE 9900 LOOP. BUT IF SOME PARAMETER SETS
C  HAVE PARAMETER VALUES OUTSIDE THEIR REQUIRED BOUNDARIES, ITOTSETS

C  WILL END UP BEING > NSUB.

        ITOTSETS = 0


        DO 9900 ISUB = 1,NSUB

	 IF(IPRNPAT .GE. 1) THEN
	  PATFIL=PREFIX//NUMBER(ISUB)//'.'//EXT
	  TMPFILE = PATFIL
	  CALL FULLNAME(PATH,TMPFILE,PATHFIL3)
	 ENDIF

C  AS OF MONT101F.FOR, INOUT WILL BE CALLED FOR EVERY SUBJECT, SINCE
C  IT IS NECESSARY TO RESET THE VALUES IN COMMON/OBSER IN THE CASE
C  WHERE PATHFIL2 CONTAINS STEADY STATE DOSE SETS. I.E., IN THIS CASE,
C  SUBROUTINE NEWWORK1 MUST ALTER THE DOSAGE BLOCK AND OBS. TIMES
C  TO BE WHAT IS EXPECTED BY SUBROUTINE FUNC2. BUT THE ORIGINAL
C  DOSAGE BLOCK AND OBS. TIMES ARE WHAT MUST BE WRITTEN TO EACH
C  SIMULATED PATIENT FILE.

         CALL INOUT(ISUB,PATHFIL2,PATHFIL3,IPRNPAT,TIMORIG)

C  OBTAIN THE PARAMETER VALUES FOR THIS SUBJECT'S SIMULATION, ALF(I),
C  I=1,NVAR. ALF HAS A GAUSSIAN (IF IDIST = 1) OR A LOGNORMAL 
C  (IF IDIST = 2) MIXTURE DIST. EACH PARAMETER HAS PROBABILITY COF(I) 
C  OF HAVING MEAN=AMEAN(I,.) AND COVARIANCE COV(I,.,.).
C  NOTE: SUM(COF(I))=1, OF COURSE.

C  AS OF MONT107.FOR, THE NEW IDIST = 0 OPTION --> ALF(I) WILL BE 
C  EXACTLY AMEAN(ISUB,I). SET THESE VALUES AND THEN GO IMMEDIATELY TO
C  LABEL 6510. NOTE THAT IF IDIST = 0, NSUB WAS SET = NGAUS IN MAIN,
C  AND SO AMEAN(ISUB,.) CONTAINS THE EXACT PARAMETER VALUES FOR THIS
C  SUBJECT. AMEAN(.,.) VALUES WERE SET IN SUBROUTINE READNPAG.
 

        IF(IDIST .EQ. 0) THEN

         DO I = 1,NVAR
          ALF(I) = AMEAN(ISUB,I)
         END DO
         GO TO 6510
        ENDIF



C  1ST, SELECT A UNIFORM RANDOM VARIABLE INSIDE [0,1]. THE SEED NO. 
C  (IDUM) FOR THE RANDOM NUMBER GENERATOR (RAN1) HAS ALREADY BEEN 
C  INITIALIZED AS A NEGATIVE NO AS REQUIRED. 

 9800   ZRAN=RAN1(IDUM)




C  ZRAN IS THE PROPORTIONAL DISTANCE BETWEEN 0 AND 1 FOR THIS UNIFORM 
C  RANDOM VARIABLE. SELECT THE GAUSSIAN MIXTURE COMPONENT WHICH
C  CORRESPONDS TO THIS PROPORTION ...
C  (E.G., IF NGAUS=4 AND COF(I)=.25 FOR I=1,2,3,4, THEN SELECT THE 1ST
C  COMPONENT IF ZRAN IS IN [0,.25], THE 2ND COMPONENT IF ZRAN IS IN
C  [.25,.50], ETC.

        STRTIN=0.D0

        DO IGAUS = 1,NGAUS

         ENDIN = STRTIN + COF(IGAUS)

C  INTERVAL IGAUS IS [STRTIN,ENDIN].

         IF(ZRAN .GE. STRTIN .AND. ZRAN .LE. ENDIN) THEN
          ICOMP=IGAUS
          GO TO 5060
         ENDIF

C  UPDATE STRTIN FOR THE NEXT COMPONENT, AND CONTINUE CHECKING.

         STRTIN = ENDIN

        END DO

C  THE ABOVE END DO IS FOR THE  DO IGAUS = 1,NGAUS  LOOP.

C  NOW, CALL GNRAT TO GET ALF(I), I=1,NVAR, WHICH IS GENERATED FROM A
C  DIST, WITH MEAN=AMEAN(ICOMP,.) AND LOWER-TRI COV = COV(ICOMP,.,.),
C  WHERE THE DISTRIBUTION IS NORMAL IF IDIST = 1, AND LOGNORMAL IF
C  IDIST = 2.

 5060    DO I=1,NVAR
          AMEANC(I) = AMEAN(ICOMP,I)
          DO J=1,I
  	   COVC(I,J) = COV(ICOMP,I,J)
	  END DO
	 END DO

C  IF IDIST = 1, AMEANC AND COVC ALREADY CONTAIN THE MEAN AND COV.
C  MATRIX DESIRED. IF IDIST = 2, MUST CONVERT THE DESIRED LOGNORMAL
C  MEANS AND COVARIANCES INTO THE CORRESPONDING MEANS AND COVARIANCES 
C  FOR A NORMAL DIST.


	IF(IDIST .EQ. 2) THEN

	 DO I=1,NVAR
	  DO J=1,NVAR
	   COVC(I,J) = DLOG(COVC(I,J)/AMEANC(I)/AMEANC(J)+1.D0)
	  END DO 
	 END DO

C  COVC(.,.,.) NOW HAS THE COV. VALUES FOR THE NORMAL DISTRIBUTION 
C  WHICH CORRESPONDS TO THE DESIRED LOGNORMAL DISTRIBUTION.

	 DO I=1,NVAR
	  AMEANC(I) = DLOG(AMEANC(I)) - COVC(I,I)/2.D0
	 END DO

C  AMEANC(.,.) NOW HAS THE MEAN VALUES FOR THE NORMAL DISTRIBUTION 
C  WHICH CORRESPONDS TO THE DESIRED LOGNORMAL DISTRIBUTION.

	ENDIF


	 CALL GNRAT(NVAR,AMEANC,COVC,ALF,IDUM)

C  STORE THESE PARAMETER VALUES INTO VALALF, SO THE SAMPLE MEANS AND
C  COVARIANCES CAN BE CALCULATED LATER. BUT NOTE THAT ALF ARE THE
C  PARAMETER VALUES ONLY IF IDIST = 1. IF IDIST = 2, MUST CONVERT
C  ALF, WHICH ARE NORMAL VALUES, TO LOGNORMAL VALUES.

	 IF(IDIST .EQ. 2) THEN
	  DO I = 1,NVAR
	   ALF(I) = DEXP(ALF(I))
	  END DO
	 ENDIF

C  TEST THAT EACH ALF(I) IS WITHIN ITS REQUIRED BOUNDARIES ... IF
C  ITS ILIMIT(I) = 0 (OTHERWISE ALF(I) IS UNRESTRICTED).

      IOK = 1
      DO I = 1,NVAR
       IF(ILIMIT(I) .EQ. 0) THEN
        IF(ALF(I) .LT. BOUND(I,1) .OR. ALF(I) .GT. BOUND(I,2)) IOK = 0
       ENDIF
      END DO


 6510  CONTINUE

C  6510 IS WHERE CONTROL IS TRANSFERRED FROM ABOVE IF IDIST = 0, SINCE
C  IN THAT CASE, ALF(I) WAS SET EXACTLY = AMEAN(ISUB,I), I=1,NVAR,
C  ABOVE.


C  STORE THIS ALF(.) VECTOR INTO THE OVERALL ARRAY OF PARAMETER SETS,
C  OVERALF. BUT DO NOT STORE IT INTO THE ARRAY VALALF, WHICH IS 
C  RESERVED FOR THOSE PARAMETER SETS THAT RESULT IN SIMULATED SUBJECTS,
C  UNLESS IOK = 1 (I.E., UNLESS ALL PARAMETER VALUES ARE WITHIN THEIR
C  REQUIRED BOUNDARIES). 

C  SO, IF IOK = 1, CONTINUE TO SIMULATES A SUBJECT. BUT IF IOK = 0,
C  RETURN TO LABEL 9800 TO GET THE NEXT PARAMETER SET CANDIDATE.


      ITOTSETS = ITOTSETS + 1

C  CHECK THAT ITOTSETS IS STILL WITHIN THE ALLOWED MAXIMUM. IF NOT,
C  WRITE STATEMENT TO THE USER AND STOP.

      IF(ITOTSETS .GT. 100000) THEN



       WRITE(*,9801) NSUB
 9801  FORMAT(//' BECAUSE OF THE BOUNDARY RESTRICTIONS ON PARAMETER'/
     1' VALUES, THE DESIRED NO. OF SUBJECTS, ',I6,', COULD NOT BE '/
     2' SIMULATED BEFORE THE MAXIMUM NO. OF SIMULATED PARAMETER SETS,'/
     3' 100000, WAS REACHED.'//
     4' THE PROGRAM STOPS.'//
     5' PLEASE RERUN THE PROGRAM WITH LESS RESTRICTIVE BOUNDARIES.'//)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,9801) NSUB  
        CLOSE(42)

       CALL PAUSE
       STOP



      ENDIF


      DO I = 1,NVAR
       OVERALF(ITOTSETS,I)=ALF(I)
      END DO

      IF(IOK .EQ. 0) GO TO 9800

C  TO GET HERE --> IOK = 1 --> STORE THIS PARAMETER SET INTO VALALF,
C  AND CONTINUE TO SIMULATE SUBJECT ISUB.

       DO I=1,NVAR
        VALALF(ISUB,I)=ALF(I)
       END DO


	 IF(IPRNPAT .GE. 1) WRITE(*,9009) ISUB

 9009    FORMAT(' SIMULATING SUBJECT NO. ',I7)


	 IF(IPRNPAT .EQ. 0) WRITE(*,9019) ISUB
 9019    FORMAT(' SUBJECT NO. ',I7)


C  OBTAIN THE ASSAY NOISE VALUES FOR THIS SUBJECT. CALL NOSGEN TO 
C  GET A NORMAL VECTOR OF LENGTH M, WITH MEAN = 0 VECTOR, AND COV. 
C  MATRIX = THE IDENTITY MATRIX. THIS VECTOR IS AS1(I),I=1,M. ASSIGN 
C  THESE VALUES TO AS(I,1). THEN REPEAT THIS STEP FOR EACH OF THE 
C  OUTPUT EQUATIONS J=1,NOS.

	 DO J=1,NOS
	  CALL NOSGEN(M,1.D0,IDUM,AS1)
	   DO I=1,M
	    AS(I,J) = AS1(I)
	    ASUB(ISUB,I,J) = AS(I,J)
	   END DO
	 END DO

C  BEFORE CALLING IDCALCY TO HAVE IT CALCULATE PREDICTED VALUES,
C  MUST MAKE SURE THE CORRECT DOSAGE REGIMEN AND OUTPUT TIMES, ETC. ARE
C  STORED INTO THE ARRAYS IN COMMON/OBSER. THESE MUST BE THE ARRAYS IN 
C  THE WORKING COPY FILE CONVERTED FROM PATHFIL2 BY SUBROUTINE NEWWORK1 
C  (I.E., SUBROUTINE FUNC2 IS CODED TO WORK ON WORKING COPY FILES
C  AFTER THEY HAVE BEEN RUN THROUGH NEWWORK1). SO CALL NEWWORK1 TO 
C  CONVERT FILE PATHFIL2 (WHICH WILL BE OPENED BELOW AS FILE 31) TO
C  SCRATCH FILE 41, AND THEN CALL SUBROUTINE STOREOBSER TO READ
C  FILE 41 SO THAT THE PROPER ARRAY VALUES CAN BE STORED INTO 
C  COMMON/OBSER.

	OPEN(31,FILE=PATHFIL2,STATUS='OLD')

C  CALL SUBROUTINE NEWWORK1 TO CONVERT FILE 31 TO FILE 41 (BASED ON THE
C  STAND-A-LONE PROGRAM OF THE SAME NAME). NOTE THAT IF FILE 31 HAS NO
C  STEADY STATE DOSE INDICATORS, FILE 41 WILL = FILE 31; IF IT DOES, 
C  FILE 41 WILL BE ALTERED TO INCLUDE AN EXTRA 101 DOSES SETS FOR EACH
C  STEADY STATE DOSE INDICATOR. NOTE THAT, UNLIKE IN THE STAND-A-LONE
C  PROGRAM, SUBROUTINE NEWWORK1 WILL LEAVE IN THE NEGATIVE DOSE TIME 
C  (WHICH IS THE STEADY STATE DOSE INDICATOR) BECAUSE THE ID ROUTINE
C  IN THIS PROGRAM (FUNC2) NEEDS TO SEE THIS INDICATOR TO KNOW THAT A
C  STEADY STATE DOSE SET IS COMING.

       OPEN(41)
 
       CALL NEWWORK1 

C  NOTE THAT NEWWORK1 CLOSE FILES 31.
	  
       REWIND(41)


       CALL STOREOBSER

C  NOTE THAT STOREOBSER CLOSES FILE 41.


C  CALL SUBROUTINE IDCALCY, A VERSION OF THE ID PROGRAM WHICH SIMPLY
C  CALCULATES THE PREDICTED VALUES OF YO(I,J) = OUTPUT CONCENTRATION OF
C  THE JTH OUTPUT EQUATION (J=1,NUMEQT) AT THE ITH OBSERVATION TIME
C  (I=1,NOBSER), ASSUMING THE PARAMETER VECTOR ALF ... BUT
C  BEFORE ALL CALLS TO IDCALCY, MUST INTEGRATE FIXED AND RANDOM
C  VALUES INTO PX, USING IRAN(I),I=1,NVAR+NOFIX. CALL MAKEVEC TO DO
C  THIS.

	 CALL MAKEVEC(NVAR,NOFIX,IRAN,ALF,VALFIX,PX)
	 CALL IDCALCY(NVAR+NOFIX,NDIM,PX,YPRED,IDUM)

C*****OUTPUT RESULTS*****


C  THE GENERATED 'TRUE' OUTPUT VALUES (YPRED, OBTAINED FROM THE CALL
C  TO IDCALCY ABOVE) ARE TO BE 'CORRUPTED' WITH ASSAY NOISE. IN 
C  PARTICULAR, WITH YPRED(I,J) = Y(I,J):
C  FOR I=1,M; J=1,NOS, SET Y(I,J)=Y(I,J)+E(I,J), WHERE 
C  E(I,J)--N(0,STDIJ**2), WHERE
C  STDIJ = C0(J) + C1(J)*Y(I,J) + C2(J)*Y(I,J)**2 + C3(J)*Y(I,J)**3. 
C  SO E(I,J)=STDIJ*AS(I,J),
C  WHERE AS(I,J)--IID--N(0,1) WAS OBTAINED ABOVE FOR THIS SUBJECT.

C  ... EXCEPT NOTE THAT IN MONTBIG5.FOR, ANY YPRED(I,J) WHICH IS
C  SIMULATED TO BE < 0 IS REPLACED BY THE FIXED VALUE, 1.D-8.
C  AND, AS OF MONT100.FOR, ANY PREDICTED VALUE THAT IS LESS THAN
C  1.D-8 IS REPLACED BY 1.D-8. OTHERWISE, E.G., 1.D-123 GETS WRITTEN
C  AS .1-122 = -121.9.


C  STORE THESE PREDICTED VALUES YPREDSUB, SO THE SAMPLE MEANS, MEDIANS,
C  MINIMUMS, MAXIMUMS, S.D.'s, AND PERCENTILES CAN BE CALCULATED LATER.

C  AS OF MONTBIG7.FOR:
C  NOTE THAT Y(I,J) IS THE OBSERVED VALUE IN THE WORKING COPY FILE
C  SUPPLIED TO THIS PROGRAM. IF IT IS .LE. -99, THE CORRESPONDING 
C  SIMULATED VALUE SHOULD BE SET = -99 (I.E., IT WILL BE A MISSING 
C  VALUE).

	DO J=1,NOS
	 DO I=1,M
          STDIJ=C0(J) + C1(J)*YPRED(I,J) + C2(J)*YPRED(I,J)**2 + 
     1          C3(J)*YPRED(I,J)**3 
 	  YPRED(I,J)=YPRED(I,J)+AS(I,J)*STDIJ
	  IF(YPRED(I,J) .LE. 1.D-8) YPRED(I,J) = 1.D-8
	  IF(Y(I,J) .LE. -99.D0) YPRED(I,J) = -99.D0
	  YPREDSUB(ISUB,I,J) = YPRED(I,J)
	 END DO
	END DO

C  NOTE: IN THE POPULATION PROGRAMS WHICH ANALYZE THE DATA GENERATED BY 
C        THIS PROGRAM, THE ABOVE 'OBSERVED' (ALREADY NOISY) OUTPUTS WILL 
C        HAVE MORE NOISE ADDED. THIS IS A SLIGHT INCONSISTENCY.

C  STORE THE COMPARTMENT AMOUNTS FOR THIS SUBJECT. THEY WERE PASSED
C  IN COMMON TO THIS ROUTINE VIA COMMON/COMAMT FROM SUBROUTINE
C  FUNC2. 

C  BUT AS OF MONT109.FOR, ANY COMPARTMENT AMOUNT WHICH IS SIMULATED TO
C  BE < 1.D-8 IS REPLACED BY 1.D-8. OTHERWISE, E.G., 1.D-123 GETS
C  WRITTEN TO THE OUTPUT FILE AS .1-122 = -121.9. THIS IS SIMILAR TO 
C  THE CODE FOR THE PREDICTED VALUES ABOVE, WHICH WAS PUT IN BACK
C  IN MONT100.FOR.


C  NDIM = -1 --> 3 ANALYTIC SOLNS. FOR THE LINEAR 3-COMP. MODEL. IN THIS
C  CASE, THE DO LOOP BELOW IS OVER 1 TO 3.

        NNN = NDIM
        IF(NDIM .EQ. -1) NNN = 3

         DO ICOMPART = 1,NNN
          DO I = 1,M
           XPP = XPRED(I,ICOMPART)
           IF(XPP .LE. 1.D-8) XPP = 1.D-8
           XPREDSUB(ISUB,I,ICOMPART) = XPP
          END DO
         END DO

C  WRITE OBSERVATIONS TO PATIENT DATA FILE.

	 IF(IPRNPAT .GE. 1) THEN

C  REPLACE WRITING OF TIMORIG(),YPRED() WITH XVERIFY (SEE LOGIC IN 
C  SUBROUTINE VERIFYVAL).

        DO I = 1,M

         XVERIFY(1) = TIMORIG(I)

         DO J = 1,NOS
          XVERIFY(1+J) = YPRED(I,J)
         END DO
         CALL VERIFYVAL(1+NOS,XVERIFY) 
     
C	   WRITE(21,245) TIMORIG(I),(YPRED(I,J),J=1,NOS)
         WRITE(21,245) (XVERIFY(IXV),IXV=1,1+NOS)

        END DO

C  NOTE THAT AS OF MONT101F.FOR, TIMORIG(.) IS WRITTEN ABOVE, RATHER
C  THAN TIM. THIS IS BECAUSE TIMORIG(.) ARE THE ORIGINAL TIMES IN
C  PATHFIL2. IF THERE ARE STEADY STATE DOSE SETS, SUBROUTINE NEWWORK1
C  ABOVE WILL HAVE ALTERED THE TIM(.) VALUES, AND THE DOSAGE REGIMEN
C  TO BE WHAT SUBROUTINE FUNC2 EXPECTS. BUT THE TIME VALUES TO BE 
C  PUT INTO THE SIMULATED SUBJECTS MUST BE THE ORIGINAL ONES.

245       FORMAT(' ',F14.7,21(',',G14.7))


C----------------- WRITE THE BOTTOM OF FILE BELOW ----------------------

C  WRITE THE NBOTLINE LINES IN READBOT. THIS IS THE BOTTOM PART OF THE
C  WORKING COPY FILE, WHICH CONTAINS THE COV. NAMES, AND THE ASSAY
C  COEFFICIENT LINE(S).

C  NOTE THAT THE LINE(S) BELOW THE LINE THAT STARTS WITH


C  'ASSAY COEFFICIENTS' MAY CONTAIN NO ASSAY COEFFICIENTS (WHICH IS
C  THE CASE IF THE TEMPLATE WORKING COPY FILE DID NOT CONTAIN THEM), OR
C  THEY MAY NOT BE THE ONES USED ABOVE IN SIMULATING THE DATA FILES.

C  EITHER WAY, REPLACE THESE LINES WITH LINES WHICH HAVE THE ASSAY C'S
C  THAT WERE USED ABOVE.



        DO I = 1,NBOTLINE
         READBOTL = READBOT(I)
         IF(READBOTL(1:18) .EQ. 'ASSAY COEFFICIENTS') GO TO 9105
         WRITE(21,303) READBOT(I)
        END DO


  303    FORMAT(A72)

 9105   CONTINUE

C  TO GET HERE MEANS THAT ONLY THE ASSAY C'S ARE LEFT TO WRITE.


        READBOTL = 'ASSAY COEFFICIENTS FOLLOW, ONE SET FOR EACH OUTPUT E
     1QUATION:'            


        WRITE(21,303) READBOTL
        
C  REPLACE WRITING OF C0(),...,C3() WITH XVERIFY (SEE LOGIC IN 
C  SUBROUTINE VERIFYVAL.

        DO IEQ = 1,NOS
         XVERIFY(1) = C0(IEQ)
         XVERIFY(2) = C1(IEQ)
         XVERIFY(3) = C2(IEQ)


         XVERIFY(4) = C3(IEQ)
         CALL VERIFYVAL(4,XVERIFY)
C        WRITE(21,9106) C0(IEQ),C1(IEQ),C2(IEQ),C3(IEQ)
         WRITE(21,9106) (XVERIFY(IXV),IXV=1,4)
 9106    FORMAT(1X,4(G14.7,2X))
        END DO

C----------------- WRITE THE BOTTOM OF FILE ABOVE ----------------------

	  CLOSE(21)


	 ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(IPRNPAT .GE. 1)  CONDITION.




 9900   CONTINUE


C  IF IPRNPAT .GE. 1, NSUB PATIENT FILES HAVE NOW BEEN CREATED.
C  IF IPRNPAT = 1 OR 3, CALL SUBROUTINE WORKTOCSV, WHICH
C  IS BASED ON THE STAND-A-LONE PROGRAM, WORKCSV, TO WRITE ALL THE
C  SUBJECT INFO INTO THE STANDARD .CSV BLOCK FORMAT, AND PUT IT INTO
C  FILE OUTCSVNAME.

        IF(IPRNPAT .EQ. 1 .OR. IPRNPAT .EQ. 3) 
     1   CALL WORKTOCSV(NSUB,PATH,PREFIX,EXT,OUTCSVNAME)

C  IF IPRNPAT = 1, DELETE THE NSUB WORKING COPY FILES CREATED IN
C  LOOP 9900 ABOVE.

        IF(IPRNPAT .EQ. 1) THEN
         DO ISUB=1,NSUB
          PATFIL=PREFIX//NUMBER(ISUB)//'.'//EXT
          TMPFILE = PATFIL
          CALL FULLNAME(PATH,TMPFILE,PATHFIL3)
C          CALL SYSTEM('DEL '//PATHFIL3)
          CALL SYSTEM(DeleteFile//PATHFIL3)
         END DO
        ENDIF




C  WRITE ALL THE OUTPUT INFO. TO FILE 23 IN "BLOCK" FORMAT.

C  AS OF MONTBIG6.FOR, ONLY WRITE THE VALUES FOR THE FIRST 10000
C  SUBJECTS (I.E., IF NSUB > 10000, ONLY THE 1ST 10000 SUBJECTS HAVE 
C  THEIR VALUES WRITTEN). SAME FOR THE OTHER BLOCKS OF INFO BELOW.
C  ... ACTUALLY, I HAVE CHANGED THE MAXIMUM VALUE OF NSUB TO BE 10000,
C  SO IN THE CODE BELOW, NWRITE WILL ALWAYS = NSUB.


	NWRITE = NSUB
	IF(NSUB .GT. 10000) NWRITE = 10000


	IF(NSUB .GT. 10000) WRITE(23,6013)
 6013   FORMAT(//' THE FOLLOWING 10000 LINES HAVE THE SIMULATED '/
     1' PARAMETER VALUES FOR THE FIRST 10000 SUBJECTS ONLY.'//
     2' SIMILARLY, ALL THE BLOCKS BELOW WILL HAVE VALUES ONLY FOR'/
     3' THE FIRST 10000 SUBJECTS.')
   
	IF(NSUB .LE. 10000) WRITE(23,7013) NSUB

 7013   FORMAT(//' THE FOLLOWING ',I7,' LINES HAVE THE SIMULATED '/
     1' PARAMETER VALUES FOR ALL THE SUBJECTS.')

	WRITE(23,7006) (PAR(J),J=1,NVAR)
 7006   FORMAT(/' SUBJ.    ',30(A12,3X))


C  REPLACE WRITING OF VALALF() WITH XVERIFY (SEE LOGIC IN 
C  SUBROUTINE VERIFYVAL.

      DO ISUB = 1,NWRITE
       DO J=1,NVAR
        XVERIFY(J) = VALALF(ISUB,J)
       END DO
       CALL VERIFYVAL(NVAR,XVERIFY)
C      WRITE(23,7007) ISUB, (VALALF(ISUB,J),J=1,NVAR)
       WRITE(23,7007) ISUB, (XVERIFY(J),J=1,NVAR)
      END DO

 7007   FORMAT(I6,1X,200(G14.7,1X))

	WRITE(23,7014) NOS,M
 7014   FORMAT(//' THE FOLLOWING ',I2,' BLOCK(S) CONTAIN THE SIMULATED A
     1SSAY'/
     2' NOISE FOR EACH OUTPUT EQUATION. EACH BLOCK HAS THE NOISE FOR'/
     3' THE ',I4,' OBSERVED VALUES FOR EACH SUBJECT ON ONE LINE.'/)

	WRITE(23,7009)
 7009   FORMAT(/'        <---- OBSERVATION TIMES ... ')

C  REPLACE WRITING OF TIMORIG() WITH XVERIFY (SEE LOGIC IN 
C  SUBROUTINE VERIFYVAL.

       DO I=1,M
        XVERIFY(I) = TIMORIG(I)
       END DO
       CALL VERIFYVAL(M,XVERIFY)
C	 WRITE(23,7008) (TIMORIG(I),I=1,M)
       WRITE(23,7008) (XVERIFY(I),I=1,M)
 7008   FORMAT(/'SUBJ ',200(G14.7,1X))


C  REPLACE WRITING OF ASUB() WITH XVERIFY (SEE LOGIC IN 
C  SUBROUTINE VERIFYVAL.

      DO IOUTEQ = 1,NOS
       WRITE(23,7017) IOUTEQ
 7017  FORMAT(/' OUTPUT EQUATION NO. ',I2/)


       DO ISUB = 1,NWRITE
        DO I=1,M
         XVERIFY(I) = ASUB(ISUB,I,IOUTEQ)
        END DO
        CALL VERIFYVAL(M,XVERIFY)
C       WRITE(23,7007) ISUB,(ASUB(ISUB,I,IOUTEQ),I=1,M)
        WRITE(23,7007) ISUB,(XVERIFY(I),I=1,M)
       END DO
      END DO


	WRITE(23,7016) NOS,M

 7016   FORMAT(//' THE FOLLOWING ',I2,' BLOCK(S) CONTAIN THE SIMULATED O
     1BSERVED'/
     2' VALUES FOR EACH OUTPUT EQUATION. EACH BLOCK HAS THE ',I4,' OBSER
     3VED VALUES'/
     4' FOR EACH SUBJECT ON ONE LINE.'/)

C  REPLACE WRITING OF TIMORIG() WITH XVERIFY (SEE LOGIC IN 
C  SUBROUTINE VERIFYVAL.

       DO I=1,M
        XVERIFY(I) = TIMORIG(I)
       END DO
       CALL VERIFYVAL(M,XVERIFY)

       WRITE(23,7009)
C	 WRITE(23,7008) (TIMORIG(I),I=1,M)
       WRITE(23,7008) (XVERIFY(I),I=1,M)


C  REPLACE WRITING OF YPREDSUB() WITH XVERIFY (SEE LOGIC IN 
C  SUBROUTINE VERIFYVAL.

      DO IOUTEQ = 1,NOS
       WRITE(23,7017) IOUTEQ
       DO ISUB = 1,NWRITE
        DO I=1,M
         XVERIFY(I) = YPREDSUB(ISUB,I,IOUTEQ)
        END DO
        CALL VERIFYVAL(M,XVERIFY)
C       WRITE(23,7007) ISUB,(YPREDSUB(ISUB,I,IOUTEQ),I=1,M)
        WRITE(23,7007) ISUB,(XVERIFY(I),I=1,M)
       END DO
      END DO


C  NDIM = -1 --> 3 ANALYTIC SOLNS. FOR THE LINEAR 3-COMP. MODEL. IN THIS
C  CASE, THE DO LOOP BELOW IS OVER 1 TO 3. AND CHANGE THE WRITE(23,7021)
C  STATEMENT ACCORDINGLY.

        NNN = NDIM
        IF(NDIM .EQ. -1) NNN = 3

	WRITE(23,7021) NNN,M
 7021   FORMAT(//' THE FOLLOWING ',I2,' BLOCK(S) CONTAIN THE SIMULATED'/
     1' AMOUNTS FOR EACH COMPARTMENT. EACH BLOCK SHOWS THE ',I4,' AMOUNT
     2S '/
     2' FOR EACH SUBJECT ON ONE LINE. '/)

C  REPLACE WRITING OF TIMORIG() WITH XVERIFY (SEE LOGIC IN 
C  SUBROUTINE VERIFYVAL.

       DO I=1,M
        XVERIFY(I) = TIMORIG(I)
       END DO
       CALL VERIFYVAL(M,XVERIFY)

       WRITE(23,7009)
C	 WRITE(23,7008) (TIMORIG(I),I=1,M)
       WRITE(23,7008) (XVERIFY(I),I=1,M)


C  REPLACE WRITING OF XPREDSUB() WITH XVERIFY (SEE LOGIC IN 
C  SUBROUTINE VERIFYVAL.


      DO IDIM = 1,NNN
       WRITE(23,7022) IDIM
 7022  FORMAT(/' COMPARTMENT NO. ',I2/)
       DO ISUB = 1,NWRITE
        DO I=1,M
         XVERIFY(I) = XPREDSUB(ISUB,I,IDIM)
        END DO
        CALL VERIFYVAL(M,XVERIFY)
C       WRITE(23,7007) ISUB,(XPREDSUB(ISUB,I,IDIM),I=1,M)
        WRITE(23,7007) ISUB,(XVERIFY(I),I=1,M)

       END DO
      END DO


	WRITE(23,7019)
 7019   FORMAT(//'******************************************************
     1**********'//
     2' SUMMARY STATISTICS FOLLOW ...'/)


C  IF ITOTSETS = NSUB, THE ITOTSETS PARAMETER SETS IN OVERALF ARE THE
C  SAME AS THE NSUB PARAMETER SETS IN VALALF. IF ITOTSETS > NSUB, THEN
C  ITOTSETS - NSUB PARAMETER SETS IN OVERALF WERE NOT USED IN VALALF.
C  IN THE FORMER CASE, SUBROUTINE STATT WILL BE CALLED JUST ONCE. IN
C  THE LATTER CASE, STATT WILL BE CALLED TWICE, ONCE WITH OVERALF AS
C  THE ARRAY OF VALUES, AND ONCE WITH VALALF AS THE ARRAY OF VALUES.
C  ALSO, WRITE THE APPROPRIATE MESSAGE TO THE OUTPUT FILE.

      IF(ITOTSETS .GT. NSUB) THEN

       WRITE(23,9802) ITOTSETS,NSUB,ITOTSETS
 9802  FORMAT(//' BECAUSE OF PARAMETER BOUNDARY RESTRICTIONS, IT TOOK'/
     1I9,' PARAMETER SETS TO OBTAIN THE ',I8,' WHICH WERE ACCEPTABLE'/
     2' FOR THE SUBJECT SIMULATIONS.'//
     3' THE SAMPLE MEANS, COV. MATRIX, AND CORR. MATRIX FOR THE '/
     4' ENTIRE ',I9,' PARAMETER SETS WERE AS FOLLOWS: ')

C  CALL SUBROUTINE STATT TO OBTAIN THE SAMPLE MEANS, SAMMEN, AND THE
C  SAMPLE COVARIANCES, SAMCOV, FOR THE PARAMETER VALUES IN OVERALF.

	CALL STATT(ITOTSETS,NVAR,OVERALF,SAMMEN,SAMCOV)

C  WRITE THESE SAMPLE STATISTICS INTO FILE 23, THE OUTPUT FILE.

C  REPLACE WRITING OF SAMMEN() WITH XVERIFY (SEE LOGIC IN 
C  SUBROUTINE VERIFYVAL).

        DO I = 1,NVAR
         XVERIFY(I) = SAMMEN(I)
        END DO
        CALL VERIFYVAL(NVAR,XVERIFY)
C       WRITE(23,9804) (SAMMEN(I),I=1,NVAR)     
        WRITE(23,9804) (XVERIFY(I),I=1,NVAR)
 9804   FORMAT(//' SAMPLE MEANS OF ALL PARAMETER DATA ARE:'/
     1  30(F12.4,1X))

        WRITE(23,9806)
 9806   FORMAT(//' SAMPLE COV. MATRIX OF ALL PARAMETER DATA IS:')


C  REPLACE WRITING OF SAMCOV() WITH XVERIFY (SEE LOGIC IN 
C  SUBROUTINE VERIFYVAL).

        DO I=1,NVAR
         DO J = 1,I
          XVERIFY(J) = SAMCOV(I,J)
         END DO
         CALL VERIFYVAL(I,XVERIFY)
C        WRITE(23,9012) I,(SAMCOV(I,J),J=1,I)
         WRITE(23,9012) I,(XVERIFY(J),J=1,I) 
        END DO	
 9012   FORMAT(' ROW ',I2,1X,200(G14.7,1X))

C  CALCULATE AND WRITE THE SAMPLE CORRELATION MATRIX.

        DO I = 1,NVAR
         DO J = 1,I
          SAMCOR(I,J)=SAMCOV(I,J)/DSQRT(SAMCOV(I,I)*SAMCOV(J,J))
         END DO
        END DO

        WRITE(23,9807)
 9807   FORMAT(//' SAMPLE CORR. MATRIX OF ALL PARAMETER DATA IS:')

        DO I=1,NVAR
         DO J = 1,I
          XVERIFY(J) = SAMCOR(I,J)
         END DO
         CALL VERIFYVAL(I,XVERIFY)
C        WRITE(23,9012) I,(SAMCOR(I,J),J=1,I)
         WRITE(23,9012) I,(XVERIFY(J),J=1,I) 

        END DO	


       WRITE(23,9803) NSUB
 9803  FORMAT(//' CORRESPONDING VALUES FOR THE ',I8,' PARAMETER SETS'/
     1' WHICH WERE ACTUALLY USED TO SIMULATE SUBJECTS WERE ...')


      ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(ITOTSETS .GT. NSUB)  CONDITION.
  
  
      IF(ITOTSETS .EQ. NSUB) WRITE(23,9808) NSUB
 9808 FORMAT(//' ALL SIMULATED PARAMETER SETS WERE USED TO SIMULATE'/
     1' THE ',I8,' SUBJECTS; I.E., NONE WAS THROWN OUT BECAUSE OF '/
     2' PARAMETER BOUNDARY RESTRICTIONS. SO THE FOLLOWING SAMPLE'/
     3' MEANS, COV. MATRIX AND CORR. MATRIX ARE FOR ALL PARAMETER'/
     4' SETS.')

C  CALL SUBROUTINE STATT TO OBTAIN THE SAMPLE MEANS, SAMMEN, AND THE
C  SAMPLE COVARIANCES, SAMCOV, FOR THE GENERATED PARAMETER VALUES.

	CALL STATT(NSUB,NVAR,VALALF,SAMMEN,SAMCOV)

C  WRITE THESE SAMPLE STATISTICS INTO FILE 23, THE OUTPUT FILE.

C  REPLACE WRITING OF SAMMEN() WITH XVERIFY (SEE LOGIC IN 
C  SUBROUTINE VERIFYVAL).

        DO I = 1,NVAR
         XVERIFY(I) = SAMMEN(I)
        END DO
        CALL VERIFYVAL(NVAR,XVERIFY)
C       WRITE(23,9876) (SAMMEN(I),I=1,NVAR)
        WRITE(23,9876) (XVERIFY(I),I=1,NVAR)

 9876   FORMAT(/' SAMPLE MEANS OF PARAMETERS USED TO SIMULATE SUBJECTS:
     1 '/
     2  30(F12.4,1X))

        WRITE(23,9878)
 9878   FORMAT(//' SAMPLE COV. MATRIX OF PARAMETERS USED TO SIMULATE SUB
     1JECTS: '/)

C  REPLACE WRITING OF SAMCOV() WITH XVERIFY (SEE LOGIC IN 
C  SUBROUTINE VERIFYVAL).

        DO I=1,NVAR
         DO J = 1,I
          XVERIFY(J) = SAMCOV(I,J)
         END DO
         CALL VERIFYVAL(I,XVERIFY)
C        WRITE(23,9012) I,(SAMCOV(I,J),J=1,I)
         WRITE(23,9012) I,(XVERIFY(J),J=1,I) 
        END DO	

C  CALCULATE AND WRITE THE SAMPLE CORRELATION MATRIX.

	 DO I = 1,NVAR
	  DO J = 1,I
	   SAMCOR(I,J)=SAMCOV(I,J)/DSQRT(SAMCOV(I,I)*SAMCOV(J,J))
	  END DO
	 END DO

        WRITE(23,9877)
 9877   FORMAT(//' SAMPLE CORR. MATRIX OF PARAMETERS USED TO SIMULATE SU
     1BJECTS: '/)

        DO I=1,NVAR
         DO J = 1,I
          XVERIFY(J) = SAMCOR(I,J)
         END DO
         CALL VERIFYVAL(I,XVERIFY)
C        WRITE(23,9012) I,(SAMCOR(I,J),J=1,I)
         WRITE(23,9012) I,(XVERIFY(J),J=1,I) 
        END DO	


C  CALL SUBROUTINE STAT2 TO OBTAIN THE SUMMARY STATISTICS FOR THE
C  OUTPUT CONCENTRATIONS, STORED IN YPREDSUB. THEN WRITE THESE
C  STATISTICS TO THE OUTPUT FILE.

	CALL STAT2(NSUB,M,NOS,YPREDSUB,YMEAN,YMIN,YMAX,YSD,Y025,
     1   Y25,Y50,Y75,Y975)

	WRITE(23,9971) NOS,M,NSUB
 9971   FORMAT(//' THE STATISTICS FOR EACH OF THE ',I2,' OUTPUT '/
     1' EQUATION(S) AND ',I4,' OBSERVATION TIMES FOLLOW: '//
     2' FOR EACH OUTPUT EQUATION AND OBSERVATION, THE 9 VALUES '/
     3' REPRESENT, IN ORDER, THE MEAN, MINIMUM, MAXIMUM, STD. DEV.,'/
     4' 2.5%-TILE, 25%-TILE, 50%-TILE (MEDIAN), 75%-TILE, AND 97.5%-TILE
     5'/
     6' ... OVER ALL ',I7,' SUBJECTS.'/)



      DO IN = 1,NOS

	 WRITE(23,9972) IN
 9972    FORMAT(/' OUTPUT EQUATION ',I1,':')
	 
       DO IM = 1,M
	
        WRITE(23,9973) IM
 9973   FORMAT(/' FOR OBSERVATION ',I4,':')


C  REPLACE WRITING OF YMEAN(),...,Y975() WITH XVERIFY (SEE LOGIC IN 
C  SUBROUTINE VERIFYVAL.

        XVERIFY(1) = YMEAN(IM,IN)
        XVERIFY(2) = YMIN(IM,IN)
        XVERIFY(3) = YMAX(IM,IN)
        XVERIFY(4) = YSD(IM,IN)
        XVERIFY(5) = Y025(IM,IN)
        XVERIFY(6) = Y25(IM,IN)
        XVERIFY(7) = Y50(IM,IN)
        XVERIFY(8) = Y75(IM,IN)
        XVERIFY(9) = Y975(IM,IN)        
        CALL VERIFYVAL(9,XVERIFY)

C       WRITE(23,9974) YMEAN(IM,IN),YMIN(IM,IN),YMAX(IM,IN),YSD(IM,IN),
C    1   Y025(IM,IN),Y25(IM,IN),Y50(IM,IN),Y75(IM,IN),Y975(IM,IN)
        WRITE(23,9974) (XVERIFY(IXV),IXV=1,9)
 9974   FORMAT(9(1X,F10.3))

	 END DO


	END DO


C  THE ABOVE END DO's ARE FOR THE  DO IM = 1,M  LOOP, AND THE
C  DO IN = 1,NOS  LOOP, RESPECTIVELY.


	CLOSE(23)

	RETURN


	END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
	SUBROUTINE INOUT(ISUB,PATHFIL2,PATHFIL3,IPRNPAT,TIMORIG)

	IMPLICIT REAL*8(A-H,O-Z)

	PARAMETER(MAXNUMEQ=7)

	CHARACTER SEX*1,READLINE*300,PATHFIL2*93,PATHFIL3*93,
     1   READLIN2*72,READBOT(99)*72,ERRFIL*20,CHARSUB*5

      COMMON/ERROR/ERRFIL
C  COMMON/ERROR/ IS SUPPLIED TO ALL THE ROUTINES WHICH COULD WRITE TO
C  ERRFIL.

      DIMENSION TIM(594),SIG(5000),RS(5000,34),YO(594,MAXNUMEQ),
     1 BS(5000,7),TIMORIG(594)

C  NOTE: AS OF MONT101F.FOR, THE FOLLOWING COMMONS, THAT ARE SUPPLIED TO
C        SUBROUTINE FUNC2, WILL BE OVERWRITTEN WHEN SUBROUTINE 
C        STOREOBSER IS CALLED AFTER SUBROUTINE NEWWORK1 CHANGES
C        PATHFIL2 TO A WORKING COPY FILE IN THE FORMAT THAT FUNC2 
C        EXPECTS (I.E., IF THERE ARE STEADY STATE DOSE SETS IN 
C        PATHFIL2, THE INFO MUST BE STORED IN THE WAY FUNC2 EXPECTS).

	COMMON/OBSER/ TIM,SIG,RS,YO,BS
	COMMON/CNST/ N,ND,NI,NUP,NUIC,NP
	COMMON/CNST2/ NPL,NUMEQT,NDRUG,NADD
	COMMON/SUM2/ M,NPNL
	COMMON/DESCR/AGE,HEIGHT,ISEX,IETHFLG
	COMMON/BOTPART/NBOTLINE,READBOT

C  COMMON/BOTPART IS PROVIDED TO SIMBIG TO WRITE THE BOTTOM PART OF
C  THE WORKING COPY FILE TO EACH SIMULATED PATIENT DATA FILE.


C  AS OF MONT101F.FOR, THE IJUMP PARAMETER IS REMOVED. NOW, EVERY TIME

C  INOUT IS CALLED, PATHFIL2 MUST BE READ TO ESTABLISH THE DOSAGE
C  REGIMEN ANEW. THE REASON IS THAT IF THERE ARE STEADY STATE DOSES
C  IN PATHFIL2, SUBROUTINE NEWWORK1 (CALLED BY SIMBIG) CHANGES
C  THE DOSE BLOCK AND THE OBSERVATION TIMES TO BE WHAT SUBROUTINE
C  FUNC2 EXPECTS ... BUT THE SIMULATED PATIENTS MUST HAVE THE 
C  ORIGINAL DOSAGE BLOCK AND SIMULATED TIMES THAT ARE IN PATHFIL2.

      OPEN(21,FILE=PATHFIL2,STATUS='OLD')


C  AGE, SEX, HEIGHT, AND ETHNICITY FLAG ARE ON LINES 8-11.

	DO I=1,7
	 READ(21,*)
	END DO
	 
	READ(21,*) AGE
	READ(21,2) SEX
    2   FORMAT(A1)
	ISEX=1
	IF(SEX .EQ. 'F') ISEX=2
	READ(21,*) HEIGHT
	READ(21,*) IETHFLG


C  READ THE NO. OF DRUGS FROM THE LINE WITH 'NO. OF DRUGS' AS ENTRIES
C  12:23. THEN READ NO. OF ADDITIONAL COVARIATES, AND THE NO. OF DOSE 
C  EVENTS, ETC.

    1   FORMAT(A300)
   10	READ(21,1) READLINE
	IF(READLINE(12:23) .NE. 'NO. OF DRUGS') GO TO 10
	BACKSPACE(21)

    3   FORMAT(T2,I5)
        READ(21,3) NDRUG

	IF(NDRUG .GT. 7) THEN

	 WRITE(*,124)
  124    FORMAT(' YOUR PATIENT DATA FILES CANNOT HAVE MORE THAN 7'/
     1' DRUGS. THE PROGRAM IS NOW STOPPING. '/)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,124)          
        CLOSE(42)

       CALL PAUSE
	 STOP

	ENDIF

        READ(21,3) NADD


C  NOTE THAT THE NO. OF "RATES" INCLUDES 2 FOR EACH DRUG (THE IV AND
C  THE PO COLUMNS) + NADD (1 COLUMN FOR EACH ADDITIONAL COVARIATE 
C  BEYOND THE FIRST 4 ABOVE, AGE, SEX, HEIGHT, AND ETHNICITY FLAG).

	NI = 2*NDRUG + NADD

	IF(NI .GT. 34) THEN

  	 WRITE(*,123)
  123    FORMAT(/' YOUR PATIENT DATA FILES HAVE TOO MANY COLUMNS IN '/
     1' THE DOSAGE REGIMEN BLOCK. THE NO. OF ADDITIONAL COVARIATES '/
     2' PLUS TWICE THE NO. OF DRUGS CANNOT EXCEED 34. THE PROGRAM IS'/
     3' NOW STOPPING. '/)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,123)          
        CLOSE(42)

	 CALL PAUSE
	 STOP

	ENDIF

        READ(21,3) ND


	IF(ND .GT. 5000) THEN

	 WRITE(*,125)
  125  FORMAT(' YOUR PATIENT DATA FILES CANNOT HAVE MORE THAN 5000'/
     1' DOSE EVENTS. THE PROGRAM IS NOW STOPPING. '/)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,125) 
        CLOSE(42)

       CALL PAUSE
	 STOP

	ENDIF

	READ(21,*)
	READ(21,*)

        IF(ND.EQ.0) GO TO 40

	DO I = 1,ND
         READ(21,*) SIG(I),(RS(I,J),J=1,NI)
	END DO	 

C  ASSIGN THE VALUES IN EACH DRUG'S PO COLUMN TO THE CORRESPONDING
C  COLUMN IN ARRAY BS.


        DO I=1,ND
         DO J=1,NDRUG
          BS(I,J) = RS(I,2*J)
	 END DO
	END DO

C  READ THE NO. OF OUTPUT EQUATIONS FROM THE LINE WITH 'NO. OF TOTAL'
C  AS ENTRIES 12:23. THEN READ NO. OF OBSERVED VALUE TIMES, ETC.

   40	READ(21,1) READLINE
	IF(READLINE(12:23) .NE. 'NO. OF TOTAL') GO TO 40
	BACKSPACE(21)

        READ(21,3) NUMEQT
        READ(21,3) M

	IF(M .GT. 594) THEN
	 WRITE(*,*) 'NO. OF OBSERVATIONS MUST BE .LE. 594'
	 WRITE(*,*) 'ONLY THE 1ST 594 OBSERVATION TIMES ARE USED.'
	 M=594
	ENDIF
C??? 150 CHANGED TO 594 IN MONTBG21.FOR.

	IF(NUMEQT .GT. MAXNUMEQ) THEN

  	 WRITE(*,127) NUMEQT,MAXNUMEQ 
  127    FORMAT(/' YOUR PATIENT DATA FILE HAS ',I3,' OUTPUT EQ.'/
     1' COLUMNS, WHICH IS MORE THAN ',I3,', THE MAX. ALLOWABLE NO. '/
     2' THE PROGRAM IS NOW STOPPING. '/)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,127) NUMEQT,MAXNUMEQ
        CLOSE(42)

       CALL PAUSE
	 STOP

	ENDIF


C  NOTE THAT ONLY THE OBSERVATION TIMES WILL BE READ IN EACH OF THE
C  M LINES BELOW (I.E., THE OBSERVED VALUES WILL BE IGNORED SINCE
C  THIS SUBJECT FILE IS BEING USED ONLY TO GET THE DOSAGE REGIMEN,
C  THE COVARIATE INFO (IF ANY), AND THE OBSERVED VALUE TIMES.

C  NO! AS OF MONTBIG7.FOR, THE OBSERVED VALUES WILL BE READ ALSO
C  SINCE ANY THAT ARE .LE. -99 ARE MISSING VALUES AND WILL BE SIMULATED
C  AS MISSING VALUES (I.E., THEIR VALUE WILL BE -99).

C  AS OF MONT101F.FOR, MUST ALSO STORE THE OBSERVATION TIMES FROM
C  PATHFIL2, SINCE NEW SUBROUTINE NEWWORK1 CAN CHANGE THESE VALUES
C  IF THERE ARE STEADY STATE DOSE SETS. THESE ORIGINAL TIMES MUST
C  BE THE ONES THAT ARE WRITTEN INTO THE SIMULATED PATIENT FILES.
C  STORE THESE TIMES INTO TIMORIG.


        DO I=1,M
         READ(21,*) TIM(I),(YO(I,J),J=1,NUMEQT)
         TIMORIG(I) = TIM(I)
        END DO

C  READ THE BOTTOM PART OF THE FILE, WHICH WILL BE PROVIDED TO
C  SUBROUTINE SIMBIG VIA COMMON/BOTPART (SO IT CAN BE PUT INTO EACH
C  SIMULATED PATIENT DATA FILE).
C  NOTE THAT IEND .LT. 0 --> END OF FILE REACHED.	

	NBOTLINE = 0

 1010	READ(21,22,IOSTAT=IEND) READLIN2
	IF(IEND .LT. 0) GO TO 1025
	NBOTLINE = NBOTLINE + 1
	READBOT(NBOTLINE) = READLIN2


	GO TO 1010
 1025	CLOSE(21)


C  WRITE ALL INFO TO PATIENT DATA FILE, EXCEPT THE SIMULATED OBSERVED
C  VALUES (WHICH WILL BE DONE IN SIMBIG/MAIN).

C  PATIENT DATA FILES WILL BE CREATED IF IPRNPAT = 1.

 	IF(IPRNPAT .GE. 1) THEN

       OPEN(21,FILE=PATHFIL3)

       CALL GETCHAR(ISUB,CHARSUB)

   22 FORMAT(A72)
	READLIN2 = '  LAST AND FIRST NAMES ARE: YOWZA '//CHARSUB

	WRITE(21,22) READLIN2
	READLIN2 = ' CHART NUMBER IS: 1234'
	WRITE(21,22) READLIN2
	WRITE(21,*)
	READLIN2= ' WARD NO, PATIENT AGE (YEARS), SEX, HEIGHT (INCHES),'
	WRITE(21,22) READLIN2
	READLIN2 = ' ETHNICITY FLAG, AND ETHNICITY DESCRIPTION (IF ANY) 
     1FOLLOW ON'
	WRITE(21,22) READLIN2
	READLIN2 = ' THE NEXT 6 LINES:'
	WRITE(21,22) READLIN2

	READLIN2 = '56'
	WRITE(21,22) READLIN2
	READLIN2 = ' 74.000000'

	WRITE(21,22) READLIN2
	READLIN2 = 'M'
	WRITE(21,22) READLIN2
	READLIN2 = ' 67.89'
	WRITE(21,22) READLIN2
	READLIN2 = '1'
	WRITE(21,22) READLIN2               
	WRITE(21,*)                
	WRITE(21,*)                                                        

	READLIN2 = ' DATE OF FIRST THERAPY IS    7  12  98'
	WRITE(21,22) READLIN2
	READLIN2 = 'CCR ML/MIN/    0.00 150.00'
	WRITE(21,22) READLIN2

	READLIN2 = 'HOURS    MG     MG/HR    MCG/ML KG       MG/DL    60
     1.00'
	WRITE(21,22) READLIN2
        WRITE(21,*)

	WRITE(21,1011) NDRUG
 1011   FORMAT(5X,I1,' ... NO. OF DRUGS')
	WRITE(21,1012) NADD
 1012   FORMAT(4X,I2,' ... NO. OF ADDITIONAL COVARIATES')
	WRITE(21,1013) ND
 1013   FORMAT(1X,I5,' ... NO. OF DOSE EVENTS')

	WRITE(21,1014)
 1014   FORMAT(/'    TIME, IV/PO FOR EACH DRUG; ADDITIONAL COVARIATES IF
     1 ANY')  

	DO I = 1,ND
         WRITE(21,*) SIG(I),(RS(I,J),J=1,NI)
	END DO	 

	WRITE(21,*)
	WRITE(21,1016) NUMEQT
 1016   FORMAT(5X,I1,' ... NO. OF TOTAL OUTPUT EQUATIONS')
	WRITE(21,1017) M
 1017   FORMAT(2X,I4,' ... NO. OF OBSERVED VALUE TIMES')


	ENDIF


C  THE ABOVE ENDIF IS FOR THE  IF(IPRNPAT .GE. 1)  CONDITION.

	RETURN


	END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

C
C  THIS IS SUBROUTINE IDCALCY FROM idm2x10.f, EXCEPT WITH THE ADDED CODE
C  RELATED TO APPLYING NOISE TO THE DOSE TIMES, DOSES, AND OBSERVATION 
C  TIMES (VIA THE PARAMETER, IDUM), AND THE CODE RELATED TO XPRED, 
C  SUPPLIED VIA COMMON/COMANT. THE SAME COMMENT APPLIES TO ROUTINES
C  FUNC2 AND EVAL2.

C  NOTE THAT SUBROUTINES USERANAL AND JACOB (FROM idm1x4.f) ARE 
C  UNCHANGED FROM MONTBG15.FOR. ALSO, VODTOT.FOR, LOCATED IN 
C  bigmlt5.f, AND SUBROUTINE SHIFT (IN SHIFT7.F) ARE INCLUDED.

	SUBROUTINE IDCALCY(NPP,NDIM,ESTML,YPRED,IDUM)

C  INPUT ARE:

C  NPP = NO. OF PARAMETERS (RANDOM AND FIXED) IN THE PARAMATER 
C       VECTOR, ESTML.
C  NDIM = NO. OF COMPARTMENTS IN THE MODEL.
C  ESTML = VECTOR OF PARAMETER ESTIMATES (RANDOM AND FIXED).

C  INFORMATION FROM A SUBJECT DATA FILE WHOSE INFO IS PASSED TO THE 
C  ROUTINES IN THIS MODULE VIA COMMONS /OBSER/, /CNST/, /CNST2/, AND 
C  /SUM2/.

C  OUTPUT IS:

C  YPRED(I,J), I=1,M; J=1,NOS = THE PREDICTED VALUE FOR THE ITH 
C	OBSERVATION OF THE JTH OUTPUT EQUATION, GIVEN THE INPUT VECTOR
C	ESTML. M AND NOS ARE INPUT TO THIS MODULE VIA COMMONS SUM2 AND
C	CNST2, RESPECTIVELY.

c-----------------------------------------------------------------------

        IMPLICIT REAL*8(A-H,O-Z)

        PARAMETER(MAXNUMEQ=7)

        DIMENSION ESTML(32),YPRED(594,MAXNUMEQ),P(32)
        COMMON/CNST/ N,ND,NI,NUP,NUIC,NP
        COMMON/PARAMD/ P

C*****INITIALIZE PROGRAM*****

	CALL SYMBOL


C  THE ABOVE CALL OBTAINS INFO FROM COMMONS.


C  NOTE THAT THIS PROGRAM NOW GETS N = NDIM AND NPP = NVAR+NOFIX
C  AS CALLING ARGUMENTS.

	N = NDIM
	NP = NPP

C  CALCULATE THE OUTPUT CONCENTRATION VECTOR, Y, FOR THE PARAMETER
C  VECTOR, ESTML.

C  PUT MODEL PARAMETER VALUES INTO P.

        DO I=1,NP
	  P(I) = ESTML(I)
	END DO


C  CALL SUBROUTINE EVAL2 TO GET Y, EVALUATED
C  AT ESTML(I) AS DEFINED ABOVE.

	CALL EVAL2(YPRED,IDUM)

        RETURN
	END

C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
      SUBROUTINE FUNC2(M,F,IDUM)

C  THIS SUBROUTINE, CALLED BY EVAL2, FINDS F(I) = OUTPUT CONC. AT
C  TIME I, I=1,M, GIVEN PARAMETER VALUES IN P.

      IMPLICIT REAL*8(A-H,O-Z)

	PARAMETER(MAXNUMEQ=7)

      COMMON/BOLUSCOMP/NBCOMP
      COMMON/OBSER/ TIM,SIG,RS,YO,BS
      COMMON/CNST/ N,ND,NI,NUP,NUIC,NP
      COMMON/INPUT/ R,B
      COMMON/PARAMD/ P
      COMMON/CNST2/ NPL,NOS,NDRUG,NADD
      COMMON/STATE/ X
      COMMON/COMAMT/XPRED
      COMMON/NOISE/ C0DT,C1DT,C2DT,C3DT,C0DA,C1DA,C2DA,C3DA,
     1   C0OT,C1OT,C2OT,C3OT

      CHARACTER ERRFIL*20

      COMMON/ERROR/ERRFIL
C  COMMON/ERROR/ IS SUPPLIED TO ALL THE ROUTINES WHICH COULD WRITE TO
C  ERRFIL.

      DIMENSION X(20),P(32),TIM(594),SIG(5000),R(37),RS(5000,34),
     1 YT(MAXNUMEQ),YO(594,MAXNUMEQ),F(594,MAXNUMEQ),BS(5000,7),
     2Y(594,MAXNUMEQ),B(20),NBCOMP(7),TLAG(7),FA(7),XPRED(594,20),
     3AS1(594),SIGN(5000),TIMN(594),RSN(5000,34),BSN(5000,7),
     4XSTORE(100,20),XXPRED(20),XVERIFY(900)

C  NOTE THAT AS OF MONT109.FOR, THE DIMENSIONS OF 6 IN XSTORE AND XXPRED
C  HAVE BEEN CHANGED TO 20, WHICH IS WHAT THEY SHOULD HAVE BEEN ALL
C  ALONG (I.E., THE SAME AS FOR XPRED).

C  THE NOMINAL VALUES IN COMMON/OBSER, TIM,SIG,RS,BS, MUST HAVE NOISE
C  APPLIED TO THEM AT THIS POINT, ACCORDING TO THE NOISE C'S THE USER
C  SPECIFIED IN MAIN, NAMELY:
C  C0DT,C1DT,C2DT,C3DT <-- DOSE TIMES
C  C0DA,C1DA,C2DA,C3DA <-- DOSE AMOUNTS
C  C0OT,C1OT,C2OT,C3OT <-- OBSERVATION TIMES.


C  FIRST OBTAIN THE NOISY DOSE TIMES AND DOSE AMOUNTS.

	DO I = 1,ND

C  FOR EACH I BELOW, WILL CALL NOSGEN TO GET A NORMAL VECTOR OF 
C  LENGTH 1, WITH MEAN = 0 VECTOR, AND COV. MATRIX = 1, I.E, A N(0,1)
C  DEVIATE FOR THE DOSE TIME.

C  AS OF MONT101F.FOR, WHEN STEADY STATE DOSES ARE ALLOWED, THE 
C  FIRST DOSE WILL ALWAYS BE ASSUMED TO BE GIVEN AT TIME 0 (PREVIOUSLY
C  IT HAD NOISE ADDED). THIS IS CONSISTENT WITH SUBSEQUENT TIME RESETS,
C  AND STEADY STATE DOSE SETS, WHERE THE FIRST DOSE IS ALWAYS ASSUMED
C  TO BE GIVEN AT THE DESIRED TIME. SO, THERE WILL NO LONGER BE ANY
C  DISTINCTION BETWEEN I = 1 AND I > 1.

C  I.E., 


C  a. CHECK TO SEE IF SIG(I) .LE. 0. IF SO, THIS TIME IS THE BEGINNING
C     DOSE TIME, A TIME RESET, OR THE BEGINNING OF A STEADY STATE DOSE
C     SET, AND THEREFORE WILL NOT HAVE NOISE APPLIED TO IT (SO IT CAN BE
C     IDENTIFIED IN THE CODE AS THE BEGINNING TIME, A TIME RESET, OR THE
C     BEGINNING OF A STEADY STATE DOSE SET).

C  b. IF SIG(I) > 0:
   
C   - SET DUR = NOMINAL DURATION BETWEEN THE PREVIOUS DOSE TIME AND
C     THIS DOSE TIME.
C   - SET SI = STD. DEV. OF DUR (I.E., A CUBIC FNT. OF DUR, BASED ON
C     THE INPUT C'S).
C   - ESTABLISH DURNOISY AS THE NOISY DURATION BETWEEN THE PREVIOUS 
C     (NOISY) DOSE TIME AND THIS (NOISY) DOSE TIME. IT IS NORMALLY 
C     DISTRIBUTED WITH MEAN = DUR AND STD. DEV. = SI ... BUT WITH THE 
C     RESTRICTION THAT IT MUST BE .GE. .5*DUR AND .LE. 2*DUR.

C  NOTE THAT WITH THIS LOGIC, THE "NOISY" DOSE TIMES CANNOT OVERLAP 
C  (I.E., "NOISY" DOSE TIME I CANNOT OCCUR BEFORE "NOISY" DOSE 
C  TIME I-1).

C  IF SIG(I) > 0, APPLY NOISE. OTHERWISE, DON'T (SEE COMMENT ABOVE).

        IF(SIG(I) .LE. 0.D0) SIGN(I) = SIG(I)

         IF(SIG(I) .GT. 0) THEN
          DUR = SIG(I) - SIG(I-1)
          CALL NOSGEN(1,1.D0,IDUM,AS1)
          SI= C0DT + C1DT*DUR + C2DT*DUR**2.D0 + C3DT*DUR**3.D0
          DURNOISY = DUR + SI*AS1(1)
          IF(DURNOISY .LT. .5D0*DUR) DURNOISY = .5D0*DUR
          IF(DURNOISY .GT. 2.D0*DUR) DURNOISY = 2.D0*DUR
          SIGN(I) = SIGN(I-1) + DURNOISY
         ENDIF


C  FOR THE ITH DOSE TIME, CALL NOSGEN TO GET A NORMAL VECTOR OF 
C  LENGTH 2*NDRUG, WITH MEAN = 0 VECTOR, AND COV. MATRIX = THE
C  IDENTITY MATRIX. THESE VALUES WILL BE USED FOR THE 2*NDRUG IV
C  AND BOLUS VALUES.

	 CALL NOSGEN(2*NDRUG,1.D0,IDUM,AS1)

	  DO J = 1,2*NDRUG

	   SI = C0DA + C1DA*RS(I,J) + C2DA*RS(I,J)**2.D0 + 
     1        C3DA*RS(I,J)**3.D0

C  APPLY THE ABOVE N(0,1) DEVIATES TO GET NOISY DOSE VALUES ... UNLESS
C  THE NOMINAL VALUE = 0 (I.E., IT IS ASSUMED THAT A DOES WITH A NOMINAL
C  VALUE OF 0 HAS 0 NOISE ASSOCIATED WITH IT - I.E., IT WILL ALWAYS BE 
C  0).
	   RSN(I,J) = RS(I,J)
	   IF(RS(I,J) .GT. 0.D0) RSN(I,J) = RS(I,J) + SI*AS1(J)	 

       IF(RSN(I,J) .LT. 0.D0) THEN

C  REPLACE WRITING OF RSN() WITH XVERIFY (SEE LOGIC IN 
C  SUBROUTINE VERIFYVAL.
       
        XVERIFY(1) = RSN(I,J)
        CALL VERIFYVAL(1,XVERIFY)
C       WRITE(*,126) J,I,RSN(I,J) 
        WRITE(*,126) J,I,XVERIFY(1)
         
  126   FORMAT(/' THE NOISY VALUE OF DOSE NO. ',I5,' FOR DOSE'/
     1' TIME ',I5,' IS ',F12.4,' WHICH IS A NEGATIVE NUMBER.'//
     2' PLEASE RERUN THE PROGRAM AND SELECT SMALLER NOISE COEFFICIENTS'/
     3' FOR THE DOSAGE AMOUNTS.')

C       WRITE(23,126) J,I,RSN(I,J)
        WRITE(23,126) J,I,XVERIFY(1)

        OPEN(42,FILE=ERRFIL)
C       WRITE(42,126) J,I,RSN(I,J)
        WRITE(42,126) J,I,XVERIFY(1)
        CLOSE(42)

        CALL PAUSE
	  STOP

       ENDIF

	  END DO
C  THE ABOVE END DO IS FOR THE  DO J = 1,2*NDRUG  LOOP.


C  NOTE THAT ALL VALUES IN RS PAST INDEX 2*NDRUG ARE COVARIATE VALUES
C  AND ARE THEREFORE NOT NOISY --> ASSIGN THESE VALUES, UNCHANGED, TO 
C  RN.

	 DO J = 2*NDRUG+1,NI
	  RSN(I,J) = RS(I,J)
	 END DO


	END DO

C  THE ABOVE END DO IS FOR THE  DO I = 1,ND  LOOP.



C  NOW FIND THE NOISY OBSERVATION TIMES.

	DO I = 1,M


C  FOR EACH I BELOW, WILL CALL NOSGEN TO GET A NORMAL VECTOR OF 
C  LENGTH 1, WITH MEAN = 0 VECTOR, AND COV. MATRIX = 1, I.E, A N(0,1)
C  DEVIATE FOR THE OBSERVATION TIME.


C  FOR I = 1, THE OBS. TIME IS NORMALLY DISTRIBUTED WITH MEAN =

C  THE NOMINAL OBS. TIME AND STD. DEV. = SI BELOW (I.E., A CUBIC FNT.
C  OF THE NOMINAL TIME, BASED ON THE INPUT C'S).

	 IF(I .EQ. 1) THEN
	  CALL NOSGEN(1,1.D0,IDUM,AS1)
	  SI = C0OT + C1OT*TIM(I) + C2OT*TIM(I)**2.D0 + C3OT*TIM(I)**3.D0
	  TIMN(I) = TIM(I) + SI*AS1(1)
	 ENDIF


C  FOR I > 1, THE NOISY OBS. TIME IS DETERMINED AS FOLLOWS:

C  a. CHECK TO SEE IF TIM(I) = 0. IF SO, THIS TIME IS A TIME RESET,
C     AND THEREFORE WILL NOT HAVE NOISE APPLIED TO IT (SO IT CAN BE
C     IDENTIFIED IN THE CODE BELOW AS A TIME RESET).

C  b. IF TIM(I) > 0:

C  -  SET DUR = NOMINAL DURATION BETWEEN THE PREVIOUS OBS. TIME AND

C     THIS OBS. TIME.
C  -  SET SI = STD. DEV. OF DUR (I.E., A CUBIC FNT. OF DUR, BASED ON
C     THE INPUT C'S).
C  -  ESTABLISH DURNOISY AS THE NOISY DURATION BETWEEN THE PREVIOUS 
C     (NOISY) OBS. TIME AND THIS (NOISY) OBS. TIME. IT IS NORMALLY 
C     DISTRIBUTED WITH MEAN = DUR AND STD. DEV. = SI ... BUT WITH THE 
C     RESTRICTION THAT IT MUST BE .GE. .5*DUR AND .LE. 2*DUR.

C  NOTE THAT WITH THIS LOGIC, THE "NOISY" OBS. TIMES CANNOT OVERLAP 
C  (I.E., "NOISY" OBS. TIME I CANNOT OCCUR BEFORE "NOISY" OBS.
C  TIME I-1).


        IF(I .GT. 1) THEN



         CALL THESAME(TIM(I),0.D0,ISAME)

         IF(ISAME .EQ. 1) TIMN(I) = 0.D0

         IF(ISAME .EQ. 0) THEN
          DUR = TIM(I) - TIM(I-1)
          CALL NOSGEN(1,1.D0,IDUM,AS1)
          SI= C0OT + C1OT*DUR + C2OT*DUR**2.D0 + C3OT*DUR**3.D0
          DURNOISY = DUR + SI*AS1(1)
          IF(DURNOISY .LT. .5D0*DUR) DURNOISY = .5D0*DUR
          IF(DURNOISY .GT. 2.D0*DUR) DURNOISY = 2.D0*DUR
          TIMN(I) = TIMN(I-1) + DURNOISY
         ENDIF

        ENDIF


	END DO


C  THE ABOVE END DO IS FOR THE  DO I = 1,M  LOOP.


C*****ODE CONSTANTS AND INITIALIZATION*****

      KNS=1
      KNT=1

C  NOTE THAT KNT IS THE RUNNING INDEX OF THE NEXT OBSERVATION TIME,
C  AND       KNS IS THE RUNNING INDEX OF THE NEXT DOSAGE TIME.

        T=0.0D0

C  INITIALIZE ISKIPBOL = 0. SEE CODE BELOW. IT IS ONLY NEEDED FOR A
C  STEADY STATE DOSE SET WHICH HAS BOLUS DOSES.

      ISKIPBOL = 0


      DO I = 1,NDRUG
       R(2*I-1) = 0.D0

      END DO

c  AS OF MONT101F.FOR, instead of R(1) = 0, the code has been changed to
c  set R(2*I-1) = 0, for I = 1,NDRUG. I.E., All IV rates for all NDRUG
c  drugs are initialized to be 0 ... in case the 1st obs. time is 0,
c  which means that OUTPUT is called before the R(I) are set below.

        

C  CALL SUBROUTINE GETFA IN npemdriv.f (THE FIRST TEMPLATE FILE TO 
C  INCLUDE GETFA IS TSTMULTG.FOR) TO OBTAIN THE VALUE OF FA FOR EACH
C  OF THE NDRUG DRUGS.

C  AS OF MONT106.FOR: BEFORE CALLING GETFA, MUST SET
C  THE R(.) IN CASE ANY OF THE FA(.) ARE FUNCTIONS OF THE 
C  COVARIATES WHICH ARE ESTABLISHED FROM THE R(.) VALUES IN
C  GETFA.
 
      DO I=1,NI
       R(I)=RSN(KNS,I)
      END DO


	 CALL GETFA(FA)


C  NOTE THAT NBCOMP(I),I=1,NDRUG WAS SET IN SUBROUTINE SYMBOL AND
C  PASSED TO THIS ROUTINE VIA COMMON/BOLUSCOMP.


C  IF N = 0, THE OUTPUT EQUATION(S) FOR Y ARE CODED EXPLICITLY INTO
C  SUBROUTINE OUTPUT, AND NO D.E. SOLUTIONS (VIA USERANAL/DIFFEQ) ARE
C  TO BE USED. IN THIS CASE, SKIP THE CODE REGARDING INITIAL CONDITIONS

C  OF THE COMPARTMENTS, SINCE THEY ARE IRRELEVANT (I.E., THE COMPARTMENT
C  AMOUNTS DON'T NEED TO BE INITIALIZED SINCE THEY WON'T BE UPDATED BY
C  INTEGRATING D.E.'S). IN FACT, COULD PROBABLY SKIP TIMELAGS TOO, 
C  SINCE THEY CHANGE THE TIME THAT BOLUS DOSES ARE GIVEN, AND THIS
C  THEORETICALLY ONLY AFFECTS COMPARTMENT AMOUNTS (WHICH ARE NOT USED
C  IF N = 0), BUT JUST SKIP INITIAL CONDITIONS FOR NOW.

        IF(N .EQ. 0) GO TO 75


C  CALL SUBROUTINE GETIX IN npemdriv.f (THE FIRST TEMPLATE FILE TO 
C  INCLUDE GETIX IS TSTMULTG.FOR) TO OBTAIN THE VALUE OF X (THE INITIAL
C  COMPARTMENT AMOUNT) FOR EACH OF THE N COMPARTMENTS.

	 CALL GETIX(N,X)


C  NOTE THAT SIG AND RS DO NOT HAVE TO BE SAVED AS IN idm2x9.f, SINCE
C  THE NOISY VERSIONS OF THESE ARRAYS (SIGN AND RSN) WILL BE USED
C  BELOW (I.E., EVEN IF THERE ARE STEADY STATE DOSE SETS IN THIS RUN,
C  IT WILL BE SIGN(.) WHICH WILL BE CHANGED TO BE 0, NOT SIG(.).
  

C  CALL SUBROUTINE GETTLAG IN npemdriv.f (THE FIRST TEMPLATE FILE TO 
C  INCLUDE GETTLAG IS TSTMULTG.FOR) TO OBTAIN THE VALUE OF THE TIMELAG
C  FOR EACH OF THE NDRUG DRUGS.

   75	 CALL GETTLAG(TLAG)

C  IF ANY TLAG(.) VALUES RETURN AS .NE. 0, THEN, CALL SUBROUTINE SHIFT
C  TO ADJUST THE DOSAGE REGIMEN APPROPRIATELY.


        NTL = 0
	DO ID = 1,NDRUG
	 IF(TLAG(ID) .NE. 0) NTL = 1
	END DO

	IF(NTL .EQ. 1) THEN

C  STORE INCOMING VALUES IN ND, SIG, AND RS (WHICH CONTAINS BS VALUES)
C  SINCE THEY WILL BE CHANGED IN THE CALL TO SUBROUTINE SHIFT, WHICH 
C  "SHIFTS" THE DOSAGE REGIMEN MATRIX TO ACCOUNT FOR THE TIMELAG 
C  PARAMETER(S), TLAG(I). AT THE END OF THIS ROUTINE, THE VALUES IN ND, 
C  SIG, AND RS WILL BE RESET TO THEIR INCOMING VALUES - TO BE READY FOR 
C  THE NEXT CALL TO THIS ROUTINE WITH POSSIBLY DIFFERENT VALUES FOR 
C  TLAG(I).

C  NOTE THAT THE VALUES OF SIG AND RS DO NOT HAVE TO BE STORED SINCE
C  THESE VALUES WON'T BE USED BELOW - I.E., THE NOISY VERSIONS OF THESE
C  ARRAYS (SIGN AND RSN) ARE NOW USED. BUT ND COULD BE CHANGED IN THE
C  CALL TO SHIFT, SO STORE IT.

	 NDO = ND
C	 DO I=1,ND
C	  SIGO(I) = SIG(I)
C	  DO J=1,NI
C	   RSO(I,J) = RS(I,J)
C	  END DO
C	 END DO


	 CALL SHIFT(TLAG,ND,SIGN,NDRUG,NADD,RSN)

	ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(NTL .EQ. 1)  CONDITION.


C  IN MONTBG17.FOR, THE FOLLOWING LOOP ESTABLISHING BSN(.,.) HAS BEEN
C  MOVED OUTSIDE THE IF(NTL .EQ. 1) SECTION, SINCE THE BSN VALUES MUST
C  BE SET REGARDLESS OF WHETHER OR NOT NTL = 1.

C  ESTABLISH THE VALUES IN EACH DRUG'S PO COLUMN TO THE CORRESPONDING
C  COLUMN IN ARRAY BS.

      DO I=1,ND
       DO J=1,NDRUG
        BSN(I,J)=RSN(I,2*J)
       END DO
      END DO


        IF(TIMN(KNT).GE.SIGN(KNS)) GO TO 12
        IF(TIMN(KNT).NE.0.0D0) GO TO 45


C  THE ONLY WAY THE F0LLOWING CALL TO OUTPUT CAN OCCUR IS IF TIMN(KNT)
C  = 0 --> OBTAIN YT = OUTPUT VALUE(S) AT TIME 0.0.

      CALL OUTPUT(0.D0,YT)
      DO 2000 I=1,NOS
2000    Y(KNT,I)=YT(I)
        KNT=KNT+1
        GO TO 45


12    IF(TIMN(KNT).GT.SIGN(KNS)) GO TO 13
	IF(TIMN(KNT).NE.0.0D0) GO TO 45

C  THE ONLY WAY THE F0LLOWING CALL TO OUTPUT CAN OCCUR IS IF TIMN(KNT)
C  = 0 --> OBTAIN YT = OUTPUT VALUE(S) AT TIME 0.0.

        CALL OUTPUT(0.D0,YT)
	DO 2005 I=1,NOS
2005    Y(KNT,I)=YT(I)

C  ESTABLISH THE COMPARTMENT AMOUNTS AT THIS TIME (TIMN(KNT)). THESE
C  WILL BE PASSED IN COMMON/COMAMT BACK TO SUBROUTINE SIMBIG.

C  NEW CODE FOR MONTBG19.FOR, IN CASE N = -1, IN WHICH CASE THERE ARE
C  3 COMPARTMENTS.

        IF(N .GT. 0) THEN

         DO ICOMPART = 1,N
          XPRED(KNT,ICOMPART) = X(ICOMPART)
         END DO
        ENDIF

        IF(N .EQ. -1) THEN
         DO ICOMPART = 1,3
          XPRED(KNT,ICOMPART) = X(ICOMPART)
         END DO

        ENDIF

       KNT=KNT+1

13      IF(SIGN(KNS) .GT. 0.0D0) GO TO 45


C  CHECK TO SEE IF SIGN(KNS) < 0. IF SO, IT MEANS THAT 100 STEADY STATE
C  DOSES SHOULD NOW BE APPLIED WITH AN INTERDOSE INTERVAL EQUAL TO
C  -SIGN(KNS). NOTE THAT AS OF MONT110.FOR, THERE WILL ALSO BE AN 
C  ADDITIONAL 101ST DOSE SET APPLIED. THIS COMMENT APPLIES TO ALL
C  COMMENTS BELOW REGARDING 100 STEADY STATE DOSE SETS.

      ISTEADY = 0


      IF(SIGN(KNS) .LT. 0.D0) THEN


       ISTEADY = 1
       NSET = 1

C  NOTE THAT ISTEADY = 1 TELLS THE PROGRAM BELOW TO PROCEED AS IF THE
C  DOSE TIME IS 0, AND START INTEGRATING THROUGH THE SET OF 100 
C  DOSE SETS, ALL OF WHICH OCCUR BEFORE THE NEXT OBSERVATION TIME ...
C  BUT PAUSE AFTER THE END OF THE 5TH DOSE SET (NSET IS THE RUNNING NO.
C  OF THE CURRENT DOSE SETS THAT HAVE BEEN RUN) AND CALL SUBROUTINE
C  PREDLAST3 TO PREDICT THE STEADY STATE COMPARTMENT AMOUNTS AFTER THE
C  100 DOSE SETS (NOTE THAT THE COMPARTMENT AMOUNTS WILL HAVE TO BE
C  STORED AT THE END OF EACH OF THE STEADY STATE DOSE SETS AS THE LOGIC
C  OF PREDLAST3 REQUIRES). 

C  IF "CONVERGENCE" IS ACHIEVED AT THAT POINT, ASSIGN THE COMPARTMENT 
C  AMOUNTS TO BE THE PREDICTED AMOUNTS, AND ASSIGN KNS TO BE WHAT IT IS
C  WHEN THESE STEADY STATE DOSE SETS HAVE FINISHED. NOTE THAT THE END OF
C  THE 100TH DOSE SET WILL BE AT TIME 100*(-SIG(KNS)), SO KNS WILL BE 
C  THE INDEX OF THE FIRST DOSE EVENT WHICH OCCURS AFTER THIS TIME.

C  IF "CONVERGENCE" IS NOT ACHIEVED, CONTINUE APPLYING THE LOGIC OF
C  PREDLAST3 UNTIL IT IS ACHIEVED, OR UNTIL THE 100 DOSE SETS ARE ALL
C  INTEGRATED THROUGH, WHICHEVER COMES FIRST

       DOSEINT = -SIGN(KNS)

C  RESET SIGN(KNS) TO BE 0 SINCE THIS DOSE EVENT REPRESENTS THE START
C  OF 100 DOSE SETS THAT BEGIN AT TIME 0. 


       SIGN(KNS) = 0

      ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(SIGN(KNS) .LT. 0.D0)  CONDITION.


      DO I=1,NI
       R(I)=RSN(KNS,I)
      END DO

	IF(NDRUG .EQ. 0) GO TO 81


C  AS OF MONT106.FOR: MUST CALL GETFA BEFORE EVERY TIME THAT
C  FA(.) ARE USED IN CASE THE EQUATION(S) FOR THE FA(.) ARE BASED
C  ON THE COVARIATES, WHICH CAN CHANGE DOSE TO DOSE.

	 CALL GETFA(FA)


        IF(N .EQ. 0) GO TO 120

        DO I=1,NDRUG

	 X(NBCOMP(I))=X(NBCOMP(I))+BSN(KNS,I)*FA(I)
	END DO


C  NOTE THAT FA(I) IS THE FRACTION OF DRUG AVAILABLE FROM A BOLUS INPUT
C  INTO THE ABSORPTIVE COMPARTMENT.

	GO TO 81

120     DO I=1,NDRUG
	 B(I)=BSN(KNS,I)*FA(I)
	END DO

81      KNS=KNS+1
C
C*****INTEGRATION OF EQUATIONS*****

C
C  DETERMINE IF, OBSER(ID=0), OR DOSE(ID=1), OR BOTH(ID=2).

45    IF(KNS.GT.ND) GO TO 15


	IF(TIMN(KNT) .EQ. 0.D0 .AND. KNT .GT. 1) THEN


C  AS OF idm2x7.f, A TIME RESET NO LONGER REQUIRES ALL INITIAL
C  COMPARTMENT AMOUNTS TO BE RESET TO 0. THIS IS BECAUSE A TIME RESET
C  NO LONGER HAS TO MEAN THAT AN "INFINITE" AMOUNT OF TIME HAS OCCURRED
C  WITH NO DOSING; IT CAN ALSO NOW MEAN THAT AN "INFINITE" AMOUNT OF 

C  TIME HAS OCCURRED WITH UNKNOWN DOSING (IN THIS CASE, SUBROUTINE
C  GETIX WILL BE CALLED BELOW TO ESTABLISH INITIAL CONDITIONS FOR THIS
C  TIME PERIOD). 

C  ADVANCE KNS TO THE NEXT VALUE THAT HAS SIGN(KNS) .LE. 0. I.E., ONCE
C  TIMN(KNT) = 0, IT MEANS THAT WE ARE DONE WITH THE OUTPUT OBS.
C  TIMES IN THE PREVIOUS SECTION --> THERE IS NO POINT IN CONTINUING
C  TO INTEGRATE TILL THE END OF THE DOSES IN THE PREVIOUS SECTION
C  (IF THERE ARE ANY).

      DO IKNS = KNS,ND
       IF(SIGN(IKNS) .LE. 0.D0) GO TO 110
      END DO

C  TO GET HERE MEANS THAT NO VALUE IN SIGN(.) FROM KNS TO ND HAS A 
C  VALUE .LE. 0, AND THIS IS AN ERROR. IT MEANS THAT THE PATIENT DATA
C  FILE HAS AN OBSERVATION TIME RESET ROW WITHOUT AN ACCOMPANYING
C  DOSE RESET ROW. TELL THE USER AND STOP.

C  REPLACE WRITING OF SIGN() WITH XVERIFY (SEE LOGIC IN 
C  SUBROUTINE VERIFYVAL.

      XVERIFY(1) = SIGN(KNS)
      CALL VERIFYVAL(1,XVERIFY)
C     WRITE(*,111) ND,KNS,SIGN(KNS)
      WRITE(*,111) ND,KNS,XVERIFY(1)

C     WRITE(25,111) ND,KNS,SIGN(KNS)
      WRITE(25,111) ND,KNS,XVERIFY(1)
 111  FORMAT(//' THE CURRENT SUBJECT HAS AN OBSERVATION TIME RESET'/
     1' ROW WITHOUT AN ACCOMPANYING DOSE RESET ROW. THE PROGRAM NOW'/
     2' STOPS. '//
     3' REVIEW YOUR PATIENT FILES AND CORRECT THE ERROR.'//
     4' NOTE THAT THE ',I4,' DOSE TIMES (POSSIBLY ALTERED BY TIMELAGS'/
     5' ARE THE FOLLOWING (AND THERE IS NO TIME .LE. 0 AFTER TIME'/
     6' NO. ',I4,' WHICH HAS CORRESPONDING TIME ',F15.4,'):')

      OPEN(42,FILE=ERRFIL)
C      WRITE(42,111) ND,KNS,SIGN(KNS)
       WRITE(42,111) ND,KNS,XVERIFY(1)
 
      DO I = 1,ND
       WRITE(*,*) SIGN(I)
       WRITE(25,*) SIGN(I)
       WRITE(42,*) SIGN(I)
      END DO

        CLOSE(42)

      CALL PAUSE
      STOP


  110 KNS = IKNS


C  THERE ARE TWO POSSIBILITES AT THIS POINT, EITHER SIGN(KNS) = 0
C  OR SIGN(KNS) < 0. 

C  IF SIGN(KNS) = 0, THIS REPRESENTS A TIME RESET (T WILL BE SET = 0
C  BELOW) WITH A SINGLE DOSE LINE TO START. IN THIS CASE, CALL GETIX
C  AGAIN (JUST AS WAS DONE NEAR THE TOP OF THIS ROUTINE) TO OBTAIN
C  INITIAL COMPARTMENT AMOUNTS. NOTE THAT BY DEFAULT, IN GETIX, ALL
C  COMPARTMENT AMOUNTS ARE SET = 0 (WHICH WOULD BE THE CASE IF IN THE 
C  LONG TIME PERIOD BETWEEN THE LAST SET OF DOSES AND THIS NEW
C  BEGINNING, NO DOSES HAVE BEEN GIVEN). BUT THE USER MAY ALSO HAVE
C  CODED INTO GETIX EQUATIONS THAT SET ONE OR MORE OF THE X(I) TO
C  FUNCTIONS OF COVARIATE AND PARAMETER VALUES (WHICH WOULD BE THE
C  SITUATION IF AN UNKNOWN DOSING REGIMEN HAS TAKEN PLACE BUT IT
C  DOESN'T MATTER WHAT IT WAS BECAUSE THE PATIENT COMES TO A LAB AND
C  SIMPLY HAS HIS COMPARTMENT VALUES ESTABLISHED BEFORE CONTINUING 
C  WITH THE OTHER VALUES IN HIS PATIENT FILE). 

C  IF SIGN(KNS) < 0, THIS REPRESENTS A TIME RESET WITH A STEADY STATE
C  SET OF 100 DOSES ABOUT TO BEGIN. IN THIS CASE, WE ASSUME THAT THE
C  PATIENT IS ABOUT TO GET 100 SETS OF DOSES SO THAT HIS COMPARTMENT
C  AMOUNTS WILL ACHIEVE STEADY STATE VALUES. THESE STEADY STATE VALUES
C  WILL BE ESTIMATED IN THE BLOCK OF CODE BELOW THAT STARTS WITH 
C  IF(ISTEADY .EQ. 1). IN THIS CASE, WE WILL STILL CALL GETIX TO 
C  MAKE SURE THAT ANY RESIDUAL COMPARTMENT AMOUNTS FROM A PREVIOUS
C  SET OF DOSES IS ZEROED OUT (OR SET = VALUES AS DETERMINED BY
C  SUBROUTINE GETIX). 


C  AS OF MONT106.FOR, BEFORE CALLING GETIX, MUST SET
C  THE R(.) IN CASE ANY OF THE INITIAL CONDITIONS FOR THE X(.)
C  ARE FUNCTIONS OF THE COVARIATES WHICH ARE ESTABLISHED FROM THE 
C  R(.) VALUES IN GETFA.

 
      DO I=1,NI
       R(I)=RSN(KNS,I)
      END DO


       CALL GETIX(N,X)
		
C  MUST ALSO RESET T = 0 SINCE THE INTEGRATION WILL AGAIN START FROM 
C  TIME 0.

       T = 0.D0


C  IF SIGN(KNS) .LT. 0, THIS IS NOT ONLY A TIME RESET, IT IS THE
C  BEGINNING OF A STEADY STATE DOSE SET. IN THIS CASE, APPLY 100 
C  STEADY STATE DOSES WITH AN INTERDOSE INTERVAL EQUAL TO -SIGN(KNS).

      ISTEADY = 0

      IF(SIGN(KNS) .LT. 0.D0) THEN

       ISTEADY = 1
       NSET = 1

C  NOTE THAT ISTEADY = 1 TELLS THE PROGRAM BELOW TO PROCEED AS IF THE
C  DOSE TIME IS 0, AND START INTEGRATING THROUGH THE SET OF 100 
C  DOSE SETS, ALL OF WHICH OCCUR BEFORE THE NEXT OBSERVATION TIME ...
C  BUT PAUSE AFTER THE END OF THE 5TH DOSE SET (NSET IS THE RUNNING NO.
C  OF THE CURRENT DOSE SETS THAT HAVE BEEN RUN) AND CALL SUBROUTINE
C  PREDLAST3 TO PREDICT THE STEADY STATE COMPARTMENT AMOUNTS AFTER THE
C  100 DOSE SETS (NOTE THAT THE COMPARTMENT AMOUNTS WILL HAVE TO BE
C  STORED AT THE END OF EACH OF THE STEADY STATE DOSE SETS AS THE LOGIC
C  OF PREDLAST3 REQUIRES). 

C  IF "CONVERGENCE" IS ACHIEVED AT THAT POINT, ASSIGN THE COMPARTMENT 
C  AMOUNTS TO BE THE PREDICTED AMOUNTS, AND ASSIGN KNS TO BE WHAT IT IS
C  WHEN THESE STEADY STATE DOSE SETS HAVE FINISHED. NOTE THAT THE END OF
C  THE 100TH DOSE SET WILL BE AT TIME 100*(-SIGN(KNS)), SO KNS WILL BE 
C  THE INDEX OF THE FIRST DOSE EVENT WHICH OCCURS AFTER THIS TIME.
C  NOTE THAT AS OF MONT110.FOR, THERE WILL ALSO BE AN ADDITIONAL 101ST
C  DOSE SET APPLIED. BUT KNS WILL STILL BE THE INDEX OF THE FIRST DOSE
C  EVENT AFTER THE 100TH DOSE SET.




C  IF "CONVERGENCE" IS NOT ACHIEVED, CONTINUE APPLYING THE LOGIC OF
C  PREDLAST3 UNTIL IT IS ACHIEVED, OR UNTIL THE 100 DOSE SETS ARE ALL
C  INTEGRATED THROUGH, WHICHEVER COMES FIRST. 


       DOSEINT = -SIGN(KNS)

C  RESET SIGN(KNS) TO BE 0 SINCE THIS DOSE EVENT REPRESENTS THE START
C  OF 100 DOSE SETS THAT BEGIN AT TIME 0. 

       SIGN(KNS) = 0

      ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(SIG(KNS) .LT. 0.D0)  CONDITION.



	ENDIF


C  THE ABOVE ENDIF IS FOR THE 
C   IF(TIMN(KNT) .EQ. 0.D0 .AND. KNT .GT. 1)  CONDITION.


      IF(TIMN(KNT).NE.SIGN(KNS)) GO TO 20
      ID=2
      TOUT=TIMN(KNT)
      KNT=KNT+1
      KNS=KNS+1

      IF(N .EQ. 0) GO TO 31

      GO TO 30


C  AS OF MONT104.FOR, A BUG IS FIXED IN THE CODE BELOW. SEE COMMENTS
C  AT THE TOP OF MONT104.FOR.
20    IF(TIMN(KNT) .GT. SIGN(KNS) .AND. SIGN(KNS) .GT. 0) GO TO 25


15    ID=0
      TOUT=TIMN(KNT)
      KNT=KNT+1

      IF(N .EQ. 0) GO TO 31

      GO TO 30

25    ID=1
      TOUT=SIGN(KNS)
      KNS=KNS+1
      IF(N .EQ. 0) GO TO 31

30      CONTINUE
32      IF(N .NE. -1) CALL USERANAL(X,T,TOUT)
        IF(N .EQ. -1) CALL ANAL3(X,T,TOUT)


C  IF ISTEADY = 1, THIS IS INSIDE A STEADY STATE DOSE SET. CHECK TO SEE
C  IF TOUT IS A MULTIPLE OF DOSEINT. IF SO, RECORD THE COMPARTMENT
C  AMOUNTS. THEN, AFTER COMPARTMENT AMOUNTS HAVE BEEN STORED FOR AT 
C  LEAST THE 1ST 5 MULTIPLES OF DOSEINT, STOP AND CALL SUBROUTINE
C  PREDLAST3 WHICH PREDICTS THE FINAL (STEADY STATE) COMPARTMENT AMOUNTS
C  AFTER THE LAST (100TH) DOSE SET. 

C  IF PREDLAST3 HAS PREDICTED VALUES WHICH "CONVERGE", ASSIGN THE
C  PREDICTED VALUES TO X, INCREASE KNS TO BE THE INDEX OF THE FIRST DOSE
C  EVENT WHICH OCCURS AFTER THE STEADY STATE DOSE SET ENDS AND CONTINUE.

C  IF PREDLAST3 VALUES DON'T CONVERGE, CONTINUE THE PROCESS WITH 
C  COMPARTMENT AMOUNTS FOR MULTIPLES 2 - 6 OF DOSEINT, TEST FOR
C  "CONVERGENCE", ETC. THIS PROCESS CONTINUES UNTIL "CONVERGENCE" IS
C  ACHIEVED FOR A SET OF 5 COMPARTMENT AMOUNTS (OR SETS OF AMOUNTS IF
C  NDRUG IS > 1), OR UNTIL ALL 100 DOSE SETS IN THE STEADY STATE REGIMEN
C  HAVE FINISHED. 

      IF(ISTEADY .EQ. 1) THEN


C  THE NEXT DOSE SET END TIME IS DOSEINT*NSET. IF TOUT = DOSEINT*NSET,
C  STORE THE COMPARTMENT AMOUNTS. IF NSET .GE. 5, CALL PREDLAST3 AND
C  PROCEED AS INDICATED ABOVE.

       CALL THESAME(TOUT,DOSEINT*NSET,ISAME)

       IF(ISAME .EQ. 1) THEN

        NN = N
        IF(N .EQ. -1) NN = 3

        DO J = 1,NN
         XSTORE(NSET,J) = X(J)
        END DO

        IF(NSET .GE. 5) THEN

         CALL PREDLAST3(NN,NSET,XSTORE,XXPRED,ICONV)
  
         IF(ICONV .EQ. 1) THEN

C  SINCE THE PREDICTED VALUES ARE CONSIDERED ACCURATE (I.E., 
C  "CONVERGENCE WAS ACHIEVED IN PREDLAST), RESET ISTEADY TO 0,
C  WHICH MEANS THAT THE STEADY STATE DOSES ARE FINISHED; ASSIGN THE
C  COMPARTMENT AMOUNTS TO BE THE PREDICTED VALUES; AND SET KNS TO THE
C  FIRST DOSE EVENT AFTER THE END OF THE STEADY STATE DOSE SET. ALSO,
C  SET T = THE ENDING TIME OF THE STEADY STATE DOSE SET = 100*DOSEINT,
C  SINCE THAT IS WHAT IT WOULD HAVE BEEN HAD ALL 100 DOSE SETS BEEN
C  RUN. NOTE THAT AS OF MONT110.FOR, THERE WILL ALSO BE AN 
C  ADDITIONAL 101ST DOSE SET APPLIED. BUT THE TIME WILL BE FORWARDED
C  TO THE END OF THE 100TH SET.



          ISTEADY = 0

          DO J = 1,NN
           X(J) = XXPRED(J)
          END DO

          T = 100.D0*DOSEINT




C  ADVANCE KNS TO BE THE FIRST DOSE PAST THE 100 DOSE SETS IN THIS
C  STEADY STATE SET. NOTE THAT THIS SET ENDS BEFORE 100*DOSEINT, SO
C  FIND THE FIRST SIGN(.) THAT IS .GE. 100*DOSEINT, OR THAT IS = 0
C  (WHICH SIGNIFIES A TIME RESET) OR THAT IS < 0 (WHICH SIGNIFIES 
C  ANOTHER STEADY STATE SET).

          DO I = KNS,ND
           IF(SIGN(I) .GE. 100.D0*DOSEINT .OR. SIGN(I) .LE. 0.D0) THEN
            KNSNEW = I
            GO TO 100
           ENDIF
          END DO

C  TO GET HERE MEANS THAT THERE ARE NO DOSE TIMES PAST THE END OF THIS
C  STEADY STATE DOSE SET. IN THIS CASE, SET KNS TO ND+1

          KNS = ND+1
          GO TO 200

  100     KNS = KNSNEW
  200     CONTINUE


C  SET ISKIPBOL = 1 WHENEVER CONVERGENCE OCCURS IN
C  THE STEADY STATE DOSES SINCE IN THIS CASE, WE DON'T WANT TO
C  REAPPLY THE LAST BOLUS FROM THE STEADY STATE SET BELOW LABEL 83.

          ISKIPBOL = 1


         ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(ICONV .EQ. 1)  CONDITION.

C  IF ICONV = 0, NSET WAS INCREASED ABOVE AND ISTEADY IS STILL = 1, 
C  WHICH MEANS THAT THE ATTEMPT TO PREDICT THE FINAL (STEADY STATE)
C  COMPARTMENT AMOUNTS CONTINUES.
          
        ENDIF
      
C  THE ABOVE ENDIF IS FOR THE  IF(NSET .GE. 5)  CONDITION.

C  SINCE ISAME = 1, THE END OF THE SET NO. NSET HAS OCCURRED -->
C  INCREASE NSET BY 1.


        NSET = NSET + 1

       ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(ISAME .EQ. 1)  CONDITION.

      ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(ISTEADY .EQ. 1)  CONDITION.



31      CONTINUE

C  RECORD OBSERVATION AND SUPPLY NEW DOSE
        IF(ID.EQ.1) GO TO 35
        KNTM1=KNT-1

C  NOTE THAT THE TIME AT WHICH THE OUTPUT IS DESIRED IS TIMN(KNTM1); 
C  THIS IS CLEAR SINCE THE RETURNING VALUE(S) IN YT ARE PUT INTO ROW NO.
C  KNTM1 OF Y.

        CALL OUTPUT(TIMN(KNTM1),YT)

	DO 2010 I=1,NOS
2010    Y(KNTM1,I)=YT(I)

C  ESTABLISH THE COMPARTMENT AMOUNTS AT THIS TIME (TIMN(KNTM1)). THESE
C  WILL BE PASSED IN COMMON/COMAMT BACK TO SUBROUTINE SIMBIG.

C  NEW CODE FOR MONTBG19.FOR, IN CASE N = -1, IN WHICH CASE THERE ARE
C  3 COMPARTMENTS.

        IF(N .GT. 0) THEN
         DO ICOMPART = 1,N
          XPRED(KNTM1,ICOMPART) = X(ICOMPART)
         END DO
        ENDIF 

        IF(N .EQ. -1) THEN
         DO ICOMPART = 1,3
          XPRED(KNTM1,ICOMPART) = X(ICOMPART)
         END DO
        ENDIF
 
C??? I THINK THIS IS WHERE THE Y's ARE ASSIGNED. THESE ARE THEN
C    ASSIGNED TO BE F(I,J) = Y(I,J) BELOW, WHERE F = YPRED VIA
C    EVAL AND FUNC2. 

C    SO, FROM THE CALL USERANAL(X,T,TOUT) LINE ABOVE, I THINK THAT
C    THE X AT THIS TIME WOULD BE THE COMPARTMENT VALUES AT THIS
C    TIME. SO MAYBE I CAN JUST STORE THESE X's AND PASS THIS BACK
C    TO MONTBIG4/MAIN TO BE STORED FOR THIS SUBJECT AND THIS TIME,
C    KNTM1.
  
C    MUST CHECK THIS. PERHAPS DO A RUN WITH VOLUME A FIXED KNOWN
C    VALUE AND, SAY, 2 OUTPUT EQUATIONS AND CHECK THAT THE 
C    YPRED(1) = X(1)/V AND YPRED(2) = X(2)/V.

C???


55      IF(ID.EQ.0) GO TO 40

  35    CONTINUE

	IF(NI .EQ. 0) GO TO 83

        DO I=1,NI

	 R(I)=RSN(KNS-1,I)
	END DO

C  AS OF MONT106.FOR: MUST CALL GETFA BEFORE EVERY TIME THAT
C  FA(.) ARE USED IN CASE THE EQUATION(S) FOR THE FA(.) ARE BASED
C  ON THE COVARIATES, WHICH CAN CHANGE DOSE TO DOSE.

	 CALL GETFA(FA)

83      IF(NDRUG .EQ. 0 .OR. N .EQ. 0) GO TO 82

C  ADDING N .EQ. 0 TO ABOVE IF STATEMENT SHOWS CLEARLY THAT IF
C  N = 0 (IN WHICH CASE ANALYTIC SOLUTIONS ARE CODED DIRECTLY INTO
C  SUBROUTINE OUTPUT, WHICH MAKES THE COMPARTMENT AMOUNTS IRRELEVANT)
C  SETTING VALUES FOR THE COMPARTMENTS, X, IS UNNECESSARY.

C  IF ISKIPBOL = 1, DO NOT APPLY BOLUSES FROM DOSE KNS-1, SINCE THESE
C  BOLUSES WERE PART OF THE STEADY STATE DOSE SET WHICH ALREADY HAD
C  BOLUSES (EFFECTIVELY) APPLIED ABOVE WHERE "CONVERGENCE" OF THE
C  STEADY STATE DOSE SET WAS OBTAINED.

        IF(ISKIPBOL .EQ. 0) THEN
         DO I=1,NDRUG
          X(NBCOMP(I))=X(NBCOMP(I))+BSN(KNS-1,I)*FA(I)
         END DO
        ENDIF

C  RESET ISKIPBOL = 0 HERE. IF IT IS NOW = 1, IT MEANS THAT
C  THE ABOVE APPLICATION OF BOLUSES WAS SKIPPED SINCE THERE HAS JUST
C  BEEN A STEADY STATE SET OF DOSES WHICH CONVERGED (AND WE DON'T
C  WANT THE LAST BOLUS DOSE REAPPLIED). BUT, GOING FORWARD, ISKIPBOL
C  SHOULD BE SET AGAIN TO 0 SO THE ABOVE APPLICATION OF BOLUSES WILL
C  OCCUR WHENEVER THERE IS A NEW BOLUS TO BE APPLIED.

      ISKIPBOL = 0




82      CONTINUE

C  CHECK STOPPING TIME.

40      IF(KNT .LE. M) GO TO 45

C*****DETERMINE F(I)*****

	DO J=1,NOS
         DO I=1,M
	  F(I,J) = Y(I,J)
	 END DO
	END DO


C  CODE FOR TIME LAGS, AS OF idcy_53g.f, which allows multiple drugs.
C  IF NTL = 1, THIS RUN INCLUDES AT LEAST ONE TIMELAG PARAMETER. 


C  IN THIS CASE, RESTORE THE VALUES IN ND, SIG, RS, AND BS TO THEIR 
C  INCOMING VALUES - TO BE READY FOR THE NEXT CALL TO THIS ROUTINE WITH 
C  A POSSIBLY DIFFERENT VALUE FOR THE TIMELAGS.

C  NOTE THAT THE VALUES OF SIG AND RS WERE NOT STORED ABOVE SINCE
C  THESE VALUES WEREN'T USED - I.E., THE NOISY VERSIONS OF 
C  THESE ARRAYS (SIGN AND RSN) WERE USED. SIMILARLY FOR BS VS. BSN.
C  BUT ND COULD BE HAVE BEEN CHANGED IN THE CALL TO SHIFT, SO RESTORE 
C  ITS VALUE.


	IF(NTL .EQ. 1) THEN

	 ND = NDO
C	 DO I=1,ND
C	  SIG(I) = SIGO(I)
C	  DO J=1,NI
C	   RS(I,J) = RSO(I,J)
C	  END DO
C	 END DO

C  ESTABLISH THE VALUES IN EACH DRUG'S PO COLUMN TO THE CORRESPONDING
C  COLUMN IN ARRAY BS.

C         DO I=1,ND
C          DO J=1,NDRUG
C           BS(I,J)=RS(I,2*J)
C	   END DO
C	  END DO


	ENDIF
    


      RETURN
      END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
	SUBROUTINE EVAL2(Y,IDUM)

C  THIS SUBROUTINE, CALLED BY MAIN, FINDS THE OUTPUT CONC. 
C  VECTOR, Y, EVALUATED AT PARAMETER VALUES IN VECTOR P, PASSED 
C  DIRECTLY TO SUBROUTINE FUNC2 VIA COMMON/PARAMD.

	IMPLICIT REAL*8(A-H,O-Z)

	PARAMETER(MAXNUMEQ=7)

      COMMON/SUM2/ M,NPNL
      COMMON/CNST2/ NPL,NOS,NDRUG,NADD
      DIMENSION Y(594,MAXNUMEQ)
	CALL FUNC2(M,Y,IDUM)

	RETURN
	END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C  SUBROUTINES USERANAL AND JACOB ARE FROM idm1x4.f.

        SUBROUTINE USERANAL(X,TIN,TOUT)

C  PURPOSE:
C	GIVEN X(TIN) THE PROGRAM CALCULATES X(TOUT), WHERE X IS THE 

C	STATE VECTOR FOR THE MODEL UNDER CONSIDERATION (AS DEFINED
C	BY THE D.E'S IN SUBROUTINE DIFFEQ). THESE D.E'S ARE SOLVED
C	USING THE LINPACK ROUTINE, VODE.FOR (AND ASSOCIATED ROUTINES).

C  	THIS ROUTINE CALLS SUBROUTINE DVODE (VODE.FOR) ONCE FOR EACH
C	POINT AT WHICH ANSWERS ARE DESIRED. NOTE THAT DVODE WILL CALL
C	SUBROUTINE DIFFEQ (SUPPLIED BY THE USER -- IT GIVES THE 
C	DIFF. EQS. OF THE MODEL, XP(I)) AND, IF THE USER DESIRES,
C	SUBROUTINE JACOB (SUPPLIED BY THE USER -- IT GIVES THE


C	JACOBIAN OF PARTIAL DERIVATIVES, dXP(I)/dX(J)). SUBROUTINES
C	DIFFEQ AND JACOB ARE IN THIS MODULE.

C  ARGUMENTS ON INPUT:
C           X - AN ARRAY OF DIMENSION 20. IN THE STANDARD 3-COMPARTMENT
C		MODEL,  X(1), X(2), X(3) SHOULD
C               BE SET TO THE AMOUNT OF DRUG IN THE ABSORBTION,
C               CENTRAL, AND PERIPHERAL COMPARTMENTS, RESPECTIVELY,
C               AT TIME T=TIN.
C         TIN - CURRENT VALUE OF TIME.
C        TOUT - TIME AT WHICH SOLUTION IS DESIRED.

C	VALUES FROM COMMON/TOUSER (FROM MAIN) WHICH WERE INPUT
C 	REAL-TIME BY THE USER (SEE DETAILS BELOW).
C	 NDIM = NO. OF STATES IN MODEL.
C	 MF = METHOD FLAG
C	 RTOL = SCALAR RELATIVE TOLERANCE PARAMETER.
C	 ATOL(I), I=1,NDIM = ABSOLUTE TOLERANCE PARAMETERS.

C  ARGUMENTS ON OUTPUT:
C           X - THE COMPARTMENT AMOUNTS AT T=TOUT.
C         TIN - SET AT TOUT

        IMPLICIT REAL*8(A-H,O-Z)
        DIMENSION X(20),ATOL(20),RWORK(1002),IWORK(50)

C  AS OF MONT109.FOR, THE DIMENSION OF RWORK IS CHANGED FROM 300 TO
C  1002 TO ACCOMADATE AN NDIM (NEQ IN SUBROUTINE DVODE) OF UP TO 20. SO
C  CHANGE LRW BELOW TO 1002. SIMILARLY THE DIMENSION OF IWORK AND
C  LIW BELOW ARE CHANGED FROM 40 TO 50. 

	EXTERNAL DIFFEQ,JACOB

	COMMON/TOUSER/NDIM,MF,RTOL,ATOL



C  THE LOGIC OF THIS CODE IS TAKEN FROM PROGRAM DESOLV3.FOR (4/28/96).

C  FOLLOWING VALUES ARE SUPPLIED TO SUBROUTINE DVODE:

C  DIFFEQ  = NAME OF SUBROUTINE COMPLETED BY USER WHICH GIVES THE D.E.'S 
C	     OF THE MODEL. IT MUST BE DECLARED EXTERNAL.
C TIN      = The initial value of the independent variable.
C TOUT   = First point where output is desired (.ne. TIN). 
C ITOL   = 2 SINCE ATOL IS AN ARRAY.
C RTOL   = Relative tolerance parameter (scalar).
C ATOL   = Absolute tolerance parameter.
C          The estimated local error in X(i) will be controlled so as
C          to be roughly less (in magnitude) than
C             EWT(i) = RTOL*abs(X(i)) + ATOL(i)  SINCE ITOL = 2.
C          Thus the local error test passes if, in each component,
C          either the absolute error is less than ATOL (or ATOL(i)),
C          or the relative error is less than RTOL.
C          Use RTOL = 0.0 for pure absolute error control, and
C          use ATOL = 0.0 (or ATOL(i) = 0.0) for pure relative error


C          control.  Caution.. Actual (global) errors may exceed these
C          local tolerances, so choose them conservatively.
C ITASK  = 1 for normal computation of output values of X at t = TOUT.
C ISTATE = Integer flag (input and output).  Set ISTATE = 1.
C IOPT   = 0 to indicate no optional input used.
C RWORK  = Real work array of length at least..

C             20 + 16*NDIM                      for MF = 10,
C             22 +  9*NDIM + 2*NDIM**2           for MF = 21 or 22,
C             22 + 11*NDIM + (3*ML + 2*MU)*NDIM  for MF = 24 or 25.
C	... I'LL USE AN ARRAY OF 300 (PLENTY FOR NDIM .LE. 8).
C LRW    = Declared length of RWORK (in user's DIMENSION statement).
C IWORK  = Integer work array of length at least..
C             30        for MF = 10,
C             30 + NDIM  for MF = 21, 22, 24, or 25.
C          If MF = 24 or 25, input in IWORK(1),IWORK(2) the lower
C          and upper half-bandwidths ML,MU.
C	... I'LL USE AN ARRAY OF 40 (PLENTY FOR NDIM .LE. 8).
C LIW    = Declared length of IWORK (in user's DIMENSION).
C JACOB    = Name of subroutine COMPLETED BY USER for Jacobian matrix 
C	     (MF = 21 or 24). If used, this name must be declared 
C	     external.  If not used, pass a dummy name.
C MF     = Method flag.  Standard values are..


C          10 for nonstiff (Adams) method, no Jacobian used.

C          21 for stiff (BDF) method, user-supplied full Jacobian.
C          22 for stiff method, internally generated full Jacobian.
C          24 for stiff method, user-supplied banded Jacobian.
C          25 for stiff method, internally generated banded Jacobian.
C RPAR,IPAR = user-defined real and integer SCALARS OR arrays passed to 
C	      DIFFEQ AND JACOB.

C Note that the main program must declare arrays X, RWORK, IWORK,
C and possibly ATOL, RPAR, and IPAR.


C  THE FOLLOWING VALUES RETURN FROM CALLS TO SUBROUTINE DVODE.

C      X = Array of computed values of X vector (AT TIME TOUT).
C      T = Corresponding value of independent variable (normally TOUT).
C ISTATE = 2  if DVODE was successful, negative otherwise.
C          -1 means excess work done on this call. (Perhaps wrong MF.)
C          -2 means excess accuracy requested. (Tolerances too small.)
C          -3 means illegal input detected. (See printed message.)

C          -4 means repeated error test failures. (Check all input.)
C          -5 means repeated convergence failures. (Perhaps bad
C             Jacobian supplied or wrong choice of MF or tolerances.)
C          -6 means error weight became zero during problem. (Solution

C             component i vanished, and ATOL or ATOL(i) = 0.)

	ITOL=2
	ITASK=1
	ISTATE=1
	IOPT=0
	LRW = 1002
	LIW = 50

        CALL DVODE(DIFFEQ,NDIM,X,TIN,TOUT,ITOL,RTOL,ATOL,ITASK,ISTATE,

     1            IOPT,RWORK,LRW,IWORK,LIW,JACOB,MF,RPAR,IPAR)

c        IF (ISTATE .LT. 0) THEN
c         WRITE(*,16) ISTATE

c 16      FORMAT(///' On return from DVODE, ISTATE =',I3)
c	ENDIF



	TIN=TOUT

        RETURN
        END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
	SUBROUTINE JACOB(NDIM, T, X, ML, MU, PD, NRPD, RPAR, IPAR)

	IMPLICIT REAL*8(A-H,O-Z)
        COMMON/PARAMD/ P

        COMMON/INPUT/ R,B
        DIMENSION X(NDIM),PD(NRPD,NDIM),P(32),R(37),B(20)


C  THIS ROUTINE IS CALLED BY LINPACK ROUTINE DVODE (WHICH IS CALLED
C  BY ROUTINE USERANAL). THE USER CODES THE JACOBIAN MATRIX CALCULATIONS
C  OF THE MODEL (I.E., THE PARTIAL DERIVATIVES OF XP(I) W.R.T. X(I),

C  WHERE XP(I) WERE CODED INTO ROUTINE DIFFEQ).

C  SINCE THIS ROUTINE CAN'T BE MADE BY THE 'BOXES' PROGRAM AT THIS TIME,
C  IT WILL NOT BE USED. IT IS JUST A DUMMY ROUTINE, NEEDED BECAUSE
C  DVODE EXPECTS TO 'SEE' IT.

C  INPUT ARE:

C  NDIM = NO. OF STATES (DIMENSION OF PROBLEM).
C  T = CURRENT TIME.
C  X(I) = VALUE OF STATE I AT T, I=1,NDIM.
C  [ML,MU] = HALF BANDWIDTH PARAMETERS ... UNNEEDED IF MF = 21 OR 22
C            --> FULL JACOBIAN IS PROVIDED BY USER BELOW (SEE 
C	     DESOLV3.FOR CODE FOR DETAILS).
C	     NOTE THAT SINCE MF = 21 OR 22 IN THIS CASE, NRPD = NDIM.
C  R AND B VIA COMMON/INPUT.


C  OUTPUT ARE:

C  PD(I,J) = PARTIAL DERIVATIVE OF XP(I) W.R.T. X(J), WHERE XP(I)
C	     ARE CALCULATED IN ROUTINE DIFFEQ ABOVE.

        RETURN
        END							  
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
	SUBROUTINE MAKEVEC(NVAR,NOFIX,IRAN,X,VALFIX,PX)
	IMPLICIT REAL*8(A-H,O-Z)
	DIMENSION IRAN(32),X(150),VALFIX(20),PX(32)
 
C  THIS ROUTINE, CALLED BY SUBROUTINE SIMBIG, INPUTS NVAR, NOFIX, IRAN, 

C  X, AND VALFIX, AND RETURNS PX(I) = A COMBINATION OF THE VALUES IN X 
C  AND VALFIX IN THE PROPER ORDER (AS DETERMINED BY IRAN).
 
	NNNVAR=0
	NNNFIX=0
 
	DO I=1,NVAR+NOFIX
 
	IF(IRAN(I) .EQ. 1) THEN
	 NNNVAR=NNNVAR+1

	 PX(I) = X(NNNVAR)
	ENDIF
 
	IF(IRAN(I) .EQ. 0) THEN
	 NNNFIX=NNNFIX+1
	 PX(I) = VALFIX(NNNFIX)
	ENDIF
 
	END DO
 
	RETURN

	END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC 
C
      SUBROUTINE SHIFT(TAU,ND,SIG,NDRUG,NADD,RS)
      IMPLICIT REAL*8(A-H,O-Z)
      DIMENSION SIG(5000),RS(5000,34),TAU(7),XIV(7,5000,2),
     1  BOL(7,5000,2),COV(20,5000,2),INDIV(7),INDBOL(7),INDCOV(20),
     2  TIMCAN(34)

      CHARACTER ERRFIL*20



      COMMON/ERROR/ERRFIL
C  COMMON/ERROR/ IS SUPPLIED TO ALL THE ROUTINES WHICH COULD WRITE TO
C  ERRFIL.


C  INPUT ARE:

C  TAU(I) =  THE VALUE OF THE TIMELAG FOR DRUG I.

C  ND = ORIGINAL NO. OF DOSE EVENTS. 
C  SIG(I) = TIME FOR ITH DOSE EVENT IN THE ORIGINAL DOSAGE REGIMEN,
C           I=1,ND.

C  NDRUG = NO. OF DRUGS (EACH HAS AN IV, FOLLOWED BY A BOLUS COLUMN).
C  NADD = NO. OF ADDITIONAL COVARIATES (EACH IS IN ITS OWN COLUMN
C         FOLLOWING THE IV/BOLUS COLUMNS.
C  RS(I,J) = "RATE" J FOR THE ITH DOSE EVENT IN THE ORIGINAL DOSAGE
C            REGIMEN; J=1,NI, I=1,ND, WHERE NI = 2*NDRUG + NADD

C            BECAUSE THE "RATES" CONTAIN, IN ORDER, 2 ENTRIES FOR
C            EACH DRUG (1 FOR THE IV AND 1 FOR THE BOLUS) AND 1 EACH
C            FOR THE NADD ADDITIONAL COVARIATES.


C  OUTPUT ARE:

C  ND, SIG, RS, AS ABOVE, EXCEPT FOR THE ALTERED DOSAGE REGIMEN.

C-----------------------------------------------------------------------

c  shift7 differs from shift6 as follows:

c  1. The dimensions related to the no. of dose events are changed from
c  500 to 5000. This is needed as shift7 is compiled with idm1x7.f, 
c  idm2x7.f, and idm3x7.f (part of the npageng16.f "engine"), which
c  accommodates steady state dose sets.



c  2. 3 lines testing for IF(SIG(IDOSE) .EQ. 0 .AND. IDOSE .GT. 1)
c  are replaced by 	  IF(SIG(IDOSE) .LE. 0 .AND. IDOSE .GT. 1)
c  since now a dose reset occurs when a dose time is 0 (a regular
c  time reset) or < 0 (a time reset occurring with a steady state
c  dose set indicator).

c-----------------------------------------------------------------------


C  SHIFT6.F                                                4/26/11

C  SHIFT5 HAS THE FOLLOWING CHANGES TO SHIFT5:

C  WT AND CCR ARE NO LONGER ASSUMED TO BE SPECIAL COVARIATES IN EACH
C  PATIENT'S WORKING COPY PATIENT DATA FILE. SO ALL DO LOOPS THAT 

C  START WITH  DO I = 1, 2+NADD ARE CHANGED TO START WITH DO I = 1,NADD,
C  BUT ONLY IF NADD .GT. 0.


C-----------------------------------------------------------------------

C  SHIFT5.F							9/11/09

C  SHIFT5 HAS THE FOLLOWING CHANGES TO SHIFT4.F.

C  THE ARGUMENT LIST CONTAINS TAU(.) RATHER THAN NTLAG(.). THIS
C  MEANS THAT TAU(I) IS INPUT DIRECTLY AS THE TIMELAG FOR DRUG I.
C  I.E., IT NO LONGER HAS TO BE CALCULATED AS A FUNCTION OF THE
C  PARAMETER ARRAY, P. BECAUSE OF THIS, P IS REMOVED FROM THE ARGUMENT
C  LIST AND THE DIMENSION STATEMENT. ALSO, NTLAG IS REMOVED FROM 
C  THT DIMENSION STATEMENT.

C  THE FIRST SET OF ID MODULES TO CALL SHIFT5.F ARE idm1x3.f, 

C  idm2x3.f, AND idm3x3.f

C-----------------------------------------------------------------------

C  SHIFT4.FOR							9/1/09


C  SHIFT4 HAS THE FOLLOWING CHANGES FROM SHIFT3:

C  1. NTLAG(I) CAN NOW BE NEGATIVE. IF THIS OCCURS, IT MEANS THAT THE
C  TIMELAG PARAMETER FOR DRUG I WILL BE EXP(P(-NTLAG(I)).


C  2. A BUG IS CORRECTED RELATED TO TIME "RESETS". PREVIOUSLY, IF THE
C  USER HAD A TIME "RESET" IN HIS DOSAGE REGIMEN, THIS ROUTINE WOULD
C  NOT WORK. THE REASON IS THAT IN THE CODE BELOW, EACH NEXT TIME
C  FOR AN IV, COVARIATE, OR BOLUS IS COMPARED TO THE PREVIOUSLY
C  ESTABLISHED TIME IN THE DOSAGE ARRAY (TIMNXT) AND IS A CANDIDATE
C  TO BE THE NEXT TIMNXT IF IT IS .GE. TIMNXT. SO IF A TIME RESET
C  VALUE OF 0 OCCURS, IT WILL NEVER BE A CANDIATE SINCE IT IS NOT
C  .GE. THE LAST TIMNXT. TO FIX THIS, AND MAKE SURE THAT A TIME
C  RESET VALUE OF 0 IS INCLUDED IN THE ADJUSTED DOSAGE BLOCK, THE
C  CODE WILL ADD TO EACH IV, BOLUS, AND COVARIATE ARRAY AN EXTRA
C  LINE WHEN A TIME RESET OCCURS. THIS LINE WILL HAVE A TIME OF
C  1.D19 (I.E., A LARGE VALUE WHICH REPRSENTS INFINITY); AND IT
C  WILL BE FOLLOWED BY A LINE WITH THE ADJUSTED RESET TIME (0 FOR
C  IVs AND COVARIATES, AND 0 + TAU(I) FOR BOLI.

C-----------------------------------------------------------------------

C  SHIFT3.FOR							5-23-02

C  SHIFT3 HAS MAJOR CHANGES FROM SHIFT2 TO ALLOW FOR MULTIPLE TIMELAGS,
C  ONE POTENTIALLY FOR EACH BOLUS INPUT OF UP TO 7 DRUGS.

C-----------------------------------------------------------------------

C  SHIFT2.FOR							11-16-99

C  SHIFT2 HAS THE FOLLOWING CHANGE FROM SHIFT. AT THE END OF THE 
C  FORMATION OF ARRAY XMAT, ALL ROWS WHICH HAVE 0 BOLUS INPUT AND THE
C  SAME OTHER DATA VALUES (EXCEPT TIME) AS THE PREVIOUS ROW ARE NOT
C  USED IN THE NEW ARRAY XMAT2 WHICH HAS ONLY NON-REDUNDANT ROWS.
C  THIS, THEORETICALLY, SHOULDN'T HAVE ANY EFFECT ON CALCULATIONS, BUT 
C  NUMERICALLY IT DOES SINCE WHEN THE DVODE ROUTINE SOLVES D.E.'S, IT 
C  INTEGRATES OVER DIFFERENT INTERVALS IF EXTRA DOSAGE LINES ARE 
C  INCLUDED.

C  EX: TIME   IV   BOLUS	TIME   IV   BOLUS
C       0    100     0		 0    100     0
C       5    100   1000		 2    100   1000  


C  NOTE THAT BOTH ABOVE CASES SHOULD GIVE THE SAME RESULTS IF THERE IS
C  A TIME-LAG = 3 IN THE 2ND CASE. BUT, AS THE CODE IS WRITTEN IN
C  SHIFT.FOR, THE 2ND CASE WOULD TRANSLATE TO THE FOLLOWING:

C	 TIME   IV   BOLUS 
C         0    100     0   
C         2    100     0
C         5    100   1000

C  ... AND THIS WOULD MEAN THAT THE 1ST INTEGRATION BY DVODE WOULD END
C      AT T = 2, RATHER THAN 5 (OR, E.G., 3 IF 3 WAS THE
C      FIRST OBSERVATION TIME). THIS CREATES NUMERICAL DIFFERENCES DUE
C      TO SMALL ROUNDOFF ERRORS WHICH CAN GROW SIGNIFICANTLY.

C-----------------------------------------------------------------------


C  SHIFT.FOR							7-27-99

C  SHIFT.FOR IS A MODULE WHICH INCLUDES SUBROUTINE SHIFT. SHIFT WILL BE
C  CALLED BY ROUTINES OF THE "BIG" NPEM AND IT2B PROGRAMS WHICH HAVE
C  SUBROUTINES FUNC, FUNC1, FUNC2, OR FUNC3 IN THEM.

C  SHIFT INPUTS THE DOSAGE REGIMEN VIA THE INPUT ARGUMENTS (SEE BELOW),
C  AND RETURNS AN ALTERED DOSAGE REGIMEN, WHICH HAS EACH BOLUS INPUT 

C  TIME INCREASED BY THE INPUT VALUE OF TAU (THE TIME LAG). NOTE THAT
C  EACH ROW WITH A NON-0 BOLUS INPUT VALUE WILL RESULT IN A NEW ROW IN

C  THE DOSAGE REGIMEN.

C-----------------------------------------------------------------------

C  PROCEDURE FOR THE DOSAGE REGIMEN MODIFICATION:


C  1. ESTABLISH TAU(I) AS THE TIMELAG FOR DRUG I'S BOLUS COLUMN.
C     NO. AS OF SHIFT5.F, THIS VALUE IS INPUT AS AN ARGUMENT.

C  2. ESTABLISH THE IV VALUES AND TIMES INTO XIV(I,J,K). IN PARTICULAR,
C     XIV(I,J,2) IS THE JTH IV VALUE FOR DRUG I, AND XIV(I,J,1) IS THE 
C     TIME THIS IV VALUE FIRST OCCURRED. SET THE LAST TIME TO 1.D29 AS
C     AN INDICATOR THAT THERE ARE NO MORE ENTRIES IN THE ARRAY.

C  3. ESTABLISH THE COVARIATE VALUES AND TIMES INTO COV(I,J,K). IN 
C     PARTICULAR, COV(I,J,2) IS THE JTH VALUE FOR COVARIATE I, AND 
C     COV(I,J,1) IS THE TIME THIS COV VALUE FIRST OCCURRED. SET THE 
C     LAST TIME TO 1.D29 AS AN INDICATOR THAT THERE ARE NO MORE ENTRIES
C     IN THE ARRAY.


C  4. ESTABLISH THE BOLUS VALUES AND TIMES INTO BOL(I,J,K).
C     IN PARTICULAR, BOL(I,J,2) IS THE JTH BOLUS VALUE FOR DRUG I, AND
C     BOL(I,J,1) IS THE TIME THIS BOLUS OCCURRED. THE TIMES FOR EACH
C     BOLUS VALUE ARE THOSE ADJUSTED TIMES FROM THE ASSOCIATED TIMELAGS
C     TAU(I),I=1,NDRUG, FROM STEP 1. SET THE LAST TIME TO 1.D29 AS AN
C     INDICATOR THAT THERE ARE NO MORE ENTRIES IN THE ARRAY.

C  5. REASSIGN THE VALUES IN IV, BOL, AND COV TO THE APPROPRIATE ENTRIES

C     OF RS, KEEPING TRACK OF THE RUNNING INDEX, ND, OF DOSE EVENTS. IF

C     ND EXCEEDS 5000, STOP THE PROGRAM WITH A MESSAGE TO THE USER. ALSO
C     REASSIGN THE CORRESPONDING TIME VALUES TO ARRAY SIG.


C  STEP 1.

C  NOTHING TO DO. AS OF SHIFT5.F, TAU(I), I=1,NDRUG, IS INPUT AS
C  AN ARGUMENT TO THIS ROUTINE.



C  STEP 2:

C  ESTABLISH THE IV VALUES AND TIMES INTO XIV(I,J,K). IN PARTICULAR,
C  XIV(I,J,2) IS THE JTH IV VALUE FOR DRUG I, AND XIV(I,J,1) IS THE 
C  TIME THIS IV VALUE FIRST OCCURRED.

	DO I = 1,NDRUG

C  ESTABLISH XIV(I,J,K) FOR DRUG I'S IV. PRESET THE LAST VALUE TO
C  -99 SO THAT THE FIRST VALUE WILL BE DIFFERENT AND THEREFORE ENGAGE 
C  THE LOGIC (WHICH ONLY WRITES A ROW INTO THE ARRAY IF THE VALUE IS
C  DIFFERENT THAN THE PREVIOUS VALUE). 

C*** MODIFICATION IN SHIFT4.F: IF A TIME RESET OCCURS (I.E., A
C    SIG(IDOSE) = 0, WHERE IDOSE > 1), IT WILL BE HANDLED BY ASSIGNING 
C    AN EXTRA TIME VALUE OF 1.D19 (I.E., A LARGE VALUE REPRESENTING
C    TIME = INFINITY) TO THE IV TIME ARRAY. THEN THE REST OF THE
C    THE IV TIME ARRAY WILL BE ESTABLISHED WITH THE REST OF THE VALUES
C    IN SIG, STARTING, OF COURSE, WITH THE TIME RESET VALUE OF 0.


C    THE SAME LOGIC WILL APPLY TO THE COVARIATES AND THE BOLI.


C  NOTE THAT IND WILL BE THE RUNNING INDEX OF THE LATEST ENTRY INTO 
C  THE ARRAY. PLACE 1.D29 INTO THE LAST TIME ENTRY OF EACH SUB-ARRAY 
C  AS AN INDICATOR THAT THERE ARE NO MORE ENTRIES.

	 XIV(I,1,1) = 1.D29
	 IND = 0
	 VALAST = -99.D0

C  FOR DRUG I, THE IV VALUE IS IN COLUMN 2*I-1 OF ARRAY RS.


	  
	DO IDOSE = 1,ND

	  RR = RS(IDOSE,2*I-1)

C*** MODIFICATION IN SHIFT7.F: A TIME RESET IS NOW DESIGNATED BY A
C  SIG(IDOSE) .LE. 0, RATHER THAN JUST .EQ. 0 (SINCE A STEADY STATE
C  DOSE INDICATOR HAS A NEGATIVE DOSE TIME).

	  IF(SIG(IDOSE) .LE. 0 .AND. IDOSE .GT. 1) THEN


C  THIS REPRESENTS A TIME "RESET". IN THIS CASE, AS INDICATED ABOVE,
C  PUT IN AN EXTRA ROW FOR THE IV REPRESENTING A VERY LARGE TIME
C  AND THE SAME IV VALUE AS THE PREVIOUS VALUE. THEN PUT IN THE
C  LINE REPRESENTING THE RESET TIME OF 0.
	
	    IND = IND + 1
	    XIV(I,IND,1) = 1.D19
	    XIV(I,IND,2) = XIV(I,IND-1,2)

	    IND = IND + 1

C*** MODIFICATION IN SHIFT7.F. SET THE NEXT XIV(I,IND,1) TO BE

C  SIG(IDOSE), NOT 0, SINCE SIG(IDOSE) MAY BE < 0 (SINCE A STEADY STATE
C  DOSE INDICATOR HAS A NEGATIVE DOSE TIME).

	    XIV(I,IND,1) = SIG(IDOSE) 
	    XIV(I,IND,2) = RR
	    XIV(I,IND+1,1) = 1.D29
	    VALAST = RR

	    GO TO 200

	  ENDIF

C  TO GET HERE, THIS DOSE LINE DOES NOT REPRESENT A TIME RESET.

	  IF(RR .NE. VALAST) THEN
         IND = IND + 1
	   XIV(I,IND,1) = SIG(IDOSE)
	   XIV(I,IND,2) = RR
	   XIV(I,IND+1,1) = 1.D29
	   VALAST = RR
	  ENDIF

  200     CONTINUE

	 END DO

C  THE ABOVE END DO IS FOR THE  DO IDOSE = 1,ND  LOOP.


	END DO

C  THE ABOVE END DO IS FOR THE 	DO I = 1,NDRUG  LOOP.


C  STEP 3:

C  ESTABLISH THE COVARIATE VALUES AND TIMES INTO COV(I,J,K). IN 
C  PARTICULAR, COV(I,J,2) IS THE JTH VALUE FOR COVARIATE I, AND 
C  COV(I,J,1) IS THE TIME THIS COV VALUE FIRST OCCURRED. SET THE 
C  LAST TIME TO 1.D29 AS AN INDICATOR THAT THERE ARE NO MORE ENTRIES
C  IN THE ARRAY.

        IF(NADD .GT. 0) THEN

	DO I = 1, NADD



C  ESTABLISH COV(I,J,K) FOR COVARIATE NO. 
C  PRESET THE LAST VALUE TO -99 SO THAT THE FIRST VALUE WILL BE 
C  DIFFERENT AND THEREFORE ENGAGE THE LOGIC (WHICH ONLY WRITES A ROW 
C  INTO THE ARRAY IF THE VALUE IS DIFFERENT THAN THE PREVIOUS VALUE). 
C  NOTE THAT IND WILL BE THE RUNNING INDEX OF THE LATEST ENTRY INTO THE 
C  ARRAY. PLACE 1.D29 INTO THE LAST TIME ENTRY OF EACH SUB-ARRAY AS AN 
C  INDICATOR THAT THERE ARE NO MORE ENTRIES.

	 COV(I,1,1) = 1.D29
	 IND = 0
	 VALAST = -99.D0

C  FOR COVARIATE I, THE VALUE IS IN COLUMN 2*NDRUG+I OF ARRAY RS.	  

	 DO IDOSE = 1,ND

	  RR = RS(IDOSE,2*NDRUG+I)

C*** MODIFICATION IN SHIFT7.F: A TIME RESET IS NOW DESIGNATED BY A
C  SIG(IDOSE) .LE. 0, RATHER THAN JUST .EQ. 0 (SINCE A STEADY STATE
C  DOSE INDICATOR HAS A NEGATIVE DOSE TIME).

	  IF(SIG(IDOSE) .LE. 0 .AND. IDOSE .GT. 1) THEN


C  THIS REPRESENTS A TIME "RESET". IN THIS CASE, AS INDICATED ABOVE,
C  PUT IN AN EXTRA ROW FOR THE COVARIATE REPRESENTING A VERY LARGE TIME
C  AND THE SAME COV VALUE AS THE PREVIOUS VALUE. THEN PUT IN THE
C  LINE REPRESENTING THE RESET TIME OF 0.
	
	    IND = IND + 1
	    COV(I,IND,1) = 1.D19
	    COV(I,IND,2) = COV(I,IND-1,2)

	    IND = IND + 1

C*** MODIFICATION IN SHIFT7.F. SET THE NEXT COV(I,IND,1) TO BE
C  SIG(IDOSE), NOT 0, SINCE SIG(IDOSE) MAY BE < 0 (SINCE A STEADY STATE
C  DOSE INDICATOR HAS A NEGATIVE DOSE TIME).


	    COV(I,IND,1) = SIG(IDOSE) 
	    COV(I,IND,2) = RR
	    COV(I,IND+1,1) = 1.D29

	    VALAST = RR

	    GO TO 300

	  ENDIF

C  TO GET HERE, THIS DOSE LINE DOES NOT REPRESENT A TIME RESET.

	  IF(RR .NE. VALAST) THEN
           IND = IND + 1
	   COV(I,IND,1) = SIG(IDOSE)
	   COV(I,IND,2) = RR
	   COV(I,IND+1,1) = 1.D29
	   VALAST = RR
	  ENDIF

  300     CONTINUE

	 END DO


C  THE ABOVE END DO IS FOR THE   DO IDOSE = 1,ND  LOOP.


	END DO

C  THE ABOVE END DO IS FOR THE  DO I = 1, NADD  LOOP.

        ENDIF

C  THE ABOVE ENDIF IS FOR THE   IF(NADD .GT. 0)  CONDITION.




C  STEP 4:

C  ESTABLISH THE BOLUS VALUES AND TIMES INTO BOL(I,J,K). IN PARTICULAR, 
C  BOL(I,J,2) IS THE JTH BOLUS VALUE FOR DRUG I, AND BOL(I,J,1) IS THE
C  ADJUSTED (USING THE ASSOCIATED TIMELAGS TAU(I),I=1,NDRUG) TIME THIS 
C  BOLUS OCCURRED. 

	DO I = 1,NDRUG

C  ESTABLISH BOL(I,J,K) FOR DRUG I'S BOLUS. EACH ARRAY IS FILLED ONLY

C  WITH NON-0 BOLUS VALUES. NOTE THAT IND WILL BE THE RUNNING INDEX OF 
C  THE LATEST ENTRY INTO THE ARRAY. PLACE 1.D29 INTO THE LAST TIME ENTRY 
C  OF EACH SUB-ARRAY AS AN INDICATOR THAT THERE ARE NO MORE ENTRIES.

	 BOL(I,1,1) = 1.D29
	 IND = 0


C  FOR DRUG I, THE BOLUS VALUE IS IN COLUMN 2*I OF ARRAY RS.	  

	 DO IDOSE = 1,ND

	  RR = RS(IDOSE,2*I)

C*** MODIFICATION IN SHIFT7.F: A TIME RESET IS NOW DESIGNATED BY A
C  SIG(IDOSE) .LE. 0, RATHER THAN JUST .EQ. 0 (SINCE A STEADY STATE

C  DOSE INDICATOR HAS A NEGATIVE DOSE TIME).

	  IF(SIG(IDOSE) .LE. 0 .AND. IDOSE .GT. 1) THEN

C  THIS REPRESENTS A TIME "RESET". IN THIS CASE, AS INDICATED ABOVE,
C  PUT IN AN EXTRA ROW FOR THE BOLUS REPRESENTING A VERY LARGE TIME
C  AND AN ACCOMPANYING BOLUS VALUE OF 0. THEN PUT IN THE
C  LINE REPRESENTING THE RESET TIME OF 0 + THE TIMELAG ... IF
C  RR .NE. 0.
	
	    IND = IND + 1
	    BOL(I,IND,1) = 1.D19
	    BOL(I,IND,2) = 0.D0


	    IND = IND + 1


C*** THE FOLLOWING CODE IS CHANGED IN MONT106.FOR. IT IS BASED ON 
C  SHIFT9.F IN WHICH, UNLIKE IN SHIFT7.F, BOLUS VALUES CAN NOW BE
C  INCLUDED IN STEADY STATE DOSE SETS.

C  LOGIC IS NOW AS FOLLOWS:

C  IF SIG(IDOSE) = 0, THIS IS A TIME RESET WHICH IS NOT THE START OF
C     A STEADY STATE DOSE SET. IN THIS CASE, A BOLUS WITH A TIMELAG OF
C     TAU(I) WILL OCCUR AT SIG(IDOSE) + TAU(I) = TAU(I).

C  IF SIG(IDOSE) < 0, THIS IS A TIME RESET WHICH IS THE START OF A
C     STEADY STATE DOSE SET. IN THIS CASE:
C     THE BOLUS TIME WILL BE TAU(I) ONLY IF BOTH TAU(I) AND RR
C     ARE NOT 0. OTHERWISE, IT WILL BE SIG(IDOSE).
C     REASON: IF RR = 0, THERE IS NO BOLUS TO BE GIVEN, SO IT WOULD
C     BE SILLY TO INCLUDE AN EXTRA LINE IN THE DOSAGE REGIMEN WITH
C     A 0 BOLUS (AND IT WOULD VERY SLIGHTLY CHANGE THE RESULTS SINCE
C     THE NUMERICAL INTEGRATION THEN HAS TO INTEGRATE THROUGH AN EXTRA
C     TIME). IN AN EXAMPLE (REMARK 4.b IN NPAG109.EXP, THIS CHANGED THE
C     VALUES IN THE LOG-LIKELIHOODS OUT IN THE 13TH DIGIT, BUT SOME 
C     VALUES IN THE DENSITY FILE WERE CHANGED IN THE 4TH DIGIT).

C     ALSO, IF TAU(I) = 0, THE BOLUS HAS NO TIMELAG AND THEREFORE
C     OCCURS AT SIG(IDOSE).

C  THE FOLLOWING EXAMPLE SHOWS WHY A NON-0 BOLUS IN A STEADY STATE DOSE
C  SET, WITH TAU(I) .NE. 0, MUST BE GIVEN AT TAU(I) AND NOT
C  SIG(IDOSE) + TAU(I).

C  EX: IF SIG(IDOSE) = -12, IT MEANS THAT A STEADY STATE DOSE SET IS
C      STARTING WITH AN INTERDOSE INTERVAL OF 12 HOURS. SO, IF A 
C      BOLUS WITH A TLAG OF 1.5 HOURS IS GIVEN, ITS TIME MUST BE
C      1.5, NOT -12 + 1.5 = -10.5. REASON: AFTER THE SIG(IDOSE) OF
C      -12 IS CONVERTED IN SUBROUTINE FUNC2 TO 0, THE 1.5 WILL CORRECTLY
C      INDICATE THAT THE BOLUS IS GIVEN 1.5 HOURS AFTER THE START OF THE
C      STEADY STATE DOSE SET. ALSO, A TIME OF -10.5 WOULD COMPLETELY
C      SCREW UP THE FUNC2 LOGIC WHICH WOULD INTERPRET IT AS THE START
C      OF ANOTHER STEADY STATE DOSE SEST.

C      ON THE OTHER HAND, IF A DRUG HAS A TAU(I) = 0, IT CANNOT SHOW
C      UP AS OCCURRING AT TAU(I) = 0 SINCE THIS WILL COMPLETELY SCREW
C      UP FUNC2'S LOGIC, WHICH WILL INTERPRET THE TIME OF 0 AS A
C      TIME RESET EVENT. IN THIS CASE, THE BOLUS OCCURS AT THE START OF
C      THE STEADY STATE DOSE SET, I.E., AT SIG(IDOSE) = -12, WHICH WILL
C      BE CONVERTED TO 0 BY FUNC2).


      CALL THESAME(SIG(IDOSE),0.D0,ISAME1)
      CALL THESAME(TAU(I),0.D0,ISAME2)
      CALL THESAME(RR,0.D0,ISAME3)

      IF(ISAME1 .EQ. 1) BOL(I,IND,1) = TAU(I)
C  NOTE THAT, TECHNICALLY, WE SHOULD SET BOL(I,IND,1) = SIG(IDOSE) = 0
C  IF RR = 0, SINCE THERE IS NO REASON TO HAVE AN EXTRA LINE IN THE
C  DOSAGE REGIMEN FOR A 0 BOLUS ... BUT CHANGING THIS WOULD CHANGE
C  VERY SLIGHTLY THE RESULTS IN A 0 BOLUS CASE SINCE THERE WOULD BE ONE
C  LESS DOSAGE LINE FOR THE NUMERICAL INTEGRATOR TO INTEGRATE THROUGH,
C  SO THE CODE WILL BE LEFT AS IS, FOR CONSISTENCY SAKE.


      IF(ISAME1 .EQ. 0) THEN

       BOL(I,IND,1) = SIG(IDOSE)
       IF(ISAME2 .EQ. 0 .AND. ISAME3 .EQ. 0) BOL(I,IND,1) = TAU(I)
      ENDIF


  

	    BOL(I,IND,2) = RR
	    BOL(I,IND+1,1) = 1.D29
	    VALAST = RR

	    GO TO 400

	  ENDIF

C  TO GET HERE, THIS DOSE LINE DOES NOT REPRESENT A TIME RESET.


	  IF(RR .NE. 0.D0) THEN

           IND = IND + 1

C  *** CHANGE FOR MONT105.FOR.
C  NOW BOLUS VALUES CAN OCCUR IN STEADY STATE DOSES. AND IF THEY DO,
C  THE FIRST ONE MUST OCCUR AT TIME TAU(I), NOT SIG(IDOSE) + TAU(I)
C  AS THE FOLLOWING EXAMPLE ILLUSTRATES:
C  EX: SIG(1) = -12 INDICATING THAT THE STEADY STATE DOSE SET HAS
C      AN INTERDOSE INTERVAL OF 12 HOURS. TAU(1) = 1.5 -->
C      DRUG 1 HAS A TIMELAG OF 1.5 HOURS. SO, IF THE FIRST BOLUS TIME IS
C      SET =  SIG(1) + TAU(1) = -12 + 1.5 = -10.5, THIS WILL SCREW
C      UP THE FUNC2 LOGIC SINCE IN THAT CODE, THE FIRST TIME OF
C      -12 WILL BE RESET TO BE 0, AND THIS WILL BE FOLLOWED BY -10.5,

C      WHICH WILL LOOK LIKE THE START OF ANOTHER STEADY STATE DOSE
C      SET. INSTEAD, SET FIRST BOLUS TIME = TAU(1) = 1.5, WHICH IS
C      CORRECT SINCE IT OCCURS 1.5 HOURS AFTER THE STEADY STATE DOSE
C      STARTS.

         IF(SIG(IDOSE) .GE. 0.D0) BOL(I,IND,1) = SIG(IDOSE) + TAU(I)
         IF(SIG(IDOSE) .LT. 0.D0) BOL(I,IND,1) = TAU(I)

	   BOL(I,IND,2) = RR
	   BOL(I,IND+1,1) = 1.D29
	  ENDIF

  400     CONTINUE

	 END DO

C  THE ABOVE END DO IS FOR THE  DO IDOSE = 1,ND  LOOP.


	END DO


C  THE ABOVE END DO IS FOR THE  DO I = 1,NDRUG  LOOP.


C  STEP 5:

C  REASSIGN THE VALUES IN IV, BOL, AND COV TO THE APPROPRIATE ENTRIES
C  OF RS, KEEPING TRACK OF THE RUNNING INDEX, ND, OF DOSE EVENTS. IF
C  ND EXCEEDS 5000, STOP THE PROGRAM WITH A MESSAGE TO THE USER. ALSO,
C  REASSIGN THE CORRESPONDING TIME VALUES TO ARRAY SIG.




	NI = 2*NDRUG + NADD
	ND = 0

C  GO THROUGH THE ARRAYS IV, BOL, AND COV TO DETERMINE THE NEXT
C  LOWEST DOSE TIME. PUT THIS VALUE INTO RS, ALONG WITH THE 
C  CORRESPONDING VALUES FOR THE IV'S, THE BOLI, AND THE COVARIATES.

C  IN THE LOOP BELOW, IT IS NECESSARY TO KNOW TO WHAT POINT IN THE
C  IV, BOL, AND COV ARRAYS THE TIMES AND VALUES HAVE ALREADY BEEN 

C  STORED INTO RS. THESE INDICES ARE INDIV(I), I=1,NDRUG; INDBOL(I),
C  I=1,NDRUG; AND INDCOV(I), I=1,NADD, RESPECTIVELY. E.G., 
C  INDIV(2) = 4 MEANS THAT ALL VALUES IN THE IV, BOL, AND COV ARRAYS, 
C  THROUGH THE 4TH TIME FOR IV DRUG 2 (I.E., THROUGH TIME = XIV(2,4,1))
C  HAVE BEEN OR ARE ABOUT TO BE STORED INTO THE RS ARRAY.


C  SO PRESET ALL THESE INDEX INDICATORS = 1, AND INITIALIZE THE 
C  CURRENT DOSE TIME TO A NEGATIVE NO. SO THAT THE FIRST TIME

C  THROUGH THE FOLLOWING LOOP WILL ENGAGE THE LOGIC.


	DO I = 1,NDRUG
	 INDIV(I) = 1
	 INDBOL(I) = 1
	END DO

        IF(NADD .GT. 0) THEN
         DO I = 1,NADD
          INDCOV(I) = 1
         END DO
        ENDIF


        TIMNXT = -9999999.D0


  100   CONTINUE

C  FIND THE NEXT LOWEST TIME AMONG THE IV, BOL, AND COV ARRAYS.
C  ESTABLISH INTO TIMCAN(J) THE CANDIDATES FOR THE NEXT DOSE TIME
C  (AND CORRESPONDING VALUES FOR THE IV'S, BOLI, AND COVARIATES) TO
C  BE PUT INTO RS.


        DO I = 1,NDRUG
	 IF(XIV(I,INDIV(I),1) .GT. TIMNXT) TIMCAN(I)=XIV(I,INDIV(I),1)
	 IF(XIV(I,INDIV(I),1) .EQ. TIMNXT) TIMCAN(I)=XIV(I,INDIV(I)+1,1)
	END DO

        DO I = 1,NDRUG
	 IF(BOL(I,INDBOL(I),1) .GT. TIMNXT) TIMCAN(NDRUG+I) = 
     1    BOL(I,INDBOL(I),1)
	 IF(BOL(I,INDBOL(I),1) .EQ. TIMNXT) TIMCAN(NDRUG+I) = 
     1    BOL(I,INDBOL(I)+1,1)
	END DO

        IF(NADD .GT. 0) THEN
         DO I = 1,NADD
          IF(COV(I,INDCOV(I),1) .GT. TIMNXT) TIMCAN(2*NDRUG+I) = 
     1     COV(I,INDCOV(I),1)
          IF(COV(I,INDCOV(I),1) .EQ. TIMNXT) TIMCAN(2*NDRUG+I) = 
     1     COV(I,INDCOV(I)+1,1)
         END DO
        ENDIF


C  FIND THE NEXT TIMNXT, THE MINIMUM VALUE AMONG THE NI ENTRIES IN 
C  TIMCAN. TIMNXT WILL BE THE NEXT TIME TO BE PUT INTO ARRAY RS (ALONG 
C  WITH ALL THE CORRESPONDING IV'S, BOLI, AND COVARIATE VALUES). IF 
C  TIMNXT = 1.D29, IT IS BECAUSE THERE ARE NO FURTHER VALUES TO BE PUT 
C  INTO RS (I.E, THE PROCESS IS FINISHED).


	TIMNXT = TIMCAN(1)
	DO I = 2,NI
	 IF(TIMCAN(I) .LT. TIMNXT) TIMNXT = TIMCAN(I)
	END DO

	IF(TIMNXT .EQ. 1.D29) RETURN

C  SINCE TIMNXT < 1.D29, THERE ARE MORE VALUES TO BE PUT INTO RS.
C  GO THROUGH ALL THE SUBARRAYS AND PUT IN VALUES AS FOLLOWS. IF THE
C  CURRENT TIME FOR AN IV, BOLUS, OR COVARIATE IS THE SAME AS TIMNXT, 
C  PUT THE CORRESPONDING IV, BOLUS, OR COVARIATE VALUE INTO RS, AND 
C  INCREASE THE INDEX FOR THAT SUB-ARRAY TO THE NEXT VALUE. IF THE
C  CURRENT TIME FOR AN IV OR A COVARIATE IS .GT. TIMNXT, PUT THE IV OR 
C  COVARIATE VALUE FROM THE PREVIOUS ROW INTO RS, AND LEAVE THE INDEX 
C  UNCHANGED. IF THE CURRENT TIME FOR A BOLUS IS .GT. TIMNXT, PUT 0.0 
C  INTO RS (I.E., BOLUS VALUES ARE INSTANTANEOUS, WHEREAS IV AND 
C  COVARIATE VALUES CONTINUE UNTIL CHANGED), AND LEAVE THE INDEX
C  UNCHANGED.


C  TEST FOR TIMNXT = 1.D19, WHICH INDICATES A TIME RESET.

	IF(TIMNXT .EQ. 1.D19) THEN

C  TIMNXT = 1.D19 MEANS THAT THE NEXT TIME IN EACH ARRAY IS THE
C  TIME AT OR AFTER THE RESET. SO INCRASE ALL THE ARRAY INDICES BY
C  1, RESET TIMNXT TO A NEGATIVE NO. AND RETURN TO LABEL 100.

	 DO I = 1,NDRUG
	  INDIV(I) = INDIV(I) + 1
	  INDBOL(I) = INDBOL(I) + 1
	 END DO


        IF(NADD .GT. 0) THEN
         DO I = 1,NADD
          INDCOV(I) = INDCOV(I) + 1
         END DO
        ENDIF
	 


	 TIMNXT = -9999999.D0
	
	 GO TO 100

	ENDIF


	ND = ND+1

	IF(ND .GT. 5000) THEN

C  IF ND > 5000, STOP WITH A MESSAGE TO THE USER THAT THE
C  PROGRAM ONLY ALLOWS A TOTAL OF 5000 DOSE EVENTS.

   10	 WRITE(*,1) ND


    1   FORMAT(/' THE NUMBER OF DOSE EVENTS, AFTER TAKING INTO'/
     1' ACCOUNT DIFFERING TIMES DUE TO TIMELAGS IS ',I6,', MORE THAN'/
     2' THE ALLOWABLE MAXIMUM OF 5000. THE PROGRAM IS STOPPING. PLEASE'/
     3' RERUN WITH PATIENTS HAVING FEWER DOSE EVENTS, OR WITH FEWER'/
     4' TIMELAG VALUES SELECTED AS FIXED OR RANDOM PARAMETERS.'//)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,1) ND
        CLOSE(42)



       CALL PAUSE
	 STOP

	ENDIF

C  ND .LE. 5000, SO CONTINUE. FOR THIS DOSE EVENT, PUT IN THE CURRENT 
C  TIME, AND THE CORRESPONDING IV, BOLUS, AND COVARIATE VALUES. 


	SIG(ND) = TIMNXT

        DO I = 1,NDRUG

	 IF(TIMNXT .LT. XIV(I,INDIV(I),1)) THEN
	  RS(ND,2*I-1) = RS(ND-1,2*I-1)
	 ENDIF

	 IF(TIMNXT .EQ. XIV(I,INDIV(I),1)) THEN
	  RS(ND,2*I-1) = XIV(I,INDIV(I),2)
	  INDIV(I) = INDIV(I) + 1
	 ENDIF

	 IF(TIMNXT .LT. BOL(I,INDBOL(I),1)) THEN
	  RS(ND,2*I) = 0.D0
	 ENDIF

	 IF(TIMNXT .EQ. BOL(I,INDBOL(I),1)) THEN
	  RS(ND,2*I) = BOL(I,INDBOL(I),2)
	  INDBOL(I) = INDBOL(I) + 1
	 ENDIF




	END DO




        IF(NADD .GT. 0) THEN
         DO I = 1,NADD
          IF(TIMNXT .LT. COV(I,INDCOV(I),1))
     1     RS(ND,2*NDRUG+I) = RS(ND-1,2*NDRUG+I)
          IF(TIMNXT .EQ. COV(I,INDCOV(I),1)) THEN
           RS(ND,2*NDRUG+I) = COV(I,INDCOV(I),2)
           INDCOV(I) = INDCOV(I) + 1
          ENDIF
         END DO

        ENDIF


	GO TO 100


	END

C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
	SUBROUTINE GETCHAR(JSUB,CHARSUB)
	CHARACTER CHARSUB*5
	CHARACTER*1 A,B,C,D,E

C  THIS ROUTINE, CALLED BY SIMBIG, INPUTS THE INTEGER JSUB
C  (BETWEEN 1 AND 99999), AND OUTPUTS THE 5-CHARACTER EQUIVALENT,
C  CHARSUB.

	ILEFT = JSUB

	I5 = ILEFT/10000
	ILEFT = ILEFT - I5*10000
	I4 = ILEFT/1000

	ILEFT = ILEFT - I4*1000
	I3 = ILEFT/100

	ILEFT = ILEFT - I3*100
	I2 = ILEFT/10
 	ILEFT = ILEFT - I2*10
	I1 = ILEFT

C  CONVERT THIS TO THE CHARACTER EQUIVALENT. 

	IF(I5 .EQ. 1) A='1'
	IF(I5 .EQ. 2) A='2'
	IF(I5 .EQ. 3) A='3'
	IF(I5 .EQ. 4) A='4'
	IF(I5 .EQ. 5) A='5'
	IF(I5 .EQ. 6) A='6'

	IF(I5 .EQ. 7) A='7'
	IF(I5 .EQ. 8) A='8'
	IF(I5 .EQ. 9) A='9'
	IF(I5 .EQ. 0) A='0'

	IF(I4 .EQ. 1) B='1'
	IF(I4 .EQ. 2) B='2'
	IF(I4 .EQ. 3) B='3'
	IF(I4 .EQ. 4) B='4'

	IF(I4 .EQ. 5) B='5'
	IF(I4 .EQ. 6) B='6'
	IF(I4 .EQ. 7) B='7'
	IF(I4 .EQ. 8) B='8'
	IF(I4 .EQ. 9) B='9'
	IF(I4 .EQ. 0) B='0'

	IF(I3 .EQ. 1) C='1'

	IF(I3 .EQ. 2) C='2'
	IF(I3 .EQ. 3) C='3'
	IF(I3 .EQ. 4) C='4'
	IF(I3 .EQ. 5) C='5'
	IF(I3 .EQ. 6) C='6'
	IF(I3 .EQ. 7) C='7'
	IF(I3 .EQ. 8) C='8'
	IF(I3 .EQ. 9) C='9'
	IF(I3 .EQ. 0) C='0'

	IF(I2 .EQ. 1) D='1'
	IF(I2 .EQ. 2) D='2'
	IF(I2 .EQ. 3) D='3'
	IF(I2 .EQ. 4) D='4'
	IF(I2 .EQ. 5) D='5'
	IF(I2 .EQ. 6) D='6'
	IF(I2 .EQ. 7) D='7'

	IF(I2 .EQ. 8) D='8'
	IF(I2 .EQ. 9) D='9'
	IF(I2 .EQ. 0) D='0'


	IF(I1 .EQ. 1) E='1'
	IF(I1 .EQ. 2) E='2'
	IF(I1 .EQ. 3) E='3'
	IF(I1 .EQ. 4) E='4'
	IF(I1 .EQ. 5) E='5'
	IF(I1 .EQ. 6) E='6'
	IF(I1 .EQ. 7) E='7'

	IF(I1 .EQ. 8) E='8'
	IF(I1 .EQ. 9) E='9'
	IF(I1 .EQ. 0) E='0'


	CHARSUB = A//B//C//D//E


	RETURN
	END

C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C

C  VODTOT.FOR (FROM bigmlt5.f)                            5-2-96
C  NOTE THAT THIS VERSION OF VODTOT.FOR IS FROM bigmlt5.f, BUT THE
C  NXE INFO SUPPLIED BY COMMON/NXER/NXE IS NOT USED IN THIS PROGRAM
C  (I.E., IT IS IGNORED, WHEREAS IN bigmlt5.f, IT IS USED).

C  VODTOT.FOR CONTAINS MODULES VODE.FOR AND VODEXT.FOR.
 
C----------------------------------------------------------------------
 
*DECK DVODE


      SUBROUTINE DVODE (F, NEQ, Y, T, TOUT, ITOL, RTOL, ATOL, ITASK,
     1            ISTATE, IOPT, RWORK, LRW, IWORK, LIW, JAC, MF,
     2            RPAR, IPAR)
      EXTERNAL F, JAC
      DOUBLE PRECISION Y, T, TOUT, RTOL, ATOL, RWORK, RPAR
      INTEGER NEQ, ITOL, ITASK, ISTATE, IOPT, LRW, IWORK, LIW,
     1        MF, IPAR
      DIMENSION Y(*), RTOL(*), ATOL(*), RWORK(LRW), IWORK(LIW),
     1          RPAR(*), IPAR(*)
C-----------------------------------------------------------------------

C DVODE.. Variable-coefficient Ordinary Differential Equation solver,
C with fixed-leading coefficient implementation.
C This version is in double precision.
C
C DVODE solves the initial value problem for stiff or nonstiff
C systems of first order ODEs,
C     dy/dt = f(t,y) ,  or, in component form,
C     dy(i)/dt = f(i) = f(i,t,y(1),y(2),...,y(NEQ)) (i = 1,...,NEQ).
C DVODE is a package based on the EPISODE and EPISODEB packages, and
C on the ODEPACK user interface standard, with minor modifications.
C-----------------------------------------------------------------------
C Revision History (YYMMDD)
C   890615  Date Written
C   890922  Added interrupt/restart ability, minor changes throughout.

C   910228  Minor revisions in line format,  prologue, etc.
C   920227  Modifications by D. Pang:
C           (1) Applied subgennam to get generic intrinsic names.
C           (2) Changed intrinsic names to generic in comments.
C           (3) Added *DECK lines before each routine.
C   920721  Names of routines and labeled Common blocks changed, so as
C           to be unique in combined single/double precision code (ACH).

C   920722  Minor revisions to prologue (ACH).
C   920831  Conversion to double precision done (ACH).
C-----------------------------------------------------------------------
C References..
C
C 1. P. N. Brown, G. D. Byrne, and A. C. Hindmarsh, "VODE: A Variable
C    Coefficient ODE Solver," SIAM J. Sci. Stat. Comput., 10 (1989),
C    pp. 1038-1051.  Also, LLNL Report UCRL-98412, June 1988.

C 2. G. D. Byrne and A. C. Hindmarsh, "A Polyalgorithm for the
C    Numerical Solution of Ordinary Differential Equations,"
C    ACM Trans. Math. Software, 1 (1975), pp. 71-96.
C 3. A. C. Hindmarsh and G. D. Byrne, "EPISODE: An Effective Package
C    for the Integration of Systems of Ordinary Differential
C    Equations," LLNL Report UCID-30112, Rev. 1, April 1977.
C 4. G. D. Byrne and A. C. Hindmarsh, "EPISODEB: An Experimental
C    Package for the Integration of Systems of Ordinary Differential
C    Equations with Banded Jacobians," LLNL Report UCID-30132, April
C    1976.
C 5. A. C. Hindmarsh, "ODEPACK, a Systematized Collection of ODE
C    Solvers," in Scientific Computing, R. S. Stepleman et al., eds.,
C    North-Holland, Amsterdam, 1983, pp. 55-64.



C 6. K. R. Jackson and R. Sacks-Davis, "An Alternative Implementation
C    of Variable Step-Size Multistep Formulas for Stiff ODEs," ACM
C    Trans. Math. Software, 6 (1980), pp. 295-318.
C-----------------------------------------------------------------------
C Authors..
C
C               Peter N. Brown and Alan C. Hindmarsh
C               Computing and Mathematics Research Division, L-316
C               Lawrence Livermore National Laboratory
C               Livermore, CA 94550
C and

C               George D. Byrne

C               Exxon Research and Engineering Co.
C               Clinton Township
C               Route 22 East
C               Annandale, NJ 08801
C-----------------------------------------------------------------------


C Summary of usage.
C
C Communication between the user and the DVODE package, for normal
C situations, is summarized here.  This summary describes only a subset
C of the full set of options available.  See the full description for
C details, including optional communication, nonstandard options,
C and instructions for special situations.  See also the example
C problem (with program and output) following this summary.
C
C A. First provide a subroutine of the form..
C
C           SUBROUTINE F (NEQ, T, Y, YDOT, RPAR, IPAR)
C           DOUBLE PRECISION T, Y, YDOT, RPAR
C           DIMENSION Y(NEQ), YDOT(NEQ)
C
C which supplies the vector function f by loading YDOT(i) with f(i).
C
C B. Next determine (or guess) whether or not the problem is stiff.
C Stiffness occurs when the Jacobian matrix df/dy has an eigenvalue
C whose real part is negative and large in magnitude, compared to the
C reciprocal of the t span of interest.  If the problem is nonstiff,
C use a method flag MF = 10.  If it is stiff, there are four standard
C choices for MF (21, 22, 24, 25), and DVODE requires the Jacobian
C matrix in some form.  In these cases (MF .gt. 0), DVODE will use a
C saved copy of the Jacobian matrix.  If this is undesirable because of
C storage limitations, set MF to the corresponding negative value
C (-21, -22, -24, -25).  (See full description of MF below.)
C The Jacobian matrix is regarded either as full (MF = 21 or 22),
C or banded (MF = 24 or 25).  In the banded case, DVODE requires two
C half-bandwidth parameters ML and MU.  These are, respectively, the

C widths of the lower and upper parts of the band, excluding the main
C diagonal.  Thus the band consists of the locations (i,j) with
C i-ML .le. j .le. i+MU, and the full bandwidth is ML+MU+1.
C
C C. If the problem is stiff, you are encouraged to supply the Jacobian
C directly (MF = 21 or 24), but if this is not feasible, DVODE will
C compute it internally by difference quotients (MF = 22 or 25).


C If you are supplying the Jacobian, provide a subroutine of the form..
C
C           SUBROUTINE JAC (NEQ, T, Y, ML, MU, PD, NROWPD, RPAR, IPAR)
C           DOUBLE PRECISION T, Y, PD, RPAR
C           DIMENSION Y(NEQ), PD(NROWPD,NEQ)
C
C which supplies df/dy by loading PD as follows..

C     For a full Jacobian (MF = 21), load PD(i,j) with df(i)/dy(j),
C the partial derivative of f(i) with respect to y(j).  (Ignore the
C ML and MU arguments in this case.)
C     For a banded Jacobian (MF = 24), load PD(i-j+MU+1,j) with

C df(i)/dy(j), i.e. load the diagonal lines of df/dy into the rows of
C PD from the top down.
C     In either case, only nonzero elements need be loaded.
C
C D. Write a main program which calls subroutine DVODE once for
C each point at which answers are desired.  This should also provide
C for possible use of logical unit 6 for output of error messages
C by DVODE.  On the first call to DVODE, supply arguments as follows..
C F      = Name of subroutine for right-hand side vector f.
C          This name must be declared external in calling program.
C NEQ    = Number of first order ODE-s.
C Y      = Array of initial values, of length NEQ.
C T      = The initial value of the independent variable.
C TOUT   = First point where output is desired (.ne. T).
C ITOL   = 1 or 2 according as ATOL (below) is a scalar or array.
C RTOL   = Relative tolerance parameter (scalar).

C ATOL   = Absolute tolerance parameter (scalar or array).
C          The estimated local error in Y(i) will be controlled so as

C          to be roughly less (in magnitude) than
C             EWT(i) = RTOL*abs(Y(i)) + ATOL     if ITOL = 1, or
C             EWT(i) = RTOL*abs(Y(i)) + ATOL(i)  if ITOL = 2.
C          Thus the local error test passes if, in each component,

C          either the absolute error is less than ATOL (or ATOL(i)),
C          or the relative error is less than RTOL.
C          Use RTOL = 0.0 for pure absolute error control, and

C          use ATOL = 0.0 (or ATOL(i) = 0.0) for pure relative error

C          control.  Caution.. Actual (global) errors may exceed these
C          local tolerances, so choose them conservatively.
C ITASK  = 1 for normal computation of output values of Y at t = TOUT.
C ISTATE = Integer flag (input and output).  Set ISTATE = 1.
C IOPT   = 0 to indicate no optional input used.

C RWORK  = Real work array of length at least..
C             20 + 16*NEQ                      for MF = 10,
C             22 +  9*NEQ + 2*NEQ**2           for MF = 21 or 22,
C             22 + 11*NEQ + (3*ML + 2*MU)*NEQ  for MF = 24 or 25.
C LRW    = Declared length of RWORK (in user's DIMENSION statement).
C IWORK  = Integer work array of length at least..
C             30        for MF = 10,
C             30 + NEQ  for MF = 21, 22, 24, or 25.
C          If MF = 24 or 25, input in IWORK(1),IWORK(2) the lower
C          and upper half-bandwidths ML,MU.

C LIW    = Declared length of IWORK (in user's DIMENSION).
C JAC    = Name of subroutine for Jacobian matrix (MF = 21 or 24).
C          If used, this name must be declared external in calling
C          program.  If not used, pass a dummy name.
C MF     = Method flag.  Standard values are..
C          10 for nonstiff (Adams) method, no Jacobian used.
C          21 for stiff (BDF) method, user-supplied full Jacobian.
C          22 for stiff method, internally generated full Jacobian.
C          24 for stiff method, user-supplied banded Jacobian.
C          25 for stiff method, internally generated banded Jacobian.
C RPAR,IPAR = user-defined real and integer arrays passed to F and JAC.
C Note that the main program must declare arrays Y, RWORK, IWORK,
C and possibly ATOL, RPAR, and IPAR.
C
C E. The output from the first call (or any call) is..
C      Y = Array of computed values of y(t) vector.

C      T = Corresponding value of independent variable (normally TOUT).
C ISTATE = 2  if DVODE was successful, negative otherwise.
C          -1 means excess work done on this call. (Perhaps wrong MF.)
C          -2 means excess accuracy requested. (Tolerances too small.)
C          -3 means illegal input detected. (See printed message.)
C          -4 means repeated error test failures. (Check all input.)
C          -5 means repeated convergence failures. (Perhaps bad
C             Jacobian supplied or wrong choice of MF or tolerances.)
C          -6 means error weight became zero during problem. (Solution

C             component i vanished, and ATOL or ATOL(i) = 0.)
C
C F. To continue the integration after a successful return, simply
C reset TOUT and call DVODE again.  No other parameters need be reset.
C
C-----------------------------------------------------------------------

C EXAMPLE PROBLEM
C
C The following is a simple example problem, with the coding
C needed for its solution by DVODE.  The problem is from chemical
C kinetics, and consists of the following three rate equations..
C     dy1/dt = -.04*y1 + 1.e4*y2*y3
C     dy2/dt = .04*y1 - 1.e4*y2*y3 - 3.e7*y2**2
C     dy3/dt = 3.e7*y2**2
C on the interval from t = 0.0 to t = 4.e10, with initial conditions
C y1 = 1.0, y2 = y3 = 0.  The problem is stiff.
C
C The following coding solves this problem with DVODE, using MF = 21
C and printing results at t = .4, 4., ..., 4.e10.  It uses
C ITOL = 2 and ATOL much smaller for y2 than y1 or y3 because
C y2 has much smaller values.
C At the end of the run, statistical quantities of interest are

C printed. (See optional output in the full description below.)
C To generate Fortran source code, replace C in column 1 with a blank
C in the coding below.
C
C     EXTERNAL FEX, JEX
C     DOUBLE PRECISION ATOL, RPAR, RTOL, RWORK, T, TOUT, Y
C     DIMENSION Y(3), ATOL(3), RWORK(67), IWORK(33)
C     NEQ = 3
C     Y(1) = 1.0D0
C     Y(2) = 0.0D0
C     Y(3) = 0.0D0
C     T = 0.0D0
C     TOUT = 0.4D0
C     ITOL = 2
C     RTOL = 1.D-4
C     ATOL(1) = 1.D-8
C     ATOL(2) = 1.D-14
C     ATOL(3) = 1.D-6
C     ITASK = 1
C     ISTATE = 1
C     IOPT = 0
C     LRW = 67
C     LIW = 33
C     MF = 21
C     DO 40 IOUT = 1,12
C       CALL DVODE(FEX,NEQ,Y,T,TOUT,ITOL,RTOL,ATOL,ITASK,ISTATE,
C    1            IOPT,RWORK,LRW,IWORK,LIW,JEX,MF,RPAR,IPAR)
C       WRITE(6,20)T,Y(1),Y(2),Y(3)
C 20    FORMAT(' At t =',D12.4,'   y =',3D14.6)
C       IF (ISTATE .LT. 0) GO TO 80
C 40    TOUT = TOUT*10.
C     WRITE(6,60) IWORK(11),IWORK(12),IWORK(13),IWORK(19),
C    1            IWORK(20),IWORK(21),IWORK(22)
C 60  FORMAT(/' No. steps =',I4,'   No. f-s =',I4,
C    1       '   No. J-s =',I4,'   No. LU-s =',I4/
C    2       '  No. nonlinear iterations =',I4/
C    3       '  No. nonlinear convergence failures =',I4/
C    4       '  No. error test failures =',I4/)
C     STOP
C 80  WRITE(6,90)ISTATE
C 90  FORMAT(///' Error halt.. ISTATE =',I3)
C     STOP
C     END

C
C     SUBROUTINE FEX (NEQ, T, Y, YDOT, RPAR, IPAR)
C     DOUBLE PRECISION RPAR, T, Y, YDOT
C     DIMENSION Y(NEQ), YDOT(NEQ)
C     YDOT(1) = -.04D0*Y(1) + 1.D4*Y(2)*Y(3)
C     YDOT(3) = 3.D7*Y(2)*Y(2)
C     YDOT(2) = -YDOT(1) - YDOT(3)
C     RETURN
C     END
C
C     SUBROUTINE JEX (NEQ, T, Y, ML, MU, PD, NRPD, RPAR, IPAR)
C     DOUBLE PRECISION PD, RPAR, T, Y
C     DIMENSION Y(NEQ), PD(NRPD,NEQ)
C     PD(1,1) = -.04D0
C     PD(1,2) = 1.D4*Y(3)
C     PD(1,3) = 1.D4*Y(2)
C     PD(2,1) = .04D0
C     PD(2,3) = -PD(1,3)
C     PD(3,2) = 6.D7*Y(2)
C     PD(2,2) = -PD(1,2) - PD(3,2)
C     RETURN
C     END
C
C The following output was obtained from the above program on a
C Cray-1 computer with the CFT compiler.
C
C At t =  4.0000e-01   y =  9.851680e-01  3.386314e-05  1.479817e-02
C At t =  4.0000e+00   y =  9.055255e-01  2.240539e-05  9.445214e-02
C At t =  4.0000e+01   y =  7.158108e-01  9.184883e-06  2.841800e-01
C At t =  4.0000e+02   y =  4.505032e-01  3.222940e-06  5.494936e-01
C At t =  4.0000e+03   y =  1.832053e-01  8.942690e-07  8.167938e-01
C At t =  4.0000e+04   y =  3.898560e-02  1.621875e-07  9.610142e-01

C At t =  4.0000e+05   y =  4.935882e-03  1.984013e-08  9.950641e-01
C At t =  4.0000e+06   y =  5.166183e-04  2.067528e-09  9.994834e-01
C At t =  4.0000e+07   y =  5.201214e-05  2.080593e-10  9.999480e-01
C At t =  4.0000e+08   y =  5.213149e-06  2.085271e-11  9.999948e-01
C At t =  4.0000e+09   y =  5.183495e-07  2.073399e-12  9.999995e-01
C At t =  4.0000e+10   y =  5.450996e-08  2.180399e-13  9.999999e-01
C
C No. steps = 595   No. f-s = 832   No. J-s =  13   No. LU-s = 112
C  No. nonlinear iterations = 831
C  No. nonlinear convergence failures =   0
C  No. error test failures =  22
C-----------------------------------------------------------------------
C Full description of user interface to DVODE.
C
C The user interface to DVODE consists of the following parts.
C
C i.   The call sequence to subroutine DVODE, which is a driver
C      routine for the solver.  This includes descriptions of both
C      the call sequence arguments and of user-supplied routines.
C      Following these descriptions is
C        * a description of optional input available through the
C          call sequence,
C        * a description of optional output (in the work arrays), and
C        * instructions for interrupting and restarting a solution.
C
C ii.  Descriptions of other routines in the DVODE package that may be
C      (optionally) called by the user.  These provide the ability to
C      alter error message handling, save and restore the internal
C      COMMON, and obtain specified derivatives of the solution y(t).
C
C iii. Descriptions of COMMON blocks to be declared in overlay
C      or similar environments.
C
C iv.  Description of two routines in the DVODE package, either of
C      which the user may replace with his own version, if desired.

C      these relate to the measurement of errors.
C
C-----------------------------------------------------------------------
C Part i.  Call Sequence.
C
C The call sequence parameters used for input only are
C     F, NEQ, TOUT, ITOL, RTOL, ATOL, ITASK, IOPT, LRW, LIW, JAC, MF,
C and those used for both input and output are
C     Y, T, ISTATE.
C The work arrays RWORK and IWORK are also used for conditional and
C optional input and optional output.  (The term output here refers
C to the return from subroutine DVODE to the user's calling program.)
C
C The legality of input parameters will be thoroughly checked on the
C initial call for the problem, but not checked thereafter unless a
C change in input parameters is flagged by ISTATE = 3 in the input.
C
C The descriptions of the call arguments are as follows.
C
C F      = The name of the user-supplied subroutine defining the

C          ODE system.  The system must be put in the first-order
C          form dy/dt = f(t,y), where f is a vector-valued function
C          of the scalar t and the vector y.  Subroutine F is to
C          compute the function f.  It is to have the form
C               SUBROUTINE F (NEQ, T, Y, YDOT, RPAR, IPAR)
C               DOUBLE PRECISION T, Y, YDOT, RPAR
C               DIMENSION Y(NEQ), YDOT(NEQ)
C          where NEQ, T, and Y are input, and the array YDOT = f(t,y)
C          is output.  Y and YDOT are arrays of length NEQ.
C          (In the DIMENSION statement above, NEQ  can be replaced by
C          *  to make  Y  and  YDOT  assumed size arrays.)
C          Subroutine F should not alter Y(1),...,Y(NEQ).

C          F must be declared EXTERNAL in the calling program.
C
C          Subroutine F may access user-defined real and integer
C          work arrays RPAR and IPAR, which are to be dimensioned
C          in the main program.
C
C          If quantities computed in the F routine are needed
C          externally to DVODE, an extra call to F should be made
C          for this purpose, for consistent and accurate results.
C          If only the derivative dy/dt is needed, use DVINDY instead.
C
C NEQ    = The size of the ODE system (number of first order
C          ordinary differential equations).  Used only for input.
C          NEQ may not be increased during the problem, but
C          can be decreased (with ISTATE = 3 in the input).
C
C Y      = A real array for the vector of dependent variables, of
C          length NEQ or more.  Used for both input and output on the
C          first call (ISTATE = 1), and only for output on other calls.
C          On the first call, Y must contain the vector of initial
C          values.  In the output, Y contains the computed solution
C          evaluated at T.  If desired, the Y array may be used
C          for other purposes between calls to the solver.
C
C          This array is passed as the Y argument in all calls to
C          F and JAC.
C
C T      = The independent variable.  In the input, T is used only on
C          the first call, as the initial point of the integration.
C          In the output, after each call, T is the value at which a
C          computed solution Y is evaluated (usually the same as TOUT).
C          On an error return, T is the farthest point reached.
C
C TOUT   = The next value of t at which a computed solution is desired.
C          Used only for input.
C

C          When starting the problem (ISTATE = 1), TOUT may be equal
C          to T for one call, then should .ne. T for the next call.
C          For the initial T, an input value of TOUT .ne. T is used
C          in order to determine the direction of the integration
C          (i.e. the algebraic sign of the step sizes) and the rough
C          scale of the problem.  Integration in either direction
C          (forward or backward in t) is permitted.
C
C          If ITASK = 2 or 5 (one-step modes), TOUT is ignored after
C          the first call (i.e. the first call with TOUT .ne. T).

C          Otherwise, TOUT is required on every call.

C
C          If ITASK = 1, 3, or 4, the values of TOUT need not be
C          monotone, but a value of TOUT which backs up is limited

C          to the current internal t interval, whose endpoints are
C          TCUR - HU and TCUR.  (See optional output, below, for
C          TCUR and HU.)
C

C ITOL   = An indicator for the type of error control.  See
C          description below under ATOL.  Used only for input.
C
C RTOL   = A relative error tolerance parameter, either a scalar or
C          an array of length NEQ.  See description below under ATOL.
C          Input only.
C
C ATOL   = An absolute error tolerance parameter, either a scalar or
C          an array of length NEQ.  Input only.
C
C          The input parameters ITOL, RTOL, and ATOL determine
C          the error control performed by the solver.  The solver will
C          control the vector e = (e(i)) of estimated local errors
C          in Y, according to an inequality of the form
C                      rms-norm of ( e(i)/EWT(i) )   .le.   1,
C          where       EWT(i) = RTOL(i)*abs(Y(i)) + ATOL(i),
C          and the rms-norm (root-mean-square norm) here is
C          rms-norm(v) = sqrt(sum v(i)**2 / NEQ).  Here EWT = (EWT(i))
C          is a vector of weights which must always be positive, and
C          the values of RTOL and ATOL should all be non-negative.
C          The following table gives the types (scalar/array) of

C          RTOL and ATOL, and the corresponding form of EWT(i).
C
C             ITOL    RTOL       ATOL          EWT(i)


C              1     scalar     scalar     RTOL*ABS(Y(i)) + ATOL
C              2     scalar     array      RTOL*ABS(Y(i)) + ATOL(i)
C              3     array      scalar     RTOL(i)*ABS(Y(i)) + ATOL
C              4     array      array      RTOL(i)*ABS(Y(i)) + ATOL(i)
C
C          When either of these parameters is a scalar, it need not
C          be dimensioned in the user's calling program.
C
C          If none of the above choices (with ITOL, RTOL, and ATOL
C          fixed throughout the problem) is suitable, more general
C          error controls can be obtained by substituting
C          user-supplied routines for the setting of EWT and/or for
C          the norm calculation.  See Part iv below.
C
C          If global errors are to be estimated by making a repeated
C          run on the same problem with smaller tolerances, then all
C          components of RTOL and ATOL (i.e. of EWT) should be scaled
C          down uniformly.
C
C ITASK  = An index specifying the task to be performed.
C          Input only.  ITASK has the following values and meanings.
C          1  means normal computation of output values of y(t) at
C             t = TOUT (by overshooting and interpolating).
C          2  means take one step only and return.
C          3  means stop at the first internal mesh point at or
C             beyond t = TOUT and return.
C          4  means normal computation of output values of y(t) at
C             t = TOUT but without overshooting t = TCRIT.
C             TCRIT must be input as RWORK(1).  TCRIT may be equal to
C             or beyond TOUT, but not behind it in the direction of
C             integration.  This option is useful if the problem
C             has a singularity at or beyond t = TCRIT.
C          5  means take one step, without passing TCRIT, and return.

C             TCRIT must be input as RWORK(1).

C
C          Note..  If ITASK = 4 or 5 and the solver reaches TCRIT
C          (within roundoff), it will return T = TCRIT (exactly) to

C          indicate this (unless ITASK = 4 and TOUT comes before TCRIT,
C          in which case answers at T = TOUT are returned first).
C
C ISTATE = an index used for input and output to specify the
C          the state of the calculation.
C
C          In the input, the values of ISTATE are as follows.
C          1  means this is the first call for the problem

C             (initializations will be done).  See note below.
C          2  means this is not the first call, and the calculation
C             is to continue normally, with no change in any input
C             parameters except possibly TOUT and ITASK.
C             (If ITOL, RTOL, and/or ATOL are changed between calls
C             with ISTATE = 2, the new values will be used but not
C             tested for legality.)
C          3  means this is not the first call, and the
C             calculation is to continue normally, but with
C             a change in input parameters other than
C             TOUT and ITASK.  Changes are allowed in

C             NEQ, ITOL, RTOL, ATOL, IOPT, LRW, LIW, MF, ML, MU,
C             and any of the optional input except H0.
C             (See IWORK description for ML and MU.)
C          Note..  A preliminary call with TOUT = T is not counted
C          as a first call here, as no initialization or checking of

C          input is done.  (Such a call is sometimes useful to include
C          the initial conditions in the output.)
C          Thus the first call for which TOUT .ne. T requires
C          ISTATE = 1 in the input.
C
C          In the output, ISTATE has the following values and meanings.
C           1  means nothing was done, as TOUT was equal to T with
C              ISTATE = 1 in the input.
C           2  means the integration was performed successfully.

C          -1  means an excessive amount of work (more than MXSTEP
C              steps) was done on this call, before completing the
C              requested task, but the integration was otherwise
C              successful as far as T.  (MXSTEP is an optional input
C              and is normally 500.)  To continue, the user may
C              simply reset ISTATE to a value .gt. 1 and call again.
C              (The excess work step counter will be reset to 0.)
C              In addition, the user may increase MXSTEP to avoid
C              this error return.  (See optional input below.)
C          -2  means too much accuracy was requested for the precision
C              of the machine being used.  This was detected before
C              completing the requested task, but the integration
C              was successful as far as T.  To continue, the tolerance
C              parameters must be reset, and ISTATE must be set
C              to 3.  The optional output TOLSF may be used for this
C              purpose.  (Note.. If this condition is detected before
C              taking any steps, then an illegal input return
C              (ISTATE = -3) occurs instead.)
C          -3  means illegal input was detected, before taking any
C              integration steps.  See written message for details.
C              Note..  If the solver detects an infinite loop of calls
C              to the solver with illegal input, it will cause
C              the run to stop.
C          -4  means there were repeated error test failures on

C              one attempted step, before completing the requested
C              task, but the integration was successful as far as T.
C              The problem may have a singularity, or the input
C              may be inappropriate.
C          -5  means there were repeated convergence test failures on
C              one attempted step, before completing the requested
C              task, but the integration was successful as far as T.

C              This may be caused by an inaccurate Jacobian matrix,
C              if one is being used.
C          -6  means EWT(i) became zero for some i during the
C              integration.  Pure relative error control (ATOL(i)=0.0)
C              was requested on a variable which has now vanished.
C              The integration was successful as far as T.
C

C          Note..  Since the normal output value of ISTATE is 2,
C          it does not need to be reset for normal continuation.
C          Also, since a negative input value of ISTATE will be
C          regarded as illegal, a negative output value requires the
C          user to change it, and possibly other input, before
C          calling the solver again.

C
C IOPT   = An integer flag to specify whether or not any optional
C          input is being used on this call.  Input only.
C          The optional input is listed separately below.
C          IOPT = 0 means no optional input is being used.
C                   Default values will be used in all cases.
C          IOPT = 1 means optional input is being used.
C
C RWORK  = A real working array (double precision).
C          The length of RWORK must be at least
C             20 + NYH*(MAXORD + 1) + 3*NEQ + LWM    where
C          NYH    = the initial value of NEQ,
C          MAXORD = 12 (if METH = 1) or 5 (if METH = 2) (unless a

C                   smaller value is given as an optional input),
C          LWM = length of work space for matrix-related data..
C          LWM = 0             if MITER = 0,
C          LWM = 2*NEQ**2 + 2  if MITER = 1 or 2, and MF.gt.0,
C          LWM = NEQ**2 + 2    if MITER = 1 or 2, and MF.lt.0,
C          LWM = NEQ + 2       if MITER = 3,
C          LWM = (3*ML+2*MU+2)*NEQ + 2 if MITER = 4 or 5, and MF.gt.0,
C          LWM = (2*ML+MU+1)*NEQ + 2   if MITER = 4 or 5, and MF.lt.0.
C          (See the MF description for METH and MITER.)
C          Thus if MAXORD has its default value and NEQ is constant,
C          this length is..
C             20 + 16*NEQ                    for MF = 10,
C             22 + 16*NEQ + 2*NEQ**2         for MF = 11 or 12,
C             22 + 16*NEQ + NEQ**2           for MF = -11 or -12,
C             22 + 17*NEQ                    for MF = 13,
C             22 + 18*NEQ + (3*ML+2*MU)*NEQ  for MF = 14 or 15,
C             22 + 17*NEQ + (2*ML+MU)*NEQ    for MF = -14 or -15,
C             20 +  9*NEQ                    for MF = 20,
C             22 +  9*NEQ + 2*NEQ**2         for MF = 21 or 22,
C             22 +  9*NEQ + NEQ**2           for MF = -21 or -22,
C             22 + 10*NEQ                    for MF = 23,

C             22 + 11*NEQ + (3*ML+2*MU)*NEQ  for MF = 24 or 25.
C             22 + 10*NEQ + (2*ML+MU)*NEQ    for MF = -24 or -25.
C          The first 20 words of RWORK are reserved for conditional
C          and optional input and optional output.
C

C          The following word in RWORK is a conditional input..
C            RWORK(1) = TCRIT = critical value of t which the solver
C                       is not to overshoot.  Required if ITASK is
C                       4 or 5, and ignored otherwise.  (See ITASK.)
C
C LRW    = The length of the array RWORK, as declared by the user.
C          (This will be checked by the solver.)
C
C IWORK  = An integer work array.  The length of IWORK must be at least
C             30        if MITER = 0 or 3 (MF = 10, 13, 20, 23), or
C             30 + NEQ  otherwise (abs(MF) = 11,12,14,15,21,22,24,25).
C          The first 30 words of IWORK are reserved for conditional and
C          optional input and optional output.
C
C          The following 2 words in IWORK are conditional input..
C            IWORK(1) = ML     These are the lower and upper
C            IWORK(2) = MU     half-bandwidths, respectively, of the
C                       banded Jacobian, excluding the main diagonal.
C                       The band is defined by the matrix locations
C                       (i,j) with i-ML .le. j .le. i+MU.  ML and MU
C                       must satisfy  0 .le.  ML,MU  .le. NEQ-1.
C                       These are required if MITER is 4 or 5, and
C                       ignored otherwise.  ML and MU may in fact be
C                       the band parameters for a matrix to which
C                       df/dy is only approximately equal.
C

C LIW    = the length of the array IWORK, as declared by the user.
C          (This will be checked by the solver.)
C
C Note..  The work arrays must not be altered between calls to DVODE
C for the same problem, except possibly for the conditional and


C optional input, and except for the last 3*NEQ words of RWORK.
C The latter space is used for internal scratch space, and so is
C available for use by the user outside DVODE between calls, if
C desired (but not for use by F or JAC).
C
C JAC    = The name of the user-supplied routine (MITER = 1 or 4) to
C          compute the Jacobian matrix, df/dy, as a function of
C          the scalar t and the vector y.  It is to have the form
C               SUBROUTINE JAC (NEQ, T, Y, ML, MU, PD, NROWPD,

C                               RPAR, IPAR)
C               DOUBLE PRECISION T, Y, PD, RPAR
C               DIMENSION Y(NEQ), PD(NROWPD, NEQ)
C          where NEQ, T, Y, ML, MU, and NROWPD are input and the array
C          PD is to be loaded with partial derivatives (elements of the
C          Jacobian matrix) in the output.  PD must be given a first
C          dimension of NROWPD.  T and Y have the same meaning as in
C          Subroutine F.  (In the DIMENSION statement above, NEQ can
C          be replaced by  *  to make Y and PD assumed size arrays.)
C               In the full matrix case (MITER = 1), ML and MU are
C          ignored, and the Jacobian is to be loaded into PD in
C          columnwise manner, with df(i)/dy(j) loaded into PD(i,j).
C               In the band matrix case (MITER = 4), the elements
C          within the band are to be loaded into PD in columnwise
C          manner, with diagonal lines of df/dy loaded into the rows
C          of PD. Thus df(i)/dy(j) is to be loaded into PD(i-j+MU+1,j).
C          ML and MU are the half-bandwidth parameters. (See IWORK).
C          The locations in PD in the two triangular areas which
C          correspond to nonexistent matrix elements can be ignored
C          or loaded arbitrarily, as they are overwritten by DVODE.
C               JAC need not provide df/dy exactly.  A crude
C          approximation (possibly with a smaller bandwidth) will do.

C               In either case, PD is preset to zero by the solver,
C          so that only the nonzero elements need be loaded by JAC.
C          Each call to JAC is preceded by a call to F with the same
C          arguments NEQ, T, and Y.  Thus to gain some efficiency,
C          intermediate quantities shared by both calculations may be

C          saved in a user COMMON block by F and not recomputed by JAC,
C          if desired.  Also, JAC may alter the Y array, if desired.
C          JAC must be declared external in the calling program.


C               Subroutine JAC may access user-defined real and integer
C          work arrays, RPAR and IPAR, whose dimensions are set by the
C          user in the main program.
C
C MF     = The method flag.  Used only for input.  The legal values of
C          MF are 10, 11, 12, 13, 14, 15, 20, 21, 22, 23, 24, 25,
C          -11, -12, -14, -15, -21, -22, -24, -25.
C          MF is a signed two-digit integer, MF = JSV*(10*METH + MITER).

C          JSV = SIGN(MF) indicates the Jacobian-saving strategy..
C            JSV =  1 means a copy of the Jacobian is saved for reuse
C                     in the corrector iteration algorithm.
C            JSV = -1 means a copy of the Jacobian is not saved
C                     (valid only for MITER = 1, 2, 4, or 5).
C          METH indicates the basic linear multistep method..
C            METH = 1 means the implicit Adams method.
C            METH = 2 means the method based on backward
C                     differentiation formulas (BDF-s).
C          MITER indicates the corrector iteration method..
C            MITER = 0 means functional iteration (no Jacobian matrix
C                      is involved).
C            MITER = 1 means chord iteration with a user-supplied
C                      full (NEQ by NEQ) Jacobian.
C            MITER = 2 means chord iteration with an internally
C                      generated (difference quotient) full Jacobian
C                      (using NEQ extra calls to F per df/dy value).

C            MITER = 3 means chord iteration with an internally
C                      generated diagonal Jacobian approximation
C                      (using 1 extra call to F per df/dy evaluation).
C            MITER = 4 means chord iteration with a user-supplied
C                      banded Jacobian.

C            MITER = 5 means chord iteration with an internally

C                      generated banded Jacobian (using ML+MU+1 extra
C                      calls to F per df/dy evaluation).
C          If MITER = 1 or 4, the user must supply a subroutine JAC
C          (the name is arbitrary) as described above under JAC.
C          For other values of MITER, a dummy argument can be used.
C
C RPAR     User-specified array used to communicate real parameters
C          to user-supplied subroutines.  If RPAR is a vector, then
C          it must be dimensioned in the user's main program.  If it

C          is unused or it is a scalar, then it need not be
C          dimensioned.
C


C IPAR     User-specified array used to communicate integer parameter
C          to user-supplied subroutines.  The comments on dimensioning
C          RPAR apply to IPAR.
C-----------------------------------------------------------------------
C Optional Input.
C
C The following is a list of the optional input provided for in the
C call sequence.  (See also Part ii.)  For each such input variable,
C this table lists its name as used in this documentation, its
C location in the call sequence, its meaning, and the default value.


C The use of any of this input requires IOPT = 1, and in that
C case all of this input is examined.  A value of zero for any
C of these optional input variables will cause the default value to be
C used.  Thus to use a subset of the optional input, simply preload
C locations 5 to 10 in RWORK and IWORK to 0.0 and 0 respectively, and
C then set those of interest to nonzero values.
C
C NAME    LOCATION      MEANING AND DEFAULT VALUE
C
C H0      RWORK(5)  The step size to be attempted on the first step.
C                   The default value is determined by the solver.
C
C HMAX    RWORK(6)  The maximum absolute step size allowed.
C                   The default value is infinite.
C
C HMIN    RWORK(7)  The minimum absolute step size allowed.
C                   The default value is 0.  (This lower bound is not
C                   enforced on the final step before reaching TCRIT
C                   when ITASK = 4 or 5.)
C
C MAXORD  IWORK(5)  The maximum order to be allowed.  The default
C                   value is 12 if METH = 1, and 5 if METH = 2.
C                   If MAXORD exceeds the default value, it will
C                   be reduced to the default value.
C                   If MAXORD is changed during the problem, it may
C                   cause the current order to be reduced.
C
C MXSTEP  IWORK(6)  Maximum number of (internally defined) steps
C                   allowed during one call to the solver.
C                   The default value is 500.
C
C MXHNIL  IWORK(7)  Maximum number of messages printed (per problem)
C                   warning that T + H = T on a step (H = step size).
C                   This must be positive to result in a non-default
C                   value.  The default value is 10.
C
C-----------------------------------------------------------------------
C Optional Output.
C
C As optional additional output from DVODE, the variables listed
C below are quantities related to the performance of DVODE
C which are available to the user.  These are communicated by way of
C the work arrays, but also have internal mnemonic names as shown.
C Except where stated otherwise, all of this output is defined
C on any successful return from DVODE, and on any return with
C ISTATE = -1, -2, -4, -5, or -6.  On an illegal input return
C (ISTATE = -3), they will be unchanged from their existing values
C (if any), except possibly for TOLSF, LENRW, and LENIW.
C On any error return, output relevant to the error will be defined,
C as noted below.
C
C NAME    LOCATION      MEANING
C
C HU      RWORK(11) The step size in t last used (successfully).
C
C HCUR    RWORK(12) The step size to be attempted on the next step.
C
C TCUR    RWORK(13) The current value of the independent variable
C                   which the solver has actually reached, i.e. the
C                   current internal mesh point in t.  In the output,
C                   TCUR will always be at least as far from the
C                   initial value of t as the current argument T,
C                   but may be farther (if interpolation was done).
C
C TOLSF   RWORK(14) A tolerance scale factor, greater than 1.0,

C                   computed when a request for too much accuracy was
C                   detected (ISTATE = -3 if detected at the start of
C                   the problem, ISTATE = -2 otherwise).  If ITOL is
C                   left unaltered but RTOL and ATOL are uniformly
C                   scaled up by a factor of TOLSF for the next call,

C                   then the solver is deemed likely to succeed.
C                   (The user may also ignore TOLSF and alter the
C                   tolerance parameters in any other way appropriate.)
C
C NST     IWORK(11) The number of steps taken for the problem so far.
C
C NFE     IWORK(12) The number of f evaluations for the problem so far.
C
C NJE     IWORK(13) The number of Jacobian evaluations so far.
C
C NQU     IWORK(14) The method order last used (successfully).
C
C NQCUR   IWORK(15) The order to be attempted on the next step.
C
C IMXER   IWORK(16) The index of the component of largest magnitude in
C                   the weighted local error vector ( e(i)/EWT(i) ),
C                   on an error return with ISTATE = -4 or -5.
C
C LENRW   IWORK(17) The length of RWORK actually required.
C                   This is defined on normal returns and on an illegal
C                   input return for insufficient storage.
C
C LENIW   IWORK(18) The length of IWORK actually required.
C                   This is defined on normal returns and on an illegal
C                   input return for insufficient storage.
C
C NLU     IWORK(19) The number of matrix LU decompositions so far.
C
C NNI     IWORK(20) The number of nonlinear (Newton) iterations so far.
C
C NCFN    IWORK(21) The number of convergence failures of the nonlinear
C                   solver so far.
C
C NETF    IWORK(22) The number of error test failures of the integrator
C                   so far.
C
C The following two arrays are segments of the RWORK array which

C may also be of interest to the user as optional output.
C For each array, the table below gives its internal name,
C its base address in RWORK, and its description.
C
C NAME    BASE ADDRESS      DESCRIPTION
C
C YH      21             The Nordsieck history array, of size NYH by
C                        (NQCUR + 1), where NYH is the initial value

C                        of NEQ.  For j = 0,1,...,NQCUR, column j+1
C                        of YH contains HCUR**j/factorial(j) times
C                        the j-th derivative of the interpolating

C                        polynomial currently representing the
C                        solution, evaluated at t = TCUR.
C
C ACOR     LENRW-NEQ+1   Array of size NEQ used for the accumulated
C                        corrections on each step, scaled in the output
C                        to represent the estimated local error in Y
C                        on the last step.  This is the vector e in

C                        the description of the error control.  It is
C                        defined only on a successful return from DVODE.
C
C-----------------------------------------------------------------------
C Interrupting and Restarting
C


C If the integration of a given problem by DVODE is to be
C interrrupted and then later continued, such as when restarting
C an interrupted run or alternating between two or more ODE problems,
C the user should save, following the return from the last DVODE call
C prior to the interruption, the contents of the call sequence
C variables and internal COMMON blocks, and later restore these
C values before the next DVODE call for that problem.  To save
C and restore the COMMON blocks, use subroutine DVSRCO, as
C described below in part ii.
C

C In addition, if non-default values for either LUN or MFLAG are
C desired, an extra call to XSETUN and/or XSETF should be made just
C before continuing the integration.  See Part ii below for details.
C
C-----------------------------------------------------------------------
C Part ii.  Other Routines Callable.
C
C The following are optional calls which the user may make to
C gain additional capabilities in conjunction with DVODE.
C (The routines XSETUN and XSETF are designed to conform to the
C SLATEC error handling package.)
C

C     FORM OF CALL                  FUNCTION
C  CALL XSETUN(LUN)           Set the logical unit number, LUN, for
C                             output of messages from DVODE, if
C                             the default is not desired.
C                             The default value of LUN is 6.
C
C  CALL XSETF(MFLAG)          Set a flag to control the printing of
C                             messages by DVODE.
C                             MFLAG = 0 means do not print. (Danger..
C                             This risks losing valuable information.)
C                             MFLAG = 1 means print (the default).
C
C                             Either of the above calls may be made at
C                             any time and will take effect immediately.
C
C  CALL DVSRCO(RSAV,ISAV,JOB) Saves and restores the contents of
C                             the internal COMMON blocks used by
C                             DVODE. (See Part iii below.)
C                             RSAV must be a real array of length 49
C                             or more, and ISAV must be an integer
C                             array of length 40 or more.
C                             JOB=1 means save COMMON into RSAV/ISAV.

C                             JOB=2 means restore COMMON from RSAV/ISAV.
C                                DVSRCO is useful if one is
C                             interrupting a run and restarting
C                             later, or alternating between two or
C                             more problems solved with DVODE.
C
C  CALL DVINDY(,,,,,)         Provide derivatives of y, of various
C        (See below.)         orders, at a specified point T, if
C                             desired.  It may be called only after
C                             a successful return from DVODE.
C
C The detailed instructions for using DVINDY are as follows.
C The form of the call is..
C
C  CALL DVINDY (T, K, RWORK(21), NYH, DKY, IFLAG)
C
C The input parameters are..
C
C T         = Value of independent variable where answers are desired
C             (normally the same as the T last returned by DVODE).
C             For valid results, T must lie between TCUR - HU and TCUR.
C             (See optional output for TCUR and HU.)
C K         = Integer order of the derivative desired.  K must satisfy
C             0 .le. K .le. NQCUR, where NQCUR is the current order
C             (see optional output).  The capability corresponding
C             to K = 0, i.e. computing y(T), is already provided
C             by DVODE directly.  Since NQCUR .ge. 1, the first
C             derivative dy/dt is always available with DVINDY.
C RWORK(21) = The base address of the history array YH.
C NYH       = Column length of YH, equal to the initial value of NEQ.
C
C The output parameters are..
C
C DKY       = A real array of length NEQ containing the computed value
C             of the K-th derivative of y(t).

C IFLAG     = Integer flag, returned as 0 if K and T were legal,
C             -1 if K was illegal, and -2 if T was illegal.
C             On an error return, a message is also written.
C-----------------------------------------------------------------------
C Part iii.  COMMON Blocks.
C If DVODE is to be used in an overlay situation, the user
C must declare, in the primary overlay, the variables in..
C   (1) the call sequence to DVODE,
C   (2) the two internal COMMON blocks
C         /DVOD01/  of length  81  (48 double precision words
C                         followed by 33 integer words),
C         /DVOD02/  of length  9  (1 double precision word
C                         followed by 8 integer words),
C
C If DVODE is used on a system in which the contents of internal

C COMMON blocks are not preserved between calls, the user should
C declare the above two COMMON blocks in his main program to insure
C that their contents are preserved.
C
C-----------------------------------------------------------------------
C Part iv.  Optionally Replaceable Solver Routines.
C
C Below are descriptions of two routines in the DVODE package which
C relate to the measurement of errors.  Either routine can be
C replaced by a user-supplied version, if desired.  However, since such
C a replacement may have a major impact on performance, it should be
C done only when absolutely necessary, and only with great caution.
C (Note.. The means by which the package version of a routine is
C superseded by the user's version may be system-dependent.)
C
C (a) DEWSET.
C The following subroutine is called just before each internal
C integration step, and sets the array of error weights, EWT, as
C described under ITOL/RTOL/ATOL above..
C     SUBROUTINE DEWSET (NEQ, ITOL, RTOL, ATOL, YCUR, EWT)
C where NEQ, ITOL, RTOL, and ATOL are as in the DVODE call sequence,
C YCUR contains the current dependent variable vector, and
C EWT is the array of weights set by DEWSET.
C

C If the user supplies this subroutine, it must return in EWT(i)
C (i = 1,...,NEQ) a positive quantity suitable for comparison with
C errors in Y(i).  The EWT array returned by DEWSET is passed to the

C DVNORM routine (See below.), and also used by DVODE in the computation
C of the optional output IMXER, the diagonal Jacobian approximation,
C and the increments for difference quotient Jacobians.
C
C In the user-supplied version of DEWSET, it may be desirable to use
C the current values of derivatives of y.  Derivatives up to order NQ
C are available from the history array YH, described above under

C Optional Output.  In DEWSET, YH is identical to the YCUR array,
C extended to NQ + 1 columns with a column length of NYH and scale
C factors of h**j/factorial(j).  On the first call for the problem,
C given by NST = 0, NQ is 1 and H is temporarily set to 1.0.
C NYH is the initial value of NEQ.  The quantities NQ, H, and NST
C can be obtained by including in DEWSET the statements..
C     DOUBLE PRECISION RVOD, H, HU
C     COMMON /DVOD01/ RVOD(48), IVOD(33)
C     COMMON /DVOD02/ HU, NCFN, NETF, NFE, NJE, NLU, NNI, NQU, NST
C     NQ = IVOD(28)
C     H = RVOD(21)
C Thus, for example, the current value of dy/dt can be obtained as
C YCUR(NYH+i)/H  (i=1,...,NEQ)  (and the division by H is
C unnecessary when NST = 0).
C
C (b) DVNORM.
C The following is a real function routine which computes the weighted
C root-mean-square norm of a vector v..

C     D = DVNORM (N, V, W)
C where..
C   N = the length of the vector,

C   V = real array of length N containing the vector,
C   W = real array of length N containing weights,
C   D = sqrt( (1/N) * sum(V(i)*W(i))**2 ).
C DVNORM is called with N = NEQ and with W(i) = 1.0/EWT(i), where
C EWT is as set by subroutine DEWSET.
C
C If the user supplies this function, it should return a non-negative
C value of DVNORM suitable for use in the error control in DVODE.
C None of the arguments should be altered by DVNORM.
C For example, a user-supplied DVNORM routine might..
C   -substitute a max-norm of (V(i)*W(i)) for the rms-norm, or


C   -ignore some components of V in the norm, with the effect of
C    suppressing the error control on those components of Y.
C-----------------------------------------------------------------------
C Other Routines in the DVODE Package.

C
C In addition to subroutine DVODE, the DVODE package includes the
C following subroutines and function routines..
C  DVHIN     computes an approximate step size for the initial step.
C  DVINDY    computes an interpolated value of the y vector at t = TOUT.
C  DVSTEP    is the core integrator, which does one step of the
C            integration and the associated error control.
C  DVSET     sets all method coefficients and test constants.
C  DVNLSD    solves the underlying nonlinear system -- the corrector.

C  DVJAC     computes and preprocesses the Jacobian matrix J = df/dy
C            and the Newton iteration matrix P = I - (h/l1)*J.
C  DVSOL     manages solution of linear system in chord iteration.
C  DVJUST    adjusts the history array on a change of order.
C  DEWSET    sets the error weight vector EWT before each step.
C  DVNORM    computes the weighted r.m.s. norm of a vector.
C  DVSRCO    is a user-callable routines to save and restore
C            the contents of the internal COMMON blocks.
C  DACOPY    is a routine to copy one two-dimensional array to another.
C  DGEFA and DGESL   are routines from LINPACK for solving full
C            systems of linear algebraic equations.
C  DGBFA and DGBSL   are routines from LINPACK for solving banded

C            linear systems.
C  DAXPY, DSCAL, and DCOPY are basic linear algebra modules (BLAS).
C  D1MACH    sets the unit roundoff of the machine.
C  XERRWD, XSETUN, XSETF, LUNSAV, and MFLGSV handle the printing of all

C            error messages and warnings.  XERRWD is machine-dependent.
C Note..  DVNORM, D1MACH, LUNSAV, and MFLGSV are function routines.
C All the others are subroutines.
C
C The intrinsic and external routines used by the DVODE package are..
C ABS, MAX, MIN, REAL, SIGN, SQRT, and WRITE.
C
C-----------------------------------------------------------------------
C
C Type declarations for labeled COMMON block DVOD01 --------------------
C
      DOUBLE PRECISION ACNRM, CCMXJ, CONP, CRATE, DRC, EL,
     1     ETA, ETAMAX, H, HMIN, HMXI, HNEW, HSCAL, PRL1,
     2     RC, RL1, TAU, TQ, TN, UROUND
      INTEGER ICF, INIT, IPUP, JCUR, JSTART, JSV, KFLAG, KUTH,
     1        L, LMAX, LYH, LEWT, LACOR, LSAVF, LWM, LIWM,
     2        LOCJS, MAXORD, METH, MITER, MSBJ, MXHNIL, MXSTEP,
     3        N, NEWH, NEWQ, NHNIL, NQ, NQNYH, NQWAIT, NSLJ,
     4        NSLP, NYH
C
C Type declarations for labeled COMMON block DVOD02 --------------------

C
      DOUBLE PRECISION HU
      INTEGER NCFN, NETF, NFE, NJE, NLU, NNI, NQU, NST
C
C Type declarations for local variables --------------------------------

C
      EXTERNAL DVNLSD
      LOGICAL IHIT
      DOUBLE PRECISION ATOLI, BIG, EWTI, FOUR, H0, HMAX, HMX, HUN, ONE,
     1   PT2, RH, RTOLI, SIZE, TCRIT, TNEXT, TOLSF, TP, TWO, ZERO
      INTEGER I, IER, IFLAG, IMXER, JCO, KGO, LENIW, LENJ, LENP, LENRW,
     1   LENWM, LF0, MBAND, ML, MORD, MU, MXHNL0, MXSTP0, NITER, NSLAST
      CHARACTER*80 MSG
C
C Type declaration for function subroutines called ---------------------
C
      DOUBLE PRECISION D1MACH, DVNORM

C
      DIMENSION MORD(2)
C-----------------------------------------------------------------------
C The following Fortran-77 declaration is to cause the values of the
C listed (local) variables to be saved between calls to DVODE.
C-----------------------------------------------------------------------
      SAVE MORD, MXHNL0, MXSTP0
      SAVE ZERO, ONE, TWO, FOUR, PT2, HUN
C-----------------------------------------------------------------------
C The following internal COMMON blocks contain variables which are
C communicated between subroutines in the DVODE package, or which are
C to be saved between calls to DVODE.
C In each block, real variables precede integers.
C The block /DVOD01/ appears in subroutines DVODE, DVINDY, DVSTEP,
C DVSET, DVNLSD, DVJAC, DVSOL, DVJUST and DVSRCO.
C The block /DVOD02/ appears in subroutines DVODE, DVINDY, DVSTEP,
C DVNLSD, DVJAC, and DVSRCO.
C
C The variables stored in the internal COMMON blocks are as follows..
C
C ACNRM  = Weighted r.m.s. norm of accumulated correction vectors.
C CCMXJ  = Threshhold on DRC for updating the Jacobian. (See DRC.)
C CONP   = The saved value of TQ(5).
C CRATE  = Estimated corrector convergence rate constant.
C DRC    = Relative change in H*RL1 since last DVJAC call.
C EL     = Real array of integration coefficients.  See DVSET.
C ETA    = Saved tentative ratio of new to old H.
C ETAMAX = Saved maximum value of ETA to be allowed.
C H      = The step size.
C HMIN   = The minimum absolute value of the step size H to be used.
C HMXI   = Inverse of the maximum absolute value of H to be used.
C          HMXI = 0.0 is allowed and corresponds to an infinite HMAX.

C HNEW   = The step size to be attempted on the next step.
C HSCAL  = Stepsize in scaling of YH array.
C PRL1   = The saved value of RL1.
C RC     = Ratio of current H*RL1 to value on last DVJAC call.
C RL1    = The reciprocal of the coefficient EL(1).
C TAU    = Real vector of past NQ step sizes, length 13.
C TQ     = A real vector of length 5 in which DVSET stores constants

C          used for the convergence test, the error test, and the
C          selection of H at a new order.
C TN     = The independent variable, updated on each step taken.
C UROUND = The machine unit roundoff.  The smallest positive real number
C          such that  1.0 + UROUND .ne. 1.0
C ICF    = Integer flag for convergence failure in DVNLSD..
C            0 means no failures.
C            1 means convergence failure with out of date Jacobian

C                   (recoverable error).
C            2 means convergence failure with current Jacobian or
C                   singular matrix (unrecoverable error).
C INIT   = Saved integer flag indicating whether initialization of the
C          problem has been done (INIT = 1) or not.
C IPUP   = Saved flag to signal updating of Newton matrix.
C JCUR   = Output flag from DVJAC showing Jacobian status..

C            JCUR = 0 means J is not current.
C            JCUR = 1 means J is current.


C JSTART = Integer flag used as input to DVSTEP..
C            0  means perform the first step.
C            1  means take a new step continuing from the last.
C            -1 means take the next step with a new value of MAXORD,
C                  HMIN, HMXI, N, METH, MITER, and/or matrix parameters.
C          On return, DVSTEP sets JSTART = 1.
C JSV    = Integer flag for Jacobian saving, = sign(MF).
C KFLAG  = A completion code from DVSTEP with the following meanings..
C               0      the step was succesful.
C              -1      the requested error could not be achieved.
C              -2      corrector convergence could not be achieved.
C              -3, -4  fatal error in VNLS (can not occur here).
C KUTH   = Input flag to DVSTEP showing whether H was reduced by the
C          driver.  KUTH = 1 if H was reduced, = 0 otherwise.
C L      = Integer variable, NQ + 1, current order plus one.
C LMAX   = MAXORD + 1 (used for dimensioning).
C LOCJS  = A pointer to the saved Jacobian, whose storage starts at
C          WM(LOCJS), if JSV = 1.
C LYH, LEWT, LACOR, LSAVF, LWM, LIWM = Saved integer pointers
C          to segments of RWORK and IWORK.

C MAXORD = The maximum order of integration method to be allowed.
C METH/MITER = The method flags.  See MF.
C MSBJ   = The maximum number of steps between J evaluations, = 50.
C MXHNIL = Saved value of optional input MXHNIL.
C MXSTEP = Saved value of optional input MXSTEP.
C N      = The number of first-order ODEs, = NEQ.
C NEWH   = Saved integer to flag change of H.
C NEWQ   = The method order to be used on the next step.
C NHNIL  = Saved counter for occurrences of T + H = T.
C NQ     = Integer variable, the current integration method order.
C NQNYH  = Saved value of NQ*NYH.
C NQWAIT = A counter controlling the frequency of order changes.
C          An order change is about to be considered if NQWAIT = 1.
C NSLJ   = The number of steps taken as of the last Jacobian update.
C NSLP   = Saved value of NST as of last Newton matrix update.
C NYH    = Saved value of the initial value of NEQ.
C HU     = The step size in t last used.
C NCFN   = Number of nonlinear convergence failures so far.
C NETF   = The number of error test failures of the integrator so far.
C NFE    = The number of f evaluations for the problem so far.
C NJE    = The number of Jacobian evaluations so far.
C NLU    = The number of matrix LU decompositions so far.
C NNI    = Number of nonlinear iterations so far.
C NQU    = The method order last used.
C NST    = The number of steps taken for the problem so far.
C-----------------------------------------------------------------------
      COMMON /DVOD01/ ACNRM, CCMXJ, CONP, CRATE, DRC, EL(13),
     1                ETA, ETAMAX, H, HMIN, HMXI, HNEW, HSCAL, PRL1,
     2                RC, RL1, TAU(13), TQ(5), TN, UROUND,
     3                ICF, INIT, IPUP, JCUR, JSTART, JSV, KFLAG, KUTH,
     4                L, LMAX, LYH, LEWT, LACOR, LSAVF, LWM, LIWM,
     5                LOCJS, MAXORD, METH, MITER, MSBJ, MXHNIL, MXSTEP,
     6                N, NEWH, NEWQ, NHNIL, NQ, NQNYH, NQWAIT, NSLJ,
     7                NSLP, NYH
      COMMON /DVOD02/ HU, NCFN, NETF, NFE, NJE, NLU, NNI, NQU, NST
C
      DATA  MORD(1) /12/, MORD(2) /5/, MXSTP0 /500/, MXHNL0 /10/

      DATA ZERO /0.0D0/, ONE /1.0D0/, TWO /2.0D0/, FOUR /4.0D0/,
     1     PT2 /0.2D0/, HUN /100.0D0/
C-----------------------------------------------------------------------
C Block A.
C This code block is executed on every call.

C It tests ISTATE and ITASK for legality and branches appropriately.
C If ISTATE .gt. 1 but the flag INIT shows that initialization has
C not yet been done, an error return occurs.

C If ISTATE = 1 and TOUT = T, return immediately.
C-----------------------------------------------------------------------
      IF (ISTATE .LT. 1 .OR. ISTATE .GT. 3) GO TO 601
      IF (ITASK .LT. 1 .OR. ITASK .GT. 5) GO TO 602
      IF (ISTATE .EQ. 1) GO TO 10
      IF (INIT .NE. 1) GO TO 603
      IF (ISTATE .EQ. 2) GO TO 200
      GO TO 20

 10   INIT = 0
      IF (TOUT .EQ. T) RETURN

C-----------------------------------------------------------------------
C Block B.
C The next code block is executed for the initial call (ISTATE = 1),
C or for a continuation call with parameter changes (ISTATE = 3).

C It contains checking of all input and various initializations.
C
C First check legality of the non-optional input NEQ, ITOL, IOPT,
C MF, ML, and MU.
C-----------------------------------------------------------------------

 20   IF (NEQ .LE. 0) GO TO 604
      IF (ISTATE .EQ. 1) GO TO 25
      IF (NEQ .GT. N) GO TO 605
 25   N = NEQ
      IF (ITOL .LT. 1 .OR. ITOL .GT. 4) GO TO 606
      IF (IOPT .LT. 0 .OR. IOPT .GT. 1) GO TO 607
      JSV = SIGN(1,MF)

      MF = ABS(MF)
      METH = MF/10
      MITER = MF - 10*METH
      IF (METH .LT. 1 .OR. METH .GT. 2) GO TO 608
      IF (MITER .LT. 0 .OR. MITER .GT. 5) GO TO 608
      IF (MITER .LE. 3) GO TO 30
      ML = IWORK(1)
      MU = IWORK(2)
      IF (ML .LT. 0 .OR. ML .GE. N) GO TO 609
      IF (MU .LT. 0 .OR. MU .GE. N) GO TO 610
 30   CONTINUE
C Next process and check the optional input. ---------------------------


      IF (IOPT .EQ. 1) GO TO 40
      MAXORD = MORD(METH)
      MXSTEP = MXSTP0
      MXHNIL = MXHNL0
      IF (ISTATE .EQ. 1) H0 = ZERO
      HMXI = ZERO
      HMIN = ZERO
      GO TO 60
 40   MAXORD = IWORK(5)
      IF (MAXORD .LT. 0) GO TO 611
      IF (MAXORD .EQ. 0) MAXORD = 100
      MAXORD = MIN(MAXORD,MORD(METH))


      MXSTEP = IWORK(6)
      IF (MXSTEP .LT. 0) GO TO 612
      IF (MXSTEP .EQ. 0) MXSTEP = MXSTP0
      MXHNIL = IWORK(7)
      IF (MXHNIL .LT. 0) GO TO 613
      IF (MXHNIL .EQ. 0) MXHNIL = MXHNL0
      IF (ISTATE .NE. 1) GO TO 50
      H0 = RWORK(5)
      IF ((TOUT - T)*H0 .LT. ZERO) GO TO 614
 50   HMAX = RWORK(6)
      IF (HMAX .LT. ZERO) GO TO 615
      HMXI = ZERO
      IF (HMAX .GT. ZERO) HMXI = ONE/HMAX
      HMIN = RWORK(7)
      IF (HMIN .LT. ZERO) GO TO 616
C-----------------------------------------------------------------------
C Set work array pointers and check lengths LRW and LIW.
C Pointers to segments of RWORK and IWORK are named by prefixing L to
C the name of the segment.  E.g., the segment YH starts at RWORK(LYH).
C Segments of RWORK (in order) are denoted  YH, WM, EWT, SAVF, ACOR.
C Within WM, LOCJS is the location of the saved Jacobian (JSV .gt. 0).
C-----------------------------------------------------------------------
 60   LYH = 21
      IF (ISTATE .EQ. 1) NYH = N
      LWM = LYH + (MAXORD + 1)*NYH
      JCO = MAX(0,JSV)
      IF (MITER .EQ. 0) LENWM = 0
      IF (MITER .EQ. 1 .OR. MITER .EQ. 2) THEN
        LENWM = 2 + (1 + JCO)*N*N
        LOCJS = N*N + 3
      ENDIF
      IF (MITER .EQ. 3) LENWM = 2 + N
      IF (MITER .EQ. 4 .OR. MITER .EQ. 5) THEN
        MBAND = ML + MU + 1
        LENP = (MBAND + ML)*N
        LENJ = MBAND*N
        LENWM = 2 + LENP + JCO*LENJ
        LOCJS = LENP + 3
        ENDIF
      LEWT = LWM + LENWM
      LSAVF = LEWT + N
      LACOR = LSAVF + N
      LENRW = LACOR + N - 1
      IWORK(17) = LENRW
      LIWM = 1
      LENIW = 30 + N
      IF (MITER .EQ. 0 .OR. MITER .EQ. 3) LENIW = 30
      IWORK(18) = LENIW
      IF (LENRW .GT. LRW) GO TO 617

      IF (LENIW .GT. LIW) GO TO 618

C Check RTOL and ATOL for legality. ------------------------------------
      RTOLI = RTOL(1)
      ATOLI = ATOL(1)
      DO 70 I = 1,N
        IF (ITOL .GE. 3) RTOLI = RTOL(I)
        IF (ITOL .EQ. 2 .OR. ITOL .EQ. 4) ATOLI = ATOL(I)
        IF (RTOLI .LT. ZERO) GO TO 619
        IF (ATOLI .LT. ZERO) GO TO 620

 70     CONTINUE
      IF (ISTATE .EQ. 1) GO TO 100
C If ISTATE = 3, set flag to signal parameter changes to DVSTEP. -------
      JSTART = -1
      IF (NQ .LE. MAXORD) GO TO 90
C MAXORD was reduced below NQ.  Copy YH(*,MAXORD+2) into SAVF. ---------
      CALL DCOPY (N, RWORK(LWM), 1, RWORK(LSAVF), 1)
C Reload WM(1) = RWORK(LWM), since LWM may have changed. ---------------
 90   IF (MITER .GT. 0) RWORK(LWM) = SQRT(UROUND)
C-----------------------------------------------------------------------
C Block C.
C The next block is for the initial call only (ISTATE = 1).
C It contains all remaining initializations, the initial call to F,
C and the calculation of the initial step size.
C The error weights in EWT are inverted after being loaded.
C-----------------------------------------------------------------------
 100  UROUND = D1MACH(4)
      TN = T
      IF (ITASK .NE. 4 .AND. ITASK .NE. 5) GO TO 110
      TCRIT = RWORK(1)
      IF ((TCRIT - TOUT)*(TOUT - T) .LT. ZERO) GO TO 625
      IF (H0 .NE. ZERO .AND. (T + H0 - TCRIT)*H0 .GT. ZERO)
     1   H0 = TCRIT - T

 110  JSTART = 0
      IF (MITER .GT. 0) RWORK(LWM) = SQRT(UROUND)
      CCMXJ = PT2
      MSBJ = 50
      NHNIL = 0
      NST = 0
      NJE = 0
      NNI = 0
      NCFN = 0
      NETF = 0
      NLU = 0
      NSLJ = 0
      NSLAST = 0
      HU = ZERO
      NQU = 0
C Initial call to F.  (LF0 points to YH(*,2).) -------------------------
      LF0 = LYH + NYH
      CALL F (N, T, Y, RWORK(LF0), RPAR, IPAR)
      NFE = 1
C Load the initial value vector in YH. ---------------------------------
      CALL DCOPY (N, Y, 1, RWORK(LYH), 1)
C Load and invert the EWT array.  (H is temporarily set to 1.0.) -------
      NQ = 1
      H = ONE
      CALL DEWSET (N, ITOL, RTOL, ATOL, RWORK(LYH), RWORK(LEWT))
      DO 120 I = 1,N
        IF (RWORK(I+LEWT-1) .LE. ZERO) GO TO 621
 120    RWORK(I+LEWT-1) = ONE/RWORK(I+LEWT-1)

      IF (H0 .NE. ZERO) GO TO 180
C Call DVHIN to set initial step size H0 to be attempted. --------------
      CALL DVHIN (N, T, RWORK(LYH), RWORK(LF0), F, RPAR, IPAR, TOUT,
     1   UROUND, RWORK(LEWT), ITOL, ATOL, Y, RWORK(LACOR), H0,
     2   NITER, IER)
      NFE = NFE + NITER
      IF (IER .NE. 0) GO TO 622
C Adjust H0 if necessary to meet HMAX bound. ---------------------------
 180  RH = ABS(H0)*HMXI
      IF (RH .GT. ONE) H0 = H0/RH
C Load H with H0 and scale YH(*,2) by H0. ------------------------------
      H = H0
      CALL DSCAL (N, H0, RWORK(LF0), 1)
      GO TO 270
C-----------------------------------------------------------------------
C Block D.

C The next code block is for continuation calls only (ISTATE = 2 or 3)

C and is to check stop conditions before taking a step.
C-----------------------------------------------------------------------

 200  NSLAST = NST
      KUTH = 0
      GO TO (210, 250, 220, 230, 240), ITASK
 210  IF ((TN - TOUT)*H .LT. ZERO) GO TO 250
      CALL DVINDY (TOUT, 0, RWORK(LYH), NYH, Y, IFLAG)
      IF (IFLAG .NE. 0) GO TO 627
      T = TOUT
      GO TO 420
 220  TP = TN - HU*(ONE + HUN*UROUND)
      IF ((TP - TOUT)*H .GT. ZERO) GO TO 623
      IF ((TN - TOUT)*H .LT. ZERO) GO TO 250
      GO TO 400


 230  TCRIT = RWORK(1)
      IF ((TN - TCRIT)*H .GT. ZERO) GO TO 624
      IF ((TCRIT - TOUT)*H .LT. ZERO) GO TO 625
      IF ((TN - TOUT)*H .LT. ZERO) GO TO 245
      CALL DVINDY (TOUT, 0, RWORK(LYH), NYH, Y, IFLAG)

      IF (IFLAG .NE. 0) GO TO 627
      T = TOUT
      GO TO 420
 240  TCRIT = RWORK(1)
      IF ((TN - TCRIT)*H .GT. ZERO) GO TO 624
 245  HMX = ABS(TN) + ABS(H)
      IHIT = ABS(TN - TCRIT) .LE. HUN*UROUND*HMX
      IF (IHIT) GO TO 400
      TNEXT = TN + HNEW*(ONE + FOUR*UROUND)
      IF ((TNEXT - TCRIT)*H .LE. ZERO) GO TO 250
      H = (TCRIT - TN)*(ONE - FOUR*UROUND)
      KUTH = 1
C-----------------------------------------------------------------------
C Block E.
C The next block is normally executed for all calls and contains
C the call to the one-step core integrator DVSTEP.
C
C This is a looping point for the integration steps.
C
C First check for too many steps being taken, update EWT (if not at
C start of problem), check for too much accuracy being requested, and

C check for H below the roundoff level in T.
C-----------------------------------------------------------------------
 250  CONTINUE
      IF ((NST-NSLAST) .GE. MXSTEP) GO TO 500
      CALL DEWSET (N, ITOL, RTOL, ATOL, RWORK(LYH), RWORK(LEWT))

      DO 260 I = 1,N
        IF (RWORK(I+LEWT-1) .LE. ZERO) GO TO 510
 260    RWORK(I+LEWT-1) = ONE/RWORK(I+LEWT-1)
 270  TOLSF = UROUND*DVNORM (N, RWORK(LYH), RWORK(LEWT))
      IF (TOLSF .LE. ONE) GO TO 280
      TOLSF = TOLSF*TWO

      IF (NST .EQ. 0) GO TO 626
      GO TO 520
 280  IF ((TN + H) .NE. TN) GO TO 290
      NHNIL = NHNIL + 1
      IF (NHNIL .GT. MXHNIL) GO TO 290
      MSG = 'DVODE--  Warning..internal T (=R1) and H (=R2) are'
      CALL XERRWD (MSG, 50, 101, 1, 0, 0, 0, 0, ZERO, ZERO)
      MSG='      such that in the machine, T + H = T on the next step  '
      CALL XERRWD (MSG, 60, 101, 1, 0, 0, 0, 0, ZERO, ZERO)
      MSG = '      (H = step size). solver will continue anyway'
      CALL XERRWD (MSG, 50, 101, 1, 0, 0, 0, 2, TN, H)
      IF (NHNIL .LT. MXHNIL) GO TO 290
      MSG = 'DVODE--  Above warning has been issued I1 times.  '
      CALL XERRWD (MSG, 50, 102, 1, 0, 0, 0, 0, ZERO, ZERO)
      MSG = '      it will not be issued again for this problem'
      CALL XERRWD (MSG, 50, 102, 1, 1, MXHNIL, 0, 0, ZERO, ZERO)
 290  CONTINUE
C-----------------------------------------------------------------------
C CALL DVSTEP (Y, YH, NYH, YH, EWT, SAVF, VSAV, ACOR,
C              WM, IWM, F, JAC, F, DVNLSD, RPAR, IPAR)
C-----------------------------------------------------------------------
      CALL DVSTEP (Y, RWORK(LYH), NYH, RWORK(LYH), RWORK(LEWT),
     1   RWORK(LSAVF), Y, RWORK(LACOR), RWORK(LWM), IWORK(LIWM),
     2   F, JAC, F, DVNLSD, RPAR, IPAR)
      KGO = 1 - KFLAG
C Branch on KFLAG.  Note..In this version, KFLAG can not be set to -3.
C  KFLAG .eq. 0,   -1,  -2

      GO TO (300, 530, 540), KGO
C-----------------------------------------------------------------------
C Block F.
C The following block handles the case of a successful return from the
C core integrator (KFLAG = 0).  Test for stop conditions.
C-----------------------------------------------------------------------
 300  INIT = 1
      KUTH = 0
      GO TO (310, 400, 330, 340, 350), ITASK
C ITASK = 1.  If TOUT has been reached, interpolate. -------------------
 310  IF ((TN - TOUT)*H .LT. ZERO) GO TO 250
      CALL DVINDY (TOUT, 0, RWORK(LYH), NYH, Y, IFLAG)
      T = TOUT
      GO TO 420
C ITASK = 3.  Jump to exit if TOUT was reached. ------------------------
 330  IF ((TN - TOUT)*H .GE. ZERO) GO TO 400
      GO TO 250
C ITASK = 4.  See if TOUT or TCRIT was reached.  Adjust H if necessary.
 340  IF ((TN - TOUT)*H .LT. ZERO) GO TO 345
      CALL DVINDY (TOUT, 0, RWORK(LYH), NYH, Y, IFLAG)
      T = TOUT
      GO TO 420
 345  HMX = ABS(TN) + ABS(H)
      IHIT = ABS(TN - TCRIT) .LE. HUN*UROUND*HMX
      IF (IHIT) GO TO 400
      TNEXT = TN + HNEW*(ONE + FOUR*UROUND)
      IF ((TNEXT - TCRIT)*H .LE. ZERO) GO TO 250
      H = (TCRIT - TN)*(ONE - FOUR*UROUND)
      KUTH = 1
      GO TO 250
C ITASK = 5.  See if TCRIT was reached and jump to exit. ---------------
 350  HMX = ABS(TN) + ABS(H)
      IHIT = ABS(TN - TCRIT) .LE. HUN*UROUND*HMX
C-----------------------------------------------------------------------
C Block G.
C The following block handles all successful returns from DVODE.
C If ITASK .ne. 1, Y is loaded from YH and T is set accordingly.
C ISTATE is set to 2, and the optional output is loaded into the work
C arrays before returning.

C-----------------------------------------------------------------------
 400  CONTINUE
      CALL DCOPY (N, RWORK(LYH), 1, Y, 1)
      T = TN
      IF (ITASK .NE. 4 .AND. ITASK .NE. 5) GO TO 420
      IF (IHIT) T = TCRIT
 420  ISTATE = 2

      RWORK(11) = HU
      RWORK(12) = HNEW
      RWORK(13) = TN
      IWORK(11) = NST
      IWORK(12) = NFE
      IWORK(13) = NJE

      IWORK(14) = NQU
      IWORK(15) = NEWQ
      IWORK(19) = NLU

      IWORK(20) = NNI
      IWORK(21) = NCFN

      IWORK(22) = NETF
      RETURN
C-----------------------------------------------------------------------
C Block H.
C The following block handles all unsuccessful returns other than
C those for illegal input.  First the error message routine is called.
C if there was an error test or convergence test failure, IMXER is set.
C Then Y is loaded from YH, T is set to TN, and the illegal input
C The optional output is loaded into the work arrays before returning.
C-----------------------------------------------------------------------
C The maximum number of steps was taken before reaching TOUT. ----------
 500  MSG = 'DVODE--  At current T (=R1), MXSTEP (=I1) steps   '
      CALL XERRWD (MSG, 50, 201, 1, 0, 0, 0, 0, ZERO, ZERO)
      MSG = '      taken on this call before reaching TOUT     '
      CALL XERRWD (MSG, 50, 201, 1, 1, MXSTEP, 0, 1, TN, ZERO)
      ISTATE = -1
      GO TO 580
C EWT(i) .le. 0.0 for some i (not at start of problem). ----------------
 510  EWTI = RWORK(LEWT+I-1)
      MSG = 'DVODE--  At T (=R1), EWT(I1) has become R2 .le. 0.'
      CALL XERRWD (MSG, 50, 202, 1, 1, I, 0, 2, TN, EWTI)
      ISTATE = -6
      GO TO 580
C Too much accuracy requested for machine precision. -------------------
 520  MSG = 'DVODE--  At T (=R1), too much accuracy requested  '

      CALL XERRWD (MSG, 50, 203, 1, 0, 0, 0, 0, ZERO, ZERO)
      MSG = '      for precision of machine..  see TOLSF (=R2) '
      CALL XERRWD (MSG, 50, 203, 1, 0, 0, 0, 2, TN, TOLSF)

      RWORK(14) = TOLSF
      ISTATE = -2


      GO TO 580
C KFLAG = -1.  Error test failed repeatedly or with ABS(H) = HMIN. -----
 530  MSG = 'DVODE--  At T(=R1) and step size H(=R2), the error'
      CALL XERRWD (MSG, 50, 204, 1, 0, 0, 0, 0, ZERO, ZERO)
      MSG = '      test failed repeatedly or with abs(H) = HMIN'
      CALL XERRWD (MSG, 50, 204, 1, 0, 0, 0, 2, TN, H)
      ISTATE = -4
      GO TO 560
C KFLAG = -2.  Convergence failed repeatedly or with abs(H) = HMIN. ----
 540  MSG = 'DVODE--  At T (=R1) and step size H (=R2), the    '
      CALL XERRWD (MSG, 50, 205, 1, 0, 0, 0, 0, ZERO, ZERO)
      MSG = '      corrector convergence failed repeatedly     '
      CALL XERRWD (MSG, 50, 205, 1, 0, 0, 0, 0, ZERO, ZERO)
      MSG = '      or with abs(H) = HMIN   '

      CALL XERRWD (MSG, 30, 205, 1, 0, 0, 0, 2, TN, H)
      ISTATE = -5
C Compute IMXER if relevant. -------------------------------------------
 560  BIG = ZERO
      IMXER = 1
      DO 570 I = 1,N
        SIZE = ABS(RWORK(I+LACOR-1)*RWORK(I+LEWT-1))
        IF (BIG .GE. SIZE) GO TO 570
        BIG = SIZE
        IMXER = I
 570    CONTINUE
      IWORK(16) = IMXER
C Set Y vector, T, and optional output. --------------------------------
 580  CONTINUE
      CALL DCOPY (N, RWORK(LYH), 1, Y, 1)
      T = TN
      RWORK(11) = HU

      RWORK(12) = H
      RWORK(13) = TN
      IWORK(11) = NST
      IWORK(12) = NFE
      IWORK(13) = NJE
      IWORK(14) = NQU
      IWORK(15) = NQ

      IWORK(19) = NLU
      IWORK(20) = NNI
      IWORK(21) = NCFN
      IWORK(22) = NETF
      RETURN
C-----------------------------------------------------------------------
C Block I.
C The following block handles all error returns due to illegal input
C (ISTATE = -3), as detected before calling the core integrator.
C First the error message routine is called.   If the illegal input

C is a negative ISTATE, the run is aborted (apparent infinite loop).
C-----------------------------------------------------------------------
 601  MSG = 'DVODE--  ISTATE (=I1) illegal '
      CALL XERRWD (MSG, 30, 1, 1, 1, ISTATE, 0, 0, ZERO, ZERO)
      IF (ISTATE .LT. 0) GO TO 800
      GO TO 700
 602  MSG = 'DVODE--  ITASK (=I1) illegal  '
      CALL XERRWD (MSG, 30, 2, 1, 1, ITASK, 0, 0, ZERO, ZERO)
      GO TO 700
 603  MSG='DVODE--  ISTATE (=I1) .gt. 1 but DVODE not initialized      '
      CALL XERRWD (MSG, 60, 3, 1, 1, ISTATE, 0, 0, ZERO, ZERO)
      GO TO 700
 604  MSG = 'DVODE--  NEQ (=I1) .lt. 1     '
      CALL XERRWD (MSG, 30, 4, 1, 1, NEQ, 0, 0, ZERO, ZERO)
      GO TO 700
 605  MSG = 'DVODE--  ISTATE = 3 and NEQ increased (I1 to I2)  '
      CALL XERRWD (MSG, 50, 5, 1, 2, N, NEQ, 0, ZERO, ZERO)
      GO TO 700
 606  MSG = 'DVODE--  ITOL (=I1) illegal   '
      CALL XERRWD (MSG, 30, 6, 1, 1, ITOL, 0, 0, ZERO, ZERO)
      GO TO 700
 607  MSG = 'DVODE--  IOPT (=I1) illegal   '
      CALL XERRWD (MSG, 30, 7, 1, 1, IOPT, 0, 0, ZERO, ZERO)
      GO TO 700
 608  MSG = 'DVODE--  MF (=I1) illegal     '


      CALL XERRWD (MSG, 30, 8, 1, 1, MF, 0, 0, ZERO, ZERO)
      GO TO 700
 609  MSG = 'DVODE--  ML (=I1) illegal.. .lt.0 or .ge.NEQ (=I2)'
      CALL XERRWD (MSG, 50, 9, 1, 2, ML, NEQ, 0, ZERO, ZERO)
      GO TO 700
 610  MSG = 'DVODE--  MU (=I1) illegal.. .lt.0 or .ge.NEQ (=I2)'
      CALL XERRWD (MSG, 50, 10, 1, 2, MU, NEQ, 0, ZERO, ZERO)
      GO TO 700
 611  MSG = 'DVODE--  MAXORD (=I1) .lt. 0  '
      CALL XERRWD (MSG, 30, 11, 1, 1, MAXORD, 0, 0, ZERO, ZERO)

      GO TO 700
 612  MSG = 'DVODE--  MXSTEP (=I1) .lt. 0  '
      CALL XERRWD (MSG, 30, 12, 1, 1, MXSTEP, 0, 0, ZERO, ZERO)
      GO TO 700
 613  MSG = 'DVODE--  MXHNIL (=I1) .lt. 0  '
      CALL XERRWD (MSG, 30, 13, 1, 1, MXHNIL, 0, 0, ZERO, ZERO)

      GO TO 700
 614  MSG = 'DVODE--  TOUT (=R1) behind T (=R2)      '
      CALL XERRWD (MSG, 40, 14, 1, 0, 0, 0, 2, TOUT, T)
      MSG = '      integration direction is given by H0 (=R1)  '
      CALL XERRWD (MSG, 50, 14, 1, 0, 0, 0, 1, H0, ZERO)
      GO TO 700

 615  MSG = 'DVODE--  HMAX (=R1) .lt. 0.0  '

      CALL XERRWD (MSG, 30, 15, 1, 0, 0, 0, 1, HMAX, ZERO)
      GO TO 700
 616  MSG = 'DVODE--  HMIN (=R1) .lt. 0.0  '
      CALL XERRWD (MSG, 30, 16, 1, 0, 0, 0, 1, HMIN, ZERO)
      GO TO 700
 617  CONTINUE
      MSG='DVODE--  RWORK length needed, LENRW (=I1), exceeds LRW (=I2)'
      CALL XERRWD (MSG, 60, 17, 1, 2, LENRW, LRW, 0, ZERO, ZERO)
      GO TO 700
 618  CONTINUE
      MSG='DVODE--  IWORK length needed, LENIW (=I1), exceeds LIW (=I2)'
      CALL XERRWD (MSG, 60, 18, 1, 2, LENIW, LIW, 0, ZERO, ZERO)
      GO TO 700
 619  MSG = 'DVODE--  RTOL(I1) is R1 .lt. 0.0        '
      CALL XERRWD (MSG, 40, 19, 1, 1, I, 0, 1, RTOLI, ZERO)
      GO TO 700
 620  MSG = 'DVODE--  ATOL(I1) is R1 .lt. 0.0        '
      CALL XERRWD (MSG, 40, 20, 1, 1, I, 0, 1, ATOLI, ZERO)
      GO TO 700
 621  EWTI = RWORK(LEWT+I-1)
      MSG = 'DVODE--  EWT(I1) is R1 .le. 0.0         '
      CALL XERRWD (MSG, 40, 21, 1, 1, I, 0, 1, EWTI, ZERO)
      GO TO 700

 622  CONTINUE
      MSG='DVODE--  TOUT (=R1) too close to T(=R2) to start integration'
      CALL XERRWD (MSG, 60, 22, 1, 0, 0, 0, 2, TOUT, T)
      GO TO 700
 623  CONTINUE
      MSG='DVODE--  ITASK = I1 and TOUT (=R1) behind TCUR - HU (= R2)  '
      CALL XERRWD (MSG, 60, 23, 1, 1, ITASK, 0, 2, TOUT, TP)
      GO TO 700
 624  CONTINUE
      MSG='DVODE--  ITASK = 4 or 5 and TCRIT (=R1) behind TCUR (=R2)   '
      CALL XERRWD (MSG, 60, 24, 1, 0, 0, 0, 2, TCRIT, TN)
      GO TO 700
 625  CONTINUE
      MSG='DVODE--  ITASK = 4 or 5 and TCRIT (=R1) behind TOUT (=R2)   '
      CALL XERRWD (MSG, 60, 25, 1, 0, 0, 0, 2, TCRIT, TOUT)
      GO TO 700
 626  MSG = 'DVODE--  At start of problem, too much accuracy   '
      CALL XERRWD (MSG, 50, 26, 1, 0, 0, 0, 0, ZERO, ZERO)

      MSG='      requested for precision of machine..  see TOLSF (=R1) '

      CALL XERRWD (MSG, 60, 26, 1, 0, 0, 0, 1, TOLSF, ZERO)
      RWORK(14) = TOLSF
      GO TO 700
 627  MSG='DVODE--  Trouble from DVINDY.  ITASK = I1, TOUT = R1.       '
      CALL XERRWD (MSG, 60, 27, 1, 1, ITASK, 0, 1, TOUT, ZERO)

C
 700  CONTINUE
      ISTATE = -3
      RETURN
C

 800  MSG = 'DVODE--  Run aborted.. apparent infinite loop     '
      CALL XERRWD (MSG, 50, 303, 2, 0, 0, 0, 0, ZERO, ZERO)
      RETURN
C----------------------- End of Subroutine DVODE -----------------------
      END
*DECK DVHIN
      SUBROUTINE DVHIN (N, T0, Y0, YDOT, F, RPAR, IPAR, TOUT, UROUND,
     1   EWT, ITOL, ATOL, Y, TEMP, H0, NITER, IER)


      EXTERNAL F


      DOUBLE PRECISION T0, Y0, YDOT, RPAR, TOUT, UROUND, EWT, ATOL, Y,
     1   TEMP, H0
      INTEGER N, IPAR, ITOL, NITER, IER

      DIMENSION Y0(*), YDOT(*), EWT(*), ATOL(*), Y(*),
     1   TEMP(*), RPAR(*), IPAR(*)
C-----------------------------------------------------------------------
C Call sequence input -- N, T0, Y0, YDOT, F, RPAR, IPAR, TOUT, UROUND,
C                        EWT, ITOL, ATOL, Y, TEMP
C Call sequence output -- H0, NITER, IER
C COMMON block variables accessed -- None
C
C Subroutines called by DVHIN.. F
C Function routines called by DVHIN.. DVNORM
C-----------------------------------------------------------------------
C This routine computes the step size, H0, to be attempted on the
C first step, when the user has not supplied a value for this.

C
C First we check that TOUT - T0 differs significantly from zero.  Then
C an iteration is done to approximate the initial second derivative
C and this is used to define h from w.r.m.s.norm(h**2 * yddot / 2) = 1.
C A bias factor of 1/2 is applied to the resulting h.
C The sign of H0 is inferred from the initial values of TOUT and T0.
C
C Communication with DVHIN is done with the following variables..
C
C N      = Size of ODE system, input.
C T0     = Initial value of independent variable, input.

C Y0     = Vector of initial conditions, input.
C YDOT   = Vector of initial first derivatives, input.
C F      = Name of subroutine for right-hand side f(t,y), input.
C RPAR, IPAR = Dummy names for user's real and integer work arrays.
C TOUT   = First output value of independent variable
C UROUND = Machine unit roundoff
C EWT, ITOL, ATOL = Error weights and tolerance parameters

C                   as described in the driver routine, input.
C Y, TEMP = Work arrays of length N.


C H0     = Step size to be attempted, output.
C NITER  = Number of iterations (and of f evaluations) to compute H0,
C          output.
C IER    = The error flag, returned with the value
C          IER = 0  if no trouble occurred, or

C          IER = -1 if TOUT and T0 are considered too close to proceed.
C-----------------------------------------------------------------------

C
C Type declarations for local variables --------------------------------
C
      DOUBLE PRECISION AFI, ATOLI, DELYI, HALF, HG, HLB, HNEW, HRAT,

     1     HUB, HUN, PT1, T1, TDIST, TROUND, TWO, YDDNRM
      INTEGER I, ITER
C
C Type declaration for function subroutines called ---------------------
C
      DOUBLE PRECISION DVNORM
C-----------------------------------------------------------------------
C The following Fortran-77 declaration is to cause the values of the
C listed (local) variables to be saved between calls to this integrator.
C-----------------------------------------------------------------------
      SAVE HALF, HUN, PT1, TWO
      DATA HALF /0.5D0/, HUN /100.0D0/, PT1 /0.1D0/, TWO /2.0D0/
C

      NITER = 0
      TDIST = ABS(TOUT - T0)
      TROUND = UROUND*MAX(ABS(T0),ABS(TOUT))

      IF (TDIST .LT. TWO*TROUND) GO TO 100
C
C Set a lower bound on h based on the roundoff level in T0 and TOUT. ---
      HLB = HUN*TROUND
C Set an upper bound on h based on TOUT-T0 and the initial Y and YDOT. -
      HUB = PT1*TDIST
      ATOLI = ATOL(1)
      DO 10 I = 1, N
        IF (ITOL .EQ. 2 .OR. ITOL .EQ. 4) ATOLI = ATOL(I)
        DELYI = PT1*ABS(Y0(I)) + ATOLI
        AFI = ABS(YDOT(I))
        IF (AFI*HUB .GT. DELYI) HUB = DELYI/AFI
 10     CONTINUE
C
C Set initial guess for h as geometric mean of upper and lower bounds. -

      ITER = 0
      HG = SQRT(HLB*HUB)

C If the bounds have crossed, exit with the mean value. ----------------
      IF (HUB .LT. HLB) THEN
        H0 = HG

        GO TO 90
      ENDIF
C
C Looping point for iteration. -----------------------------------------
 50   CONTINUE
C Estimate the second derivative as a difference quotient in f. --------
      T1 = T0 + HG
      DO 60 I = 1, N
 60     Y(I) = Y0(I) + HG*YDOT(I)
      CALL F (N, T1, Y, TEMP, RPAR, IPAR)
      DO 70 I = 1, N
 70     TEMP(I) = (TEMP(I) - YDOT(I))/HG
      YDDNRM = DVNORM (N, TEMP, EWT)
C Get the corresponding new value of h. --------------------------------
      IF (YDDNRM*HUB*HUB .GT. TWO) THEN
        HNEW = SQRT(TWO/YDDNRM)
      ELSE
        HNEW = SQRT(HG*HUB)
      ENDIF
      ITER = ITER + 1
C-----------------------------------------------------------------------
C Test the stopping conditions.
C Stop if the new and previous h values differ by a factor of .lt. 2.
C Stop if four iterations have been done.  Also, stop with previous h
C if HNEW/HG .gt. 2 after first iteration, as this probably means that
C the second derivative value is bad because of cancellation error.
C-----------------------------------------------------------------------
      IF (ITER .GE. 4) GO TO 80
      HRAT = HNEW/HG
      IF ( (HRAT .GT. HALF) .AND. (HRAT .LT. TWO) ) GO TO 80
      IF ( (ITER .GE. 2) .AND. (HNEW .GT. TWO*HG) ) THEN
        HNEW = HG
        GO TO 80

      ENDIF
      HG = HNEW
      GO TO 50
C
C Iteration done.  Apply bounds, bias factor, and sign.  Then exit. ----
 80   H0 = HNEW*HALF

      IF (H0 .LT. HLB) H0 = HLB
      IF (H0 .GT. HUB) H0 = HUB
 90   H0 = SIGN(H0, TOUT - T0)
      NITER = ITER
      IER = 0
      RETURN
C Error return for TOUT - T0 too small. --------------------------------
 100  IER = -1
      RETURN
C----------------------- End of Subroutine DVHIN -----------------------
      END

*DECK DVINDY
      SUBROUTINE DVINDY (T, K, YH, LDYH, DKY, IFLAG)
      DOUBLE PRECISION T, YH, DKY
      INTEGER K, LDYH, IFLAG
      DIMENSION YH(LDYH,*), DKY(*)
C-----------------------------------------------------------------------
C Call sequence input -- T, K, YH, LDYH
C Call sequence output -- DKY, IFLAG
C COMMON block variables accessed..
C     /DVOD01/ --  H, TN, UROUND, L, N, NQ
C     /DVOD02/ --  HU
C
C Subroutines called by DVINDY.. DSCAL, XERRWD
C Function routines called by DVINDY.. None
C-----------------------------------------------------------------------
C DVINDY computes interpolated values of the K-th derivative of the

C dependent variable vector y, and stores it in DKY.  This routine
C is called within the package with K = 0 and T = TOUT, but may
C also be called by the user for any K up to the current order.
C (See detailed instructions in the usage documentation.)
C-----------------------------------------------------------------------
C The computed values in DKY are gotten by interpolation using the
C Nordsieck history array YH.  This array corresponds uniquely to a
C vector-valued polynomial of degree NQCUR or less, and DKY is set
C to the K-th derivative of this polynomial at T.
C The formula for DKY is..
C              q
C  DKY(i)  =  sum  c(j,K) * (T - TN)**(j-K) * H**(-j) * YH(i,j+1)
C             j=K
C where  c(j,K) = j*(j-1)*...*(j-K+1), q = NQCUR, TN = TCUR, H = HCUR.
C The quantities  NQ = NQCUR, L = NQ+1, N, TN, and H are
C communicated by COMMON.  The above sum is done in reverse order.
C IFLAG is returned negative if either K or T is out of bounds.

C

C Discussion above and comments in driver explain all variables.
C-----------------------------------------------------------------------

C
C Type declarations for labeled COMMON block DVOD01 --------------------
C
      DOUBLE PRECISION ACNRM, CCMXJ, CONP, CRATE, DRC, EL,
     1     ETA, ETAMAX, H, HMIN, HMXI, HNEW, HSCAL, PRL1,
     2     RC, RL1, TAU, TQ, TN, UROUND
      INTEGER ICF, INIT, IPUP, JCUR, JSTART, JSV, KFLAG, KUTH,
     1        L, LMAX, LYH, LEWT, LACOR, LSAVF, LWM, LIWM,
     2        LOCJS, MAXORD, METH, MITER, MSBJ, MXHNIL, MXSTEP,
     3        N, NEWH, NEWQ, NHNIL, NQ, NQNYH, NQWAIT, NSLJ,
     4        NSLP, NYH
C
C Type declarations for labeled COMMON block DVOD02 --------------------
C
      DOUBLE PRECISION HU


      INTEGER NCFN, NETF, NFE, NJE, NLU, NNI, NQU, NST
C
C Type declarations for local variables --------------------------------
C
      DOUBLE PRECISION C, HUN, R, S, TFUZZ, TN1, TP, ZERO
      INTEGER I, IC, J, JB, JB2, JJ, JJ1, JP1
      CHARACTER*80 MSG
C-----------------------------------------------------------------------
C The following Fortran-77 declaration is to cause the values of the
C listed (local) variables to be saved between calls to this integrator.
C-----------------------------------------------------------------------
      SAVE HUN, ZERO
C
      COMMON /DVOD01/ ACNRM, CCMXJ, CONP, CRATE, DRC, EL(13),
     1                ETA, ETAMAX, H, HMIN, HMXI, HNEW, HSCAL, PRL1,

     2                RC, RL1, TAU(13), TQ(5), TN, UROUND,
     3                ICF, INIT, IPUP, JCUR, JSTART, JSV, KFLAG, KUTH,
     4                L, LMAX, LYH, LEWT, LACOR, LSAVF, LWM, LIWM,
     5                LOCJS, MAXORD, METH, MITER, MSBJ, MXHNIL, MXSTEP,
     6                N, NEWH, NEWQ, NHNIL, NQ, NQNYH, NQWAIT, NSLJ,
     7                NSLP, NYH
      COMMON /DVOD02/ HU, NCFN, NETF, NFE, NJE, NLU, NNI, NQU, NST
C
      DATA HUN /100.0D0/, ZERO /0.0D0/
C
      IFLAG = 0
      IF (K .LT. 0 .OR. K .GT. NQ) GO TO 80
      TFUZZ = HUN*UROUND*(TN + HU)
      TP = TN - HU - TFUZZ
      TN1 = TN + TFUZZ
      IF ((T-TP)*(T-TN1) .GT. ZERO) GO TO 90
C
      S = (T - TN)/H
      IC = 1
      IF (K .EQ. 0) GO TO 15
      JJ1 = L - K
      DO 10 JJ = JJ1, NQ
 10     IC = IC*JJ

 15   C = REAL(IC)
      DO 20 I = 1, N
 20     DKY(I) = C*YH(I,L)
      IF (K .EQ. NQ) GO TO 55
      JB2 = NQ - K
      DO 50 JB = 1, JB2
        J = NQ - JB
        JP1 = J + 1
        IC = 1
        IF (K .EQ. 0) GO TO 35
        JJ1 = JP1 - K
        DO 30 JJ = JJ1, J
 30       IC = IC*JJ
 35     C = REAL(IC)
        DO 40 I = 1, N
 40       DKY(I) = C*YH(I,JP1) + S*DKY(I)
 50     CONTINUE
      IF (K .EQ. 0) RETURN
 55   R = H**(-K)
      CALL DSCAL (N, R, DKY, 1)
      RETURN
C

 80   MSG = 'DVINDY-- K (=I1) illegal      '
      CALL XERRWD (MSG, 30, 51, 1, 1, K, 0, 0, ZERO, ZERO)

      IFLAG = -1
      RETURN
 90   MSG = 'DVINDY-- T (=R1) illegal      '
      CALL XERRWD (MSG, 30, 52, 1, 0, 0, 0, 1, T, ZERO)
      MSG='      T not in interval TCUR - HU (= R1) to TCUR (=R2)      '
      CALL XERRWD (MSG, 60, 52, 1, 0, 0, 0, 2, TP, TN)
      IFLAG = -2
      RETURN
C----------------------- End of Subroutine DVINDY ----------------------

      END
*DECK DVSTEP
      SUBROUTINE DVSTEP (Y, YH, LDYH, YH1, EWT, SAVF, VSAV, ACOR,
     1                  WM, IWM, F, JAC, PSOL, VNLS, RPAR, IPAR)
      EXTERNAL F, JAC, PSOL, VNLS
      DOUBLE PRECISION Y, YH, YH1, EWT, SAVF, VSAV, ACOR, WM, RPAR
      INTEGER LDYH, IWM, IPAR
      DIMENSION Y(*), YH(LDYH,*), YH1(*), EWT(*), SAVF(*), VSAV(*),
     1   ACOR(*), WM(*), IWM(*), RPAR(*), IPAR(*)
C-----------------------------------------------------------------------
C Call sequence input -- Y, YH, LDYH, YH1, EWT, SAVF, VSAV,
C                        ACOR, WM, IWM, F, JAC, PSOL, VNLS, RPAR, IPAR
C Call sequence output -- YH, ACOR, WM, IWM
C COMMON block variables accessed..
C     /DVOD01/  ACNRM, EL(13), H, HMIN, HMXI, HNEW, HSCAL, RC, TAU(13),
C               TQ(5), TN, JCUR, JSTART, KFLAG, KUTH,

C               L, LMAX, MAXORD, MITER, N, NEWQ, NQ, NQWAIT

C     /DVOD02/  HU, NCFN, NETF, NFE, NQU, NST
C
C Subroutines called by DVSTEP.. F, DAXPY, DCOPY, DSCAL,
C                               DVJUST, VNLS, DVSET
C Function routines called by DVSTEP.. DVNORM
C-----------------------------------------------------------------------
C DVSTEP performs one step of the integration of an initial value
C problem for a system of ordinary differential equations.

C DVSTEP calls subroutine VNLS for the solution of the nonlinear system
C arising in the time step.  Thus it is independent of the problem
C Jacobian structure and the type of nonlinear system solution method.
C DVSTEP returns a completion flag KFLAG (in COMMON).

C A return with KFLAG = -1 or -2 means either ABS(H) = HMIN or 10
C consecutive failures occurred.  On a return with KFLAG negative,
C the values of TN and the YH array are as of the beginning of the last
C step, and H is the last step size attempted.

C
C Communication with DVSTEP is done with the following variables..

C
C Y      = An array of length N used for the dependent variable vector.

C YH     = An LDYH by LMAX array containing the dependent variables
C          and their approximate scaled derivatives, where
C          LMAX = MAXORD + 1.  YH(i,j+1) contains the approximate
C          j-th derivative of y(i), scaled by H**j/factorial(j)
C          (j = 0,1,...,NQ).  On entry for the first step, the first
C          two columns of YH must be set from the initial values.
C LDYH   = A constant integer .ge. N, the first dimension of YH.
C          N is the number of ODEs in the system.
C YH1    = A one-dimensional array occupying the same space as YH.
C EWT    = An array of length N containing multiplicative weights
C          for local error measurements.  Local errors in y(i) are
C          compared to 1.0/EWT(i) in various error tests.
C SAVF   = An array of working storage, of length N.
C          also used for input of YH(*,MAXORD+2) when JSTART = -1
C          and MAXORD .lt. the current order NQ.
C VSAV   = A work array of length N passed to subroutine VNLS.
C ACOR   = A work array of length N, used for the accumulated
C          corrections.  On a successful return, ACOR(i) contains
C          the estimated one-step local error in y(i).
C WM,IWM = Real and integer work arrays associated with matrix
C          operations in VNLS.
C F      = Dummy name for the user supplied subroutine for f.
C JAC    = Dummy name for the user supplied Jacobian subroutine.
C PSOL   = Dummy name for the subroutine passed to VNLS, for
C          possible use there.
C VNLS   = Dummy name for the nonlinear system solving subroutine,
C          whose real name is dependent on the method used.
C RPAR, IPAR = Dummy names for user's real and integer work arrays.
C-----------------------------------------------------------------------
C

C Type declarations for labeled COMMON block DVOD01 --------------------
C
      DOUBLE PRECISION ACNRM, CCMXJ, CONP, CRATE, DRC, EL,
     1     ETA, ETAMAX, H, HMIN, HMXI, HNEW, HSCAL, PRL1,
     2     RC, RL1, TAU, TQ, TN, UROUND
      INTEGER ICF, INIT, IPUP, JCUR, JSTART, JSV, KFLAG, KUTH,
     1        L, LMAX, LYH, LEWT, LACOR, LSAVF, LWM, LIWM,

     2        LOCJS, MAXORD, METH, MITER, MSBJ, MXHNIL, MXSTEP,
     3        N, NEWH, NEWQ, NHNIL, NQ, NQNYH, NQWAIT, NSLJ,
     4        NSLP, NYH
C
C Type declarations for labeled COMMON block DVOD02 --------------------
C
      DOUBLE PRECISION HU
      INTEGER NCFN, NETF, NFE, NJE, NLU, NNI, NQU, NST
C
C Type declarations for local variables --------------------------------
C
      DOUBLE PRECISION ADDON, BIAS1,BIAS2,BIAS3, CNQUOT, DDN, DSM, DUP,
     1     ETACF, ETAMIN, ETAMX1, ETAMX2, ETAMX3, ETAMXF,
     2     ETAQ, ETAQM1, ETAQP1, FLOTL, ONE, ONEPSM,

     3     R, THRESH, TOLD, ZERO
      INTEGER I, I1, I2, IBACK, J, JB, KFC, KFH, MXNCF, NCF, NFLAG
C
C Type declaration for function subroutines called ---------------------
C
      DOUBLE PRECISION DVNORM
C-----------------------------------------------------------------------
C The following Fortran-77 declaration is to cause the values of the
C listed (local) variables to be saved between calls to this integrator.
C-----------------------------------------------------------------------
      SAVE ADDON, BIAS1, BIAS2, BIAS3,
     1     ETACF, ETAMIN, ETAMX1, ETAMX2, ETAMX3, ETAMXF,
     2     KFC, KFH, MXNCF, ONEPSM, THRESH, ONE, ZERO
C-----------------------------------------------------------------------
      COMMON /DVOD01/ ACNRM, CCMXJ, CONP, CRATE, DRC, EL(13),
     1                ETA, ETAMAX, H, HMIN, HMXI, HNEW, HSCAL, PRL1,
     2                RC, RL1, TAU(13), TQ(5), TN, UROUND,
     3                ICF, INIT, IPUP, JCUR, JSTART, JSV, KFLAG, KUTH,

     4                L, LMAX, LYH, LEWT, LACOR, LSAVF, LWM, LIWM,
     5                LOCJS, MAXORD, METH, MITER, MSBJ, MXHNIL, MXSTEP,
     6                N, NEWH, NEWQ, NHNIL, NQ, NQNYH, NQWAIT, NSLJ,
     7                NSLP, NYH
      COMMON /DVOD02/ HU, NCFN, NETF, NFE, NJE, NLU, NNI, NQU, NST
C
      DATA KFC/-3/, KFH/-7/, MXNCF/10/
      DATA ADDON  /1.0D-6/,    BIAS1  /6.0D0/,     BIAS2  /6.0D0/,
     1     BIAS3  /10.0D0/,    ETACF  /0.25D0/,    ETAMIN /0.1D0/,

     2     ETAMXF /0.2D0/,     ETAMX1 /1.0D4/,     ETAMX2 /10.0D0/,
     3     ETAMX3 /10.0D0/,    ONEPSM /1.00001D0/, THRESH /1.5D0/
      DATA ONE/1.0D0/, ZERO/0.0D0/
C
      KFLAG = 0
      TOLD = TN
      NCF = 0
      JCUR = 0
      NFLAG = 0
      IF (JSTART .GT. 0) GO TO 20
      IF (JSTART .EQ. -1) GO TO 100

C-----------------------------------------------------------------------

C On the first call, the order is set to 1, and other variables are
C initialized.  ETAMAX is the maximum ratio by which H can be increased
C in a single step.  It is normally 1.5, but is larger during the
C first 10 steps to compensate for the small initial H.  If a failure
C occurs (in corrector convergence or error test), ETAMAX is set to 1
C for the next increase.
C-----------------------------------------------------------------------
      LMAX = MAXORD + 1
      NQ = 1
      L = 2
      NQNYH = NQ*LDYH
      TAU(1) = H
      PRL1 = ONE
      RC = ZERO
      ETAMAX = ETAMX1
      NQWAIT = 2
      HSCAL = H
      GO TO 200
C-----------------------------------------------------------------------
C Take preliminary actions on a normal continuation step (JSTART.GT.0).

C If the driver changed H, then ETA must be reset and NEWH set to 1.
C If a change of order was dictated on the previous step, then
C it is done here and appropriate adjustments in the history are made.
C On an order decrease, the history array is adjusted by DVJUST.
C On an order increase, the history array is augmented by a column.
C On a change of step size H, the history array YH is rescaled.
C-----------------------------------------------------------------------
 20   CONTINUE
      IF (KUTH .EQ. 1) THEN
        ETA = MIN(ETA,H/HSCAL)
        NEWH = 1
        ENDIF
 50   IF (NEWH .EQ. 0) GO TO 200
      IF (NEWQ .EQ. NQ) GO TO 150

      IF (NEWQ .LT. NQ) THEN
        CALL DVJUST (YH, LDYH, -1)
        NQ = NEWQ
        L = NQ + 1
        NQWAIT = L
        GO TO 150

        ENDIF
      IF (NEWQ .GT. NQ) THEN
        CALL DVJUST (YH, LDYH, 1)
        NQ = NEWQ
        L = NQ + 1
        NQWAIT = L
        GO TO 150
      ENDIF
C-----------------------------------------------------------------------

C The following block handles preliminaries needed when JSTART = -1.
C If N was reduced, zero out part of YH to avoid undefined references.

C If MAXORD was reduced to a value less than the tentative order NEWQ,
C then NQ is set to MAXORD, and a new H ratio ETA is chosen.
C Otherwise, we take the same preliminary actions as for JSTART .gt. 0.
C In any case, NQWAIT is reset to L = NQ + 1 to prevent further
C changes in order for that many steps.

C The new H ratio ETA is limited by the input H if KUTH = 1,
C by HMIN if KUTH = 0, and by HMXI in any case.
C Finally, the history array YH is rescaled.
C-----------------------------------------------------------------------
 100  CONTINUE
      LMAX = MAXORD + 1
      IF (N .EQ. LDYH) GO TO 120
      I1 = 1 + (NEWQ + 1)*LDYH
      I2 = (MAXORD + 1)*LDYH
      IF (I1 .GT. I2) GO TO 120

      DO 110 I = I1, I2
 110    YH1(I) = ZERO
 120  IF (NEWQ .LE. MAXORD) GO TO 140


      FLOTL = REAL(LMAX)
      IF (MAXORD .LT. NQ-1) THEN
        DDN = DVNORM (N, SAVF, EWT)/TQ(1)
        ETA = ONE/((BIAS1*DDN)**(ONE/FLOTL) + ADDON)
        ENDIF
      IF (MAXORD .EQ. NQ .AND. NEWQ .EQ. NQ+1) ETA = ETAQ
      IF (MAXORD .EQ. NQ-1 .AND. NEWQ .EQ. NQ+1) THEN
        ETA = ETAQM1
        CALL DVJUST (YH, LDYH, -1)
        ENDIF
      IF (MAXORD .EQ. NQ-1 .AND. NEWQ .EQ. NQ) THEN
        DDN = DVNORM (N, SAVF, EWT)/TQ(1)
        ETA = ONE/((BIAS1*DDN)**(ONE/FLOTL) + ADDON)
        CALL DVJUST (YH, LDYH, -1)

        ENDIF
      ETA = MIN(ETA,ONE)
      NQ = MAXORD
      L = LMAX
 140  IF (KUTH .EQ. 1) ETA = MIN(ETA,ABS(H/HSCAL))
      IF (KUTH .EQ. 0) ETA = MAX(ETA,HMIN/ABS(HSCAL))
      ETA = ETA/MAX(ONE,ABS(HSCAL)*HMXI*ETA)
      NEWH = 1

      NQWAIT = L
      IF (NEWQ .LE. MAXORD) GO TO 50
C Rescale the history array for a change in H by a factor of ETA. ------
 150  R = ONE
      DO 180 J = 2, L
        R = R*ETA
        CALL DSCAL (N, R, YH(1,J), 1 )
 180    CONTINUE
      H = HSCAL*ETA
      HSCAL = H
      RC = RC*ETA
      NQNYH = NQ*LDYH
C-----------------------------------------------------------------------
C This section computes the predicted values by effectively
C multiplying the YH array by the Pascal triangle matrix.
C DVSET is called to calculate all integration coefficients.
C RC is the ratio of new to old values of the coefficient H/EL(2)=h/l1.
C-----------------------------------------------------------------------
 200  TN = TN + H
      I1 = NQNYH + 1
      DO 220 JB = 1, NQ
        I1 = I1 - LDYH
        DO 210 I = I1, NQNYH
 210      YH1(I) = YH1(I) + YH1(I+LDYH)
 220  CONTINUE
      CALL DVSET
      RL1 = ONE/EL(2)
      RC = RC*(RL1/PRL1)
      PRL1 = RL1
C
C Call the nonlinear system solver. ------------------------------------
C
      CALL VNLS (Y, YH, LDYH, VSAV, SAVF, EWT, ACOR, IWM, WM,
     1           F, JAC, PSOL, NFLAG, RPAR, IPAR)

C
      IF (NFLAG .EQ. 0) GO TO 450
C-----------------------------------------------------------------------
C The VNLS routine failed to achieve convergence (NFLAG .NE. 0).
C The YH array is retracted to its values before prediction.
C The step size H is reduced and the step is retried, if possible.
C Otherwise, an error exit is taken.
C-----------------------------------------------------------------------

        NCF = NCF + 1
        NCFN = NCFN + 1

        ETAMAX = ONE
        TN = TOLD
        I1 = NQNYH + 1
        DO 430 JB = 1, NQ
          I1 = I1 - LDYH
          DO 420 I = I1, NQNYH
 420        YH1(I) = YH1(I) - YH1(I+LDYH)
 430      CONTINUE
        IF (NFLAG .LT. -1) GO TO 680

        IF (ABS(H) .LE. HMIN*ONEPSM) GO TO 670
        IF (NCF .EQ. MXNCF) GO TO 670
        ETA = ETACF
        ETA = MAX(ETA,HMIN/ABS(H))
        NFLAG = -1
        GO TO 150
C-----------------------------------------------------------------------
C The corrector has converged (NFLAG = 0).  The local error test is
C made and control passes to statement 500 if it fails.
C-----------------------------------------------------------------------
 450  CONTINUE
      DSM = ACNRM/TQ(2)
      IF (DSM .GT. ONE) GO TO 500
C-----------------------------------------------------------------------
C After a successful step, update the YH and TAU arrays and decrement
C NQWAIT.  If NQWAIT is then 1 and NQ .lt. MAXORD, then ACOR is saved
C for use in a possible order increase on the next step.
C If ETAMAX = 1 (a failure occurred this step), keep NQWAIT .ge. 2.
C-----------------------------------------------------------------------
      KFLAG = 0
      NST = NST + 1
      HU = H
      NQU = NQ
      DO 470 IBACK = 1, NQ

        I = L - IBACK

 470    TAU(I+1) = TAU(I)
      TAU(1) = H
      DO 480 J = 1, L
        CALL DAXPY (N, EL(J), ACOR, 1, YH(1,J), 1 )
 480    CONTINUE
      NQWAIT = NQWAIT - 1

      IF ((L .EQ. LMAX) .OR. (NQWAIT .NE. 1)) GO TO 490
      CALL DCOPY (N, ACOR, 1, YH(1,LMAX), 1 )
      CONP = TQ(5)
 490  IF (ETAMAX .NE. ONE) GO TO 560
      IF (NQWAIT .LT. 2) NQWAIT = 2
      NEWQ = NQ
      NEWH = 0
      ETA = ONE
      HNEW = H
      GO TO 690
C-----------------------------------------------------------------------
C The error test failed.  KFLAG keeps track of multiple failures.
C Restore TN and the YH array to their previous values, and prepare
C to try the step again.  Compute the optimum step size for the


C same order.  After repeated failures, H is forced to decrease
C more rapidly.
C-----------------------------------------------------------------------
 500  KFLAG = KFLAG - 1
      NETF = NETF + 1
      NFLAG = -2
      TN = TOLD
      I1 = NQNYH + 1
      DO 520 JB = 1, NQ

        I1 = I1 - LDYH
        DO 510 I = I1, NQNYH

 510      YH1(I) = YH1(I) - YH1(I+LDYH)
 520  CONTINUE
      IF (ABS(H) .LE. HMIN*ONEPSM) GO TO 660
      ETAMAX = ONE
      IF (KFLAG .LE. KFC) GO TO 530
C Compute ratio of new H to current H at the current order. ------------
      FLOTL = REAL(L)
      ETA = ONE/((BIAS2*DSM)**(ONE/FLOTL) + ADDON)
      ETA = MAX(ETA,HMIN/ABS(H),ETAMIN)
      IF ((KFLAG .LE. -2) .AND. (ETA .GT. ETAMXF)) ETA = ETAMXF
      GO TO 150
C-----------------------------------------------------------------------
C Control reaches this section if 3 or more consecutive failures
C have occurred.  It is assumed that the elements of the YH array
C have accumulated errors of the wrong order.  The order is reduced
C by one, if possible.  Then H is reduced by a factor of 0.1 and
C the step is retried.  After a total of 7 consecutive failures,
C an exit is taken with KFLAG = -1.
C-----------------------------------------------------------------------
 530  IF (KFLAG .EQ. KFH) GO TO 660

      IF (NQ .EQ. 1) GO TO 540
      ETA = MAX(ETAMIN,HMIN/ABS(H))
      CALL DVJUST (YH, LDYH, -1)
      L = NQ
      NQ = NQ - 1
      NQWAIT = L
      GO TO 150
 540  ETA = MAX(ETAMIN,HMIN/ABS(H))
      H = H*ETA
      HSCAL = H
      TAU(1) = H
      CALL F (N, TN, Y, SAVF, RPAR, IPAR)
      NFE = NFE + 1
      DO 550 I = 1, N
 550    YH(I,2) = H*SAVF(I)
      NQWAIT = 10
      GO TO 200
C-----------------------------------------------------------------------
C If NQWAIT = 0, an increase or decrease in order by one is considered.
C Factors ETAQ, ETAQM1, ETAQP1 are computed by which H could

C be multiplied at order q, q-1, or q+1, respectively.
C The largest of these is determined, and the new order and
C step size set accordingly.

C A change of H or NQ is made only if H increases by at least a

C factor of THRESH.  If an order change is considered and rejected,
C then NQWAIT is set to 2 (reconsider it after 2 steps).
C-----------------------------------------------------------------------
C Compute ratio of new H to current H at the current order. ------------

 560  FLOTL = REAL(L)
      ETAQ = ONE/((BIAS2*DSM)**(ONE/FLOTL) + ADDON)
      IF (NQWAIT .NE. 0) GO TO 600
      NQWAIT = 2
      ETAQM1 = ZERO


      IF (NQ .EQ. 1) GO TO 570
C Compute ratio of new H to current H at the current order less one. ---
      DDN = DVNORM (N, YH(1,L), EWT)/TQ(1)
      ETAQM1 = ONE/((BIAS1*DDN)**(ONE/(FLOTL - ONE)) + ADDON)
 570  ETAQP1 = ZERO
      IF (L .EQ. LMAX) GO TO 580
C Compute ratio of new H to current H at current order plus one. -------


      CNQUOT = (TQ(5)/CONP)*(H/TAU(2))**L
      DO 575 I = 1, N
 575    SAVF(I) = ACOR(I) - CNQUOT*YH(I,LMAX)
      DUP = DVNORM (N, SAVF, EWT)/TQ(3)
      ETAQP1 = ONE/((BIAS3*DUP)**(ONE/(FLOTL + ONE)) + ADDON)
 580  IF (ETAQ .GE. ETAQP1) GO TO 590

      IF (ETAQP1 .GT. ETAQM1) GO TO 620
      GO TO 610
 590  IF (ETAQ .LT. ETAQM1) GO TO 610

 600  ETA = ETAQ
      NEWQ = NQ
      GO TO 630
 610  ETA = ETAQM1
      NEWQ = NQ - 1
      GO TO 630
 620  ETA = ETAQP1
      NEWQ = NQ + 1
      CALL DCOPY (N, ACOR, 1, YH(1,LMAX), 1)
C Test tentative new H against THRESH, ETAMAX, and HMXI, then exit. ----
 630  IF (ETA .LT. THRESH .OR. ETAMAX .EQ. ONE) GO TO 640
      ETA = MIN(ETA,ETAMAX)
      ETA = ETA/MAX(ONE,ABS(H)*HMXI*ETA)
      NEWH = 1
      HNEW = H*ETA
      GO TO 690
 640  NEWQ = NQ
      NEWH = 0
      ETA = ONE
      HNEW = H
      GO TO 690
C-----------------------------------------------------------------------
C All returns are made through this section.
C On a successful return, ETAMAX is reset and ACOR is scaled.

C-----------------------------------------------------------------------
 660  KFLAG = -1
      GO TO 720
 670  KFLAG = -2
      GO TO 720
 680  IF (NFLAG .EQ. -2) KFLAG = -3
      IF (NFLAG .EQ. -3) KFLAG = -4
      GO TO 720

 690  ETAMAX = ETAMX3
      IF (NST .LE. 10) ETAMAX = ETAMX2
 700  R = ONE/TQ(2)
      CALL DSCAL (N, R, ACOR, 1)
 720  JSTART = 1



      RETURN
C----------------------- End of Subroutine DVSTEP ----------------------
      END
*DECK DVSET
      SUBROUTINE DVSET
C-----------------------------------------------------------------------
C Call sequence communication.. None
C COMMON block variables accessed..
C     /DVOD01/ -- EL(13), H, TAU(13), TQ(5), L(= NQ + 1),
C                 METH, NQ, NQWAIT
C
C Subroutines called by DVSET.. None
C Function routines called by DVSET.. None
C-----------------------------------------------------------------------

C DVSET is called by DVSTEP and sets coefficients for use there.
C
C For each order NQ, the coefficients in EL are calculated by use of
C  the generating polynomial lambda(x), with coefficients EL(i).
C      lambda(x) = EL(1) + EL(2)*x + ... + EL(NQ+1)*(x**NQ).
C For the backward differentiation formulas,
C                                     NQ-1
C      lambda(x) = (1 + x/xi*(NQ)) * product (1 + x/xi(i) ) .
C                                     i = 1
C For the Adams formulas,
C                              NQ-1

C      (d/dx) lambda(x) = c * product (1 + x/xi(i) ) ,
C                              i = 1
C      lambda(-1) = 0,    lambda(0) = 1,
C where c is a normalization constant.
C In both cases, xi(i) is defined by
C      H*xi(i) = t sub n  -  t sub (n-i)

C              = H + TAU(1) + TAU(2) + ... TAU(i-1).
C
C
C In addition to variables described previously, communication
C with DVSET uses the following..
C   TAU    = A vector of length 13 containing the past NQ values
C            of H.
C   EL     = A vector of length 13 in which vset stores the
C            coefficients for the corrector formula.
C   TQ     = A vector of length 5 in which vset stores constants
C            used for the convergence test, the error test, and the

C            selection of H at a new order.

C   METH   = The basic method indicator.
C   NQ     = The current order.
C   L      = NQ + 1, the length of the vector stored in EL, and
C            the number of columns of the YH array being used.
C   NQWAIT = A counter controlling the frequency of order changes.

C            An order change is about to be considered if NQWAIT = 1.
C-----------------------------------------------------------------------
C
C Type declarations for labeled COMMON block DVOD01 --------------------
C
      DOUBLE PRECISION ACNRM, CCMXJ, CONP, CRATE, DRC, EL,
     1     ETA, ETAMAX, H, HMIN, HMXI, HNEW, HSCAL, PRL1,
     2     RC, RL1, TAU, TQ, TN, UROUND
      INTEGER ICF, INIT, IPUP, JCUR, JSTART, JSV, KFLAG, KUTH,
     1        L, LMAX, LYH, LEWT, LACOR, LSAVF, LWM, LIWM,
     2        LOCJS, MAXORD, METH, MITER, MSBJ, MXHNIL, MXSTEP,
     3        N, NEWH, NEWQ, NHNIL, NQ, NQNYH, NQWAIT, NSLJ,
     4        NSLP, NYH
C
C Type declarations for local variables --------------------------------
C
      DOUBLE PRECISION AHATN0, ALPH0, CNQM1, CORTES, CSUM, ELP, EM,
     1     EM0, FLOTI, FLOTL, FLOTNQ, HSUM, ONE, RXI, RXIS, S, SIX,
     2     T1, T2, T3, T4, T5, T6, TWO, XI, ZERO

      INTEGER I, IBACK, J, JP1, NQM1, NQM2
C
      DIMENSION EM(13)
C-----------------------------------------------------------------------
C The following Fortran-77 declaration is to cause the values of the
C listed (local) variables to be saved between calls to this integrator.
C-----------------------------------------------------------------------
      SAVE CORTES, ONE, SIX, TWO, ZERO
C
      COMMON /DVOD01/ ACNRM, CCMXJ, CONP, CRATE, DRC, EL(13),
     1                ETA, ETAMAX, H, HMIN, HMXI, HNEW, HSCAL, PRL1,
     2                RC, RL1, TAU(13), TQ(5), TN, UROUND,
     3                ICF, INIT, IPUP, JCUR, JSTART, JSV, KFLAG, KUTH,
     4                L, LMAX, LYH, LEWT, LACOR, LSAVF, LWM, LIWM,
     5                LOCJS, MAXORD, METH, MITER, MSBJ, MXHNIL, MXSTEP,
     6                N, NEWH, NEWQ, NHNIL, NQ, NQNYH, NQWAIT, NSLJ,
     7                NSLP, NYH
C
      DATA CORTES /0.1D0/
      DATA ONE  /1.0D0/, SIX /6.0D0/, TWO /2.0D0/, ZERO /0.0D0/
C
      FLOTL = REAL(L)
      NQM1 = NQ - 1
      NQM2 = NQ - 2
      GO TO (100, 200), METH
C
C Set coefficients for Adams methods. ----------------------------------
 100  IF (NQ .NE. 1) GO TO 110
      EL(1) = ONE
      EL(2) = ONE
      TQ(1) = ONE
      TQ(2) = TWO
      TQ(3) = SIX*TQ(2)
      TQ(5) = ONE
      GO TO 300
 110  HSUM = H
      EM(1) = ONE
      FLOTNQ = FLOTL - ONE
      DO 115 I = 2, L
 115    EM(I) = ZERO
      DO 150 J = 1, NQM1
        IF ((J .NE. NQM1) .OR. (NQWAIT .NE. 1)) GO TO 130
        S = ONE
        CSUM = ZERO
        DO 120 I = 1, NQM1
          CSUM = CSUM + S*EM(I)/REAL(I+1)
 120      S = -S
        TQ(1) = EM(NQM1)/(FLOTNQ*CSUM)
 130    RXI = H/HSUM
        DO 140 IBACK = 1, J
          I = (J + 2) - IBACK
 140      EM(I) = EM(I) + EM(I-1)*RXI


        HSUM = HSUM + TAU(J)
 150    CONTINUE
C Compute integral from -1 to 0 of polynomial and of x times it. -------

      S = ONE
      EM0 = ZERO
      CSUM = ZERO
      DO 160 I = 1, NQ
        FLOTI = REAL(I)
        EM0 = EM0 + S*EM(I)/FLOTI
        CSUM = CSUM + S*EM(I)/(FLOTI+ONE)
 160    S = -S
C In EL, form coefficients of normalized integrated polynomial. --------
      S = ONE/EM0
      EL(1) = ONE
      DO 170 I = 1, NQ
 170    EL(I+1) = S*EM(I)/REAL(I)
      XI = HSUM/H
      TQ(2) = XI*EM0/CSUM
      TQ(5) = XI/EL(L)
      IF (NQWAIT .NE. 1) GO TO 300
C For higher order control constant, multiply polynomial by 1+x/xi(q). -
      RXI = ONE/XI
      DO 180 IBACK = 1, NQ
        I = (L + 1) - IBACK
 180    EM(I) = EM(I) + EM(I-1)*RXI
C Compute integral of polynomial. --------------------------------------
      S = ONE
      CSUM = ZERO

      DO 190 I = 1, L

        CSUM = CSUM + S*EM(I)/REAL(I+1)
 190    S = -S

      TQ(3) = FLOTL*EM0/CSUM
      GO TO 300
C
C Set coefficients for BDF methods. ------------------------------------
 200  DO 210 I = 3, L
 210    EL(I) = ZERO
      EL(1) = ONE
      EL(2) = ONE

      ALPH0 = -ONE
      AHATN0 = -ONE
      HSUM = H

      RXI = ONE
      RXIS = ONE
      IF (NQ .EQ. 1) GO TO 240
      DO 230 J = 1, NQM2
C In EL, construct coefficients of (1+x/xi(1))*...*(1+x/xi(j+1)). ------
        HSUM = HSUM + TAU(J)

        RXI = H/HSUM
        JP1 = J + 1
        ALPH0 = ALPH0 - ONE/REAL(JP1)
        DO 220 IBACK = 1, JP1
          I = (J + 3) - IBACK
 220      EL(I) = EL(I) + EL(I-1)*RXI
 230    CONTINUE
      ALPH0 = ALPH0 - ONE/REAL(NQ)
      RXIS = -EL(2) - ALPH0
      HSUM = HSUM + TAU(NQM1)
      RXI = H/HSUM
      AHATN0 = -EL(2) - RXI
      DO 235 IBACK = 1, NQ
        I = (NQ + 2) - IBACK
 235    EL(I) = EL(I) + EL(I-1)*RXIS
 240  T1 = ONE - AHATN0 + ALPH0
      T2 = ONE + REAL(NQ)*T1
      TQ(2) = ABS(ALPH0*T2/T1)

      TQ(5) = ABS(T2/(EL(L)*RXI/RXIS))
      IF (NQWAIT .NE. 1) GO TO 300
      CNQM1 = RXIS/EL(L)
      T3 = ALPH0 + ONE/REAL(NQ)
      T4 = AHATN0 + RXI
      ELP = T3/(ONE - T4 + T3)
      TQ(1) = ABS(ELP/CNQM1)
      HSUM = HSUM + TAU(NQ)
      RXI = H/HSUM
      T5 = ALPH0 - ONE/REAL(NQ+1)
      T6 = AHATN0 - RXI
      ELP = T2/(ONE - T6 + T5)
      TQ(3) = ABS(ELP*RXI*(FLOTL + ONE)*T5)
 300  TQ(4) = CORTES*TQ(2)
      RETURN
C----------------------- End of Subroutine DVSET -----------------------
      END
*DECK DVJUST

      SUBROUTINE DVJUST (YH, LDYH, IORD)
      DOUBLE PRECISION YH
      INTEGER LDYH, IORD
      DIMENSION YH(LDYH,*)
C-----------------------------------------------------------------------
C Call sequence input -- YH, LDYH, IORD
C Call sequence output -- YH
C COMMON block input -- NQ, METH, LMAX, HSCAL, TAU(13), N
C COMMON block variables accessed..
C     /DVOD01/ -- HSCAL, TAU(13), LMAX, METH, N, NQ,
C
C Subroutines called by DVJUST.. DAXPY
C Function routines called by DVJUST.. None
C-----------------------------------------------------------------------
C This subroutine adjusts the YH array on reduction of order,
C and also when the order is increased for the stiff option (METH = 2).
C Communication with DVJUST uses the following..
C IORD  = An integer flag used when METH = 2 to indicate an order
C         increase (IORD = +1) or an order decrease (IORD = -1).
C HSCAL = Step size H used in scaling of Nordsieck array YH.
C         (If IORD = +1, DVJUST assumes that HSCAL = TAU(1).)

C See References 1 and 2 for details.
C-----------------------------------------------------------------------
C
C Type declarations for labeled COMMON block DVOD01 --------------------
C
      DOUBLE PRECISION ACNRM, CCMXJ, CONP, CRATE, DRC, EL,
     1     ETA, ETAMAX, H, HMIN, HMXI, HNEW, HSCAL, PRL1,
     2     RC, RL1, TAU, TQ, TN, UROUND
      INTEGER ICF, INIT, IPUP, JCUR, JSTART, JSV, KFLAG, KUTH,

     1        L, LMAX, LYH, LEWT, LACOR, LSAVF, LWM, LIWM,
     2        LOCJS, MAXORD, METH, MITER, MSBJ, MXHNIL, MXSTEP,
     3        N, NEWH, NEWQ, NHNIL, NQ, NQNYH, NQWAIT, NSLJ,
     4        NSLP, NYH
C

C Type declarations for local variables --------------------------------
C
      DOUBLE PRECISION ALPH0, ALPH1, HSUM, ONE, PROD, T1, XI,XIOLD, ZERO
      INTEGER I, IBACK, J, JP1, LP1, NQM1, NQM2, NQP1
C-----------------------------------------------------------------------
C The following Fortran-77 declaration is to cause the values of the
C listed (local) variables to be saved between calls to this integrator.
C-----------------------------------------------------------------------
      SAVE ONE, ZERO
C
      COMMON /DVOD01/ ACNRM, CCMXJ, CONP, CRATE, DRC, EL(13),
     1                ETA, ETAMAX, H, HMIN, HMXI, HNEW, HSCAL, PRL1,
     2                RC, RL1, TAU(13), TQ(5), TN, UROUND,
     3                ICF, INIT, IPUP, JCUR, JSTART, JSV, KFLAG, KUTH,
     4                L, LMAX, LYH, LEWT, LACOR, LSAVF, LWM, LIWM,
     5                LOCJS, MAXORD, METH, MITER, MSBJ, MXHNIL, MXSTEP,

     6                N, NEWH, NEWQ, NHNIL, NQ, NQNYH, NQWAIT, NSLJ,
     7                NSLP, NYH
C
      DATA ONE /1.0D0/, ZERO /0.0D0/
C
      IF ((NQ .EQ. 2) .AND. (IORD .NE. 1)) RETURN
      NQM1 = NQ - 1
      NQM2 = NQ - 2
      GO TO (100, 200), METH
C-----------------------------------------------------------------------
C Nonstiff option...
C Check to see if the order is being increased or decreased.
C-----------------------------------------------------------------------
 100  CONTINUE
      IF (IORD .EQ. 1) GO TO 180
C Order decrease. ------------------------------------------------------
      DO 110 J = 1, LMAX
 110    EL(J) = ZERO
      EL(2) = ONE
      HSUM = ZERO
      DO 130 J = 1, NQM2
C Construct coefficients of x*(x+xi(1))*...*(x+xi(j)). -----------------
        HSUM = HSUM + TAU(J)
        XI = HSUM/HSCAL
        JP1 = J + 1
        DO 120 IBACK = 1, JP1
          I = (J + 3) - IBACK
 120      EL(I) = EL(I)*XI + EL(I-1)
 130    CONTINUE
C Construct coefficients of integrated polynomial. ---------------------
      DO 140 J = 2, NQM1
 140    EL(J+1) = REAL(NQ)*EL(J)/REAL(J)
C Subtract correction terms from YH array. -----------------------------
      DO 170 J = 3, NQ
        DO 160 I = 1, N

 160      YH(I,J) = YH(I,J) - YH(I,L)*EL(J)
 170    CONTINUE
      RETURN
C Order increase. ------------------------------------------------------
C Zero out next column in YH array. ------------------------------------
 180  CONTINUE
      LP1 = L + 1
      DO 190 I = 1, N
 190    YH(I,LP1) = ZERO
      RETURN
C-----------------------------------------------------------------------
C Stiff option...
C Check to see if the order is being increased or decreased.

C-----------------------------------------------------------------------
 200  CONTINUE
      IF (IORD .EQ. 1) GO TO 300
C Order decrease. ------------------------------------------------------
      DO 210 J = 1, LMAX
 210    EL(J) = ZERO
      EL(3) = ONE

      HSUM = ZERO
      DO 230 J = 1,NQM2
C Construct coefficients of x*x*(x+xi(1))*...*(x+xi(j)). ---------------
        HSUM = HSUM + TAU(J)
        XI = HSUM/HSCAL
        JP1 = J + 1
        DO 220 IBACK = 1, JP1
          I = (J + 4) - IBACK

 220      EL(I) = EL(I)*XI + EL(I-1)
 230    CONTINUE
C Subtract correction terms from YH array. -----------------------------
      DO 250 J = 3,NQ
        DO 240 I = 1, N
 240      YH(I,J) = YH(I,J) - YH(I,L)*EL(J)

 250    CONTINUE

      RETURN
C Order increase. ------------------------------------------------------
 300  DO 310 J = 1, LMAX
 310    EL(J) = ZERO

      EL(3) = ONE
      ALPH0 = -ONE
      ALPH1 = ONE
      PROD = ONE
      XIOLD = ONE

      HSUM = HSCAL
      IF (NQ .EQ. 1) GO TO 340

      DO 330 J = 1, NQM1
C Construct coefficients of x*x*(x+xi(1))*...*(x+xi(j)). ---------------
        JP1 = J + 1
        HSUM = HSUM + TAU(JP1)
        XI = HSUM/HSCAL
        PROD = PROD*XI
        ALPH0 = ALPH0 - ONE/REAL(JP1)
        ALPH1 = ALPH1 + ONE/XI
        DO 320 IBACK = 1, JP1
          I = (J + 4) - IBACK
 320      EL(I) = EL(I)*XIOLD + EL(I-1)
        XIOLD = XI
 330    CONTINUE
 340  CONTINUE
      T1 = (-ALPH0 - ALPH1)/PROD
C Load column L + 1 in YH array. ---------------------------------------
      LP1 = L + 1
      DO 350 I = 1, N
 350    YH(I,LP1) = T1*YH(I,LMAX)
C Add correction terms to YH array. ------------------------------------

      NQP1 = NQ + 1

      DO 370 J = 3, NQP1
        CALL DAXPY (N, EL(J), YH(1,LP1), 1, YH(1,J), 1 )
 370  CONTINUE
      RETURN
C----------------------- End of Subroutine DVJUST ----------------------
      END
*DECK DVNLSD
      SUBROUTINE DVNLSD (Y, YH, LDYH, VSAV, SAVF, EWT, ACOR, IWM, WM,
     1                 F, JAC, PDUM, NFLAG, RPAR, IPAR)
      EXTERNAL F, JAC, PDUM
      DOUBLE PRECISION Y, YH, VSAV, SAVF, EWT, ACOR, WM, RPAR
      INTEGER LDYH, IWM, NFLAG, IPAR
      DIMENSION Y(*), YH(LDYH,*), VSAV(*), SAVF(*), EWT(*), ACOR(*),

     1          IWM(*), WM(*), RPAR(*), IPAR(*)
C-----------------------------------------------------------------------
C Call sequence input -- Y, YH, LDYH, SAVF, EWT, ACOR, IWM, WM,
C                        F, JAC, NFLAG, RPAR, IPAR
C Call sequence output -- YH, ACOR, WM, IWM, NFLAG
C COMMON block variables accessed..
C     /DVOD01/ ACNRM, CRATE, DRC, H, RC, RL1, TQ(5), TN, ICF,
C                JCUR, METH, MITER, N, NSLP
C     /DVOD02/ HU, NCFN, NETF, NFE, NJE, NLU, NNI, NQU, NST
C
C Subroutines called by DVNLSD.. F, DAXPY, DCOPY, DSCAL, DVJAC, DVSOL
C Function routines called by DVNLSD.. DVNORM
C-----------------------------------------------------------------------
C Subroutine DVNLSD is a nonlinear system solver, which uses functional
C iteration or a chord (modified Newton) method.  For the chord method
C direct linear algebraic system solvers are used.  Subroutine DVNLSD
C then handles the corrector phase of this integration package.
C
C Communication with DVNLSD is done with the following variables. (For
C more details, please see the comments in the driver subroutine.)
C
C Y          = The dependent variable, a vector of length N, input.

C YH         = The Nordsieck (Taylor) array, LDYH by LMAX, input
C              and output.  On input, it contains predicted values.
C LDYH       = A constant .ge. N, the first dimension of YH, input.
C VSAV       = Unused work array.
C SAVF       = A work array of length N.

C EWT        = An error weight vector of length N, input.
C ACOR       = A work array of length N, used for the accumulated
C              corrections to the predicted y vector.
C WM,IWM     = Real and integer work arrays associated with matrix
C              operations in chord iteration (MITER .ne. 0).
C F          = Dummy name for user supplied routine for f.
C JAC        = Dummy name for user supplied Jacobian routine.
C PDUM       = Unused dummy subroutine name.  Included for uniformity
C              over collection of integrators.
C NFLAG      = Input/output flag, with values and meanings as follows..
C              INPUT
C                  0 first call for this time step.
C                 -1 convergence failure in previous call to DVNLSD.
C                 -2 error test failure in DVSTEP.
C              OUTPUT
C                  0 successful completion of nonlinear solver.
C                 -1 convergence failure or singular matrix.
C                 -2 unrecoverable error in matrix preprocessing
C                    (cannot occur here).
C                 -3 unrecoverable error in solution (cannot occur
C                    here).
C RPAR, IPAR = Dummy names for user's real and integer work arrays.
C
C IPUP       = Own variable flag with values and meanings as follows..
C              0,            do not update the Newton matrix.
C              MITER .ne. 0, update Newton matrix, because it is the
C                            initial step, order was changed, the error
C                            test failed, or an update is indicated by
C                            the scalar RC or step counter NST.
C
C For more details, see comments in driver subroutine.
C-----------------------------------------------------------------------
C Type declarations for labeled COMMON block DVOD01 --------------------
C
      DOUBLE PRECISION ACNRM, CCMXJ, CONP, CRATE, DRC, EL,
     1     ETA, ETAMAX, H, HMIN, HMXI, HNEW, HSCAL, PRL1,
     2     RC, RL1, TAU, TQ, TN, UROUND
      INTEGER ICF, INIT, IPUP, JCUR, JSTART, JSV, KFLAG, KUTH,
     1        L, LMAX, LYH, LEWT, LACOR, LSAVF, LWM, LIWM,
     2        LOCJS, MAXORD, METH, MITER, MSBJ, MXHNIL, MXSTEP,
     3        N, NEWH, NEWQ, NHNIL, NQ, NQNYH, NQWAIT, NSLJ,
     4        NSLP, NYH
C
C Type declarations for labeled COMMON block DVOD02 --------------------

C
      DOUBLE PRECISION HU
      INTEGER NCFN, NETF, NFE, NJE, NLU, NNI, NQU, NST
C
C Type declarations for local variables --------------------------------
C
      DOUBLE PRECISION CCMAX, CRDOWN, CSCALE, DCON, DEL, DELP, ONE,
     1     RDIV, TWO, ZERO
      INTEGER I, IERPJ, IERSL, M, MAXCOR, MSBP
C
C Type declaration for function subroutines called ---------------------
C
      DOUBLE PRECISION DVNORM
C-----------------------------------------------------------------------
C The following Fortran-77 declaration is to cause the values of the
C listed (local) variables to be saved between calls to this integrator.
C-----------------------------------------------------------------------
      SAVE CCMAX, CRDOWN, MAXCOR, MSBP, RDIV, ONE, TWO, ZERO
C
      COMMON /DVOD01/ ACNRM, CCMXJ, CONP, CRATE, DRC, EL(13),
     1                ETA, ETAMAX, H, HMIN, HMXI, HNEW, HSCAL, PRL1,
     2                RC, RL1, TAU(13), TQ(5), TN, UROUND,
     3                ICF, INIT, IPUP, JCUR, JSTART, JSV, KFLAG, KUTH,
     4                L, LMAX, LYH, LEWT, LACOR, LSAVF, LWM, LIWM,
     5                LOCJS, MAXORD, METH, MITER, MSBJ, MXHNIL, MXSTEP,
     6                N, NEWH, NEWQ, NHNIL, NQ, NQNYH, NQWAIT, NSLJ,
     7                NSLP, NYH
      COMMON /DVOD02/ HU, NCFN, NETF, NFE, NJE, NLU, NNI, NQU, NST
C
      DATA CCMAX /0.3D0/, CRDOWN /0.3D0/, MAXCOR /3/, MSBP /20/,
     1     RDIV  /2.0D0/

      DATA ONE /1.0D0/, TWO /2.0D0/, ZERO /0.0D0/

C-----------------------------------------------------------------------
C On the first step, on a change of method order, or after a
C nonlinear convergence failure with NFLAG = -2, set IPUP = MITER

C to force a Jacobian update when MITER .ne. 0.
C-----------------------------------------------------------------------
      IF (JSTART .EQ. 0) NSLP = 0

      IF (NFLAG .EQ. 0) ICF = 0
      IF (NFLAG .EQ. -2) IPUP = MITER
      IF ( (JSTART .EQ. 0) .OR. (JSTART .EQ. -1) ) IPUP = MITER

C If this is functional iteration, set CRATE .eq. 1 and drop to 220
      IF (MITER .EQ. 0) THEN
        CRATE = ONE
        GO TO 220
      ENDIF
C-----------------------------------------------------------------------
C RC is the ratio of new to old values of the coefficient H/EL(2)=h/l1.
C When RC differs from 1 by more than CCMAX, IPUP is set to MITER
C to force DVJAC to be called, if a Jacobian is involved.
C In any case, DVJAC is called at least every MSBP steps.
C-----------------------------------------------------------------------
      DRC = ABS(RC-ONE)

      IF (DRC .GT. CCMAX .OR. NST .GE. NSLP+MSBP) IPUP = MITER
C-----------------------------------------------------------------------
C Up to MAXCOR corrector iterations are taken.  A convergence test is
C made on the r.m.s. norm of each correction, weighted by the error
C weight vector EWT.  The sum of the corrections is accumulated in the
C vector ACOR(i).  The YH array is not altered in the corrector loop.
C-----------------------------------------------------------------------

 220  M = 0
      DELP = ZERO
      CALL DCOPY (N, YH(1,1), 1, Y, 1 )
      CALL F (N, TN, Y, SAVF, RPAR, IPAR)
      NFE = NFE + 1
      IF (IPUP .LE. 0) GO TO 250
C-----------------------------------------------------------------------
C If indicated, the matrix P = I - h*rl1*J is reevaluated and
C preprocessed before starting the corrector iteration.  IPUP is set
C to 0 as an indicator that this has been done.
C-----------------------------------------------------------------------
      CALL DVJAC (Y, YH, LDYH, EWT, ACOR, SAVF, WM, IWM, F, JAC, IERPJ,
     1           RPAR, IPAR)
      IPUP = 0
      RC = ONE
      DRC = ZERO
      CRATE = ONE
      NSLP = NST
C If matrix is singular, take error return to force cut in step size. --
      IF (IERPJ .NE. 0) GO TO 430
 250  DO 260 I = 1,N
 260    ACOR(I) = ZERO

C This is a looping point for the corrector iteration. -----------------
 270  IF (MITER .NE. 0) GO TO 350
C-----------------------------------------------------------------------
C In the case of functional iteration, update Y directly from
C the result of the last function evaluation.
C-----------------------------------------------------------------------
      DO 280 I = 1,N
 280    SAVF(I) = RL1*(H*SAVF(I) - YH(I,2))
      DO 290 I = 1,N
 290    Y(I) = SAVF(I) - ACOR(I)
      DEL = DVNORM (N, Y, EWT)
      DO 300 I = 1,N
 300    Y(I) = YH(I,1) + SAVF(I)
      CALL DCOPY (N, SAVF, 1, ACOR, 1)
      GO TO 400
C-----------------------------------------------------------------------
C In the case of the chord method, compute the corrector error,
C and solve the linear system with that as right-hand side and
C P as coefficient matrix.  The correction is scaled by the factor
C 2/(1+RC) to account for changes in h*rl1 since the last DVJAC call.

C-----------------------------------------------------------------------

 350  DO 360 I = 1,N
 360    Y(I) = (RL1*H)*SAVF(I) - (RL1*YH(I,2) + ACOR(I))
      CALL DVSOL (WM, IWM, Y, IERSL)
      NNI = NNI + 1
      IF (IERSL .GT. 0) GO TO 410
      IF (METH .EQ. 2 .AND. RC .NE. ONE) THEN
        CSCALE = TWO/(ONE + RC)
        CALL DSCAL (N, CSCALE, Y, 1)
      ENDIF
      DEL = DVNORM (N, Y, EWT)
      CALL DAXPY (N, ONE, Y, 1, ACOR, 1)
      DO 380 I = 1,N

 380    Y(I) = YH(I,1) + ACOR(I)
C-----------------------------------------------------------------------
C Test for convergence.  If M .gt. 0, an estimate of the convergence
C rate constant is stored in CRATE, and this is used in the test.
C-----------------------------------------------------------------------

 400  IF (M .NE. 0) CRATE = MAX(CRDOWN*CRATE,DEL/DELP)
      DCON = DEL*MIN(ONE,CRATE)/TQ(4)
      IF (DCON .LE. ONE) GO TO 450
      M = M + 1
      IF (M .EQ. MAXCOR) GO TO 410
      IF (M .GE. 2 .AND. DEL .GT. RDIV*DELP) GO TO 410
      DELP = DEL
      CALL F (N, TN, Y, SAVF, RPAR, IPAR)
      NFE = NFE + 1
      GO TO 270
C
 410  IF (MITER .EQ. 0 .OR. JCUR .EQ. 1) GO TO 430

      ICF = 1
      IPUP = MITER
      GO TO 220

C
 430  CONTINUE
      NFLAG = -1
      ICF = 2
      IPUP = MITER
      RETURN
C
C Return for successful step. ------------------------------------------
 450  NFLAG = 0

      JCUR = 0
      ICF = 0
      IF (M .EQ. 0) ACNRM = DEL
      IF (M .GT. 0) ACNRM = DVNORM (N, ACOR, EWT)
      RETURN
C----------------------- End of Subroutine DVNLSD ----------------------
      END
*DECK DVJAC
      SUBROUTINE DVJAC (Y, YH, LDYH, EWT, FTEM, SAVF, WM, IWM, F, JAC,
     1                 IERPJ, RPAR, IPAR)
      EXTERNAL F, JAC
      DOUBLE PRECISION Y, YH, EWT, FTEM, SAVF, WM, RPAR
      INTEGER LDYH, IWM, IERPJ, IPAR
      DIMENSION Y(*), YH(LDYH,*), EWT(*), FTEM(*), SAVF(*),
     1   WM(*), IWM(*), RPAR(*), IPAR(*)
C-----------------------------------------------------------------------
C Call sequence input -- Y, YH, LDYH, EWT, FTEM, SAVF, WM, IWM,
C                        F, JAC, RPAR, IPAR
C Call sequence output -- WM, IWM, IERPJ

C COMMON block variables accessed..
C     /DVOD01/  CCMXJ, DRC, H, RL1, TN, UROUND, ICF, JCUR, LOCJS,
C               MSBJ, NSLJ
C     /DVOD02/  NFE, NST, NJE, NLU
C
C Subroutines called by DVJAC.. F, JAC, DACOPY, DCOPY, DGBFA, DGEFA,
C                              DSCAL
C Function routines called by DVJAC.. DVNORM
C-----------------------------------------------------------------------
C DVJAC is called by DVSTEP to compute and process the matrix
C P = I - h*rl1*J , where J is an approximation to the Jacobian.

C Here J is computed by the user-supplied routine JAC if
C MITER = 1 or 4, or by finite differencing if MITER = 2, 3, or 5.

C If MITER = 3, a diagonal approximation to J is used.
C If JSV = -1, J is computed from scratch in all cases.
C If JSV = 1 and MITER = 1, 2, 4, or 5, and if the saved value of J is
C considered acceptable, then P is constructed from the saved J.
C J is stored in wm and replaced by P.  If MITER .ne. 3, P is then
C subjected to LU decomposition in preparation for later solution
C of linear systems with P as coefficient matrix. This is done
C by DGEFA if MITER = 1 or 2, and by DGBFA if MITER = 4 or 5.

C
C Communication with DVJAC is done with the following variables.  (For
C more details, please see the comments in the driver subroutine.)
C Y          = Vector containing predicted values on entry.
C YH         = The Nordsieck array, an LDYH by LMAX array, input.
C LDYH       = A constant .ge. N, the first dimension of YH, input.
C EWT        = An error weight vector of length N.
C SAVF       = Array containing f evaluated at predicted y, input.
C WM         = Real work space for matrices.  In the output, it containS
C              the inverse diagonal matrix if MITER = 3 and the LU

C              decomposition of P if MITER is 1, 2 , 4, or 5.
C              Storage of matrix elements starts at WM(3).
C              Storage of the saved Jacobian starts at WM(LOCJS).
C              WM also contains the following matrix-related data..
C              WM(1) = SQRT(UROUND), used in numerical Jacobian step.
C              WM(2) = H*RL1, saved for later use if MITER = 3.
C IWM        = Integer work space containing pivot information,
C              starting at IWM(31), if MITER is 1, 2, 4, or 5.

C              IWM also contains band parameters ML = IWM(1) and

C              MU = IWM(2) if MITER is 4 or 5.
C F          = Dummy name for the user supplied subroutine for f.
C JAC        = Dummy name for the user supplied Jacobian subroutine.
C RPAR, IPAR = Dummy names for user's real and integer work arrays.
C RL1        = 1/EL(2) (input).
C IERPJ      = Output error flag,  = 0 if no trouble, 1 if the P
C              matrix is found to be singular.
C JCUR       = Output flag to indicate whether the Jacobian matrix
C              (or approximation) is now current.
C              JCUR = 0 means J is not current.
C              JCUR = 1 means J is current.
C-----------------------------------------------------------------------

C
C Type declarations for labeled COMMON block DVOD01 --------------------
C

      DOUBLE PRECISION ACNRM, CCMXJ, CONP, CRATE, DRC, EL,
     1     ETA, ETAMAX, H, HMIN, HMXI, HNEW, HSCAL, PRL1,
     2     RC, RL1, TAU, TQ, TN, UROUND
      INTEGER ICF, INIT, IPUP, JCUR, JSTART, JSV, KFLAG, KUTH,
     1        L, LMAX, LYH, LEWT, LACOR, LSAVF, LWM, LIWM,
     2        LOCJS, MAXORD, METH, MITER, MSBJ, MXHNIL, MXSTEP,
     3        N, NEWH, NEWQ, NHNIL, NQ, NQNYH, NQWAIT, NSLJ,
     4        NSLP, NYH
C
C Type declarations for labeled COMMON block DVOD02 --------------------
C
      DOUBLE PRECISION HU
      INTEGER NCFN, NETF, NFE, NJE, NLU, NNI, NQU, NST
C
C Type declarations for local variables --------------------------------
C
      DOUBLE PRECISION CON, DI, FAC, HRL1, ONE, PT1, R, R0, SRUR, THOU,
     1     YI, YJ, YJJ, ZERO
      INTEGER I, I1, I2, IER, II, J, J1, JJ, JOK, LENP, MBA, MBAND,

     1        MEB1, MEBAND, ML, ML3, MU, NP1
C

C Type declaration for function subroutines called ---------------------

C
      DOUBLE PRECISION DVNORM
C-----------------------------------------------------------------------
C The following Fortran-77 declaration is to cause the values of the
C listed (local) variables to be saved between calls to this subroutine.
C-----------------------------------------------------------------------
      SAVE ONE, PT1, THOU, ZERO
C-----------------------------------------------------------------------
      COMMON /DVOD01/ ACNRM, CCMXJ, CONP, CRATE, DRC, EL(13),
     1                ETA, ETAMAX, H, HMIN, HMXI, HNEW, HSCAL, PRL1,
     2                RC, RL1, TAU(13), TQ(5), TN, UROUND,
     3                ICF, INIT, IPUP, JCUR, JSTART, JSV, KFLAG, KUTH,
     4                L, LMAX, LYH, LEWT, LACOR, LSAVF, LWM, LIWM,
     5                LOCJS, MAXORD, METH, MITER, MSBJ, MXHNIL, MXSTEP,
     6                N, NEWH, NEWQ, NHNIL, NQ, NQNYH, NQWAIT, NSLJ,
     7                NSLP, NYH
      COMMON /DVOD02/ HU, NCFN, NETF, NFE, NJE, NLU, NNI, NQU, NST
C
      DATA ONE /1.0D0/, THOU /1000.0D0/, ZERO /0.0D0/, PT1 /0.1D0/

C
      IERPJ = 0
      HRL1 = H*RL1
C See whether J should be evaluated (JOK = -1) or not (JOK = 1). -------

      JOK = JSV
      IF (JSV .EQ. 1) THEN
        IF (NST .EQ. 0 .OR. NST .GT. NSLJ+MSBJ) JOK = -1
        IF (ICF .EQ. 1 .AND. DRC .LT. CCMXJ) JOK = -1
        IF (ICF .EQ. 2) JOK = -1

      ENDIF
C End of setting JOK. --------------------------------------------------
C
      IF (JOK .EQ. -1 .AND. MITER .EQ. 1) THEN
C If JOK = -1 and MITER = 1, call JAC to evaluate Jacobian. ------------
      NJE = NJE + 1
      NSLJ = NST
      JCUR = 1
      LENP = N*N
      DO 110 I = 1,LENP
 110    WM(I+2) = ZERO
      CALL JAC (N, TN, Y, 0, 0, WM(3), N, RPAR, IPAR)
      IF (JSV .EQ. 1) CALL DCOPY (LENP, WM(3), 1, WM(LOCJS), 1)
      ENDIF
C
      IF (JOK .EQ. -1 .AND. MITER .EQ. 2) THEN
C If MITER = 2, make N calls to F to approximate the Jacobian. ---------
      NJE = NJE + 1
      NSLJ = NST
      JCUR = 1
      FAC = DVNORM (N, SAVF, EWT)


      R0 = THOU*ABS(H)*UROUND*REAL(N)*FAC
      IF (R0 .EQ. ZERO) R0 = ONE
      SRUR = WM(1)
      J1 = 2
      DO 230 J = 1,N
        YJ = Y(J)
        R = MAX(SRUR*ABS(YJ),R0/EWT(J))
        Y(J) = Y(J) + R
        FAC = ONE/R
        CALL F (N, TN, Y, FTEM, RPAR, IPAR)
        DO 220 I = 1,N
 220      WM(I+J1) = (FTEM(I) - SAVF(I))*FAC
        Y(J) = YJ
        J1 = J1 + N
 230    CONTINUE
      NFE = NFE + N
      LENP = N*N
      IF (JSV .EQ. 1) CALL DCOPY (LENP, WM(3), 1, WM(LOCJS), 1)
      ENDIF
C
      IF (JOK .EQ. 1 .AND. (MITER .EQ. 1 .OR. MITER .EQ. 2)) THEN
      JCUR = 0
      LENP = N*N
      CALL DCOPY (LENP, WM(LOCJS), 1, WM(3), 1)
      ENDIF
C
      IF (MITER .EQ. 1 .OR. MITER .EQ. 2) THEN

C Multiply Jacobian by scalar, add identity, and do LU decomposition. --
      CON = -HRL1
      CALL DSCAL (LENP, CON, WM(3), 1)
      J = 3
      NP1 = N + 1
      DO 250 I = 1,N
        WM(J) = WM(J) + ONE
 250    J = J + NP1
      NLU = NLU + 1
      CALL DGEFA (WM(3), N, N, IWM(31), IER)
      IF (IER .NE. 0) IERPJ = 1
      RETURN
      ENDIF
C End of code block for MITER = 1 or 2. --------------------------------
C
      IF (MITER .EQ. 3) THEN
C If MITER = 3, construct a diagonal approximation to J and P. ---------
      NJE = NJE + 1
      JCUR = 1
      WM(2) = HRL1
      R = RL1*PT1
      DO 310 I = 1,N
 310    Y(I) = Y(I) + R*(H*SAVF(I) - YH(I,2))
      CALL F (N, TN, Y, WM(3), RPAR, IPAR)
      NFE = NFE + 1
      DO 320 I = 1,N
        R0 = H*SAVF(I) - YH(I,2)
        DI = PT1*R0 - H*(WM(I+2) - SAVF(I))
        WM(I+2) = ONE

        IF (ABS(R0) .LT. UROUND/EWT(I)) GO TO 320
        IF (ABS(DI) .EQ. ZERO) GO TO 330
        WM(I+2) = PT1*R0/DI
 320    CONTINUE
      RETURN
 330  IERPJ = 1
      RETURN
      ENDIF
C End of code block for MITER = 3. -------------------------------------
C

C Set constants for MITER = 4 or 5. ------------------------------------
      ML = IWM(1)
      MU = IWM(2)
      ML3 = ML + 3

      MBAND = ML + MU + 1
      MEBAND = MBAND + ML
      LENP = MEBAND*N
C
      IF (JOK .EQ. -1 .AND. MITER .EQ. 4) THEN
C If JOK = -1 and MITER = 4, call JAC to evaluate Jacobian. ------------
      NJE = NJE + 1
      NSLJ = NST
      JCUR = 1
      DO 410 I = 1,LENP
 410    WM(I+2) = ZERO
      CALL JAC (N, TN, Y, ML, MU, WM(ML3), MEBAND, RPAR, IPAR)
      IF (JSV .EQ. 1)
     1   CALL DACOPY (MBAND, N, WM(ML3), MEBAND, WM(LOCJS), MBAND)

      ENDIF
C
      IF (JOK .EQ. -1 .AND. MITER .EQ. 5) THEN
C If MITER = 5, make N calls to F to approximate the Jacobian. ---------
      NJE = NJE + 1

      NSLJ = NST
      JCUR = 1
      MBA = MIN(MBAND,N)
      MEB1 = MEBAND - 1
      SRUR = WM(1)
      FAC = DVNORM (N, SAVF, EWT)
      R0 = THOU*ABS(H)*UROUND*REAL(N)*FAC
      IF (R0 .EQ. ZERO) R0 = ONE
      DO 560 J = 1,MBA
        DO 530 I = J,N,MBAND
          YI = Y(I)
          R = MAX(SRUR*ABS(YI),R0/EWT(I))
 530      Y(I) = Y(I) + R
        CALL F (N, TN, Y, FTEM, RPAR, IPAR)
        DO 550 JJ = J,N,MBAND
          Y(JJ) = YH(JJ,1)
          YJJ = Y(JJ)

          R = MAX(SRUR*ABS(YJJ),R0/EWT(JJ))
          FAC = ONE/R
          I1 = MAX(JJ-MU,1)
          I2 = MIN(JJ+ML,N)
          II = JJ*MEB1 - ML + 2
          DO 540 I = I1,I2
 540        WM(II+I) = (FTEM(I) - SAVF(I))*FAC
 550      CONTINUE
 560    CONTINUE
      NFE = NFE + MBA
      IF (JSV .EQ. 1)
     1   CALL DACOPY (MBAND, N, WM(ML3), MEBAND, WM(LOCJS), MBAND)
      ENDIF
C
      IF (JOK .EQ. 1) THEN
      JCUR = 0
      CALL DACOPY (MBAND, N, WM(LOCJS), MBAND, WM(ML3), MEBAND)

      ENDIF
C

C Multiply Jacobian by scalar, add identity, and do LU decomposition.
      CON = -HRL1
      CALL DSCAL (LENP, CON, WM(3), 1 )

      II = MBAND + 2
      DO 580 I = 1,N
        WM(II) = WM(II) + ONE
 580    II = II + MEBAND
      NLU = NLU + 1
      CALL DGBFA (WM(3), MEBAND, N, ML, MU, IWM(31), IER)
      IF (IER .NE. 0) IERPJ = 1
      RETURN
C End of code block for MITER = 4 or 5. --------------------------------
C
C----------------------- End of Subroutine DVJAC -----------------------
      END
*DECK DACOPY
      SUBROUTINE DACOPY (NROW, NCOL, A, NROWA, B, NROWB)
      DOUBLE PRECISION A, B
      INTEGER NROW, NCOL, NROWA, NROWB
      DIMENSION A(NROWA,NCOL), B(NROWB,NCOL)
C-----------------------------------------------------------------------
C Call sequence input -- NROW, NCOL, A, NROWA, NROWB
C Call sequence output -- B
C COMMON block variables accessed -- None
C
C Subroutines called by DACOPY.. DCOPY

C Function routines called by DACOPY.. None
C-----------------------------------------------------------------------

C This routine copies one rectangular array, A, to another, B,
C where A and B may have different row dimensions, NROWA and NROWB.
C The data copied consists of NROW rows and NCOL columns.
C-----------------------------------------------------------------------
      INTEGER IC
C
      DO 20 IC = 1,NCOL
        CALL DCOPY (NROW, A(1,IC), 1, B(1,IC), 1)

 20     CONTINUE
C

      RETURN
C----------------------- End of Subroutine DACOPY ----------------------
      END
*DECK DVSOL
      SUBROUTINE DVSOL (WM, IWM, X, IERSL)
      DOUBLE PRECISION WM, X
      INTEGER IWM, IERSL
      DIMENSION WM(*), IWM(*), X(*)
C-----------------------------------------------------------------------
C Call sequence input -- WM, IWM, X

C Call sequence output -- X, IERSL
C COMMON block variables accessed..
C     /DVOD01/ -- H, RL1, MITER, N
C

C Subroutines called by DVSOL.. DGESL, DGBSL
C Function routines called by DVSOL.. None
C-----------------------------------------------------------------------
C This routine manages the solution of the linear system arising from
C a chord iteration.  It is called if MITER .ne. 0.
C If MITER is 1 or 2, it calls DGESL to accomplish this.
C If MITER = 3 it updates the coefficient H*RL1 in the diagonal
C matrix, and then computes the solution.
C If MITER is 4 or 5, it calls DGBSL.
C Communication with DVSOL uses the following variables..

C WM    = Real work space containing the inverse diagonal matrix if
C         MITER = 3 and the LU decomposition of the matrix otherwise.
C         Storage of matrix elements starts at WM(3).
C         WM also contains the following matrix-related data..

C         WM(1) = SQRT(UROUND) (not used here),

C         WM(2) = HRL1, the previous value of H*RL1, used if MITER = 3.
C IWM   = Integer work space containing pivot information, starting at
C         IWM(31), if MITER is 1, 2, 4, or 5.  IWM also contains band
C         parameters ML = IWM(1) and MU = IWM(2) if MITER is 4 or 5.
C X     = The right-hand side vector on input, and the solution vector
C         on output, of length N.
C IERSL = Output flag.  IERSL = 0 if no trouble occurred.
C         IERSL = 1 if a singular matrix arose with MITER = 3.
C-----------------------------------------------------------------------
C
C Type declarations for labeled COMMON block DVOD01 --------------------
C
      DOUBLE PRECISION ACNRM, CCMXJ, CONP, CRATE, DRC, EL,
     1     ETA, ETAMAX, H, HMIN, HMXI, HNEW, HSCAL, PRL1,
     2     RC, RL1, TAU, TQ, TN, UROUND

      INTEGER ICF, INIT, IPUP, JCUR, JSTART, JSV, KFLAG, KUTH,
     1        L, LMAX, LYH, LEWT, LACOR, LSAVF, LWM, LIWM,
     2        LOCJS, MAXORD, METH, MITER, MSBJ, MXHNIL, MXSTEP,
     3        N, NEWH, NEWQ, NHNIL, NQ, NQNYH, NQWAIT, NSLJ,
     4        NSLP, NYH
C
C Type declarations for local variables --------------------------------
C
      INTEGER I, MEBAND, ML, MU
      DOUBLE PRECISION DI, HRL1, ONE, PHRL1, R, ZERO
C-----------------------------------------------------------------------
C The following Fortran-77 declaration is to cause the values of the
C listed (local) variables to be saved between calls to this integrator.

C-----------------------------------------------------------------------
      SAVE ONE, ZERO
C
      COMMON /DVOD01/ ACNRM, CCMXJ, CONP, CRATE, DRC, EL(13),
     1                ETA, ETAMAX, H, HMIN, HMXI, HNEW, HSCAL, PRL1,
     2                RC, RL1, TAU(13), TQ(5), TN, UROUND,
     3                ICF, INIT, IPUP, JCUR, JSTART, JSV, KFLAG, KUTH,
     4                L, LMAX, LYH, LEWT, LACOR, LSAVF, LWM, LIWM,
     5                LOCJS, MAXORD, METH, MITER, MSBJ, MXHNIL, MXSTEP,
     6                N, NEWH, NEWQ, NHNIL, NQ, NQNYH, NQWAIT, NSLJ,
     7                NSLP, NYH
C
      DATA ONE /1.0D0/, ZERO /0.0D0/
C
      IERSL = 0
      GO TO (100, 100, 300, 400, 400), MITER

 100  CALL DGESL (WM(3), N, N, IWM(31), X, 0)
      RETURN
C
 300  PHRL1 = WM(2)
      HRL1 = H*RL1
      WM(2) = HRL1
      IF (HRL1 .EQ. PHRL1) GO TO 330

      R = HRL1/PHRL1
      DO 320 I = 1,N
        DI = ONE - R*(ONE - ONE/WM(I+2))
        IF (ABS(DI) .EQ. ZERO) GO TO 390
 320    WM(I+2) = ONE/DI
C
 330  DO 340 I = 1,N
 340    X(I) = WM(I+2)*X(I)
      RETURN
 390  IERSL = 1
      RETURN
C

 400  ML = IWM(1)
      MU = IWM(2)
      MEBAND = 2*ML + MU + 1
      CALL DGBSL (WM(3), MEBAND, N, ML, MU, IWM(31), X, 0)
      RETURN
C----------------------- End of Subroutine DVSOL -----------------------
      END
*DECK DVSRCO
      SUBROUTINE DVSRCO (RSAV, ISAV, JOB)
      DOUBLE PRECISION RSAV
      INTEGER ISAV, JOB
      DIMENSION RSAV(*), ISAV(*)
C-----------------------------------------------------------------------
C Call sequence input -- RSAV, ISAV, JOB
C Call sequence output -- RSAV, ISAV
C COMMON block variables accessed -- All of /DVOD01/ and /DVOD02/
C
C Subroutines/functions called by DVSRCO.. None
C-----------------------------------------------------------------------
C This routine saves or restores (depending on JOB) the contents of the
C COMMON blocks DVOD01 and DVOD02, which are used internally by DVODE.
C
C RSAV = real array of length 49 or more.
C ISAV = integer array of length 41 or more.
C JOB  = flag indicating to save or restore the COMMON blocks..
C        JOB  = 1 if COMMON is to be saved (written to RSAV/ISAV).
C        JOB  = 2 if COMMON is to be restored (read from RSAV/ISAV).

C        A call with JOB = 2 presumes a prior call with JOB = 1.
C-----------------------------------------------------------------------
      DOUBLE PRECISION RVOD1, RVOD2

      INTEGER IVOD1, IVOD2
      INTEGER I, LENIV1, LENIV2, LENRV1, LENRV2
C-----------------------------------------------------------------------
C The following Fortran-77 declaration is to cause the values of the
C listed (local) variables to be saved between calls to this integrator.
C-----------------------------------------------------------------------

      SAVE LENRV1, LENIV1, LENRV2, LENIV2
C
      COMMON /DVOD01/ RVOD1(48), IVOD1(33)
      COMMON /DVOD02/ RVOD2(1), IVOD2(8)
      DATA LENRV1/48/, LENIV1/33/, LENRV2/1/, LENIV2/8/
C
      IF (JOB .EQ. 2) GO TO 100
      DO 10 I = 1,LENRV1
 10     RSAV(I) = RVOD1(I)
      DO 15 I = 1,LENRV2
 15     RSAV(LENRV1+I) = RVOD2(I)
C
      DO 20 I = 1,LENIV1
 20     ISAV(I) = IVOD1(I)

      DO 25 I = 1,LENIV2
 25     ISAV(LENIV1+I) = IVOD2(I)
C
      RETURN
C

 100  CONTINUE
      DO 110 I = 1,LENRV1
 110     RVOD1(I) = RSAV(I)

      DO 115 I = 1,LENRV2
 115     RVOD2(I) = RSAV(LENRV1+I)
C
      DO 120 I = 1,LENIV1
 120     IVOD1(I) = ISAV(I)
      DO 125 I = 1,LENIV2
 125     IVOD2(I) = ISAV(LENIV1+I)
C

      RETURN
C----------------------- End of Subroutine DVSRCO ----------------------
      END
*DECK DEWSET
      SUBROUTINE DEWSET (N, ITOL, RTOL, ATOL, YCUR, EWT)
      DOUBLE PRECISION RTOL, ATOL, YCUR, EWT
      INTEGER N, ITOL
      DIMENSION RTOL(*), ATOL(*), YCUR(N), EWT(N)
C-----------------------------------------------------------------------

C Call sequence input -- N, ITOL, RTOL, ATOL, YCUR


C Call sequence output -- EWT
C COMMON block variables accessed -- None

C
C Subroutines/functions called by DEWSET.. None

C-----------------------------------------------------------------------
C This subroutine sets the error weight vector EWT according to
C     EWT(i) = RTOL(i)*abs(YCUR(i)) + ATOL(i),  i = 1,...,N,
C with the subscript on RTOL and/or ATOL possibly replaced by 1 above,
C depending on the value of ITOL.
C-----------------------------------------------------------------------
      INTEGER I
C
      GO TO (10, 20, 30, 40), ITOL

 10   CONTINUE
      DO 15 I = 1, N
 15     EWT(I) = RTOL(1)*ABS(YCUR(I)) + ATOL(1)
      RETURN
 20   CONTINUE
      DO 25 I = 1, N
 25     EWT(I) = RTOL(1)*ABS(YCUR(I)) + ATOL(I)
      RETURN

 30   CONTINUE
      DO 35 I = 1, N
 35     EWT(I) = RTOL(I)*ABS(YCUR(I)) + ATOL(1)
      RETURN
 40   CONTINUE

      DO 45 I = 1, N
 45     EWT(I) = RTOL(I)*ABS(YCUR(I)) + ATOL(I)
      RETURN
C----------------------- End of Subroutine DEWSET ----------------------
      END
*DECK DVNORM
      DOUBLE PRECISION FUNCTION DVNORM (N, V, W)

      DOUBLE PRECISION V, W
      INTEGER N

      DIMENSION V(N), W(N)
C-----------------------------------------------------------------------
C Call sequence input -- N, V, W
C Call sequence output -- None
C COMMON block variables accessed -- None
C
C Subroutines/functions called by DVNORM.. None
C-----------------------------------------------------------------------
C This function routine computes the weighted root-mean-square norm
C of the vector of length N contained in the array V, with weights
C contained in the array W of length N..
C   DVNORM = sqrt( (1/N) * sum( V(i)*W(i) )**2 )
C-----------------------------------------------------------------------
      DOUBLE PRECISION SUM
      INTEGER I
C
      SUM = 0.0D0
      DO 10 I = 1, N
 10     SUM = SUM + (V(I)*W(I))**2
      DVNORM = SQRT(SUM/REAL(N))
      RETURN
C----------------------- End of Function DVNORM ------------------------
      END
*DECK D1MACH
      DOUBLE PRECISION FUNCTION D1MACH (IDUM)
      INTEGER IDUM
C-----------------------------------------------------------------------
C This routine computes the unit roundoff of the machine.
C This is defined as the smallest positive machine number
C u such that  1.0 + u .ne. 1.0
C
C Subroutines/functions called by D1MACH.. None
C-----------------------------------------------------------------------
      DOUBLE PRECISION U, COMP
      U = 1.0D0
 10   U = U*0.5D0
      COMP = 1.0D0 + U
      IF (COMP .NE. 1.0D0) GO TO 10
      D1MACH = U*2.0D0
      RETURN
C----------------------- End of Function D1MACH ------------------------
      END
*DECK XERRWD
      SUBROUTINE XERRWD (MSG, NMES, NERR, LEVEL, NI, I1, I2, NR, R1, R2)
      DOUBLE PRECISION R1, R2
      INTEGER NMES, NERR, LEVEL, NI, I1, I2, NR
      CHARACTER*1 MSG(NMES)
      CHARACTER ERRFIL*20



      COMMON/ERROR/ERRFIL
C  COMMON/ERROR/ IS SUPPLIED TO ALL THE ROUTINES WHICH COULD WRITE TO
C  ERRFIL.

	COMMON/NXER/NXE
C  NXE (NO. OF CALLS TO THIS ROUTINE) IS PASSED BACK TO MAIN FOR
C  WRITING TO THE SCREEN.


C-----------------------------------------------------------------------
C Subroutines XERRWD, XSETF, XSETUN, and the two function routines
C MFLGSV and LUNSAV, as given here, constitute a simplified version of
C the SLATEC error handling package.
C Written by A. C. Hindmarsh and P. N. Brown at LLNL.
C Version of 13 April, 1989.
C This version is in double precision.
C
C All arguments are input arguments.

C
C MSG    = The message (character array).
C NMES   = The length of MSG (number of characters).
C NERR   = The error number (not used).
C LEVEL  = The error level..

C          0 or 1 means recoverable (control returns to caller).
C          2 means fatal (run is aborted--see note below).
C NI     = Number of integers (0, 1, or 2) to be printed with message.
C I1,I2  = Integers to be printed, depending on NI.
C NR     = Number of reals (0, 1, or 2) to be printed with message.
C R1,R2  = Reals to be printed, depending on NR.
C
C Note..  this routine is machine-dependent and specialized for use
C in limited context, in the following ways..
C 1. The argument MSG is assumed to be of type CHARACTER, and
C    the message is printed with a format of (1X,80A1).

C 2. The message is assumed to take only one line.
C    Multi-line messages are generated by repeated calls.

C 3. If LEVEL = 2, control passes to the statement   STOP
C    to abort the run.  This statement may be machine-dependent.
C 4. R1 and R2 are assumed to be in double precision and are printed
C    in D21.13 format.
C
C For a different default logical unit number, change the data
C statement in function routine LUNSAV.
C For a different run-abort command, change the statement following
C statement 100 at the end.
C-----------------------------------------------------------------------
C Subroutines called by XERRWD.. None
C Function routines called by XERRWD.. MFLGSV, LUNSAV
C-----------------------------------------------------------------------
C
      INTEGER I, LUNIT, LUNSAV, MESFLG, MFLGSV

C  SKIP ALL ERROR MESSAGES, SIMPLY GO TO LABEL 100. BUT KEEP A RUNNING
C  TOTAL OF CALLS TO THIS ROUTINE, NXE, AND RETURN IT TO MAIN FOR
C  OUTPUT.

	NXE = NXE + 1
	GO TO 100



C Get message print flag and logical unit number. ----------------------
      MESFLG = MFLGSV (0,.FALSE.)

      LUNIT = LUNSAV (0,.FALSE.)
      IF (MESFLG .EQ. 0) GO TO 100
C Write the message. ---------------------------------------------------
      WRITE (LUNIT,10) (MSG(I),I=1,NMES)
 10   FORMAT(1X,80A1)
      IF (NI .EQ. 1) WRITE (LUNIT, 20) I1
 20   FORMAT(6X,'In above message,  I1 =',I10)


      IF (NI .EQ. 2) WRITE (LUNIT, 30) I1,I2
 30   FORMAT(6X,'In above message,  I1 =',I10,3X,'I2 =',I10)
      IF (NR .EQ. 1) WRITE (LUNIT, 40) R1
 40   FORMAT(6X,'In above message,  R1 =',D21.13)
      IF (NR .EQ. 2) WRITE (LUNIT, 50) R1,R2
 50   FORMAT(6X,'In above,  R1 =',D21.13,3X,'R2 =',D21.13)
C Abort the run if LEVEL = 2. ------------------------------------------
 100  IF (LEVEL .NE. 2) RETURN

C  SINCE THE PROGRAM IS TERMINATING ABNORMALLY, WRITE THE ERROR MESSAGE
C  TO ERRFIL ALSO.

        OPEN(42,FILE=ERRFIL)
         WRITE(42,51)
   51    FORMAT(/' LEVEL 2 (FATAL) IN SUBROUTINE XERRWD. '/)
        CLOSE(42)



      CALL PAUSE
      STOP

C----------------------- End of Subroutine XERRWD ----------------------
      END
*DECK XSETF
      SUBROUTINE XSETF (MFLAG)

C-----------------------------------------------------------------------
C This routine resets the print control flag MFLAG.
C
C Subroutines called by XSETF.. None
C Function routines called by XSETF.. MFLGSV
C-----------------------------------------------------------------------
      INTEGER MFLAG, JUNK, MFLGSV
C
      IF (MFLAG .EQ. 0 .OR. MFLAG .EQ. 1) JUNK = MFLGSV (MFLAG,.TRUE.)
      RETURN

C----------------------- End of Subroutine XSETF -----------------------
      END
*DECK XSETUN
      SUBROUTINE XSETUN (LUN)
C-----------------------------------------------------------------------
C This routine resets the logical unit number for messages.
C
C Subroutines called by XSETUN.. None
C Function routines called by XSETUN.. LUNSAV
C-----------------------------------------------------------------------
      INTEGER LUN, JUNK, LUNSAV
C
      IF (LUN .GT. 0) JUNK = LUNSAV (LUN,.TRUE.)
      RETURN
C----------------------- End of Subroutine XSETUN ----------------------
      END
*DECK MFLGSV
      INTEGER FUNCTION MFLGSV (IVALUE, ISET)
      LOGICAL ISET
      INTEGER IVALUE
C-----------------------------------------------------------------------
C MFLGSV saves and recalls the parameter MESFLG which controls the

C printing of the error messages.
C
C Saved local variable..
C
C   MESFLG = Print control flag..
C            1 means print all messages (the default).
C            0 means no printing.
C
C On input..
C
C   IVALUE = The value to be set for the MESFLG parameter,
C            if ISET is .TRUE. .
C

C   ISET   = Logical flag to indicate whether to read or write.
C            If ISET=.TRUE., the MESFLG parameter will be given
C            the value IVALUE.  If ISET=.FALSE., the MESFLG
C            parameter will be unchanged, and IVALUE is a dummy

C            parameter.
C
C On return..
C
C   The (old) value of the MESFLG parameter will be returned
C   in the function value, MFLGSV.
C
C This is a modification of the SLATEC library routine J4SAVE.

C
C Subroutines/functions called by MFLGSV.. None

C-----------------------------------------------------------------------
      INTEGER MESFLG
C-----------------------------------------------------------------------
C The following Fortran-77 declaration is to cause the values of the
C listed (local) variables to be saved between calls to this integrator.
C-----------------------------------------------------------------------
      SAVE MESFLG
      DATA MESFLG/1/
C
      MFLGSV = MESFLG
      IF (ISET) MESFLG = IVALUE
      RETURN
C----------------------- End of Function MFLGSV ------------------------
      END
*DECK LUNSAV
      INTEGER FUNCTION LUNSAV (IVALUE, ISET)
      LOGICAL ISET
      INTEGER IVALUE
C-----------------------------------------------------------------------
C LUNSAV saves and recalls the parameter LUNIT which is the logical
C unit number to which error messages are printed.
C
C Saved local variable..
C
C  LUNIT   = Logical unit number for messages.
C            The default is 6 (machine-dependent).

C
C On input..
C
C   IVALUE = The value to be set for the LUNIT parameter,
C            if ISET is .TRUE. .
C
C   ISET   = Logical flag to indicate whether to read or write.
C            If ISET=.TRUE., the LUNIT parameter will be given
C            the value IVALUE.  If ISET=.FALSE., the LUNIT
C            parameter will be unchanged, and IVALUE is a dummy
C            parameter.
C
C On return..
C
C   The (old) value of the LUNIT parameter will be returned
C   in the function value, LUNSAV.
C
C This is a modification of the SLATEC library routine J4SAVE.
C
C Subroutines/functions called by LUNSAV.. None
C-----------------------------------------------------------------------
      INTEGER LUNIT
C-----------------------------------------------------------------------
C The following Fortran-77 declaration is to cause the values of the
C listed (local) variables to be saved between calls to this integrator.
C-----------------------------------------------------------------------

      SAVE LUNIT
      DATA LUNIT/6/
C
      LUNSAV = LUNIT
      IF (ISET) LUNIT = IVALUE
      RETURN
C----------------------- End of Function LUNSAV ------------------------
      END
 
C***********************************************************************

C***********************************************************************
 
C  VODEXT.FOR IS SIMPLY A CONCATENATION OF 9 MODULES NEEDED BY
C  VODE.FOR. THEY ARE FOUND IN  ftp.netlib.org  on the web.
 
C  In \BLAS
c	DCOPY.F  DSCAL.F  DAXPY.F  DDOT.F  IDAMAX.F
 
C  In \LINPACK
c  	DGEFA.F  DGESL.F  DGBFA.F  DGBSL.F
 
C  ALL ABOVE MODULES HAVE BEEN COPIED INTO FILES WITH EXTENSION .FOR.
 
 

C-----------------------------------------------------------------------
 
      subroutine dgefa(a,lda,n,ipvt,info)
      integer lda,n,ipvt(1),info
      double precision a(lda,1)
c
c     dgefa factors a double precision matrix by gaussian elimination.
c
c     dgefa is usually called by dgeco, but it can be called
c     directly with a saving in time if  rcond  is not needed.
c     (time for dgeco) = (1 + 9/n)*(time for dgefa) .
c
c     on entry
c
c        a       double precision(lda, n)
c                the matrix to be factored.

c
c        lda     integer
c                the leading dimension of the array  a .
c
c        n       integer
c                the order of the matrix  a .
c
c     on return
c
c        a       an upper triangular matrix and the multipliers
c                which were used to obtain it.
c                the factorization can be written  a = l*u  where
c                l  is a product of permutation and unit lower
c                triangular matrices and  u  is upper triangular.
c
c        ipvt    integer(n)
c                an integer vector of pivot indices.
c
c        info    integer
c                = 0  normal value.
c                = k  if  u(k,k) .eq. 0.0 .  this is not an error
c                     condition for this subroutine, but it does
c                     indicate that dgesl or dgedi will divide by zero
c                     if called.  use  rcond  in dgeco for a reliable
c                     indication of singularity.
c

c     linpack. this version dated 08/14/78 .

c     cleve moler, university of new mexico, argonne national lab.
c
c     subroutines and functions
c
c     blas daxpy,dscal,idamax

c
c     internal variables
c
      double precision t
      integer idamax,j,k,kp1,l,nm1
c
c
c     gaussian elimination with partial pivoting
c
      info = 0
      nm1 = n - 1
      if (nm1 .lt. 1) go to 70
      do 60 k = 1, nm1
         kp1 = k + 1
c


c        find l = pivot index
c
         l = idamax(n-k+1,a(k,k),1) + k - 1
         ipvt(k) = l
c
c        zero pivot implies this column already triangularized
c
         if (a(l,k) .eq. 0.0d0) go to 40
c
c           interchange if necessary

c
            if (l .eq. k) go to 10
               t = a(l,k)
               a(l,k) = a(k,k)
               a(k,k) = t
   10       continue
c
c           compute multipliers
c
            t = -1.0d0/a(k,k)
            call dscal(n-k,t,a(k+1,k),1)
c
c           row elimination with column indexing
c
            do 30 j = kp1, n
               t = a(l,j)
               if (l .eq. k) go to 20

                  a(l,j) = a(k,j)
                  a(k,j) = t

   20          continue
               call daxpy(n-k,t,a(k+1,k),1,a(k+1,j),1)
   30       continue
         go to 50
   40    continue
            info = k
   50    continue
   60 continue

   70 continue
      ipvt(n) = n
      if (a(n,n) .eq. 0.0d0) info = n
      return

      end
 
C-----------------------------------------------------------------------
 
      subroutine dgesl(a,lda,n,ipvt,b,job)
      integer lda,n,ipvt(1),job

      double precision a(lda,1),b(1)
c
c     dgesl solves the double precision system
c     a * x = b  or  trans(a) * x = b
c     using the factors computed by dgeco or dgefa.

c
c     on entry
c
c        a       double precision(lda, n)
c                the output from dgeco or dgefa.
c
c        lda     integer
c                the leading dimension of the array  a .
c
c        n       integer
c                the order of the matrix  a .
c
c        ipvt    integer(n)
c                the pivot vector from dgeco or dgefa.
c
c        b       double precision(n)
c                the right hand side vector.

c
c        job     integer
c                = 0         to solve  a*x = b ,

c                = nonzero   to solve  trans(a)*x = b  where
c                            trans(a)  is the transpose.
c
c     on return
c

c        b       the solution vector  x .
c
c     error condition
c
c        a division by zero will occur if the input factor contains a
c        zero on the diagonal.  technically this indicates singularity
c        but it is often caused by improper arguments or improper
c        setting of lda .  it will not occur if the subroutines are
c        called correctly and if dgeco has set rcond .gt. 0.0
c        or dgefa has set info .eq. 0 .
c
c     to compute  inverse(a) * c  where  c  is a matrix
c     with  p  columns

c           call dgeco(a,lda,n,ipvt,rcond,z)
c           if (rcond is too small) go to ...
c           do 10 j = 1, p
c              call dgesl(a,lda,n,ipvt,c(1,j),0)
c        10 continue
c
c     linpack. this version dated 08/14/78 .
c     cleve moler, university of new mexico, argonne national lab.
c
c     subroutines and functions
c
c     blas daxpy,ddot
c
c     internal variables

c
      double precision ddot,t
      integer k,kb,l,nm1
c
      nm1 = n - 1
      if (job .ne. 0) go to 50
c
c        job = 0 , solve  a * x = b
c        first solve  l*y = b
c
         if (nm1 .lt. 1) go to 30
         do 20 k = 1, nm1

            l = ipvt(k)
            t = b(l)
            if (l .eq. k) go to 10
               b(l) = b(k)
               b(k) = t
   10       continue
            call daxpy(n-k,t,a(k+1,k),1,b(k+1),1)
   20    continue
   30    continue

c
c        now solve  u*x = y
c
         do 40 kb = 1, n
            k = n + 1 - kb
            b(k) = b(k)/a(k,k)

            t = -b(k)
            call daxpy(k-1,t,a(1,k),1,b(1),1)

   40    continue
      go to 100
   50 continue
c
c        job = nonzero, solve  trans(a) * x = b
c        first solve  trans(u)*y = b

c
         do 60 k = 1, n
            t = ddot(k-1,a(1,k),1,b(1),1)
            b(k) = (b(k) - t)/a(k,k)
   60    continue
c

c        now solve trans(l)*x = y
c
         if (nm1 .lt. 1) go to 90
         do 80 kb = 1, nm1
            k = n - kb
            b(k) = b(k) + ddot(n-k,a(k+1,k),1,b(k+1),1)
            l = ipvt(k)
            if (l .eq. k) go to 70
               t = b(l)
               b(l) = b(k)
               b(k) = t
   70       continue
   80    continue
   90    continue
  100 continue
      return
      end

 
C-----------------------------------------------------------------------
 
      subroutine dgbfa(abd,lda,n,ml,mu,ipvt,info)
      integer lda,n,ml,mu,ipvt(1),info
      double precision abd(lda,1)
c
c     dgbfa factors a double precision band matrix by elimination.
c
c     dgbfa is usually called by dgbco, but it can be called
c     directly with a saving in time if  rcond  is not needed.
c
c     on entry
c
c        abd     double precision(lda, n)
c                contains the matrix in band storage.  the columns
c                of the matrix are stored in the columns of  abd  and
c                the diagonals of the matrix are stored in rows
c                ml+1 through 2*ml+mu+1 of  abd .
c                see the comments below for details.
c
c        lda     integer
c                the leading dimension of the array  abd .
c                lda must be .ge. 2*ml + mu + 1 .
c
c        n       integer
c                the order of the original matrix.
c
c        ml      integer
c                number of diagonals below the main diagonal.
c                0 .le. ml .lt. n .
c
c        mu      integer
c                number of diagonals above the main diagonal.
c                0 .le. mu .lt. n .
c                more efficient if  ml .le. mu .
c     on return
c
c        abd     an upper triangular matrix in band storage and
c                the multipliers which were used to obtain it.
c                the factorization can be written  a = l*u  where
c                l  is a product of permutation and unit lower
c                triangular matrices and  u  is upper triangular.
c
c        ipvt    integer(n)
c                an integer vector of pivot indices.
c
c        info    integer
c                = 0  normal value.
c                = k  if  u(k,k) .eq. 0.0 .  this is not an error
c                     condition for this subroutine, but it does


c                     indicate that dgbsl will divide by zero if
c                     called.  use  rcond  in dgbco for a reliable
c                     indication of singularity.
c
c     band storage
c
c           if  a  is a band matrix, the following program segment
c           will set up the input.
c
c                   ml = (band width below the diagonal)
c                   mu = (band width above the diagonal)
c                   m = ml + mu + 1
c                   do 20 j = 1, n
c                      i1 = max0(1, j-mu)
c                      i2 = min0(n, j+ml)
c                      do 10 i = i1, i2
c                         k = i - j + m
c                         abd(k,j) = a(i,j)
c                10    continue
c                20 continue
c
c           this uses rows  ml+1  through  2*ml+mu+1  of  abd .
c           in addition, the first  ml  rows in  abd  are used for
c           elements generated during the triangularization.
c           the total number of rows needed in  abd  is  2*ml+mu+1 .
c           the  ml+mu by ml+mu  upper left triangle and the
c           ml by ml  lower right triangle are not referenced.
c
c     linpack. this version dated 08/14/78 .
c     cleve moler, university of new mexico, argonne national lab.
c
c     subroutines and functions
c
c     blas daxpy,dscal,idamax
c     fortran max0,min0
c
c     internal variables
c
      double precision t
      integer i,idamax,i0,j,ju,jz,j0,j1,k,kp1,l,lm,m,mm,nm1
c
c
      m = ml + mu + 1


      info = 0
c
c     zero initial fill-in columns
c

      j0 = mu + 2
      j1 = min0(n,m) - 1

      if (j1 .lt. j0) go to 30
      do 20 jz = j0, j1
         i0 = m + 1 - jz
         do 10 i = i0, ml
            abd(i,jz) = 0.0d0
   10    continue
   20 continue
   30 continue
      jz = j1
      ju = 0


c
c     gaussian elimination with partial pivoting
c
      nm1 = n - 1
      if (nm1 .lt. 1) go to 130
      do 120 k = 1, nm1
         kp1 = k + 1
c
c        zero next fill-in column
c
         jz = jz + 1
         if (jz .gt. n) go to 50
         if (ml .lt. 1) go to 50
            do 40 i = 1, ml
               abd(i,jz) = 0.0d0
   40       continue
   50    continue
c
c        find l = pivot index
c


         lm = min0(ml,n-k)
         l = idamax(lm+1,abd(m,k),1) + m - 1
         ipvt(k) = l + k - m
c
c        zero pivot implies this column already triangularized
c
         if (abd(l,k) .eq. 0.0d0) go to 100
c
c           interchange if necessary
c
            if (l .eq. m) go to 60
               t = abd(l,k)
               abd(l,k) = abd(m,k)
               abd(m,k) = t
   60       continue
c
c           compute multipliers

c
            t = -1.0d0/abd(m,k)
            call dscal(lm,t,abd(m+1,k),1)
c
c           row elimination with column indexing
c
            ju = min0(max0(ju,mu+ipvt(k)),n)

            mm = m
            if (ju .lt. kp1) go to 90
            do 80 j = kp1, ju
               l = l - 1
               mm = mm - 1
               t = abd(l,j)
               if (l .eq. mm) go to 70


                  abd(l,j) = abd(mm,j)
                  abd(mm,j) = t
   70          continue
               call daxpy(lm,t,abd(m+1,k),1,abd(mm+1,j),1)
   80       continue
   90       continue
         go to 110
  100    continue
            info = k
  110    continue
  120 continue
  130 continue
      ipvt(n) = n
      if (abd(m,n) .eq. 0.0d0) info = n

      return
      end
 
C-----------------------------------------------------------------------
 
      subroutine dgbsl(abd,lda,n,ml,mu,ipvt,b,job)
      integer lda,n,ml,mu,ipvt(1),job
      double precision abd(lda,1),b(1)
c

c     dgbsl solves the double precision band system
c     a * x = b  or  trans(a) * x = b
c     using the factors computed by dgbco or dgbfa.
c

c     on entry
c
c        abd     double precision(lda, n)
c                the output from dgbco or dgbfa.
c
c        lda     integer
c                the leading dimension of the array  abd .

c
c        n       integer
c                the order of the original matrix.

c
c        ml      integer
c                number of diagonals below the main diagonal.
c
c        mu      integer
c                number of diagonals above the main diagonal.
c
c        ipvt    integer(n)
c                the pivot vector from dgbco or dgbfa.
c
c        b       double precision(n)
c                the right hand side vector.
c
c        job     integer
c                = 0         to solve  a*x = b ,
c                = nonzero   to solve  trans(a)*x = b , where
c                            trans(a)  is the transpose.

c
c     on return
c
c        b       the solution vector  x .
c

c     error condition
c

c        a division by zero will occur if the input factor contains a
c        zero on the diagonal.  technically this indicates singularity
c        but it is often caused by improper arguments or improper
c        setting of lda .  it will not occur if the subroutines are
c        called correctly and if dgbco has set rcond .gt. 0.0
c        or dgbfa has set info .eq. 0 .
c
c     to compute  inverse(a) * c  where  c  is a matrix
c     with  p  columns
c           call dgbco(abd,lda,n,ml,mu,ipvt,rcond,z)

c           if (rcond is too small) go to ...
c           do 10 j = 1, p
c              call dgbsl(abd,lda,n,ml,mu,ipvt,c(1,j),0)
c        10 continue
c
c     linpack. this version dated 08/14/78 .
c     cleve moler, university of new mexico, argonne national lab.
c
c     subroutines and functions

c
c     blas daxpy,ddot
c     fortran min0
c
c     internal variables
c
      double precision ddot,t
      integer k,kb,l,la,lb,lm,m,nm1
c
      m = mu + ml + 1
      nm1 = n - 1
      if (job .ne. 0) go to 50
c
c        job = 0 , solve  a * x = b
c        first solve l*y = b
c
         if (ml .eq. 0) go to 30

         if (nm1 .lt. 1) go to 30
            do 20 k = 1, nm1
               lm = min0(ml,n-k)
               l = ipvt(k)
               t = b(l)

               if (l .eq. k) go to 10
                  b(l) = b(k)
                  b(k) = t
   10          continue
               call daxpy(lm,t,abd(m+1,k),1,b(k+1),1)

   20       continue
   30    continue
c
c        now solve  u*x = y
c


         do 40 kb = 1, n
            k = n + 1 - kb
            b(k) = b(k)/abd(m,k)
            lm = min0(k,m) - 1
            la = m - lm
            lb = k - lm
            t = -b(k)
            call daxpy(lm,t,abd(la,k),1,b(lb),1)
   40    continue

      go to 100
   50 continue
c

c        job = nonzero, solve  trans(a) * x = b
c        first solve  trans(u)*y = b
c

         do 60 k = 1, n

            lm = min0(k,m) - 1
            la = m - lm
            lb = k - lm
            t = ddot(lm,abd(la,k),1,b(lb),1)
            b(k) = (b(k) - t)/abd(m,k)
   60    continue
c
c        now solve trans(l)*x = y

c
         if (ml .eq. 0) go to 90
         if (nm1 .lt. 1) go to 90
            do 80 kb = 1, nm1

               k = n - kb
               lm = min0(ml,n-k)
               b(k) = b(k) + ddot(lm,abd(m+1,k),1,b(k+1),1)
               l = ipvt(k)
               if (l .eq. k) go to 70
                  t = b(l)
                  b(l) = b(k)
                  b(k) = t
   70          continue
   80       continue

   90    continue
  100 continue
      return

      end


      subroutine checkd(corden,new,nactveold,ab,maxgrd,nvar,iclose)
      implicit real*8 (a-h,o-z)
      real*8 ab(30,2), corden(maxgrd,1)
      iclose=0
      do ibas=1,nactveold
       sum=0.

       do i=1,nvar
       sum=sum+abs(corden(new,i)-corden(ibas,i))/(ab(i,2)-ab(i,1))
       enddo
      if(sum.le.1.d-4) then
      iclose=1
      return
      endif
      enddo
      return
      end


      subroutine emint(psi,ldpsi,theta,ldtheta,npoint,nsub,ijob,
     &                 x,dx,y,dy,fobj,gap,nvar,keep)
      implicit real*8 (a-h,o-z)
      real*8 mu
      dimension psi(ldpsi,*),theta(ldtheta,*),x(*),dx(*),y(*),dy(*)

      CHARACTER ERRFIL*20



      COMMON/ERROR/ERRFIL
C  COMMON/ERROR/ IS SUPPLIED TO ALL THE ROUTINES WHICH COULD WRITE TO
C  ERRFIL.


	COMMON/SUPRES/ISUPRES
C  COMMON/SUPRES IS SUPPLIED FROM SUBROUTINE BIGNPAG.

c This subroutine solves the 'EM' problem of maximizing the function
 
c   fobj(x) = sum_i (log[sum_j ( psi(i,j) * x(j)) ]  ),
c             j=1,..,npoint and i=1,...,nsub
c   subject to: x(j) >= 0, sum_j x(j) = 1 (i.e. x is a probability
c             vector of length npoint)
c   where psi(i,j) is a fixed non-negative data array representing the
c   likelihood of point j for subject i
 
c inputs: psi,ldpsi,npoint,nsub,nvar
c psi contains the likelihood vectors for each subject - the i-th
c row of psi is likelikhood vector for subject i.  Thus psi(i,j) is
c likelihood of the j-th point for c the i-th subject.  The input value
c ldpsi is the 'leading dimension of psi' - i.e. the first dimension of the
c array psi as dimensioned in the calling program.
c
c input work arrays: dx(*), y(*), dy(*) - should be at least large enough to
c contain npoint points, as should the probabiltiy array x(*)
c
c outputs: x(*), fobj
c x(i) is  final probability for point i
c fobj - optimal value of the objective function
 
c note - usually npoint is much larger than nsub; here we dimension

c some internal work arrays with the maximum expected number of subjects
c MAXSUBem and the maximum number of points MAXACTem
c are be set in the parameter statement
      parameter (MAXSUBem=999,MAXACTem=10000000)
      dimension w(MAXSUBem),dw(MAXSUBem),Ptx(MAXSUBem),
     &          hess(MAXSUBem,2*MAXSUBem)
      dimension psisum(MAXSUBem)

      integer kpvt(MAXSUBem), ipivot(MAXACTem), list(MAXACTem)
c here w(*) is a vector if `dual variables'
c dw(*) is a calculated change (as a Newton step) in w(*)
c Ptx(*) (Psi times x) is the vector Ptx(j) = sum_i Psi(j,i)*x(i)
c first , perform some dimension checks to make sure no internal dimensions
c are exceeded
      keep = nactve

      if(nsub.gt.MAXSUBem) then



      write(6,*) 'nsub =',nsub, ' is greater than MAXSUBem=',MAXSUBem
      write(6,*) 'MAXSUBem needs to be reset as large as nsub'
      write(6,*) 'in PARAMETER statement in subroutine emint'

C  SINCE THE PROGRAM IS TERMINATING ABNORMALLY, WRITE THE ERROR MESSAGE
C  TO ERRFIL ALSO.

        OPEN(42,FILE=ERRFIL)
      write(42,*) 'nsub =',nsub, ' is greater than MAXSUBem=',MAXSUBem
      write(42,*) 'MAXSUBem needs to be reset as large as nsub'
      write(42,*) 'in PARAMETER statement in subroutine emint'
        CLOSE(42)




      CALL PAUSE
      stop



      endif



      if(npoint.gt.MAXACTem) then



      write(6,*) 'npoint=',npoint,' is larger than MAXACTem=',MAXACTem
      write(6,*) 'MAXACTem needs to be reset as large as npoint'
      write(6,*) 'in PARAMETER statement in subroutine emint'

C  SINCE THE PROGRAM IS TERMINATING ABNORMALLY, WRITE THE ERROR MESSAGE
C  TO ERRFIL ALSO.

        OPEN(42,FILE=ERRFIL)
      write(42,*) 'npoint=',npoint,' is larger than MAXACTem=',MAXACTem
      write(42,*) 'MAXACTem needs to be reset as large as npoint'
      write(42,*) 'in PARAMETER statement in subroutine emint'
        CLOSE(42)



      CALL PAUSE
      stop



      endif



c     Second, check that psi is non-negative
      psimin=0.
      do j=1,nsub
      do i=1,npoint
      if(psi(j,i).le.psimin) psimin=psi(j,i)
      enddo
      enddo



      if(psimin.lt.0) then



	  write(6,*) 'Psi matrix not non-negative -stop'

C  SINCE THE PROGRAM IS TERMINATING ABNORMALLY, WRITE THE ERROR MESSAGE
C  TO ERRFIL ALSO.

        OPEN(42,FILE=ERRFIL)
	   write(42,*) 'Psi matrix not non-negative -stop'
        CLOSE(42)



	  CALL PAUSE
	  stop



      endif



c     Third,check that the row sums of psi are positive - no zero rows
c     also initialize x and w
      colsummin=1.e10
      do j=1,nsub
        s=0.
        do i=1,npoint
           x(i)=1.d0
           s=s+psi(j,i)
        enddo

      psisum(j) = s
        Ptx(j)=s
        if(s.le.colsummin) colsummin=s

        if(s.le.0) then



           write(6,*) 'psi has a zero row -stop'

C  SINCE THE PROGRAM IS TERMINATING ABNORMALLY, WRITE THE ERROR MESSAGE
C  TO ERRFIL ALSO.

        OPEN(42,FILE=ERRFIL)
	   write(42,*) 'psi has a zero row -stop'
        CLOSE(42)



	   CALL PAUSE
           stop



        endif



        w(j)=1./s
      enddo
c     calc ptw = w'*psi
      shrink=0.
      do i=1,npoint
        sum=0.d0
        do j=1,nsub
           sum=sum+psi(j,i)*w(j)
        enddo


        y(i)=sum
        if(sum.gt.shrink) shrink=sum
      enddo
      shrink=2.d0*shrink

      if(s.le.0) then



	  write(6,*) 'Psi has a zero column -stop'

C  SINCE THE PROGRAM IS TERMINATING ABNORMALLY, WRITE THE ERROR MESSAGE
C  TO ERRFIL ALSO.

        OPEN(42,FILE=ERRFIL)
	   write(42,*) 'Psi has a zero column -stop'

        CLOSE(42)



	  CALL PAUSE


	  stop



      endif

c     stopping tolerance
      eps=1.d-10
      sig=0.d0

      mu=0.d0
      do i=1,npoint
c       x = x*shrink;
        x(i)=1.d0*shrink
c       Ptw  = Ptw/shrink;
        y(i)=y(i)/shrink
c       y  = ecol-Ptw;
        y(i)=1.d0-y(i)
c       mu  =  (x'*y)/npoint;

        mu=mu+x(i)*y(i)
      enddo

      mu=mu/npoint
      rmax = -1.e38
      do j=1,nsub
c       w                       =  w/shrink;
        w(j)=w(j)/shrink
c       Plam            =  Plam*shrink;
        Ptx(j)=Ptx(j)*shrink
c
c       R =  erow-w.*Plam;
        if(dabs(1.d0-w(j)*Ptx(j)).ge.rmax) rmax =
     &  dabs(1.d0-w(j)*Ptx(j))
      enddo
      gap=1.d0
c start of iterations
      iter=0
100   continue
c     following is iteration termination condition
      if(mu.le.eps.and.rmax.le.eps.and.gap.le.eps) go to 9000

      iter=iter+1
      tbuilda=0
      smu=sig*mu

c     zero out hessian
      do j=1,nsub
        do k=1,nsub
           hess(j,k)=0.
        enddo
      enddo

c do outer product portion of Hessian
      do i=1,npoint
        scale=x(i)/y(i)
       do j=1,nsub
         fact=scale*psi(j,i)
         do k=j,nsub

           hess(k,j)=hess(k,j)+fact*psi(k,i)
         enddo
       enddo
      enddo
      do j=1,nsub-1
      do k=j+1,nsub
      hess(j,k)=hess(k,j)
      enddo
      enddo
c do diagonal portion of hessian
      do j=1,nsub
        hess(j,j)=hess(j,j)+Ptx(j)/w(j)
      enddo
      tbuildb=0
      tbuild=tbuildb-tbuilda

      IF(ISUPRES .EQ. 0) write(6,*) 'tbuild=',tbuild

c now do cholesky decomposition-for time bing, use simple dpofa
c from LINPACK
c     call dpofa(hess,MAXSUBem,nsub,info)
c     call dsifa(hess,MAXSUBem,nsub,kpvt,info)
c note dpofa is cholesky factorization routine from LINPACK
c      dsifa is symmetric indefintie factorization routine from LINAPCK
c      DPOTRF is Cholesky factorization routine from LAPACK
c DPOTRF is fastest of the three, but DSIFA may be more reliable for
c nearly singular cases
c Regardless of which of the three routines is used, it must be matched
c with the proper solve routine (dposl for dpofa, dsisl for dsifa, DPOTRS for DPOTRF


c below
      CALL DPOTRF( 'L', nsub, hess, MAXSUBem, INFO )
      tbuildc=0
      tfactor=tbuildc-tbuildb


      IF(ISUPRES .EQ. 0) write(6,*) 'tfactor=',tfactor

cdebugwrite(6,*) 'gap,info=',gap,info

      if(info.ne.0) then

      WRITE(*,163)
  163  FORMAT(//' Hessian matrix in interior point EM algorithm'/
     1' is singular.  Possibly number of grid points is too small,'/
     2' or assay coefficients are too large. '//
     3' Try again with a new assay polynomial or larger grid.'//
     4' Suggested quick fix: rerun and select error model 2)'/
     5' in response to the initial question; then enter a'/
     6' initial value gamma = 10.0 in response to the prompt for'/
     7' that value.'/)
   
C  AS of npageng23.f, SINCE THE PROGRAM IS TERMINATING ABNORMALLY, WRITE
C  THE ERROR MESSAGE TO ERRFIL ALSO.

        OPEN(42,FILE=ERRFIL)
         WRITE(42,163) 
        CLOSE(42)



      CALL PAUSE
      stop



      endif



c construct rhs for linear equation system
      do j=1,nsub
        sum=0.d0
        do i=1,npoint
          sum=sum+psi(j,i)*smu/y(i)
        enddo


        dw(j)=1.d0/w(j)-sum
      enddo

c now solve linear system with LINPACK routine dposl
c and put answer in dw
c note - these routines match the factor routines dpofa, dsifa, and DPOTRF, respectively
c see note about 15 lines back where the factor routine is called
c     call dposl(hess,MAXSUBem,nsub,dw)
c     call dsisl(hess,MAXSUBem,nsub,kpvt,dw)
      call DPOTRS( 'L', nsub, 1, hess, MAXSUBem, dw, nsub, INFO )
c now compute dy and dx from dw
      do i=1,npoint
        sum=0.
        do j=1,nsub
          sum=sum+psi(j,i)*dw(j)
        enddo

        dy(i)=-sum
        dx(i)=smu/y(i)-x(i)-dy(i)*x(i)/y(i)
      enddo
c damp the Newton step
      alfpri=-.5
      do i=1,npoint
        if(dx(i)/x(i).le.alfpri) alfpri=dx(i)/x(i)
      enddo
      alfpri=-1.d0/alfpri
      alfpri=min(1.d0,0.99995*alfpri)
      alfdual=-0.5d0
      do i=1,npoint
        if(dy(i)/y(i).le.alfdual) alfdual=dy(i)/y(i)
      enddo
      alfdual=-1.d0/alfdual
      alfdual=min(1.d0,0.99995*alfdual)
      mu=0.d0
      do i=1,npoint
        x(i)=x(i)+alfpri*dx(i)
        y(i)=y(i)+alfdual*dy(i)
        mu=mu+x(i)*y(i)
      enddo
      mu=mu/npoint
      do j=1,nsub
        sum=0.d0
        do i=1,npoint
          sum=sum+psi(j,i)*x(i)

        enddo
        Ptx(j)=sum
      enddo
      do j=1,nsub
        w(j)=w(j)+alfdual*dw(j)
      enddo
c compute rmax (norm(r,inf)-note we don't really need to compute r
      rmax=0.
      do j=1,nsub
        rtest=1.d0-w(j)*Ptx(j)

        if(dabs(rtest).gt.rmax) rmax=dabs(rtest)
      enddo
      sumlogw=0.d0
      sumlgPtx=0.d0
      do j=1,nsub
        sumlogw=sumlogw+dlog(w(j))
        sumlgPtx=sumlgPtx+dlog(Ptx(j))
      enddo
      gap = dabs(sumlogw+sumlgPtx)/(1.d0+dabs(sumlgPtx))


      if(mu.lt.eps.and.rmax.gt.eps) then

        sig=1.d0
      else
        c2=1.d2
        term1=(1.d0-alfpri)**2
        term2=(1.d0-alfdual)**2
        term3=(rmax-mu)/(rmax+c2*mu)
        term=max(term1,term2)
        term=max(term,term3)
        sig=min(0.3d0,term)
      endif
      sumx=0.d0
      do i=1,npoint
        sumx=sumx+x(i)
      enddo
      fobj=0.
      do j=1,nsub
        fobj=fobj+dlog(Ptx(j)/sumx)


      enddo
      go to 100
c following is exit point
9000  continue
c finish by normalizing x to sum to 1.
c fobj has already been computed
      sumx=0.
      do i=1,npoint
      sumx=sumx+x(i)
      enddo
      do i=1,npoint
      x(i)=x(i)/sumx
      enddo
c finished if ijob=0
      if(ijob.eq.0) return
      isum=0
      xlim=0.
      do i=1,npoint
      if(x(i).gt.xlim) xlim=x(i)
      enddo
      xlim=xlim*1.d-3
      isum = 0
      do i=1,npoint

      if(x(i).gt.xlim) then

        isum = isum + 1
        list(isum) = i
        do j=1,nsub
        psi(j,isum) = psi(j,i)
        enddo
cpull
c now condense the original density grid
      do j=1,nvar
      theta(isum,j)=theta(i,j)
      enddo
      x(isum)=x(i)
      endif
      enddo
      job=1
      do k=1,npoint
      ipivot(k)=0

      enddo
c save a copy of psi after current end of psi
      do i=1,isum
      do j=1,nsub
      psi(j,i+isum)=psi(j,i)
      enddo
      enddo
      do i=1,isum
      do j=1,nsub
      psi(j,i) = psi(j,i)/psisum(j)
      enddo
      enddo
      call dqrdc(psi,ldpsi,nsub,isum,y,ipivot,dy,job)
      keep = 0
      limloop = nsub
      if(isum.lt.nsub) limloop = isum
      do i=1,limloop
      test=dnrm2(i,psi(1,i),1)
cdebugwrite(6,*) i,psi(i,i),test,psi(i,i)/test
      if(dabs(psi(i,i)/test).ge.1.d-8) keep=keep+1
      enddo
c sort ipivot to avoid collisions during condensing
      if(isum.gt.1) then
      do i=1,keep-1
      do j=i,keep
      if(ipivot(i)*ipivot(j).ne.0.and.ipivot(i).gt.ipivot(j)) then
         itemp=ipivot(i)
         ipivot(i)=ipivot(j)
         ipivot(j)=itemp
      endif
      enddo
      enddo
      endif
      do i=1,isum
      do j=1,nsub
      psi(j,i)=psi(j,i+isum)
      enddo
      enddo
c restore psi

 
 
 
c     CALL PAUSE
      do k=1,npoint
      dx(k)=0
      enddo
      sumkeep = 0.
      do k=1,keep
      j=ipivot(k)
      if(j.ne.0) then
         do jj=1,nsub
         psi(jj,k)=psi(jj,j)
         enddo
      do jvar=1,nvar
      theta(k,jvar) = theta(j,jvar)
      enddo
      endif
      if(j.gt.0) dx(list(j))=1.
      if(j.gt.0) sumkeep = sumkeep + x(list(j))
      if(j.gt.0) w(k)=x(list(j))
      enddo
      return
      end
      subroutine dpoco(a,lda,n,rcond,z,info)
      integer lda,n,info
      double precision a(lda,1),z(1)
      double precision rcond
c
c     dpoco factors a double precision symmetric positive definite
c     matrix and estimates the condition of the matrix.

c
c     if  rcond  is not needed, dpofa is slightly faster.
c     to solve  a*x = b , follow dpoco by dposl.

c     to compute  inverse(a)*c , follow dpoco by dposl.
c     to compute  determinant(a) , follow dpoco by dpodi.
c     to compute  inverse(a) , follow dpoco by dpodi.
c
c     on entry
c
c        a       double precision(lda, n)
c                the symmetric matrix to be factored.  only the
c                diagonal and upper triangle are used.
c

c        lda     integer
c                the leading dimension of the array  a .
c
c        n       integer
c                the order of the matrix  a .

c
c     on return
c
c        a       an upper triangular matrix  r  so that  a = trans(r)*r
c                where  trans(r)  is the transpose.
c                the strict lower triangle is unaltered.
c                if  info .ne. 0 , the factorization is not complete.
c
c        rcond   double precision
c                an estimate of the reciprocal condition of  a .
c                for the system  a*x = b , relative perturbations
c                in  a  and  b  of size  epsilon  may cause
c                relative perturbations in  x  of size  epsilon/rcond .
c                if  rcond  is so small that the logical expression
c                           1.0 + rcond .eq. 1.0
c                is true, then  a  may be singular to working
c                precision.  in particular,  rcond  is zero  if
c                exact singularity is detected or the estimate
c                underflows.  if info .ne. 0 , rcond is unchanged.
c
c        z       double precision(n)
c                a work vector whose contents are usually unimportant.
c                if  a  is close to a singular matrix, then  z  is
c                an approximate null vector in the sense that
c                norm(a*z) = rcond*norm(a)*norm(z) .
c                if  info .ne. 0 , z  is unchanged.

c
c        info    integer
c                = 0  for normal return.
c                = k  signals an error condition.  the leading minor
c                     of order  k  is not positive definite.
c
c     linpack.  this version dated 08/14/78 .
c     cleve moler, university of new mexico, argonne national lab.
c

c     subroutines and functions

c
c     linpack dpofa
c     blas daxpy,ddot,dscal,dasum
c     fortran dabs,dmax1,dreal,dsign
c
c     internal variables
c
      double precision ddot,ek,t,wk,wkm
      double precision anorm,s,dasum,sm,ynorm
      integer i,j,jm1,k,kb,kp1
c
c
c     find norm of a using only upper half

c
      do 30 j = 1, n
         z(j) = dasum(j,a(1,j),1)
         jm1 = j - 1
         if (jm1 .lt. 1) go to 20
         do 10 i = 1, jm1
            z(i) = z(i) + dabs(a(i,j))
   10    continue
   20    continue

   30 continue
      anorm = 0.0d0
      do 40 j = 1, n
         anorm = dmax1(anorm,z(j))
   40 continue
c
c     factor
c
      call dpofa(a,lda,n,info)
      if (info .ne. 0) go to 180

c

c        rcond = 1/(norm(a)*(estimate of norm(inverse(a)))) .
c        estimate = norm(z)/norm(y) where  a*z = y  and  a*y = e .
c        the components of  e  are chosen to cause maximum local
c        growth in the elements of w  where  trans(r)*w = e .
c        the vectors are frequently rescaled to avoid overflow.
c
c        solve trans(r)*w = e
c
         ek = 1.0d0
         do 50 j = 1, n
            z(j) = 0.0d0
   50    continue
         do 110 k = 1, n
            if (z(k) .ne. 0.0d0) ek = dsign(ek,-z(k))
            if (dabs(ek-z(k)) .le. a(k,k)) go to 60
               s = a(k,k)/dabs(ek-z(k))
               call dscal(n,s,z,1)
               ek = s*ek
   60       continue

            wk = ek - z(k)
            wkm = -ek - z(k)
            s = dabs(wk)
            sm = dabs(wkm)

            wk = wk/a(k,k)

            wkm = wkm/a(k,k)
            kp1 = k + 1
            if (kp1 .gt. n) go to 100
               do 70 j = kp1, n
                  sm = sm + dabs(z(j)+wkm*a(k,j))
                  z(j) = z(j) + wk*a(k,j)
                  s = s + dabs(z(j))
   70          continue
               if (s .ge. sm) go to 90
                  t = wkm - wk
                  wk = wkm
                  do 80 j = kp1, n
                     z(j) = z(j) + t*a(k,j)
   80             continue
   90          continue
  100       continue
            z(k) = wk
  110    continue
         s = 1.0d0/dasum(n,z,1)
         call dscal(n,s,z,1)
c
c        solve r*y = w
c
         do 130 kb = 1, n
            k = n + 1 - kb
            if (dabs(z(k)) .le. a(k,k)) go to 120
               s = a(k,k)/dabs(z(k))
               call dscal(n,s,z,1)
  120       continue
            z(k) = z(k)/a(k,k)
            t = -z(k)
            call daxpy(k-1,t,a(1,k),1,z(1),1)
  130    continue
         s = 1.0d0/dasum(n,z,1)
         call dscal(n,s,z,1)
c
         ynorm = 1.0d0

c
c        solve trans(r)*v = y
c
         do 150 k = 1, n
            z(k) = z(k) - ddot(k-1,a(1,k),1,z(1),1)
            if (dabs(z(k)) .le. a(k,k)) go to 140
               s = a(k,k)/dabs(z(k))
               call dscal(n,s,z,1)
               ynorm = s*ynorm
  140       continue
            z(k) = z(k)/a(k,k)
  150    continue
         s = 1.0d0/dasum(n,z,1)
         call dscal(n,s,z,1)
         ynorm = s*ynorm
c
c        solve r*z = v
c
         do 170 kb = 1, n
            k = n + 1 - kb
            if (dabs(z(k)) .le. a(k,k)) go to 160
               s = a(k,k)/dabs(z(k))
               call dscal(n,s,z,1)
               ynorm = s*ynorm
  160       continue
            z(k) = z(k)/a(k,k)
            t = -z(k)
            call daxpy(k-1,t,a(1,k),1,z(1),1)
  170    continue
c        make znorm = 1.0
         s = 1.0d0/dasum(n,z,1)
         call dscal(n,s,z,1)
         ynorm = s*ynorm
c
         if (anorm .ne. 0.0d0) rcond = ynorm/anorm
         if (anorm .eq. 0.0d0) rcond = 0.0d0
  180 continue
      return
      end
      subroutine dpofa(a,lda,n,info)
      integer lda,n,info
      double precision a(lda,1)
c
c     dpofa factors a double precision symmetric positive definite
c     matrix.

c
c     dpofa is usually called by dpoco, but it can be called
c     directly with a saving in time if  rcond  is not needed.
c     (time for dpoco) = (1 + 18/n)*(time for dpofa) .
c
c     on entry
c
c        a       double precision(lda, n)


c                the symmetric matrix to be factored.  only the
c                diagonal and upper triangle are used.

c
c        lda     integer
c                the leading dimension of the array  a .
c
c        n       integer
c                the order of the matrix  a .
c
c     on return
c
c        a       an upper triangular matrix  r  so that  a = trans(r)*r
c                where  trans(r)  is the transpose.
c                the strict lower triangle is unaltered.
c                if  info .ne. 0 , the factorization is not complete.
c
c        info    integer
c                = 0  for normal return.

c                = k  signals an error condition.  the leading minor

c                     of order  k  is not positive definite.
c

c     linpack.  this version dated 08/14/78 .
c     cleve moler, university of new mexico, argonne national lab.
c
c     subroutines and functions
c
c     blas ddot
c     fortran dsqrt
c

c     internal variables
c
      double precision ddot,t
      double precision s
      integer j,jm1,k
c     begin block with ...exits to 40
c
c
         do 30 j = 1, n
            info = j
            s = 0.0d0
            jm1 = j - 1
            if (jm1 .lt. 1) go to 20
            do 10 k = 1, jm1

               t = a(k,j) - ddot(k-1,a(1,k),1,a(1,j),1)
               t = t/a(k,k)
               a(k,j) = t

               s = s + t*t
   10       continue
   20       continue

            s = a(j,j) - s

c     ......exit
            if (s .le. 0.0d0) go to 40


            a(j,j) = dsqrt(s)
   30    continue
         info = 0
   40 continue
      return
      end
      subroutine dposl(a,lda,n,b)
      integer lda,n


      double precision a(lda,1),b(1)
c
c     dposl solves the double precision symmetric positive definite
c     system a * x = b
c     using the factors computed by dpoco or dpofa.
c
c     on entry
c
c        a       double precision(lda, n)
c                the output from dpoco or dpofa.
c
c        lda     integer

c                the leading dimension of the array  a .
c
c        n       integer
c                the order of the matrix  a .
c
c        b       double precision(n)
c                the right hand side vector.
c
c     on return
c
c        b       the solution vector  x .
c
c     error condition
c
c        a division by zero will occur if the input factor contains
c        a zero on the diagonal.  technically this indicates
c        singularity but it is usually caused by improper subroutine
c        arguments.  it will not occur if the subroutines are called
c        correctly and  info .eq. 0 .
c
c     to compute  inverse(a) * c  where  c  is a matrix
c     with  p  columns
c           call dpoco(a,lda,n,rcond,z,info)
c           if (rcond is too small .or. info .ne. 0) go to ...
c           do 10 j = 1, p
c              call dposl(a,lda,n,c(1,j))
c        10 continue
c
c     linpack.  this version dated 08/14/78 .
c     cleve moler, university of new mexico, argonne national lab.
c


c     subroutines and functions
c
c     blas daxpy,ddot
c
c     internal variables
c
      double precision ddot,t
      integer k,kb
c
c     solve trans(r)*y = b
c
      do 10 k = 1, n
         t = ddot(k-1,a(1,k),1,b(1),1)
         b(k) = (b(k) - t)/a(k,k)
   10 continue
c
c     solve r*x = y
c
      do 20 kb = 1, n
         k = n + 1 - kb
         b(k) = b(k)/a(k,k)
         t = -b(k)
         call daxpy(k-1,t,a(1,k),1,b(1),1)
   20 continue
      return
      end
      subroutine dsifa(a,lda,n,kpvt,info)
      integer lda,n,kpvt(1),info
      double precision a(lda,1)
c
c     dsifa factors a double precision symmetric matrix by elimination
c     with symmetric pivoting.
c
c     to solve  a*x = b , follow dsifa by dsisl.


c     to compute  inverse(a)*c , follow dsifa by dsisl.
c     to compute  determinant(a) , follow dsifa by dsidi.
c     to compute  inertia(a) , follow dsifa by dsidi.
c     to compute  inverse(a) , follow dsifa by dsidi.
c
c     on entry
c
c        a       double precision(lda,n)
c                the symmetric matrix to be factored.
c                only the diagonal and upper triangle are used.
c
c        lda     integer
c                the leading dimension of the array  a .
c
c        n       integer
c                the order of the matrix  a .
c
c     on return
c
c        a       a block diagonal matrix and the multipliers which

c                were used to obtain it.
c                the factorization can be written  a = u*d*trans(u)
c                where  u  is a product of permutation and unit
c                upper triangular matrices , trans(u) is the
c                transpose of  u , and  d  is block diagonal

c                with 1 by 1 and 2 by 2 blocks.
c

c        kpvt    integer(n)
c                an integer vector of pivot indices.
c
c        info    integer
c                = 0  normal value.
c                = k  if the k-th pivot block is singular. this is
c                     not an error condition for this subroutine,
c                     but it does indicate that dsisl or dsidi may
c                     divide by zero if called.

c

c     linpack. this version dated 08/14/78 .
c     james bunch, univ. calif. san diego, argonne nat. lab.
c
c     subroutines and functions
c
c     blas daxpy,dswap,idamax
c     fortran dabs,dmax1,dsqrt
c
c     internal variables
c
      double precision ak,akm1,bk,bkm1,denom,mulk,mulkm1,t
      double precision absakk,alpha,colmax,rowmax
      integer imax,imaxp1,j,jj,jmax,k,km1,km2,kstep,idamax
      logical swap
c

c
c     initialize
c
c     alpha is used in choosing pivot block size.
      alpha = (1.0d0 + dsqrt(17.0d0))/8.0d0
c
      info = 0
c
c     main loop on k, which goes from n to 1.
c
      k = n
   10 continue
c
c        leave the loop if k=0 or k=1.
c
c     ...exit
         if (k .eq. 0) go to 200
         if (k .gt. 1) go to 20
            kpvt(1) = 1
            if (a(1,1) .eq. 0.0d0) info = 1
c     ......exit

            go to 200
   20    continue
c
c        this section of code determines the kind of
c        elimination to be performed.  when it is completed,

c        kstep will be set to the size of the pivot block, and
c        swap will be set to .true. if an interchange is
c        required.
c
         km1 = k - 1
         absakk = dabs(a(k,k))


c
c        determine the largest off-diagonal element in
c        column k.
c
         imax = idamax(k-1,a(1,k),1)
         colmax = dabs(a(imax,k))
         if (absakk .lt. alpha*colmax) go to 30
            kstep = 1
            swap = .false.
         go to 90
   30    continue
c
c           determine the largest off-diagonal element in


c           row imax.
c
            rowmax = 0.0d0


            imaxp1 = imax + 1
            do 40 j = imaxp1, k
               rowmax = dmax1(rowmax,dabs(a(imax,j)))
   40       continue
            if (imax .eq. 1) go to 50
               jmax = idamax(imax-1,a(1,imax),1)
               rowmax = dmax1(rowmax,dabs(a(jmax,imax)))
   50       continue
            if (dabs(a(imax,imax)) .lt. alpha*rowmax) go to 60
               kstep = 1
               swap = .true.
            go to 80
   60       continue
            if (absakk .lt. alpha*colmax*(colmax/rowmax)) go to 70
               kstep = 1
               swap = .false.
            go to 80
   70       continue
               kstep = 2
               swap = imax .ne. km1
   80       continue
   90    continue
         if (dmax1(absakk,colmax) .ne. 0.0d0) go to 100
c
c           column k is zero.  set info and iterate the loop.

c
            kpvt(k) = k
            info = k
         go to 190
  100    continue
         if (kstep .eq. 2) go to 140
c
c           1 x 1 pivot block.
c
            if (.not.swap) go to 120
c
c              perform an interchange.
c


               call dswap(imax,a(1,imax),1,a(1,k),1)
               do 110 jj = imax, k
                  j = k + imax - jj
                  t = a(j,k)
                  a(j,k) = a(imax,j)
                  a(imax,j) = t
  110          continue
  120       continue
c
c           perform the elimination.
c

            do 130 jj = 1, km1

               j = k - jj
               mulk = -a(j,k)/a(k,k)
               t = mulk
               call daxpy(j,t,a(1,k),1,a(1,j),1)
               a(j,k) = mulk
  130       continue
c
c           set the pivot array.
c
            kpvt(k) = k
            if (swap) kpvt(k) = imax
         go to 190
  140    continue
c
c           2 x 2 pivot block.
c
            if (.not.swap) go to 160
c

c              perform an interchange.
c
               call dswap(imax,a(1,imax),1,a(1,k-1),1)
               do 150 jj = imax, km1
                  j = km1 + imax - jj
                  t = a(j,k-1)
                  a(j,k-1) = a(imax,j)
                  a(imax,j) = t
  150          continue

               t = a(k-1,k)
               a(k-1,k) = a(imax,k)
               a(imax,k) = t
  160       continue
c

c           perform the elimination.
c
            km2 = k - 2
            if (km2 .eq. 0) go to 180
               ak = a(k,k)/a(k-1,k)
               akm1 = a(k-1,k-1)/a(k-1,k)
               denom = 1.0d0 - ak*akm1

               do 170 jj = 1, km2
                  j = km1 - jj
                  bk = a(j,k)/a(k-1,k)
                  bkm1 = a(j,k-1)/a(k-1,k)
                  mulk = (akm1*bk - bkm1)/denom


                  mulkm1 = (ak*bkm1 - bk)/denom
                  t = mulk
                  call daxpy(j,t,a(1,k),1,a(1,j),1)

                  t = mulkm1
                  call daxpy(j,t,a(1,k-1),1,a(1,j),1)
                  a(j,k) = mulk
                  a(j,k-1) = mulkm1
  170          continue
  180       continue
c

c           set the pivot array.
c
            kpvt(k) = 1 - k
            if (swap) kpvt(k) = -imax
            kpvt(k-1) = kpvt(k)
  190    continue
         k = k - kstep
      go to 10
  200 continue
      return

      end
      subroutine dsisl(a,lda,n,kpvt,b)
      integer lda,n,kpvt(1)
      double precision a(lda,1),b(1)
c
c     dsisl solves the double precision symmetric system
c     a * x = b
c     using the factors computed by dsifa.
c
c     on entry
c
c        a       double precision(lda,n)
c                the output from dsifa.
c
c        lda     integer
c                the leading dimension of the array  a .
c
c        n       integer
c                the order of the matrix  a .
c

c        kpvt    integer(n)
c                the pivot vector from dsifa.
c
c        b       double precision(n)

c                the right hand side vector.

c
c     on return
c
c        b       the solution vector  x .
c
c     error condition
c
c        a division by zero may occur if  dsico  has set rcond .eq. 0.0
c        or  dsifa  has set info .ne. 0  .
c
c     to compute  inverse(a) * c  where  c  is a matrix
c     with  p  columns
c           call dsifa(a,lda,n,kpvt,info)
c           if (info .ne. 0) go to ...

c           do 10 j = 1, p
c              call dsisl(a,lda,n,kpvt,c(1,j))
c        10 continue
c
c     linpack. this version dated 08/14/78 .
c     james bunch, univ. calif. san diego, argonne nat. lab.
c
c     subroutines and functions
c
c     blas daxpy,ddot
c     fortran iabs
c
c     internal variables.
c
      double precision ak,akm1,bk,bkm1,ddot,denom,temp
      integer k,kp
c
c     loop backward applying the transformations and
c     d inverse to b.
c
      k = n
   10 if (k .eq. 0) go to 80
         if (kpvt(k) .lt. 0) go to 40

c
c           1 x 1 pivot block.
c
            if (k .eq. 1) go to 30
               kp = kpvt(k)
               if (kp .eq. k) go to 20
c
c                 interchange.
c
                  temp = b(k)
                  b(k) = b(kp)
                  b(kp) = temp
   20          continue
c
c              apply the transformation.

c
               call daxpy(k-1,b(k),a(1,k),1,b(1),1)
   30       continue
c
c           apply d inverse.
c
            b(k) = b(k)/a(k,k)
            k = k - 1
         go to 70
   40    continue
c
c           2 x 2 pivot block.


c
            if (k .eq. 2) go to 60
               kp = iabs(kpvt(k))
               if (kp .eq. k - 1) go to 50
c
c                 interchange.
c
                  temp = b(k-1)
                  b(k-1) = b(kp)
                  b(kp) = temp
   50          continue
c
c              apply the transformation.
c
               call daxpy(k-2,b(k),a(1,k),1,b(1),1)
               call daxpy(k-2,b(k-1),a(1,k-1),1,b(1),1)

   60       continue
c
c           apply d inverse.
c
            ak = a(k,k)/a(k-1,k)
            akm1 = a(k-1,k-1)/a(k-1,k)
            bk = b(k)/a(k-1,k)
            bkm1 = b(k-1)/a(k-1,k)
            denom = ak*akm1 - 1.0d0
            b(k) = (akm1*bk - bkm1)/denom

            b(k-1) = (ak*bkm1 - bk)/denom
            k = k - 2
   70    continue
      go to 10
   80 continue
c
c     loop forward applying the transformations.
c
      k = 1
   90 if (k .gt. n) go to 160
         if (kpvt(k) .lt. 0) go to 120
c
c           1 x 1 pivot block.
c
            if (k .eq. 1) go to 110
c
c              apply the transformation.
c
               b(k) = b(k) + ddot(k-1,a(1,k),1,b(1),1)
               kp = kpvt(k)
               if (kp .eq. k) go to 100
c
c                 interchange.
c
                  temp = b(k)

                  b(k) = b(kp)
                  b(kp) = temp
  100          continue

  110       continue
            k = k + 1
         go to 150
  120    continue
c
c           2 x 2 pivot block.
c
            if (k .eq. 1) go to 140
c
c              apply the transformation.
c

               b(k) = b(k) + ddot(k-1,a(1,k),1,b(1),1)

               b(k+1) = b(k+1) + ddot(k-1,a(1,k+1),1,b(1),1)
               kp = iabs(kpvt(k))
               if (kp .eq. k) go to 130
c
c                 interchange.
c
                  temp = b(k)
                  b(k) = b(kp)
                  b(kp) = temp
  130          continue
  140       continue
            k = k + 2
  150    continue
      go to 90
  160 continue
      return
      end
      subroutine dqrdc(x,ldx,n,p,qraux,jpvt,work,job)
      integer ldx,n,p,job
      integer jpvt(1)
      double precision x(ldx,1),qraux(1),work(1)
c

c     dqrdc uses householder transformations to compute the qr
c     factorization of an n by p matrix x.  column pivoting
c     based on the 2-norms of the reduced columns may be
c     performed at the users option.
c
c     on entry
c
c        x       double precision(ldx,p), where ldx .ge. n.
c                x contains the matrix whose decomposition is to be
c                computed.
c
c        ldx     integer.
c                ldx is the leading dimension of the array x.
c
c        n       integer.
c                n is the number of rows of the matrix x.
c
c        p       integer.

c                p is the number of columns of the matrix x.
c
c        jpvt    integer(p).
c                jpvt contains integers that control the selection
c                of the pivot columns.  the k-th column x(k) of x
c                is placed in one of three classes according to the
c                value of jpvt(k).
c
c                   if jpvt(k) .gt. 0, then x(k) is an initial
c                                      column.
c
c                   if jpvt(k) .eq. 0, then x(k) is a free column.
c
c                   if jpvt(k) .lt. 0, then x(k) is a final column.

c
c                before the decomposition is computed, initial columns
c                are moved to the beginning of the array x and final
c                columns to the end.  both initial and final columns
c                are frozen in place during the computation and only

c                free columns are moved.  at the k-th stage of the
c                reduction, if x(k) is occupied by a free column
c                it is interchanged with the free column of largest
c                reduced norm.  jpvt is not referenced if
c                job .eq. 0.
c
c        work    double precision(p).
c                work is a work array.  work is not referenced if
c                job .eq. 0.
c

c        job     integer.
c                job is an integer that initiates column pivoting.
c                if job .eq. 0, no pivoting is done.
c                if job .ne. 0, pivoting is done.
c


c     on return
c
c        x       x contains in its upper triangle the upper
c                triangular matrix r of the qr factorization.
c                below its diagonal x contains information from
c                which the orthogonal part of the decomposition
c                can be recovered.  note that if pivoting has
c                been requested, the decomposition is not that
c                of the original matrix x but that of x
c                with its columns permuted as described by jpvt.
c

c        qraux   double precision(p).
c                qraux contains further information required to recover
c                the orthogonal part of the decomposition.
c
c        jpvt    jpvt(k) contains the index of the column of the
c                original matrix that has been interchanged into
c                the k-th column, if pivoting was requested.
c

c     linpack. this version dated 08/14/78 .
c     g.w. stewart, university of maryland, argonne national lab.
c
c     dqrdc uses the following functions and subprograms.
c
c     blas daxpy,ddot,dscal,dswap,dnrm2
c     fortran dabs,dmax1,min0,dsqrt

c

c     internal variables

c
      integer j,jp,l,lp1,lup,maxj,pl,pu
      double precision maxnrm,dnrm2,tt
      double precision ddot,nrmxl,t
      logical negj,swapj
c
c
      pl = 1
      pu = 0
      if (job .eq. 0) go to 60
c
c        pivoting has been requested.  rearrange the columns
c        according to jpvt.
c
         do 20 j = 1, p
            swapj = jpvt(j) .gt. 0
            negj = jpvt(j) .lt. 0
            jpvt(j) = j
            if (negj) jpvt(j) = -j
            if (.not.swapj) go to 10
               if (j .ne. pl) call dswap(n,x(1,pl),1,x(1,j),1)
               jpvt(j) = jpvt(pl)
               jpvt(pl) = j
               pl = pl + 1
   10       continue
   20    continue
         pu = p
         do 50 jj = 1, p
            j = p - jj + 1
            if (jpvt(j) .ge. 0) go to 40
               jpvt(j) = -jpvt(j)
               if (j .eq. pu) go to 30
                  call dswap(n,x(1,pu),1,x(1,j),1)
                  jp = jpvt(pu)
                  jpvt(pu) = jpvt(j)
                  jpvt(j) = jp

   30          continue
               pu = pu - 1
   40       continue
   50    continue
   60 continue
c
c     compute the norms of the free columns.
c
      if (pu .lt. pl) go to 80
      do 70 j = pl, pu
         qraux(j) = dnrm2(n,x(1,j),1)
         work(j) = qraux(j)
   70 continue
   80 continue
c

c     perform the householder reduction of x.
c
      lup = min0(n,p)
      do 200 l = 1, lup

         if (l .lt. pl .or. l .ge. pu) go to 120
c
c           locate the column of largest norm and bring it
c           into the pivot position.
c
            maxnrm = 0.0d0

            maxj = l
            do 100 j = l, pu
               if (qraux(j) .le. maxnrm) go to 90
                  maxnrm = qraux(j)
                  maxj = j

   90          continue
  100       continue
            if (maxj .eq. l) go to 110
               call dswap(n,x(1,l),1,x(1,maxj),1)
               qraux(maxj) = qraux(l)
               work(maxj) = work(l)
               jp = jpvt(maxj)
               jpvt(maxj) = jpvt(l)
               jpvt(l) = jp
  110       continue
  120    continue
         qraux(l) = 0.0d0
         if (l .eq. n) go to 190
c
c           compute the householder transformation for column l.
c
            nrmxl = dnrm2(n-l+1,x(l,l),1)
            if (nrmxl .eq. 0.0d0) go to 180
               if (x(l,l) .ne. 0.0d0) nrmxl = dsign(nrmxl,x(l,l))

               call dscal(n-l+1,1.0d0/nrmxl,x(l,l),1)
               x(l,l) = 1.0d0 + x(l,l)
c
c              apply the transformation to the remaining columns,
c              updating the norms.
c
               lp1 = l + 1
               if (p .lt. lp1) go to 170
               do 160 j = lp1, p
                  t = -ddot(n-l+1,x(l,l),1,x(l,j),1)/x(l,l)
                  call daxpy(n-l+1,t,x(l,l),1,x(l,j),1)
                  if (j .lt. pl .or. j .gt. pu) go to 150
                  if (qraux(j) .eq. 0.0d0) go to 150
                     tt = 1.0d0 - (dabs(x(l,j))/qraux(j))**2
                     tt = dmax1(tt,0.0d0)
                     t = tt
                     tt = 1.0d0 + 0.05d0*tt*(qraux(j)/work(j))**2
                     if (tt .eq. 1.0d0) go to 130
                        qraux(j) = qraux(j)*dsqrt(t)
                     go to 140
  130                continue
                        qraux(j) = dnrm2(n-l,x(l+1,j),1)
                        work(j) = qraux(j)
  140                continue
  150             continue
  160          continue
  170          continue
c
c              save the transformation.
c
               qraux(l) = x(l,l)
               x(l,l) = -nrmxl
  180       continue
  190    continue
  200 continue
      return
      end
C LAPACK routines follow
C note that thte call to the LAPACK auxialliary routine
C that defines NB has been rpelaced by a hardwired
C NB=16 in dpotrf.f

C This is probably OK for PCs, but workstations may be a bit faster with
C NB = 32
      SUBROUTINE DPOTRF( UPLO, N, A, LDA, INFO )
*
*  -- LAPACK routine (version 3.0) --
*     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
*     Courant Institute, Argonne National Lab, and Rice University
*     March 31, 1993
*
*     .. Scalar Arguments ..
      CHARACTER          UPLO

      INTEGER            INFO, LDA, N
*     ..

*     .. Array Arguments ..
      DOUBLE PRECISION   A( LDA, * )
*     ..
*
*  Purpose
*  =======
*
*  DPOTRF computes the Cholesky factorization of a real symmetric
*  positive definite matrix A.
*
*  The factorization has the form
*     A = U**T * U,  if UPLO = 'U', or
*     A = L  * L**T,  if UPLO = 'L',

*  where U is an upper triangular matrix and L is lower triangular.
*
*  This is the block version of the algorithm, calling Level 3 BLAS.
*
*  Arguments
*  =========
*
*  UPLO    (input) CHARACTER*1

*          = 'U':  Upper triangle of A is stored;
*          = 'L':  Lower triangle of A is stored.
*
*  N       (input) INTEGER
*          The order of the matrix A.  N >= 0.
*
*  A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
*          On entry, the symmetric matrix A.  If UPLO = 'U', the leading

*          N-by-N upper triangular part of A contains the upper
*          triangular part of the matrix A, and the strictly lower
*          triangular part of A is not referenced.  If UPLO = 'L', the
*          leading N-by-N lower triangular part of A contains the lower
*          triangular part of the matrix A, and the strictly upper
*          triangular part of A is not referenced.
*
*          On exit, if INFO = 0, the factor U or L from the Cholesky
*          factorization A = U**T*U or A = L*L**T.
*
*  LDA     (input) INTEGER
*          The leading dimension of the array A.  LDA >= max(1,N).
*
*  INFO    (output) INTEGER
*          = 0:  successful exit
*          < 0:  if INFO = -i, the i-th argument had an illegal value
*          > 0:  if INFO = i, the leading minor of order i is not
*                positive definite, and the factorization could not be
*                completed.

*

*  =====================================================================
*
*     .. Parameters ..
      DOUBLE PRECISION   ONE
      PARAMETER          ( ONE = 1.0D+0 )
*     ..
*     .. Local Scalars ..
      LOGICAL            UPPER
      INTEGER            J, JB, NB
*     ..
*     .. External Functions ..

      LOGICAL            LSAME
      EXTERNAL           LSAME
*     ..
*     .. External Subroutines ..
      EXTERNAL           DGEMM, DPOTF2, DSYRK, DTRSM, XERBLA
*     ..
*     .. Intrinsic Functions ..
      INTRINSIC          MAX, MIN
*     ..
*     .. Executable Statements ..
*
*     Test the input parameters.
*
      INFO = 0
      UPPER = LSAME( UPLO, 'U' )
      IF( .NOT.UPPER .AND. .NOT.LSAME( UPLO, 'L' ) ) THEN

         INFO = -1
      ELSE IF( N.LT.0 ) THEN
         INFO = -2

      ELSE IF( LDA.LT.MAX( 1, N ) ) THEN
         INFO = -4
      END IF
      IF( INFO.NE.0 ) THEN
         CALL XERBLA( 'DPOTRF', -INFO )
         RETURN
      END IF
*
*     Quick return if possible
*
      IF( N.EQ.0 )
     $   RETURN
*
*     Determine the block size for this environment.
*
      nb = 16
      IF( NB.LE.1 .OR. NB.GE.N ) THEN
*
*        Use unblocked code.
*
         CALL DPOTF2( UPLO, N, A, LDA, INFO )
      ELSE
*
*        Use blocked code.
*

         IF( UPPER ) THEN
*
*           Compute the Cholesky factorization A = U'*U.
*
            DO 10 J = 1, N, NB
*
*              Update and factorize the current diagonal block and test
*              for non-positive-definiteness.
*
               JB = MIN( NB, N-J+1 )
               CALL DSYRK( 'Upper', 'Transpose', JB, J-1, -ONE,
     $                     A( 1, J ), LDA, ONE, A( J, J ), LDA )


               CALL DPOTF2( 'Upper', JB, A( J, J ), LDA, INFO )
               IF( INFO.NE.0 )
     $            GO TO 30
               IF( J+JB.LE.N ) THEN
*
*                 Compute the current block row.

*
                  CALL DGEMM( 'Transpose', 'No transpose', JB, N-J-JB+1,
     $                        J-1, -ONE, A( 1, J ), LDA, A( 1, J+JB ),
     $                        LDA, ONE, A( J, J+JB ), LDA )
                  CALL DTRSM( 'Left', 'Upper', 'Transpose', 'Non-unit',
     $                        JB, N-J-JB+1, ONE, A( J, J ), LDA,


     $                        A( J, J+JB ), LDA )
               END IF

   10       CONTINUE
*
         ELSE
*
*           Compute the Cholesky factorization A = L*L'.
*
            DO 20 J = 1, N, NB
*
*              Update and factorize the current diagonal block and test
*              for non-positive-definiteness.
*
               JB = MIN( NB, N-J+1 )
               CALL DSYRK( 'Lower', 'No transpose', JB, J-1, -ONE,
     $                     A( J, 1 ), LDA, ONE, A( J, J ), LDA )
               CALL DPOTF2( 'Lower', JB, A( J, J ), LDA, INFO )
               IF( INFO.NE.0 )
     $            GO TO 30
               IF( J+JB.LE.N ) THEN
*
*                 Compute the current block column.
*
                  CALL DGEMM( 'No transpose', 'Transpose', N-J-JB+1, JB,
     $                        J-1, -ONE, A( J+JB, 1 ), LDA, A( J, 1 ),

     $                        LDA, ONE, A( J+JB, J ), LDA )
                  CALL DTRSM( 'Right', 'Lower', 'Transpose', 'Non-unit',
     $                        N-J-JB+1, JB, ONE, A( J, J ), LDA,
     $                        A( J+JB, J ), LDA )

               END IF
   20       CONTINUE
         END IF
      END IF
      GO TO 40
*
   30 CONTINUE
      INFO = INFO + J - 1
*
   40 CONTINUE
      RETURN
*
*     End of DPOTRF
*
      END
      SUBROUTINE DPOTRS( UPLO, N, NRHS, A, LDA, B, LDB, INFO )
*
*  -- LAPACK routine (version 3.0) --
*     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
*     Courant Institute, Argonne National Lab, and Rice University
*     March 31, 1993
*
*     .. Scalar Arguments ..
      CHARACTER          UPLO

      INTEGER            INFO, LDA, LDB, N, NRHS
*     ..
*     .. Array Arguments ..
      DOUBLE PRECISION   A( LDA, * ), B( LDB, * )
*     ..
*
*  Purpose

*  =======
*
*  DPOTRS solves a system of linear equations A*X = B with a symmetric
*  positive definite matrix A using the Cholesky factorization
*  A = U**T*U or A = L*L**T computed by DPOTRF.
*
*  Arguments
*  =========
*
*  UPLO    (input) CHARACTER*1
*          = 'U':  Upper triangle of A is stored;

*          = 'L':  Lower triangle of A is stored.
*
*  N       (input) INTEGER
*          The order of the matrix A.  N >= 0.
*
*  NRHS    (input) INTEGER
*          The number of right hand sides, i.e., the number of columns
*          of the matrix B.  NRHS >= 0.
*
*  A       (input) DOUBLE PRECISION array, dimension (LDA,N)
*          The triangular factor U or L from the Cholesky factorization
*          A = U**T*U or A = L*L**T, as computed by DPOTRF.
*
*  LDA     (input) INTEGER
*          The leading dimension of the array A.  LDA >= max(1,N).
*
*  B       (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS)
*          On entry, the right hand side matrix B.
*          On exit, the solution matrix X.

*
*  LDB     (input) INTEGER

*          The leading dimension of the array B.  LDB >= max(1,N).
*
*  INFO    (output) INTEGER
*          = 0:  successful exit
*          < 0:  if INFO = -i, the i-th argument had an illegal value
*
*  =====================================================================
*
*     .. Parameters ..
      DOUBLE PRECISION   ONE

      PARAMETER          ( ONE = 1.0D+0 )
*     ..
*     .. Local Scalars ..
      LOGICAL            UPPER
*     ..
*     .. External Functions ..
      LOGICAL            LSAME

      EXTERNAL           LSAME

*     ..
*     .. External Subroutines ..
      EXTERNAL           DTRSM, XERBLA

*     ..
*     .. Intrinsic Functions ..
      INTRINSIC          MAX
*     ..
*     .. Executable Statements ..
*
*     Test the input parameters.
*
      INFO = 0
      UPPER = LSAME( UPLO, 'U' )

      IF( .NOT.UPPER .AND. .NOT.LSAME( UPLO, 'L' ) ) THEN
         INFO = -1
      ELSE IF( N.LT.0 ) THEN
         INFO = -2
      ELSE IF( NRHS.LT.0 ) THEN

         INFO = -3
      ELSE IF( LDA.LT.MAX( 1, N ) ) THEN
         INFO = -5
      ELSE IF( LDB.LT.MAX( 1, N ) ) THEN
         INFO = -7

      END IF
      IF( INFO.NE.0 ) THEN
         CALL XERBLA( 'DPOTRS', -INFO )
         RETURN
      END IF
*

*     Quick return if possible
*
      IF( N.EQ.0 .OR. NRHS.EQ.0 )
     $   RETURN
*
      IF( UPPER ) THEN
*
*        Solve A*X = B where A = U'*U.
*
*        Solve U'*X = B, overwriting B with X.
*
         CALL DTRSM( 'Left', 'Upper', 'Transpose', 'Non-unit', N, NRHS,
     $               ONE, A, LDA, B, LDB )
*
*        Solve U*X = B, overwriting B with X.
*
         CALL DTRSM( 'Left', 'Upper', 'No transpose', 'Non-unit', N,
     $               NRHS, ONE, A, LDA, B, LDB )
      ELSE
*
*        Solve A*X = B where A = L*L'.
*

*        Solve L*X = B, overwriting B with X.
*
         CALL DTRSM( 'Left', 'Lower', 'No transpose', 'Non-unit', N,
     $               NRHS, ONE, A, LDA, B, LDB )
*
*        Solve L'*X = B, overwriting B with X.
*
         CALL DTRSM( 'Left', 'Lower', 'Transpose', 'Non-unit', N, NRHS,
     $               ONE, A, LDA, B, LDB )
      END IF
*
      RETURN
*
*     End of DPOTRS

*
      END
      SUBROUTINE DPOTF2( UPLO, N, A, LDA, INFO )
*
*  -- LAPACK routine (version 3.0) --
*     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
*     Courant Institute, Argonne National Lab, and Rice University
*     February 29, 1992
*
*     .. Scalar Arguments ..
      CHARACTER          UPLO
      INTEGER            INFO, LDA, N
*     ..
*     .. Array Arguments ..
      DOUBLE PRECISION   A( LDA, * )
*     ..
*
*  Purpose
*  =======
*
*  DPOTF2 computes the Cholesky factorization of a real symmetric
*  positive definite matrix A.

*
*  The factorization has the form
*     A = U' * U ,  if UPLO = 'U', or

*     A = L  * L',  if UPLO = 'L',
*  where U is an upper triangular matrix and L is lower triangular.
*
*  This is the unblocked version of the algorithm, calling Level 2 BLAS.
*
*  Arguments
*  =========
*
*  UPLO    (input) CHARACTER*1

*          Specifies whether the upper or lower triangular part of the
*          symmetric matrix A is stored.

*          = 'U':  Upper triangular
*          = 'L':  Lower triangular
*
*  N       (input) INTEGER
*          The order of the matrix A.  N >= 0.
*
*  A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)

*          On entry, the symmetric matrix A.  If UPLO = 'U', the leading
*          n by n upper triangular part of A contains the upper
*          triangular part of the matrix A, and the strictly lower
*          triangular part of A is not referenced.  If UPLO = 'L', the
*          leading n by n lower triangular part of A contains the lower

*          triangular part of the matrix A, and the strictly upper
*          triangular part of A is not referenced.
*

*          On exit, if INFO = 0, the factor U or L from the Cholesky
*          factorization A = U'*U  or A = L*L'.
*
*  LDA     (input) INTEGER
*          The leading dimension of the array A.  LDA >= max(1,N).
*
*  INFO    (output) INTEGER
*          = 0: successful exit
*          < 0: if INFO = -k, the k-th argument had an illegal value
*          > 0: if INFO = k, the leading minor of order k is not
*               positive definite, and the factorization could not be
*               completed.
*
*  =====================================================================
*
*     .. Parameters ..
      DOUBLE PRECISION   ONE, ZERO
      PARAMETER          ( ONE = 1.0D+0, ZERO = 0.0D+0 )
*     ..
*     .. Local Scalars ..
      LOGICAL            UPPER
      INTEGER            J
      DOUBLE PRECISION   AJJ
*     ..
*     .. External Functions ..
      LOGICAL            LSAME
      DOUBLE PRECISION   DDOT
      EXTERNAL           LSAME, DDOT
*     ..
*     .. External Subroutines ..
      EXTERNAL           DGEMV, DSCAL, XERBLA
*     ..
*     .. Intrinsic Functions ..
      INTRINSIC          MAX, SQRT
*     ..
*     .. Executable Statements ..
*
*     Test the input parameters.
*
      INFO = 0
      UPPER = LSAME( UPLO, 'U' )
      IF( .NOT.UPPER .AND. .NOT.LSAME( UPLO, 'L' ) ) THEN
         INFO = -1
      ELSE IF( N.LT.0 ) THEN
         INFO = -2
      ELSE IF( LDA.LT.MAX( 1, N ) ) THEN
         INFO = -4
      END IF

      IF( INFO.NE.0 ) THEN
         CALL XERBLA( 'DPOTF2', -INFO )
         RETURN
      END IF
*
*     Quick return if possible
*
      IF( N.EQ.0 )
     $   RETURN
*
      IF( UPPER ) THEN
*
*        Compute the Cholesky factorization A = U'*U.
*
         DO 10 J = 1, N
*
*           Compute U(J,J) and test for non-positive-definiteness.
*
            AJJ = A( J, J ) - DDOT( J-1, A( 1, J ), 1, A( 1, J ), 1 )
            IF( AJJ.LE.ZERO ) THEN
               A( J, J ) = AJJ
               GO TO 30
            END IF
            AJJ = SQRT( AJJ )
            A( J, J ) = AJJ
*
*           Compute elements J+1:N of row J.
*
            IF( J.LT.N ) THEN
               CALL DGEMV( 'Transpose', J-1, N-J, -ONE, A( 1, J+1 ),
     $                     LDA, A( 1, J ), 1, ONE, A( J, J+1 ), LDA )
               CALL DSCAL( N-J, ONE / AJJ, A( J, J+1 ), LDA )
            END IF
   10    CONTINUE

      ELSE
*
*        Compute the Cholesky factorization A = L*L'.
*
         DO 20 J = 1, N
*
*           Compute L(J,J) and test for non-positive-definiteness.
*
            AJJ = A( J, J ) - DDOT( J-1, A( J, 1 ), LDA, A( J, 1 ),
     $            LDA )
            IF( AJJ.LE.ZERO ) THEN
               A( J, J ) = AJJ
               GO TO 30
            END IF
            AJJ = SQRT( AJJ )
            A( J, J ) = AJJ
*
*           Compute elements J+1:N of column J.
*
            IF( J.LT.N ) THEN
               CALL DGEMV( 'No transpose', N-J, J-1, -ONE, A( J+1, 1 ),
     $                     LDA, A( J, 1 ), LDA, ONE, A( J+1, J ), 1 )
               CALL DSCAL( N-J, ONE / AJJ, A( J+1, J ), 1 )
            END IF
   20    CONTINUE



      END IF

      GO TO 40
*


   30 CONTINUE
      INFO = J
*
   40 CONTINUE
      RETURN
*
*     End of DPOTF2
*
      END
      LOGICAL          FUNCTION LSAME( CA, CB )
*
*  -- LAPACK auxiliary routine (version 3.0) --
*     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
*     Courant Institute, Argonne National Lab, and Rice University
*     September 30, 1994
*
*     .. Scalar Arguments ..
      CHARACTER          CA, CB
*     ..
*
*  Purpose
*  =======
*

*  LSAME returns .TRUE. if CA is the same letter as CB regardless of
*  case.

*
*  Arguments
*  =========
*
*  CA      (input) CHARACTER*1
*  CB      (input) CHARACTER*1
*          CA and CB specify the single characters to be compared.
*
* =====================================================================
*
*     .. Intrinsic Functions ..
      INTRINSIC          ICHAR
*     ..
*     .. Local Scalars ..
      INTEGER            INTA, INTB, ZCODE
*     ..
*     .. Executable Statements ..

*
*     Test if the characters are equal
*
      LSAME = CA.EQ.CB
      IF( LSAME )
     $   RETURN
*
*     Now test for equivalence if both characters are alphabetic.
*
      ZCODE = ICHAR( 'Z' )
*
*     Use 'Z' rather than 'A' so that ASCII can be detected on Prime
*     machines, on which ICHAR returns a value with bit 8 set.
*     ICHAR('A') on Prime machines returns 193 which is the same as
*     ICHAR('A') on an EBCDIC machine.
*
      INTA = ICHAR( CA )
      INTB = ICHAR( CB )
*
      IF( ZCODE.EQ.90 .OR. ZCODE.EQ.122 ) THEN
*
*        ASCII is assumed - ZCODE is the ASCII code of either lower or
*        upper case 'Z'.
*
         IF( INTA.GE.97 .AND. INTA.LE.122 ) INTA = INTA - 32
         IF( INTB.GE.97 .AND. INTB.LE.122 ) INTB = INTB - 32
*
      ELSE IF( ZCODE.EQ.233 .OR. ZCODE.EQ.169 ) THEN

*

*        EBCDIC is assumed - ZCODE is the EBCDIC code of either lower or
*        upper case 'Z'.
*
         IF( INTA.GE.129 .AND. INTA.LE.137 .OR.

     $       INTA.GE.145 .AND. INTA.LE.153 .OR.
     $       INTA.GE.162 .AND. INTA.LE.169 ) INTA = INTA + 64
         IF( INTB.GE.129 .AND. INTB.LE.137 .OR.

     $       INTB.GE.145 .AND. INTB.LE.153 .OR.
     $       INTB.GE.162 .AND. INTB.LE.169 ) INTB = INTB + 64
*
      ELSE IF( ZCODE.EQ.218 .OR. ZCODE.EQ.250 ) THEN

*
*        ASCII is assumed, on Prime machines - ZCODE is the ASCII code
*        plus 128 of either lower or upper case 'Z'.
*
         IF( INTA.GE.225 .AND. INTA.LE.250 ) INTA = INTA - 32
         IF( INTB.GE.225 .AND. INTB.LE.250 ) INTB = INTB - 32
      END IF
      LSAME = INTA.EQ.INTB
*
*     RETURN
*
*     End of LSAME

*
      END

      SUBROUTINE XERBLA( SRNAME, INFO )
*
*  -- LAPACK auxiliary routine (preliminary version) --
*     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
*     Courant Institute, Argonne National Lab, and Rice University
*     February 29, 1992
*
*     .. Scalar Arguments ..
      CHARACTER*6        SRNAME
      INTEGER            INFO
      CHARACTER ERRFIL*20



      COMMON/ERROR/ERRFIL
C  COMMON/ERROR/ IS SUPPLIED TO ALL THE ROUTINES WHICH COULD WRITE TO
C  ERRFIL.

*     ..
*
*  Purpose
*  =======
*

*  XERBLA  is an error handler for the LAPACK routines.
*  It is called by an LAPACK routine if an input parameter has an

*  invalid value.  A message is printed and execution stops.
*
*  Installers may consider modifying the STOP statement in order to
*  call system-specific exception-handling facilities.
*
*  Arguments
*  =========
*
*  SRNAME  (input) CHARACTER*6

*          The name of the routine which called XERBLA.
*
*  INFO    (input) INTEGER
*          The position of the invalid parameter in the parameter list
*          of the calling routine.
*
*
      WRITE( *, FMT = 9999 )SRNAME, INFO

C  SINCE THE PROGRAM IS TERMINATING ABNORMALLY, WRITE THE ERROR MESSAGE
C  TO ERRFIL ALSO.

        OPEN(42,FILE=ERRFIL)
      WRITE( 42, FMT = 9999 )SRNAME, INFO
        CLOSE(42)



      CALL PAUSE
      STOP

*
 9999 FORMAT( ' ** On entry to ', A6, ' parameter number ', I2, ' had ',
     $      'an illegal value' )
*
*     End of XERBLA
*
      END
C 
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C

C  THE FOLLOWING IS blasnpag.f FROM THE bignpaglap1_4.f PROGRAM.

C  This file contains source code for the BLAS routines that are used by BIGNPAG

C  These are separated out here since it may be more efficient to just compile
C  bignpag.f and link to an optimized math library containing the BLAS than to
C  compile bignpag.f and this file blasnpag.f together.
C  contents:
c       dgemm:    blas level 3
c       dgemv:    blas level 2
c       dsyrk:    blas level 3
c       dtrsm:    blas level 1
c       dcopy:    blas levle 1
c       dscal:    blas level 1
c       daxpy:    blas level 1
c       ddot:     blas level 1
c       idamax:   blas level 1
c       dswap:    blas level 1
c       dasum:    blas level 1
c       dnrm2:    blas level 1
      SUBROUTINE DGEMM ( TRANSA, TRANSB, M, N, K, ALPHA, A, LDA, B, LDB,
     $                   BETA, C, LDC )
*     .. Scalar Arguments ..
      CHARACTER*1        TRANSA, TRANSB
      INTEGER            M, N, K, LDA, LDB, LDC
      DOUBLE PRECISION   ALPHA, BETA
*     .. Array Arguments ..
      DOUBLE PRECISION   A( LDA, * ), B( LDB, * ), C( LDC, * )
*     ..
*
*  Purpose
*  =======
*
*  DGEMM  performs one of the matrix-matrix operations

*
*     C := alpha*op( A )*op( B ) + beta*C,
*
*  where  op( X ) is one of
*
*     op( X ) = X   or   op( X ) = X',
*
*  alpha and beta are scalars, and A, B and C are matrices, with op( A )
*  an m by k matrix,  op( B )  a  k by n matrix and  C an m by n matrix.
*
*  Parameters
*  ==========
*
*  TRANSA - CHARACTER*1.
*           On entry, TRANSA specifies the form of op( A ) to be used in

*           the matrix multiplication as follows:
*
*              TRANSA = 'N' or 'n',  op( A ) = A.
*
*              TRANSA = 'T' or 't',  op( A ) = A'.
*
*              TRANSA = 'C' or 'c',  op( A ) = A'.
*
*           Unchanged on exit.
*
*  TRANSB - CHARACTER*1.
*           On entry, TRANSB specifies the form of op( B ) to be used in
*           the matrix multiplication as follows:
*
*              TRANSB = 'N' or 'n',  op( B ) = B.
*
*              TRANSB = 'T' or 't',  op( B ) = B'.

*
*              TRANSB = 'C' or 'c',  op( B ) = B'.
*
*           Unchanged on exit.
*

*  M      - INTEGER.
*           On entry,  M  specifies  the number  of rows  of the  matrix
*           op( A )  and of the  matrix  C.  M  must  be at least  zero.
*           Unchanged on exit.
*
*  N      - INTEGER.
*           On entry,  N  specifies the number  of columns of the matrix
*           op( B ) and the number of columns of the matrix C. N must be
*           at least zero.
*           Unchanged on exit.
*
*  K      - INTEGER.

*           On entry,  K  specifies  the number of columns of the matrix
*           op( A ) and the number of rows of the matrix op( B ). K must
*           be at least  zero.
*           Unchanged on exit.
*

*  ALPHA  - DOUBLE PRECISION.
*           On entry, ALPHA specifies the scalar alpha.
*           Unchanged on exit.
*
*  A      - DOUBLE PRECISION array of DIMENSION ( LDA, ka ), where ka is
*           k  when  TRANSA = 'N' or 'n',  and is  m  otherwise.
*           Before entry with  TRANSA = 'N' or 'n',  the leading  m by k
*           part of the array  A  must contain the matrix  A,  otherwise
*           the leading  k by m  part of the array  A  must contain  the
*           matrix A.
*           Unchanged on exit.

*
*  LDA    - INTEGER.
*           On entry, LDA specifies the first dimension of A as declared
*           in the calling (sub) program. When  TRANSA = 'N' or 'n' then
*           LDA must be at least  max( 1, m ), otherwise  LDA must be at
*           least  max( 1, k ).
*           Unchanged on exit.
*
*  B      - DOUBLE PRECISION array of DIMENSION ( LDB, kb ), where kb is
*           n  when  TRANSB = 'N' or 'n',  and is  k  otherwise.
*           Before entry with  TRANSB = 'N' or 'n',  the leading  k by n
*           part of the array  B  must contain the matrix  B,  otherwise
*           the leading  n by k  part of the array  B  must contain  the

*           matrix B.
*           Unchanged on exit.
*

*  LDB    - INTEGER.
*           On entry, LDB specifies the first dimension of B as declared
*           in the calling (sub) program. When  TRANSB = 'N' or 'n' then

*           LDB must be at least  max( 1, k ), otherwise  LDB must be at
*           least  max( 1, n ).
*           Unchanged on exit.
*
*  BETA   - DOUBLE PRECISION.
*           On entry,  BETA  specifies the scalar  beta.  When  BETA  is
*           supplied as zero then C need not be set on input.
*           Unchanged on exit.
*
*  C      - DOUBLE PRECISION array of DIMENSION ( LDC, n ).
*           Before entry, the leading  m by n  part of the array  C must
*           contain the matrix  C,  except when  beta  is zero, in which
*           case C need not be set on entry.

*           On exit, the array  C  is overwritten by the  m by n  matrix
*           ( alpha*op( A )*op( B ) + beta*C ).
*
*  LDC    - INTEGER.
*           On entry, LDC specifies the first dimension of C as declared
*           in  the  calling  (sub)  program.   LDC  must  be  at  least
*           max( 1, m ).
*           Unchanged on exit.
*
*
*  Level 3 Blas routine.
*
*  -- Written on 8-February-1989.

*     Jack Dongarra, Argonne National Laboratory.
*     Iain Duff, AERE Harwell.
*     Jeremy Du Croz, Numerical Algorithms Group Ltd.
*     Sven Hammarling, Numerical Algorithms Group Ltd.
*
*
*     .. External Functions ..
      LOGICAL            LSAME
      EXTERNAL           LSAME
*     .. External Subroutines ..
      EXTERNAL           XERBLA
*     .. Intrinsic Functions ..
      INTRINSIC          MAX

*     .. Local Scalars ..
      LOGICAL            NOTA, NOTB
      INTEGER            I, INFO, J, L, NCOLA, NROWA, NROWB
      DOUBLE PRECISION   TEMP
*     .. Parameters ..
      DOUBLE PRECISION   ONE         , ZERO
      PARAMETER        ( ONE = 1.0D+0, ZERO = 0.0D+0 )
*     ..
*     .. Executable Statements ..
*
*     Set  NOTA  and  NOTB  as  true if  A  and  B  respectively are not
*     transposed and set  NROWA, NCOLA and  NROWB  as the number of rows
*     and  columns of  A  and the  number of  rows  of  B  respectively.
*

      NOTA  = LSAME( TRANSA, 'N' )
      NOTB  = LSAME( TRANSB, 'N' )
      IF( NOTA )THEN
         NROWA = M
         NCOLA = K
      ELSE
         NROWA = K
         NCOLA = M
      END IF
      IF( NOTB )THEN
         NROWB = K
      ELSE
         NROWB = N
      END IF
*
*     Test the input parameters.
*
      INFO = 0
      IF(      ( .NOT.NOTA                 ).AND.

     $         ( .NOT.LSAME( TRANSA, 'C' ) ).AND.
     $         ( .NOT.LSAME( TRANSA, 'T' ) )      )THEN
         INFO = 1
      ELSE IF( ( .NOT.NOTB                 ).AND.

     $         ( .NOT.LSAME( TRANSB, 'C' ) ).AND.
     $         ( .NOT.LSAME( TRANSB, 'T' ) )      )THEN
         INFO = 2
      ELSE IF( M  .LT.0               )THEN
         INFO = 3

      ELSE IF( N  .LT.0               )THEN

         INFO = 4
      ELSE IF( K  .LT.0               )THEN
         INFO = 5


      ELSE IF( LDA.LT.MAX( 1, NROWA ) )THEN
         INFO = 8
      ELSE IF( LDB.LT.MAX( 1, NROWB ) )THEN
         INFO = 10
      ELSE IF( LDC.LT.MAX( 1, M     ) )THEN
         INFO = 13
      END IF
      IF( INFO.NE.0 )THEN
         CALL XERBLA( 'DGEMM ', INFO )

         RETURN
      END IF
*
*     Quick return if possible.
*
      IF( ( M.EQ.0 ).OR.( N.EQ.0 ).OR.
     $    ( ( ( ALPHA.EQ.ZERO ).OR.( K.EQ.0 ) ).AND.( BETA.EQ.ONE ) ) )

     $   RETURN
*
*     And if  alpha.eq.zero.

*
      IF( ALPHA.EQ.ZERO )THEN
         IF( BETA.EQ.ZERO )THEN
            DO 20, J = 1, N
               DO 10, I = 1, M
                  C( I, J ) = ZERO
   10          CONTINUE
   20       CONTINUE
         ELSE
            DO 40, J = 1, N
               DO 30, I = 1, M
                  C( I, J ) = BETA*C( I, J )
   30          CONTINUE
   40       CONTINUE
         END IF
         RETURN
      END IF
*

*     Start the operations.


*
      IF( NOTB )THEN
         IF( NOTA )THEN
*
*           Form  C := alpha*A*B + beta*C.
*

            DO 90, J = 1, N
               IF( BETA.EQ.ZERO )THEN
                  DO 50, I = 1, M
                     C( I, J ) = ZERO
   50             CONTINUE
               ELSE IF( BETA.NE.ONE )THEN
                  DO 60, I = 1, M
                     C( I, J ) = BETA*C( I, J )
   60             CONTINUE
               END IF

               DO 80, L = 1, K
                  IF( B( L, J ).NE.ZERO )THEN
                     TEMP = ALPHA*B( L, J )
                     DO 70, I = 1, M
                        C( I, J ) = C( I, J ) + TEMP*A( I, L )
   70                CONTINUE
                  END IF
   80          CONTINUE

   90       CONTINUE
         ELSE
*
*           Form  C := alpha*A'*B + beta*C
*
            DO 120, J = 1, N
               DO 110, I = 1, M
                  TEMP = ZERO
                  DO 100, L = 1, K
                     TEMP = TEMP + A( L, I )*B( L, J )
  100             CONTINUE
                  IF( BETA.EQ.ZERO )THEN
                     C( I, J ) = ALPHA*TEMP


                  ELSE
                     C( I, J ) = ALPHA*TEMP + BETA*C( I, J )
                  END IF
  110          CONTINUE
  120       CONTINUE
         END IF

      ELSE
         IF( NOTA )THEN
*
*           Form  C := alpha*A*B' + beta*C
*
            DO 170, J = 1, N
               IF( BETA.EQ.ZERO )THEN
                  DO 130, I = 1, M
                     C( I, J ) = ZERO
  130             CONTINUE
               ELSE IF( BETA.NE.ONE )THEN
                  DO 140, I = 1, M
                     C( I, J ) = BETA*C( I, J )
  140             CONTINUE
               END IF
               DO 160, L = 1, K
                  IF( B( J, L ).NE.ZERO )THEN
                     TEMP = ALPHA*B( J, L )
                     DO 150, I = 1, M
                        C( I, J ) = C( I, J ) + TEMP*A( I, L )
  150                CONTINUE
                  END IF
  160          CONTINUE
  170       CONTINUE
         ELSE
*

*           Form  C := alpha*A'*B' + beta*C
*
            DO 200, J = 1, N
               DO 190, I = 1, M
                  TEMP = ZERO
                  DO 180, L = 1, K
                     TEMP = TEMP + A( L, I )*B( J, L )
  180             CONTINUE
                  IF( BETA.EQ.ZERO )THEN
                     C( I, J ) = ALPHA*TEMP
                  ELSE
                     C( I, J ) = ALPHA*TEMP + BETA*C( I, J )
                  END IF
  190          CONTINUE
  200       CONTINUE
         END IF
      END IF
*
      RETURN
*
*     End of DGEMM .
*
      END
      SUBROUTINE DGEMV ( TRANS, M, N, ALPHA, A, LDA, X, INCX,
     $                   BETA, Y, INCY )

*     .. Scalar Arguments ..
      DOUBLE PRECISION   ALPHA, BETA
      INTEGER            INCX, INCY, LDA, M, N
      CHARACTER*1        TRANS
*     .. Array Arguments ..
      DOUBLE PRECISION   A( LDA, * ), X( * ), Y( * )
*     ..
*
*  Purpose

*  =======
*
*  DGEMV  performs one of the matrix-vector operations
*
*     y := alpha*A*x + beta*y,   or   y := alpha*A'*x + beta*y,
*
*  where alpha and beta are scalars, x and y are vectors and A is an
*  m by n matrix.
*
*  Parameters
*  ==========
*
*  TRANS  - CHARACTER*1.
*           On entry, TRANS specifies the operation to be performed as
*           follows:
*
*              TRANS = 'N' or 'n'   y := alpha*A*x + beta*y.
*
*              TRANS = 'T' or 't'   y := alpha*A'*x + beta*y.
*
*              TRANS = 'C' or 'c'   y := alpha*A'*x + beta*y.
*
*           Unchanged on exit.
*
*  M      - INTEGER.
*           On entry, M specifies the number of rows of the matrix A.
*           M must be at least zero.
*           Unchanged on exit.
*
*  N      - INTEGER.
*           On entry, N specifies the number of columns of the matrix A.
*           N must be at least zero.
*           Unchanged on exit.

*
*  ALPHA  - DOUBLE PRECISION.
*           On entry, ALPHA specifies the scalar alpha.
*           Unchanged on exit.
*
*  A      - DOUBLE PRECISION array of DIMENSION ( LDA, n ).
*           Before entry, the leading m by n part of the array A must
*           contain the matrix of coefficients.
*           Unchanged on exit.
*
*  LDA    - INTEGER.
*           On entry, LDA specifies the first dimension of A as declared
*           in the calling (sub) program. LDA must be at least
*           max( 1, m ).
*           Unchanged on exit.
*
*  X      - DOUBLE PRECISION array of DIMENSION at least
*           ( 1 + ( n - 1 )*abs( INCX ) ) when TRANS = 'N' or 'n'

*           and at least
*           ( 1 + ( m - 1 )*abs( INCX ) ) otherwise.
*           Before entry, the incremented array X must contain the

*           vector x.
*           Unchanged on exit.
*



*  INCX   - INTEGER.
*           On entry, INCX specifies the increment for the elements of
*           X. INCX must not be zero.
*           Unchanged on exit.
*
*  BETA   - DOUBLE PRECISION.
*           On entry, BETA specifies the scalar beta. When BETA is
*           supplied as zero then Y need not be set on input.
*           Unchanged on exit.
*
*  Y      - DOUBLE PRECISION array of DIMENSION at least

*           ( 1 + ( m - 1 )*abs( INCY ) ) when TRANS = 'N' or 'n'
*           and at least
*           ( 1 + ( n - 1 )*abs( INCY ) ) otherwise.

*           Before entry with BETA non-zero, the incremented array Y
*           must contain the vector y. On exit, Y is overwritten by the
*           updated vector y.
*
*  INCY   - INTEGER.
*           On entry, INCY specifies the increment for the elements of
*           Y. INCY must not be zero.
*           Unchanged on exit.

*
*
*  Level 2 Blas routine.
*
*  -- Written on 22-October-1986.
*     Jack Dongarra, Argonne National Lab.
*     Jeremy Du Croz, Nag Central Office.
*     Sven Hammarling, Nag Central Office.
*     Richard Hanson, Sandia National Labs.
*
*
*     .. Parameters ..
      DOUBLE PRECISION   ONE         , ZERO
      PARAMETER        ( ONE = 1.0D+0, ZERO = 0.0D+0 )
*     .. Local Scalars ..
      DOUBLE PRECISION   TEMP
      INTEGER            I, INFO, IX, IY, J, JX, JY, KX, KY, LENX, LENY
*     .. External Functions ..
      LOGICAL            LSAME
      EXTERNAL           LSAME
*     .. External Subroutines ..
      EXTERNAL           XERBLA
*     .. Intrinsic Functions ..
      INTRINSIC          MAX
*     ..
*     .. Executable Statements ..
*
*     Test the input parameters.

*
      INFO = 0
      IF     ( .NOT.LSAME( TRANS, 'N' ).AND.
     $         .NOT.LSAME( TRANS, 'T' ).AND.
     $         .NOT.LSAME( TRANS, 'C' )      )THEN
         INFO = 1
      ELSE IF( M.LT.0 )THEN
         INFO = 2
      ELSE IF( N.LT.0 )THEN
         INFO = 3
      ELSE IF( LDA.LT.MAX( 1, M ) )THEN
         INFO = 6
      ELSE IF( INCX.EQ.0 )THEN

         INFO = 8
      ELSE IF( INCY.EQ.0 )THEN
         INFO = 11
      END IF
      IF( INFO.NE.0 )THEN
         CALL XERBLA( 'DGEMV ', INFO )
         RETURN
      END IF
*

*     Quick return if possible.
*
      IF( ( M.EQ.0 ).OR.( N.EQ.0 ).OR.
     $    ( ( ALPHA.EQ.ZERO ).AND.( BETA.EQ.ONE ) ) )
     $   RETURN
*
*     Set  LENX  and  LENY, the lengths of the vectors x and y, and set
*     up the start points in  X  and  Y.
*
      IF( LSAME( TRANS, 'N' ) )THEN
         LENX = N
         LENY = M
      ELSE
         LENX = M
         LENY = N
      END IF
      IF( INCX.GT.0 )THEN
         KX = 1
      ELSE

         KX = 1 - ( LENX - 1 )*INCX
      END IF
      IF( INCY.GT.0 )THEN
         KY = 1

      ELSE
         KY = 1 - ( LENY - 1 )*INCY
      END IF
*

*     Start the operations. In this version the elements of A are
*     accessed sequentially with one pass through A.
*
*     First form  y := beta*y.
*
      IF( BETA.NE.ONE )THEN

         IF( INCY.EQ.1 )THEN
            IF( BETA.EQ.ZERO )THEN
               DO 10, I = 1, LENY
                  Y( I ) = ZERO

   10          CONTINUE
            ELSE
               DO 20, I = 1, LENY
                  Y( I ) = BETA*Y( I )
   20          CONTINUE
            END IF
         ELSE
            IY = KY
            IF( BETA.EQ.ZERO )THEN
               DO 30, I = 1, LENY
                  Y( IY ) = ZERO
                  IY      = IY   + INCY
   30          CONTINUE
            ELSE
               DO 40, I = 1, LENY
                  Y( IY ) = BETA*Y( IY )
                  IY      = IY           + INCY
   40          CONTINUE
            END IF
         END IF
      END IF
      IF( ALPHA.EQ.ZERO )
     $   RETURN

      IF( LSAME( TRANS, 'N' ) )THEN
*
*        Form  y := alpha*A*x + y.
*
         JX = KX
         IF( INCY.EQ.1 )THEN
            DO 60, J = 1, N
               IF( X( JX ).NE.ZERO )THEN
                  TEMP = ALPHA*X( JX )
                  DO 50, I = 1, M
                     Y( I ) = Y( I ) + TEMP*A( I, J )
   50             CONTINUE
               END IF
               JX = JX + INCX
   60       CONTINUE
         ELSE

            DO 80, J = 1, N
               IF( X( JX ).NE.ZERO )THEN

                  TEMP = ALPHA*X( JX )
                  IY   = KY
                  DO 70, I = 1, M
                     Y( IY ) = Y( IY ) + TEMP*A( I, J )
                     IY      = IY      + INCY
   70             CONTINUE
               END IF

               JX = JX + INCX
   80       CONTINUE

         END IF
      ELSE
*
*        Form  y := alpha*A'*x + y.
*
         JY = KY
         IF( INCX.EQ.1 )THEN
            DO 100, J = 1, N
               TEMP = ZERO
               DO 90, I = 1, M
                  TEMP = TEMP + A( I, J )*X( I )
   90          CONTINUE
               Y( JY ) = Y( JY ) + ALPHA*TEMP
               JY      = JY      + INCY
  100       CONTINUE
         ELSE
            DO 120, J = 1, N
               TEMP = ZERO
               IX   = KX
               DO 110, I = 1, M
                  TEMP = TEMP + A( I, J )*X( IX )

                  IX   = IX   + INCX
  110          CONTINUE
               Y( JY ) = Y( JY ) + ALPHA*TEMP
               JY      = JY      + INCY

  120       CONTINUE
         END IF


      END IF
*
      RETURN

*
*     End of DGEMV .
*
      END
      SUBROUTINE DSYRK ( UPLO, TRANS, N, K, ALPHA, A, LDA,
     $                   BETA, C, LDC )
*     .. Scalar Arguments ..
      CHARACTER*1        UPLO, TRANS
      INTEGER            N, K, LDA, LDC
      DOUBLE PRECISION   ALPHA, BETA
*     .. Array Arguments ..
      DOUBLE PRECISION   A( LDA, * ), C( LDC, * )
*     ..
*
*  Purpose
*  =======
*
*  DSYRK  performs one of the symmetric rank k operations
*
*     C := alpha*A*A' + beta*C,
*
*  or

*
*     C := alpha*A'*A + beta*C,
*
*  where  alpha and beta  are scalars, C is an  n by n  symmetric matrix
*  and  A  is an  n by k  matrix in the first case and a  k by n  matrix
*  in the second case.
*

*  Parameters
*  ==========
*
*  UPLO   - CHARACTER*1.
*           On  entry,   UPLO  specifies  whether  the  upper  or  lower
*           triangular  part  of the  array  C  is to be  referenced  as
*           follows:
*
*              UPLO = 'U' or 'u'   Only the  upper triangular part of  C
*                                  is to be referenced.


*
*              UPLO = 'L' or 'l'   Only the  lower triangular part of  C
*                                  is to be referenced.
*
*           Unchanged on exit.
*
*  TRANS  - CHARACTER*1.
*           On entry,  TRANS  specifies the operation to be performed as
*           follows:
*
*              TRANS = 'N' or 'n'   C := alpha*A*A' + beta*C.
*
*              TRANS = 'T' or 't'   C := alpha*A'*A + beta*C.
*
*              TRANS = 'C' or 'c'   C := alpha*A'*A + beta*C.
*
*           Unchanged on exit.

*

*  N      - INTEGER.
*           On entry,  N specifies the order of the matrix C.  N must be
*           at least zero.
*           Unchanged on exit.
*
*  K      - INTEGER.
*           On entry with  TRANS = 'N' or 'n',  K  specifies  the number
*           of  columns   of  the   matrix   A,   and  on   entry   with
*           TRANS = 'T' or 't' or 'C' or 'c',  K  specifies  the  number
*           of rows of the matrix  A.  K must be at least zero.
*           Unchanged on exit.
*
*  ALPHA  - DOUBLE PRECISION.
*           On entry, ALPHA specifies the scalar alpha.
*           Unchanged on exit.
*
*  A      - DOUBLE PRECISION array of DIMENSION ( LDA, ka ), where ka is
*           k  when  TRANS = 'N' or 'n',  and is  n  otherwise.

*           Before entry with  TRANS = 'N' or 'n',  the  leading  n by k
*           part of the array  A  must contain the matrix  A,  otherwise
*           the leading  k by n  part of the array  A  must contain  the
*           matrix A.
*           Unchanged on exit.
*
*  LDA    - INTEGER.

*           On entry, LDA specifies the first dimension of A as declared
*           in  the  calling  (sub)  program.   When  TRANS = 'N' or 'n'
*           then  LDA must be at least  max( 1, n ), otherwise  LDA must

*           be at least  max( 1, k ).
*           Unchanged on exit.

*
*  BETA   - DOUBLE PRECISION.
*           On entry, BETA specifies the scalar beta.
*           Unchanged on exit.
*
*  C      - DOUBLE PRECISION array of DIMENSION ( LDC, n ).
*           Before entry  with  UPLO = 'U' or 'u',  the leading  n by n
*           upper triangular part of the array C must contain the upper
*           triangular part  of the  symmetric matrix  and the strictly

*           lower triangular part of C is not referenced.  On exit, the
*           upper triangular part of the array  C is overwritten by the
*           upper triangular part of the updated matrix.
*           Before entry  with  UPLO = 'L' or 'l',  the leading  n by n



*           lower triangular part of the array C must contain the lower
*           triangular part  of the  symmetric matrix  and the strictly
*           upper triangular part of C is not referenced.  On exit, the
*           lower triangular part of the array  C is overwritten by the
*           lower triangular part of the updated matrix.
*
*  LDC    - INTEGER.
*           On entry, LDC specifies the first dimension of C as declared
*           in  the  calling  (sub)  program.   LDC  must  be  at  least
*           max( 1, n ).
*           Unchanged on exit.

*
*
*  Level 3 Blas routine.
*
*  -- Written on 8-February-1989.

*     Jack Dongarra, Argonne National Laboratory.
*     Iain Duff, AERE Harwell.
*     Jeremy Du Croz, Numerical Algorithms Group Ltd.
*     Sven Hammarling, Numerical Algorithms Group Ltd.
*
*
*     .. External Functions ..
      LOGICAL            LSAME
      EXTERNAL           LSAME
*     .. External Subroutines ..
      EXTERNAL           XERBLA
*     .. Intrinsic Functions ..
      INTRINSIC          MAX
*     .. Local Scalars ..
      LOGICAL            UPPER
      INTEGER            I, INFO, J, L, NROWA
      DOUBLE PRECISION   TEMP
*     .. Parameters ..
      DOUBLE PRECISION   ONE ,         ZERO

      PARAMETER        ( ONE = 1.0D+0, ZERO = 0.0D+0 )
*     ..
*     .. Executable Statements ..
*

*     Test the input parameters.
*
      IF( LSAME( TRANS, 'N' ) )THEN
         NROWA = N
      ELSE
         NROWA = K
      END IF
      UPPER = LSAME( UPLO, 'U' )
*
      INFO = 0
      IF(      ( .NOT.UPPER               ).AND.

     $         ( .NOT.LSAME( UPLO , 'L' ) )      )THEN
         INFO = 1
      ELSE IF( ( .NOT.LSAME( TRANS, 'N' ) ).AND.
     $         ( .NOT.LSAME( TRANS, 'T' ) ).AND.
     $         ( .NOT.LSAME( TRANS, 'C' ) )      )THEN
         INFO = 2
      ELSE IF( N  .LT.0               )THEN
         INFO = 3
      ELSE IF( K  .LT.0               )THEN

         INFO = 4
      ELSE IF( LDA.LT.MAX( 1, NROWA ) )THEN
         INFO = 7
      ELSE IF( LDC.LT.MAX( 1, N     ) )THEN
         INFO = 10
      END IF

      IF( INFO.NE.0 )THEN
         CALL XERBLA( 'DSYRK ', INFO )
         RETURN
      END IF
*
*     Quick return if possible.
*
      IF( ( N.EQ.0 ).OR.
     $    ( ( ( ALPHA.EQ.ZERO ).OR.( K.EQ.0 ) ).AND.( BETA.EQ.ONE ) ) )
     $   RETURN

*

*     And when  alpha.eq.zero.
*
      IF( ALPHA.EQ.ZERO )THEN
         IF( UPPER )THEN
            IF( BETA.EQ.ZERO )THEN
               DO 20, J = 1, N
                  DO 10, I = 1, J
                     C( I, J ) = ZERO
   10             CONTINUE
   20          CONTINUE
            ELSE
               DO 40, J = 1, N
                  DO 30, I = 1, J
                     C( I, J ) = BETA*C( I, J )
   30             CONTINUE
   40          CONTINUE
            END IF

         ELSE
            IF( BETA.EQ.ZERO )THEN
               DO 60, J = 1, N
                  DO 50, I = J, N
                     C( I, J ) = ZERO


   50             CONTINUE
   60          CONTINUE
            ELSE
               DO 80, J = 1, N
                  DO 70, I = J, N
                     C( I, J ) = BETA*C( I, J )
   70             CONTINUE
   80          CONTINUE
            END IF
         END IF
         RETURN

      END IF
*
*     Start the operations.
*
      IF( LSAME( TRANS, 'N' ) )THEN
*
*        Form  C := alpha*A*A' + beta*C.
*
         IF( UPPER )THEN
            DO 130, J = 1, N
               IF( BETA.EQ.ZERO )THEN
                  DO 90, I = 1, J
                     C( I, J ) = ZERO
   90             CONTINUE
               ELSE IF( BETA.NE.ONE )THEN
                  DO 100, I = 1, J
                     C( I, J ) = BETA*C( I, J )
  100             CONTINUE

               END IF

               DO 120, L = 1, K
                  IF( A( J, L ).NE.ZERO )THEN
                     TEMP = ALPHA*A( J, L )
                     DO 110, I = 1, J
                        C( I, J ) = C( I, J ) + TEMP*A( I, L )
  110                CONTINUE
                  END IF
  120          CONTINUE
  130       CONTINUE
         ELSE
            DO 180, J = 1, N
               IF( BETA.EQ.ZERO )THEN
                  DO 140, I = J, N
                     C( I, J ) = ZERO
  140             CONTINUE
               ELSE IF( BETA.NE.ONE )THEN
                  DO 150, I = J, N

                     C( I, J ) = BETA*C( I, J )
  150             CONTINUE
               END IF
               DO 170, L = 1, K
                  IF( A( J, L ).NE.ZERO )THEN
                     TEMP      = ALPHA*A( J, L )
                     DO 160, I = J, N
                        C( I, J ) = C( I, J ) + TEMP*A( I, L )
  160                CONTINUE
                  END IF
  170          CONTINUE
  180       CONTINUE
         END IF
      ELSE
*
*        Form  C := alpha*A'*A + beta*C.
*
         IF( UPPER )THEN
            DO 210, J = 1, N
               DO 200, I = 1, J
                  TEMP = ZERO
                  DO 190, L = 1, K
                     TEMP = TEMP + A( L, I )*A( L, J )
  190             CONTINUE

                  IF( BETA.EQ.ZERO )THEN
                     C( I, J ) = ALPHA*TEMP
                  ELSE
                     C( I, J ) = ALPHA*TEMP + BETA*C( I, J )
                  END IF
  200          CONTINUE
  210       CONTINUE
         ELSE
            DO 240, J = 1, N
               DO 230, I = J, N
                  TEMP = ZERO
                  DO 220, L = 1, K
                     TEMP = TEMP + A( L, I )*A( L, J )
  220             CONTINUE
                  IF( BETA.EQ.ZERO )THEN
                     C( I, J ) = ALPHA*TEMP
                  ELSE
                     C( I, J ) = ALPHA*TEMP + BETA*C( I, J )
                  END IF

  230          CONTINUE
  240       CONTINUE
         END IF
      END IF
*
      RETURN
*
*     End of DSYRK .
*
      END
      SUBROUTINE DTRSM ( SIDE, UPLO, TRANSA, DIAG, M, N, ALPHA, A, LDA,
     $                   B, LDB )
*     .. Scalar Arguments ..

      CHARACTER*1        SIDE, UPLO, TRANSA, DIAG
      INTEGER            M, N, LDA, LDB

      DOUBLE PRECISION   ALPHA
*     .. Array Arguments ..
      DOUBLE PRECISION   A( LDA, * ), B( LDB, * )
*     ..
*
*  Purpose
*  =======
*
*  DTRSM  solves one of the matrix equations
*
*     op( A )*X = alpha*B,   or   X*op( A ) = alpha*B,
*
*  where alpha is a scalar, X and B are m by n matrices, A is a unit, or
*  non-unit,  upper or lower triangular matrix  and  op( A )  is one  of
*
*     op( A ) = A   or   op( A ) = A'.
*
*  The matrix X is overwritten on B.
*
*  Parameters
*  ==========
*
*  SIDE   - CHARACTER*1.
*           On entry, SIDE specifies whether op( A ) appears on the left
*           or right of X as follows:
*
*              SIDE = 'L' or 'l'   op( A )*X = alpha*B.
*
*              SIDE = 'R' or 'r'   X*op( A ) = alpha*B.
*
*           Unchanged on exit.
*
*  UPLO   - CHARACTER*1.
*           On entry, UPLO specifies whether the matrix A is an upper or
*           lower triangular matrix as follows:
*

*              UPLO = 'U' or 'u'   A is an upper triangular matrix.
*

*              UPLO = 'L' or 'l'   A is a lower triangular matrix.
*
*           Unchanged on exit.
*
*  TRANSA - CHARACTER*1.
*           On entry, TRANSA specifies the form of op( A ) to be used in
*           the matrix multiplication as follows:
*
*              TRANSA = 'N' or 'n'   op( A ) = A.
*
*              TRANSA = 'T' or 't'   op( A ) = A'.

*
*              TRANSA = 'C' or 'c'   op( A ) = A'.
*
*           Unchanged on exit.
*
*  DIAG   - CHARACTER*1.
*           On entry, DIAG specifies whether or not A is unit triangular
*           as follows:


*
*              DIAG = 'U' or 'u'   A is assumed to be unit triangular.
*
*              DIAG = 'N' or 'n'   A is not assumed to be unit
*                                  triangular.
*
*           Unchanged on exit.
*
*  M      - INTEGER.
*           On entry, M specifies the number of rows of B. M must be at
*           least zero.
*           Unchanged on exit.

*
*  N      - INTEGER.
*           On entry, N specifies the number of columns of B.  N must be
*           at least zero.
*           Unchanged on exit.
*

*  ALPHA  - DOUBLE PRECISION.
*           On entry,  ALPHA specifies the scalar  alpha. When  alpha is
*           zero then  A is not referenced and  B need not be set before
*           entry.
*           Unchanged on exit.
*
*  A      - DOUBLE PRECISION array of DIMENSION ( LDA, k ), where k is m
*           when  SIDE = 'L' or 'l'  and is  n  when  SIDE = 'R' or 'r'.
*           Before entry  with  UPLO = 'U' or 'u',  the  leading  k by k
*           upper triangular part of the array  A must contain the upper
*           triangular matrix  and the strictly lower triangular part of

*           A is not referenced.
*           Before entry  with  UPLO = 'L' or 'l',  the  leading  k by k
*           lower triangular part of the array  A must contain the lower
*           triangular matrix  and the strictly upper triangular part of

*           A is not referenced.
*           Note that when  DIAG = 'U' or 'u',  the diagonal elements of
*           A  are not referenced either,  but are assumed to be  unity.
*           Unchanged on exit.
*

*  LDA    - INTEGER.
*           On entry, LDA specifies the first dimension of A as declared
*           in the calling (sub) program.  When  SIDE = 'L' or 'l'  then
*           LDA  must be at least  max( 1, m ),  when  SIDE = 'R' or 'r'
*           then LDA must be at least max( 1, n ).
*           Unchanged on exit.
*
*  B      - DOUBLE PRECISION array of DIMENSION ( LDB, n ).
*           Before entry,  the leading  m by n part of the array  B must
*           contain  the  right-hand  side  matrix  B,  and  on exit  is
*           overwritten by the solution matrix  X.
*
*  LDB    - INTEGER.
*           On entry, LDB specifies the first dimension of B as declared
*           in  the  calling  (sub)  program.   LDB  must  be  at  least
*           max( 1, m ).
*           Unchanged on exit.
*
*
*  Level 3 Blas routine.
*
*
*  -- Written on 8-February-1989.
*     Jack Dongarra, Argonne National Laboratory.
*     Iain Duff, AERE Harwell.
*     Jeremy Du Croz, Numerical Algorithms Group Ltd.
*     Sven Hammarling, Numerical Algorithms Group Ltd.
*
*
*     .. External Functions ..
      LOGICAL            LSAME
      EXTERNAL           LSAME
*     .. External Subroutines ..
      EXTERNAL           XERBLA
*     .. Intrinsic Functions ..
      INTRINSIC          MAX
*     .. Local Scalars ..
      LOGICAL            LSIDE, NOUNIT, UPPER

      INTEGER            I, INFO, J, K, NROWA
      DOUBLE PRECISION   TEMP
*     .. Parameters ..
      DOUBLE PRECISION   ONE         , ZERO
      PARAMETER        ( ONE = 1.0D+0, ZERO = 0.0D+0 )
*     ..
*     .. Executable Statements ..
*
*     Test the input parameters.
*
      LSIDE  = LSAME( SIDE  , 'L' )
      IF( LSIDE )THEN
         NROWA = M
      ELSE
         NROWA = N
      END IF
      NOUNIT = LSAME( DIAG  , 'N' )
      UPPER  = LSAME( UPLO  , 'U' )
*
      INFO   = 0
      IF(      ( .NOT.LSIDE                ).AND.
     $         ( .NOT.LSAME( SIDE  , 'R' ) )      )THEN
         INFO = 1
      ELSE IF( ( .NOT.UPPER                ).AND.

     $         ( .NOT.LSAME( UPLO  , 'L' ) )      )THEN
         INFO = 2
      ELSE IF( ( .NOT.LSAME( TRANSA, 'N' ) ).AND.
     $         ( .NOT.LSAME( TRANSA, 'T' ) ).AND.
     $         ( .NOT.LSAME( TRANSA, 'C' ) )      )THEN
         INFO = 3
      ELSE IF( ( .NOT.LSAME( DIAG  , 'U' ) ).AND.
     $         ( .NOT.LSAME( DIAG  , 'N' ) )      )THEN
         INFO = 4
      ELSE IF( M  .LT.0               )THEN
         INFO = 5

      ELSE IF( N  .LT.0               )THEN
         INFO = 6

      ELSE IF( LDA.LT.MAX( 1, NROWA ) )THEN
         INFO = 9
      ELSE IF( LDB.LT.MAX( 1, M     ) )THEN
         INFO = 11
      END IF
      IF( INFO.NE.0 )THEN
         CALL XERBLA( 'DTRSM ', INFO )
         RETURN
      END IF
*
*     Quick return if possible.
*
      IF( N.EQ.0 )

     $   RETURN
*
*     And when  alpha.eq.zero.
*
      IF( ALPHA.EQ.ZERO )THEN
         DO 20, J = 1, N

            DO 10, I = 1, M
               B( I, J ) = ZERO

   10       CONTINUE
   20    CONTINUE
         RETURN

      END IF
*
*     Start the operations.
*
      IF( LSIDE )THEN
         IF( LSAME( TRANSA, 'N' ) )THEN
*

*           Form  B := alpha*inv( A )*B.
*
            IF( UPPER )THEN
               DO 60, J = 1, N
                  IF( ALPHA.NE.ONE )THEN
                     DO 30, I = 1, M
                        B( I, J ) = ALPHA*B( I, J )
   30                CONTINUE
                  END IF
                  DO 50, K = M, 1, -1
                     IF( B( K, J ).NE.ZERO )THEN
                        IF( NOUNIT )
     $                     B( K, J ) = B( K, J )/A( K, K )
                        DO 40, I = 1, K - 1
                           B( I, J ) = B( I, J ) - B( K, J )*A( I, K )
   40                   CONTINUE
                     END IF
   50             CONTINUE
   60          CONTINUE
            ELSE
               DO 100, J = 1, N
                  IF( ALPHA.NE.ONE )THEN
                     DO 70, I = 1, M
                        B( I, J ) = ALPHA*B( I, J )
   70                CONTINUE
                  END IF
                  DO 90 K = 1, M
                     IF( B( K, J ).NE.ZERO )THEN
                        IF( NOUNIT )
     $                     B( K, J ) = B( K, J )/A( K, K )
                        DO 80, I = K + 1, M
                           B( I, J ) = B( I, J ) - B( K, J )*A( I, K )

   80                   CONTINUE
                     END IF
   90             CONTINUE
  100          CONTINUE


            END IF
         ELSE
*
*           Form  B := alpha*inv( A' )*B.
*
            IF( UPPER )THEN

               DO 130, J = 1, N

                  DO 120, I = 1, M
                     TEMP = ALPHA*B( I, J )
                     DO 110, K = 1, I - 1

                        TEMP = TEMP - A( K, I )*B( K, J )
  110                CONTINUE

                     IF( NOUNIT )

     $                  TEMP = TEMP/A( I, I )
                     B( I, J ) = TEMP
  120             CONTINUE
  130          CONTINUE
            ELSE
               DO 160, J = 1, N
                  DO 150, I = M, 1, -1

                     TEMP = ALPHA*B( I, J )
                     DO 140, K = I + 1, M
                        TEMP = TEMP - A( K, I )*B( K, J )
  140                CONTINUE
                     IF( NOUNIT )
     $                  TEMP = TEMP/A( I, I )
                     B( I, J ) = TEMP
  150             CONTINUE
  160          CONTINUE
            END IF
         END IF
      ELSE
         IF( LSAME( TRANSA, 'N' ) )THEN
*
*           Form  B := alpha*B*inv( A ).
*
            IF( UPPER )THEN
               DO 210, J = 1, N
                  IF( ALPHA.NE.ONE )THEN
                     DO 170, I = 1, M
                        B( I, J ) = ALPHA*B( I, J )
  170                CONTINUE
                  END IF
                  DO 190, K = 1, J - 1
                     IF( A( K, J ).NE.ZERO )THEN
                        DO 180, I = 1, M
                           B( I, J ) = B( I, J ) - A( K, J )*B( I, K )
  180                   CONTINUE
                     END IF
  190             CONTINUE
                  IF( NOUNIT )THEN
                     TEMP = ONE/A( J, J )
                     DO 200, I = 1, M
                        B( I, J ) = TEMP*B( I, J )
  200                CONTINUE
                  END IF
  210          CONTINUE
            ELSE
               DO 260, J = N, 1, -1
                  IF( ALPHA.NE.ONE )THEN
                     DO 220, I = 1, M

                        B( I, J ) = ALPHA*B( I, J )
  220                CONTINUE

                  END IF

                  DO 240, K = J + 1, N
                     IF( A( K, J ).NE.ZERO )THEN
                        DO 230, I = 1, M
                           B( I, J ) = B( I, J ) - A( K, J )*B( I, K )
  230                   CONTINUE
                     END IF
  240             CONTINUE
                  IF( NOUNIT )THEN
                     TEMP = ONE/A( J, J )
                     DO 250, I = 1, M
                       B( I, J ) = TEMP*B( I, J )
  250                CONTINUE

                  END IF
  260          CONTINUE
            END IF
         ELSE
*
*           Form  B := alpha*B*inv( A' ).
*
            IF( UPPER )THEN
               DO 310, K = N, 1, -1
                  IF( NOUNIT )THEN
                     TEMP = ONE/A( K, K )
                     DO 270, I = 1, M
                        B( I, K ) = TEMP*B( I, K )
  270                CONTINUE
                  END IF
                  DO 290, J = 1, K - 1
                     IF( A( J, K ).NE.ZERO )THEN
                        TEMP = A( J, K )

                        DO 280, I = 1, M
                           B( I, J ) = B( I, J ) - TEMP*B( I, K )
  280                   CONTINUE
                     END IF
  290             CONTINUE
                  IF( ALPHA.NE.ONE )THEN
                     DO 300, I = 1, M
                        B( I, K ) = ALPHA*B( I, K )

  300                CONTINUE
                  END IF
  310          CONTINUE
            ELSE
               DO 360, K = 1, N
                  IF( NOUNIT )THEN
                     TEMP = ONE/A( K, K )
                     DO 320, I = 1, M
                        B( I, K ) = TEMP*B( I, K )
  320                CONTINUE
                  END IF
                  DO 340, J = K + 1, N
                     IF( A( J, K ).NE.ZERO )THEN
                        TEMP = A( J, K )
                        DO 330, I = 1, M
                           B( I, J ) = B( I, J ) - TEMP*B( I, K )
  330                   CONTINUE
                     END IF
  340             CONTINUE
                  IF( ALPHA.NE.ONE )THEN

                     DO 350, I = 1, M
                        B( I, K ) = ALPHA*B( I, K )
  350                CONTINUE
                  END IF
  360          CONTINUE
            END IF
         END IF
      END IF
*
      RETURN
*
*     End of DTRSM .
*
      END
      subroutine  dcopy(n,dx,incx,dy,incy)
c
c     copies a vector, x, to a vector, y.
c     uses unrolled loops for increments equal to one.
c     jack dongarra, linpack, 3/11/78.
c     modified 12/3/93, array(1) declarations changed to array(*)
c
      double precision dx(*),dy(*)
      integer i,incx,incy,ix,iy,m,mp1,n
c
      if(n.le.0)return
      if(incx.eq.1.and.incy.eq.1)go to 20
c
c        code for unequal increments or equal increments
c          not equal to 1
c
      ix = 1
      iy = 1
      if(incx.lt.0)ix = (-n+1)*incx + 1
      if(incy.lt.0)iy = (-n+1)*incy + 1
      do 10 i = 1,n
        dy(iy) = dx(ix)
        ix = ix + incx
        iy = iy + incy
   10 continue
      return
c
c        code for both increments equal to 1


c
c
c        clean-up loop

c
   20 m = mod(n,7)
      if( m .eq. 0 ) go to 40
      do 30 i = 1,m
        dy(i) = dx(i)
   30 continue
      if( n .lt. 7 ) return
   40 mp1 = m + 1
      do 50 i = mp1,n,7
        dy(i) = dx(i)
        dy(i + 1) = dx(i + 1)
        dy(i + 2) = dx(i + 2)
        dy(i + 3) = dx(i + 3)
        dy(i + 4) = dx(i + 4)
        dy(i + 5) = dx(i + 5)

        dy(i + 6) = dx(i + 6)
   50 continue
      return
      end

 

C-----------------------------------------------------------------------
 
      subroutine  dscal(n,da,dx,incx)
c
c     scales a vector by a constant.

c     uses unrolled loops for increment equal to one.
c     jack dongarra, linpack, 3/11/78.
c     modified 3/93 to return if incx .le. 0.
c     modified 12/3/93, array(1) declarations changed to array(*)
c
      double precision da,dx(*)
      integer i,incx,m,mp1,n,nincx
c

      if( n.le.0 .or. incx.le.0 )return
      if(incx.eq.1)go to 20
c
c        code for increment not equal to 1
c
      nincx = n*incx
      do 10 i = 1,nincx,incx
        dx(i) = da*dx(i)
   10 continue
      return
c
c        code for increment equal to 1
c
c
c        clean-up loop

c
   20 m = mod(n,5)
      if( m .eq. 0 ) go to 40
      do 30 i = 1,m
        dx(i) = da*dx(i)
   30 continue
      if( n .lt. 5 ) return
   40 mp1 = m + 1
      do 50 i = mp1,n,5

        dx(i) = da*dx(i)
        dx(i + 1) = da*dx(i + 1)
        dx(i + 2) = da*dx(i + 2)
        dx(i + 3) = da*dx(i + 3)
        dx(i + 4) = da*dx(i + 4)
   50 continue
      return
      end
 
C-----------------------------------------------------------------------
 
      subroutine daxpy(n,da,dx,incx,dy,incy)
c
c     constant times a vector plus a vector.
c     uses unrolled loops for increments equal to one.
c     jack dongarra, linpack, 3/11/78.
c     modified 12/3/93, array(1) declarations changed to array(*)
c
      double precision dx(*),dy(*),da
      integer i,incx,incy,ix,iy,m,mp1,n
c
      if(n.le.0)return
      if (da .eq. 0.0d0) return
      if(incx.eq.1.and.incy.eq.1)go to 20
c
c        code for unequal increments or equal increments
c          not equal to 1
c
      ix = 1

      iy = 1
      if(incx.lt.0)ix = (-n+1)*incx + 1
      if(incy.lt.0)iy = (-n+1)*incy + 1
      do 10 i = 1,n
        dy(iy) = dy(iy) + da*dx(ix)
        ix = ix + incx
        iy = iy + incy
   10 continue
      return
c
c        code for both increments equal to 1
c
c
c        clean-up loop
c

   20 m = mod(n,4)
      if( m .eq. 0 ) go to 40
      do 30 i = 1,m
        dy(i) = dy(i) + da*dx(i)

   30 continue
      if( n .lt. 4 ) return
   40 mp1 = m + 1
      do 50 i = mp1,n,4
        dy(i) = dy(i) + da*dx(i)

        dy(i + 1) = dy(i + 1) + da*dx(i + 1)
        dy(i + 2) = dy(i + 2) + da*dx(i + 2)
        dy(i + 3) = dy(i + 3) + da*dx(i + 3)
   50 continue
      return
      end
 

C-----------------------------------------------------------------------
 
      double precision function ddot(n,dx,incx,dy,incy)
c
c     forms the dot product of two vectors.
c     uses unrolled loops for increments equal to one.
c     jack dongarra, linpack, 3/11/78.
c     modified 12/3/93, array(1) declarations changed to array(*)


c
      double precision dx(*),dy(*),dtemp
      integer i,incx,incy,ix,iy,m,mp1,n
c
      ddot = 0.0d0
      dtemp = 0.0d0
      if(n.le.0)return
      if(incx.eq.1.and.incy.eq.1)go to 20
c
c        code for unequal increments or equal increments
c          not equal to 1
c

      ix = 1
      iy = 1
      if(incx.lt.0)ix = (-n+1)*incx + 1
      if(incy.lt.0)iy = (-n+1)*incy + 1
      do 10 i = 1,n
        dtemp = dtemp + dx(ix)*dy(iy)

        ix = ix + incx
        iy = iy + incy

   10 continue
      ddot = dtemp

      return
c
c        code for both increments equal to 1
c
c
c        clean-up loop
c
   20 m = mod(n,5)
      if( m .eq. 0 ) go to 40
      do 30 i = 1,m
        dtemp = dtemp + dx(i)*dy(i)
   30 continue
      if( n .lt. 5 ) go to 60
   40 mp1 = m + 1
      do 50 i = mp1,n,5
        dtemp = dtemp + dx(i)*dy(i) + dx(i + 1)*dy(i + 1) +
     *   dx(i + 2)*dy(i + 2) + dx(i + 3)*dy(i + 3) + dx(i + 4)*dy(i + 4)
   50 continue

   60 ddot = dtemp
      return
      end
 
 
C-----------------------------------------------------------------------
 
      integer function idamax(n,dx,incx)
c

c     finds the index of element having max. absolute value.
c     jack dongarra, linpack, 3/11/78.
c     modified 3/93 to return if incx .le. 0.
c     modified 12/3/93, array(1) declarations changed to array(*)
c
      double precision dx(*),dmax
      integer i,incx,ix,n
c
      idamax = 0
      if( n.lt.1 .or. incx.le.0 ) return
      idamax = 1

      if(n.eq.1)return
      if(incx.eq.1)go to 20
c
c        code for increment not equal to 1
c
      ix = 1
      dmax = dabs(dx(1))
      ix = ix + incx
      do 10 i = 2,n
         if(dabs(dx(ix)).le.dmax) go to 5
         idamax = i

         dmax = dabs(dx(ix))
    5    ix = ix + incx
   10 continue
      return
c
c        code for increment equal to 1
c
   20 dmax = dabs(dx(1))
      do 30 i = 2,n
         if(dabs(dx(i)).le.dmax) go to 30
         idamax = i
         dmax = dabs(dx(i))
   30 continue
      return
      end

 
C-----------------------------------------------------------------------
 
      subroutine  dswap (n,dx,incx,dy,incy)
c
c     interchanges two vectors.
c     uses unrolled loops for increments equal one.
c     jack dongarra, linpack, 3/11/78.
c     modified 12/3/93, array(1) declarations changed to array(*)
c
      double precision dx(*),dy(*),dtemp
      integer i,incx,incy,ix,iy,m,mp1,n
c
      if(n.le.0)return
      if(incx.eq.1.and.incy.eq.1)go to 20
c

c       code for unequal increments or equal increments not equal
c         to 1
c
      ix = 1
      iy = 1
      if(incx.lt.0)ix = (-n+1)*incx + 1
      if(incy.lt.0)iy = (-n+1)*incy + 1

      do 10 i = 1,n
        dtemp = dx(ix)
        dx(ix) = dy(iy)
        dy(iy) = dtemp
        ix = ix + incx
        iy = iy + incy
   10 continue
      return
c

c       code for both increments equal to 1

c
c
c       clean-up loop
c
   20 m = mod(n,3)
      if( m .eq. 0 ) go to 40
      do 30 i = 1,m
        dtemp = dx(i)
        dx(i) = dy(i)
        dy(i) = dtemp
   30 continue
      if( n .lt. 3 ) return
   40 mp1 = m + 1
      do 50 i = mp1,n,3
        dtemp = dx(i)
        dx(i) = dy(i)
        dy(i) = dtemp
        dtemp = dx(i + 1)
        dx(i + 1) = dy(i + 1)
        dy(i + 1) = dtemp
        dtemp = dx(i + 2)
        dx(i + 2) = dy(i + 2)
        dy(i + 2) = dtemp
   50 continue

      return
      end
      double precision function dasum(n,dx,incx)
c
c     takes the sum of the absolute values.
c     jack dongarra, linpack, 3/11/78.
c     modified 3/93 to return if incx .le. 0.

c     modified 12/3/93, array(1) declarations changed to array(*)
c
      double precision dx(*),dtemp
      integer i,incx,m,mp1,n,nincx
c

      dasum = 0.0d0
      dtemp = 0.0d0
      if( n.le.0 .or. incx.le.0 )return
      if(incx.eq.1)go to 20
c
c        code for increment not equal to 1
c
      nincx = n*incx
      do 10 i = 1,nincx,incx
        dtemp = dtemp + dabs(dx(i))
   10 continue
      dasum = dtemp
      return
c
c        code for increment equal to 1
c
c
c        clean-up loop
c
   20 m = mod(n,6)
      if( m .eq. 0 ) go to 40
      do 30 i = 1,m
        dtemp = dtemp + dabs(dx(i))
   30 continue
      if( n .lt. 6 ) go to 60

   40 mp1 = m + 1
      do 50 i = mp1,n,6
        dtemp = dtemp + dabs(dx(i)) + dabs(dx(i + 1)) + dabs(dx(i + 2))
     *  + dabs(dx(i + 3)) + dabs(dx(i + 4)) + dabs(dx(i + 5))
   50 continue
   60 dasum = dtemp
      return
      end
      DOUBLE PRECISION FUNCTION DNRM2 ( N, X, INCX )
*     .. Scalar Arguments ..
      INTEGER                           INCX, N

*     .. Array Arguments ..

      DOUBLE PRECISION                  X( * )
*     ..
*
*  DNRM2 returns the euclidean norm of a vector via the function
*  name, so that
*
*     DNRM2 := sqrt( x'*x )
*
*
*

*  -- This version written on 25-October-1982.
*     Modified on 14-October-1993 to inline the call to DLASSQ.
*     Sven Hammarling, Nag Ltd.
*
*
*     .. Parameters ..

      DOUBLE PRECISION      ONE         , ZERO
      PARAMETER           ( ONE = 1.0D+0, ZERO = 0.0D+0 )
*     .. Local Scalars ..
      INTEGER               IX
      DOUBLE PRECISION      ABSXI, NORM, SCALE, SSQ
*     .. Intrinsic Functions ..
      INTRINSIC             ABS, SQRT
*     ..

*     .. Executable Statements ..

      IF( N.LT.1 .OR. INCX.LT.1 )THEN
         NORM  = ZERO

      ELSE IF( N.EQ.1 )THEN
         NORM  = ABS( X( 1 ) )
      ELSE
         SCALE = ZERO
         SSQ   = ONE
*        The following loop is equivalent to this call to the LAPACK
*        auxiliary routine:
*        CALL DLASSQ( N, X, INCX, SCALE, SSQ )
*
         DO 10, IX = 1, 1 + ( N - 1 )*INCX, INCX
            IF( X( IX ).NE.ZERO )THEN
               ABSXI = ABS( X( IX ) )
               IF( SCALE.LT.ABSXI )THEN
                  SSQ   = ONE   + SSQ*( SCALE/ABSXI )**2

                  SCALE = ABSXI
               ELSE
                  SSQ   = SSQ   +     ( ABSXI/SCALE )**2
               END IF
            END IF
   10    CONTINUE

         NORM  = SCALE * SQRT( SSQ )
      END IF
*
      DNRM2 = NORM
      RETURN
*
*     End of DNRM2.
*

      END

C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
	SUBROUTINE GETNUMEQ(NUMEQT)

	IMPLICIT REAL*8(A-H,O-Z)
	DIMENSION XX(14)
	CHARACTER READLINE*78,ERRFIL*20
      COMMON/ERROR/ERRFIL
C  COMMON/ERROR/ IS SUPPLIED TO ALL THE ROUTINES WHICH COULD WRITE TO
C  ERRFIL.

C  THIS SUBROUTINE READS THE PATIENT DATA FILE (FILE 21) TO FIND THE 
C  NO. OF OUTPUT EQUATIONS (NUMEQT).

C  PRINT MESSAGE TO THE USER THAT IF HE CHANGES HIS WORKING COPY 
C  FILE IN SUBROUTINE VERIF1, HE MUST MAKE SURE THAT THE NEW WORKING
C  COPY FILE HAS THE SAME NO. OF OUTPUT EQUATIONS AS THE FILE.

	WRITE(*,4)
    4   FORMAT(//' YOUR WORKING COPY FILE WILL NOW BE OPENED TO'/
     1' READ THE NUMBER OF OUTPUT EQUATIONS. LATER, YOU WILL HAVE THE '/
     2' OPTION TO CHANGE YOUR WORKING COPY FILE. IF YOU DO THIS, MAKE '/
     3' SURE THAT THE NEW FILE HAS THE SAME NUMBER OF OUTPUT '/
     4' EQUATIONS.'//)


	CALL PAUSE

C  VERIFY THAT PATHFIL2 IS A 'CURRENT' TYPE WORKING COPY FILE (I.E., 
C  CREATED BY CONVRTI.FOR OR LATER VERSION). IF NOT, IT DOESN'T HAVE THE
C  TEXT NEEDED BY THE LOGIC BELOW TO FIND NUMEQT.

   33   FORMAT(A78)
	READ(21,33) READLINE


	IF(READLINE(1:16) .NE. '  LAST AND FIRST') THEN

	 WRITE(*,37)
   37   FORMAT(/' RESTRICTION: THIS PROGRAM CAN ONLY READ WORKING COPY'/
     1'              FILES WHICH HAVE BEEN CREATED BY A RECENT VERSION'/
     2'              (1998 OR NEWER) OF THIS PROGRAM. THESE WORKING '/
     3'              COPY FILES MUST HAVE NAME, AGE, SEX, ETC. INFO '/
     4'              AT THE TOP.'//
     7' 	     YOU ARE TRYING TO USE A WORKING COPY PATIENT DATA'/

     1' 	     FILE WHICH WAS MADE BY AN OLDER VERSION OF THIS'/
     2'		     PROGRAM.'//
     3'		     PLEASE RERUN THE PROGRAM WITH AN APPROPRIATE '/
     4'              PATIENT DATA FILE.'/)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,37)
        CLOSE(42)

       CALL PAUSE
	 STOP

	ENDIF

    3   FORMAT(T2,I5)

C  READ THE NO. OF OUTPUT EQUATIONS FROM THE LINE WITH 'NO. OF TOTAL'
C  AS ENTRIES 12:23.


   50	READ(21,33) READLINE
      IF(READLINE(12:23) .NE. 'NO. OF TOTAL') GO TO 50
      BACKSPACE(21)
      READ(21,3) NUMEQT

	RETURN
	END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
        SUBROUTINE GETDIST(IDIST,NGAUS,NVAR,COF,AMEAN,COV,PATH,NOB,
     1   OUTNPAG,TEXTFILE,OSname,ListDir)

        IMPLICIT REAL*8(A-H,O-Z)


        DIMENSION AMEAN(150,30),COF(150),COV(150,30,30),CORR(30,30),
     1   STD(30),XVERIFY(900)



        CHARACTER OUTNPAG*20,PATH*61,OSname*20,ListDir*10,TEXTFILE*20

C  THIS ROUTINE READS IN THE DESIRED DISTRIBUTION FROM THE USER, AND
C  RETURNS THE INFO TO MAIN.

      WRITE(*,1)
    1 FORMAT(/' THIS PROGRAM GENERATES SUBJECT VECTORS FROM A'/
     1' SET OF DISTRIBUTIONS WHICH WILL BE INPUT VIA THE KEYBOARD'/
     2' OR FROM THE OUTPUT OF A PREVIOUS NPAG RUN. ')


 2070   WRITE(*,1071)
 1071   FORMAT(/' ENTER 1 IF THE MIXTURE INDICATED ABOVE WILL BE INPUT'/
     1'         VIA THE KEYBOARD; '/
     2' ENTER 2 IF THE MIXTURE WILL COME FROM THE RESULTS OF A BIG'/
     3'         NPAG RUN: ')
        READ(*,*,ERR= 2070) KEYNPAG
        IF(KEYNPAG .NE. 1 .AND. KEYNPAG .NE. 2) GO TO 2070

        IF(KEYNPAG .EQ. 1) THEN

 1030   WRITE(*,1032)
 1032   FORMAT(/' FOR THE MIXTURE INDICATED ABOVE, ENTER THE NUMBER '/
     1' OF DISTRIBUTIONS DESIRED (BETWEEN 1 AND 30): ')
        READ(*,*,ERR=1030) NGAUS
        IF(NGAUS .LT. 1 .OR. NGAUS .GT. 30) GO TO 1030

 4320	WRITE(*,4321)
 4321   FORMAT(/' ENTER 1 TO ENTER INFO IN TERMS OF CORRELATIONS; '/
     1' ENTER 0 TO ENTER INFO IN TERMS OF COVARIANCES: ')
	READ(*,*,ERR=4320) ICORR
	IF(ICORR .NE. 1 .AND. ICORR .NE. 0) GO TO 4320


 1045   WRITE(*,1046) 
 1046   FORMAT(/' FOR EACH COMPONENT OF THE MIXTURE, ENTER THE '/
     1' REQUESTED INFORMATION AS PROMPTED ...')



      DO 1100 IGAUS=1,NGAUS


      WRITE(*,1051) IGAUS
 1051 FORMAT(//' FOR MIXTURE COMPONENT NO. ',I3,': ')
      WRITE(*,1052)
 1052 FORMAT(/' ENTER THE WEIGHT: ')
 1055 READ(*,*,ERR=1060) COF(IGAUS)
      IF(COF(IGAUS) .GT. 0.) GO TO 1065
 1060 WRITE(*,1061)
 1061 FORMAT(/' SEE ABOVE; ENTER A POSITIVE REAL NO.: ')
      GO TO 1055


 1065 CONTINUE

	IF(ICORR .EQ. 0) THEN
	
      WRITE(*,1066) 
 1066 FORMAT(/,' ENTER THE PARAMETER MEAN VECTOR: ')
 1070 READ(*,*,ERR=1075) (AMEAN(IGAUS,I),I=1,NVAR)
      GO TO 2080
 1075 WRITE(*,1076) NVAR
 1076 FORMAT(/' SEE ABOVE; ENTER ',I2,' REAL NUMBERS: ')
      GO TO 1070


 2080 WRITE(*,2081)
 2081 FORMAT(/' ENTER 1 TO SELECT A DIAGONAL COV. MATRIX WITH EACH'/
     1' 	STD. DEV. EXACTLY 25% OF THE CORRESPONDING MEAN. THIS'/
     2'		WILL ENSURE THAT NO PARAMETER VALUES ARE NEGATIVE.'/
     3' ENTER 0 TO ENTER A DIFFERENT COV. MATRIX (IN THIS CASE, YOU'/
     4'		WILL HAVE THE RESPONSIBILITY TO MAKE SURE THAT THE'/
     5'		COV. MATRIX IS CHOSEN PROPERLY SO THAT NO PARAMETER'/
     6'		VALUES ARE NEGATIVE: ')
	READ(*,*,ERR=2080) ICMAT
	IF(ICMAT .NE. 0 .AND. ICMAT .NE. 1) GO TO 2080



C  FIRST ZERO OUT THE COV. MATRIX

	 DO I = 1,NVAR
	  DO J = 1,NVAR
	   COV(IGAUS,I,J) = 0.D0
	  END DO
	 END DO	   


	IF(ICMAT .EQ. 1) THEN


	 DO I = 1,NVAR
	  COV(IGAUS,I,I) = (.25D0*AMEAN(IGAUS,I))**2.D0
	 END DO
	ENDIF

	IF(ICMAT .EQ. 0) THEN
 	 WRITE(*,1081)
 1081    FORMAT(/,' ENTER, ROW x ROW, LOWER-TRI PART OF THE COV MATRIX')
         DO 1095 I=1,NVAR

          WRITE(*,1086)I
 1085     READ(*,*,ERR=1090) (COV(IGAUS,I,J),J=1,I)
          GO TO 1095
 1090     WRITE(*,1076) I
          GO TO 1085
 1095    CONTINUE
 1086    FORMAT(' ',' ROW ',I3,' : ')
	ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(ICMAT .EQ. 0)  CONDITION.

	ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(ICORR .EQ. 0)  CONDITION.


	IF(ICORR .EQ. 1) THEN
	
 3065 WRITE(*,3066) 
 3066 FORMAT(/,' ENTER EACH PARAMETER MEAN AND STD. DEV. AS PROMPTED: ')

	DO I = 1,NVAR
 3070	 WRITE(*,3067) I
 3067    FORMAT(/' MEAN AND STD. DEV. FOR PARAMETER NO. ',I3,': ')
	 READ(*,*,ERR=3070) AMEAN(IGAUS,I),STD(I)
	END DO

 3080 WRITE(*,3081)
 3081 FORMAT(/,' ENTER, ROW x ROW, THE LOWER-TRI PART OF THE CORR '/
     1' MATRIX. RECALL THAT EACH DIAGONAL VALUE MUST BE 1.0 ')

      DO I=1,NVAR
 3090  WRITE(*,3086) I
 3085  READ(*,*,ERR=3090) (CORR(I,J),J=1,I)
      END DO

 3086 FORMAT(' ',' ROW ',I3,': ')


C  ESTABLISH THE COVARIANCE MATRIX FOR THIS COMPONENT, IGAUS.


	 DO I = 1,NVAR
	  DO J = 1,I
	   COV(IGAUS,I,J) = CORR(I,J)*STD(I)*STD(J)
	  END DO
	 END DO

	ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(ICORR .EQ. 1) THEN  CONDITION.


 1100 CONTINUE	

C  ENSURE THAT SUM(COF(I))=1.0.

      SUMCOF=0.D0
      DO 1110 IGAUS=1,NGAUS
 1110 SUMCOF=SUMCOF+COF(IGAUS)
      DO 1115 IGAUS=1,NGAUS
 1115 COF(IGAUS)=COF(IGAUS)/SUMCOF

C  REPLACE WRITING OF COF() WITH XVERIFY (SEE LOGIC IN 
C  SUBROUTINE VERIFYVAL).

        DO I = 1,NGAUS
         XVERIFY(I) = COF(I)
        END DO
        CALL VERIFYVAL(NGAUS,XVERIFY)      
C       WRITE(*,1116) (COF(I),I=1,NGAUS)
        WRITE(*,1116) (XVERIFY(IXV),IXV=1,NGAUS)
 1116 FORMAT(/' THE NORMALIZED COEFFICIENTS ARE: ',150F8.4)



        ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(KEYNPAG .EQ. 1)  CONDITION.


      IF(KEYNPAG .EQ. 2) THEN

 3010    WRITE(*,2)
    2    FORMAT(/' ENTER 1 IF EACH OF THE ACTIVE GRID PTS. WILL BE'/
     4'         A DISTRIBUTION WITH THE COORDINATES OF EACH GRID PT.'/
     5'         BEING THE MEAN OF THE DISTRIBUTION, AND THE PROB. OF'/
     6'         THE GRID PT. BEING THE WEIGHT. ALSO, THE COV. OF EACH'/
     7'         DIST. WILL BE THE FINAL CYCLE COV. MATRIX, DIVIDED BY'/
     8'         THE NO. OF ACTIVE PTS.); '/
     9' ENTER 2 IF EACH OF THE ACTIVE GRID PTS. WILL BE USED ONCE EACH'/
     1'         AS THE PARAMETER SET FOR A SIMULATED SUBJECT: ')
       READ(*,*,ERR=3010) KKEY
       IF(KKEY .NE. 1 .AND. KKEY .NE. 2) GO TO 3010       

        CALL READNPAG(NGAUS,KKEY,NVAR,COF,AMEAN,COV,PATH,NOB,OUTNPAG,
     1   TEXTFILE,OSname,ListDir)


      ENDIF
C  ABOVE ENDIF IS FOR THE  IF(KEYNPAG .EQ. 2) CONDITION.

       IF(KKEY .EQ. 2) KEYNPAG = 3

        IF(KEYNPAG .EQ. 3) IDIST = 0

        IF(KEYNPAG .EQ. 1 .OR. KEYNPAG .EQ. 2) THEN
        
 2040   WRITE(*,2031)
 2031   FORMAT(/' THIS PROGRAM GENERATES SUBJECT VECTORS FROM A'/
     1' DISTRIBUTION WHICH IS A MIXTURE OF GAUSSIAN DISTRIBUTIONS '/
     2' OR LOGNORMAL DISTRIBUTIONS. '/
     3' ENTER 1 FOR GAUSSIAN DISTRIBUTIONS;'/
     4' ENTER 2 FOR LOGNORMAL DISTRIBUTIONS: ')
	READ(*,*,ERR=2040) IDIST
	IF(IDIST .NE. 1 .AND. IDIST .NE. 2) GO TO 2040

      ENDIF





        RETURN

        END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
        SUBROUTINE STAT2(NSUB,M,NOS,YPREDSUB,YMEAN,YMIN,YMAX,YSD,Y025,
     1   Y25,Y50,Y75,Y975)

        IMPLICIT REAL*8(A-H,O-Z)

	PARAMETER(MAXNUMEQ=7)

        DIMENSION YPREDSUB(10000,594,MAXNUMEQ),YMEAN(594,MAXNUMEQ),
     1   YMIN(594,MAXNUMEQ),YMAX(594,MAXNUMEQ),YSD(594,MAXNUMEQ),
     2   Y025(594,MAXNUMEQ),Y25(594,MAXNUMEQ),Y50(594,MAXNUMEQ),
     3   Y75(594,MAXNUMEQ),Y975(594,MAXNUMEQ),X(10000)

C  THIS SUBROUTINE, CALLED BY SIMBIG, INPUTS NSUB (NO. OF SUBJECTS),
C  M (NO. OF OBSERVATIONS PER OUTPUT EQ.), NOS (NO. OF OUTPUT 
C  EQUATIONS), AND YPREDSUB (THE OUPUT CONCENTRATIONS WHICH IS
C  NSUB x M x NOS).

C  IT OUTPUTS:

C  FOR EACH OUTPUT EQUATION AND OBSERVATION TIME:
C  MEAN CONC.    OVER ALL THE SUBJECTS YMEAN(IM,IN), IN=1,NOS; IM=1,M.

C  MIN CONC.     OVER ALL THE SUBJECTS  YMIN(IM,IN), IN=1,NOS; IM=1,M.

C  MAX CONC.     OVER ALL THE SUBJECTS  YMAX(IM,IN), IN=1,NOS; IM=1,M.
C  S.D. CONC.    OVER ALL THE SUBJECTS   YSD(IM,IN), IN=1,NOS; IM=1,M.
C  2.5TH %-TILE CONC. OVER ALL SUBJECTS  Y025(IM,IN), IN=1,NOS; IM=1,N.
C   25TH %-TILE CONC. OVER ALL SUBJECTS   Y25(IM,IN), IN=1,NOS; IM=1,N.
C   50TH %-TILE CONC. OVER ALL SUBJECTS   Y50(IM,IN), IN=1,NOS; IM=1,N.
C   75TH %-TILE CONC. OVER ALL SUBJECTS   Y75(IM,IN), IN=1,NOS; IM=1,N.
C 97.5TH %-TILE CONC. OVER ALL SUBJECTS  Y975(IM,IN), IN=1,NOS; IM=1,N.


C  IF NSUB = 1, THERE IS NOTHING FOR THIS ROUTINE TO DO SINCE THE
C  MEAN, MED, MIN, MAX, AND ALL %-TILES ARE THE SINGLE VALUE. RETURN
C  IN THIS CASE.

	  IF(NSUB .EQ. 1) THEN
	   WRITE(23,101)
  101      FORMAT(/' SINCE NSUB = 1, SUBROUTINE STAT2 WILL CALCULATE'/
     1' NOTHING.')
	   RETURN
	  ENDIF


C  FOR EACH OUTPUT EQUATION AND EACH OBSERVATION TIME, CALCULATE THE
C  ABOVE VALUES:

	DO IM = 1,M
	 DO IN = 1,NOS


C  FIRST STORE THE NSUB VALUES INTO VECTOR X.

	  DO ISUB = 1,NSUB
	   X(ISUB) = YPREDSUB(ISUB,IM,IN)
	  END DO

C  CALCULATE THE MEAN AND STD. DEV. 

	  SUM = 0.D0
	  SUMSQ = 0.D0
	   DO ISUB = 1,NSUB

	    SUM = SUM + X(ISUB)
	    SUMSQ = SUMSQ + X(ISUB)*X(ISUB)
	   END DO
	  YMEAN(IM,IN) = SUM/NSUB
	  XBAR = YMEAN(IM,IN)

C  AS OF MONTBIG7.FOR, CHECK TO MAKE SURE THE ARGUMENT TO THE SQ. ROOT
C  BELOW IS NON-NEGATIVE. IF IT IS (WHICH COULD HAPPEN DUE TO 
C  NUMERICAL ROUNDOFF), SET IT = 0, WHICH IT SHOULD BE IN SUCH CASES.

	  ARG = (SUMSQ - NSUB*XBAR*XBAR)/(NSUB - 1.D0)
	  IF(ARG .LT. 0.D0) ARG = 0.D0
 
	  YSD(IM,IN) = DSQRT(ARG)


C  CALL SUBROUTINE PERCENT TO CALCULATE THE 2.5, 25, 50 (MEDIAN), 75,
C  AND 97.5 %-TILES OF THE NSUB VALUES IN X, ALONG WITH THE MINIMUM
C  AND MAXIMUM. AND THEN STORE THESE VALUES.

	  CALL PERCENT(NSUB,X,XMIN,XMAX,X025,X25,X50,X75,X975)

	   YMIN(IM,IN) = XMIN
	   YMAX(IM,IN) = XMAX
	   Y025(IM,IN) = X025
	    Y25(IM,IN) = X25
	    Y50(IM,IN) = X50 

 	    Y75(IM,IN) = X75 
	   Y975(IM,IN) = X975
	

	 END DO
	END DO




C  THE ABOVE END DO'S ARE FOR THE DO IN = 1,NOS AND DO IM= 1,M LOOPS.


      RETURN
      END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
	SUBROUTINE PERCENT(NSUB,X,XMIN,XMAX,X025,X25,X50,X75,X975)
        IMPLICIT REAL*8(A-H,O-Z)
        DIMENSION X(10000),XI(10001),CUMPROP(0:10000),NUM(10000)

C  THIS SUBROUTINE, CALLED BY STAT2, CALCULATES THE MIN, MAX, AND 
C  INDICATED PERCENTILES OF THE VALUES IN VECTOR X.


	XMAX = -1.D30
	XMIN =  1.D30
	DO ISUB = 1,NSUB
	 IF(X(ISUB) .GT. XMAX) XMAX = X(ISUB)
	 IF(X(ISUB) .LT. XMIN) XMIN = X(ISUB)	
	END DO

C  TO FIND THE %-TILES OF THE SAMPLE OF VALUES IN X, A RELATIVELY
C  EASY WAY, WHICH HANDLES THE POSSIBILITY OF TIES, IS TO ESTABLISH
C  10000 INTERVALS BETWEEN XMIN AND XMAX, AND RECORD HOW MANY VALUES
C  ARE IN EACH INTERVAL. THEN EACH %-TILE WILL BE IN THE INTERVAL 
C  WHERE THE CUMULATIVE PERCENTAGE TO THAT INTERVAL REACHES THE
C  CORRESPONDING PERCENT.

C  FIND THE 10000 INTERVALS -- EQUALLY SPACED -- BETWEEN XMIN AND XMAX.

	XINT=(XMAX - XMIN)/10000.D0
	XI(1) = XMIN
	XI(10001) = XMAX
	DO I = 1, 9999
         XI(I+1) = XI(I) + XINT
	END DO


C  FIND NUM(INTR) = NO. OF X's IN INTERVAL INTR; INTR = 1,10000.

 
	DO INTR = 1,10000
	 N = 0
	  DO ISUB = 1,NSUB
	   XX = X(ISUB)
	   IF(XX .GE. XI(INTR) .AND. XX .LT. XI(INTR+1)) N = N + 1
	   IF(INTR .EQ. 10000 .AND. XX .GE. XI(INTR+1)) N = N + 1 
	  END DO
	 NUM(INTR) = N
	END DO


C  FIND THE 5 %-TILE VALUES. 

C  X025 IS THE X-VALUE BELOW WHICH IS 2.5 % OF THE DISTRIBUTION.
C  X25  IS THE X-VALUE BELOW WHICH IS 25 % OF THE DISTRIBUTION.
C  X50  IS THE X-VALUE BELOW WHICH IS 50 % OF THE DISTRIBUTION.
C  X75  IS THE X-VALUE BELOW WHICH IS 75 % OF THE DISTRIBUTION.
C  X975 IS THE X-VALUE BELOW WHICH IS 97.5 % OF THE DISTRIBUTION.


C  ACTUALLY, X025 WILL BE THE WEIGHTED VALUE IN THE INTERVAL WHERE 
C  THE CUMULATIVE NO. X's EXCEEDS 2.5%. SIMILARLY FOR THE OTHER
C  %-TILE VALUES. 



C  FIND THE INTERVALS WHERE THE CUMULATIVE NO. OF X's EXCEED 2.5%, 
C  25%, 50%, 75%, AND 97.5%.

C  CUMPROP(I) BELOW IS THE CUMULATIVE PROPORTION OF X's THROUGH 
C  INTERVAL I.

	CUMPROP(0)=0.D0

	DO INTR = 1,10000
	 
	 CUMPROP(INTR) = CUMPROP(INTR-1) + 1.D0*NUM(INTR)/NSUB

	 IF(CUMPROP(INTR-1) .LT. .025D0 .AND. CUMPROP(INTR) .GE. .025D0) 
     1    IND025=INTR
	 IF(CUMPROP(INTR-1) .LT. .25D0 .AND. CUMPROP(INTR) .GE. .25D0) 
     1    IND25=INTR

	 IF(CUMPROP(INTR-1) .LT. .50D0 .AND. CUMPROP(INTR) .GE. .50D0) 
     1    IND50=INTR
	 IF(CUMPROP(INTR-1) .LT. .75D0 .AND. CUMPROP(INTR) .GE. .75D0) 
     1    IND75=INTR
	 IF(CUMPROP(INTR-1) .LT. .975D0 .AND. CUMPROP(INTR) .GE. .975D0) 
     1    IND975=INTR

	END DO


C  NOW IND025 IS THE INTERVAL WHERE THE CUMULATIVE PROPORTION OF X's
C  EXCEEDS .025 (SIMILARLY FOR THE OTHER IND'S).

	X025 = XI(IND025) + (XI(IND025+1)-XI(IND025))*
     1  (.025D0-CUMPROP(IND025-1))/(CUMPROP(IND025)-CUMPROP(IND025-1))

	X25 = XI(IND25)+(XI(IND25+1)-XI(IND25))*

     1  (.25D0-CUMPROP(IND25-1))/(CUMPROP(IND25)-CUMPROP(IND25-1))

	X50 = XI(IND50)+(XI(IND50+1)-XI(IND50))*

     1  (.50D0-CUMPROP(IND50-1))/(CUMPROP(IND50)-CUMPROP(IND50-1))

	X75 = XI(IND75)+(XI(IND75+1)-XI(IND75))*
     1  (.75D0-CUMPROP(IND75-1))/(CUMPROP(IND75)-CUMPROP(IND75-1))

	X975 = XI(IND975)+(XI(IND975+1)-XI(IND975))*
     1  (.975D0-CUMPROP(IND975-1))/(CUMPROP(IND975)-CUMPROP(IND975-1))


	RETURN
	END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
	SUBROUTINE EXPLAINOISE

C  THIS ROUTINE SIMPLY WRITES TO THE SCREEN THE EXPLANATION FOR HOW
C  THE NOISY DOSETIMES, DOSE AMOUNTS, AND OBSERVATION TIMES ARE
C  OBTAINED.

   20	WRITE(*,1)
    1   FORMAT(/' THE DOSE TIMES, DOSE AMOUNTS, AND OBSERVATION '/
     1' TIMES ARE MADE "NOISY" USING THE COEFFICIENTS YOU ENTER FOR'/
     2' EACH SET.'//
     3' ENTER 1 FOR NO MORE DETAIL;'/
     4' ENTER 2 FOR AN EXPLANATION OF THE "NOISY" DOSE TIMES AND'/
     4'         "NOISY" OBS. TIMES;'/
     4' ENTER 3 FOR AN EXPLANATION OF THE "NOISY" DOSE AMOUNTS: ')
	READ(*,*,ERR=20) IEXP
	IF(IEXP .NE. 1 .AND. IEXP .NE. 2 .AND. IEXP .NE. 3) GO TO 20

	IF(IEXP .EQ. 1) RETURN
	IF(IEXP .EQ. 2) WRITE(*,12)
	IF(IEXP .EQ. 3) WRITE(*,13)
	GO TO 20

   12   FORMAT(/' EACH DOSE TIME IS MADE "NOISY" AS FOLLOWS:'/
     1' THE FIRST DOSE TIME, WITH A TRUE VALUE OF VTRUE, WILL BE '/
     2' CHANGED TO BE VNOISY, WHERE VNOISY = VTRUE + Ei, WHERE'/
     3' Ei ~ N(0,STDI**2), WHERE '/
     4' STDI = C0 + C1*VTRUE + C2*VTRUE**2 + C3*VTRUE**3'//
     5' FOR SUBSEQUENT DOSE TIMES, THE NOISY DOSE TIME IS '/
     6' DETERMINED AS FOLLOWS:'/
     7' a. SET DUR = NOMINAL DURATION BETWEEN THE PREVIOUS DOSE TIME '/
     8'    AND THE CURRENT DOSE TIME.'/
     3' b. CALC. THE NOISY DURATION, DURNOISY, AS '/
     4'    DURNOISY = DUR + Ei, Ei ~ N(0,STDI**2), WHERE '/
     7'    STDI = C0 + C1*DUR + C2*DUR**2 + C3*DUR**3'/
     8' c. ... BUT LIMIT DURNOISY TO BE .GE. .5*DUR AND .LE. 2*DUR.'/
     9' d. SET THE CURRENT NOISY DOSE TIME = PREVIOUS NOISY DOSE TIME'/
     1'    + DURNOISY.'//
     2' THE SAME LOGIC APPLIES FOR OBS. TIMES. '//
     3' NOTE THIS LOGIC --> TIMES CANNOT BE OUT OF ORDER.')

   13   FORMAT(/' EACH IV RATE AND EACH BOLUS VALUE WHICH = 0 WILL NOT'/
     1' BE MADE NOISY. I.E., IT IS ASSUMED THAT IF A RATE OR BOLUS IS'/
     2' INTENDED TO BE 0, IT WILL BE ACHIEVED WITHOUT ERROR.'
     2/
     3' A NON-ZERO IV OR BOLUS VALUE, WITH A TRUE VALUE OF VTRUE, '/
     4' WILL BE CHANGED TO BE VNOISY, WHERE VNOISY = VTRUE + Ei, WHERE'/
     6' Ei ~ N(0,STDI**2), WHERE '/
     7' STDI = C0 + C1*VTRUE + C2*VTRUE**2 + C3*VTRUE**3')


	END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
        SUBROUTINE READNPAG(NGAUS,KKEY,NVAR,COF,AMEAN,COV,PATH,NOB,
     1   OUTNPAG,TEXTFILE,OSname,ListDir)


C  READNPAG IS CALLED BY GETDIST. IT INPUTS THE DISTRIBUTION 
C  MIXTURE (NGAUS, NVAR, COF, AMEAN, COV) FROM THE (COMBINED) OUTPUT 
C  FILE OF A BIG NPAG RUN ... OR, AS OF MONT108.FOR FROM A SIMPLE
C  TEXT FILE, OR VIA THE KEYBOARD.


C  IF KKEY = 1: EACH OF THE ACTIVE GRID PTS. WILL BE A DISTRIBUTION 
C  WITH THE COORDINATES OF EACH GRID PT. BEING THE MEAN OF THE
C  DISTRIBUTION,  AND THE PROB. OF THE GRID PT. BEING THE WEIGHT. ALSO,
C  THE COV. OF EACH DIST. WILL BE THE FINAL CYCLE COV. MATRIX, DIVIDED
C  BY THE NO. OF ACTIVE PTS.

C  IF KKEY = 2 (STARTING WITH MONT107.FOR), THE PROGRAM WILL USE THESE
C  NGAUS GRID PTS. ONCE EACH TO SIMULATE A SUBJECT. IN THIS CASE, THE 
C  COVARIANCE MATRIX IS IRRELEVANT.

        IMPLICIT REAL*8(A-H,O-Z)
        DIMENSION AMEAN(150,30),COF(150),COV(150,30,30),COVV(30,30),
     1   VALFIX(20),RANFIXEST(20)

        CHARACTER OUTNPAG*20,PATH*61,TMPFILE*32,PATHFILE*93,READLIN2*78,
     1   READLINE*1000,OSname*20,ListDir*10,TEXTFILE*20,ERRFIL*20



      COMMON/ERROR/ERRFIL
C  COMMON/ERROR/ IS SUPPLIED TO ALL THE ROUTINES WHICH COULD WRITE TO
C  ERRFIL.

    1   FORMAT(A20)

      IF(KKEY .EQ. 2) THEN
  
  180  WRITE(*,6321)
 6321  FORMAT(//' ENTER 1 TO INPUT THE ACTIVE GRID PTS. MANUALLY;'/
     1' ENTER 2 TO INPUT THE ACTIVE GRID PTS. FROM THE OUTPUT FILE'/
     2'         OF AN NPAG RUN;'/
     3' ENTER 3 TO INPUT THE ACTIVE GRID PTS. FROM A SIMPLE TEXT FILE: '
     4)
       READ(*,*,ERR=180) INHOW
       IF(INHOW .NE. 1 .AND. INHOW .NE. 2 .AND. INHOW .NE. 3) GO TO 180

       IF(INHOW .EQ. 2) GO TO 170


  280   WRITE(*,6322)
 6322   FORMAT(/' ENTER THE NO. OF ACTIVE GRID PTS. THIS NUMBER MUST'/
     1' BE .LE. 150: ')
        READ(*,*,ERR=280) NGAUS
        IF(NGAUS .LT. 1 .OR. NGAUS .GT. 150) GO TO 280


       IF(INHOW .EQ. 1) THEN

        WRITE(*,6323) NGAUS,NVAR
 6323   FORMAT(/' ENTER ',I4,' ROWS OF PARAMETER VALUES. EACH ROW MUST'/
     1' HAVE THE ',I3,' PARAMETER VALUES FOR THAT GRID PT. '//)
  
        DO IGAUS = 1,NGAUS
  220    WRITE(*,6324) NVAR,IGAUS
 6324    FORMAT(' ENTER ',I3,' PAR. VALUES FOR GRID PT. ',I4,': ')
         READ(*,*,ERR=220) (AMEAN(IGAUS,J),J=1,NVAR)
        END DO

C  GO TO LABEL 260 TO ESTABLISH COF(.) = 1, AND COV(.,.,.) = 0.

        GO TO 260

       ENDIF
C  THE ABOVE ENDIF IS FOR THE  IF(INHOW .EQ. 1)  CONDITION.
      

       IF(INHOW .EQ. 3) THEN

  230   WRITE(*,6326) NGAUS,NVAR 
 6326   FORMAT(/' ENTER THE NAME OF THE TEXT FILE WHICH HAS A MATRIX'/
     1' OF ',I4,' ROWS OF PARAMETER VALUES, EACH ROW HAVING THE ',I3/
     2' PARAMETER VALUES FOR A GRID PT.: ')

        WRITE(*,*)' ENTER -99 TO SEE ALL OR A PART OF YOUR DIRECTORY: ' 
        READ(*,1) TEXTFILE 
        IF(TEXTFILE(1:3) .EQ. '-99') CALL SEEDIR(PATH,NOB,TEXTFILE,
     1     OSName,ListDir)

C  CALL FULLNAME WHICH CONVERTS THE FILENAME TO PATHFILE, THE COMPLETE 
C  NAME OF THE FILE, WHICH INCLUDES THE PATH (IF THE PATH IS NOT THE 
C  CURRENT DIRECTORY).

     	  TMPFILE = ' '
        TMPFILE = TEXTFILE
        CALL FULLNAME(PATH,TMPFILE,PATHFILE)
        OPEN(45,FILE=PATHFILE,STATUS='OLD',ERR=250)
        GO TO 240
  250   WRITE(*,5316) PATHFILE

        GO TO 230

  240   DO IGAUS = 1,NGAUS
         READ(45,*) (AMEAN(IGAUS,J),J=1,NVAR)
        END DO

        CLOSE(45)

C  GO TO LABEL 260 TO ESTABLISH COF(.) = 1, AND COV(.,.,.) = 0.

        GO TO 260

       ENDIF
C  THE ABOVE ENDIF IS FOR THE  IF(INHOW .EQ. 3)  CONDITION.



      ENDIF
C  THE ABOVE ENDIF IS FOR THE  IF(KKEY .EQ. 2)  CONDITION.



  170   WRITE(*,5321) 
 5321   FORMAT(//' ENTER THE NAME OF A "COMBINED" OUTPUT FILE FROM A'/
     1' PREVIOUS RUN.'// 
     4' IT WILL BE OF THE FORM OUTxxxx, WHERE xxxx WAS THE JOB NUMBER'/
     5' ASSIGNED TO THE RUN.'//)
        WRITE(*,*)' ENTER -99 TO SEE ALL OR A PART OF YOUR DIRECTORY: ' 
        READ(*,1) OUTNPAG
        IF(OUTNPAG(1:3) .EQ. '-99') CALL SEEDIR(PATH,NOB,OUTNPAG,
     1     OSName,ListDir)

C  FOR SOME REASON, OUTNPAG IS NOT READ IN CORRECLY UNLESS THERE IS
C  A PAUSE AFTER IT IS READ.
        CALL PAUSE


C  CALL FULLNAME WHICH CONVERTS THE FILENAME TO PATHFILE, THE COMPLETE 
C  NAME OF THE FILE, WHICH INCLUDES THE PATH (IF THE PATH IS NOT THE 
C  CURRENT DIRECTORY).

     	TMPFILE = ' '
	TMPFILE = OUTNPAG
	CALL FULLNAME(PATH,TMPFILE,PATHFILE)
	OPEN(45,FILE=PATHFILE,STATUS='OLD',ERR=95)
	GO TO 210
   95   WRITE(*,5316) PATHFILE
 5316   FORMAT(//' THE FOLLOWING FILE DOES NOT EXIST ... '/
     1'    ',A73)
	GO TO 170


C  FIRST VERIFY THAT THE VERSION NO. FOR THIS OUPUT FILE IS AT LEAST
C  36, WHICH MEANS IT IS A COMBINED OUTPUT FILE.


  210   IVER=0


        READ(45,2) READLINE

        IF(READLINE(2:11) .EQ. 'VERSION 36') IVER=36
        IF(READLINE(2:11) .EQ. 'VERSION 37') IVER=37
        IF(READLINE(2:11) .EQ. 'VERSION 38') IVER=38
        IF(READLINE(2:11) .EQ. 'VERSION 39') IVER=39
        IF(READLINE(2:11) .EQ. 'VERSION 40') IVER=40
        IF(READLINE(2:11) .EQ. 'VERSION 41') IVER=41
        IF(READLINE(2:11) .EQ. 'VERSION 42') IVER=42
        IF(READLINE(2:11) .EQ. 'VERSION 43') IVER=43


        IF(IVER .EQ. 0) THEN
         WRITE(*,3013)
 3013    FORMAT(//' YOUR OUTPUT FILE IS NOT A "COMBINED" OUTPUT FILE'/
     1' AS REQUIRED BY THIS PROGRAM. SUCH A FILE WILL HAVE A VERSION '/
     2' NO. OF AT LEAST 36 ON THE FIRST LINE.')
         GO TO 170
        ENDIF


C  NEXT VERIFY THAT NVAR INPUT TO THIS ROUTINE MATCHES NVAR FROM THE 
C  OUTPUT FILE. THE NO. OF RANDOM VARIABLES WILL BE THE NO. OF TIMES
C  THE CHARACTER : IS READ IN IN COLUMN 13, JUST AFTER THE LINE
C  WHICH = " THE RANDOM VARIABLES AND THEIR RANGES ARE: "


   70   READ(45,2) READLINE
        IF(READLINE(1:21) .NE. ' THE RANDOM VARIABLES') GO TO 70
        READ(45,2) READLINE
        NVARR = 0
   80   READ(45,2) READLINE

        IF(READLINE(13:13) .EQ. ':') THEN
         NVARR = NVARR + 1
         GO TO 80
        ENDIF

        IF(READLINE(1:9) .EQ. ' THE USER') GO TO 100
        IF(READLINE(1:9) .EQ. ' NO FIXED') GO TO 100


        GO TO 80

  100   IF(NVARR .NE. NVAR) THEN
         WRITE(*,81) NVARR,NVAR,NVAR
   81    FORMAT(/' THE NO. OF RANDOM VARIABLES IN YOUR OUTPUT FILE'/
     1' IS ',I3,'. THIS IS DIFFERENT THAN THE NO. YOU ENTERED ABOVE,'/
     2' ... ',I3,'. PLEASE ENTER AN OUTPUT FILE WITH ',I3,' RANDOM'/
     3' VARIABLES.')
         GO TO 170
        ENDIF
       

C  PRINT TO THE SCREEN A SUMMARY OF THE INPUT INFO FOR THE RUN, SO
C  THE USER CAN VERIFY THAT THIS RUN IS THE ONE HE WANTS.

      WRITE(*,*)
      WRITE(*,*)
      WRITE(*,*)' THE FOLLOWING INFO SUMMARIZES THE INPUT INSTRUCTIONS'
      WRITE(*,*)' FOR THE RUN WHOSE OUTPUT FILE YOU JUST ENTERED: '
      WRITE(*,*)

        ILINES=3

C  ILINES IS THE RUNNING TOTAL OF LINES PRINTED TO THE SCREEN SINCE THE
C  LAST PAUSE. EVERYTIME IT GETS TO 20, PAUSE THE OUTPUT.

    2   FORMAT(A1000)
  202   FORMAT(A78)
  150	READ(45,202) READLIN2
	ILINES=ILINES+1
	WRITE(*,1102) READLIN2
 1102   FORMAT(' ',A78)

	IF(ILINES .EQ. 20) THEN
	  
	  ILINES=0	
	ENDIF

	IF(READLIN2(5:15) .NE. '***********') GO TO 150

  160	WRITE(*,12)
   12   FORMAT(//' ENTER 1 IF THE OUTPUT FILE DESCRIBED ABOVE IS THE'/
     1'         ONE FROM THE RUN FROM WHICH YOU WISH TO INPUT THE '/
     2'         DISTRIBUTION MIXTURE FOR THIS RUN;'/ 
     3' ENTER 0 IF YOU WISH TO ENTER ANOTHER OUTPUT FILE: ')
	READ(*,*,ERR=160) IANOT
	IF(IANOT .NE. 0 .AND. IANOT .NE. 1) GO TO 160

	IF(IANOT .EQ. 0) THEN 

	  CLOSE(45)
	  GO TO 170
	ENDIF

	
C  CLOSE AND REOPEN THE FILE AT THE END, AND THEN BACKSPACE UNTIL THE
C  FINAL CYCLE INFO CAN BE READ IN.

        CLOSE(45)
        OPEN(45,FILE=PATHFILE,POSITION='APPEND')

   30	  BACKSPACE(45)
	  BACKSPACE(45)

	  READ(45,2) READLINE
	  IF(READLINE(1:10) .NE. ' CYCLE NO.') GO TO 30
	
C  READ IN THE COV. MATRIX FOR THIS FINAL CYCLE ... UNLESS IT CAN'T
C  BE READ WHICH HAPPENS WHEN  A VARIANCE FOR A PARAMETER IS NUMERICALLY
C  .LE. 0. IN THAT CASE, TELL THE USER THAT EACH COV. MATRIX WILL BE 
C  DIAGONAL WITH EACH STD. DEV. EXACTLY 25% OF THE CORRESPONDING MEAN
C  ... IF KKEY = 1 (IF KKEY = 2, COVARIANCES ARE UNNEEDED).

   40   READ(45,2) READLINE
        IF(READLINE(1:15) .EQ. ' THE COV MATRIX') GO TO 50


        IF(READLINE(1:15) .EQ. ' THE VARIANCE F' .AND. KKEY .EQ. 1)
     1   GO TO 60

        IF(READLINE(1:15) .EQ. ' THE VARIANCE F' .AND. KKEY .EQ. 2)
     1   GO TO 90


        GO TO 40

   50   READ(45,2) READLINE

C  READ IN THE FINAL CYCLE COV. MATRIX. CALL IT COVV. BELOW, IT WILL BE
C  DIVIDED BY NACTVE TO GET COV.

        DO IVAR = 1,NVAR

         READ(45,*) (COVV(IVAR,J),J=1,IVAR)
        END DO

        ICOVMAT = 1

C  ICOVMAT = 1 --> COV(.,.,.) WILL BE SET = COVV(.,.)/NACTVE BELOW.

        GO TO 90


   60   WRITE(*,61)
   61 FORMAT(/' YOUR OUTPUT FILE HAS NO FINAL CYCLE COV. MATRIX'/
     1' SINCE AT LEAST ONE PARAMETER HAD A VARIANCE NUMERICALLY .LE. 0.'
     2//
     3' SO THE COV. MATRIX ASSOCIATED WITH EACH GRID PT. IN THE '/
     4' BIG NPAG RUN WILL DEFAULT TO A DIAGONAL COV. MATRIX WITH EACH'/
     5' STD. DEV. EXACTLY 25% OF THE CORRESPONDING MEAN. THIS WILL'/
     6' ENSURE THAT NO SIMULATED PARAMETER VALUES ARE NEGATIVE.'/)

      ICOVMAT = 0

C  ICOVMAT = 0 --> COV(.,.,.) WILL BE SET AS INDICATED IN FORMAT 61.


   90   CONTINUE

C  NOW READ THE DENSITY PART OF THE FILE TO OBTAIN NGAUS = THE NO. OF
C  ACTIVE GRID PTS. (NACTVE IN bigmlt6.f), COORDINATES OF THE GRID PTS.,
C  WHICH WILL BE THE MEANS OF NGAUS "DISTRIBUTIONS", AND THE 
C  PROBABILTIIES, WHICH WILL BE THE WEIGHTS OF THE "DISTRIBUTIONS".


  110   READ(45,2) READLINE

        IF(READLINE(19:34) .NE. 'START OF THE DEN') GO TO 110
        
        DO I = 1,4
         READ(45,2) READLINE
        END DO


        READ(45,*) NGAUS

C  THIS PROGRAM IS LIMITED TO NGAUS .LE. 150. IF NGAUS > 150, TELL
C  THE USER AND GIVE HIM THE OPTION OF STOPPING OR USING JUST THE
C  FIRST 150 GRID POINTS.

        IF(NGAUS .GT. 150) THEN

  120    WRITE(*,121) NGAUS
  121    FORMAT(/' YOUR OUTPUT FILE HAS A FINAL CYCLE WITH ',I5,/
     1' ACTIVE GRID POINTS. THIS IS MORE THAN THE ALLOWABLE VALUE OF '/
     2' 150. YOU HAVE THE OPTION OF STOPPING NOW, OR OF SIMPLY USING'/
     3' THE FIRST 150 GRID POINTS.'//

     4' ENTER 1 TO STOP;'/
     5' ENTER 2 TO CONTINUE, USING THE FIRST 150 GRID POINT: ')
         READ(*,*,ERR=120) ISTOP
         IF(ISTOP .NE. 1 .AND. ISTOP .NE. 2) GO TO 120
         IF(ISTOP .EQ. 1) STOP
         NGAUS = 150

        ENDIF


        READ(45,2) READLINE
        DO I = 1,NVAR
         READ(45,2) READLINE
        END DO

        READ(45,*) NOFIX
         DO I = 1,NOFIX
          READ(45,2) READLINE
         END DO

        IF(IVER .GE. 43) THEN
         READ(45,*) NRANFIX
         DO I = 1,NRANFIX
          READ(45,2) READLINE
         END DO
        ENDIF

        DO I = 1,NVAR
         READ(45,2) READLINE
        END DO
  
C  VALFIX(.) ARE NOT NEEDED, BUT MUST BE READ TO KEEP TRACK OF THE 
C  LOCATION OF READ STATEMENTS IN THE FILE.
  
        READ(45,*) (VALFIX(I),I=1,NOFIX)

C  RANFIXEST(.) ARE NOT NEEDED, BUT MUST BE READ TO KEEP TRACK OF THE 
C  LOCATION OF READ STATEMENTS IN THE FILE ... IF IVER .GE. 43.

        IF(IVER .GE. 43) READ(45,*) (RANFIXEST(I),I=1,NOFIX)

        READ(45,*) NINT

C  AS A MIDCOURSE CHECK, VERIFY THAT NINT = 100. IF NOT, STOP AND
C  TELL THE READER THAN SOMETHING IS AMISS.

        IF(NINT .NE. 100) THEN
         WRITE(*,111) NINT
  111    FORMAT(/' IN THE DENSITY PART OF THE FILE, NINT WAS READ'/
     1' AS ',I7,' BUT IT SHOULD HAVE BEEN 100. THE PROGRAM STOPS.'/
     2' PLEASE RECHECK YOUR OUTPUT FILE OR ASK LAPK TO ANALYZE YOUR'/
     3' FILE FOR YOU.'/)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,111) NINT
        CLOSE(42)

         CALL PAUSE
         STOP
        ENDIF  
       
        READ(45,2) READLINE
        READ(45,2) READLINE

C  AS THE WEIGHTS ARE BEING READ IN, IN THE DO LOOP BELOW, FIND THE SUM
C  SINCE THEY ARE NOT NORMALIZED TO SUM TO 1.0. NOTE THAT ABOVE IF NGAUS
C  WAS > 150, IT WAS RESET = 150 --> ONLY THE FIRST 150 SETS OF GRID
C  POINTS AND ASSOCIATED PROBABILITIES WILL BE READ IN IN THE LOOP 
C  BELOW. THIS IS OK SINCE THE WEIGHTS OF THE FIRST 150 GRID POINTS
C  WOULD THEN STILL BE NORMALIZED TO BE 1.0 IN THE 2ND LOOP BELOW. BUT 
C  IF ICOVMAT = 1 BELOW, AND IF NGAUS WAS LOWERED TO 150 ABOVE, THE 
C  COV(.,.,.) MATRIX WILL HAVE LARGER VALUES THAN IF NGAUS WAS NOT 
C  RESET. BUT SINCE THE "AD-HOC" PROCEDURE TO ESTABLISH THE COV(.,.,.)
C  MATRIX HAS NO REAL THEORETICAL BASIS, IT DOESN'T MATTER.

        SUMWEIGHT = 0.D0
        DO IGAUS = 1,NGAUS
         READ(45,*) (AMEAN(IGAUS,J),J=1,NVAR),COF(IGAUS)
         SUMWEIGHT = SUMWEIGHT + COF(IGAUS)
        END DO

        CLOSE(45)


C  ESTABLISH COV. AND COF. VALUES IF KKEY = 1.

      IF(KKEY .EQ. 1) THEN

C  NORMALIZE THE VALUES IN COF SO THAT THEY SUM TO 1.0.

        DO IGAUS = 1,NGAUS
         COF(IGAUS) = COF(IGAUS)/SUMWEIGHT
        END DO

C  ESTABLISH THE COVARIANCE MATRICES FOR THE NGAUS DISTRIBUTIONS
C  DEPENDING ON THE VALUE OF ICOVMAT. 

        IF(ICOVMAT .EQ. 1) THEN
          DO IGAUS = 1,NGAUS


           DO I = 1,NVAR
            DO J = 1,I
             COV(IGAUS,I,J) = COVV(I,J)/NGAUS
            END DO
          END DO
         END DO
        ENDIF


        IF(ICOVMAT .EQ. 0) THEN
          DO IGAUS = 1,NGAUS
           DO I = 1,NVAR
            DO J = 1,I
             COV(IGAUS,I,J) = 0.D0
             IF(I .EQ. J) COV(IGAUS,I,I) = AMEAN(IGAUS,I)*.0625D0
            END DO
          END DO
         END DO
        ENDIF

      ENDIF
C  ABOVE ENDIF IS FOR THE  IF(KKEY .EQ. 1)  CONDITION.


C  SET COV. AND COF. VALUES IF KKEY = 2.


  260 CONTINUE


      IF(KKEY .EQ. 2) THEN

C  RATHER THAN NORMALIZING THE VALUES IN COF SO THAT THEY SUM TO 1.0,
C  SET THEM ALL TO 1. IT DOESN'T MATTER SINCE THEY WON'T BE USED.


       DO IGAUS = 1,NGAUS
        COF(IGAUS) = 1.D0
       END DO


       DO IGAUS = 1,NGAUS
        DO I = 1,NVAR
         DO J = 1,I
          COV(IGAUS,I,J) = 0.D0
         END DO
        END DO
       END DO


      ENDIF
C  ABOVE ENDIF IS FOR THE  IF(KKEY .EQ. 2)  CONDITION.





        RETURN
        END

























C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C	
        SUBROUTINE READBLOCK2(PATH,C0,C1,C2,C3)
	  IMPLICIT REAL*8(A-H,O-Z)

	PARAMETER(MAXNUMEQ=7)

C  THIS ROUTINE IS BASED ON SUBROUTINE READBLOCK IN NPBG15E1.FOR, BUT
C  INSTEAD OF CREATING A WORKING COPY PATIENT DATA FILE FOR EACH BLOCK
C  OF DATA IN THE .CSV FILE ALREADY OPENED AS FILE 66 IN MAIN, IT ONLY
C  CREATES ONE MULTIPLE DRUG WORKING COPY PATIENT DATA FILE, 
C  XQZPJ001.ZMQ, FROM THE FIRST SUBJECT'S DATA. SO MAXSUB WILL BE 
C  HARDCODED = 1 BELOW, AND ALL DIMENSIONS WHICH WERE MAXSUB IN
C  NPBG15E1.FOR/READBLOCK WILL NOW BE 1.

        DIMENSION TIMOUT(1,MAXNUMEQ,650),TIMIV(1,7,5200),
     1   NTIMOUT(1,MAXNUMEQ),NTIMIV(1,7),RATEIV(1,7,5200),
     2   BOLUS(1,7,5200),OUT(1,MAXNUMEQ,650),COV(1,26,5200),
     3   ICOVTYPE(26),TIMBOL(1,7,5200),NTIMBOL(1,7),NTIMCOV(1,26),
     4   TIMCOV(1,26,5200),TIMALL(1,24000),NTIMALL(1),TIMI(24000),
     5   C0(MAXNUMEQ),C1(MAXNUMEQ),C2(MAXNUMEQ),C3(MAXNUMEQ),


     6   CSUB(1,4,MAXNUMEQ),NSST(1),DOSELINEST(1,99,100),XVERIFY(900)

        CHARACTER READLINE*1000,COVNAME(26)*11,NUMBER(1)*3,
     1   PATFIL*20,CHARSUB*3,SUBID*11,SUBIDPREV*11,SUBARRAY(1)*11,
     3   PATH*61,TMPFILE*32,PATHFILE*93,ERRFIL*20

      COMMON/ERROR/ERRFIL
C  COMMON/ERROR/ IS SUPPLIED TO ALL THE ROUTINES WHICH COULD WRITE TO
C  ERRFIL.

    1   FORMAT(A1000)


C  SET MAXSUB = 1 SINCE ONLY 1 SUBJECT WILL BE CREATED BY THIS ROUTINE.


        MAXSUB = 1



C  INITIALIZE NDRUG (THE NO. OF DRUGS IN THE PATIENT DATA SET) TO BE
C  0. EVERY TIME IDRUGNO IS READ BELOW, NDRUG WILL BE SET = 
C  MAX(NDRUG,IDRUGNO).


C  SIMILARLY, INITIALIZE NOUT (THE NO. OF OUTPUT EQUATIONS IN THE

C  PATIENT DATA SET) TO BE 0. EVERY TIME IOUTEQ IS READ BELOW, 
C  NOUT WILL BE SET = MAX(NOUT,IOUTEQ).

	NDRUG = 0
	NOUT = 0

C  INITIALIZE NSST(ISUB) TO 0. IT GIVES THE NO. OF STEADY STATE DOSE
C  LINES THAT WILL BE WRITTEN TO THE DOSAGE BLOCK FOR EACH SUBJECT. 

      DO ISUB = 1,MAXSUB
       NSST(ISUB) = 0
      END DO



C  NOTE THAT ANY LINE STARTING WITH A # WILL BE IGNORED. THE FIRST LINE
C  WILL ALSO BE IGNORED - IT HAS ALREADY BEEN VERIFIED TO HAVE THE
C  REQUIRED CODE IN IT.


	READ(66,*)

C  READ THE 2ND LINE, WHICH MUST HAVE A # AS THE FIRST CHARACTER. IT HAS
C  THE NAMES OF THE COLUMNS. COUNT THE NO. OF COMMAS ON THE LINE. THE 
C  NO. OF COVARIATES WILL BE THE NO. OF COMMAS - 11 (SINCE THERE ARE 12
C  FIXED ENTRIES WHICH POTENTIALLY SHOW UP ON EACH LINE: PATIENT ID, 

C  EVENT ID, TIME, INFUSION DURATION, TOTAL DOSE, INPUT DRUG NO.,
C  OUTPUT VALUE, OUTPUT EQ., AND 4 SPOTS FOR ASSAY COEFFICIENTS WHICH 
C  ONLY SHOW UP ON OUTPUT LINES). NOTE THAT THIS VALUE WILL BE CALLED
C  NCOVA, WHICH MEANS NO. OF ADDITION COVARIATES (IN ADDITION TO THE 4

C  PERMANENT ONES AT THE TOP OF EACH PATIENT'S WORKING COPY FILE (AGE,
C  SEX, HEIGHT, ETHNICITY FLAG), ... TO BE CONSISTENT WITH THE NAME 
C  USED IN NPAG100.FOR.

	  READ(66,1) READLINE


	NCOMMA = 0

	DO ISTART = 1,1000

	 IF(READLINE(ISTART:ISTART) .EQ. ',') THEN
	  NCOMMA = NCOMMA + 1
	 ENDIF

	END DO	    

	NCOVA = NCOMMA - 11


	IF(NCOVA .GT. 0) THEN

C  READ THE NAMES OF THE NCOVA COVARIATES FROM THE LINE STARTING WITH
C  #ID OR "#ID. 

C  NOTE THAT AFTERCOMMA OPENS AND PUTS INTO FILE 57 THE PART OF READLINE
C  WHICH IS BETWEEN COMMA C AND COMMA C+1, WHERE C IS THE 3RD ARGUMENT.
C  ALSO,NOTE THAT NCOVA MUST BE PROVIDED TO AFTERCOMMA SO IT WILL KNOW
C  THE TOTAL NO. OF COMMAS IN READLINE (WHICH = 11 + NCOVA).

	REWIND(66)
  120	READ(66,1) READLINE
	IF(READLINE(1:3) .NE. '#ID' .AND. READLINE(1:4).NE. '"#ID' 
     1  .AND. READLINE(1:3) .NE. '#id' .AND. READLINE(1:4).NE. '"#id')
     2   GO TO 120

	 DO ICOV = 1,NCOVA
	  CALL AFTERCOMMA(NCOVA,READLINE,11+ICOV)
	  BACKSPACE(57)
	  READ(57,2) COVNAME(ICOV)
    2     FORMAT(A11)
	  CLOSE(57)
	 END DO


	ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(NCOVA .GT. 0)  CONDITION.


C  CALL SUBROUTINE GETMAXTIM TO GET THE MAXIMUM TIME OVER ALL THE
C  SUBJECTS IN FILE 66. THIS INCLUDES THE ENDING TIME OVER ALL IV
C  EVENTS. THEN SET TIMADD = THIS TIME + 1. FOR EACH SUBJECT BELOW,
C  EACH TIME WILL HAVE TIMADD*NRESET ADDED TO IT, WHERE NRESET IS THE 
C  NO. OF TIME RESETS (FOR THAT SUBJECT) UP TO AND INCLUDING THAT TIME. 
C  THIS WILL MAKE EACH TIME A UNIQUE TIME (I.E., WITH TIME RESETS IN
C  THE BLOCK FORMAT FILE, THERE COULD BE MANY TIMES WITH THE SAME 
C  VALUE).

	CALL GETMAXTIM(NCOVA,TIMAX)



C  VERIFY THAT TIMAX WAS CALCULATED CORRECTLY - I.E., THAT IT IS NOT
C  STILL THE INITIALIZED NEGATIVE VALUE IN GETMAXTIM.

	IF(TIMAX .LT. 0) THEN



	 WRITE(*,11) 
   11    FORMAT(/' THERE IS SOMETHING WRONG WITH YOUR BLOCK FORMAT'/


     1' FILE. THE TIMES IN COLUMN 3 AND/OR THE TIME DURATIONS'/
     2' IN COLUMN 4 ARE BAD. PLEASE CHECK YOUR VALUES. '//
     3' THE PROGRAM STOPS.')

        OPEN(42,FILE=ERRFIL)
         WRITE(42,11)
        CLOSE(42)



	 CALL PAUSE
	 STOP



	ENDIF

   	TIMADD = TIMAX + 1.D0


C  REWIND FILE 66, READ PAST THE FIRST LINE WHICH HAS THE CODE, AND 
C  THE SECOND LINE, WHICH HAS THE COVARIATE INFORMATION ON IT, AND
C  THEN READ ALL LINES, EXCEPT THOSE THAT START WITH # OR "#.
C  GO THROUGH EACH SUCCEEDING LINE IN FILE 66 AND EXTRACT ALL THE 
C  INFORMATION. NOTE THAT EACH LINE CAN CONTAIN OUTPUT INFO OR DOSAGE
C  INFO (INCLUDING COVARIATE VALUES), DEPENDING ON THE VALUE FOR IDEVENT
C  (THE 2ND ENTRY IN EACH LINE), BUT NOT BOTH. IN PARTICULAR, IF
C  IDEVENT = 0 --> THE ROW HAS OUTPUT EQUATION INFO.
C  IDEVENT = 1 --> THE ROW HAS DOSAGE/COVARIATE INFO.
C  IDEVENT = 4 --> SAME AS IDEVENT = 1, EXCEPT THIS ROW REPRESENTS A 
C                  TIME RESET.

	REWIND(66)
	READ(66,1)
	READ(66,1)

C  INITIALIZE SUBIDPREV (THE PREVIOUS SUBJECT ID) TO BE '%^&*' SO THE 
C  FIRST SUJBECT ID READ IN BELOW WILL BE DIFFERENT THAN THIS, AND SO 

C  START THE SUBJECT ID LOGIC. ALSO, INITIALIZE THE SUBJECT NO. TO 0.

	SUBIDPREV = '%^&*'
	NSUB = 0

C  NOTE THAT IEND .LT. 0 --> END OF FILE REACHED.	

   10	READ(66,1,IOSTAT=IEND) READLINE

	IF(IEND .LT. 0) GO TO 100
	IF(READLINE(1:1) .EQ. '#' .OR. READLINE(1:2) .EQ. '"#') GO TO 10

C  THE FIRST VALUE (I.E., AFTER COMMA NO. 0) IS THE SUBJECT ID.

	CALL AFTERCOMMA(NCOVA,READLINE,0)
	BACKSPACE(57)
	READ(57,2) SUBID

	CLOSE(57)

C  NOTE THAT SUBID CONTAINS THE 1ST 11 CHARACTERS OF THE LINE, BUT THE
C  SUBJECT ID IS JUST THE SET OF CHARACTERS PRIOR TO THE 1ST COMMA.
C  CALL SUBROUTINE GETID TO CORRECT THE VALUE OF SUBID.

	CALL GETID(SUBID)

C  IF SUBID = SUBIDPREV, THIS IS ANOTHER LINE FOR THE CURRENT SUBJECT. 
C  IF SUBID .NE. SUBIDPREV, THIS IS THE 1ST EVENT FOR A NEW SUBJECT, SO 
C  INCREASE NSUB, AND SET THE NO. OF INFUSIONS (FOR EACH DRUG), BOLI, 
C  OBSERVATION, AND COVARIATE TIMES FOR THIS SUBJECT TO 0 (THEY WILL 
C  BE UPDATED BELOW AS REQUIRED). SIMILARY SET THE TOTAL NO. OF DOSE 
C  EVENTS = 0. 

C  ALSO, SINCE THIS IS A NEW SUBJECT, DEFAULT THE ASSAY COEFFICIENTS FOR
C  OUTPUT EQ. IEQ TO [C0(IEQ),C1(IEQ),C2(IEQ),C3(IEQ)], 
C  IEQ = 1,MAXNUMEQ (MAXNUMEQ IS THE MAXIMUM THAT NUMEQT CAN BE). THEN,
C  AS THIS SUBJECT'S INFO IS BEING READ BELOW, ANY ASSAY C'S SPECIFIED
C  FOR THIS SUBJECT WILL OVERWRITE THE DEFAULT VALUES. AND NOTE THAT IF
C  A SUBJECT HAS MORE THAN ONE SET OF ASSAY C'S FOR A GIVEN OUTPUT EQ.,
C  THE LAST SET WILL BE USED.

C  NOTE THAT AFTER READBLOCK2 HAS FINISHED READING THE PATIENT INFO,
C  CSUB(I,J,K), J=1,4 WILL BE ASSAY C'S [C0 C1 C2 C3] FOR SUBJECT I
C  AND OUTPUT EQ. K. 
 


	IF(SUBID .NE. SUBIDPREV) THEN

	 SUBIDPREV = SUBID
	 NSUB = NSUB + 1

C  FASTFORWARD THE LOGIC TO THE END OF THE ROUTINE IF NSUB = 2, SINCE
C  THE INFO FOR THE FIRST SUBJECT WILL ALREADY HAVE BEEN READ IN. AND 
C  RESET NSUB = 1 AT THAT POINT SINCE ONLY THE FIRST SUBJECT'S DATA WILL
C  BE NEEDED.

        IF(NSUB .EQ. 2) GO TO 100


	 WRITE(*,8888) NSUB
 8888    FORMAT('+ ',' NOW WORKING ON SUBJECT NO. ',I4)

	 SUBARRAY(NSUB) = SUBID

	 NTIMALL(NSUB) = 0

	 DO K = 1,7
	  NTIMIV(NSUB,K) = 0
	  NTIMBOL(NSUB,K) = 0
	 END DO

	 DO K = 1,26
	  NTIMCOV(NSUB,K) = 0
	 END DO

        DO K = 1,MAXNUMEQ
         NTIMOUT(NSUB,K) = 0
         CSUB(NSUB,1,K) = C0(K)
         CSUB(NSUB,2,K) = C1(K)
         CSUB(NSUB,3,K) = C2(K)
         CSUB(NSUB,4,K) = C3(K)
        END DO


C  SEE LOGIC BELOW. IF THIS ROW REPRESENTS A TIME RESET, THEN AN
C  EXTRA VALUE (-99) AT AN EXTRA TIME (0) WILL BE ADDED TO EACH OUTPUT
C  EQUATION ARRAY. BUT THIS NEEDS TO BE DONE JUST ONCE FOR EACH TIME

C  RESET, NOT FOR EACH DOSAGE LINE THAT HAS A RESET. I.E., IF THERE
C  ARE 5 DRUGS, THEN THERE COULD BE AS MANY AS 5 DOSE LINES WITH A
C  RESET VALUE. ALSO, WITHIN EACH LINE, A DOSE AND/OR A COVARIATE
C  COULD HAVE A RESET TIME OF 0. THEREFORE EACH BLOCK OF CODE BELOW,
C  FOR EACH DRUG NO. AND EACH COVARIATE, IS TESTED FOR A TIME RESET,
C  AND IN EACH CASE, EXTRA LINES ARE POTENTIALLY ADDED TO THE OUPUT 
C  ARRAYS. TO PREVENT MORE EXTRA LINES (OF OUTPUT VALUES = -99 AT
C  TIMES = 0) THAN ARE NECESSARY, INITIALIZE NRESETADD = 0. THIS 
C  TELLS THE PROGRAM THAT NO EXTRA LINES HAVE BEEN ADDED TO THE OUTPUT
C  ARRAYS SINCE THE LAST ACTUAL OUTPUT VALUE WAS PUT INTO ONE OF THE
C  ARRAYS. NRESETADD WILL BE CHANGED TO 1 WHENEVER EXTRA LINES HAVE
C  BEEN ADDED TO THE OUTPUT ARRAYS, AND THEN BACK TO 0 WHENEVER ANOTHER
C  ACTUAL OUTPUT VALUE HAS BEEN PUT INTO AN ARRAY.

	NRESETADD = 0

C  INITIALIZE NRESET TO 0. IT WILL BE THE NO. OF TIME RESETS THAT
C  HAVE OCCURRED UP TO ANY TIME. ALSO INITIALIZE TIMERESET = 0; THIS 
C  WILL BE THE RUNNING TIME TO BE ADDED TO EACH ACTUAL TIME. IT WILL
C  ALWAYS BE SET = TIMADD*NRESET BELOW.

	NRESET = 0	
	TIMERESET = TIMADD*NRESET

C  ALSO INITIALIZE NRESETLAST = -1 (SEE CODE BELOW).

       NRESETLAST = -1
       DOSELINEST(NSUB,1,100) = -99

C  DOSELINE(NSUB,1,100) IS INITIALIZED TO BE -99. IF IT CHANGES BELOW
C  TO BE .GE. 0, IT MEANS THAT THERE IS AT LEAST ONE STEADY STATE DOSE
C  SET, AND THE FIRST ONE OCCURS AT THE VALUE OF NRESET =
C  DOSELINEST(NSUB,1,100).


C  VERIFY THAT THE 2ND VALUE (I.E., AFTER COMMA NO. 1), WHICH IS THE 
C  EVENT ID, IDEVENT, IS 1 SINCE THE FIRST EVENT FOR EACH SUBJECT

C  SHOULD BE 1 (A NON-TIME-RESET DOSE EVENT).

	CALL AFTERCOMMA(NCOVA,READLINE,1)
	BACKSPACE(57)
	READ(57,*) IDEVENT
	CLOSE(57)

	IF(IDEVENT .NE. 1) THEN



	 WRITE(*,402) SUBARRAY(NSUB),IDEVENT
  402    FORMAT(/' THERE IS AN ERROR IN THE BLOCK FORMAT. FOR SUBJECT '/
     1 1X,A11,', THE FIRST EVENT ID IS NOT 1 AS REQUIRED. IT IS ',I3/
     3' THE PROGRAM STOPS.'/)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,402) SUBARRAY(NSUB),IDEVENT
        CLOSE(42)

	 CALL PAUSE
	 STOP



	ENDIF


	ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(SUBID .NE. SUBIDPREV)  CONDITION.


C  THE 2ND VALUE (I.E., AFTER COMMA NO. 1) IS THE EVENT ID, IDEVENT 

C  (SEE ABOVE).               
	
	CALL AFTERCOMMA(NCOVA,READLINE,1)
	BACKSPACE(57)
	READ(57,*) IDEVENT
	CLOSE(57)

C  IF THE ID OF THIS EVENT IS NO. 4, IT IS A TIME RESET EVENT. IN THIS
C  CASE, INCREASE NRESET AND TIMERESET AS INDICATED ABOVE.


	IF(IDEVENT .EQ. 4) THEN
	 NRESET = NRESET + 1
	 TIMERESET = TIMADD*NRESET
	ENDIF


C  THE 3RD VALUE (I.E., AFTER COMMA NO. 2) IS THE TIME OF THE EVENT.
C  READ THIS VALUE NOW.
	

	CALL AFTERCOMMA(NCOVA,READLINE,2)
	BACKSPACE(57)
	READ(57,*) TIMEVENT
	CLOSE(57)


      IF(TIMEVENT .LT. 0.D0) THEN

C  STORE INTO DOSELINEST(.,.,.) ALL THE INFO FOR THE WORKING COPY FILE
C  FOR THIS STEADY STATE DOSE SET.



C  COMPARE NRESET WITH THE PREVIOUS VALUE OF NRESET WHEN THIS PART OF
C  THE CODE WAS USED: IF THEY ARE THE SAME, THIS LINE WILL PROVIDES
C  MORE INFO (FOR A DIFFERENT DRUG NO.) FOR THE SAME STEADY STATE DOSE
C  EVENT TO BE PUT INTO THE WORKING COPY FILE. IF THEY ARE DIFFERENT,
C  THIS LINE IS THE FIRST LINE OF A NEW STEADY STATE DOSE SET.


       IF(NRESET .GT. NRESETLAST) THEN

C  PUT IN NEW INFO FOR A NEW LINE (FOR A NEW STEADY STATE DOSE SET).
C  THIS LINE IS THE FIRST LINE WITH INFO ON A NEW STEADY STATE DOSE SET.
C  STORE ALL THE INFO FROM THIS LINE, INCLUDING NRESET, SO SUBROUTINE
C  WRITEDOS CAN WRITE THE INFO FOR THIS LINE SEPARATELY. NOTE THAT THIS
C  LINE WILL NOT BE A PART OF THE LOGIC BELOW WHICH STORES ALL DOSE 
C  INFO, AND THEN SORTS IT BY TIME. NOTE THAT NRESET IS STORED INTO
C  ENTRY 100 FOR THIS LINE.

        NSST(NSUB) = NSST(NSUB) + 1

        IF(NSST(NSUB) .GT. 99) THEN



         WRITE(*,172) NSUB
  172    FORMAT(/' FOR SUBJECT NO. ',I5,' THE NO. OF STEADY STATE DOSE'/
     1' SETS IS MORE THAN 99, THE MAXIMUM ALLOWED. PLEASE RERUN THE'/
     2' PROGRAM AFTER REDUCING THE NO. OF STEADY STATE DOSE SETS TO'/
     3' NO MORE THAN 99.'//
     4' THE PROGRAM STOPS.'/)
	  WRITE(*,401) NSUB,SUBARRAY(NSUB)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,172) NSUB                  
        CLOSE(42)



         CALL PAUSE
         STOP



        ENDIF


        DOSELINEST(NSUB,NSST(NSUB),100) = NRESET

C  TIMEVENT IS THE NEGATIVE OF THE INTERDOSE INTERVAL, WHICH WILL SHOW
C  UP IN THE TIME COLUMN OF THE WORKING COPY FILE.

        DOSELINEST(NSUB,NSST(NSUB),1) = TIMEVENT

C  ZERO OUT ALL THE IV AND BOLUS ENTRIES FOR ALL POSSIBLE DRUGS
C  (I.E., THERE COULD BE AS MANY AS 7 DRUGS).

        DO I = 1,7
         DOSELINEST(NSUB,NSST(NSUB),2*I) = 0.D0
         DOSELINEST(NSUB,NSST(NSUB),2*I+1) = 0.D0
        END DO


C  STORE ANY COVARIATE INFO INTO THE COVARIATE ENTRIES. NOTE IT IS NOT
C  KNOWN AT THIS POINT HOW MANY TOTAL DRUGS ARE USED IN THE MODEL SINCE
C  THE VALUE FOR NDRUG HAS NOT YET FINISHED UPDATING (IN THE CODE BELOW,
C  IT IS SET = IDRUGNO IF NDRUG .LT. IDRUGNO). SO, THE COVARIATE VALUES
C  WILL BE STORED FAR ENOUGH OUT IN THE DOSELINEST(.,.,.) ARRAY TO NOT
C  INTERFERE WITH THE ENTRIES FOR THE MAXIMUM NO. OF POSSIBLE DRUGS.
C  SINCE THERE ARE AT MOST 7 POSSIBLE DRUGS, ENTRIES 2,3,...,14,15 WILL
C  BE RESERVED FOR THESE DRUG VALUES, AND THE COVARIATE VALUES WILL
C  START WITH ENTRY NO. 20.


        IF(NCOVA .GT. 0) THEN
         
         DO 110 ICOV = 1,NCOVA
          CALL AFTERCOMMA(NCOVA,READLINE,11+ICOV)
          BACKSPACE(57)
 	    READ(57,*,ERR=95) COVVAL
	    CLOSE(57)
          DOSELINEST(NSUB,NSST(NSUB),19+ICOV) = COVVAL

          GO TO 110
   95     DOSELINEST(NSUB,NSST(NSUB),19+ICOV) = -99.D0
  110    CONTINUE

        ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(NCOVA .GT. 0)  CONDITION.


C  THIS IS EITHER A TIME RESET EVENT, OR THE TOP OF THE PATIENT'S FILE.
C  IF IT IS THE TOP OF THE PATIENT'S FILE, NRESET WILL = 0. IF IT IS A 
C  TIME RESET EVENT, NRESET WILL BE > 0, AND IN THIS CASE, MUST STORE 
C  VALUES INTO THE OUPUT ARRAYS (SEE LOGIC BELOW) WHICH INDICATE THAT

C  SUBSEQUENT OUTPUT TIMES ARE BASED ON THIS TIME RESET.

       IF(NRESET .GT. 0) THEN
        DO IOUTEQ = 1,MAXNUMEQ
         NTIMOUT(NSUB,IOUTEQ) = NTIMOUT(NSUB,IOUTEQ) + 1
         TIMOUT(NSUB,IOUTEQ,NTIMOUT(NSUB,IOUTEQ)) = TIMERESET
         OUT(NSUB,IOUTEQ,NTIMOUT(NSUB,IOUTEQ)) = -99.D0
        END DO
       ENDIF


       ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(NRESET .GT. NRESETLAST)  CONDITION.


C  ESTABLISH THE DURATION, (4TH VALUE, AFTER THE 3RD COMMA), DOSE (5TH
C  VALUE, AFTER THE 4TH COMMA), AND DRUG NO. (6TH VALUE, AFTER THE 5TH

C  COMMA) FOR THIS LINE.

        CALL AFTERCOMMA(NCOVA,READLINE,3)
        BACKSPACE(57)
        READ(57,*,ERR=170) DUR
        CLOSE(57)


        CALL AFTERCOMMA(NCOVA,READLINE,4)
        BACKSPACE(57)
        READ(57,*,ERR=170) TOTDOS

        CLOSE(57)

        CALL AFTERCOMMA(NCOVA,READLINE,5)
        BACKSPACE(57)
        READ(57,*,ERR=170) IDRUGNO
	  IF(NDRUG .LT. IDRUGNO) NDRUG = IDRUGNO


        CLOSE(57)

C  STORE THE IV RATE INTO THE IV ENTRY FOR DRUG NO. IDRUGNO; SIMILARLY,
C  STORE THE TOTAL DOSE INTO THE BOLUS ENTRY FOR DRUG NO. IDRUGNO.
C  NOTE THAT IF DUR = 0, THIS LINE REPRESENTS A STEADY STATE OF BOLUS 
C  VALUES. IN THIS CASE, SET THE IV RATE TO 0.

        IF(DUR .LE. 0.D0) 
     1   DOSELINEST(NSUB,NSST(NSUB),2*IDRUGNO) = 0.D0
        IF(DUR .GT. 0.D0)
     1   DOSELINEST(NSUB,NSST(NSUB),2*IDRUGNO) = TOTDOS/DUR
        DOSELINEST(NSUB,NSST(NSUB),2*IDRUGNO+1) = TOTDOS




C  NOTE THAT COVARIATE VALUES ARE ONLY READ FOR THE FIRST DOSE LINE
C  IN A STEADY STATE SET (I.E., WHEN NRESET .GT. NRESETLAST). IT IS
C  POSSIBLE THAT THE USER'S .csv FILE HAS A DIFFERENT SET OF COV. VALUES
C  FOR EACH LINE (FOR A DIFFERENT DRUG) THAT IS INCLUDED IN THE 
C  CURRENT STEADY STATE DOSE SET. BUT, THIS WOULD BE A MISTAKE SINCE
C  ONLY 1 SET OF COV. VALUES CAN BE USED FOR THE STEADY STATE SET. THE
C  FIRST SET OF VALUES WILL BE USED (AND ALL OTHERS WILL BE IGNORED).
 
C  SET NRESETLAST = NRESET SO IF ANOTHER LINE OF DOSE INFO FOR THE
C  CURRENT STEADY STATE SET FOLLOWS, THE PROGRAM WILL KNOW IT IS
C  MORE INFO ON THE CURRENT SET, AND NOT NEW INFO ON THE NEXT SET.
  
       NRESETLAST = NRESET

       GO TO 10


  170  WRITE(*,171) NSUB,READLINE(1:75)
  171  FORMAT(/' THERE IS AN ERROR IN YOUR BLOCK FORMAT FILE FOR '/
     1' SUBJECT NO. ',I5,'. EITHER THE DURATION, THE DOSE, OR THE '/
     2' DRUG NUMBER IS MISSING. THE 1ST 75 CHARACTERS OF THE LINE ARE:'/
     2A75//
     3' THE PROGRAM STOPS.'/)
	 WRITE(*,401) NSUB,SUBARRAY(NSUB)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,401) NSUB,SUBARRAY(NSUB)
        CLOSE(42)



  	 CALL PAUSE
	 STOP

      ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(TIMEVENT .LT. 0.D0)  CONDITION.




	TIMEVENT = TIMEVENT + TIMERESET




C  IF IDEVENT = 0, IT MEANS THAT THIS ROW IS AN OBSERVED VALUE ROW.
C  IN THIS CASE, READ THE OBSERVED VALUE INFO.

	IF(IDEVENT .EQ. 0) THEN

C  THE 7TH ENTRY (AFTER COMMA NO. 6) IS AN OUTPUT VALUE FOR THIS TIME 
C  IF THERE IS AN ERROR, IT IS ASSUMED THAT THE PROGRAM READ A DOT,

C  WHICH WOULD BE INCONSISTENT SINCE IDEVENT = 0 (MEANING THERE SHOULD
C  BE AN OUTPUT VALUE ON THE ROW).

	CALL AFTERCOMMA(NCOVA,READLINE,6)
	BACKSPACE(57)
	READ(57,*,ERR=30) YVAL
	CLOSE(57)

C  TO GET TO THIS POINT --> YVAL CONTAINS AN OUTPUT VALUE FOR THIS
C  LINE. BEFORE THIS VALUE CAN BE STORED, MUST READ THE OUTPUT EQUATION 
C  NO. AFTER COMMA NO. 7. 

	CALL AFTERCOMMA(NCOVA,READLINE,7)
	BACKSPACE(57)

	READ(57,*,ERR=30) IOUTEQ
	IF(NOUT .LT. IOUTEQ) NOUT = IOUTEQ 
	CLOSE(57)

C  STORE THIS VALUE. ALSO STORE THE TIME OF THIS EVENT INTO THE ARRAY 
C  WHICH STORES OUTPUT TIMES.

	NTIMOUT(NSUB,IOUTEQ) = NTIMOUT(NSUB,IOUTEQ) + 1
	TIMOUT(NSUB,IOUTEQ,NTIMOUT(NSUB,IOUTEQ)) = TIMEVENT
	OUT(NSUB,IOUTEQ,NTIMOUT(NSUB,IOUTEQ)) = YVAL
	NRESETADD = 0

C  SEE CODE ABOVE REGARDING NRESEADD.


	GO TO 20

C  REPLACE WRITING OF TIMEVENT - TIMERESET WITH XVERIFY (SEE LOGIC IN 
C  SUBROUTINE VERIFYVAL.

   30   XVERIFY(1) = TIMEVENT - TIMERESET
        CALL VERIFYVAL(1,XVERIFY)
C  30   WRITE(*,31) NSUB, TIMEVENT - TIMERESET
        WRITE(*,31) NSUB, XVERIFY(1)
   31   FORMAT(/' THERE IS AN ERROR IN THE BLOCK FORMAT. FOR SUBJECT '/
     1' NO. ',I4,' AND TIME ',F10.4, ' A LINE HAS AN EVENT ID OF 0 IN'/
     2' COL. 2, INDICATING OBSERVED VALUE INFORMATION. BUT THERE IS '/
     3' EITHER NO OBSERVED VALUE IN COL. 7, OR NO OUTPUT EQUATION NO.'/
     4' IN ENTRY 8. '//
     3' THE PROGRAM STOPS.')
	  WRITE(*,401) NSUB,SUBARRAY(NSUB)
  401   FORMAT(/' NOTE: THE ID FOR SUBJECT NO. ',I4,' IS ',A11/)

        OPEN(42,FILE=ERRFIL)
C        WRITE(42,31) NSUB, TIMEVENT - TIMERESET
         WRITE(42,31) NSUB, XVERIFY(1)
         WRITE(42,401) NSUB,SUBARRAY(NSUB)
        CLOSE(42)	

        CALL PAUSE
        STOP

   20 CONTINUE

C  THE 9TH - 12TH ENTRIES FOR THIS ROW POTENTIALLY HOLD NEW ASSAY 
C  COEFFICIENTS FOR THIS SUBJECT (NSUB) AND OUTPUT EQ. (IOUTEQ).
C  READ THESE VALUES. IF THEY ARE NOT MISSING, UPDATE THE ASSAY
C  COEFFICIENT INFO FOR THIS SUBJECT/OUTPUT EQ.

C  NOTE THAT THESE ENTRIES SHOULD ALL BE MISSING (DOTS OR n's) OR ALL
C  BE NUMBERS. IF THERE IS A COMBINATION  OF MISSING VALUES AND NUMBERS,
C  STOP THE PROGRAM AND TELL THE USER.

        IMISSC0 = 0
        IMISSC1 = 0
        IMISSC2 = 0
        IMISSC3 = 0
      
        CALL AFTERCOMMA(NCOVA,READLINE,8)
        BACKSPACE(57)
        READ(57,*,ERR=230) C00

        CLOSE(57)


        GO TO 235
  230   IMISSC0 = 1

  235   CALL AFTERCOMMA(NCOVA,READLINE,9)
        BACKSPACE(57)
        READ(57,*,ERR=240) C11
        CLOSE(57)

        GO TO 245

  240   IMISSC1 = 1

  245   CALL AFTERCOMMA(NCOVA,READLINE,10)
        BACKSPACE(57)
        READ(57,*,ERR=250) C22
        CLOSE(57)

        GO TO 255
  250   IMISSC2 = 1

  255   CALL AFTERCOMMA(NCOVA,READLINE,11)
        BACKSPACE(57)
        READ(57,*,ERR=260) C33
        CLOSE(57)

        GO TO 265
  260   IMISSC3 = 1



  265   CONTINUE

C  IF ALL IMISSCx VALUES ARE 0, UPDATE THE ASSAY C'S FOR THIS
C  SUBJECT AND OUTPUT EQ. NO. IF ALL IMISSCx VALUES ARE 1, THEY
C  ARE ALL MISSING, SO JUST CONTINUE. IF SOME OF THE IMISSCx VALUES
C  ARE 0 AND SOME ARE 1, THIS IS AN INCONSISTENCY (I.E., THE USER HAS
C  ENTERED SOME BUT NOT ALL OF THE ASSAY C'S). IN THIS CASE, STOP THE
C  PROGRAM AFTER INFORMING THE USER OF HIS ERROR.

        ISUMC = IMISSC0 + IMISSC1 + IMISSC2 + IMISSC3

        IF(ISUMC .EQ. 0) THEN
         CSUB(NSUB,1,IOUTEQ) = C00
         CSUB(NSUB,2,IOUTEQ) = C11
         CSUB(NSUB,3,IOUTEQ) = C22
         CSUB(NSUB,4,IOUTEQ) = C33
        ENDIF

        IF(ISUMC .NE. 0 .AND. ISUMC .NE. 4) THEN

C  REPLACE WRITING OF TIMEVENT - TIMERESET WITH XVERIFY (SEE LOGIC IN 
C  SUBROUTINE VERIFYVAL.

         XVERIFY(1) = TIMEVENT - TIMERESET
         CALL VERIFYVAL(1,XVERIFY)
C        WRITE(*,231) NSUB, TIMEVENT - TIMERESET,IOUTEQ
         WRITE(*,231) NSUB, XVERIFY(1),IOUTEQ
  231    FORMAT(/' THERE IS AN ERROR IN THE BLOCK FORMAT. FOR SUBJECT '/
     1' NO. ',I4,' AND TIME ',F10.4, ' A LINE HAS AN EVENT ID OF 0 IN'/
     2' COL. 2, INDICATING OBSERVED VALUE INFORMATION, BUT THIS LINE'/
     3' HAS AN INCOMPLETE SET OF ASSAY COEFFICIENTS FOR OUTPUT EQ. '/
     4' NUMBER ',I3,'. THERE MUST BE EITHER 4 ASSAY COEFFICIENTS ON'/
     5' AN OUTPUT LINE, OR NONE (IF NO OUTPUT LINES FOR A PARTICULAR'/
     6' SUBJECT x OUTPUT EQ. COMBO HAVE ASSAY COEFFICIENTS, THEN THE'/
     7' POPULATION COEFFICIENTS WILL BE USED).'//
     8' THE PROGRAM STOPS.')
         WRITE(*,401) NSUB,SUBARRAY(NSUB)

        OPEN(42,FILE=ERRFIL)
C        WRITE(42,231) NSUB, TIMEVENT - TIMERESET,IOUTEQ
         WRITE(42,231) NSUB, XVERIFY(1),IOUTEQ
         WRITE(42,401) NSUB,SUBARRAY(NSUB)
        CLOSE(42)

         CALL PAUSE
         STOP


        ENDIF


	ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(IDEVENT .EQ. 0)  CONDITION.


	IF(IDEVENT .EQ. 1 .OR. IDEVENT .EQ. 4) THEN



C  IDEVENT = 1 OR 4 --> DOSE AND/OR COVARITE INFO IS TO BE READ IN.

C  THE 4TH ENTRY (AFTER COMMA NO. 3) IS AN INFUSION DURATION, AND THE
C  5TH ENTRY (AFTER COMMA NO. 4) IS THE TOTAL DOSE ... IF THIS LINE 
C  HAS DOSE INFORMATION. NOTE THAT IF THERE IS NO DOSE, THE TOTAL DOSE
C  ENTRY WILL BE A DOT ("."). ALSO, IF THERE IS A TOTAL DOSE, BUT THE
C  INFUSION DURATION IS 0, THIS LINE REPRESENTS A BOLUS INPUT.

C  SO, 1ST TRY READING THE TOTAL DOSE AS A REAL NUMBER; IF THERE IS AN 
C  ERROR, IT IS ASSUMED THAT THE PROGRAM READ A DOT.

	CALL AFTERCOMMA(NCOVA,READLINE,4)
	BACKSPACE(57)
	READ(57,*,ERR=40) TOTDOS 
	CLOSE(57)

C  TO GET TO THIS POINT --> TOTDOS CONTAINS A TOTAL DOSE VALUE FOR THIS
C  LINE. READ THE INFUSION DURATION AFTER COMMA NO. 3 TO SEE IF THIS
C  DOSE IS AN INFUSION (WITH A POSITIVE DURATION) OR A BOLUS (WITH A
C  0 DURATION).

	CALL AFTERCOMMA(NCOVA,READLINE,3)
	BACKSPACE(57)
	READ(57,*,ERR=50) DUR
	CLOSE(57)

C  BEFORE THIS VALUE CAN BE STORED, MUST READ THE DRUG NO. AFTER COMMA
C  NO. 5.

	CALL AFTERCOMMA(NCOVA,READLINE,5)
	BACKSPACE(57)
	READ(57,*,ERR=50) IDRUGNO
	IF(NDRUG .LT. IDRUGNO) NDRUG = IDRUGNO
	CLOSE(57)

C  STORE THE ABOVE VALUES DEPENDING ON WHETHER THEY REPRESENT AN
C  INFUSION OR A BOLUS INPUT.


C  INCREASE THE NO. OF DOSAGE LINES FOR THIS SUBJECT. IF DUR > 0, THE
C  NO. OF DOSAGE LINES INCREASES BY 2 SINCE THERE WILL BE A START TIME
C  AND AN ENDING TIME. IF DUR = 0, THE NO. OF DOSAGE LINES WILL INCREASE
C  BY 1.

	IF(DUR .GT. 0) THEN


C  THE INFUSION RATE IS TOTDOS/DUR. SO THE DOSE VALUE THE 1ST DOSE
C  TIME BELOW WILL BE THIS INFUSION RATE, AND THE DOSE VALUE AT THE
C  2ND DOSE TIME BELOW WILL BE 0.

C  NOTE THAT EVERYTIME NTIMALL(NSUB) IS INCREASED, THE PROGRAM CHECKS
C  THAT IT HAS NOT GONE PAST 24000. IF SO, A MESSAGE TO THE USER IS
C  WRITTEN THAT THIS IS NOT ALLOWED AND THE PROGRAM STOPS.

	 NTIMALL(NSUB) = NTIMALL(NSUB) + 1

	 IF(NTIMALL(NSUB) .GT. 24000) THEN



	  WRITE(*,3001) NSUB
 3001     FORMAT(/' THE NO. OF LINES IN THE DOSAGE REGIMEN FOR SUBJECT'/
     1' NO. ',I5,' IS MORE THAN THE LIMIT OF 24000. PLEASE RERUN THE'/
     2' PROGRAM AFTER REDUCING THIS NO. TO BE LESS THAN 24000.'/)
	  WRITE(*,401) NSUB,SUBARRAY(NSUB)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,3001) NSUB
         WRITE(42,401) NSUB,SUBARRAY(NSUB)
        CLOSE(42)	




	  CALL PAUSE
	  STOP



	 ENDIF


	 TIMALL(NSUB,NTIMALL(NSUB)) = TIMEVENT


      IF(IDEVENT .EQ. 4) THEN

C  IF IDEVENT = 4, IT MEANS THAT THIS IS A TIME RESET POINT (I.E., A 
C  TIME IN THE DISTANT FUTURE WHICH WILL SHOW UP AS T = 0 IN THE 
C  WORKING COPY FORMAT FILE). IN THIS CASE, IF NRESETADD = 0, ADD 
C  VALUES TO NTIMOUT, TIMOUT, AND OUT FOR EACH  OF THE MAXNUMEQ POSSIBLE
C  OUTPUT EQUATIONS (THERE ARE NOUT OUTPUT EQUATIONS SO FAR, BUT IN 
C  SUBSEQUENT ROWS, NOUT COULD INCREASE TO AT MOST MAXNUMEQ) TO 
C  INDICATE THAT ANY OUTPUTS FOLLOWING THIS TIME ARE BASED ON THE TIME
C  RESET. TO DO THIS, PUT IN THE CURRENT TIME IN TIMOUT, AND A
C  CORRESPONDING VALUE OF -99 (MISSING VALUE), FOR EACH OUTPUT EQUATION.

C  STORE VALUES INTO THE OUPUT ARRAYS (TIME = 0 AND VALUE = -99) WHICH 
C  INDICATE THAT SUBSEQUENT OUTPUT TIMES ARE BASED ON THIS TIME RESET.
C  ... BUT ONLY STORE THESE EXTRA VALUES IF NRESETADD = 0. IF 
C  NRESETADD = 1, IT MEANS THAT THESE LINES HAVE ALREADY BEEN ADDED
C  SINCE THE LAST ACTUAL OUTPUT VALUE WAS PUT INTO ONE OF THE OUTPUT
C  ARRAYS.

       IF(NRESETADD .EQ. 0) THEN
        DO IOUTEQ = 1,MAXNUMEQ
         NTIMOUT(NSUB,IOUTEQ) = NTIMOUT(NSUB,IOUTEQ) + 1
         TIMOUT(NSUB,IOUTEQ,NTIMOUT(NSUB,IOUTEQ)) = TIMEVENT
   	   OUT(NSUB,IOUTEQ,NTIMOUT(NSUB,IOUTEQ)) = -99.D0
        END DO
        NRESETADD = 1
       ENDIF

	 ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(IDEVENT .EQ. 4)  CONDITION.


C  IF THE CURRENT TIME IS THE SAME AS THE ENDING TIME OF THE PREVIOUS 
C  IV, DO NOT INCREASE NTIMIV(.,.) BELOW, BECAUSE THE NEW STARTING IV 
C  RATE MUST REPLACE THE 0.0 FROM THE ENDING OF THE PREVIOUS IV.

        ISAME = 0
        IF(NTIMIV(NSUB,IDRUGNO) .GT. 0) 
     1   CALL THESAME(TIMEVENT,TIMIV(NSUB,IDRUGNO,NTIMIV(NSUB,IDRUGNO)),
     2 ISAME)

        IF(ISAME .EQ. 0) NTIMIV(NSUB,IDRUGNO) = NTIMIV(NSUB,IDRUGNO) + 1
        TIMIV(NSUB,IDRUGNO,NTIMIV(NSUB,IDRUGNO)) = TIMEVENT
        RATEIV(NSUB,IDRUGNO,NTIMIV(NSUB,IDRUGNO)) = TOTDOS/DUR

	 NTIMALL(NSUB) = NTIMALL(NSUB) + 1

	 IF(NTIMALL(NSUB) .GT. 24000) THEN

	  WRITE(*,3001) NSUB
	  WRITE(*,401) NSUB,SUBARRAY(NSUB)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,3001) NSUB
         WRITE(42,401) NSUB,SUBARRAY(NSUB)
        CLOSE(42)	



	  CALL PAUSE
	  STOP



	 ENDIF

	 TIMALL(NSUB,NTIMALL(NSUB)) = TIMEVENT + DUR
	 NTIMIV(NSUB,IDRUGNO) = NTIMIV(NSUB,IDRUGNO) + 1
	 TIMIV(NSUB,IDRUGNO,NTIMIV(NSUB,IDRUGNO)) = TIMEVENT + DUR

	 RATEIV(NSUB,IDRUGNO,NTIMIV(NSUB,IDRUGNO)) = 0.D0

	ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(DUR .GT. 0)  CONDITION.

	

	IF(DUR .LE. 0) THEN

C  STORE THE BOLUS VALUE AT THE INDICATED TIME, TIMEVENT.

	 NTIMALL(NSUB) = NTIMALL(NSUB) + 1

	 IF(NTIMALL(NSUB) .GT. 24000) THEN



	  WRITE(*,3001) NSUB
	  WRITE(*,401) NSUB,SUBARRAY(NSUB)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,3001) NSUB
         WRITE(42,401) NSUB,SUBARRAY(NSUB)
        CLOSE(42)	



	  CALL PAUSE
	  STOP



	 ENDIF

	 TIMALL(NSUB,NTIMALL(NSUB)) = TIMEVENT



      IF(IDEVENT .EQ. 4) THEN

C  SEE LOGIC ABOVE FOR TIME RESET LOGIC, AND ADDING LINES TO THE

C  OUTPUT EQUATION VALUES IN THAT CASE.

C  STORE VALUES INTO THE OUPUT ARRAYS (SEE LOGIC ABOVE) WHICH 
C  INDICATE THAT SUBSEQUENT OUTPUT TIMES ARE BASED ON THIS TIME RESET.
C  ... BUT ONLY STORE THESE EXTRA VALUES IF NRESETADD = 0. IF 
C  NRESETADD = 1, IT MEANS THAT THESE LINES HAVE ALREADY BEEN ADDED
C  SINCE THE LAST ACTUAL OUTPUT VALUE WAS PUT INTO ONE OF THE OUTPUT
C  ARRAYS.

       IF(NRESETADD .EQ. 0) THEN
        DO IOUTEQ = 1,MAXNUMEQ
         NTIMOUT(NSUB,IOUTEQ) = NTIMOUT(NSUB,IOUTEQ) + 1
         TIMOUT(NSUB,IOUTEQ,NTIMOUT(NSUB,IOUTEQ)) = TIMEVENT
   	   OUT(NSUB,IOUTEQ,NTIMOUT(NSUB,IOUTEQ)) = -99.D0
        END DO
        NRESETADD = 1
       ENDIF

	 ENDIF


C  THE ABOVE ENDIF IS FOR THE  IF(IDEVENT .EQ. 4)  CONDITION.


	 NTIMBOL(NSUB,IDRUGNO) = NTIMBOL(NSUB,IDRUGNO) + 1
	 TIMBOL(NSUB,IDRUGNO,NTIMBOL(NSUB,IDRUGNO)) = TIMEVENT
	 BOLUS(NSUB,IDRUGNO,NTIMBOL(NSUB,IDRUGNO)) = TOTDOS

	ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(DUR .LE. 0)  CONDITION.


	GO TO 40


C  REPLACE WRITING OF TIMEVENT - TIMERESET WITH XVERIFY (SEE LOGIC IN 
C  SUBROUTINE VERIFYVAL.

   50 XVERIFY(1) = TIMEVENT - TIMERESET
      CALL VERIFYVAL(1,XVERIFY)
C  50 WRITE(*,51) NSUB, TIMEVENT - TIMERESET
      WRITE(*,51) NSUB, XVERIFY(1)

   51 FORMAT(/' THERE IS AN ERROR IN THE BLOCK FORMAT. FOR SUBJECT '/
     1' NO. ',I4,' AND TIME ',F10.4,' A LINE HAS A DOSAGE AMT., BUT NO'/
     2' DURATION (EVEN A BOLUS SHOULD HAVE A DURATION OF 0) IN '/
     3' ENTRY 4., OR NO DRUG NO. IN ENTRY 5.'//
     3' THE PROGRAM STOPS.')
	WRITE(*,401) NSUB,SUBARRAY(NSUB)

        OPEN(42,FILE=ERRFIL)
C        WRITE(42,51) NSUB, TIMEVENT - TIMERESET
         WRITE(42,51) NSUB, XVERIFY(1)
         WRITE(42,401) NSUB,SUBARRAY(NSUB)
        CLOSE(42)
	
	CALL PAUSE
	STOP


   40   CONTINUE


C  READ IN ANY COVARIATE VALUES IF NCOVA .GT. 0.


	IF(NCOVA .GT. 0) THEN

         DO 60 ICOV = 1,NCOVA

	  CALL AFTERCOMMA(NCOVA,READLINE,11+ICOV)

	  BACKSPACE(57)
 	  READ(57,*,ERR=70) COVVAL
	  CLOSE(57)

C  TO GET TO THIS POINT --> COVVAL REPRESENTS THE VALUE OF COV. NO.
C  ICOV. STORE IT AT THE INDICATED TIME, TIMEVENT.

	  NTIMALL(NSUB) = NTIMALL(NSUB) + 1

	 IF(NTIMALL(NSUB) .GT. 24000) THEN



	  WRITE(*,3001) NSUB
	  WRITE(*,401) NSUB,SUBARRAY(NSUB)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,3001) NSUB
         WRITE(42,401) NSUB,SUBARRAY(NSUB)
        CLOSE(42)	



	  CALL PAUSE
	  STOP

	 ENDIF

	 TIMALL(NSUB,NTIMALL(NSUB)) = TIMEVENT



      IF(IDEVENT .EQ. 4) THEN

C  SEE LOGIC ABOVE FOR TIME RESET LOGIC, AND ADDING LINES TO THE
C  OUTPUT EQUATION VALUES IN THAT CASE.

C  STORE VALUES INTO THE OUPUT ARRAYS (TIME = 0 AND VALUE = -99) WHICH 
C  INDICATE THAT SUBSEQUENT OUTPUT TIMES ARE BASED ON THIS TIME RESET.
C  ... BUT ONLY STORE THESE EXTRA VALUES IF NRESETADD = 0. IF 
C  NRESETADD = 1, IT MEANS THAT THESE LINES HAVE ALREADY BEEN ADDED
C  SINCE THE LAST ACTUAL OUTPUT VALUE WAS PUT INTO ONE OF THE OUTPUT
C  ARRAYS.

       IF(NRESETADD .EQ. 0) THEN
        DO IOUTEQ = 1,MAXNUMEQ
         NTIMOUT(NSUB,IOUTEQ) = NTIMOUT(NSUB,IOUTEQ) + 1
         TIMOUT(NSUB,IOUTEQ,NTIMOUT(NSUB,IOUTEQ)) = TIMEVENT
   	   OUT(NSUB,IOUTEQ,NTIMOUT(NSUB,IOUTEQ)) = -99.D0
        END DO
        NRESETADD = 1
       ENDIF

	 ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(IDEVENT .EQ. 4)  CONDITION.

C  SINCE MULTIPLE DOSE LINES CAN OCCUR AT THE SAME TIME (DEFINING
C  DOSES FOR DIFFERENT DRUGS OR IV VS. BOLUS VALUES, IT IS POSSIBLE
C  THAT A COVARIATE VALUE IS BEING RESET AT THE SAME TIME AS IN A

C  PREVIOUS LINE. IF THIS IS TRUE, TELL THE USER THAT THE COVARIATE
C  VALUE FROM THE FIRST LINE WILL BE USED. THIS MUST BE CHECKED ONLY
C  IF THE INDEX OF THE NO. OF COVARIATE VALUES IS > 0 - OTHERWISE
C  THIS IS THE FIRST LINE WITH A COVARIATE VALUE ON IT).

C  BUT, ONLY WRITE THIS WARNING IF THE TWO COVARIATE VALUES ARE
C  ACTUALLY DIFFERENT, BECAUSE IF THEY ARE THE SAME, THERE IS NO
C  CONFLICT, JUST REDUNDANCY.


	  IF(NTIMCOV(NSUB,ICOV) .GT. 0) THEN

	   CALL THESAME(TIMEVENT,TIMCOV(NSUB,ICOV,NTIMCOV(NSUB,ICOV)),
     1                  ISAMETIME)

	   CALL THESAME(COVVAL,COV(NSUB,ICOV,NTIMCOV(NSUB,ICOV)),
     1                  ISAMECOV)



	   IF(ISAMETIME .EQ. 1 .AND. ISAMECOV .EQ. 1) GO TO 60

	   IF(ISAMETIME .EQ. 1 .AND. ISAMECOV .EQ. 0) THEN

C  REPLACE WRITING OF TIMEVENT - TIMERESET, ETC. WITH XVERIFY (SEE 

C  LOGIC IN SUBROUTINE VERIFYVAL.

        XVERIFY(1) = TIMEVENT - TIMERESET
        XVERIFY(2) = COV(NSUB,ICOV,NTIMCOV(NSUB,ICOV))
        XVERIFY(3) = COVVAL
        CALL VERIFYVAL(3,XVERIFY)

C        WRITE(*,41) NSUB,TIMEVENT-TIMERESET,ICOV,
C    1    COV(NSUB,ICOV,NTIMCOV(NSUB,ICOV)),COVVAL
        WRITE(*,41) NSUB,XVERIFY(1),ICOV,XVERIFY(2),XVERIFY(3)
   41   FORMAT(/' FOR SUBJECT, 'I3,' AT TIME ',G14.7,', COVARIATE'/
     1' NO. ',I2,' WAS SET TO BOTH ',G14.7,' AND ',G14.7,'. YOU SHOULD'/
     2' CHECK YOUR BLOCK FILE. FOR NOW, THE FIRST VALUE WILL BE USED.')
    
	    GO TO 60


	   ENDIF

	  ENDIF

	  NTIMCOV(NSUB,ICOV) = NTIMCOV(NSUB,ICOV) + 1


	  TIMCOV(NSUB,ICOV,NTIMCOV(NSUB,ICOV)) = TIMEVENT 
	  COV(NSUB,ICOV,NTIMCOV(NSUB,ICOV)) = COVVAL

	  GO TO 60

   70     CONTINUE

C  TO GET TO LABEL 70 --> THERE WAS NO NUMBER IN THE ENTRY FOR 
C  COVARIATE, ICOV.

   60   CONTINUE



	ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(NCOVA .EQ. 0)  CONDITION.


	ENDIF


C  THE ABOVE ENDIF IS FOR THE  IF(IDEVENT .EQ. 1 .OR. IDEVENT .EQ. 4) 
C  CONDITION.


C  RETURN TO LABEL 10 TO READ THE NEXT LINE IN THE BLOCK PATIENT
C  DATA FILE.


	GO TO 10



  100   NSUB = 1


	IF(NCOVA .GT. 0) THEN

	 WRITE(*,111) NCOVA
  111    FORMAT(/' YOUR BLOCK FORMAT PATIENT INFORMATION FILE SHOWS'/
     1' ',I2,' COVARIATES. EACH COVARIATE MUST BE SPECIFIED TO BE '/
     2' EITHER A PIECEWISE CONSTANT COVARIATE OR AN INTERPOLATED '/
     3' COVARIATE.'//
     4' A PIECEWISE CONSTANT COVARIATE WILL HAVE THE SAME VALUE FROM'/
     5' ONE EXPLICITLY CODED VALUE, THROUGH ALL INTERVEENING DOSE'/
     6' TIMES, TO THE NEXT EXPLICITLY CODED VALUE (WHEN IT WILL CHANGE).
     7 '//
     8' AN INTERPOLATED COVARIATE WILL HAVE INTERPOLATED VALUES FROM'/
     9' ONE EXPLICITY CODED VALUE, THROUGH ALL INTERVEENING DOSE '/
     1' TIMES, TO THE NEXT EXPLCITLY CODED VALUE.'//)


	 DO ICOV = 1,NCOVA


  130	  WRITE(*,112) COVNAME(ICOV)
  112     FORMAT(/' FOR COVARIATE ',A11/
     1'  ENTER 1 IF IT IS TO BE PIECEWISE CONSTANT; '/
     2'  ENTER 2 IF IT IS TO BE INTERPOLATED: ')
	  READ(*,*,ERR=130) ITYPE
	  IF(ITYPE .NE. 1 .AND. ITYPE .NE. 2) GO TO 130
	  ICOVTYPE(ICOV) = ITYPE
	 END DO

	ENDIF


C  THE ABOVE ENDIF IS FOR THE  IF(NCOVA .GT. 0)  CONDITION.


C  WRITE OUT ALL THE INFO IN THE ABOVE ARRAYS INTO A WORKING COPY
C  FORMAT. ACTUALLY, FOR NOW, JUST TRY TO CREATE THE DOSAGE AND
C  OBSERVATION PART OF A FILE SIMILAR TO 2DRUG001 (I.E., DON'T
C  WORRY NOW ABOUT THE TOP PART OF THE FILE, OR THE BOTTOM).

C  FIRST, CALL SUBROUTINE GETCHAR2 TO ESTABLISH THE NUMBER ARRAY.

	DO JSUB = 1,NSUB

	 CALL GETCHAR2(JSUB,CHARSUB)
	 NUMBER(JSUB) = CHARSUB
	END DO

	DO 1000 ISUB = 1,NSUB

C  NOTE THAT THE WORKING COPY SUBJECTS WILL BE PLACED INTO THE 
C  WORKING DIRECTORY. THE PREFIX WILL BE HARDCODED TO 'XQZPJ', AND THE 
C  SUFFIX TO 'ZMQ'.

	 PATFIL = 'XQZPJ'//NUMBER(ISUB)//'.ZMQ'

C  CALL FULLNAME WHICH CONVERTS THE FILENAME TO PATHFILE, THE COMPLETE 

C  NAME OF THE FILE, WHICH INCLUDES THE PATH (IF THE PATH IS NOT THE 
C  CURRENT DIRECTORY).

         TMPFILE = ' '
	 TMPFILE = PATFIL 
	 CALL FULLNAME(PATH,TMPFILE,PATHFILE)

	 OPEN(33,FILE=PATHFILE)


	 IF(NDRUG .GT. 7) THEN

	  WRITE(*,101) NDRUG
  101     FORMAT(/' NO. OF DRUGS IN THIS PATIENT DATA SET IS ',I2/
     1'  THIS IS MORE THAN 7, THE MAXIMUM --> PROGRAM STOPS.'/)
	  WRITE(*,401) ISUB,SUBARRAY(ISUB)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,101) NDRUG
         WRITE(42,401) ISUB,SUBARRAY(ISUB)
        CLOSE(42)	



	  CALL PAUSE
	  STOP



	 ENDIF

	 IF(NOUT .GT. MAXNUMEQ) THEN



        WRITE(*,106) NOUT,MAXNUMEQ
  106   FORMAT(/' NO. OF OUTPUT EQS. THIS PATIENT DATA SET IS ',I2/
     1' THIS IS MORE THAN THE MAX. ALLOWED VALUE OF ',I2,'. SO THE'/
     2' PROGRAM STOPS.'/)
	  WRITE(*,401) ISUB,SUBARRAY(ISUB)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,106) NOUT,MAXNUMEQ
         WRITE(42,401) ISUB,SUBARRAY(ISUB)
        CLOSE(42)
	
	  CALL PAUSE
	  STOP

	 ENDIF

	 IF(NCOVA .GT. 26) THEN



	  WRITE(*,103) NCOVA
  103     FORMAT(/' NO. OF COVARIATES IN THIS PATIENT DATA SET IS ',I3/
     1'  THIS IS MORE THAN 26, THE MAXIMUM --> PROGRAM STOPS.'/)
	  WRITE(*,401) ISUB,SUBARRAY(ISUB)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,103) NCOVA
         WRITE(42,401) ISUB,SUBARRAY(ISUB)
        CLOSE(42)	




	  CALL PAUSE
	  STOP



	 ENDIF


C  BEFORE CALLING WRITEDOS, CALL TIMESET FOR THIS SUBJECT TO 
C  ELIMINATE ALL THE DUPLICATE TIMES IN TIMALL(ISUB,.). THERE COULD BE 
C  DUPLICATE TIMES BECAUSE NTIMALL(ISUB) WAS INCREASED BY 1 FOR EACH 
C  BOLUS, IV, OR COVARIATE VALUE, AND SOME OF THESE VALUES OCCUR AT THE 
C  SAME TIME.  TIMESET ALSO ORDERS THE TIMES AND THEY COULD BE OUT OF 
C  ORDER DUE TO AN IV RATE WHOSE DURATION RESULTS IN THE ENDING TIME 
C  BEING PAST THE NEXT DOSE EVENT. 

C  TIMESET RETURNS THE COMPLETE SET OF TIMES FOR THIS SUBJECT'S DOSAGE 
C  REGIMEN IN TIMI (AND THERE ARE NTIMI OF THEM).

	 CALL TIMESET(MAXSUB,ISUB,SUBARRAY(ISUB),NTIMALL,TIMALL,NTIMI,
     1    TIMI)
	

C  CALL WRITEDOS TO WRITE THE PATIENT INFO TO PATHFILE = FILE 33.

	 CALL WRITEDOS(ISUB,NTIMIV,TIMIV,RATEIV,NTIMBOL,TIMBOL,BOLUS,
     1    NTIMCOV,TIMCOV,COV,ICOVTYPE,NDRUG,NCOVA,NOUT,NTIMOUT,
     2    TIMOUT,OUT,SUBARRAY(ISUB),COVNAME,MAXSUB,NTIMI,TIMI,TIMADD,
     3    CSUB,NSST,DOSELINEST)

 1000   CONTINUE


	RETURN
	END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
	SUBROUTINE AFTERCOMMA(NCOVA,READLINE,NCOMMA)
	CHARACTER READLINE*1000,ERRFIL*20

      COMMON/ERROR/ERRFIL
C  COMMON/ERROR/ IS SUPPLIED TO ALL THE ROUTINES WHICH COULD WRITE TO
C  ERRFIL.

C  OPEN AND WRITE INTO SCRATCH FILE 57 THE PART OF READLINE THAT 
C  IS BETWEEN COMMAS NCOMMA AND NCOMMA+1 ... UNLESS NCOMMA IS THE MAX.
C  NO. OF COMMAS (11+NCOVA). IN THIS CASE, WRITE INTO SCRATCH FILE 57 THE 
C  PART OF READLINE THAT FOLLOWS COMMA NCOMMA (SINCE THERE WILL NOT BE 
C  ANOTHER COMMA).


    1   FORMAT(A1000)

C  IF NCOMMA = 0, SET ISTART = 0 AND GO TO LABEL 10.

	
	IF(NCOMMA .EQ. 0) THEN
	 ISTART = 0
	 GO TO 10
	ENDIF


	ICOMMA = 0

	DO ISTART = 1,300
	 IF(READLINE(ISTART:ISTART) .EQ. ',') THEN
	  ICOMMA = ICOMMA + 1
	  IF(ICOMMA .EQ. NCOMMA) GO TO 10

	 ENDIF
	END DO	    


C  TO GET TO THIS POINT MEANS THAT THE NO. OF COMMAS IN LINE
C  READLINE IS LESS THAN NCOMMA. WRITE A MESSAGE AND STOP.

	WRITE(*,2) NCOMMA,ICOMMA,READLINE
    2   FORMAT(/' THE FOLLOWING LINE WAS SUPPOSED TO HAVE AT LEAST ',I3/
     1' COMMAS, BUT IT HAD ONLY ',I3,' SO THE PROGRAM STOPS.'//


     2A1000)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,2) NCOMMA,ICOMMA,READLINE
        CLOSE(42)
	


	CALL PAUSE
	STOP
	

C  TO REACH LABEL 10, ISTART IS NOW THE COLUMN NO. WHICH HAS THE
C  NCOMMAth COMMA IN LINE READLINE.  FIND IEND, WHICH IS THE COLUMN NO.
C  WHICH HAS THE NCOMMA+1 ST COMMA IN THE LINE. THEN WRITE THE PORTION
C  OF READLINE WHICH IS BETWEEN ISTART AND IEND INTO FILE57.

   10	ICOMMA = 0

	DO IEND = 1,300
	 IF(READLINE(IEND:IEND) .EQ. ',') THEN
	  ICOMMA = ICOMMA + 1
	  IF(ICOMMA .EQ. NCOMMA+1) GO TO 20
	 ENDIF
	END DO	    


C  TO GET TO THIS POINT MEANS THAT THE NO. OF COMMAS IN LINE
C  READLINE IS LESS THAN NCOMMA+1. THIS IS OK IF NCOMMA IS THE MAXIMUM
C  NO. OF COMMAS, WHICH IS 11+NCOVA. OTHERWISE, WRITE A MESSAGE AND 
C  STOP.




	IF(NCOMMA .LT. 11 + NCOVA) THEN

	 WRITE(*,2) NCOMMA+1,ICOMMA,READLINE

        OPEN(42,FILE=ERRFIL)
         WRITE(42,2) NCOMMA+1,ICOMMA,READLINE
        CLOSE(42)
	


	 CALL PAUSE
	 STOP



	ENDIF

	IF(NCOMMA .EQ. 11 + NCOVA) IEND = 301

   20	OPEN(57,STATUS='SCRATCH')

C  SEE CODE AT TOP OF MONTBG100.FOR TO SEE WHY FORMATTED WRITE 
C  STATEMENTS ARE USED (UNLESS NUMCHAR BELOW IS > 11, IN WHICH CASE

C  A FREE FORMAT WRITE STATEMENT IS STILL USED).

        NUMCHAR = IEND - ISTART - 1
	

        IF(NUMCHAR .EQ. 1) WRITE(57,101) READLINE(ISTART+1:IEND-1)
  101   FORMAT(A1)

        IF(NUMCHAR .EQ. 2) WRITE(57,102) READLINE(ISTART+1:IEND-1)
  102   FORMAT(A2)

        IF(NUMCHAR .EQ. 3) WRITE(57,103) READLINE(ISTART+1:IEND-1)
  103   FORMAT(A3)

        IF(NUMCHAR .EQ. 4) WRITE(57,104) READLINE(ISTART+1:IEND-1)
  104   FORMAT(A4)


        IF(NUMCHAR .EQ. 5) WRITE(57,105) READLINE(ISTART+1:IEND-1)
  105   FORMAT(A5)

        IF(NUMCHAR .EQ. 6) WRITE(57,106) READLINE(ISTART+1:IEND-1)
  106   FORMAT(A6)

        IF(NUMCHAR .EQ. 7) WRITE(57,107) READLINE(ISTART+1:IEND-1)

  107   FORMAT(A7)

        IF(NUMCHAR .EQ. 8) WRITE(57,108) READLINE(ISTART+1:IEND-1)
  108   FORMAT(A8)

        IF(NUMCHAR .EQ. 9) WRITE(57,109) READLINE(ISTART+1:IEND-1)
  109   FORMAT(A9)

        IF(NUMCHAR .EQ. 10) WRITE(57,110) READLINE(ISTART+1:IEND-1)
  110   FORMAT(A10)

        IF(NUMCHAR .EQ. 11) WRITE(57,111) READLINE(ISTART+1:IEND-1)
  111   FORMAT(A11)

        IF(NUMCHAR .GT. 11) WRITE(57,*) READLINE(ISTART+1:IEND-1)


	RETURN
	END
C

CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
        SUBROUTINE WRITEDOS(ISUB,NTIMIV,TIMIV,RATEIV,NTIMBOL,TIMBOL,
     1   BOLUS,NTIMCOV,TIMCOV,COV,ICOVTYPE,NDRUG,NCOVA,NOUT,NTIMOUT,
     2   TIMOUT,OUT,SUBID,COVNAME,MAXSUB,NTIMI,TIMI,TIMADD,CSUB,
     3   NSST,DOSELINEST)

         IMPLICIT REAL*8(A-H,O-Z)

         PARAMETER(MAXNUMEQ=7)

      DIMENSION BOLVAL(7),COVVAL(26),XIVVAL(7),DOSELINE(5200,43),
     1 TIMOUT(MAXSUB,MAXNUMEQ,650),TIMIV(MAXSUB,7,5200),
     2 NTIMOUT(MAXSUB,MAXNUMEQ),NTIMIV(MAXSUB,7),RATEIV(MAXSUB,7,5200),
     3 BOLUS(MAXSUB,7,5200),OUT(MAXSUB,MAXNUMEQ,650),
     4 COV(MAXSUB,26,5200),ICOVTYPE(26),TIMBOL(MAXSUB,7,5200),
     5 NTIMBOL(MAXSUB,7),NTIMCOV(MAXSUB,26),TIMCOV(MAXSUB,26,5200),
     6 INDIV(7),INDBOL(7),INDCOV(26),TIMI(24000),TIMORD(3900),
     7 BLOCKOUT(3900,MAXNUMEQ),CSUB(MAXSUB,4,MAXNUMEQ),NSST(MAXSUB),
     8 DOSELINEST(MAXSUB,99,100),DOSELINES(100),XVERIFY(900)

	CHARACTER SUBID*11,COVNAME(26)*11,ERRFIL*20

      COMMON/ERROR/ERRFIL
C  COMMON/ERROR/ IS SUPPLIED TO ALL THE ROUTINES WHICH COULD WRITE TO
C  ERRFIL.

C  THIS ROUTINE WRITES THE DOSE EVENTS AND THE OBSERVATION EVENTS OF 
C  THE PATIENT DATA FILE TO FILE33. NOTE THAT A DOSE EVENT OCCURS 
C  WHENEVER THERE IS A BOLUS APPLIED, AN IV RATE CHANGE, AND/OR A
C  COVARIATE VALUE APPLIED.


C----------------- WRITE THE TOP OF FILE BELOW -------------------------

	WRITE(33,301) SUBID
  301   FORMAT('  LAST AND FIRST NAMES ARE: ',A11)
	WRITE(33,302) SUBID
  302   FORMAT(' CHART NUMBER IS: ',A11//
     1' WARD NO, PATIENT AGE (YEARS), SEX, HEIGHT (INCHES),'/
     2' ETHNICITY FLAG, AND ETHNICITY DESCRIPTION (IF ANY)   FOLLOW ON'/
     3' THE NEXT 6 LINES:'/
     4'-99'/
     5'-99'/
     6'M'/
     7'-99'/
     8'1'/
     9'Ethnicity Description'//
     1' DATE OF FIRST THERAPY IS   1   1   08'/
     2'CCR ML/MIN/    0.00 150.00'/
     3'HOURS    MG     MG/HR    MCG/ML KG       MG/DL    60  .00 ')              


C----------------- WRITE THE TOP OF FILE ABOVE -------------------------


C----------------- WRITE THE DOSE EVENTS BELOW -------------------------

	 WRITE(33,102) NDRUG
  102    FORMAT(/'     ',I1,' ... NO. OF DRUGS')

C  NOTE THAT NCOVA IS THE NO. OF COVARIATES IN THE USER'S BLOCK FORMAT
C  FILE. THIS AUTOMATICALLY BECOMES NADD, THE NO. OF "ADDITIONAL"
C  COVARIATES IN THE WORKING COPY FILE.

	 WRITE(33,104) NCOVA
  104    FORMAT('    ',I2,' ... NO. OF ADDITIONAL COVARIATES')


C  INCREASE THE NO. OF DOSE EVENTS BY THE NO. OF STEADY STATE DOSE LINES
C  THAT WILL BE IN THE FILE (THESE WERE NOT PART OF THE ARRAY EXAMINED
C  BY SUBROUTINE TIMESET).

	WRITE(33,2) NTIMI + NSST(ISUB)
    2   FORMAT('   ',I3,' ... NO. OF DOSE EVENTS'//
     1'    TIME, IV/PO FOR EACH DRUG; ADDITIONAL COVARIATES IF ANY')


C  SET THE IVs FOR EACH DRUG TO 0. EACH DRUG IV VALUE STAYS THE SAME
C  AS ITS PREVIOUS VALUE UNTIL CHANGED. ALSO INITIALIZE EACH BOLUS
C  VALUE TO 0.

	DO IDRUG = 1,NDRUG
	 XIVVAL(IDRUG) = 0.D0
	 BOLVAL(IDRUG) = 0.D0

	END DO

C  SET EACH COVARIATE VALUE TO ITS INITIAL VALUE. IT IS ASSUMED THAT
C  EACH COV. HAS ITS FIRST VALUE SET AT THE FIRST DOSE TIME (T=0).
C  IF THIS IS NOT TRUE, SEE REMARK BELOW WHERE THE COVARIATE VALUES
C  ARE SET FOR EACH TIME.

	DO ICOV = 1,NCOVA
	 COVVAL(ICOV) = COV(ISUB,ICOV,1)
	END DO


C  INITIALIZE THE INDEX OF THE NEXT TIME IN EACH TIME ARRAY TO BE 1.

	DO IDRUG = 1,NDRUG
	 INDIV(IDRUG) = 1
	 INDBOL(IDRUG) = 1
	END DO

	DO ICOV = 1,NCOVA
	 INDCOV(ICOV) = 1
	END DO

C  GO THROUGH ALL THE NTIMI DOSAGE BLOCK TIMES IN TIMI AND ESTABLISH ALL
C  IV, BOLUS, AND COV. VALUES AT EACH TIME AND WRITE THEM TO THE DOSAGE 
C  REGIMEN, BUT NOTE THAT EACH TIME MUST BE REDUCED BY TIMERESET, WHERE
C  TIMERESET = TIMADD*NRESET, WHERE NRESET IS THE NO. OF TIME RESETS 
C  THROUGH THAT TIME (SEE IN READBLOCK2 THAT TIMERESET WAS ADDED TO EACH
C  TIME).

	NRESET = 0
	TIMERESET = TIMADD*NRESET

C  INITIALIZE NSSEVENTS = 1. THIS WILL BE THE INDEX OF THE NEXT STEADY
C  STATE DOSE EVENT (IF ANY) IN THE CURRENT PATIENT'S DATA FILE. THE
C  TOTAL NO. OF SUCH EVENTS IS NSST(ISUB).


      NSSEVENTS = 1

C  AS OF MONT101F, PUT IN A STEADY STATE LINE AS THE FIRST DOSE EVENT
C  IF ONE EXISTS. 

C  DOSELINEST(ISUB,1,100) = NRESET, THE NO. OF DOSE RESETS BEFORE THE
C  1ST STEADY STATE DOSE SET. 

C  IF DOSELINST(ISUB,1,100) = 0, IT MEANS THAT THERE IS A STEADY STATE
C  DOSE SET AT THE TOP OF THE FILE (I.E., BEFORE ANY RESETS). 

C  IF DOSELINEST(ISUB,1,100) IS = -99, IT MEANS THERE ARE NO STEADY 
C  STATE LINES FOR THIS SUBJECT. 

C  IF DOSELINEST(ISUB,1,100) = N > 0, IT MEANS THE FIRST STEADY STATE
C  DOSE SET OCCURS AFTER RESET NO. N.

      CALL THESAME(DOSELINEST(ISUB,1,100),0.D0,ISAME)

      IF(ISAME .EQ. 1) THEN

C  FILL IN THE ENTRIES TO DOSELINE FOR THE STEADY STATE DOSE AT THE
C  TOP OF THE PATIENT'S FILE.


C  THE FIRST ENTRY IN DOSELINST IS TIMEVENT = THE NEGATIVE OF THE
C  INTERDOSE INTERVAL.

	 DOSELINES(1) = DOSELINEST(ISUB,1,1)
	 NENTRY = 1

C  FOR EACH DRUG, THE IV AND TOTAL VALUES ARE ALREADY STORED INTO
C  DOSELINEST(ISUB,1,2*I) AND DOSELINEST(ISUB,1,2*I+1), I=1,NDRUG.

	 DO IDRUG = 1,NDRUG
	  NENTRY = NENTRY+1
        DOSELINES(NENTRY) = DOSELINEST(ISUB,1,2*IDRUG)
	  NENTRY = NENTRY+1
	  DOSELINES(NENTRY) = DOSELINEST(ISUB,1,2*IDRUG+1)

	 END DO

C  FOR EACH COVARIATE, IF ANY, THE VALUES ARE STORED INTO
C  DOSELINEST(ISUB,1,19+ICOV), ICOV = 1,NCOVA.

       IF(NCOVA .GT. 0) THEN
	  DO ICOV = 1,NCOVA
	   NENTRY = NENTRY+1
	   DOSELINES(NENTRY) = DOSELINEST(ISUB,1,19+ICOV)
	  END DO

       ENDIF


C  REPLACE WRITING OF DOSELINES() WITH XVERIFY (SEE LOGIC IN 
C  SUBROUTINE VERIFYVAL.

        DO J = 1,NENTRY
         XVERIFY(J) = DOSELINES(J)
        END DO
        CALL VERIFYVAL(NENTRY,XVERIFY)
C       WRITE(33,1) (DOSELINES(J),J=1,NENTRY)
        WRITE(33,1) (XVERIFY(J),J=1,NENTRY)

       NSSEVENTS = NSSEVENTS + 1


      ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(ISAME .EQ. 1)  CONDITION.


	DO 1000 ITIM = 1,NTIMI

	 TIME = TIMI(ITIM)

C  IF THIS TIME = THE NEXT MULTIPLE OF TIMADD, INCREASE THE NO. OF 
C  RESETS BY 1 AND RECALCULATE TIMERESET, THE CURRENT AMOUNT THAT EACH
C  TIME MUST BE REDUCED BEFORE BEING WRITTEN INTO THE WORKING COPY 
C  FILE.

C  AS OF MONT101F.FOR, THIS TIME COULD BE PAST A TIME RESET POINT. THIS
C  WOULD HAPPEN IF A TIME RESET HAD A STEADY STATE DOSE SET ASSOCIATED
C  WITH IT, WITHOUT A NON STEADY STATE DOSE IMMEDIATELY FOLLOWING IT (IF
C  A NON STEADY STATE DOSE IMMEDIATELY FOLLOWED A STEADY STATE SET, 
C  THEN THERE WILL BE TIMI(.) ENTRY THAT = TIMADD*(NRESET+1)). IN THIS
C  CASE TOO, UPDATE NRESET AND TIMERESET.

C  CALL THESAME HERE TO ESTABLISH THE VALUE FOR ISAMERESET. IT
C  WILL USED BELOW TO SUPPRESS INTERPOLATION OF COVARIATES ACROSS A
C  TIME RESET.


       CALL THESAME(TIME,TIMADD*(NRESET+1),ISAMERESET)   


       IF(TIME .GE. TIMADD*(NRESET+1)) THEN


C  TIME IS AT OR PAST THE NEXT MULTIPLE OF TIMADD (I.E., IT IS A TIME
C  RESET POINT). IN THIS CASE, INCREASE NRESET BY 1 AND RECALCULATE
C  TIMERESET.

	  NRESET = NRESET + 1
	  TIMERESET = TIMADD*NRESET

C  FOR THIS TIME RESET, CHECK TO SEE IF THE FIRST DOSE LINE WILL BE
C  A STEADY STATE DOSE EVENT. THE NO. OF STEADY STATE DOSE EVENTS IN
C  THIS PATIENT'S FILE IS NSST(ISUB), AND THE NO. OF SUCH EVENTS THAT
C  HAVE ALREADY BEEN WRITTEN TO FILE 33 IS NSSEVENTS-1 SO FAR.

        IF(NSSEVENTS .LE. NSST(ISUB)) THEN

C  THE NEXT STEADY STATE DOSE EVENT OCCURS AFTER RESET NO.
C  DOSELINEST(ISUB,NSSEVENTS,100). CHECK TO SEE IF THIS VALUE IS
C  THE SAME AS NRESET. IF SO, THIS RESET STARTS WITH A STEADY STATE
C  LINE.

         XRESET = NRESET

         CALL THESAME(DOSELINEST(ISUB,NSSEVENTS,100),XRESET,ISAME)

         IF(ISAME .EQ. 1) THEN

C  FILL IN THE ENTRIES TO DOSELINE FOR THE STEADY STATE DOSE AT THE
C  BEGINNING OF THIS DOSE RESET.

C  THE FIRST ENTRY IN DOSELINST IS TIMEVENT = THE NEGATIVE OF THE
C  INTERDOSE INTERVAL.

          DOSELINES(1) = DOSELINEST(ISUB,NSSEVENTS,1)
          NENTRY = 1

C  FOR EACH DRUG, THE IV AND TOTAL VALUES ARE ALREADY STORED INTO

C  DOSELINEST(ISUB,NSSEVENTS,2*I) AND DOSELINEST(ISUB,NSSEVENTS,2*I+1),
C  I=1,NDRUG.

          DO IDRUG = 1,NDRUG
           NENTRY = NENTRY+1
           DOSELINES(NENTRY) = DOSELINEST(ISUB,NSSEVENTS,2*IDRUG)
           NENTRY = NENTRY+1
           DOSELINES(NENTRY) = DOSELINEST(ISUB,NSSEVENTS,2*IDRUG+1)
          END DO

C  FOR EACH COVARIATE, IF ANY, THE VALUES ARE STORED INTO
C  DOSELINEST(ISUB,NSSEVENTS,19+ICOV), ICOV = 1,NCOVA.

          IF(NCOVA .GT. 0) THEN
           DO ICOV = 1,NCOVA
            NENTRY = NENTRY+1
            DOSELINES(NENTRY) = DOSELINEST(ISUB,NSSEVENTS,19+ICOV)
           END DO
          ENDIF


C  REPLACE WRITING OF DOSELINES() WITH XVERIFY (SEE LOGIC IN 
C  SUBROUTINE VERIFYVAL.

        DO J = 1,NENTRY
         XVERIFY(J) = DOSELINES(J)
        END DO
        CALL VERIFYVAL(NENTRY,XVERIFY)
C       WRITE(33,1) (DOSELINES(J),J=1,NENTRY)
        WRITE(33,1) (XVERIFY(J),J=1,NENTRY)

          NSSEVENTS = NSSEVENTS + 1

         ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(ISAME .EQ. 1)  CONDITION.


        ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(NSSEVENTS .LE. NSST(ISUB))  CONDITION.


	 ENDIF

C  THE ABOVE ENDIF IS FOR THE IF(TIME .GE. TIMADD*(NRESET+1)) CONDITION.



C  CHECK TO SEE IF ANY BOLUS TIMES = TIME.

	DO IDRUG = 1,NDRUG

C  IF THE CURRENT INDEX FOR THIS BOLUS IS MORE THAN THE NO.
C  OF ENTRIES IN THE CORRESPONDING ARRAY, IT MEANS THAT THERE ARE NO
C  MORE BOLUS VALUES FOR THIS DRUG. IN THAT CASE, SET ITS TIME TO -99.
C  OTHERWISE, SET ITS TIME TO THE NEXT TIME IN THE ARRAY.


	 IF(INDBOL(IDRUG) .GT. NTIMBOL(ISUB,IDRUG)) TIMEB = -99.D0

	 IF(INDBOL(IDRUG) .LE. NTIMBOL(ISUB,IDRUG)) THEN
	  TIMEB = TIMBOL(ISUB,IDRUG,INDBOL(IDRUG))

	 ENDIF


	 CALL THESAME(TIME,TIMEB,ISAME)


C  IF ISAME RETURNS FROM SUBROUTINE THESAME AS 1, THE TIMES ARE THE 
C  "SAME" (I.E., WITHIN 1.D-10). IN THIS CASE, SET THE BOLUS VALUE FOR
C  THIS EVENT TO THE CORRESPONDING VALUE IN BOLUS, AND INCREASE THE 
C  INDEX OF THE NEXT TIME BY 1. IF ISAME RETURNS AS 0, SET THE BOLUS 
C  VALUE = 0.


	  IF(ISAME .EQ. 0) BOLVAL(IDRUG) = 0.D0

	  IF(ISAME .EQ. 1) THEN
	   BOLVAL(IDRUG) = BOLUS(ISUB,IDRUG,INDBOL(IDRUG))
	   INDBOL(IDRUG) = INDBOL(IDRUG) + 1
	  ENDIF


	 END DO


C  CHECK TO SEE IF ANY COVARIATE TIMES = TIME.

	DO ICOV = 1,NCOVA

C  IF THE CURRENT INDEX FOR THIS COVARIATE IS MORE THAN THE NO.
C  OF ENTRIES IN THE CORRESPONDING ARRAY, IT MEANS THAT THERE ARE NO
C  MORE COV VALUES FOR THIS COVARIATE. IN THAT CASE, SET ITS TIME TO 
C  -99. OTHERWISE, SET ITS TIME TO THE NEXT TIME IN THE ARRAY.

	 IF(INDCOV(ICOV) .GT. NTIMCOV(ISUB,ICOV)) TIMEC = -99.D0

	 IF(INDCOV(ICOV) .LE. NTIMCOV(ISUB,ICOV)) THEN
	  TIMEC = TIMCOV(ISUB,ICOV,INDCOV(ICOV))
	 ENDIF

	 CALL THESAME(TIME,TIMEC,ISAME)

	
C  IF ISAME RETURNS FROM SUBROUTINE THESAME AS 1, THE TIMES ARE THE 
C  "SAME" (I.E., WITHIN 1.D-10). IN THIS CASE, SET THE COVARIATE VALUE 
C  FOR THIS EVENT TO THE CORRESPONDING VALUE IN COV, AND INCREASE THE 
C  INDEX OF THE NEXT TIME BY 1. 

	  IF(ISAME .EQ. 1) THEN
	   COVVAL(ICOV) = COV(ISUB,ICOV,INDCOV(ICOV))
	   INDCOV(ICOV) = INDCOV(ICOV) + 1
	  ENDIF



C  IF ISAME RETURNS AS 0, THE COV. VALUE WILL BE THE SAME AS IT WAS 
C  PREVIOUSLY IF ICOVTYPE(ICOV) = 1 OR 0 (I.E., IF THIS IS A PIECEWISE
C  CONTINOUS COVARIATE). IT WILL ALSO BE THE SAME AS IT WAS PREVIOUSLY
C  IF ICOVTYPE(ICOV) = 2 (I.E., FOR A LINEARLY INTERPOLATED COVARIATE)
C  IF TIMEC = -99, OR IF ISAMERESET = 1. HERE IS WHY:

C  TIMEC = -99 --> THERE ARE NO MORE COVARIATE VALUES (SEE ABOVE).
C  IF ISAMERESET = 1, THEN THIS IS A TIME RESET POINT. AND IN THIS CASE,
C  EVEN AN INTERPOLATED COVARIATE VALUE SHOULD BE SET = ITS LAST VALUE 
C  FROM BEFORE THE RESET, SINCE NO INTERPOLATION IS POSSIBLE FOR OUT OF 
C  ORDER TIMES (E.G., (T,COV) = (24,400), FOLLOWED BY (T,COV) = 
C  (20,1000) --> INTERPOLATED VALUE AT 0 WOULD BE: 
C  (0-24)/(20-24) * (1000 - 400) + 400 = 4000, WHICH IS PREPOSTEROUS).


	IF(ISAME .EQ. 0) THEN


C  SET INTERP = 1, WHICH MEANS THAT THIS COVARIATE VALUE SHOULD BE 
C  INTERPOLATED FROM THE TWO SURROUNDING COVARIATE VALUES (WHICH HAVE
C  BEEN EXPLICITLY SPECIFIED IN THE BLOCK FORMAT FILE). CHANGE INTERP
C  TO 0 IF THIS IS NOT AN INTERPOLATED COVARIATE (ICOVTYPE(ICOV) = 1
C  OR 0) OR IF THIS IS AN INTERPOLATED COVARIATE BUT THERE ARE NO MORE
C  COVARIATE VALUES FOR THIS COVARIATE (TIMEC = -99) OR IF THIS IS A
C  TIME RESET VALUE (ISAMERESET = 1), OR IF THE CURRENT COVARIATE TIME

C  (WHICH WOULD BE USED IN THE INTERPOLATION) IS AT OR PAST THE NEXT 
C  TIME RESET.



	 INTERP = 1
	 IF(ICOVTYPE(ICOV) .EQ. 1 .OR. ICOVTYPE(ICOV) .EQ. 0) 
     1    INTERP = 0

	 IF(TIMEC .LE. -99) INTERP = 0
	 IF(ISAMERESET .EQ. 1) INTERP = 0

	 IF(TIMEC .GE. TIMERESET + TIMADD) INTERP = 0


C  IF INTERP = 1:

C  NOTE THAT INDCOV(ICOV) MUST BE .GE. 2 UNLESS THE USER HAS MADE A 
C  MISTAKE SINCE THE FIRST TIME (TIME = 0) IS SUPPOSED TO HAVE ALL 
C  COVARIATE VALUES SPECIFIED, WHICH MEANS THE FIRST TIME THROUGH THIS
C  PART OF THE CODE ABOVE, INDCOV(ICOV) WAS INCREASED BY 1 (FROM ITS
C  ORIGINAL VALUE OF 1). IF THIS IS NOT TRUE, WRITE A MESSAGE TO THE

C  USER AND STOP.



	 IF(INDCOV(ICOV) .EQ. 1) THEN



	  WRITE(*,111) ICOV
  111     FORMAT(/' THERE IS A MISTAKE IN THE BLOCK FORMAT PATIENT'/
     1' DATA FILE. THE FIRST VALUE FOR COVARIATE NO. ',I2,' WAS NOT'/
     2' SPECIFIED AT THE ORIGINAL TIME = 0, AS IS REQUIRED. PLEASE'/
     3' FIX THIS ERROR AND RERUN THE PROGRAM. '//)
	  WRITE(*,401) ISUB,SUBID
  401   FORMAT(/' NOTE: THE ID FOR SUBJECT NO. ',I4,' IS ',A11/)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,111) ICOV
         WRITE(42,401) ISUB,SUBID
        CLOSE(42)	



	  CALL PAUSE
	  STOP



	 ENDIF 


	 CLAST = COV(ISUB,ICOV,INDCOV(ICOV)-1)

	 IF(INTERP .EQ. 0) COVVAL(ICOV) = CLAST

	 IF(INTERP .EQ. 1) THEN

C  NOTE: THE LAST COV. VALUE WAS CLAST WHICH OCCURRED AT TLAST. THE NEXT
C  COV VALUE IS CNEXT WHICH OCCURS AT TNEXT. SO ESTABLISH THE 
C  LINEARLY INTERPOLATED VALUE FOR THIS TIME, TIME. NOTE THAT THE TIMES,
C  TLAST AND TNEXT, MUST BE RECAST AS THEIR ACTUAL TIMES (BY REDUCING
C  THEM BY TIMERESET) FIRST.


	  TLAST = TIMCOV(ISUB,ICOV,INDCOV(ICOV)-1) - TIMERESET
	  CNEXT = COV(ISUB,ICOV,INDCOV(ICOV))
	  TNEXT = TIMCOV(ISUB,ICOV,INDCOV(ICOV)) - TIMERESET
	  TIMEREAL = TIME - TIMERESET
	  COVVAL(ICOV) = (TIMEREAL-TLAST)/(TNEXT-TLAST) * (CNEXT-CLAST)
     1     + CLAST
	 ENDIF	  

	ENDIF


C  THE ABOVE ENDIF IS FOR THE  IF(ISAME .EQ. 0)  CONDITION.



	 END DO


C  THE ABOVE END DO IS FOR THE  DO ICOV = 1,NCOVA  LOOP.



C  CHECK TO SEE IF ANY IV TIMES = TIME.

	DO IDRUG = 1,NDRUG

C  IF THE CURRENT INDEX FOR THIS IV IS MORE THAN THE NO.
C  OF ENTRIES IN THE CORRESPONDING ARRAY, IT MEANS THAT THERE ARE NO
C  MORE IV VALUES FOR THIS DRUG. IN THAT CASE, SET ITS TIME TO -99.
C  OTHERWISE, SET ITS TIME TO THE NEXT TIME IN THE ARRAY.

	 IF(INDIV(IDRUG) .GT. NTIMIV(ISUB,IDRUG)) TIMEI = -99.D0

	 IF(INDIV(IDRUG) .LE. NTIMIV(ISUB,IDRUG)) THEN

	  TIMEI = TIMIV(ISUB,IDRUG,INDIV(IDRUG))
	 ENDIF

	 CALL THESAME(TIME,TIMEI,ISAME)

C  IF ISAME RETURNS FROM SUBROUTINE THESAME AS 1, THE TIMES ARE THE 
C  "SAME" (I.E., WITHIN 1.D-10). IN THIS CASE, SET THE IV VALUE FOR
C  THIS EVENT TO THE CORRESPONDING VALUE IN RATEIV, AND INCREASE THE 
C  INDEX OF THE NEXT TIME BY 1. IF ISAME RETURNS AS 0, THE IV VALUE
C  WILL REMAIN WHAT IT WAS PREVIOUSLY.

	  IF(ISAME .EQ. 1) THEN
	   XIVVAL(IDRUG) = RATEIV(ISUB,IDRUG,INDIV(IDRUG))
	   INDIV(IDRUG) = INDIV(IDRUG) + 1
	  ENDIF

	 END DO


C  PUT THE ACTUAL TIME (I.E., TIME - TIMERESET) INTO THE 1ST ENTRY FOR
C  THIS ROW. THEN PUT IN THE IV/BOLUS VALUES FOR EACH OF THE NDRUG DRUGS
C  IN ORDER; THEN ALL ADDITIONAL COV. VALUES.

	 DOSELINE(ITIM,1) = TIME - TIMERESET
	 NENTRY = 1


	 DO IDRUG = 1,NDRUG
	  NENTRY = NENTRY+1
	  DOSELINE(ITIM,NENTRY) = XIVVAL(IDRUG)
	  NENTRY = NENTRY+1
	  DOSELINE(ITIM,NENTRY) = BOLVAL(IDRUG)
	 END DO

	 DO ICOV = 1,NCOVA
	  NENTRY = NENTRY+1
	  DOSELINE(ITIM,NENTRY) = COVVAL(ICOV) 
	 END DO

C  REPLACE WRITING OF DOSELINES() WITH XVERIFY (SEE LOGIC IN 
C  SUBROUTINE VERIFYVAL.

        DO J = 1,NENTRY
         XVERIFY(J) = DOSELINE(ITIM,J)
        END DO
        CALL VERIFYVAL(NENTRY,XVERIFY)
C       WRITE(33,1) (DOSELINE(ITIM,J),J=1,NENTRY)
        WRITE(33,1) (XVERIFY(J),J=1,NENTRY)
    1   FORMAT(43(G19.9,1X))



 1000   CONTINUE

C  THE ABOVE LABEL IS THE END OF THE  DO 1000 ITIM = 1,NTIMI  LOOP.


C  NOW CHECK TO SEE IF THE DOSAGE REGIMEN ENDS WITH ONE OR MORE STEADY

C  STATE EVENTS. NOTE THAT THERE ARE NSST(ISUB) STEADY STATE EVENTS,
C  AND NSSEVENTS - 1 OF THESE HAVE BEEN WRITTEN TO THE WORKING COPY FILE
C  SO FAR. 

 1010   CONTINUE

        IF(NSSEVENTS .LE. NSST(ISUB)) THEN


C  THE NEXT STEADY STATE DOSE EVENT OCCURS AFTER RESET NO.
C  DOSELINEST(ISUB,NSSEVENTS,100). 

C  FILL IN THE ENTRIES TO DOSELINE FOR THE STEADY STATE DOSE AT THE
C  BEGINNING OF THIS DOSE RESET.

C  THE FIRST ENTRY IN DOSELINST IS TIMEVENT = THE NEGATIVE OF THE
C  INTERDOSE INTERVAL.

          DOSELINES(1) = DOSELINEST(ISUB,NSSEVENTS,1)
          NENTRY = 1

C  FOR EACH DRUG, THE IV AND TOTAL VALUES ARE ALREADY STORED INTO
C  DOSELINEST(ISUB,NSSEVENTS,2*I) AND DOSELINEST(ISUB,NSSEVENTS,2*I+1),

C  I=1,NDRUG.

          DO IDRUG = 1,NDRUG
           NENTRY = NENTRY+1
           DOSELINES(NENTRY) = DOSELINEST(ISUB,NSSEVENTS,2*IDRUG)

           NENTRY = NENTRY+1
           DOSELINES(NENTRY) = DOSELINEST(ISUB,NSSEVENTS,2*IDRUG+1)

          END DO

C  FOR EACH COVARIATE, IF ANY, THE VALUES ARE STORED INTO
C  DOSELINEST(ISUB,NSSEVENTS,19+ICOV), ICOV = 1,NCOVA.

          IF(NCOVA .GT. 0) THEN
           DO ICOV = 1,NCOVA
            NENTRY = NENTRY+1
            DOSELINES(NENTRY) = DOSELINEST(ISUB,NSSEVENTS,19+ICOV)
           END DO
          ENDIF

C  REPLACE WRITING OF DOSELINES() WITH XVERIFY (SEE LOGIC IN 
C  SUBROUTINE VERIFYVAL.

        DO J = 1,NENTRY
         XVERIFY(J) = DOSELINES(J)
        END DO
        CALL VERIFYVAL(NENTRY,XVERIFY)
C       WRITE(33,1) (DOSELINES(J),J=1,NENTRY)
        WRITE(33,1) (XVERIFY(J),J=1,NENTRY)

          NSSEVENTS = NSSEVENTS + 1
 
          GO TO 1010

        ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(NSSEVENTS .LE. NSST(ISUB))  CONDITION.




C----------------- WRITE THE DOSE EVENTS ABOVE -------------------------



C----------------- WRITE THE OBSERVATION EVENTS BELOW ------------------


	WRITE(33,106) NOUT
  106   FORMAT(/'     ',I1,' ... NO. OF TOTAL OUTPUT EQUATIONS')


C  EACH SET OF TIMES FOR EACH OUTPUT EQUATION, TIMOUT(ISUB,IOUT,I),
C  I = 1,NTIMOUT(ISUB,IOUT), IS IN ORDER, BUT EACH TIME HAS ADDED
C  TO IT TIMADD*NRESET, WHERE NRESET IS THE NO. OF TIME RESETS UP TO
C  AND TIME. 

C  CALL FIXOUTIM TO OBTAIN NTIMORD, TIMORD, AND BLOCKOUT, WHERE
C  NTIMORD IS THE TOTAL NO. OF UNIQUE TIMES TO BE PUT INTO THE 
C  OBSERVATION BLOCK; TIMORD(.) IS THE ORDERED ACTUAL TIMES (I.E., EACH
C  OF THE TIMES IN TIMOUT(.,.,.) HAS BEEN REDUCED BY TIMADD*NRESET - SEE
C  ABOVE), EXCEPT THAT EACH TIME OF 0 IS NOT ORDERED (IT INDICATES THE 
C  NEXT TIME RESET) FOR THE OBSERVATION BLOCK; AND BLOCKOUT IS THE 
C  CORRESPONDING ARRAY OF OBSERVED VALUES FOR THE NOUT OUTPUT EQUATIONS 
C  AT THE TIMES IN TIMORD.



	CALL FIXOUTIM(MAXSUB,ISUB,SUBID,NOUT,NTIMOUT,TIMOUT,OUT,NTIMORD,
     1   TIMORD,BLOCKOUT,TIMADD)


      	WRITE(33,62) NTIMORD
   62   FORMAT('  ',I4,' ... NO. OF OBSERVED VALUE TIMES')

C  REPLACE WRITING OF TIMORD(), BLOCKOUT() WITH XVERIFY (SEE LOGIC IN 
C  SUBROUTINE VERIFYVAL).


       DO I = 1,NTIMORD
        XVERIFY(1) = TIMORD(I)
        DO J = 1,NOUT
         XVERIFY(1+J) = BLOCKOUT(I,J)
        END DO
        CALL VERIFYVAL(1+NOUT,XVERIFY)      
C       WRITE(33,63) TIMORD(I),(BLOCKOUT(I,J),J=1,NOUT)

        WRITE(33,63) (XVERIFY(IXV),IXV=1,1+NOUT)
   63   FORMAT(7(G16.8,1X))
       END DO


C----------------- WRITE THE OBSERVATION EVENTS ABOVE ------------------


C----------------- WRITE THE BOTTOM OF FILE BELOW ----------------------

	WRITE(33,303)
  303   FORMAT(/' COVARIATE NAMES AND VALUES (1ST, LAST, AND MEAN) FOLLO

     1W:')

C  FOR NOW, THE MEAN VALUE OF EACH COV. WILL BE -99 ... UNTIL WE DECIDE
C  WHAT KIND OF MEAN WE WANT. E.G., IF A COV. = 100 AT T=0 AND
C  200 AT T = 10 AND 300 AT T = 11, WHICH IS THE LAST TIME, DO WE
C  SIMPLY AVERAGE 100,200, AND 300, OR DO WE TAKE A WEIGHTED MEAN
C  WHICH WOULD BE (100*10 + 200*1 + 300*0)/11, OR SOMETHING ELSE???

C  REPLACE WRITING OF COV(),XMEAN WITH XVERIFY (SEE LOGIC IN 
C  SUBROUTINE VERIFYVAL

      XMEAN = -99
      DO ICOV = 1,NCOVA
       XVERIFY(1) = COV(ISUB,ICOV,1)
       XVERIFY(2) = COV(ISUB,ICOV,NTIMCOV(ISUB,ICOV))
       XVERIFY(3) = XMEAN
       CALL VERIFYVAL(3,XVERIFY)
C      WRITE(33,304) COVNAME(ICOV),COV(ISUB,ICOV,1),
C    1  COV(ISUB,ICOV,NTIMCOV(ISUB,ICOV)),XMEAN
       WRITE(33,304) COVNAME(ICOV),(XVERIFY(I),I=1,3) 
      END DO
  304 FORMAT(A11,3X,3(F15.5,1X))


	WRITE(33,306)
  306   FORMAT(/'ASSAY COEFFICIENTS FOLLOW, ONE SET FOR EACH OUTPUT EQUA
     1TION:')

C  REPLACE WRITING OF CSUB() WITH XVERIFY (SEE LOGIC IN 
C  SUBROUTINE VERIFYVAL.

        DO K = 1,NOUT
         DO I=1,4
          XVERIFY(I) = CSUB(ISUB,I,K)
         END DO
         CALL VERIFYVAL(4,XVERIFY)
C        WRITE(33,3061) (CSUB(ISUB,I,K),I=1,4)
         WRITE(33,3061) (XVERIFY(I),I=1,4)
        END DO

 3061   FORMAT(4(F17.8,1X))


C----------------- WRITE THE BOTTOM OF FILE ABOVE ----------------------


	CLOSE(33)

	RETURN 
	END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
	SUBROUTINE THESAME(X1,X2,ISAME)
	IMPLICIT REAL*8(A-H,O-Z)


C  THIS ROUTINE CHECKS TO SEE IF X1 AND X2 ARE VIRTUALLY THE SAME 
C  VALUES (I.E., IF THEY ARE WITHIN 1.D-10 OF EACH OTHER). IF SO,
C  ISAME RETURNS AS 1; IF NOT ISAME RETURNS AS 0.

	ISAME = 0
	XDEL = DABS(X1-X2)
	IF(XDEL .LE. 1.D-10) ISAME = 1
	
	RETURN
	END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
	SUBROUTINE GETID(SUBID)
	CHARACTER SUBID*11,SUB*11

C  THIS ROUTINE IS CALLED TO REPLACE SUBID (WHICH HAS 11 CHARACTERS IN
C  IT) WITH THE CHARACTERS UP TO BUT NOT INCLUDING THE 1ST COMMA.


	SUB = '           '
	DO I = 1,11
	 IF(SUBID(I:I) .NE. ',') SUB(I:I) = SUBID(I:I)	 
	 IF(SUBID(I:I) .EQ. ',') GO TO 10
	END DO


   10   SUBID = SUB
		
	RETURN
	END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
	SUBROUTINE TIMESET(MAXSUB,ISUB,SUBID,NTIMALL,TIMALL,NTIMI,
     1    TIMI)

      IMPLICIT REAL*8(A-H,O-Z)
      DIMENSION TIMALL(MAXSUB,24000),NTIMALL(MAXSUB),TIMI(24000),
     1   TIM(24000)
	CHARACTER SUBID*11


C  THIS ROUTINE IS CALLED BY READBLOCK2, TO ORDER ALL THE NTIMALL(ISUB) 
C  TIMES IN TIMALL(ISUB,.), ELIMINATING DUPLICATE TIMES.

C  RETURNED TO READBLOCK2 IS THE VECTOR TIMI, WITH NTIMI TIMES, 
C  ESTABLISHED AS INDICATED ABOVE.


C  THE FIRST TIME IS TIMALL(ISUB,1) AND SHOULD BE 0. CHECK THIS FIRST.

	CALL THESAME(TIMALL(ISUB,1),0.D0,ISAME)

C  IF ISAME RETURNS FROM SUBROUTINE THESAME AS 1, THE TIMES ARE THE 
C  "SAME" (I.E., WITHIN 1.D-10). OTHERWISE, THE TIMES ARE NOT THE 
C  SAME AND ISAME = 0.


C  STARTING WITH MONT101F.FOR, DO NOT CHECK THAT THE FIRST DOSE TIME IN
C  EACH PATIENT IS 0, SINCE THE FIRST TIME MAY BE NEGATIVE (WHICH 

C  SIGNIFIES THE DOSAGE REGIMEN BEGINS WITH A STEADY STATE OF DOSES).



C	IF(ISAME .EQ. 0) THEN
C	 WRITE(*,1) ISUB,TIMALL(ISUB,1)
C    1    FORMAT(/' THE FIRST TIME IN THE DOSAGE BLOCK FOR SUBJECT ',I5,
C     1' IS NOT 0; IT IS ',G14.5//
C     2' THIS IS NOT ALLOWED. PLEASE SET THE FIRST TIME IN THE DOSAGE'/
C     3' BLOCKS FOR ALL SUBJECTS TO BE 0, AND RERUN THE PROGRAM.')
C	 WRITE(*,401) ISUB,SUBID
C  401    FORMAT(/' NOTE: THE ID FOR SUBJECT NO. ',I4,' IS ',A11/)
C	 CALL PAUSE
C	 STOP
C	ENDIF





C  CALL SUBROUTINE PUTORDER TO ORDER THE NTIMALL(ISUB) VALUES IN 
C  TIMALL(ISUB,.).

	DO I = 1,NTIMALL(ISUB)
	 TIM(I) = TIMALL(ISUB,I)
	END DO

	CALL PUTORDER(NTIMALL(ISUB),TIM)



C  THE NTIMALL(ISUB) VALUES ARE NOW ORDERED IN TIM.


C  THE CODE BELOW BELOW WILL REMOVE DUPLICATE TIMES.

	TIMELAST = -1.D39

	NTIMI = 0

	DO I = 1,NTIMALL(ISUB)

	 TIME = TIM(I)
	 CALL THESAME(TIME,TIMELAST,ISAME)

C  IF ISAME RETURNS FROM SUBROUTINE THESAME AS 1, TIME = TIMELAST (OR AT
C  LEAST, THEY ARE WITHIN 1.D-10), AND THIS TIME CAN BE IGNORED SINCE IT
C  WAS ALREADY PUT INTO TIMI (ACTUALLY THE VALUE REDUCED BY TIMERESET)
C  BY A PREVIOUS TIME.

	 IF(ISAME .EQ. 1) GO TO 30

C  TO GET HERE, ISAME = 0, WHICH MEANS THIS IS A NEW TIME. SO PUT
C  TIME INTO TIMI. THEN SET TIMELAST = TIME AND CONTINUE THE LOOP.


	  NTIMI = NTIMI + 1
	  TIMI(NTIMI) = TIME
	  TIMELAST = TIME



   30    CONTINUE


	END DO


	RETURN
	END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
	SUBROUTINE PUTORDER(NX,XX)

C  SUBROUTINE PUTORDER IS CALLED BY SUBROUTINE TIMESET. IT INPUTS XX, A
C  VECTOR OF SIZE, NX, AND RETURNS RETURNS XX, BUT WITH THE VALUES 
C  ORDERED FROM LOW TO HIGH.

      IMPLICIT REAL*8(A-H,O-Z)
      DIMENSION XX(24000),Y(24000),IZ(24000),IZZ(24000)

C  ORDER THE NX VALUES IN X AS FOLLOWS:

C  PUT THE NX VALUES INTO VECTOR Y TO START.
C  INITIALIZE VECTOR IZ TO BE -99 IN ALL ITS NX LOCATIONS. THEN, FOR
C  EXAMPLE, IF ENTRY 17 IS THE SMALLEST VALUE IN Y, IZ(17) WILL BE 
C  SET = 0, AND THE PROGRAM WILL KNOW NOT TO CHECK THE 17TH ENTRY 
C  AGAIN (SINCE IT HAS ALREADY BEEN SELECTED). IF THE NEXT SMALLEST 
C  ENTRY HAS INDEX 37, THEN IZ(37) WILL BE SET = 0, ETC. 

C  NOTE THAT IZZ WILL BE THE ARRAY WHICH CONTAINS THE ACTUAL ORDERING.
C  IN THE EXAMPLE ABOVE, IZZ(1) = 17, IZZ(2) = 37. IT WILL BE EASY TO 
C  ASSIGN ORDERED VALUES BACK INTO XX USING IZZ. IN THE EXAMPLE ABOVE, 
C  XX(1) = Y(IZZ(1)) = Y(17), XX(2) = Y(IZZ(2)) = Y(37), ETC.

	 DO I=1,NX
	  Y(I) = XX(I)

	  IZ(I) = -99
	 END DO


	 DO IPLACE = 1,NX

C  PUT THE NEXT LOWEST VALUE OF Y INTO THE IPLACE LOCATION OF
C  IZZ.

C  TEMP IS THE RUNNING VALUE OF THE NEXT VALUE TO BE PLACED INTO Y.
C  INITIALIZE IT TO BE VERY HIGH VALUE SO THE FIRST VALUE Y WILL BE 

C  SURE TO BE LOWER THAN IT IS.

	  TEMP = 1.D50

	  DO I=1,NX

	   IF(Y(I) .LT. TEMP .AND. IZ(I) .EQ. -99) THEN
	    TEMP = Y(I)

	    IND = I
	   ENDIF
	  END DO

C  AT THIS POINT, IND IS THE INDEX OF THE SMALLEST REMAINING VALUE
C  (TEMP) IN Y. PUT THIS INFORMATION INTO IZZ. ALSO,

C  SET IZ(IND) = 0 --> THE IND LOCATION IN Y HAS BEEN USED.

	  IZZ(IPLACE) = IND
	  IZ(IND) = 0

	 END DO	

C  AT THIS POINT IZZ CONTAINS THE ORDERED INDICES (LOW TO HIGH) OF Y.
C  USE THIS TO RE-ESTABLISH X TO BE ORDERED LOW TO HIGH.
	
	 DO I = 1,NX

	  XX(I) = Y(IZZ(I))
	 END DO

	
	RETURN
	END

C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
	SUBROUTINE FIXOUTIM(MAXSUB,ISUB,SUBID,NOUT,NTIMOUT,TIMOUT,OUT,
     1   NTIMORD,TIMORD,BLOCKOUT,TIMADD)

	IMPLICIT REAL*8(A-H,O-Z)

	PARAMETER(MAXNUMEQ=7)

      DIMENSION TIMOUT(MAXSUB,MAXNUMEQ,650),NTIMOUT(MAXSUB,MAXNUMEQ),
     1 IENTRY(MAXNUMEQ),OUT(MAXSUB,MAXNUMEQ,650),TIMORD(3900),
     2 BLOCKOUT(3900,MAXNUMEQ)

	CHARACTER SUBID*11,ERRFIL*20



      COMMON/ERROR/ERRFIL
C  COMMON/ERROR/ IS SUPPLIED TO ALL THE ROUTINES WHICH COULD WRITE TO
C  ERRFIL.

C  FIXOUTIM IS CALLED BY WRITEDOS TO ORDER THE OUTPUT TIMES AMONG ALL 
C  THE NOUT OUTPUT EQUATIONS. NOTE THAT EACH OF THE TIMES CURRENTLY IN
C  TIMOUT HAS BEEN INCREASE BY TIMERESET = TIMADD*NRESET, WHERE NRESET
C  IS THE NO. OF TIME RESETS UP TO AND INCLUDING THAT TIME (THIS WAS 
C  DONE IN SUBROUTINE READBLOCK2).


C  RETURNED TO SUBROUTINE WRITEDOS ARE:

C  NTIMORD = NO. OF TIME VALUES IN TIMORD.

C  TIMORD(I), I=1,NTIMORD = THE ORDERED SET OF TIMES (EXCEPT FOR 0'S
C   WHICH INDICATE A TIME RESET) OVER ALL THE NOUT TIME ARRAYS.


C  BLOCKOUT(I,J) = OBSERVED VALUE FOR IOUTPUT EQUATION J, FOR THE TIME
C   VALUE, TIMORD(I), I=1,NEXT; J = I,NOUT.


C  NOTE THAT EACH OF THE TIME ARRAYS, TIMOUT(ISUB,IOUT,.) HAS ITS OWN
C  VALUES IN ORDER (THEY WERE FILLED IN ORDER IN READBLOCK2). NOW, 
C  ESTABLISH THE ARRAY, TIMORD, WHICH HAS THE ORDERED SET OF
C  TIMES OVER ALL THE NOUT TIME ARRAYS. ALSO, REDUCE EACH TIME BY 
C  TIMRESET = NRESET*TIMADD TO RETURN EACH TIME TO ITS ORIGINAL VALUE. 
C  NOTE THAT THIS WILL HAVE THE EFFECT OF SETTING TO 0 THE TIMES WHICH 
C  ARE THE TIME RESET POINTS (THEIR ACCOMPANYING OUTPUT VALUES WILL
C  OF COURSE BE SET TO -99).

C  INITIALIZE THE NEXT TIME TO BE PUT INTO TIMORD TO BE A LARGE NO.
C  AND INITIALIZE THE INDEX OF THE NEXT ENTRY IN EACH OF THE TIMOUT
C  ARRAYS TO BE 1. ALSO INITIALIZE INEXT TO BE 1. IT WILL BE THE 
C  RUNNING INDEX OF THE NEXT ENTRY TO BE PUT INTO TIMORD.



	DO IOUT = 1,NOUT

	 IENTRY(IOUT) = 1
	END DO

	INEXT = 1

   20	TIMENEXT = 1.D50

C  SET IANOTHER = 0. IF IT STAYS 0, THERE ARE NO MORE TIMES IN
C  ANY OF THE ARRAYS.

	 IANOTHER = 0


        DO IOUT	= 1,NOUT

C  FOR OUTPUT EQUATION IOUT, IF IENTRY(IOUT) .LE. THE NO. OF ENTRIES
C  IN THE TIME ARRAY FOR IOUT, THEN THIS ENTRY IS EQUATION IOUT'S
C  CANDIDATE FOR THE NEXT LOWEST TIME.

	 IF(IENTRY(IOUT) .LE. NTIMOUT(ISUB,IOUT)) THEN
	  IANOTHER = 1
	  IF(TIMOUT(ISUB,IOUT,IENTRY(IOUT)) .LE. TIMENEXT) 
     1     TIMENEXT = TIMOUT(ISUB,IOUT,IENTRY(IOUT))
	 ENDIF

	END DO

C  IF IANOTHER = 0, ALL TIME ARRAY, AND CORRESPONDING OBSERVED, VALUES 
C  HAVE BEEN STORED, SO GO TO 100 TO RECAST TIMORD BEFORE RETURNING.

	IF(IANOTHER .EQ. 0) GO TO 100


C  AT THIS POINT, TIMENEXT IS THE NEXT LOWEST TIME OVER ALL THE NOUT
C  TIMOUT ARRAYS. PUT IT INTO TIMORD, AND PUT THE CORRESPONDING ENTRIES
C  FOR EACH OF THE NOUT OUTPUT EQUATIONS INTO THE ARRAY BLOCKOUT. ALSO,
C  INCREASE THE ENTRY NO. FOR THE TIME ARRAY(S) WHICH HAD THIS TIME. 
C  BUT CHECK THAT THE NO. OF ENTRIES INTO TIMORD IS NOT > THE MAX, 3900. 
C  IF IT IS, STOP.


	IF(INEXT .GT. 3900) THEN



	 WRITE(*,1)
    1    FORMAT(/' THE TOTAL NO. OF OBSERVATION TIMES IS GREATER THAN'/
     1' THE MAXIMUM ALLOWABLE VALUE OF 3900 (SUBROUTINE FIXOUTIM).'/
     2' RERUN THE PROGRAM AFTER REDUCING THE NO. OF OBS. TIMES.'/)
	 WRITE(*,401) ISUB,SUBID
  401    FORMAT(/' NOTE: THE ID FOR SUBJECT NO. ',I4,' IS ',A11/)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,1) 
         WRITE(42,401) ISUB,SUBID
        CLOSE(42)
	


	 CALL PAUSE
	 STOP



	ENDIF

	TIMORD(INEXT) = TIMENEXT


        DO IOUT	= 1,NOUT

	  BLOCKOUT(INEXT,IOUT) = -99.D0
	  CALL THESAME(TIMENEXT,TIMOUT(ISUB,IOUT,IENTRY(IOUT)),ISAME)

	  IF(ISAME .EQ. 1) THEN
	   BLOCKOUT(INEXT,IOUT) = OUT(ISUB,IOUT,IENTRY(IOUT))
	   IENTRY(IOUT) = IENTRY(IOUT) + 1
	  ENDIF

	END DO


	INEXT = INEXT + 1	

	GO TO 20
 

  100   NTIMORD = INEXT - 1


C  NOW, RECAST TIMORD TO BE THE CORRECT TIME VALUES. RECALL THAT,
C  CURRENTLY, EACH TIME HAS NRESET*TIMADD ADDED TO ITS VALUE WHERE 
C  NRESET IS THE NO. OF TIME RESET 0'S UP TO AND INCLUDING THAT TIME 
C  VALUE.

C  INITIALIZE NRESET = 0. THIS IS THE RUNNING NUMBER OF TIME RESETS 
C  THAT HAVE OCCURED. ALSO INITIALIZE TIMERESET AS THE CURRENT AMOUNT 
C  OF TIME TO SUBTRACT TO DO THE RECASTING.

	NRESET = 0

	TIMERESET = TIMADD*NRESET

	DO I = 1,NTIMORD
	 CALL THESAME(TIMORD(I),TIMADD*(NRESET+1),ISAME)	 	
	 


	 IF(ISAME .EQ. 1) THEN
	  NRESET = NRESET + 1
	  TIMERESET = TIMADD*NRESET
	 ENDIF

	 TIMORD(I) = TIMORD(I) - TIMERESET
	END DO


	RETURN


	END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
	SUBROUTINE GETMAXTIM(NCOVA,TIMAX)

	IMPLICIT REAL*8(A-H,O-Z)

	CHARACTER READLINE*1000

C  THIS SUBROUTINE IS CALLED BY READBLOCK2 TO GET TIMAX, THE MAXIMUM TIME 
C  OVER ALL SUBJECTS IN FILE 67. THIS MAXIMUM TIME INCLUDES THE ENDING
C  TIME FOR ALL IV RATES.

C  GO THROUGH ALL THE ROWS OF THE BLOCK FORMAT FILE. READ THE EVENT 
C  TIMES IN ENTRY 3. IF THE ROW IS AN IV ROW, ADD THIS VALUE TO THE 
C  DURATION TIME IN ENTRY 4. THEN UPDATE TIMAX IF THIS TOTAL TIME IS
C  > TIMAX, WHICH IS INITIALIZED BELOW TO BE NEGATIVE.


	TIMAX = -1.D0


   10   READ(66,1,IOSTAT=IEND) READLINE
    1   FORMAT(A1000)

	IF(IEND .LT. 0) RETURN
	IF(READLINE(1:1) .EQ. '#' .OR. READLINE(1:2) .EQ. '"#') GO TO 10

	 CALL AFTERCOMMA(NCOVA,READLINE,2)
	 BACKSPACE(57)
	 READ(57,*) TIMEVENT
	 CLOSE(57)



	 CALL AFTERCOMMA(NCOVA,READLINE,3)
	 BACKSPACE(57)
	 READ(57,*,ERR=15) TIMDUR
	 GO TO 20	 	
   15    TIMDUR = 0.D0
   20    TIME = TIMEVENT + TIMDUR
	 CLOSE(57)

	 IF(TIMAX .LT. TIME) TIMAX = TIME
	 GO TO 10


	END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
	SUBROUTINE GETCHAR2(JSUB,CHARSUB)
	CHARACTER CHARSUB*3
	CHARACTER*1 B,C,D


C  THIS ROUTINE, CALLED BY READBLOCK2, INPUTS THE INTEGER JSUB
C  (BETWEEN 1 AND 999), AND OUTPUTS THE 3-CHARACTER EQUIVALENT, CHARSUB.

	ILEFT = JSUB
	I3 = ILEFT/100
	ILEFT = ILEFT - I3*100
	I2 = ILEFT/10
 	ILEFT = ILEFT - I2*10
	I1 = ILEFT

C  CONVERT THIS TO THE CHARACTER EQUIVALENT. 

	IF(I3 .EQ. 1) B='1'
	IF(I3 .EQ. 2) B='2'
	IF(I3 .EQ. 3) B='3'
	IF(I3 .EQ. 4) B='4'
	IF(I3 .EQ. 5) B='5'
	IF(I3 .EQ. 6) B='6'
	IF(I3 .EQ. 7) B='7'
	IF(I3 .EQ. 8) B='8'


	IF(I3 .EQ. 9) B='9'
	IF(I3 .EQ. 0) B='0'

	IF(I2 .EQ. 1) C='1'
	IF(I2 .EQ. 2) C='2'
	IF(I2 .EQ. 3) C='3'
	IF(I2 .EQ. 4) C='4'
	IF(I2 .EQ. 5) C='5'
	IF(I2 .EQ. 6) C='6'
	IF(I2 .EQ. 7) C='7'


	IF(I2 .EQ. 8) C='8'
	IF(I2 .EQ. 9) C='9'
	IF(I2 .EQ. 0) C='0'

	IF(I1 .EQ. 1) D='1'
	IF(I1 .EQ. 2) D='2'
	IF(I1 .EQ. 3) D='3'
	IF(I1 .EQ. 4) D='4'
	IF(I1 .EQ. 5) D='5'
	IF(I1 .EQ. 6) D='6'
	IF(I1 .EQ. 7) D='7'
	IF(I1 .EQ. 8) D='8'
	IF(I1 .EQ. 9) D='9'
	IF(I1 .EQ. 0) D='0'


	CHARSUB = B//C//D

	RETURN

	END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
        SUBROUTINE PAUSE


C  THIS ROUTINE IS USED TO REPLACE A PAUSE STATEMENT, WHICH CAUSES 
C  WARNINGS WHEN THIS PROGRAM IS COMPILED AND LINKED USING gfortran
C  (AND FORCES THE USER TO TYPE "go" INSTEAD OF SIMPLY HITTING THE
C  ENTER KEY).

        WRITE(*,1)
    1   FORMAT(' HIT ANY KEY TO CONTINUE: ')
        READ(*,*,ERR=10) IKEY
        IF(IKEY .EQ. 1) RETURN
   10   RETURN
        END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
        SUBROUTINE NEWCSV


C  NEWCSV IS CALLED BY MAIN TO CONVERT THE .CSV FILE IN FILE 77 TO
C  A NEW .CSV FILE IN FILE 67, WITH ALL MISSING VALUE DOTS CHANGED TO
C  n's. THIS CODE IS BASED ON THE STAND-A-LONE PROGRAM NEWCSV.FOR.

C  IN PARTICULAR, THE FOLLOWING SEQUENCES WILL BE REPLACED AS SHOWN:

C   ,.,  WILL BE REPLACED BY  ,n,
C   ,.   WILL BE REPLACED BY  ,n  <-- THIS OCCURS AT END OF LINES.

C  NOTE THAT THE SECOND SEQUENCE ABOVE IS COMMA/DOT/SPACE, NOT JUST
C  COMMA/DOT SINCE WE DON'T WANT ,.35  REPLACED BY ,n35, FOR EXAMPLE.

        IMPLICIT REAL*8(A-H,O-Z)
        CHARACTER READLINE*1000


C  WRITE EACH LINE OF FILE 77 TO FILE 67, BUT REPLACE ALL MISSING VALUE
C  DOTS WITH n's.       

   10   READ(77,4,IOSTAT=IEND) READLINE

    4   FORMAT(A1000)
        IF(IEND .LT. 0) GO TO 100


C  FOR THIS LINE, READLINE, FIND IENDL, THE LAST CHARACTER WHICH IS NOT
C  BLANK. THEN ONLY CHARACTERS 1:IENDL WILL BE WRITTEN TO FILEOUT.

        DO IENDL = 1000,1,-1
         IF(READLINE(IENDL:IENDL) .NE. ' ') GO TO 20
        END DO

   20   CONTINUE


C  BEFORE WRITING READLINE(1:IENDL) TO FILE 22, GO THROUGH THE LINE AND
C  REPLACE ANY DOTS WHICH REPRESENT MISSING VALUES WITH n's.

C  NOTE THAT, AS EXPLAINED ABOVE, THIS MEANS REPLACING AS FOLLOWS:
C   ,.,  WILL BE REPLACED BY  ,n,
C   ,.   WILL BE REPLACED BY  ,n  <-- THIS OCCURS AT END OF LINES.

        DO I = 1,IENDL-2
         IF(READLINE(I:I+2) .EQ. ',.,') READLINE(I:I+2) = ',n,'
        END DO

        IF(READLINE(IENDL-1:IENDL) .EQ. ',.') 
     1   READLINE(IENDL-1:IENDL) = ',n'
      

C  CANNOT USE WRITE(67,4) READLINE(1:IENDL) SINCE, FOR SOME REASON,
C  WRITING LIKE THIS "RIGHT JUSTIFIES" THE CHARACTERS AT THE END
C  OF THE A1000 FORMAT. INSTEAD MUST WRITE (67,__) READLINE, WHERE
C  THE FORMAT IS DETERMINED BY THE LAST NON-BLANK CHARACTER (IENDL)
C  IN READLINE.


	IF(IENDL .LE. 26) THEN
	 WRITE(67,26) READLINE
   26    FORMAT(A26)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 51) THEN
	 WRITE(67,51) READLINE
   51    FORMAT(A51)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 76) THEN
	 WRITE(67,76) READLINE
   76    FORMAT(A76)
	 GO TO 10
	ENDIF


	IF(IENDL .LE. 101) THEN
	 WRITE(67,101) READLINE
  101    FORMAT(A101)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 126) THEN
	 WRITE(67,126) READLINE
  126    FORMAT(A126)


	 GO TO 10
	ENDIF

	IF(IENDL .LE. 151) THEN
	 WRITE(67,151) READLINE
  151    FORMAT(A151)
	 GO TO 10
	ENDIF



	IF(IENDL .LE. 176) THEN
	 WRITE(67,176) READLINE
  176    FORMAT(A176)
	 GO TO 10
	ENDIF


	IF(IENDL .LE. 201) THEN
	 WRITE(67,201) READLINE
  201    FORMAT(A201)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 226) THEN
	 WRITE(67,226) READLINE
  226    FORMAT(A226)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 251) THEN
	 WRITE(67,251) READLINE
  251    FORMAT(A251)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 276) THEN
	 WRITE(67,276) READLINE
  276    FORMAT(A276)
	 GO TO 10

	ENDIF

	IF(IENDL .LE. 301) THEN
	 WRITE(67,301) READLINE
  301    FORMAT(A301)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 326) THEN
	 WRITE(67,326) READLINE
  326    FORMAT(A326)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 351) THEN
	 WRITE(67,351) READLINE

  351    FORMAT(A351)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 376) THEN
	 WRITE(67,376) READLINE
  376    FORMAT(A376)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 401) THEN

	 WRITE(67,401) READLINE
  401    FORMAT(A401)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 426) THEN
	 WRITE(67,426) READLINE
  426    FORMAT(A426)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 451) THEN
	 WRITE(67,451) READLINE
  451    FORMAT(A451)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 476) THEN
	 WRITE(67,476) READLINE
  476    FORMAT(A476)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 501) THEN

	 WRITE(67,501) READLINE
  501    FORMAT(A501)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 526) THEN
	 WRITE(67,526) READLINE
  526    FORMAT(A526)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 551) THEN
	 WRITE(67,551) READLINE
  551    FORMAT(A551)

	 GO TO 10
	ENDIF


	IF(IENDL .LE. 576) THEN
	 WRITE(67,576) READLINE
  576    FORMAT(A576)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 601) THEN
	 WRITE(67,601) READLINE
  601    FORMAT(A601)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 626) THEN
	 WRITE(67,626) READLINE
  626    FORMAT(A626)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 651) THEN
	 WRITE(67,651) READLINE
  651    FORMAT(A651)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 676) THEN
	 WRITE(67,676) READLINE
  676    FORMAT(A676)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 701) THEN
	 WRITE(67,701) READLINE
  701    FORMAT(A701)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 726) THEN

	 WRITE(67,726) READLINE
  726    FORMAT(A726)
	 GO TO 10
	ENDIF


	IF(IENDL .LE. 751) THEN
	 WRITE(67,751) READLINE
  751    FORMAT(A751)
	 GO TO 10

	ENDIF

	IF(IENDL .LE. 776) THEN
	 WRITE(67,776) READLINE
  776    FORMAT(A776)
	 GO TO 10
	ENDIF


	IF(IENDL .LE. 801) THEN
	 WRITE(67,801) READLINE
  801    FORMAT(A801)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 826) THEN
	 WRITE(67,826) READLINE

  826    FORMAT(A826)

	 GO TO 10
	ENDIF

	IF(IENDL .LE. 851) THEN
	 WRITE(67,851) READLINE
  851    FORMAT(A851)
	 GO TO 10

	ENDIF


	IF(IENDL .LE. 876) THEN

	 WRITE(67,876) READLINE
  876    FORMAT(A876)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 901) THEN
	 WRITE(67,901) READLINE
  901    FORMAT(A901)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 926) THEN
	 WRITE(67,926) READLINE
  926    FORMAT(A926)

	 GO TO 10
	ENDIF

	IF(IENDL .LE. 951) THEN
	 WRITE(67,951) READLINE
  951    FORMAT(A951)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 976) THEN
	 WRITE(67,976) READLINE
  976    FORMAT(A976)

	 GO TO 10
	ENDIF


	WRITE(67,4) READLINE
	GO TO 10



  100   CLOSE(77)
        REWIND(67)

        RETURN
        END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
        SUBROUTINE WORKTOCSV(NSUB,PATH,PREFIX,EXT,OUTCSVNAME)

C  THIS SUBROUTINE IS BASED ON THE STAND-A-LONE PROGRAM,
C  WORKCSV.FOR, BUT SOME OF THE DIMENSIONS ARE DIFFERENT TO BE
C  COMPATIBLE WITH THIS PROGRAM.
C  NO! AS OF MONT101F.FOR, THIS ROUTINE WILL CREATE THE NEW-STYLE
C      .CSV FILE, WITH CODE POPDATA DEC_11 AT THE TOP (I.E., THE TYPE
C      THAT HAS TWO EXTRA COLUMNS FOR ADDL AND II).

        PARAMETER(MAXSUB=10000,MAXNUMEQ=7)
        IMPLICIT REAL*8(A-H,O-Z)

      DIMENSION SIG(5000),RS(5000,34),YO(594,MAXNUMEQ),C0(MAXNUMEQ),
     1 C1(MAXNUMEQ),C2(MAXNUMEQ),C3(MAXNUMEQ),TIM(594)

        CHARACTER PREFIX*3,EXT*3,NUMBER(MAXSUB)*5,PATFIL*32,PATH*61,
     1   TMPFILE*32,PATHFILE*93,SUBID*11,DESCR(26)*20,OUTCSVNAME*32,
     2   PATHFILE2*93,TOPLINE*1000,TOP1*58,READLINE*80,CHARSUB*5,
     3   COVTIGHT*550,CODE*14

        CODE = 'POPDATA DEC_11'

C  CALL FULLNAME WHICH CONVERTS THE FILENAME TO PATHFILE2, THE COMPLETE 
C  NAME OF THE FILE, WHICH INCLUDES THE PATH (IF THE PATH IS NOT THE 
C  CURRENT DIRECTORY).

         TMPFILE = ' '
         TMPFILE = OUTCSVNAME 
         CALL FULLNAME(PATH,TMPFILE,PATHFILE2)
         OPEN(29,FILE=PATHFILE2)

C  CALL SUBROUTINE GETCHAR TO ESTABLISH THE NUMBER ARRAY.

        DO ISUB = 1,NSUB
         CALL GETCHAR(ISUB,CHARSUB)
         NUMBER(ISUB) = CHARSUB
        END DO


	DO 1000 ISUB = 1,NSUB

	 PATFIL = PREFIX//NUMBER(ISUB)//'.'//EXT

C  CALL FULLNAME WHICH CONVERTS THE FILENAME TO PATHFILE, THE COMPLETE 
C  NAME OF THE FILE, WHICH INCLUDES THE PATH (IF THE PATH IS NOT THE 
C  CURRENT DIRECTORY).

         TMPFILE = ' '
         TMPFILE = PATFIL 
         CALL FULLNAME(PATH,TMPFILE,PATHFILE)
         OPEN(33,FILE=PATHFILE)

C  FOR THIS SUBJECT, READ THE NAME. ALSO, IF IT IS THE FIRST SUBJECT,
C  READ THE NO. AND NAMES OF THE ADDITIONAL COVARIATES (BEYOND THE
C  4 PERMANENT ONES, AGE, SEX, HEIGHT, ETHNICITY FLAG, AT THE TOP
C  OF EACH WORKING COPY FILE) IF ANY, AND WRITE THE TOP LINE OF THE
C  .CSV FILE.

C  THE NAME IS ON LINE 1 IN ENTRIES 29 TO 39. 

         READ(33,9) SUBID
    9    FORMAT(T29,A11)

C  BUT SINCE ALL THE SIMULATED PATIENTS HAVE THE SAME NAME, REPLACE
C  THE READ IN VALUE OF SUBID WITH SIM00001,...

         SUBID = 'SIM'//NUMBER(ISUB)

         IF(ISUB .EQ. 1) THEN

C  WRITE THE FIRST LINE (THE ONE WITH THE CODE) INTO FILE 29.

          WRITE(29,14) CODE
   14     FORMAT(A14)
        
          CALL GETCOVNAME(NCOVA,DESCR)

          
          TOP1 = '#ID,EVID,TIME,DUR,DOSE,ADDL,II,INPUT,OUT,OUTEQ,C0,C1,C
     12,C3'

C  THE TOP LINE OF THE .CSV FILE WILL ALWAYS HAVE TOP1 IN IT, BUT IT  

C  WILL ALSO HAVE THE NAMES OF THE ADDITIONAL COVARIATES, IF ANY, ON 
C  IT. IF NCOVA > 0, CALL COVSTRING TO OBTAIN THE CHARACTER STRING OF 
C  COVARIATE NAMES (COVTIGHT), TIGHTENED TO REMOVE UNNECCESARY SPACES.
C  NCOVTIGHT RETURNS AS THE NO. OF CHARACTERS IN COVTIGHT.

          TOPLINE = TOP1  

          IF(NCOVA .GT. 0) THEN
           CALL COVSTRING(NCOVA,DESCR,COVTIGHT,NCOVTIGHT)
           TOPLINE = TOP1//COVTIGHT(1:NCOVTIGHT)
          ENDIF

          CALL CONDENSE(TOPLINE)

C  CONDENSE WRITES TOPLINE INTO FILE 29 AFTER CONDENSING IT.


         ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(ISUB .EQ. 1)  CONDITION.


C  READ THE DOSAGE INFO AFTER READING THE NO. OF DRUGS, AND THE NO.
C  OF DOSE EVENTS.

   10	   READ(33,22) READLINE
   22    FORMAT(A80)


         IF(READLINE(12:23) .NE. 'NO. OF DRUGS') GO TO 10
         BACKSPACE(33)
         READ(33,13) NDRUG
   13    FORMAT(T2,I5)

C  SKIP THE NEXT LINE. IT HAS NCOVA ON IT, WHICH IS ALREADY KNOWN.

         READ(33,*)

         NI = 2*NDRUG + NCOVA
      
C  READ THE NO. OF DOSE EVENTS ON THE NEXT LINE.



         READ(33,13) ND
         READ(33,*)
         READ(33,*)

         IF(ND.EQ.0) GO TO 40

         DO I = 1,ND
          READ(33,*) SIG(I),(RS(I,J),J=1,NI)
         END DO

C  READ THE NO. OF OUTPUT EQUATIONS FROM THE LINE WITH 'NO. OF TOTAL'
C  AS ENTRIES 12:23. THEN READ NO. OF OBSERVED VALUE TIMES, ETC.

   40	   READ(33,22) READLINE
         IF(READLINE(12:23) .NE. 'NO. OF TOTAL') GO TO 40
         BACKSPACE(33)

         READ(33,13) NUMEQT
         READ(33,13) M

         DO I=1,M
          READ(33,*) TIM(I),(YO(I,J),J=1,NUMEQT)
         END DO

C  AT THIS POINT, MUST SKIP THE COVARIATE INFO IN THE FILE, AND PROCEED
C  TO READ THE ASSAY NOISE COEFFICIENTS BELOW THAT, IF THEY ARE
C  INCLUDED. IF THEY ARE NOT INCLUDED, SET ALL ASSAY COEFFICIENTS TO 0.


   50	   READ(33,22) READLINE
	   IF(READLINE(1:18) .NE. 'ASSAY COEFFICIENTS') GO TO 50

         IF(READLINE(20:25) .EQ. 'FOLLOW') THEN
          DO IEQ = 1,NUMEQT

           READ(33,*) C0(IEQ),C1(IEQ),C2(IEQ),C3(IEQ)
          END DO
         ENDIF

         IF(READLINE(20:25) .NE. 'FOLLOW') THEN
          DO IEQ = 1,NUMEQT
           C0(IEQ) = 0.D0
           C1(IEQ) = 0.D0
           C2(IEQ) = 0.D0
           C3(IEQ) = 0.D0
          END DO
         ENDIF


         CLOSE(33)

C  CALL WRITECSV TO CONVERT THIS SUBJECT'S VALUES INTO A BLOCK OF
C  LINES IN THE .CSV FILE.

         CALL WRITECSV(SUBID,NDRUG,NCOVA,ND,SIG,RS,NUMEQT,M,TIM,YO,C0,
     1    C1,C2,C3)


 1000   CONTINUE

C  THE ABOVE LINE IS THE END OF THE  DO 1000  LOOP.

        CLOSE(29)

        RETURN
        END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
	SUBROUTINE GETCOVNAME(NCOVA,DESCR)
	IMPLICIT REAL*8(A-H,O-Z)
	CHARACTER READLINE*1000,DESCR(26)*20


C  THIS ROUTINE IS CALLED BY SUBROUTINE WORKTOCSV TO OBTAIN, FROM 
C  FILE 33, THE NO. OF ADDITIONAL COVARIATES (NCOVA), AND THEIR 
C  NAMES (DESCR(I),I=1,NCOVA).


    2   FORMAT(A20)
   33   FORMAT(A1000)

        REWIND(33)

C  THE NO. OF ADDITIONAL COVARIATES IS ON THE LINE HAVING
C  "NO. OF ADDITIONAL COVARIATES" STARTING IN ENTRY 12.

   10	READ(33,33) READLINE
	IF(READLINE(12:28) .NE. 'NO. OF ADDITIONAL') GO TO 10
	BACKSPACE(33)
    3 FORMAT(T2,I5)

      READ(33,3) NCOVA

C  READ THE NCOVA ADDITIONAL COVARIATE NAMES FROM BELOW THE LINE HAVING
C  "COVARIATE NAMES" STARTING IN COLUMN 2. IF NCOVA = 0, NO NAMES 
C  WILL BE READ.



   20	READ(33,33) READLINE
	IF(READLINE(2:16) .NE. 'COVARIATE NAMES') GO TO 20


        IF(NCOVA .GT. 0) THEN

         DO J = 1,NCOVA

          READ(33,33) READLINE

C  FOR THIS COVARIATE, ESTABLISH DESCR(J) AS THE PORTION OF THE
C  CURRENT READLINE UP TO THE  FIRST SPACE, WHICH WILL BE ASSUMED TO BE
C  THE END OF THE COV. NAME. IN CASE THERE IS A SPACE OR TWO AT THE
C  BEGINNING OF READLINE FOR SOME REASON, START CHECKING FOR SPACES AT
C  ENTRY 3.

          DO I = 3,20
           IF(READLINE(I:I) .EQ. ' ') GO TO 30
          END DO

   30     DESCR(J) = READLINE(1:I-1)

         END DO

        ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(NCOVA .GT. 0)  CONDITION.


	REWIND(33)

	RETURN
	END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
        SUBROUTINE WRITECSV(SUBID,NDRUG,NCOVA,ND,SIG,RS,NUMEQT,M,TIM,
     1   YO,C0,C1,C2,C3)

C  WRITECSV IS CALLED BY MAIN TO CONVERT THIS SUBJECT'S VALUES INTO
C  A BLOCK OF LINES IN THE .CSV FILE.

        IMPLICIT REAL*8(A-H,O-Z)

        PARAMETER(MAXNUMEQ=7)

      DIMENSION SIG(5000),RS(5000,34),YO(594,MAXNUMEQ),C0(MAXNUMEQ),
     1 C1(MAXNUMEQ),C2(MAXNUMEQ),C3(MAXNUMEQ),TIM(594),BS(5000,7),
     2 NOIV(7),AMTIV(7,5000),DURIV(7,5000),IVDOSE(7,5000),XVERIFY(900)

        CHARACTER SUBID*11,DOSESTRING*12,OBSSTRING*52,BIGLINE*1000,
     1   SMALLLINE*1000


C  INITIALIZE IDOSENEXT TO BE 0. SEE LOGIC BELOW.

        IDOSENEXT = 0


C  ASSIGN THE VALUES IN EACH DRUG'S PO COLUMN TO THE CORRESPONDING
C  COLUMN IN ARRAY BS.

        DO IDOSE = 1,ND
         DO JDRUG = 1,NDRUG
          BS(IDOSE,JDRUG) = RS(IDOSE,2*JDRUG)
         END DO
        END DO

C  NOTE THAT, AS OF MONT101F.FOR, IF A STEADY STATE DOSE OCCURS AT

C  IDOSE, THE VALUES PUT INTO BS(.,.) ABOVE ARE NOT BOLI, BUT IT
C  DOESN'T MATTER SINCE THEY WON'T BE USED.



C  FIND THE LARGEST OBSERVATION TIME, TIMOBSMAX. IT WILL ONLY BE USED
C  IN CASE AN IV IS READ IN AS GOING ON INDEFINITELY. IN THAT CASE,
C  THIS IV, WHICH NEEDS A STOPPING TIME IN THE .CSV FILE (UNLIKE IN
C  A WORKING COPY FILE), WILL BE SHOWN AS STOPPING AT TIMOBSMAX. NOTE
C  THAT IF THERE ARE TIME RESETS, IT IS POSSIBLE THAT THE MAXIMUM
C  OBSERVATION TIME FOR THE TIME PERIOD OF THE NEVER-ENDING IV IS 
C  LESS THAN TIMOBSMAX, BUT THIS DOESN'T MATTER (SINCE THE IV WILL
C  HAVE GONE AT LEAST AS LONG AS REQUIRED IN THIS CASE).

        TIMOBSMAX = -1.D39
        DO I = 1,M
         IF(TIM(I) .GT. TIMOBSMAX) TIMOBSMAX = TIM(I)
        END DO

  
C  DETERMINE, FOR EACH DRUG, THE TOTAL AMOUNT OF IV THAT IS GIVEN,
C  AND THE TIME OVER WHICH IT IS GIVEN, FOR EACH SEPARATE IV INFUSION.

        DO JDRUG = 1,NDRUG

C  NOIV(JDRUG) WILL BE THE NO. OF IVs FOR THIS DRUG.

         NOIV(JDRUG) = 0

         IDOSE = 0

   40    IDOSE = IDOSE + 1

C  IF IDOSE IS NOW > ND, THERE ARE NO MORE POSSIBLE IVs FOR THIS DRUG.

          IF(IDOSE .GT. ND) GO TO 60


C  AS OF MONT101F.FOR, MUST CHECK EACH DOSE TIME TO SEE IF IT IS < 0.
C  IF IT IS, THE LINE REPRESENTS A STEADY STATE DOSE SET. IN THIS CASE,
C  SKIP THIS DOSE (SINCE IT CERTAINLY DOES NOT REPRESENT A REGULAR IV).

          IF(SIG(IDOSE) .LT. 0.D0) GO TO 40 


C  IF THE CURRENT DOSE IS .NE. 0, IT IS THE START OF THE NEXT IV.
    
          CALL THESAME(RS(IDOSE,2*JDRUG-1),0.D0,ISAME) 

          IF(ISAME .EQ. 0) THEN

C  FOR DRUG NO. JDRUG, AN IV STARTS WITH DOSE NO. IDOSE. ESTABLISH THE
C  TOTAL AMOUNT FOR THIS IV, AND THE TIME IT LASTS.



           PREVIV = RS(IDOSE,2*JDRUG-1)

           IIDOSE = IDOSE

   50      IIDOSE = IIDOSE + 1

C  IF THIS DOSE TIME IS 0, IT INDICATES A DOSE RESET TIME. THIS MEANS
C  THAT THE CURRENT IV WILL BE SET TO END AT TIMOBSMAX.

C  BUG CORRECTION AS OF MONT110.FOR:
C  ACTUALLY, THE CHECK SHOULD BE TO CHECK TO SEE IF THE DOSE TIME IS
C  0 OR .LE. 0, BECAUSE THE FIRST INDICATES A DOSE RESET TIME WITHOUT
C  A STEADY STATE DOSE SET, AND THE SECOND INDICATES A DOSE RESET TIME
C  WITH A STEADY STATE DOSE SET. EITHER WAY, THE CURRENT IV SHOULD BE
C  SET TO END AT TIMOBSMAX.

            IF(SIG(IIDOSE) .LE. 0.D0) THEN
C            CALL THESAME(SIG(IIDOSE),0.D0,ISAME)
C            IF(ISAME .EQ. 1) THEN
             TIMIV = TIMOBSMAX - SIG(IDOSE)
             TOTIV = TIMIV*RS(IDOSE,2*JDRUG-1)
             GO TO 30
            ENDIF


C  TO GET HERE --> THIS DOSE TIME, SIG(IIDOSE), IS NOT .LE. 0. IN THIS
C  CASE, IF THE IV FOR THIS DRUG IS .NE. PREVIV, THIS DOSE TIME IS THE
C  ENDING TIME FOR THE IV. OTHERWISE, CONTINUE THE LOOP.

            CALL THESAME(RS(IIDOSE,2*JDRUG-1),PREVIV,ISAME)
            IF(ISAME .EQ. 0) THEN
             TIMIV = SIG(IIDOSE) - SIG(IDOSE)
             TOTIV = TIMIV*RS(IDOSE,2*JDRUG-1)
             GO TO 30
            ENDIF

           IF(IIDOSE .LT. ND) GO TO 50

C  TO GET HERE --> THE IV STARTED AT DOSE NO. IDOSE WAS NEVER ENDED
C  IN THE WORKING COPY FILE, AND A TIME RESET (A DOSE TIME OF 0) WAS
C  NEVER ENCOUNTERED. THIS MEANS THE IV MUST BE SHOWN TO CONTINUE
C  UNTIL TIMOBSMAX (SEE ABOVE). 

C  ALSO NOTE THAT THIS IS THE END OF POSSIBLE IVs FOR THIS DRUG SINCE
C  THE IV THAT WAS STARTED AT IDOSE WAS NEVER TURNED OFF. SO SET
C  IIDOSE = ND + 1 SO THAT BELOW WHEN IDOSE = IIDOSE - 1, IDOSE WILL
C  = ND, WHICH MEANS AFTER THE TRANSFER BACK TO LABEL 40, IDOSE WILL
C  THEN BE SET = ND+1 --> END OF SEARCHING FOR NEW IVs FOR THIS DRUG.


            TIMIV = TIMOBSMAX - SIG(IDOSE)
            TOTIV = TIMIV*RS(IDOSE,2*JDRUG-1)
            IIDOSE = ND + 1


   30      NOIV(JDRUG) = NOIV(JDRUG) + 1
           AMTIV(JDRUG,NOIV(JDRUG)) = TOTIV 

           DURIV(JDRUG,NOIV(JDRUG)) = TIMIV
           IVDOSE(JDRUG,NOIV(JDRUG)) = IDOSE

C  THE ABOVE ARRAYS SHOW THAT FOR DRUG NO. JDRUG, IV NO. NOIV(JDRUG)
C  STARTED AT DOSE NO. IDOSE, LASTED FOR DURIV(JDRUG,NOIV(JDRUG)), AND
C  HAD A TOTAL AMOUNT OF AMTIV(JDRUG,NOIV(JDRUG)). FOR EXAMPLE, IF FOR
C  DRUG 4, THE 3RD IV STARTS AT DOSE NO. 7, THEN IVDOSE(4,3) = 7.

C  SET IDOSE TO IIDOSE - 1, SO THAT AFTER TRANSFER BACK TO 
C  LABEL 40, THE NEXT IDOSE TO BE CONSIDERED WILL BE THE CURRENT



C  IIDOSE (I.E., THE NEXT IV COULD BE STARTING WITH THE DOSE WHICH
C  ENDED THE CURRENT IV).

           IDOSE = IIDOSE - 1
           GO TO 40     
            
          ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(ISAME .EQ. 0)  CONDITION.

C  TO GET HERE MEANS THAT THE CURRENT IV IS 0, SO CONTINUE LOOKING
C  FOR THE START OF THE NEXT IV.

         GO TO 40

   60    CONTINUE

        END DO


C  THE ABOVE END DO IS FOR THE  DO JDRUG = 1,NDRUG  LOOP.


C  ESTABLISH TWO STRINGS WHICH WILL WE NEEDED IN WRITING TO FILE 25.
C  DOSESTRING CONSISTS OF THE COMMAS AND DOTS WHICH REPRESENT MISSING
C  OUTPUT AND ASSAY COEFFCIENT INFO FOR EACH DOSE LINE.
C  OBSSTRING CONSISTS OF THE COMMAS AND DOTS WHICH REPRESENT MISSING
C  COVARIATE VALUES FOR EACH DOSE LINE. 

        DOSESTRING = ',.,.,.,.,.,.'
       

C  ESTABLISH OBSSTRING TO CONTAIN NCOVA SETS OF ',.', AND ILASTOBS TO
C  BE THE NO. OF CHARACTERS IN OBSSTRING (NOT COUNTING BLANKS).

        DO I = 1,52
         OBSSTRING(I:I) = ' '
        END DO

        IF(NCOVA .GE. 1) THEN
         OBSSTRING(1:2) = ',.'
         ILASTOBS = 2
        ENDIF

        IF(NCOVA .GT. 1) THEN

         DO ICOVA = 2,NCOVA

          DO I = 52,1,-1
           IF(OBSSTRING(I:I) .NE. ' ') GO TO 65 
          END DO


   65     ILAST = I


          OBSSTRING = OBSSTRING(1:ILAST)//',.'

         END DO

         ILASTOBS = ILAST + 2

        ENDIF


C  GO THROUGH ALL THE ND DOSE EVENTS AND THE M OBSERVATION LINES AT THE
C  SAME TIME, AND PUT LINES INTO FILE 25 IN THE PROPER ORDER FOR THIS
C  SUBJECT. 
        
        IDOSE = 1
        IOBS = 1

  100   CONTINUE

C  IF IOBS > M, THERE ARE NO MORE OBSERVATION ROWS TO WRITE TO FILE 25.
C  IF IDOSE > ND, THERE ARE NO MORE DOSE EVENT ROWS TO WRITE TO FILE 25.

        IF(IOBS .GT. M .AND. IDOSE .GT. ND) RETURN

C  IF IOBS > M, ALL THAT IS LEFT ARE DOSE EVENTS.
C  IF IDOSE > ND, ALL THAT IS LEFT ARE OBSERVATION ROWS.

        IF(IOBS .GT. M) GO TO 10
        IF(IDOSE .GT. ND) GO TO 20


C  TO GET HERE MEANS THERE ARE BOTH DOSE EVENTS AND OBSERVATION ROWS

C  TO BE WRITTEN. WRITE THE NEXT DOSE IF IT OCCURS BEFORE THE NEXT
C  OBSERVATION TIME. OTHERWISE, WRITE THE NEXT OBSERVATION ROW.
C  ... BUT CHECK FIRST TO SEE IF EITHER THE DOSE TIME OR THE OBSERVATION
C  TIME REPRESENTS A TIME RESET.  


C  IF THIS IS A DOSE TIME RESET, BUT NOT AN OBSERVATION TIME RESET,
C  THEN THE OBSERVATION GOES FIRST. AND VICE-VERSA.

C  THIS IS A DOSE TIME RESET IF SIG(IDOSE) = 0 AND IDOSE > 1.

        IDOSERESET = 0
        CALL THESAME(SIG(IDOSE),0.D0,ISAME)
        IF(ISAME .EQ. 1 .AND. IDOSE .GT. 1) IDOSERESET = 1
        IF(SIG(IDOSE) .LT. 0.D0 .AND. IDOSE .GT. 1) IDOSERESET = 1

C  AS OF MONT101F.FOR, MUST ALLOW FOR THE POSSIBILITY THAT A DOSE RESET
C  OCCURS WITH A STEADY STATE DOSE SET (I.E., SIG(.) < 0) ABOVE.

        IOBSRESET = 0
        CALL THESAME(TIM(IOBS),0.D0,ISAME)
        IF(ISAME .EQ. 1 .AND. IOBS .GT. 1) IOBSRESET = 1   

        IF(IDOSERESET .EQ. 1 .AND. IOBSRESET .EQ. 1) THEN

C  THIS IS BOTH A DOSE AND AN OBSERVATION TIME RESET. IN THIS CASE,
C  GO TO 20 TO WRITE OBSERVATIONS, IF ANY ARE NOT EQUAL TO -99 FOR THIS
C  OBSERVATION TIME, AND THEN IMMEDIATELY GO TO 10 TO WRITE THE DOSE 
C  INFO. AT THIS TIME RESET. SET IDOSENEXT = 1 IN THIS CASE SO THE 
C  PROGRAM WILL KNOW TO GO DIRECTLY TO 10 AFTER DOING THE CODE AT 20,
C  WITHOUT GOING BACK TO 100 FIRST. NOTE THAT AT THE BOTTOM OF THE
C  DOSE CODE STARTING AT 10, IDOSENEXT IS RESET BACK TO 0.

         IDOSENEXT = 1
         GO TO 20

        ENDIF

        IF(IDOSERESET .EQ. 1 .AND. IOBSRESET .EQ. 0) GO TO 20
        IF(IDOSERESET .EQ. 0 .AND. IOBSRESET .EQ. 1) GO TO 10

        IF(SIG(IDOSE) .GE. TIM(IOBS)) GO TO 20


C  THE NEXT LINES TO BE WRITTEN TO FILE 25 ARE DOSE LINES.


   10    CONTINUE

C  IF THIS IS NOT A TIME RESET, THE EVENT ID IS 1; IF IT IS A TIME 
C  RESET, THE EVENT ID IS 4. IT IS A TIME RESET IF SIG(IDOSE) = .LE. 0
C  AND IDOSE > 1.

        IDEVENT = 1
        CALL THESAME(SIG(IDOSE),0.D0,ISAME)
        IF(ISAME .EQ. 1 .AND. IDOSE .GT. 1) IDEVENT = 4
        IF(SIG(IDOSE) .LT. 0.D0 .AND. IDOSE .GT. 1) IDEVENT = 4

C  AS OF MONT101F.FOR, MUST ALLOW FOR THE POSSIBILITY THAT A DOSE RESET
C  OCCURS WITH A STEADY STATE DOSE SET (I.E., SIG(.) < 0) ABOVE.   

C  AS OF MONT101F.FOR, MUST CHECK EACH DOSE TIME TO SEE IF IT IS < 0.
C  IF IT IS, THE LINE REPRESENTS A STEADY STATE DOSE SET. IN THIS CASE,
C  CALL WRITESTEADY TO WRITE THE STEADY STATE DOSE INFO TO FILE 29 IN
C  A SPECIAL WAY.


        IF(SIG(IDOSE) .LT. 0.D0) THEN
         CALL WRITESTEADY(NCOVA,NDRUG,IDOSE,SIG,RS,BS,DOSESTRING,
     1    SUBID,IDEVENT)
         IDOSE = IDOSE + 1
         IDOSENEXT = 0
         GO TO 100
        ENDIF

C  IF IDEVENT = 4 (I.E., THIS IS A DOSE TIME RESET),  ONLY THE FIRST
C  ROW RELATED TO THIS EVENT SHOULD HAVE AN IDEVENT OF 4; SUBSEQUENT
C  ROWS MUST SHOW IDEVENT = 1. FOR EXAMPLE, IF A DOSE TIME RESET OCCURS
C  WITH BOTH AN IV AND A BOLUS FOR A DRUG, OR AN IV FOR ONE DRUG AND
C  A BOLUS FOR ANOTHER, ONLY THE 1ST ROW SHOULD SHOW AN IDEVENT OF 4;
C  OTHERWISE, THE PROGRAM WILL THINK THAT THE 2ND ROW IS ANOTHER DOSE
C  TIME RESET AFTER THE ONE IN THE 1ST ROW.  

C  THE TIME OF THIS DOSE IS SIG(IDOSE). FOR EACH DRUG, DETERMINE IF
C  THIS TIME REPRESENTS THE TIME OF A NON-0 BOLUS AND/OR THE START OF
C  AN IV. 

C  INITIALIZE IDOSWRITE TO 0. IF IT REMAINS 0 AFTER THE

C  DO JDRUG = 1,NDRUG LOOP, IT MEANS THAT THIS DOSE EVENT HAS NEITHER
C  A BOLUS VALUE OR A STARTING IV FOR ANY OF THE DRUGS. IN THIS CASE,
C  A LINE WILL BE WRITTEN TO FILE 25 WITH THE COVARIATE VALUES IN 
C  THIS LINE. IF IT CHANGES TO 1, THERE IS NO NEED TO WRITE ANOTHER
C  LINE WITH THE COVARIATE VALUES FOR THIS LINE SINCE THEY HAVE ALREADY
C  BEEN INCLUDED IN AT LEAST ONE LINE ALREADY WRITTEN.

         IDOSWRITE = 0


         DO JDRUG = 1,NDRUG

C  CHECK TO SEE IF BOLUS(IDOSE,JDRUG) IS THE SAME AS 0.0. IF NOT,
C  THIS TIME HAS A BOLUS VALUE FOR THIS DRUG. IN THAT CASE, PUT IN
C  A LINE TO FILE 25 FOR THIS VALUE.

          CALL THESAME(BS(IDOSE,JDRUG),0.D0,ISAME)



          IF(ISAME .EQ. 0) THEN

           OPEN(37)

C  REPLACE WRITING OF SIG(),BS(),RS() WITH XVERIFY (SEE LOGIC IN 
C  SUBROUTINE VERIFYVAL).

           IF(NCOVA .GT. 0) THEN
            XVERIFY(1) = SIG(IDOSE)
            XVERIFY(2) = BS(IDOSE,JDRUG)
            DO K = 1,NCOVA
             XVERIFY(2+K) = RS(IDOSE,2*NDRUG+K)
            END DO
            CALL VERIFYVAL(2+NCOVA,XVERIFY)
C           WRITE(37,13) SUBID,IDEVENT,SIG(IDOSE),
C    1      BS(IDOSE,JDRUG),JDRUG,DOSESTRING,
C    2      (RS(IDOSE,2*NDRUG+K),K=1,NCOVA)
            WRITE(37,13) SUBID,IDEVENT,XVERIFY(1),XVERIFY(2),
     1      JDRUG,DOSESTRING,(XVERIFY(2+K),K=1,NCOVA)
           ENDIF

   13      FORMAT(A11,',',I1,',',G14.7,',0,',G14.7,',.,.,',I1,A12,
     1      26(',',G14.7))


           IF(NCOVA .EQ. 0) THEN
            XVERIFY(1) = SIG(IDOSE)
            XVERIFY(2) = BS(IDOSE,JDRUG)     
            CALL VERIFYVAL(2,XVERIFY)
C           WRITE(37,14) SUBID,IDEVENT,SIG(IDOSE),
C    1      BS(IDOSE,JDRUG),JDRUG,DOSESTRING
            WRITE(37,14) SUBID,IDEVENT,XVERIFY(1),XVERIFY(2),
     1      JDRUG,DOSESTRING   
           ENDIF

   14      FORMAT(A11,',',I1,',',G14.7,',0,',G14.7,',.,.,',I1,A12)

           BACKSPACE(37)
           READ(37,12) BIGLINE
           CLOSE(37)
           CALL REDUCE(BIGLINE,SMALLLINE)
           CALL CONDENSE(SMALLLINE)
           IDOSWRITE = 1
           IDEVENT = 1
C  EVEN IF IDEVENT = 4, IT SHOULD BE CHANGED AFTER THE ABOVE WRITING,
C  SINCE EACH DOSE RESET ROW SHOULD HAVE JUST ONE IDEVENT = 4 ROW
C  IN THE .CSV FILE; ALL SUBSEQUENT ROWS FOR THIS EVENT SHOULD SHOW

C  IDEVENT = 1. 
           

          ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(ISAME .EQ. 0)  CONDITION.


C  CHECK TO SEE IF DRUG JDRUG HAS AN IV WHICH STARTS AT DOSE NO. IDOSE.
C  IF SO, PUT IN A LINE TO FILE 25 FOR THIS VALUE.

          IF(NOIV(JDRUG) .GE. 1) THEN

           DO IN = 1,NOIV(JDRUG)

            IF(IVDOSE(JDRUG,IN) .EQ. IDOSE) THEN

             OPEN(37)

C  REPLACE WRITING OF SIG(),DURIV(),AMTIV(),RS() WITH XVERIFY 
C  (SEE LOGIC IN SUBROUTINE VERIFYVAL).

           IF(NCOVA .GT. 0) THEN
            XVERIFY(1) = SIG(IDOSE)
            XVERIFY(2) = DURIV(JDRUG,IN) 
            XVERIFY(3) = AMTIV(JDRUG,IN)
            DO K = 1,NCOVA
             XVERIFY(3+K) = RS(IDOSE,2*NDRUG+K)
            END DO
            CALL VERIFYVAL(3+NCOVA,XVERIFY)
C           WRITE(37,16) SUBID,IDEVENT,SIG(IDOSE),
C    1      DURIV(JDRUG,IN),AMTIV(JDRUG,IN),JDRUG,
C    2      DOSESTRING,(RS(IDOSE,2*NDRUG+K),K=1,NCOVA)
            WRITE(37,16) SUBID,IDEVENT,(XVERIFY(IXV),IXV=1,3),
     1      JDRUG,DOSESTRING,(XVERIFY(3+K),K=1,NCOVA)
           ENDIF

   16      FORMAT(A11,',',I1,',',G14.7,',',G14.7,',',G14.7,',.,.,',I1,
     1      A12,26(',',G14.7))



           IF(NCOVA .EQ. 0) THEN
            XVERIFY(1) = SIG(IDOSE)
            XVERIFY(2) = DURIV(JDRUG,IN) 
            XVERIFY(3) = AMTIV(JDRUG,IN)
            CALL VERIFYVAL(3,XVERIFY)
C           WRITE(37,17) SUBID,IDEVENT,SIG(IDOSE),
C    1       DURIV(JDRUG,IN),AMTIV(JDRUG,IN),JDRUG,
C    2       DOSESTRING
            WRITE(37,17) SUBID,IDEVENT,(XVERIFY(IXV),IXV=1,3),
     1       JDRUG,DOSESTRING 
           ENDIF

   17      FORMAT(A11,',',I1,',',G14.7,',',G14.7,',',G14.7,',.,.,',I1,
     1      A12)

             BACKSPACE(37)
             READ(37,12) BIGLINE
             CLOSE(37)
             CALL REDUCE(BIGLINE,SMALLLINE)
             CALL CONDENSE(SMALLLINE)

             IDOSWRITE = 1
             IDEVENT = 1
C  EVEN IF IDEVENT = 4, IT SHOULD BE CHANGED AFTER THE ABOVE WRITING,
C  SINCE EACH DOSE RESET ROW SHOULD HAVE JUST ONE IDEVENT = 4 ROW

C  IN THE .CSV FILE; ALL SUBSEQUENT ROWS FOR THIS EVENT SHOULD SHOW
C  IDEVENT = 1. 

             GO TO 70

            ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(IVDOSE(JDRUG,IN) .EQ. IDOSE)  
C  CONDITION.  

           END DO

C  THE ABOVE END DO IS FOR THE  DO IN = 1,NOIV(DRUG)  LOOP.


          ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(NOIV(JDRUG) .GE. 1)  CONDITION.

   70     CONTINUE

         END DO

C  THE ABOVE END DO IS FOR THE  DO JDRUG = 1,NDRUG  LOOP.



C  IF IDOSWRITE = 0, MUST PUT IN A LINE TO ESTABLISH THE COVARIATE
C  VALUES (SEE ABOVE).

         IF(IDOSWRITE .EQ. 0) THEN

          OPEN(37)


C  REPLACE WRITING OF SIG(),RS() WITH XVERIFY (SEE LOGIC IN 
C  SUBROUTINE VERIFYVAL).

          IF(NCOVA .GT. 0) THEN
           XVERIFY(1) = SIG(IDOSE)
            DO K = 1,NCOVA
             XVERIFY(1+K) = RS(IDOSE,2*NDRUG+K)
            END DO
            CALL VERIFYVAL(1+NCOVA,XVERIFY)
C          WRITE(37,18) SUBID,IDEVENT,SIG(IDOSE),
C    1     DOSESTRING,(RS(IDOSE,2*NDRUG+K),K=1,NCOVA)
           WRITE(37,18) SUBID,IDEVENT,XVERIFY(1),
     1     DOSESTRING,(XVERIFY(1+K),K=1,NCOVA)
          ENDIF

   18     FORMAT(A11,',',I1,',',G14.7,',0,0,.,.,1',A12,26(',',G14.7))

C  REPLACE WRITING OF SIG() WITH XVERIFY (SEE LOGIC IN 
C  SUBROUTINE VERIFYVAL).

          IF(NCOVA .EQ. 0) THEN
           XVERIFY(1) = SIG(IDOSE)
            CALL VERIFYVAL(1,XVERIFY)
C           WRITE(37,19) SUBID,IDEVENT,SIG(IDOSE),DOSESTRING 
            WRITE(37,19) SUBID,IDEVENT,XVERIFY(1),DOSESTRING
          ENDIF
 
   19     FORMAT(A11,',',I1,',',G14.7,',0,0,.,.,1',A12)

  
          BACKSPACE(37)
          READ(37,12) BIGLINE
          CLOSE(37)
          CALL REDUCE(BIGLINE,SMALLLINE)
          CALL CONDENSE(SMALLLINE)

         ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(IDOSWRITE .EQ. 0)  CONDITION.
 

         IDOSE = IDOSE + 1


C  SET IDOSENEXT TO 0. SEE LOGIC BELOW LABEL 20.

         IDOSENEXT = 0


         GO TO 100


C  TO GET TO 20 MEANS THAT OBSERVATION ROWS WILL BE WRITTEN.

   20   CONTINUE

C  THE NEXT LINES TO BE WRITTEN TO FILE 29 ARE OBSERVATION LINES, ONE
C  FOR EACH OUTPUT EQUATION WHICH HAS A NON-MISSING OBSERVATION AT THE

C  CURRENT TIME, TIM(IOBS).


C  ALSO NOTE THAT THE ASSAY COEFFICIENTS WILL BE WRITTEN TO EACH LINE.

         DO IEQ = 1,NUMEQT

C  CHECK TO SEE IF OBSERVATION IOBS FOR OUTPUT EQ. IEQ IS -99. IF NOT,
C  WRITE A LINE INTO FILE 25 FOR THIS VALUE. IN THIS CASE, WRITE THE
C  INFO TO SCRATCH FILE 37, READ THIS LINE AS A CHARACTER CONSTANT,
C  CALL REDUCE TO REMOVE THE SPACES IN THIS CHARACTER CONSTANT, AND THEN
C  CALL CONDENSE TO WRITE THIS REDUCED CONSTANT TO FILE 25 WITH AS 
C  SMALL A FORMAT AS POSSIBLE (WITHIN 25 CHARACTERS).

          CALL THESAME(YO(IOBS,IEQ),-99.D0,ISAME)

          IF(ISAME .EQ. 0) THEN
           OPEN(37)

C  REPLACE WRITING OF TIM(),..., C3()  WITH XVERIFY (SEE LOGIC IN 
C  SUBROUTINE VERIFYVAL).

           IF(NCOVA .GT. 0) THEN
            XVERIFY(1) = TIM(IOBS)
            XVERIFY(2) = YO(IOBS,IEQ)
            XVERIFY(3) = C0(IEQ)
            XVERIFY(4) = C1(IEQ)
            XVERIFY(5) = C2(IEQ)
            XVERIFY(6) = C3(IEQ)
            CALL VERIFYVAL(6,XVERIFY)
C           WRITE(37,11)SUBID,TIM(IOBS),YO(IOBS,IEQ),
C    1       IEQ,C0(IEQ),C1(IEQ),C2(IEQ),C3(IEQ),OBSSTRING(1:ILASTOBS)
            WRITE(37,11)SUBID,XVERIFY(1),XVERIFY(2),IEQ,
     1      (XVERIFY(K),K=3,6),OBSSTRING(1:ILASTOBS)
           ENDIF

   11       FORMAT(A11,',0,',G14.7,',.,.,.,.,.,',G14.7,',',I1,',',
     1       G14.7,',',G14.7,',',G14.7,',',G14.7,A)

           IF(NCOVA .EQ. 0) THEN
            XVERIFY(1) = TIM(IOBS)
            XVERIFY(2) = YO(IOBS,IEQ)
            XVERIFY(3) = C0(IEQ)
            XVERIFY(4) = C1(IEQ)
            XVERIFY(5) = C2(IEQ)
            XVERIFY(6) = C3(IEQ)
            CALL VERIFYVAL(6,XVERIFY)
C           WRITE(37,111)SUBID,TIM(IOBS),YO(IOBS,IEQ),
C    1       IEQ,C0(IEQ),C1(IEQ),C2(IEQ),C3(IEQ)
            WRITE(37,111)SUBID,XVERIFY(1),XVERIFY(2),IEQ,
     1      (XVERIFY(K),K=3,6)
           ENDIF

  111      FORMAT(A11,',0,',G14.7,',.,.,.,.,.,',G14.7,',',I1,',',
     1      G14.7,',',G14.7,',',G14.7,',',G14.7)

           BACKSPACE(37)
           READ(37,12) BIGLINE
   12      FORMAT(A1000)

           CLOSE(37)
           CALL REDUCE(BIGLINE,SMALLLINE)
           CALL CONDENSE(SMALLLINE)

          ENDIF

         END DO

C  THE ABOVE END DO IS FOR THE  DO IEQ = 1,NUMEQT  LOOP.

         IOBS = IOBS + 1

         IF(IDOSENEXT .EQ. 1) GO TO 10
C  NOTE THAT IF IDOSENEXT = 1, IT MEANS THAT THE CURRENT TIME
C  REPRESENTS BOTH AN OBSERVATION AND A DOSE TIME RESET. SINCE THE
C  CODE TO WRITE THE INFO FOR THE OBSERVATION HAS NOW BEEN COMPLETED,
C  CONTROL SHIFTS IMMEDIATELY TO LABEL 10 WHERE THE DOSE INFO WILL NEXT
C  BE WRITTEN.

         GO TO 100


        END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
        SUBROUTINE REDUCE(BIGLINE,SMALLLINE)
        CHARACTER BIGLINE*1000,SMALLLINE*1000

C  THIS ROUTINE, CALLED BY WRITECSV, INPUTS BIGLINE, AND OUTPUTS
C  SMALLLINE WHICH HAS ALL THE NON-BLANK CHARACTERS OF BIGLINE
C  (EXCEPT THAT THE FIRST 11 CHARACTERS, WHICH CONSTITUTE THE
C  PATIENT NAME) CAN HAVE BLANKS.

C  FIRST BLANK OUT ALL OF SMALLLINE, IN CASE IT HAS SOME "JUNK" IN 
C  SOME OF ITS ENTRIES.

        DO I = 1,1000
         SMALLLINE(I:I) = ' '
        END DO
 
        SMALLLINE(1:11) = BIGLINE(1:11)

        IENTRY = 11

        DO I = 12,1000
         IF(BIGLINE(I:I) .NE. ' ') THEN
          IENTRY = IENTRY + 1
          SMALLLINE(IENTRY:IENTRY) = BIGLINE(I:I)
         ENDIF
        END DO


C  BECAUSE OF THE FORMAT USED TO WRITE DOSES TO FILE 37 IN MAIN, IT IS
C  POSSIBLE THAT THE LAST CHARACTER COULD BE A COMMA. SO CHECK THE LAST
C  ENTRY IN SMALLLINE, AND IF IT IS A COMMA, CHANGE IT TO A BLANK.

        IF(SMALLLINE(IENTRY:IENTRY) .EQ. ',') 
     1   SMALLLINE(IENTRY:IENTRY) = ' '

        RETURN
        END
C

CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
        SUBROUTINE CONDENSE(READLINE)


        CHARACTER READLINE*1000        

C  SUBROUTINE CONDENSE IS CALLED BY WRITECSV TO WRITE READLINE WITH AS 
C  SMALL A FORMAT AS POSSIBLE (WITHIN 25 CHARACTERS) TO FILE 29.

C  FOR THIS LINE, READLINE, FIND IEND, THE LAST CHARACTER WHICH IS NOT

C  BLANK. THEN ONLY CHARACTERS 1:IEND WILL BE WRITTEN TO FILE 29.



	DO IEND = 1000,1,-1
	 IF(READLINE(IEND:IEND) .NE. ' ') GO TO 20
	END DO

   20   CONTINUE



C  CANNOT USE WRITE(29,_) READLINE(1:IEND) SINCE, FOR SOME REASON,
C  WRITING LIKE THIS "RIGHT JUSTIFIES" THE CHARACTERS AT THE END
C  OF THE A1000 FORMAT. INSTEAD MUST WRITE(29,__) READLINE, WHERE
C  THE FORMAT IS DETERMINED BY THE LAST NON-BLANK CHARACTER (IEND)
C  IN READLINE.

	IF(IEND .LE. 26) THEN
	 WRITE(29,26) READLINE
   26    FORMAT(A26)
	 RETURN
	ENDIF

	IF(IEND .LE. 51) THEN
	 WRITE(29,51) READLINE
   51    FORMAT(A51)
	 RETURN
	ENDIF

	IF(IEND .LE. 76) THEN
	 WRITE(29,76) READLINE
   76    FORMAT(A76)
	 RETURN
	ENDIF

	IF(IEND .LE. 101) THEN
	 WRITE(29,101) READLINE
  101    FORMAT(A101)
	 RETURN
	ENDIF

	IF(IEND .LE. 126) THEN

	 WRITE(29,126) READLINE
  126    FORMAT(A126)
	 RETURN
	ENDIF

	IF(IEND .LE. 151) THEN
	 WRITE(29,151) READLINE
  151    FORMAT(A151)
	 RETURN
	ENDIF


	IF(IEND .LE. 176) THEN
	 WRITE(29,176) READLINE
  176    FORMAT(A176)
	 RETURN
	ENDIF

	IF(IEND .LE. 201) THEN
	 WRITE(29,201) READLINE
  201    FORMAT(A201)
	 RETURN
	ENDIF

	IF(IEND .LE. 226) THEN
	 WRITE(29,226) READLINE
  226    FORMAT(A226)
	 RETURN
	ENDIF

	IF(IEND .LE. 251) THEN
	 WRITE(29,251) READLINE
  251    FORMAT(A251)

	 RETURN
	ENDIF

	IF(IEND .LE. 276) THEN
	 WRITE(29,276) READLINE
  276    FORMAT(A276)
	 RETURN
	ENDIF


	IF(IEND .LE. 301) THEN
	 WRITE(29,301) READLINE
  301    FORMAT(A301)
	 RETURN
	ENDIF

	IF(IEND .LE. 326) THEN
	 WRITE(29,326) READLINE
  326    FORMAT(A326)
	 RETURN
	ENDIF

	IF(IEND .LE. 351) THEN
	 WRITE(29,351) READLINE
  351    FORMAT(A351)

	 RETURN
	ENDIF

	IF(IEND .LE. 376) THEN
	 WRITE(29,376) READLINE
  376    FORMAT(A376)
	 RETURN
	ENDIF

	IF(IEND .LE. 401) THEN
	 WRITE(29,401) READLINE
  401    FORMAT(A401)
	 RETURN
	ENDIF

	IF(IEND .LE. 426) THEN
	 WRITE(29,426) READLINE

  426    FORMAT(A426)
	 RETURN
	ENDIF

	IF(IEND .LE. 451) THEN
	 WRITE(29,451) READLINE
  451    FORMAT(A451)
	 RETURN
	ENDIF

	IF(IEND .LE. 476) THEN
	 WRITE(29,476) READLINE
  476    FORMAT(A476)
	 RETURN
	ENDIF

	IF(IEND .LE. 501) THEN

	 WRITE(29,501) READLINE


  501    FORMAT(A501)
	 RETURN
	ENDIF

	IF(IEND .LE. 526) THEN
	 WRITE(29,526) READLINE
  526    FORMAT(A526)
	 RETURN
	ENDIF

	IF(IEND .LE. 551) THEN
	 WRITE(29,551) READLINE
  551    FORMAT(A551)
	 RETURN
	ENDIF

	IF(IEND .LE. 576) THEN



	 WRITE(29,576) READLINE
  576    FORMAT(A576)
	 RETURN
	ENDIF

	IF(IEND .LE. 601) THEN
	 WRITE(29,601) READLINE
  601    FORMAT(A601)
	 RETURN
	ENDIF

	IF(IEND .LE. 626) THEN
	 WRITE(29,626) READLINE
  626    FORMAT(A626)
	 RETURN
	ENDIF

	IF(IEND .LE. 651) THEN
	 WRITE(29,651) READLINE
  651    FORMAT(A651)
	 RETURN
	ENDIF

	IF(IEND .LE. 676) THEN
	 WRITE(29,676) READLINE
  676    FORMAT(A676)
	 RETURN
	ENDIF

	IF(IEND .LE. 701) THEN
	 WRITE(29,701) READLINE
  701    FORMAT(A701)
	 RETURN
	ENDIF

	IF(IEND .LE. 726) THEN
	 WRITE(29,726) READLINE
  726    FORMAT(A726)
	 RETURN
	ENDIF

	IF(IEND .LE. 751) THEN
	 WRITE(29,751) READLINE

  751    FORMAT(A751)
	 RETURN
	ENDIF



	IF(IEND .LE. 776) THEN
	 WRITE(29,776) READLINE
  776    FORMAT(A776)
	 RETURN
	ENDIF

	IF(IEND .LE. 801) THEN

	 WRITE(29,801) READLINE
  801    FORMAT(A801)
	 RETURN
	ENDIF

	IF(IEND .LE. 826) THEN
	 WRITE(29,826) READLINE
  826    FORMAT(A826)
	 RETURN
	ENDIF


	IF(IEND .LE. 851) THEN
	 WRITE(29,851) READLINE
  851    FORMAT(A851)
	 RETURN
	ENDIF

	IF(IEND .LE. 876) THEN
	 WRITE(29,876) READLINE
  876    FORMAT(A876)
	 RETURN
	ENDIF

	IF(IEND .LE. 901) THEN
	 WRITE(29,901) READLINE
  901    FORMAT(A901)
	 RETURN
	ENDIF

	IF(IEND .LE. 926) THEN
	 WRITE(29,926) READLINE
  926    FORMAT(A926)
	 RETURN
	ENDIF

	IF(IEND .LE. 951) THEN
	 WRITE(29,951) READLINE
  951    FORMAT(A951)
	 RETURN
	ENDIF

	IF(IEND .LE. 976) THEN
	 WRITE(29,976) READLINE
  976    FORMAT(A976)
	 RETURN
	ENDIF

	WRITE(29,4) READLINE
    4    FORMAT(A1000)

        RETURN

        END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
        SUBROUTINE COVSTRING(NCOVA,DESCR,COVTIGHT,NCOVTIGHT)


        CHARACTER DESCR(26)*20,COVTIGHT*550,BIGLINE*1000

C  THIS SUBROUTINE IS CALLED BY MAIN TO PLACE INTO COVTIGHT THE
C  LIST OF NCOVA COVARIATE NAMES, EACH SEPARATED BY A COMMA.
C  NCOVTIGHT RETURNS AS THE NO. OF CHARACTERS IN COVTIGHT.
        
        DO I = 1,1000
         BIGLINE(I:I) = ' '
        END DO


        BIGLINE(1:21) = ','//DESCR(1)

        IF(NCOVA .GT. 1) THEN

        DO I = 2,NCOVA

C  CALL CALCSTART TO DETERMINE THE LAST USED CHARACTER IN BIGLINE.

         CALL CALCSTART(BIGLINE,ILAST)
         BIGLINE = BIGLINE(1:ILAST)//','//DESCR(I)

        END DO

        ENDIF

C  BUG FIX AS OF MONT111.FOR (SEE COMMENTS AT THE TOP OF THIS 
C  PROGRAM TO SEE WHAT GOES WRONG IF ILAST IS NOT ESTABLISHED IN
C  THE CASE OF NCOVA = 1).

C  IN CASE NCOVA = 1, ILAST WAS NOT ESTABLISHED ABOVE. IN THIS
C  CASE, SET ILAST = 1 SINCE THE MOST ENTRIES FOR THE SINGLE COVARIATE
C  AND THE FIRST COMMA IS 1 + 20.
C  IS 20.

        IF(NCOVA .EQ. 1) ILAST = 1


C  THE NO. OF ENTRIES IN BIGLINE IS ILAST + 20 (SINCE THE LAST
C  COVARIATE, DESCR(NCOVA), HAS AT MOST 20 ENTRIES).

        NCOVTIGHT = ILAST + 20
        COVTIGHT = BIGLINE(1:NCOVTIGHT)

        RETURN 
        END               
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
        SUBROUTINE CALCSTART(BIGLINE,ILAST)
        CHARACTER BIGLINE*1000

        DO I = 1000,1,-1

         IF(BIGLINE(I:I) .NE. ' ') GO TO 10
        END DO

        ILAST = 0
        RETURN

   10   ILAST = I

        RETURN
        END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
      SUBROUTINE CONVERTCSV
      IMPLICIT REAL*8(A-H,O-Z)

      CHARACTER READLINE*1000,ERRFIL*20



      COMMON/ERROR/ERRFIL
C  COMMON/ERROR/ IS SUPPLIED TO ALL THE ROUTINES WHICH COULD WRITE TO
C  ERRFIL.

C  SUBROUTINE CONVERTCSV READS FILE 87 AND WRITES SCRATCH FILE 77.
C  IF FILE 87 IS ALREADY IN THE TYPICAL "AMERICAN" .CSV FORMAT, 
C  FILE 77 IS THE SAME AS FILE 87. 

C  IF FILE 87 IS IN THE "EUROPEAN" .CSV FORMAT, WHERE SEMICOLONS
C  ARE THE FIELD SEPARATORS, AND COMMAS ARE USED TO SEPARATE THE
C  WHOLE AND FRACTIONAL PARTS OF NUMBERS, IT WILL BE WRITTEN TO
C  FILE 77 WITH THE INDICATED CHANGES BELOW.


C  FILE 87 IS AT LINE 1. READ PAST THIS LINE TO READ LINE 2 AND CHECK
C  FOR A SEMICOLON. IF ONE IS FOUND, THEN THIS IS A "EUROPEAN" VERSION OF
C  A .CSV FILE. NOTE THAT IT IS ONLY NECESSARY TO CHECK THE FIRST FEW
C  CHARACTERS OF THIS LINE - EITHER THERE WILL BE COMMAS OR SEMICOLONS.
C  IF THERE ARE BOTH COMMAS AND SEMICOLONS, SOMETHING IS WRONG WITH THE
C  FILE; IN THIS CASE, PRINT A MESSAGE TO THE USER AND STOP.
C  NOTE THAT, EVEN IN THE "EURO" VERSION, IT WILL STILL BE ASSUMED THAT
C  A DOT REPRESENTS AN UNNEEDED VALUE.

        READ(87,*)
        READ(87,4) READLINE

        ICOMMA = 0
        ISEMICOLON = 0

        DO I = 1,20
         IF(READLINE(I:I) .EQ. ',') ICOMMA = 1
         IF(READLINE(I:I) .EQ. ';') ISEMICOLON = 1
        END DO

C  IF ICOMMA = 1 AND ISEMICOLON = 0, NO CONVERSION IS NEEDED AS THIS
C  FILE IS A TYPICAL .CSV FILE. IN THIS CASE SET ICONVERT = 0.

C  IF ICOMMA = 0 AND ISEMICOLON = 1, CONVERT THIS FILE AS FOLLOWS:
C  a. CHANGE ALL COMMAS TO PERIODS; THEN
C  b. CHANGE ALL SEMICOLONS TO COMMAS.
C  IN THIS CASE, SET ICONVERT = 1.

C  IF ICOMMA = 1 AND ISEMICOLON = 1, STOP THE PROGRAM WITH A MESSAGE TO
C  THE USER.

        IF(ICOMMA .EQ. 1 .AND. ISEMICOLON .EQ. 1) THEN



         WRITE(*,121)
  121    FORMAT(/' YOUR .CSV FILE HAS BOTH COMMAS AND SEMICOLONS IN '/
     1' THE SECOND LINE. THIS IS A CONFLICT. IF YOU ARE USING THE '/
     2' "EUROPEAN" VERSION OF A .CSV FILE, WITH SEMICOLONS AS FIELD'/
     3' SEPARATORS AND COMMAS TO SEPARATE THE WHOLE AND FRACTIONAL'/
     4' PARTS OF NUMBERS, THERE SHOULD BE NO COMMAS IN THE SECOND'/
     5' LINE.'//
     6' SIMILARLY IF YOU ARE USING THE "AMERICAN" VERSION OF A .CSV'/
     7' FILE, WITH COMMAS AS FIELD SEPARATORS, AND PERIODS TO SEPARTE'/
     8' THE WHOLE AND FRACTIONAL PARTS OF NUMBERS, THERE SHOULD BE NO'/
     9' SEMICOLONS IN THE SECOND LINE.'//
     1' PLEASE CORRECT YOUR .CSV FILE AND RERUN THE PROGRAM.'//)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,121) 
        CLOSE(42)	



         CALL PAUSE
         STOP



        ENDIF


        IF(ICOMMA .EQ. 1 .AND. ISEMICOLON .EQ. 0) ICONVERT = 0
        IF(ICOMMA .EQ. 0 .AND. ISEMICOLON .EQ. 1) ICONVERT = 1      

        REWIND(87)
        OPEN(77)


C  COPY FILE 87 TO FILE 77 BUT MAKE THE INDICATED CHANGES, IF
C  ICONVERT = 1, LINE BY LINE.

   10   READ(87,4,IOSTAT=IEND) READLINE
    4   FORMAT(A1000)
        IF(IEND .LT. 0) GO TO 100

C  FOR THIS LINE, READLINE, FIND IENDL, THE LAST CHARACTER WHICH IS NOT
C  BLANK. THEN ONLY CHARACTERS 1:IENDL WILL BE WRITTEN TO FILEOUT.

        DO IENDL = 1000,1,-1
         IF(READLINE(IENDL:IENDL) .NE. ' ') GO TO 20
        END DO

   20   CONTINUE

        DO I = 1,IENDL
         IF(ICONVERT .EQ. 1) THEN
          IF(READLINE(I:I) .EQ. ',') READLINE(I:I) = '.'
          IF(READLINE(I:I) .EQ. ';') READLINE(I:I) = ','
         ENDIF
        END DO


C  CANNOT USE WRITE(77,4) READLINE(1:IENDL) SINCE, FOR SOME REASON,
C  WRITING LIKE THIS "RIGHT JUSTIFIES" THE CHARACTERS AT THE END
C  OF THE A1000 FORMAT. INSTEAD MUST WRITE (77,__) READLINE, WHERE
C  THE FORMAT IS DETERMINED BY THE LAST NON-BLANK CHARACTER (IENDL)
C  IN READLINE.

	IF(IENDL .LE. 26) THEN
	 WRITE(77,26) READLINE
   26    FORMAT(A26)
	 GO TO 10
	ENDIF


	IF(IENDL .LE. 51) THEN
	 WRITE(77,51) READLINE
   51    FORMAT(A51)
	 GO TO 10
	ENDIF


	IF(IENDL .LE. 76) THEN
	 WRITE(77,76) READLINE
   76    FORMAT(A76)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 101) THEN

	 WRITE(77,101) READLINE
  101    FORMAT(A101)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 126) THEN
	 WRITE(77,126) READLINE
  126    FORMAT(A126)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 151) THEN
	 WRITE(77,151) READLINE
  151    FORMAT(A151)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 176) THEN

	 WRITE(77,176) READLINE
  176    FORMAT(A176)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 201) THEN

	 WRITE(77,201) READLINE
  201    FORMAT(A201)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 226) THEN
	 WRITE(77,226) READLINE
  226    FORMAT(A226)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 251) THEN
	 WRITE(77,251) READLINE
  251    FORMAT(A251)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 276) THEN

	 WRITE(77,276) READLINE
  276    FORMAT(A276)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 301) THEN
	 WRITE(77,301) READLINE
  301    FORMAT(A301)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 326) THEN
	 WRITE(77,326) READLINE
  326    FORMAT(A326)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 351) THEN
	 WRITE(77,351) READLINE
  351    FORMAT(A351)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 376) THEN
	 WRITE(77,376) READLINE
  376    FORMAT(A376)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 401) THEN
	 WRITE(77,401) READLINE
  401    FORMAT(A401)
	 GO TO 10
	ENDIF


	IF(IENDL .LE. 426) THEN
	 WRITE(77,426) READLINE
  426    FORMAT(A426)
	 GO TO 10
	ENDIF


	IF(IENDL .LE. 451) THEN
	 WRITE(77,451) READLINE
  451    FORMAT(A451)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 476) THEN

	 WRITE(77,476) READLINE
  476    FORMAT(A476)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 501) THEN
	 WRITE(77,501) READLINE
  501    FORMAT(A501)
	 GO TO 10
	ENDIF


	IF(IENDL .LE. 526) THEN
	 WRITE(77,526) READLINE
  526    FORMAT(A526)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 551) THEN
	 WRITE(77,551) READLINE
  551    FORMAT(A551)
	 GO TO 10
	ENDIF


	IF(IENDL .LE. 576) THEN
	 WRITE(77,576) READLINE
  576    FORMAT(A576)
	 GO TO 10
	ENDIF


	IF(IENDL .LE. 601) THEN
	 WRITE(77,601) READLINE
  601    FORMAT(A601)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 626) THEN
	 WRITE(77,626) READLINE
  626    FORMAT(A626)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 651) THEN
	 WRITE(77,651) READLINE
  651    FORMAT(A651)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 676) THEN
	 WRITE(77,676) READLINE
  676    FORMAT(A676)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 701) THEN
	 WRITE(77,701) READLINE
  701    FORMAT(A701)
	 GO TO 10

	ENDIF


	IF(IENDL .LE. 726) THEN
	 WRITE(77,726) READLINE
  726    FORMAT(A726)
	 GO TO 10

	ENDIF


	IF(IENDL .LE. 751) THEN
	 WRITE(77,751) READLINE
  751    FORMAT(A751)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 776) THEN
	 WRITE(77,776) READLINE

  776    FORMAT(A776)
	 GO TO 10
	ENDIF



	IF(IENDL .LE. 801) THEN
	 WRITE(77,801) READLINE
  801    FORMAT(A801)
	 GO TO 10

	ENDIF

	IF(IENDL .LE. 826) THEN
	 WRITE(77,826) READLINE

  826    FORMAT(A826)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 851) THEN
	 WRITE(77,851) READLINE
  851    FORMAT(A851)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 876) THEN
	 WRITE(77,876) READLINE

  876    FORMAT(A876)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 901) THEN
	 WRITE(77,901) READLINE
  901    FORMAT(A901)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 926) THEN
	 WRITE(77,926) READLINE
  926    FORMAT(A926)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 951) THEN
	 WRITE(77,951) READLINE
  951    FORMAT(A951)
	 GO TO 10
	ENDIF


	IF(IENDL .LE. 976) THEN
	 WRITE(77,976) READLINE
  976    FORMAT(A976)
	 GO TO 10
	ENDIF

	WRITE(77,4) READLINE
	GO TO 10




  100   CLOSE(87)
        REWIND(77)


        RETURN
        END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
      SUBROUTINE CSVCHANGE

C  SUBROUTINE CSVCHANGE IS CALLED BY MAIN AND SUBROUTINE GETNUMEQ TO
C  CHANGE .csv FILES WITH CODE OF POPDATA DEC_11 (I.E., THOSE WITH 2
C  EXTRA COLUMNS FOR ADDL AND II) TO EQUIVALENT .csv FILES WITH CODE OF
C  POPDATA APR_11 (THOSE WITHOUT THE TWO EXTRA COLUMNS). IT READS
C  FILE 67, AND WRITES THE INFORMATION TO SCRATCH FILE 66. NOTE THAT IF
C  THE .csv FILE READ IN ALREADY IS THE OLDER VERSION (WITH CODE 
C  POPDATA APR_11), THIS ROUTINE SIMPLY REWRITES IT TO FILE 66, WHICH IS
C  THEN READ BY SUBROUTINE READBLOCK.

C  THIS ROUTINE IS BASED ON THE STAND-A-LONE PROGRAM, CSVCHANGE.FOR.
C  AS OF IT2B104.FOR, THIS ROUTINE IS BASED ON CSVCHANGE2.FOR.

C  CSVCHANGE.FOR                                           12/6/11

C  THIS PROGRAM CONVERTS THE NEW-STYLE .csv FILES (WITH TWO ADDITIONAL
C  COLUMNS (ADDL AND II) TO THE PREVIOUS .csv FORMAT.

C  ADDL GIVES THE NO. OF ADDITIONAL DOSES FOR ANY DOSE EVENT, AND II
C  GIVES THE INTERDOSE INTERVAL FOR THE ADDITIONAL DOSES.

C  EX: IF TIME = 0, DUR = 2, DOSE = 1000, ADDL = 2, II = 12, THIS
C  PROGRAM WOULD PUT IN TWO EXTRA LINES AS FOLLOWS:

C  TIME    DUR    DOSE  ADDL  II    
C   0       2     1000   2    12  <-- ONLY LINE IN NEW-STYLE FILE
C  12       2     1000   <-- THESE TWO LINES ARE ADDED TO THE OLD
C  24       2     1000       STYLE FILE (WHICH DOESN'T HAVE ADDL AND
C                            II COLUMNS.

C  NOTE THAT ADDL = -1 IS A STEADY STATE DOSE INDICATOR. IN THIS CASE,
C  CHANGE THE TIME OF THE DOSE TO -II, SO SUBROUTINES READBLOCK/WRITEDOS

C  WILL RECOGNIZE THE LINE AS THE BEGINNING OF A STEADY STATE DOSE SET.


C  NOTE THAT ONCE ALL THE ADDITIONAL DOSES ARE ADDED TO THE DOSE
C  ARRAY, THEY MUST ALL BE ORDERED AMONG THEMSELVES (UNTIL THE NEXT
C  DOSE/TIME RESET) SINCE READBLOCK EXPECTS ORDERED DOSES. BUT IT IS
C  OK FOR ALL THE DOSES IN A GIVEN REGION TO COME FIRST, AND THEN ALL
C  THE OBSERVATIONS TO FOLLOW (I.E., THE DOSES SHOULD BE ORDERED AMONG
C  THEMSELVES AND THE OBSERVATIONS FOLLOW THE DOSES, ORDERED AMONG
C  THEMSELVES).

C  NOTE THAT ADDL AND II ENTRIES ARE IGNORED IF EVID = 0 (I.E.,THE
C  EVENT IS AN OBSERVATION).

C  NOTE THAT IF ADDL AND II ARE MISSING FOR A DOSE EVENT (EVID = 1 OR
C  4) THEN ADDL IS ASSUME TO BE 0 (NO ADDITIONAL DOSES) AND II IS
C  IRRELEVANT.

C  NOTE THAT THIS PROGRAM WILL OPEN AND READ THE NEW-STYLE .csv
C  FILE FROM FILE 67, AND THEN WRITE THE PREVIOUS .csv FORMAT TO FILE
C  66.

      IMPLICIT REAL*8(A-H,O-Z)
      DIMENSION TIMENTRY(99999),IDENTRY(99999)

      CHARACTER READLINE*1000,CODEPAT*15,
     1 READLINE2*1000,HOLDMAT(99999)*150,TIMCHAR*50,SUBID*11,
     2 SUBIDPREV*11,ERRFIL*20



      COMMON/ERROR/ERRFIL
C  COMMON/ERROR/ IS SUPPLIED TO ALL THE ROUTINES WHICH COULD WRITE TO
C  ERRFIL.

    1 FORMAT(A1000)
    2 FORMAT(A20)

      OPEN(66)

      ICODEPAT = 0


    6 FORMAT(A15)
      ICODEPAT = -1


      READ(67,6) CODEPAT
      IF(CODEPAT .EQ. '"POPDATA DEC_11') ICODEPAT = 1
      IF(CODEPAT(1:14) .EQ. 'POPDATA DEC_11') ICODEPAT = 1

      IF(CODEPAT .EQ. '"POPDATA APR_11') ICODEPAT = 0
      IF(CODEPAT(1:14) .EQ. 'POPDATA APR_11') ICODEPAT = 0


      IF(ICODEPAT .EQ. -1) THEN



       WRITE(*,7)


    7  FORMAT(//' YOUR PATIENT DATA BLOCK FILE IS NOT FROM THE'/
     1' ALLOWABLE SET OF SUCH FILES.'//
     2' A PATIENT DATA BLOCK FILE MUST HAVE "POPDATA XXX_XX IN'/
     3' COLUMNS 1 THROUGH 15 ON LINE 1, WHERE  XXX_XX  IS APR_11 OR A '/
     4' MORE RECENT DATE.'//)
       WRITE(*,*)' THE PROGRAM STOPS.'

        OPEN(42,FILE=ERRFIL)
         WRITE(42,7) 
         WRITE(42,*)' THE PROGRAM STOPS.'
        CLOSE(42)	



       CALL PAUSE
       STOP



      ENDIF

C  IF ICODEPAT = 0, THE INPUT .csv FILE IS ALREADY IN THE CORRECT FORM
C  TO BE READ BY SUBROUTINE READBLOCK. IN THIS CASE, JUST COPY FILE 67,
C  LINE BY LINE TO FILE 66.

      IF(ICODEPAT .EQ. 0) THEN

C  WRITE THE TOP LINE (WITH THE CODE) TO FILE 66.


       CODEPAT = 'POPDATA APR_11'
       WRITE(66,6) CODEPAT

 1020  READ(67,1,IOSTAT=IEND) READLINE
        IF(IEND .LT. 0) THEN
         CLOSE(67)
         RETURN
        ENDIF
       WRITE(66,1) READLINE
       GO TO 1020

      ENDIF


C  ICODEPAT = 1. SO WRITE THE INFO IN FILE 67 TO FILE 66 IN THE OLD
C  FORMAT (WITHOUT THE TWO COLUMNS FOR ADDL AND II).

C  WRITE THE TOP LINE (WITH THE CODE) TO FILE 66.

      CODEPAT = 'POPDATA APR_11'
      WRITE(66,6) CODEPAT

C  READ THE 2ND LINE OF FILE 67 AND WRITE THIS LINE TO FILE 66, BUT
C  WITHOUT THE ADDL AND II NAMES. 

      READ(67,1) READLINE

C  SEARCH FOR THE CHARACTER STRING  ",ADDL,II"  IN THE EARLY PART OF
C  READLINE AND ELIMINATE IT, BEFORE WRITING THE LINE TO FILE 66. IF
C  THIS STRING IS NOT FOUND, TELL THE USER HIS FILE 67 HAS AN ERROR IN 
C  IT, AND STOP

      DO I = 1,50
       IF(READLINE(I:I+7) .EQ. ',ADDL,II') THEN
        ISS = I
        GO TO 10
       ENDIF
      END DO

C  TO GET HERE MEANS THE ABOVE STRING WAS NEVER FOUND. SO WRITE A 

C  MESSAGE TO THE USER AND STOP.

       WRITE(*,8)
    8  FORMAT(//' YOUR PATIENT DATA BLOCK FILE IS NOT FROM THE '/
     1' ALLOWABLE SET OF SUCH FILES.'//
     2' A PATIENT DATA BLOCK FILE MUST HAVE ",ADDL,II" AS THE 6TH AND'/
     3' 7TH COLUMN HEADINGS ON LINE 2.'//)
       WRITE(*,*)' THE PROGRAM STOPS.'

        OPEN(42,FILE=ERRFIL)
         WRITE(42,8) 
         WRITE(42,*)' THE PROGRAM STOPS.'
        CLOSE(42)



       CALL PAUSE
       STOP


   10 CONTINUE

C  PUT ALL OF READLINE, EXCEPT ENTRIES ISS:ISS+7 INTO READLINE2,
C  AND WRITE READLINE2 INTO FILE 66.

      READLINE2(1:ISS-1) = READLINE(1:ISS-1)
      READLINE2(ISS:992) = READLINE(ISS+8:1000)

      WRITE(66,1) READLINE2


C  EACH LINE IN FILE 67, STARTING WITH LINE 3 (EXCEPT FOR LINES 
C  BEGINNING WITH #) HAS A SUBJECT ID IN THE 1ST 11 ENTRIES. THEN
C  THE ENTRIES ARE, IN ORDER, EVID, TIME, DUR, DOSE, ADDL, II, INPUT,
C  ...



C  READ EACH DOSE LINE (EVID = 1 OR 4) TO OBTAIN THE VALUES OF ADDL AND
C  II FOR THOSE. ADDL IS THE NO. OF ADDITIONAL DOSE LINES THAT ARE 

C  IDENTICAL TO THE CURRENT LINE, AND II IS THE ASSOCIATED INTERDOSE
C  INTERVAL. IF ADDL = -1, THIS REPRESENTS A STEADY STATE SET OF DOSES.

C  FOR A DOSE LINE, IF ADDL = 0 OR IS MISSING (WHICH MEANS ADDL IS
C  ASSUMED TO BE 0), WRITE THE LINE, WITHOUT THE ADDL AND II VALUES,
C  INTO HOLDMAT. 

C  FOR EACH DOSE LINE WITH AN ADDL > 0, WRITE THAT LINE
C  WITHOUT THE ADDL AND II VALUES, AND ADDL MORE SIMILAR LINES INTO THE
C  HOLDMAT, MAKING SURE THAT THE TIME FOR EACH SUCCESSIVE LINE
C  IS INCREASED BY II FROM THE PREVIOUS LINE.

C  NOTE THAT THE ABOVE PROCESS CAN CAUSE THE DOSE LINES TO BE OUT OF
C  ORDER IN HOLDMAT. EACH BLOCK OF DOSE LINES WILL BE 
C  ORDERED UP TO THE NEXT DOSE/TIME RESET LINE BELOW. AND NOTE THAT
C  ALL THE DOSES IN EACH REGION (UNTIL THE NEXT TIME RESET LINE - I.E.,
C  UNTIL THE NEXT EVID = 4) WILL BE WRITTEN TOGETHER, AND THEN BE
C  FOLLOWED BY ALL THE OBSERVATION LINES IN THAT REGION).


C  NOTE BELOW THAT AFTERCOMMA OPENS AND PUTS INTO FILE 57 THE PART OF
C  READLINE WHICH IS BETWEEN COMMA C AND COMMA C+1, WHERE C IS THE 3RD
C  ARGUMENT. ALSO,NOTE THAT NCOVA MUST BE PROVIDED TO AFTERCOMMA SO IT
C  WILL KNOW THE TOTAL NO. OF COMMAS IN READLINE, WHICH = 13 + NCOVA 

C  SINCE THIS FILE HAS 14 FIXED FIELDS (COUNTING THE 2 NEWS ONES, 
C  ADDL AND II).
C  
C  SO, FIRST FIND NCOVA FROM READLINE JUST READ IN (THE 2ND LINE OF THE
C  .csv FILE).

        NCOMMA = 0

        DO ISTART = 1,1000	 
         IF(READLINE(ISTART:ISTART) .EQ. ',') THEN
          NCOMMA = NCOMMA + 1
         ENDIF
        END DO

        NCOVA = NCOMMA - 13

C  INITIALIZE SUBIDPREV (THE PREVIOUS SUBJECT ID), AND THE CURRENT
C  SUBJECT TO BE '%^&*'.

	SUBIDPREV = '%^&*'
	SUBID = '%^&*'
      NROW = 0


C  NROW IS THE RUNNING INDEX OF THE NEXT LINE TO BE PUT INTO THE
C  HOLDMAT.



   20 READ(67,1,IOSTAT=IEND) READLINE


C  IF IEND .LT. 0, THE FILE HAS BEEN READ THROUGH COMPLETELY, SO GO TO
C  LABEL 100 TO WRITE THE LAST SUBJECT'S ROWS TO FILE 66.

	IF(IEND .LT. 0) GO TO 100


C  IF READLINE(1:1) IS #, THIS LINE IS A COMMENT LINE AND CAN BE
C  SKIPPED (I.E., NOT WRITTEN INTO HOLDMAT).

      IF(READLINE(1:1) .EQ. '#') GO TO 20


C  WILL ALSO GO TO LABEL 100 IF THIS SUBJECT ID IS DIFFERENT THAN
C  SUBIDPREV (SINCE THAT MEANS THAT THE PREVIOUS SUBJECT'S LINES ARE
C  READY TO BE WRITTEN TO FILE 66).    

C  THE FIRST VALUE (I.E., AFTER COMMA NO. 0) IS THE SUBJECT ID.

	CALL AFTERCOMMA(NCOVA,READLINE,0)
	BACKSPACE(57)
	READ(57,222) SUBID
  222 FORMAT(A11)
	CLOSE(57)


C  NOTE THAT SUBID CONTAINS THE 1ST 11 CHARACTERS OF THE LINE, BUT THE
C  SUBJECT ID IS JUST THE SET OF CHARACTERS PRIOR TO THE 1ST COMMA.
C  CALL SUBROUTINE GETID TO CORRECT THE VALUE OF SUBID.

	CALL GETID(SUBID)

      IF(SUBID .NE. SUBIDPREV) GO TO 100


C  TO GET TO THIS POINT, SUBID = SUBIDPREV, WHICH MEANS THIS IS A
C  LINE FOR THE CURRENT SUBJECT.

C  IF THE EVENT ID, IN ENTRY NO. 2 (I.E., AFTER COMMA NO. 1) IN 
C  READLINE IS 0, THE LINE REPRESENTS AN OBSERVATION AND CAN BE WRITTEN

C  INTO HOLDMAT, EXCEPT FOR ADDL AND II AS DONE ABOVE.

	CALL AFTERCOMMA(NCOVA,READLINE,1)
	BACKSPACE(57)
	READ(57,*) IDEVENT
	CLOSE(57)

      IF(IDEVENT .EQ. 0) THEN
       NROW = NROW + 1
       CALL GETCOM(NCOMMA,READLINE,I5,I7)
       HOLDMAT(NROW) = READLINE(1:I5)//READLINE(I7+1:150)
      ENDIF

C  IF THE EVENT ID IS 1 OR 4, THE LINE REPRESENTS A DOSE
C  EVENT (1 -> REGULAR DOSE; 4 -> TIME RESET EVENT WITH A DOSE). EITHER
C  WAY IF THE ENTRY FOR ADDL IS MISSING OR A 0, IT MEANS THAT THIS LINE
C  REPRESENTS A SINGLE DOSE. IF ADDL > 0, THIS LINE MUST BE COPIED
C  ADDL TIMES. NOTE THAT THE ADDL ENTRY IS NO. 6, AFTER COMMA NO. 5.

      IF(IDEVENT .EQ. 1 .OR. IDEVENT .EQ. 4) THEN

       CALL AFTERCOMMA(NCOVA,READLINE,5)
       BACKSPACE(57)
       READ(57,*,ERR=25) IADDL
       CLOSE(57)
       GO TO 30

   25  IADDL = 0

C  TO GET TO LABEL 25 MEANS IADDL TRIED TO READ A NON-NUMBER, WHICH 
C  MEANS IT IS MISSING --> IT IS EQUIVALENT TO 0. IN THIS CASE, WRITE
C  THE LINE INTO HOLDMAT, EXCEPT FOR IADDL AND II AS 
C  DONE ABOVE.

   30  CONTINUE
       
       IF(IADDL .GE. 0) THEN
        NROW = NROW + 1
        CALL GETCOM(NCOMMA,READLINE,I5,I7)
        HOLDMAT(NROW) = READLINE(1:I5)//READLINE(I7+1:150)
       ENDIF


       IF(IADDL .GT. 0) THEN

C  THIS LINE MUST BE COPIED IADDL TIMES, BUT EACH LINE MUST HAVE ITS 
C  TIME ENTRY INCREASED BY XII (THE INTERDOSE INTERVAL) FROM THE 

C  PREVIOUS LINE. FIRST FIND THE VALUE OF XII, IN THE 7TH ENTRY, AFTER
C  THE 6TH COMMA. IF XII IS MISSING, STOP THE PROGRAM TELLING THE USER
C  THAT THE .cvs FILE HAS AN ERROR; IT HAS A ROW WITH AN IADDL > 0, BUT
C  WITH AN ACCOMPANYING INTERDOSE INTERVAL WHICH IS MISSING. NOTE THAT
C  THIS LINE NO. IS 2 (THE TOP 2 LINES) + NROW + 1 = NROW + 3.

	  CALL AFTERCOMMA(NCOVA,READLINE,6)
	  BACKSPACE(57)
	  READ(57,*,ERR=35) XII
	  CLOSE(57)
        GO TO 40
        
   35   WRITE(*,36) NROW + 3
   36   FORMAT(/' THE INTERDOSE INTERVAL IS MISSING ON LINE NO. ',I6//
     1' PLEASE CORRECT YOUR .csv FILE AND RERUN THE PROGRAM.'/)


        OPEN(42,FILE=ERRFIL)
         WRITE(42,36) NROW + 3 
        CLOSE(42)	



        CALL PAUSE
        STOP





   40   CONTINUE

C  THE TIME FOR THE ORIGINAL DOSE IS IN ENTRY NO. 3, AFTER COMMA NO. 2.

	  CALL AFTERCOMMA(NCOVA,READLINE,2)
	  BACKSPACE(57)
	  READ(57,*) TIM
	  CLOSE(57)

        DO IADD = 1,IADDL

C  NOTE THAT THE ORIGINAL LINE FOR THIS DOSE HAS ALREADY BEEN WRITTEN
C  TO HOLDMAT (IN THE IF(IADDL .GE. 0) SECTION ABOVE). SO
C  NOW MUST WRITE IADDL LINES TO HOLDMAT, EACH IDENTICAL TO
C  THE CURRENT LINE, EXCEPT EACH TIM WILL BE INCREMENTED BY
C  XII. TO DO THIS, WRITE THE NEXT TIM + XII TO SCRATCH FILE 57; THEN
C  REREAD THIS VALUE AS A CHARACTER SO IT CAN BE INSERTED INTO
C  THE CHARACTER STRING READLINE AND THEN WRITTEN TO THE HOLDING
C  MATRIX.


C  FIRST RESET READLINE TO HOLDMAT(NROW), WHICH DOES NOT HAVE THE
C  ADDL AND II ENTRIES.

         READLINE(1:150) = HOLDMAT(NROW)

         OPEN(57,STATUS='SCRATCH')

         WRITE(57,*) TIM + XII*IADD
         BACKSPACE(57)
         READ(57,41) TIMCHAR



   41    FORMAT(A50)

C  TAKE OUT ALL SPACES AT THE END OF TIMCHAR.

         DO IEND = 50,1,-1
          IF(TIMCHAR(IEND:IEND) .NE. ' ') GO TO 50
         END DO

   50    CONTINUE

C  NOW TIMCHAR(1:IEND) IS THE CONDENSED FORM OF THE TIME FOR THIS
C  ROW. REPLACE WHAT IS CURRENTLY BETWEEN COMMAS 2 AND 3 OF 
C  HOLDMAT(NROW) WITH THIS, AND STORE IT INTO THE NEXT ROW OF HOLDMAT.

         ICOMMA = 0

         DO I = 1,150


          IF(READLINE(I:I) .EQ. ',') THEN
           ICOMMA = ICOMMA + 1
           IF(ICOMMA .EQ. 2) I2 = I
           IF(ICOMMA .EQ. 3) THEN
            I3 = I
            GO TO 60
           ENDIF
          ENDIF
         END DO

   60    READLINE2 =
     1    READLINE(1:I2)//TIMCHAR(1:IEND)//READLINE(I3:150)


         NROW = NROW + 1         
         HOLDMAT(NROW) = READLINE2(1:150)
         
        END DO

C  THE ABOVE END DO IS FOR THE  DO IADD = 1,IADDL  LOOP.


       ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(IADDL .GT. 0)  CONDITION.



       IF(IADDL .EQ. -1) THEN


C  WRITE JUST ONE LINE TO THE NEW .CSV FILE, EVEN THOUGH IADDL = -1
C  REPRESENTS A STEADY STATE DOSE SET OF 100 DOSES. MAKE THE TIME FOR
C  THIS EVENT = -II SO READBLOCK/WRITEDOS WILL KNOW THIS IS A LINE WITH
C  STEADY STATE DOSE INFO.

	  CALL AFTERCOMMA(NCOVA,READLINE,6)
	  BACKSPACE(57)
	  READ(57,*,ERR=65) XII
	  CLOSE(57)

        GO TO 70
        
   65   WRITE(*,36) NROW + 3

        OPEN(42,FILE=ERRFIL)
         WRITE(42,36) NROW + 3 
        CLOSE(42)	



        CALL PAUSE
        STOP

   70   CONTINUE

C  NOW ESTABLISH THE NEXT LINE OF HOLDMAT AS THE CURRENT
C  READLINE, BUT WITHOUT THE ENTRIES FOR ADDL AND II; THEN RESET
C  READLINE TO BE THIS NEW LINE.

        NROW = NROW + 1
        CALL GETCOM(NCOMMA,READLINE,I5,I7)
        HOLDMAT(NROW) = READLINE(1:I5)//READLINE(I7+1:150)
        READLINE(1:150) = HOLDMAT(NROW)


C  NOW ESTABLISH READLINE2 = READLINE, BUT WITH THE TIME VALUE RESET

C  TO BE TIME = -XII. TO DO THIS, WRITE -XII TO SCRATCH FILE 57; THEN
C  REREAD THIS VALUE AS A CHARACTER SO IT CAN BE INSERTED INTO
C  THE CHARACTER STRING READLINE AND THEN WRITTEN TO THE HOLDING
C  MATRIX.

         OPEN(57,STATUS='SCRATCH')

         WRITE(57,*) -XII
         BACKSPACE(57)
         READ(57,41) TIMCHAR

C  TAKE OUT ALL SPACES AT THE END OF TIMCHAR.

         DO IEND = 50,1,-1
          IF(TIMCHAR(IEND:IEND) .NE. ' ') GO TO 80
         END DO

   80    CONTINUE

C  NOW TIMCHAR(1:IEND) IS THE CONDENSED FORM OF THE TIME FOR THIS
C  ROW. REPLACE WHAT IS CURRENTLY BETWEEN COMMAS 2 AND 3 OF 
C  HOLDMAT(NROW) WITH THIS, AND STORE IT BACK INTO THE SAME ROW OF 
C  HOLDMAT.

         ICOMMA = 0

         DO I = 1,150
          IF(READLINE(I:I) .EQ. ',') THEN
           ICOMMA = ICOMMA + 1
           IF(ICOMMA .EQ. 2) I2 = I
           IF(ICOMMA .EQ. 3) THEN
            I3 = I
            GO TO 90
           ENDIF

          ENDIF
         END DO

   90    READLINE2 =
     1    READLINE(1:I2)//TIMCHAR(1:IEND)//READLINE(I3:150)
         HOLDMAT(NROW) = READLINE2(1:150)


       ENDIF 


C  THE ABOVE ENDIF IS FOR THE  IF(IADDL .EQ. -1)  CONDITION.


      ENDIF

C  THE ABOVE ENDIF IS FOR THE  
C   IF(IDEVENT .EQ. 1 .OR. IDEVENT .EQ. 4)  CONDITION.


      GO TO 20


  100 CONTINUE



C  THE FIRST TWO LINES OF FILE 66 WERE WRITTEN ABOVE. NOW WRITE THE 
C  REST OF THE FILE.

C  NOTE THAT IN EACH SECTION OF DOSES (I.E., UNTIL THE NEXT IDEVENT 
C  = 4), MUST ORDER THE DOSES SINCE THEY COULD BE OUT OF ORDER DUE TO
C  THE ADDL ENTRY. 


C  FOR EXAMPLE, A DOSE OF T = 0 WITH ADDL = 2 AND II = 12 --> DOSES AT
C  T = 0, 12, AND 24. THEN ANOTHER DOSE (FOR A DIFFERENT DRUG, OR THE
C  SAME DRUG WITH A DIFFERENT ROUTE) COULD OCCUR AT T = 8. THEN, FROM
C  THE ABOVE CODE, THE CURRENT DOSE TIMES WOULD BE [0 12 24 8].

C  SO GO THROUGH THE NROW ROWS OF HOLDMAT, AND ORDER THE ROWS IN EACH
C  SECTION (I.E., UNTL THE NEXT IDEVENT = 4 ROW). IN PARTICULAR, FIRST
C  ORDER THE DOSE ROWS (IDEVENT = 1). IF THESE ROWS FOLLOW AN 
C  IDEVENT = 4 ROW, THAT ROW GOES FIRST OF COURSE. THEN WRITE IN THE
C  OBSERVATION ROWS (THEY SHOULD ALREADY BE IN ORDER).

C  PUT ALL THE IDEVENT ENTRIES IN HOLDMAT INTO IDENTRY(.), AND PUT ALL
C  THE TIME ENTRIES IN HOLDMAT INTO TIMENTRY(.).

      DO I = 1,NROW

       READLINE(1:150) = HOLDMAT(I)

       CALL AFTERCOMMA(NCOVA,READLINE,1)
	 BACKSPACE(57)
	 READ(57,*) IDEVENT
       IDENTRY(I) = IDEVENT
	 CLOSE(57)

       CALL AFTERCOMMA(NCOVA,READLINE,2)
	 BACKSPACE(57)
	 READ(57,*) TIM
       TIMENTRY(I) = TIM
	 CLOSE(57)

      END DO


      NN = 0
      NFIRST = 1

C  NN IS THE RUNNING INDEX OF THE ROW IN HOLDMAT UNDER CONSIDERATION.
C  NFIRST IS THE RUNNING INDEX OF THE FIRST ROW IN THE NEXT SECTION
C  UNDER CONSIDERATION.

  150 CONTINUE

C  ORDER ALL THE ROWS UNTIL THE NEXT IDENTRY(.) = 4, OR UNTIL THE 
C  END OF THE ROWS IS ENCOUNTERED, WHICHEVER COMES FIRST.

      NN = NN + 1
      IF(NN .GT. NROW) GO TO 200

      IF(IDENTRY(NN) .NE. 4 .AND. NN .LT. NROW) GO TO 150

C  ORDER THE ENTRIES IN HOLDMAT FROM NFIRST TO EITHER NROW
C  (IF NN = NROW) OR TO NN-1 (IF IDENTRY(NN) = 4), AND THEN
C  WRITE THEM INTO FILE 66.

      IF(NN .EQ. NROW) NLAST = NROW
      IF(IDENTRY(NN) .EQ. 4) NLAST = NN - 1
      CALL ORDERHOLD(HOLDMAT,NFIRST,NLAST,IDENTRY,TIMENTRY)

  151 FORMAT(A150)


      DO I = NFIRST,NLAST
       WRITE(66,151) HOLDMAT(I)
      END DO      

      NFIRST = NLAST + 1

      GO TO 150

     
  200 CONTINUE

C  IF FILE 67 HAS BEEN COMPLETELY READ, RETURN.

	IF(IEND .LT. 0) THEN
       CLOSE(67)
       RETURN

      ENDIF


C  SINCE IEND .GE. 0, THE FILE HAS NOT BEEN COMPLETELY READ. SO, RESET

C  SUBIDPREV = SUBID AND NROW TO BE 0, AND BACKSPACE FILE 67 SINCE THE
C  FIRST LINE FOR THE NEXT SUBJECT WAS ALREADY READ (I.E., THE NEXT
C  READ OF FILE 67 SHOULD REREAD THIS FIRST LINE) AND GO BACK TO LABEL
C  20 TO CONTINUE READING THE FILE.


      SUBIDPREV = SUBID
      NROW = 0
      BACKSPACE(67)
      GO TO 20


      END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
      SUBROUTINE GETCOM(NCOMMA,READLINE,I5,I7)

      CHARACTER READLINE*1000,ERRFIL*20




      COMMON/ERROR/ERRFIL
C  COMMON/ERROR/ IS SUPPLIED TO ALL THE ROUTINES WHICH COULD WRITE TO
C  ERRFIL.

C  GETCOM IS CALLED BY CVSCHANGE TO FIND THE ENTRY NO. FOR COMMA NO. 5
C (I5), AND THE ENTRY FOR COMMA NO. 7 (I7).

    1 FORMAT(A1000)
 
      ICOMMA = 0

      DO I = 1,300
       IF(READLINE(I:I) .EQ. ',') THEN
        ICOMMA = ICOMMA + 1


         IF(ICOMMA .EQ. 5) I5 = I


          IF(ICOMMA .EQ. 7) THEN
           I7 = I
           RETURN
          ENDIF
       ENDIF
      END DO

C  TO GET TO THIS POINT MEANS THAT READLINE DOESN'T HAVE 7 COMMAS IN
C  IT. REPORT THIS ERROR TO THE USER AND STOP.

      WRITE(*,2) NCOMMA,READLINE(1:70)

    2 FORMAT(/' ONE OF THE LINES IN YOUR .cvs FILE HAS AN ERROR.'/
     1' IT IS SUPPOSED TO HAVE ',I2,' COMMAS, BUT IT HAS FEWER THAN'/
     2' 7. THE FOLLOWING LINE SHOWS THE 1ST 70 CHARACTERS OF THE LINE:'/
     3' ',A70//
     4' THE PROGRAM STOPS.'/)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,2) NCOMMA,READLINE(1:70)
        CLOSE(42)
	


      CALL PAUSE
      STOP
    
      END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
      SUBROUTINE ORDERHOLD(HOLDMAT,NFIRST,NLAST,IDENTRY,TIMENTRY)


      IMPLICIT REAL*8(A-H,O-Z)

      DIMENSION TIMENTRY(99999),IDENTRY(99999),IZ(99999),IZZ(99999),
     1 DOSTIME(99999)
      CHARACTER HOLDMAT(99999)*150,HOLDMAT2(99999)*150

C  ORDER THE ENTRIES IN HOLDMAT FROM NFIRST TO NLAST, AS FOLLOWS:


C  1. PUT ALL THE DOSE EVENTS (IDENTRY(.) = 1 OR 4) FIRST, ORDERED BY
C  INCREASING TIMENTRY(.).

C  2. PUT ALL THE OBSERVATION EVENTS (IDENTRY(.) = 0) AFTER THE DOSE
C  EVENTS (THEY SHOULD ALREADY BE ORDERED).


C  FIRST, STORE THE DOSE ROWS FROM NFIRST TO NLAST IN HOLDMAT TO 
C  HOLDMAT2, STARTING AT ROW 1 IN HOLDMAT2.

C  ALSO, PUT ALL THE DOSE EVENTS TIMES INTO DOSTIME, AND INITIALIZE

C  VECTOR IZ TO BE -99 IN ALL ITS NDOSE LOCATIONS

      NDOSE = 0

      DO I = NFIRST,NLAST
       IF(IDENTRY(I) .EQ. 1 .OR. IDENTRY(I) .EQ. 4) THEN
        NDOSE = NDOSE + 1
        HOLDMAT2(NDOSE) = HOLDMAT(I)
        DOSTIME(NDOSE) = TIMENTRY(I)
        IZ(NDOSE) = -99
       ENDIF
      END DO

C  NOW, FOR EXAMPLE, IF ENTRY 17 IS THE SMALLEST VALUE IN DOSTIME,
C  IZ(17) WILL BE SET = 0, AND THE PROGRAM WILL KNOW NOT TO CHECK THE
C  17TH ENTRY AGAIN (SINCE IT HAS ALREADY BEEN SELECTED). IF THE NEXT
C  SMALLEST ENTRY HAS INDEX 37, THEN IZ(37) WILL BE SET = 0, ETC.

C  NOTE THAT IZZ WILL BE THE ARRAY WHICH CONTAINS THE ACTUAL ORDERING.
C  IN THE EXAMPLE ABOVE, IZZ(1) = 17, IZZ(2) = 37. IT WILL BE EASY TO
C  ASSIGN ORDERED VALUES BACK INTO HOLDMAT USING IZZ. IN THE EXAMPLE
C  ABOVE, HOLDMAT(1) WILL HAVE DOSE TIME = DOSTIME(IZZ(1)) =
C  DOSTIME(17); HOLDMAT(2) WILL HAVE DOSE TIME = DOSTIME(IZZ(2)) =
C  DOSTIME(37); ETC.


C  NOW PUT THE OBSERVATION ROWS FROM NFIRST TO NLAST IN HOLDMAT TO
C  HOLDMAT2, STARTING AT ROW NDOSE + 1 IN HOLDMAT2.

      NEXT = NDOSE

      DO I = NFIRST,NLAST
       IF(IDENTRY(I) .EQ. 0) THEN
        NEXT = NEXT + 1
        HOLDMAT2(NEXT) = HOLDMAT(I)
       ENDIF
      END DO


C  NOW ORDER THE FIRST NDOSE ROWS IN HOLDMAT2 ACCORDING TO THE DOSE
C  TIMES, LOW TO HIGH.

	 DO IPLACE = 1,NDOSE

C  PUT THE NEXT LOWEST VALUE OF DOSTIME INTO THE IPLACE LOCATION OF
C  IZZ.

C  TEMP IS THE RUNNING VALUE OF THE NEXT VALUE TO BE PLACED INTO 
C  DOSTIME. INITIALIZE IT TO BE VERY HIGH VALUE SO THE FIRST VALUE 

C  OF DOSTIME WILL BE SURE TO BE LOWER THAN IT IS.

	  TEMP = 1.D50


	  DO I=1,NDOSE
	   IF(DOSTIME(I) .LT. TEMP .AND. IZ(I) .EQ. -99) THEN
	    TEMP = DOSTIME(I)
	    IND = I
	   ENDIF
	  END DO

C  AT THIS POINT, IND IS THE INDEX OF THE SMALLEST REMAINING VALUE
C  (TEMP) IN DOSTIME. PUT THIS INFORMATION INTO IZZ. ALSO, SET
C  IZ(IND) = 0 --> THE IND LOCATION IN DOSTIME HAS BEEN USED.

	  IZZ(IPLACE) = IND
	  IZ(IND) = 0

	 END DO


C  AT THIS POINT IZZ CONTAINS THE ORDERED INDICES (LOW TO HIGH) OF THE
C  NDOSE VALUES IN DOSTIME, AND SO GIVES THE ORDER THAT THE NDOSE ROWS
C  NOW IN HOLDMAT2 SHOULD BE WRITTEN.

C  WRITE THESE NDOSE DOSE ROWS IN THE CORRECT ORDER INTO HOLDMAT, AND
C  THEN WRITE THE REMAINING ROWS (OBSERVATION ROWS) INTO HOLDMAT. 

      DO IDOSE = 1,NDOSE
       HOLDMAT(NFIRST-1+IDOSE) = HOLDMAT2(IZZ(IDOSE))
      END DO

C  STORE THE OBSERVATION ROWS INTO ENTRIES NFIRST + NDOSE,..., NLAST OF
C  HOLDMAT. THEY WERE STORED INTO THE LAST NOBS ROWS OF HOLDMAT2 ABOVE. 

      NEXT = NDOSE

      DO IOBS = NFIRST + NDOSE,NLAST
       NEXT = NEXT + 1
       HOLDMAT(IOBS) = HOLDMAT2(NEXT)
      END DO
     
       
      RETURN
      END


C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
      SUBROUTINE PREDLAST3(NN,NSET,XSTORE,XPRED,ICONV)

      IMPLICIT REAL*8(A-H,O-Z)

      DIMENSION XSTORE(100,20),XPRED(20),COMP(5,20)


C  NOTE THAT AS OF MONT109.FOR, THE DIMENSIONS OF 6 IN XSTORE, XPRED,
C  AND COMP HAVE BEEN CHANGED TO 20, WHICH IS WHAT THEY SHOULD HAVE BEEN
C  ALL ALONG (SEE SUBROUTINE FUNC2).


C  THIS SUBROUTINE IS CALLED BY SUBROUTINE FUNC WITH NSET SETS OF NN
C  COMPARTMENT  VALUES IN XSTORE. USE THE LAST 5 SETS OF VALUES TO

C  PREDICT THE FINAL (STEADY STATE) COMPARTMENT AMOUNTS AFTER THE LAST
C  (100TH) DOSE SET. NOTE THAT AS OF MONT110.FOR, THERE WILL ALSO BE AN 
C  ADDITIONAL 101ST DOSE SET APPLIED. BUT THE PREDICTION SHOULD STILL
C  BE AFTER THE 100TH SET.


C  IF THESE VALUES "CONVERGE", SET ICONV = 1, AND WRITE THE PREDICTED
C  VALUES INTO XPRED. IF THEY DON'T CONVERGE, SET ICONV = 0.

C  TOL1 AND TOL2 ARE, FOR NOW, HARDCODED TO BE .0005.

        TOL1 = .0005D0
        TOL2 = .0005D0



C  THE LAST 5 SETS OF VALUES ARE IN XSTORE(NSET-4:NSET,.). PUT THESE
C  VALUES INTO COMP(.,.).

      II = 0
    
      DO I = NSET-4,NSET
       II = II+1
       DO J = 1,NN
        COMP(II,J) = XSTORE(I,J)
       END DO
      END DO



C  FOR EACH COMPARTMENT AMOUNT, SEE IF THE FINAL STEADY STATE COMP.
C  AMOUNT CAN BE PREDICTED ACCURATELY.

      DO IN = 1,NN


       A1 = COMP(1,IN)
       A2 = COMP(2,IN)
       A3 = COMP(3,IN)
       DEL1 = A2 - A1
       DEL2 = A3 - A2

C  TEST FOR DEL1 = 0. IF SO, SEE ISAMETOT BELOW.

       CALL THESAME(DEL1,0.D0,ISAME1)

       IF(ISAME1 .EQ. 0) THEN

        F = DEL2/DEL1

C  THE UNDERLYING ASSUMPTION IS THAT THE RATIO F = DEL2/DEL1
C  IS CONTANT BETWEEN CONSECUTIVE OUTPUT DIFFERENCES. IF SO, THEN
C  THE STEADY STATE VALUE WILL BE A1 + DEL1/(1 - F) (SEE SS.EXP
C  IN \ALAN3\STEADYSTATE). CALCULATE THIS VALUE AND CALL IT PRED1.

C  BUT, IF DEL2 = DEL1, THEN F = 1. IN THIS CASE, CAN'T DO THE FOLLOWING 
C  CALCULATION FOR PRED1, AND WE WOULDN'T WANT TO DO IT SINCE 
C  DEL2 = DEL1 --> A2 - A1 = A3 - A2 --> A1, A2, AND A3 ARE IN AN 
C  ARITHMETIC PROGRESSION --> THERE OBVIOUSLY CAN BE NO CONVERGENCE

C  SINCE, AFTER 100 DOSES, THE VALUE WOULD JUST A1 + 99*DEL1 ... 
C  UNLESS DEL1 = 0, IN WHICH CASE THE VALUE WOULD CONVERGE TO A1.
C  IN THIS CASE SET ISAMEF1 = 1, AND SKIP CALC. OF PRED1. AND THEN
C  SEE THE LOGIC RELATED TO ISAMEF1 BELOW.

        CALL THESAME(F,1.D0,ISAMEF1)
        IF(ISAMEF1 .EQ. 0) PRED1 = A1 + DEL1/(1.D0 - F)

       ENDIF


C  SIMILARLY, CALCULATE PRED2 (BASED ON (A2,A3,A4)) AND PRED3 (BASED
C  ON (A3,A4,A5).

       A1 = COMP(2,IN)
       A2 = COMP(3,IN)
       A3 = COMP(4,IN)
       DEL1 = A2 - A1
       DEL2 = A3 - A2


C  TEST FOR DEL1 = 0. IF SO, SEE ISAMETOT BELOW.

       CALL THESAME(DEL1,0.D0,ISAME2)

       IF(ISAME2 .EQ. 0) THEN
        F = DEL2/DEL1


        CALL THESAME(F,1.D0,ISAMEF2)
        IF(ISAMEF2 .EQ. 0) PRED2 = A1 + DEL1/(1.D0 - F)

       ENDIF

       A1 = COMP(3,IN)
       A2 = COMP(4,IN)
       A3 = COMP(5,IN)
       DEL1 = A2 - A1
       DEL2 = A3 - A2


C  TEST FOR DEL1 = 0. IF SO, SEE ISAMETOT BELOW.

       CALL THESAME(DEL1,0.D0,ISAME3)

       IF(ISAME3 .EQ. 0) THEN

        F = DEL2/DEL1


        CALL THESAME(F,1.D0,ISAMEF3)
        IF(ISAMEF3 .EQ. 0) PRED3 = A1 + DEL1/(1.D0 - F)
       ENDIF


C  ASSUMING A NEGATIVE EXPONENTIAL PATTERN FIT (SEE SS.EXP IN 
C  \ALAN3\STEADYSTATE OR HOME NOTES, PG.2 ON 9/11/11 FOR DETAILS) ON
C (PRED1,PRED2,PRED3), CALCULATE PREDNEG.

C  BUT ONLY DO THIS CALCULATION, AND THE SUBSEQUENT 
C  CONVERGENCE DETERMINATION IF ISAME1 = ISAME2 = ISAME3 = 0, AND
C  ISAMEF1 = ISAMEF2 = ISAMEF3 = 0. OTHERWISE, AT LEAST ONE OF THE
C  PREDICTED VALUES ABOVE WAS NOT CALCULATED.

       ISAMETOT = ISAME1 + ISAME2 + ISAME3
       ISAMEFTOT = ISAMEF1 + ISAMEF2 + ISAMEF3


       IF(ISAMETOT .EQ. 0 .AND. ISAMEFTOT .EQ. 0) THEN

C EDITED CODE BELOW FOR MONT103.FOR.

C  IF PRED1 + PRED3 - 2*PRED2 = 0, PREDNEG (SEE BELOW) CANNOT BE 
C  CALCULATED. IN THIS CASE, PRED2 - PRED1 = PRED3 - PRED2 --> 
C  THE SEQUENCE (PRED1, PRED2, PRED3) IS LINEAR, WHICH CANNOT BE 
C  MODELED WITH AN EXPONENTIAL FIT (SEE COMMENTS ABOVE). SO, IF THIS
C  HAPPENS, CONVERGENCE WILL BE SATISFIED IF THESE 3 VALUES ARE 
C  VIRTUALLY THE SAME - I.E., ONLY THE REQUIREMENT INVOLVING TOL1
C  WILL BE NEEDED FOR CONVERGENCE (RECALL THE ONLY REASON FOR THE
C  EXTRA NEGATIVE EXPONENTIAL FIT, AND THE CALCULATION OF PREDNEG IS FOR
C  THOSE CASES WHERE PRED1, PRED2, AND PRED3 ARE NOT ALL VIRTUALLY THE
C  SAME VALUE).

        DEN = PRED1+PRED3-2.D0*PRED2
        CALL THESAME(DEN,0.D0,ISAMEDEN)
      

        IF(ISAMEDEN .EQ. 0)
     1   PREDNEG = (PRED1*PRED3 - PRED2*PRED2)/DEN

C  NOW CHECK FOR CONVERGENCE, WHICH HAS BEEN OBTAINED IF 
C  |PRED3/PRED2 - 1| < TOL1 AND |PREDNEG/PRED3 - 1| < TOL2. 

        ICONV = 1
        IF(DABS(PRED3/PRED2 - 1.D0) .GE. TOL1) ICONV = 0
        IF(ISAMEDEN .EQ. 0 .AND. DABS(PREDNEG/PRED3 - 1.D0) .GE. TOL2)
     1   ICONV = 0


C  IF ICONV = 1 FOR THIS COMPARTMENT, IN, STORE THE PREDICTED AMOUNT,
C  AND CONTINUE TO THE NEXT COMPARTMENT. NOTE BELOW THAT 
C  NON-CONVERGENCE IN ANY COMPARTMENT ENDS THE PROCESS SINCE TO
C  CONVERGE, ALL COMPARTMENT PREDICTIONS MUST CONVERGE.

        IF(ICONV .EQ. 1 .AND. ISAMEDEN .EQ. 1) XPRED(IN) = PRED3 
        IF(ICONV .EQ. 1 .AND. ISAMEDEN .EQ. 0) XPRED(IN) = PREDNEG


C EDITED CODE ABOVE FOR MONT103.FOR.


       ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(ISAMETOT .EQ. 0 .AND. ISAMEFTOT .EQ.0)
C  CONDITION.


C  IF ISAMETOT .GT. 0, THERE ARE TWO POSSIBILITIES (AND NOTE THAT IT
C  DOSEN'T MATTER WHAT ISAMEFTOT IS IN THIS CASE):

C   ISAMETOT = 3, IN WHICH CASE COMP(1:4,IN) ARE ALL THE SAME.
C   ISAMETOT = 1 OR 2, IN WHICH CASE SOME OF THE COMP(1:4,IN) VALUES
C     ARE THE SAME, AND SOME ARE NOT.


C  IN THE FORMER CASE, VERIFY THAT COMP(5,IN) IS THE SAME VALUE AS
C  THE COMP(1:4,IN). IF SO, SET THE PREDICTED VALUE = THIS VALUE
C  (I.E., THE PREDICTED VALUE FOR A CONSTANT FUNCTION IS THE
C  CONSTANT VALUE), AND SET ICONV = 1. OTHERWISE, SET ICONV = 0
C  SINCE THERE IS NO WAY TO FIT 4 VALUES WHICH ARE THE SAME AND ONE
C  WHICH IS NOT USING A NEGATIVE EXPONENTIAL FUNCTION.


C  IN THE LATTER CASE, SINCE SOME OF THE COMP(1:4,IN) VALUES ARE THE
C  SAME, AND SOME ARE NOT, SET ICONV = 0 FOR THE SAME REASON AS 
C  STATED IN THE PREVIOUS PARAGRAPH.

       IF(ISAMETOT .EQ. 3) THEN

        CALL THESAME(COMP(5,IN),COMP(1,IN),ISAME)

        IF(ISAME .EQ. 1) THEN
         ICONV = 1
         XPRED(IN) = COMP(1,IN)
        ENDIF

        IF(ISAME .EQ. 0) ICONV = 0
  
       ENDIF

       IF(ISAMETOT .EQ. 1 .OR. ISAMETOT .EQ. 2) ICONV = 0


C  IF ICONV = 0, CONVERGENCE WAS NOT ACHIEVED.

       IF(ICONV .EQ. 0) RETURN


      END DO

C  THE ABOVE END DO IS FOR THE  DO IN = 1,NN  LOOP.

C  TO GET TO THIS POINT, ALL COMPARTMENT AMOUNTS HAVE CONVERGED, AND
C  THEIR PREDICTED AMOUNTS HAVE BEEN STORED INTO XPRED(IN),IN=1,NN.


      RETURN
      END

C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
      SUBROUTINE NEWWORK1

      IMPLICIT REAL*8(A-H,O-Z)

	PARAMETER(MAXNUMEQ=7)

      DIMENSION SIG(5000),RS(5000,34),DELTAIV(7),ORDELT(7),
     1 RSS(5000,34),SIGG(5000),TIM(594),TIMM(594),YO(594,MAXNUMEQ),
     2 TIMDELAY(99),XVERIFY(900)

      CHARACTER READLINE*300,ERRFIL*20

      COMMON/ERROR/ERRFIL
C  COMMON/ERROR/ IS SUPPLIED TO ALL THE ROUTINES WHICH COULD WRITE TO
C  ERRFIL.

C  SUBROUTINE NEWWORK1 (BASED ON THE STAND-A-LONE VERSION OF THE SAME
C  NAME) READS IN A WORKING COPY PATIENT DATA FILE (IN FILE 31), AND
C  OUTPUTS ANOTHER FILE (FILE 41) WHICH IS:

C  a. EXACTLY THE SAME IF THE ORIGINAL FILE HAS NO STEADY STATE DOSE
C     INDICATORS;

C  OR

C  b. ALTERED TO HAVE THE SAME INFO AS IN THE ORIGINAL FILE, BUT ALSO
C     CONTAINING AN EXTRA 101 DOSES FOR EACH STEADY STATE DOSE 
C     INDICATOR.



C  NOTES:

C  1. A STEADY STATE DOSE INDICATOR IS A NEGATIVE VALUE IN THE TIME
C  ENTRY FOR A DOSE. THIS IS ACCOMPANIED BY INFORMATION ON THE SET OF
C  DOSES IN THE IV AND BOLUS ENTRIES, AS THE FOLLOWING EXAMPLE SHOWS:

C   Time    IV     Bolus
C   -2.0   100.0   150.0 ...

C  THE ABOVE LINE WOULD TELL THE PROGRAM:

C  a. THAT THIS WAS INFO ON 100 STEADY STATE DOSES BECAUSE OF THE 
C     NEGATIVE TIME VALUE;
C  b. THE TIME BETWEEN CONSECUTIVE IV START TIMES = 2 HOURS, BECAUSE 
C     THIS IS THE ABS. VALUE OF THE TIME;
C  C. THE IV RATE = 100MG/HOUR;
C  D. THE TOTAL DRUG AMT. FOR EACH IV DOSE IS 150MG.

C  SO THE PROGRAM WOULD THEN ADD 101 DOSES TO THE PATIENT DATA FILE,
C  STARTING AT T = 0, EACH WITH AN IV RATE = 100, AND CONTINUING FOR
C  1.5 HOURS.

C  2. IT WILL BE ASSUMED THAT EACH STEADY STATE DOSE INDICATOR ALWAYS
C  WILL BE REPLACED BY 101 IV DOSES (NOT BOLUS DOSES).
C  AS OF it2beng19.f, STEADY STATE DOSES MAY BE BOLUS DOSES. IN THIS
C  CASE, THE IV RATE WILL BE 0.0 OF COURSE.



C  3. ALL OTHER TIMES IN THE PATIENT DATA FILE (UP TO THE NEXT TIME 
C  RESET IF THERE IS ONE) WILL BE ASSUMED TO BE TIMES FROM THE END OF 
C  THE 100TH DOSE INTERVAL (NOT THE 101ST). IN THE ABOVE EXAMPLE, THE
C  100TH DOSE INTERVAL WOULD END AT T = 200 (THE 101ST IV ITSELF WOULD
C  END AT T = 201.5, BUT THE 100TH DOSE INTERVAL WOULD END AT T = 200).
C  SO ALL OTHER TIMES IN THE DOSAGE AND OBSERVATION BLOCKS WOULD HAVE
C  200 ADDED TO THEIR VALUES.


C  4. THE ABOVE EXAMPLE IS FOR ONE DRUG ONLY, BUT ANY OR ALL OF THE
C  NDRUGS IN A PATIENT'S FILE CAN HAVE STEADY STATE DOSES. ANY DRUG
C  WHICH HAS A NON-0 VALUE IN THE BOLUS COLUMN OF A STEADY STATE DOSE
C  LINE (I.E., ONE WITH TIME < 0) WILL PARTICIPATE IN A STEADY STATE
C  DOSE SET, GETTING THAT AMOUNT OF DRUG IN EACH OF THE 101 DOSES. IF
C  THE IV COLUMN IS > 0, THEN THE DRUG WILL BE GIVEN AT THE RATE 
C  SHOWN IN THE IV COLUMN. IF THE IV COLUMN IS 0, THEN THE DRUG WILL
C  BE GIVEN AS A BOLUS.

C  5. THE 101 STEADY STATE DOSES CAN BE GIVEN AS THE FIRST SET OF DOSES
C  IN A PATIENT'S FILE, AS INDICATED ABOVE, OR AT ANY TIME RESET. IF
C  THEY ARE AT A TIME RESET, ALL THE SUBSEQUENT TIMES AFTER THAT TIME
C  RESET (UP TO THE NEXT TIME RESET IF THERE IS ONE) ARE ADJUSTED AS 
C  INDICATED ABOVE TO BE TIMES AFTER THE END OF THE 100TH DOSE SET.

C-----------------------------------------------------------------------

C  BEFORE WRITING FILE 31 TO FILE 41, MUST EXAMINE FILE 31 TO SEE IF
C  IT HAS ANY STEADY STATE DOSE INDICATORS. IF IT DOES, IT MEANS THAT
C  THAT PART OF FILE 41 WILL HAVE AN EXTRA SET OF 101 DOSES FOR EACH
C  DRUG.

 1717 FORMAT(A300)

   10 READ(31,1717) READLINE
      IF(READLINE(12:23) .NE. 'NO. OF DRUGS') GO TO 10

C  READLINE NOW CONTAINS THE NO. OF DRUGS, NDRUG. BACKSPACE AND READ
C  NDRUG; THEN READ THE NO. OF ADDITIONAL COVARIATES, AND THE NO. OF
C  DOSE EVENTS. 

    3 FORMAT(T2,I5)

      BACKSPACE(31)
      READ(31,3) NDRUG
      READ(31,3) NADD
      READ(31,3) ND
	NI = 2*NDRUG + NADD

C  IF THERE ARE NO DOSE EVENTS (ND = 0), THE INFO ON FILE 41 WILL BE THE
C  SAME AS ON FILE 31 (SINCE THERE CAN BE NO STEADY STATE DOSE EVENTS IF
C  THERE ARE NO DOSES). IN THIS CASE, SET ICOPY = 1 (SEE BELOW).

      IF(ND .EQ. 0) ICOPY = 1

C  IF ANY SIG(.) IS NEGATIVE, SET ICOPY = 0 SINCE A SIG(.) < 0 IS THE
C  INDICATOR FOR A STEADY STATE SET OF DOSES.


      IF(ND .GE. 1) THEN

       READ(31,*)
       READ(31,*)

       ICOPY = 1

       DO I = 1,ND
        READ(31,*) SIG(I),(RS(I,J),J=1,NI)
        IF(SIG(I) .LT. 0.D0) ICOPY = 0
       END DO


      ENDIF

  
C  IF ICOPY = 1, IT MEANS THAT THIS PATIENT DATA FILE DOES NOT HAVE
C  A STEADY STATE DOSE SET, WHICH MEANS THAT THIS PART OF FILE 31 WILL 
C  BE COPIED LINE FOR LINE TO FILE 41 BELOW.

      IF(ICOPY .EQ. 1) THEN

C  COPY FILE 31 TO FILE 41,LINE FOR LINE.

C  BACKSPACE FILE 31 TO THE FIRST LINE FOR THIS PATIENT.

 1720  BACKSPACE(31)
       BACKSPACE(31)
       READ(31,1717,IOSTAT=IEND) READLINE

	 IF(IEND .LT. 0) THEN

C  NOTE THAT IEND .LT. 0 --> END OF FILE REACHED, BUT IF IT'S REACHED
C  AT THIS POINT, NOT ALL "ACTIVE" NSUB SUBJECT DATA SETS WERE READ
C  AND WRITTEN CORRECTLY TO FILE 41. IN THIS CASE, WRITE A MESSAGE TO
C  THE USER AND STOP.

        WRITE(*,1721)
 1721   FORMAT(/' PATIENT DATA INFORMATION WAS NOT READ CORRECTLY'/
     1' FROM THE INSTRUCTION FILE - IN SUBROUTINE NEWWORK1.')

C  SINCE THE PROGRAM IS TERMINATING ABNORMALLY, WRITE THE ERROR MESSAGE
C  TO ERRFIL ALSO.

        OPEN(42,FILE=ERRFIL)
         WRITE(42,1721)
        CLOSE(42)

	  CALL PAUSE
	  STOP

	 ENDIF

       IF(READLINE(3:16) .NE. 'LAST AND FIRST') GO TO 1720

       WRITE(41,1717) READLINE
     
   30  READ(31,1717) READLINE
       WRITE(41,1717) READLINE
   
       IF(READLINE(12:23) .NE. 'NO. OF DOSE ') GO TO 30

C  THE LINE JUST WRITTEN TO FILE 41 IS THE NO. OF DOSE EVENTS LINE.

C  WRITE THE NEXT TWO LINES ALSO.

       DO I = 1,2
        READ(31,1717) READLINE
        WRITE(41,1717) READLINE
       END DO

C  IF ND = 0, SKIP TO THE OUTPUT SECTION. OTHERWISE, WRITE THE DOSAGE
C  REGIMEN TO FILE 41.


       IF(ND.EQ.0) GO TO 40

       DO I = 1,ND
        READ(31,*) SIG(I),(RS(I,J),J=1,NI)
        WRITE(41,*) SIG(I),(RS(I,J),J=1,NI)
       END DO

C  READ THE NO. OF OUTPUT EQUATIONS FROM THE LINE WITH 'NO. OF TOTAL'
C  AS ENTRIES 12:23. THEN READ NO. OF OBSERVED VALUE TIMES, ETC., AND
C  WRITE THE REST OF THE FILE 31 TO FILE 41.

   40	 READ(31,1717) READLINE
       WRITE(41,1717) READLINE
       IF(READLINE(12:23) .NE. 'NO. OF TOTAL') GO TO 40


       BACKSPACE(31)

       READ(31,3) NUMEQT
       READ(31,3) M

C  BACKSPACE JUST ONCE TO THE LINE WITH M ON IT, SINCE THE LINE WITH

C  NUMEQT ON IT WAS ALREADY PUT INTO FILE 41. 

       BACKSPACE(31)
       READ(31,1717) READLINE
       WRITE(41,1717) READLINE

       DO I = 1,M
        READ(31,*) TIM(I),(YO(I,J),J=1,NUMEQT)
        WRITE(41,*) TIM(I),(YO(I,J),J=1,NUMEQT)
       END DO

C  NOW COPY LINE FOR LINE THE REST OF THIS PATIENT'S INFO TO FILE 41.
C  THIS PATIENT'S INFO WILL END WHEN THE END OF THE FILE IS REACHED
C  (IF THIS IS THE LAST PATIENT), OR WHEN THE START OF THE NEXT
C  PATIENT OCCURS.



   50	 READ(31,1717,IOSTAT=IEND) READLINE
       IF(IEND .LT. 0) GO TO 100
   	 IF(READLINE(3:16) .EQ. 'LAST AND FIRST') GO TO 100

       WRITE(41,1717) READLINE
       GO TO 50


  100	 CLOSE(31)

C  IN THIS PROGRAM, FILE 31 IS CLOSED HERE, SINCE IT WILL BE REOPENED

C  EACH TIME ANOTHER SUBJECT IS TO BE CREATED IN SUBROUTINE SIMBIG.


      ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(ICOPY .EQ. 1)  CONDITION.


      IF(ICOPY .EQ. 0) THEN


C  SINCE ICOPY = 0, IT MEANS THAT THERE IS AT LEAST ONE SET OF STEADY
C  STATE DOSES IN THE DOSAGE BLOCK. THE LOGIC FOR TRANSLATING THESE
C  STEADY STATE DOSES TO A REGULAR DOSAGE BLOCK (EXCEPT FOR THE NEGATIVE
C  DOSE TIME AT THE START OF EACH STEADY STATE DOSE SET) IS AS FOLLOWS:

C  EACH DOSAGE LINE WILL BE COPIED UNALTERED UNLESS IT IS PART OF A
C  STEADY STATE SET.



C  EACH STEADY STATE SET STARTS WITH A SIG(I) < 0. IN THIS CASE, 101
C  DOSES WILL BE APPLIED AT THIS POINT WITH THE STEADY STATE DOSE FOR
C  DRUG IDRUG = RS(I,2*IDRUG), WHICH WILL BE APPLIED AS A BOLUS IF
C  RS(I,2*IDRUG-1) = 0, AND AS AN IV WITH DURATION
C  RS(I,2*IDRUG)/RS(I,2*IDRUG-1) IF RS(I,2*IDRUG-1) > 0.
C  THE REST OF THE DOSE TIMES IN THIS BLOCK OF DOSES (I.E., UNTIL THE
C  NEXT TIME RESET OR STEADY STATE DOSE INDICATOR) WILL BE INCREASED
C  BY 100*DELDOSE, WHERE DELDOSE = -SIG(I) = INTERDOSE INTERVAL FOR
C  THIS SET.


C  ILINE WILL BE THE RUNNING INDEX OF THE NEXT DOSAGE LINE TO BE PUT


C  INTO THE ALTERED DOSAGE REGIMEN. SIGG(ILINE) AND RSS(ILINE,.) ARE
C  THE VALUES THAT GO INTO THIS LINE. DELDOSE IS THE CURRENT INTERDOSE
C  TIME INTERVAL FOR THE LAST STEADY STATE SET OF DOSES ALREADY PUT
C  INTO THE ALTERED DOSAGE REGIMEN (IT IS INITIALIZED TO BE 0 OF 
C  COURSE). 


C  AND NSECTION IS INITIALIZED TO BE 0. IT WILL BE THE RUNNING NO. OF
C  DOSAGE SECTIONS. EACH SECTION BEGINS WITH EITHER A 0.0 (BEGINNING
C  LINE OR TIME RESET) OR A NEGATIVE NO. (STEADY STATE DOSE SET 
C  INDICATOR). THE TIME DELAY ASSOCIATED WITH EACH DOSE SECTION (WHICH
C  WILL BE 0 IF THAT SECTION IS NOT A STEADY STATE DOSE SET), MUST BE 
C  STORED TO BE APPLIED TO THE CORRESPONDING SET OF OBSERVED VALUES
C  BELOW.

      ILINE = 0
      DELDOSE = 0.D0
      NSECTION = 0

      DO ID = 1,ND


       IF(SIG(ID) .GE. 0.D0) THEN

        CALL THESAME(SIG(ID),0.D0,ISAME)

        IF(ISAME .EQ. 1) THEN
         DELDOSE = 0.D0
         NSECTION = NSECTION + 1
         TIMDELAY(NSECTION) = 0.0
        ENDIF   



C  NOTE THAT IF SIG(ID) = 0, THIS LINE IS A TIME RESET LINE, OR THE
C  FIRST LINE IN THE DOSAGE REGIMEN. IF IT'S THE FIRST LINE IN THE
C  DOSAGE REGIMEN, THERE ARE OBVIOUSLY NO PREVIOUS STEADY STATE DOSE
C  SETS. IF ITS A TIME RESET LINE, A PREVIOUS SET OF 101 STEADY STATE
C  DOSES HAS NO EFFECT ON IT. THAT'S WHY DELDOSE IS SET = 0, WHICH 
C  MEANS, BELOW, THAT SIGG(ILINE) WILL = SIG(ID) = 0. ALSO, THE TIME


C  DELAY STORED IN TIMDELAY ABOVE IS 0 SINCE SIG(ID) .GE. 0 --> THIS
C  IS NOT A STEADY STATE DOSE SET.
        
        ILINE = ILINE + 1
        SIGG(ILINE) = SIG(ID) + 100.D0*DELDOSE

        DO J = 1,NI
         RSS(ILINE,J) = RS(ID,J)
        END DO
       
       ENDIF


       IF(SIG(ID) .LT. 0.D0) THEN




C  THIS LINE GIVES INFO ON A STEADY STATE SET OF 101 DOSES WHICH IS
C  TO APPLIED AT THIS POINT.

        DO IDRUG = 1,NDRUG

C  FOR DRUG, IDRUG, THE AMOUNT OF DRUG FOR DRUG NO. IDRUG IN EACH OF THE
C  101 DOSES WILL BE RS(ID,2*IDRUG). IF RS(ID,2*IDRUG) > 0, DRUG, IDRUG,
C  PARTICIPATES IN THE STEADY STATE DOSING. IF THIS VALUE = 0, DRUG,
C  IDRUG, DOES NOT PARTICIPATE. NOTE THAT IF A DRUG PARTICIPATES, THE
C  ROUTE WILL BE AS AN IV, WITH RATE RS(ID,2*IDRUG-1), IF 
C  RS(ID,2*IDRUG-1) > 0. BUT IF THIS VALUE IS 0, THE DRUG WILL BE GIVEN
C  AS A BOLUS. NOTE THAT THE INTERVAL BETWEEN DOSES IS -SIG(ID).

C  IF DRUG, IDRUG, PARTICIPATES IN THE 101 STEADY STATE DOSE SET, PUT 
C  THE DURATION OF IV INTO DELTAIV(IDRUG) IF RS(ID,2*IDRUG-1) > 0;
C  OTHERWISE PUT 0 INTO DELTAIV(IDRUG) SINCE IN THIS CASE, THE DRUG IS
C  GIVEN AS A BOLUS.


         DELTAIV(IDRUG) = 0.D0 
         IF(RS(ID,2*IDRUG) .GT. 0.D0 .AND. RS(ID,2*IDRUG-1) .GT. 0.D0) 
     1    DELTAIV(IDRUG) = RS(ID,2*IDRUG)/RS(ID,2*IDRUG-1) 

C  IT SHOULD NOT BE POSSIBLE FOR THE IV OF THIS DRUG TO BE > 0 AT THE
C  SAME TIME THAT THE BOLUS ENTRY = 0. THIS WOULD MEAN THAT AN IV
C  WAS TO BE GIVEN AT A SPECIFIED RATE, BUT WITH A TOTAL DOSE OF 0,
C  AND THIS MAKES NO SENSE. IF, SOMEHOW, THIS HAS OCCURRED, REPORT IT
C  TO THE USER AS AN ERROR, AND STOP.


C  REPLACE WRITING OF SIG(),RS() WITH XVERIFY (SEE LOGIC IN 
C  SUBROUTINE VERIFYVAL).

         IF(RS(ID,2*IDRUG) .LE. 0.D0 .AND. RS(ID,2*IDRUG-1) .GT. 0) THEN
          XVERIFY(1) = SIG(ID)
          XVERIFY(2) = RS(ID,2*IDRUG-1)
          XVERIFY(2) = RS(ID,2*IDRUG) 
          CALL VERIFYVAL(3,XVERIFY)
C         WRITE(*,101) ID,SIG(ID),IDRUG,RS(ID,2*IDRUG-1),RS(ID,2*IDRUG)
          WRITE(*,101) ID,XVERIFY(1),IDRUG,XVERIFY(2),XVERIFY(3)

  101     FORMAT(//' THERE IS AN ERROR IN YOUR INSTRUCTION FILE, AS'/
     1' DETERMINED BY SUBROUTINE NEWWORK1.'//
     2' ONE OF THE SUBJECTS HAS A STEADY STATE DOSE SET WITH A '/
     3' POSITIVE IV RATE, BUT WITH A TOTAL DOSE AMOUNT .LE. 0.'//
     4' IN PARTICULAR, FOR DOSE EVENT ',I4,' AND TIME ',G19.9,/
     5' FOR DRUG ',I2,', THE IV VALUE IS ',G19.9,' WHILE THE TOTAL'/
     6' DOSE AMOUNT IS ',G19.9//
     7' THE PROGRAM STOPS. PLEASE CORRECT THE ERROR BEFORE RERUNNING.'/)

C  SINCE THE PROGRAM IS TERMINATING ABNORMALLY, WRITE THE ERROR MESSAGE
C  TO ERRFIL ALSO.

        OPEN(42,FILE=ERRFIL)
C        WRITE(42,101) ID,SIG(ID),IDRUG,RS(ID,2*IDRUG-1),RS(ID,2*IDRUG)
         WRITE(42,101) ID,XVERIFY(1),IDRUG,XVERIFY(2),XVERIFY(3)


        CLOSE(42)

          CALL PAUSE
          STOP

         ENDIF
 
        END DO

        
C  CALL SUBROUTINE ORDERDELTA TO OBTAIN NDELTA, THE NO. OF UNIQUE
C  NON-0 VALUES IN THE DELTAIV(.) ARRAY JUST ESTABLISHED ABOVE, AND TO
C  PUT THE ORDERED SET OF THESE NDELTA VALUES INTO ORDELT(.).

C  NOTE THAT IF DELTAIV(IDRUG) = 0, IT MEANS THAT DRUG, IDRUG, DOES NOT
C  PARTICIPATE IN THE STEADY STATE DOSE SET, OR IF IT DOES, IT IS GIVEN
C  AS A BOLUS RATHER THAN AN IV.

        CALL ORDERDELTA(NDRUG,DELTAIV,NDELTA,ORDELT)

C  NOW ESTABLISH THE LINES WITH SIGG(.) AND RSS(.,.) AS FOLLOWS:

C  1. THE NEXT 101*(NDELTA + 1) ROWS WILL BE FOR THE STEADY STATE
C  DOSE SET (I.E., EACH OF THE 101 REPEATED DOSES HAS A START TIME,
C  AND THEN NDELTA ENDING TIMES AMONG ALL NDRUG DRUGS). NOTE THAT
C  NDELTA WILL BE 0 IF ALL THE PARTICIPATING DRUGS ARE BOLUSES SINCE
C  THEY WOULDN'T NEED AN ENDING TIME THEN.

C  2. EVERY ROW OF THE ORIGINAL DOSAGE REGIMEN AFTER LINE ID
C  WILL HAVE THE SAME VALUES IN RSS(.,.) AS IN RS(.,.), BUT THE
C  TIMES IN SIGG(.) WILL ALL BE INCREASED BY 100*DELDOSE OVER THOSE
C  IN SIG(.) ... UP TO BUT NOT INCLUDING THE NEXT TIME RESET EVENT
C  OR NEXT STEADY STATE DOSE INDICATOR LINE, WHERE DELDOSE IS THE TIME
C  INCREMENT BETWEEN CONSECUTIVE DOSES IN THE 101 STEADY STATE DOSE SET.
C  NOTE THAT DELDOSE IS THE NEGATIVE OF SIG(ID).

        DELDOSE = -SIG(ID)        
        NSECTION = NSECTION + 1
        TIMDELAY(NSECTION) = 100.D0*DELDOSE

C  NOTE THAT THE TIME DELAY ASSOCIATED WITH THIS STEADY STATE SET IS
C  STORED INTO TIMDELAY ABOVE SO THAT IT CAN BE APPLIED TO THE 
C  CORRESPONDING SET OF OBSERVED VALUES BELOW.


        DO ISET = 1,101

C  FOR EACH SET, ESTABLISH NDELTA + 1 ROWS (DOSE EVENT LINES).

C  THE FIRST ROW IN THIS SET HAS EACH DRUG IV SET = RS(ID,2*IDRUG-1),
C  AND, FOR EACH DRUG IV WHICH IS 0, THE BOLUS VALUE WILL BE SET =
C  RS(ID,2*IDRUG). NOTE THAT IF A DRUG IV > 0, THE BOLUS VALUE WILL BE
C  SET = 0 SINCE IN THIS CASE, THE VALUE IN THE BOLUS COLUMN IS THE
C  TOTAL AMOUNT OF IV (NOT A BOLUS AMOUNT).

         ILINE = ILINE + 1

         DO IDRUG = 1,NDRUG
          RSS(ILINE,2*IDRUG-1) = RS(ID,2*IDRUG-1)
          RSS(ILINE,2*IDRUG) = RS(ID,2*IDRUG)
          IF(RS(ID,2*IDRUG-1) .GT. 0.D0) RSS(ILINE,2*IDRUG) = 0.D0
         END DO

C  SET ALL THE COVARIATE VALUES = TO THOSE IN LINE ID OF RS OF COURSE.

         DO IADD = 1,NADD
          RSS(ILINE,2*NDRUG+IADD) = RS(ID,2*NDRUG+IADD)
         END DO

C  THE TIME FOR THIS ROW IS (ISET-1)*DELDOSE, EXCEPT FOR THE FIRST
C  LINE, WHICH MUST HAVE THE SAME NEGATIVE VALUE AS IN SIG, SINCE
C  THE ID ROUTINES MUST READ THE NEGATIVE SIG VALUE TO KNOW THAT A
C  STEADY STATE DOSE SET IS STARTING.

         IF(ISET .EQ. 1) THEN
          SIGG(ILINE) = SIG(ID)
          DOSESTART = 0.D0
         ENDIF

         IF(ISET .GT. 1) THEN
          SIGG(ILINE) = (ISET-1)*DELDOSE
          DOSESTART = SIGG(ILINE)
         ENDIF

C  THE NEXT NDELTA ROWS ARE THE IV TURN OFF ROWS FOR THE VARIOUS DRUGS,
C  IF NDELTA > 0. NOTE THAT NDELTA COULD = 0 IF ALL PARTICIPATING DRUGS
C  ARE GIVEN VIA A BOLUS, SINCE THEN NONE WOULD NEED A TURN OFF ROW.

        IF(NDELTA .GT. 0) THEN

         DO INDEL = 1,NDELTA

          ILINE = ILINE + 1

C  THE NEXT TURN OFF TIME IS DOSESTART + ORDELT(INDEL). EACH IV WILL BE
C  OFF UNLESS ITS DELTAIV(.) IS .GT ORDELT(INDEL). AND EACH BOLUS VALUE
C  WILL BE 0 OF COURSE (I.E., EACH BOLUS IS GIVEN JUST ONE TIME AT THE
C  START OF EACH SET).

          DO IDRUG = 1,NDRUG
           RSS(ILINE,2*IDRUG-1) = 0.D0
           IF(DELTAIV(IDRUG) .GT. ORDELT(INDEL))
     1      RSS(ILINE,2*IDRUG-1) = RS(ID,2*IDRUG-1)        
           RSS(ILINE,2*IDRUG) = 0.D0
          END DO

C  SET ALL THE COVARIATE VALUES = TO THOSE IN LINE ID OF RS AGAIN.

          DO IADD = 1,NADD
           RSS(ILINE,2*NDRUG+IADD) = RS(ID,2*NDRUG+IADD)
          END DO

C  THE TIME FOR THIS ROW IS DOSESTART + ORDELT(INDEL)

          SIGG(ILINE) = DOSESTART + ORDELT(INDEL)

         END DO   

C  THE ABOVE END DO IS FOR THE  DO INDEL = 1,NDELTA  LOOP.  

        ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(NDELTA .GT. 0)  CONDITION.

 
        END DO

C  THE ABOVE END DO IS FOR  DO ISET = 1,101  LOOP.



       ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(SIG(ID) .LT. 0.D0)  CONDITION.


      END DO

C  THE ABOVE END DO IS FOR THE  DO ID = 1,ND  LOOP.


C  THIS COMPLETES THE ESTABLISHMENT OF RSS(.,.) AND SIGG(.) ABOVE.


C  NOW ALTER THE OBSERVED VALUE TIMES BY ADDING THE APPROPRIATE VALUE
C  IN TIMDELAY(.) TO EACH OBSERVED VALUE TIME BELOW. NOTE THAT
C  TIMDELAY(1) APPLIES TO ALL TIMES BEFORE THE FIRST TIME RESET,
C  TIMDELAY(2) APPLIES TO THE NEXT SET OF TIMES AFTER THE FIRST 
C  TIME RESET BUT BEFORE THE 2ND, ETC. IF THERE ARE NO TIME RESETS,
C  ALL TIMES WILL HAVE TIMDELAY(1) ADDED TO THEM, AND THIS VALUE WILL
C  BE 0.0 (SEE DOSAGE BLOCK CODE ABOVE - IF THERE ARE NO TIME RESETS
C  OR STEADY STATE DOSE SETS, TIMDELAY(1) IS SET = 0).


   20  READ(31,1717) READLINE

       IF(READLINE(12:23) .NE. 'NO. OF TOTAL') GO TO 20
       BACKSPACE(31)
       READ(31,3) NUMEQT
       READ(31,3) M

       NSECTION = 1

       DO I = 1,M
        READ(31,*) TIM(I),(YO(I,J),J=1,NUMEQT)
        CALL THESAME(TIM(I),0.D0,ISAME)
        IF(ISAME .EQ. 1 .AND. I .GT. 1) NSECTION = NSECTION + 1

        IF(ISAME .EQ. 1) TIMM(I) = 0.D0   
        IF(ISAME .EQ. 0) TIMM(I) = TIM(I) + TIMDELAY(NSECTION)
       END DO


C  NOW COPY THIS PART OF FILE 31 TO FILE 41 WITH THE FOLLOWING
C  EXCEPTIONS:
C   1. ND WILL BE REPLACED BY ILINE (THE TOTAL NO. OF DOSAGE LINES IN
C      THE ALTERED DOSAGE REGIMEN).
C   2. SIG(.) WILL BE REPLACED BY SIGG(.).
C   3. RS(.,.) WILL BE REPLACED BY RSS(.,.)
C   4. TIM(.) WILL BE REPLACED BY TIMM(.)
C   NOTE THAT YO(.,.) WILL BE UNCHANGED.

C  BACKSPACE FILE 31 TO THE FIRST LINE FOR THIS PATIENT.

 1820  BACKSPACE(31)
       BACKSPACE(31)
       READ(31,1717,IOSTAT=IEND) READLINE

	 IF(IEND .LT. 0) THEN

C  NOTE THAT IEND .LT. 0 --> END OF FILE REACHED, BUT IF IT'S REACHED

C  AT THIS POINT, NOT ALL "ACTIVE" NSUB SUBJECT DATA SETS WERE READ
C  AND WRITTEN CORRECTLY TO FILE 41. IN THIS CASE, WRITE A MESSAGE TO
C  THE USER AND STOP.

        WRITE(*,1721)

C  SINCE THE PROGRAM IS TERMINATING ABNORMALLY, WRITE THE ERROR MESSAGE
C  TO ERRFIL ALSO.

        OPEN(42,FILE=ERRFIL)
         WRITE(42,1721) 
        CLOSE(42)

	  CALL PAUSE
	  STOP

	 ENDIF

       IF(READLINE(3:16) .NE. 'LAST AND FIRST') GO TO 1820


       WRITE(41,1717) READLINE

   60  READ(31,1717) READLINE
       WRITE(41,1717) READLINE
   
       IF(READLINE(12:23) .NE. 'NO. OF ADDIT') GO TO 60

C  THE LINE JUST WRITTEN TO FILE 41 IS THE NO. OF ADDITIONAL COVARIATES
C  LINE. WRITE THE NEXT LINE BUT CHANGE FROM ND TO ILINE AS THE NO.
C  OF DOSE EVENTS.

       READ(31,1717) READLINE
       WRITE(41,133) ILINE
  133  FORMAT(I6,' ... NO. OF DOSE EVENTS')

C  WRITE THE NEXT TWO LINES TO FILE 41 (INCLUDING THE HEADER LINE FOR
C  THE DOSAGE BLOCK).

       DO I = 1,2
        READ(31,1717) READLINE
        WRITE(41,1717) READLINE
       END DO

C  WRITE THE NEW DOSAGE BLOCK.

       SIGLAST = -999999.D0



       DO I = 1,ILINE

        WRITE(41,*) SIGG(I),(RSS(I,J),J=1,NI)

C  AS OF MONT110.FOR, MAKE SURE THAT NO TWO TIMES ARE THE SAME SINCE
C  IF THEY ARE, IT CAN CONFUSE SUBROUTINE SHIFT (CAUSING IT TO GO INTO
C  AN INFINITE LOOP - SEE NPAG115.EXP, TESTCASE 5).

        CALL THESAME(SIGLAST,SIGG(I),ISAME)

        IF(ISAME .EQ. 1) THEN

C  REPLACE WRITING OF SIGLAST WITH XVERIFY (SEE LOGIC IN 
C  SUBROUTINE VERIFYVAL).

         XVERIFY(1) = SIGLAST
         CALL VERIFYVAL(1,XVERIFY)

C        WRITE(*,4031) SIGLAST
         WRITE(*,4031) XVERIFY(1)
 4031    FORMAT(/' IN SUBROUTINE NEWWORK1, TWO CONSECUTIVE DOSE TIMES'/
     1' HAVE THE SAME VALUE IN WORKING COPY FORMAT, ',F20.8//
     2' THIS COULD CAUSE UNEXPECTED RESULTS IF THE PROGRAM WERE TO '/
     3' CONTINUE. SO THE PROGRAM NOW STOPS. PLEASE CHECK YOUR PATIENT '/
     4' INFORMATION AND CORRECT (NOTE THAT THIS CAN HAPPEN IF THE '/
     5' FIRST DOSE FOLLOWING A STEADY STATE DOSE SET HAS THE SAME'/
     6' STARTING TIME AS THE ENDING TIME OF THE LAST STEADY STATE '/
     7' DOSE SET.)'//)

C  SINCE THE PROGRAM IS TERMINATING ABNORMALLY, WRITE THE ERROR MESSAGE
C  TO ERRFIL ALSO.

        OPEN(42,FILE=ERRFIL)
C        WRITE(42,4031) SIGLAST
         WRITE(42,4031) XVERIFY(1)

        CLOSE(42)

	  CALL PAUSE


	  STOP

	 ENDIF

       SIGLAST = SIGG(I)





       END DO
C??? ABOVE END DO IS FOR THE  DO I = 1,ILINE  LOOP.




C  READ THROUGH FILE 31 DOWN TO THE END OF THE DOSAGE BLOCK


       DO I = 1,ND
        READ(31,*) SIG(I),(RS(I,J),J=1,NI)
       END DO
 
C  PUT THE BLANK LINE BETWEEN THE DOSAGE BLOCK AND THE OBSERVATION
C  BLOCK TO FILE 41, ALONG WITH THE TWO LINES WHICH GIVE THE NO. OF
C  OUTPUT EQS. AND THE NO. OF OBSERVED VALUE TIMES.


       DO I = 1,3
        READ(31,1717) READLINE
        WRITE(41,1717) READLINE
       END DO

C  WRITE THE OBSERVED BLOCK TO FILE 41, AND READ THROUGH IT IN FILE 31.

      DO I = 1,M
       WRITE(41,*) TIMM(I),(YO(I,J),J=1,NUMEQT)
       READ(31,*) TIM(I),(YO(I,J),J=1,NUMEQT)
      END DO
 
C  NOW COPY LINE FOR LINE THE REST OF THIS SUBJECT'S INFO TO FILE 41.
C  THIS PATIENT'S INFO WILL END WHEN THE END OF THE FILE IS REACHED
C  (IF THIS IS THE LAST PATIENT), OR WHEN THE START OF THE NEXT
C  PATIENT OCCURS.

   70	 READ(31,1717,IOSTAT=IEND) READLINE
       IF(IEND .LT. 0) GO TO 200
   	 IF(READLINE(3:16) .EQ. 'LAST AND FIRST') GO TO 200
       WRITE(41,1717) READLINE
       GO TO 70
  200	 CLOSE(31)

C  IN THIS PROGRAM, FILE 31 IS CLOSED HERE, SINCE IT WILL BE REOPENED
C  EACH TIME ANOTHER SUBJECT IS TO BE CREATED IN SUBROUTINE SIMBIG.


      ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(ICOPY .EQ. 0)  CONDITION.


      RETURN
      END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
      SUBROUTINE ORDERDELTA(NDRUG,DELTAIV,NDELTA,ORDELT)

      IMPLICIT REAL*8(A-H,O-Z)
      DIMENSION DELTAIV(7),ORDELT(7),X(7)

C  SUBROUTINE ORDERDELTA IS CALLED BY NEWWORK1 TO OBTAIN NDELTA, THE NO.
C  OF UNIQUE NON-0 VALUES IN THE DELTAIV(.) ARRAY. THEN THE ORDERED SET
C  OF THESE NDELTA VALUES IS PUT INTO ORDELT(.). NOTE THAT
C  NDELTA WILL BE 0 IF ALL THE PARTICIPATING DRUGS ARE BOLUSES SINCE
C  THEY WOULDN'T NEED AN ENDING TIME THEN.


C  FIRST STORE ALL THE VALUES IN DELTAIV INTO X SO THAT DELTAIV WILL
C  NOT BE CHANGED.

      DO IDRUG = 1,NDRUG
       X(IDRUG) = DELTAIV(IDRUG)
      END DO


C  THE LOGIC OF THIS ROUTINE IS BASED ON \PERSONAL\FINANCE\ORDER.FOR.
C  TO DO THIS, EACH VALUE IN X(.) WILL BE COMPARED TO THE
C  PREVIOUS ONE. IF IT IS < THE PREVIOUS ONE, THE VALUE WILL EXCHANGE
C  PLACES WITH THE PREVIOUS ONE, AND THE TESTING WILL CONTINUE. THE
C  TESTING WILL STOP FOR A VALUE WHEN IT IS COMPARED TO A PREVIOUS
C  VALUE WHICH IS .LE. ITS VALUE.

      DO IDRUG = 2, NDRUG

C  COMPARE VALUE FOR IDRUG WITH EACH PREVIOUS VALUE, AND HAVE IT 
C  EXCHANGE PLACES WITH THAT VALUE, UNTIL IT REACHES ONE WHICH HAS A 
C  SMALLER VALUE. FIRST SET IDRUGNEW = IDRUG; AFTER THE FOLLOWING
C  CODE, IDRUGNEW WILL BE THE INDEX NO. FOR VALUE AT THE OLD IDRUG
C  POSITION.

       IDRUGNEW = IDRUG

       ICOMP = IDRUG 

  110  ICOMP = ICOMP - 1

C  NOW COMPARE VALUE IN LOCATION ICOMP WITH THE VALUE IN LOCATION
C  IDRUGNEW. IF THE LATTER IS .LT. THE FORMER, INTERCHANGE THE RECORDS.

       IF(X(IDRUGNEW) .LT. X(ICOMP)) THEN

        VALUE = X(IDRUGNEW)
        X(IDRUGNEW) = X(ICOMP)         
        X(ICOMP) = VALUE
        IDRUGNEW = ICOMP


C  IF IDRUGNEW = 1, IT HAS BEEN CHECKED AGAINST ALL RECORDS (AND IS
C  THE SMALLEST VALUE); IF IS IS > 1, CONTINUE THE PROCESS.

        IF(IDRUGNEW .EQ. 1) GO TO 150
        IF(IDRUGNEW .GT. 1) GO TO 110

       ENDIF

C  THE ABOVE ENDIF IS FOR THE 
C   IF(X(IDRUGNEW) .LT. X(ICOMP))  CONDITION.


  150 END DO

C  THE ABOVE END DO IS FOR THE  DO IDRUG = 2, NDRUG LOOP.


C  NOW THE NDRUG VALUES ARE ORDERED, FROM SMALL TO LARGE IN X.
C  REWRITE THEM INTO ORDELT, BUT PUT ONLY THE NON-0 AND
C  UNIQUE VALUES INTO ORDELT, AND KEEP TRACK OF NOW MANY OF THESE
C  UNIQUE NON O VALUES THERE ARE - IT WILL BE NDELTA AT THE END OF
C  THE FOLLOWING LOOP.

      NDELTA = 0 

      DO IDRUG = 1,NDRUG

C  FOR THIS VALUE TO BE COUNTED, IT CANNOT = THE PREVIOUS VALUE, AND
C  IT CANNOT = 0.

       IF(IDRUG .EQ. 1 .AND. X(IDRUG) .GT. 0) THEN
        NDELTA = NDELTA + 1
        ORDELT(NDELTA) = X(IDRUG)
       ENDIF


       IF(IDRUG .GE. 2) THEN

        CALL THESAME(X(IDRUG),X(IDRUG-1),ISAME)

        IF(ISAME .EQ. 0) THEN
         NDELTA = NDELTA + 1
         ORDELT(NDELTA) = X(IDRUG)
        ENDIF

       ENDIF

      END DO 

C  THE ABOVE END DO IS FOR THE  DO IDRUG = 1,NDRUG  LOOP.


      RETURN
      END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C

	SUBROUTINE STOREOBSER
	IMPLICIT REAL*8(A-H,O-Z)

	PARAMETER(MAXNUMEQ=7)

      DIMENSION TIM(594),SIG(5000),RS(5000,34),YO(594,MAXNUMEQ),
     1 BS(5000,7)


	CHARACTER SEX*1,READLINE*300,ERRFIL*20



      COMMON/ERROR/ERRFIL
C  COMMON/ERROR/ IS SUPPLIED TO ALL THE ROUTINES WHICH COULD WRITE TO
C  ERRFIL.


C  THIS ROUTINE IS CALLED BY SIMBIG JUST TO READ ALREADY OPENED 
C  SCRATCH FILE 41 AND PUT THE INFO FROM THAT WORKING COPY FILE (WHICH
C  IS THE IN THE FORM EXPECTED BY SUBROUTINE FUNC2, AFTER BEING CREATED
C  BY SUBROUTINE NEWWORK1) INTO THE ARRAYS THAT FUNC2 NEEDS.

	COMMON/OBSER/ TIM,SIG,RS,YO,BS
	COMMON/CNST/ N,ND,NI,NUP,NUIC,NP
	COMMON/CNST2/ NPL,NUMEQT,NDRUG,NADD

	COMMON/SUM2/ M,NPNL
	COMMON/DESCR/AGE,HEIGHT,ISEX,IETHFLG

C  AGE, SEX, HEIGHT, AND ETHNICITY FLAG ARE ON LINES 8-11.

	DO I=1,7
	 READ(41,*)
	END DO
	 
	READ(41,*) AGE
	READ(41,2) SEX
    2   FORMAT(A1)
	ISEX=1
	IF(SEX .EQ. 'F') ISEX=2

	READ(41,*) HEIGHT
	READ(41,*) IETHFLG


C  READ THE NO. OF DRUGS FROM THE LINE WITH 'NO. OF DRUGS' AS ENTRIES
C  12:23. THEN READ NO. OF ADDITIONAL COVARIATES, AND THE NO. OF DOSE 
C  EVENTS, ETC.

    1   FORMAT(A300)
   10	READ(41,1) READLINE

	IF(READLINE(12:23) .NE. 'NO. OF DRUGS') GO TO 10
	BACKSPACE(41)

    3   FORMAT(T2,I5)
        READ(41,3) NDRUG

	IF(NDRUG .GT. 7) THEN

	 WRITE(*,124)
  124  FORMAT(' YOUR PATIENT DATA FILES CANNOT HAVE MORE THAN 7'/
     1' DRUGS. THE PROGRAM IS NOW STOPPING. '/)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,124) 
        CLOSE(42)



       CALL PAUSE
	 STOP



	ENDIF

        READ(41,3) NADD


C  NOTE THAT THE NO. OF "RATES" INCLUDES 2 FOR EACH DRUG (THE IV AND
C  THE PO COLUMNS) + NADD (1 COLUMN FOR EACH ADDITIONAL COVARIATE 
C  BEYOND THE FIRST 4 ABOVE, AGE, SEX, HEIGHT, AND ETHNICITY FLAG).

	NI = 2*NDRUG + NADD

	IF(NI .GT. 34) THEN



  	 WRITE(*,123)
  123    FORMAT(/' YOUR PATIENT DATA FILES HAVE TOO MANY COLUMNS IN '/
     1' THE DOSAGE REGIMEN BLOCK. THE NO. OF ADDITIONAL COVARIATES '/
     2' PLUS TWICE THE NO. OF DRUGS CANNOT EXCEED 34. THE PROGRAM IS'/
     3' NOW STOPPING. '/)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,123) 
        CLOSE(42)

	 CALL PAUSE
	 STOP

	ENDIF

        READ(41,3) ND


	IF(ND .GT. 5000) THEN



	 WRITE(*,125)
  125  FORMAT(' YOUR PATIENT DATA FILES CANNOT HAVE MORE THAN 5000'/
     1' DOSE EVENTS. THE PROGRAM IS NOW STOPPING. '/)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,125) 
        CLOSE(42)



       CALL PAUSE
	 STOP



	ENDIF

	READ(41,*)
	READ(41,*)

        IF(ND.EQ.0) GO TO 40

	DO I = 1,ND
         READ(41,*) SIG(I),(RS(I,J),J=1,NI)
	END DO	 

C  ASSIGN THE VALUES IN EACH DRUG'S PO COLUMN TO THE CORRESPONDING
C  COLUMN IN ARRAY BS.

        DO I=1,ND
         DO J=1,NDRUG
          BS(I,J) = RS(I,2*J)
	 END DO
	END DO

C  READ THE NO. OF OUTPUT EQUATIONS FROM THE LINE WITH 'NO. OF TOTAL'
C  AS ENTRIES 12:23. THEN READ NO. OF OBSERVED VALUE TIMES, ETC.

   40	READ(41,1) READLINE
	IF(READLINE(12:23) .NE. 'NO. OF TOTAL') GO TO 40
	BACKSPACE(41)

        READ(41,3) NUMEQT
        READ(41,3) M

	IF(M .GT. 594) THEN
	 WRITE(*,*) 'NO. OF OBSERVATIONS MUST BE .LE. 594'
	 WRITE(*,*) 'ONLY THE 1ST 594 OBSERVATION TIMES ARE USED.'
	 M=594
	ENDIF


	IF(NUMEQT .GT. MAXNUMEQ) THEN



  	 WRITE(*,127) NUMEQT,MAXNUMEQ 
  127    FORMAT(/' YOUR PATIENT DATA FILE HAS ',I3,' OUTPUT EQ.'/
     1' COLUMNS, WHICH IS MORE THAN ',I3,', THE MAX. ALLOWABLE NO. '/
     2' THE PROGRAM IS NOW STOPPING. '/)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,127) NUMEQT,MAXNUMEQ 
        CLOSE(42)



       CALL PAUSE
	 STOP



	ENDIF

      DO I=1,M
       READ(41,*) TIM(I),(YO(I,J),J=1,NUMEQT)
      END DO



      CLOSE(41)


	RETURN
	END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
      SUBROUTINE WRITESTEADY(NCOVA,NDRUG,IDOSE,SIG,RS,BS,DOSESTRING,
     1 SUBID,IDEVENT)

      IMPLICIT REAL*8(A-H,O-Z)

      DIMENSION SIG(5000),RS(5000,34),BS(5000,7),XVERIFY(900)



      CHARACTER SUBID*11,DOSESTRING*12,BIGLINE*1000,SMALLLINE*1000,
     1  ERRFIL*20


      COMMON/ERROR/ERRFIL
C  COMMON/ERROR/ IS SUPPLIED TO ALL THE ROUTINES WHICH COULD WRITE TO
C  ERRFIL.

C  THIS ROUTINE, CALLED BY SUBROUTINE WRITECSV, WRITES INTO FILE 29 
C  STEADY STATE DOSE INFO FOR THE CURRENT LINE, ONE LINE FOR EACH

C  DRUG WHICH PARTICIPATES IN THE STEADY STATE DOSING.


C  IF IDEVENT = 4 (I.E., THIS IS A DOSE TIME RESET),  ONLY THE FIRST
C  ROW RELATED TO THIS EVENT SHOULD HAVE AN IDEVENT OF 4; SUBSEQUENT
C  ROWS MUST SHOW IDEVENT = 1. OTHERWISE, THE PROGRAM WILL THINK THAT 
C  THE 2ND ROW IS ANOTHER DOSE TIME RESET AFTER THE ONE IN THE 1ST ROW
C  (SEE CODE BELOW WHERE IDEVENT IS SET = 1 AFTER THE LINE FOR THE
C  FIRST PARTICIPATING DRUG IS WRITTEN).
  
C  THE TIME OF THIS DOSE IS SIG(IDOSE). DETERMINE WHICH DRUGS ARE
C  PARTIPATING IN THIS STEADY STATE DOSE SET. A DRUG PARTICIPATES IF
C  IT HAS AN ENTRY IN THE BOLUS COLUMN FOR THAT DRUG. NOTE THAT
C  IF A DRUG HAS AN ENTRY IN THE IV BUT NOT THE BOLUS COLUMN, IT IS AN
C  ERROR (SINCE FOR EACH OF THE 101 DOSES OF THE STEADY STATE SET, IT
C  MAKES NO SENSE TO HAVE A STEADY STATE IV WITHOUT KNOWING HOW MUCH
C  TOTAL DRUG IS ADMINISTERED).


      DO JDRUG = 1,NDRUG


C  FIRST VERIFY THAT DRUG, JDRUG, HAS POSITIVE ENTRIES IN ITS BOLUS
C  COLUMN IF IT HAS A POSTIVE ENTRY IN ITS IV COLUMN. IF THIS IS NOT 
C  TRUE, STOP THE PROGRAM AFTER WRITING AN ERROR MESSAGE.

       RIV = RS(IDOSE,2*JDRUG-1)

       RBOL = RS(IDOSE,2*JDRUG)

       IF(RIV .GT. 0.D0 .AND. RBOL .LE. 0.D0) THEN



        WRITE(*,1) SUBID,IDOSE,JDRUG
    1   FORMAT(/' ERROR IN SUBROUTINE WRITESTEADY.'//
     1' SUBJECT ',A11,' HAS AN ERROR IN ITS DOSAGE REGIMEN ...'/
     1' FOR DOSE NO. ',I5,' DRUG NO. ',I2,' HAS AN IV RATE WHICH MEANS'/
     2' IT IS SUPPOSED TO PARTICIPATE IN THE STEADY STATE DOSE SET,'/
     3' BUT THE ENTRY IN ITS "BOLUS" COLUMN, WHERE THE TOTAL DRUG AMT.'/


     4' FOR EACH IV OF THE STEADY STATE DOSE SET IS SUPPOSED TO BE '/
     5' IS .LE. 0.'//
     6' TO SEE THE PROBLEM, TAKE A LOOK AT THE WORKING COPY FILE THAT'/
     7' WAS SIMULATED. IF YOU DID NOT HAVE WORKING COPY FILES CREATED'/
     8' IN THIS RUN, RERUN THE PROGRAM, SELECT TO HAVE WORKING COPY '/
     9' FILES CREATED, AND THEN TAKE A LOOK AT THE PROBLEMATIC'/
     1' SUBJECT.'//
     2' THE PROGRAM STOPS.'//)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,1) SUBID,IDOSE,JDRUG 
        CLOSE(42) 



        CALL PAUSE
        STOP



       ENDIF



C  FOR DRUG, JDRUG, THE IV RATE WAS STORED INTO RIV, AND THE TOTAL
C  AMOUNT FOR EACH STEADY STATE DOSE WAS STORED INTO RBOL ABOVE.
C  IF RBOL > 0, THIS DRUG PARTICIPATES IN THE STEADY STATE DOSE SET.
C  IN THIS CASE, ESTABLISH ALL THE ENTRIES FOR THE LINE WHICH WILL BE 
C  WRITTEN TO THE .CSV FILE FOR THIS DRUG, AND THEN WRITE THE LINE TO
C  FILE 29.

       IF(RBOL .GT. 0.D0) THEN

C  THE DURATION FOR EACH IV FOR THIS DRUG IS THE QUOTIENT OF RBOL
C  DIVIDED BY RIV IF RIV > 0; AND IT = 0 IF RIV = 0 (SINCE THAT 
C  MEANS THE DOSE IS A BOLUS).

        DURATION = 0.D0
        IF(RIV .GT. 0.D0) DURATION = RBOL/RIV

C  THE STEADY STATE DOSE INFORMATION FOR THIS DRUG THAT WILL GO ON
C  THE NEXT LINE OF THE .CSV FILE IS:
C  SUBID; EVID = IDEVENT (IF IT IS 1, IT WILL BE 1 FOR ALL 
C  PARTICIPATING DRUGS; IF IT IS 4, IT WILL BE 4 FOR THE 1ST 
C  PARTICIPATING DRUG, BUT 1 FOR ANY OTHER PARTICIPATING DRUGS);
C  TIME = 0; DURATION, DOSE = RBOL; ADDL = -1; II = -SIG(IDOSE);
C  INPUT = JDRUG; OUTPUT AND ASSAY C INFO = DOSESTRING; AND COV. INFO
C   = (RS(IDOSE,2*NDRUG+K),K=1,NCOVA).

C  WRITE ALL THE ABOVE INFO TO SCRATCH FILE 37 SO IT CAN BE READ AS
C  BIGLINE AND THEN "REDUCED" (WRITTEN WITHOUT BLANKS) INTO SMALLLINE

C  BY SUBROUTINE REDUCE.

        OPEN(37)

C  REPLACE WRITING OF RBOL,...,RS() WITH XVERIFY (SEE LOGIC IN 
C  SUBROUTINE VERIFYVAL).

        IF(NCOVA .GT. 0) THEN
         XVERIFY(1) = DURATION
         XVERIFY(2) = RBOL
         XVERIFY(3) = -SIG(IDOSE) 
         DO K = 1,NCOVA
          XVERIFY(3+K) = RS(IDOSE,2*NDRUG+K)
         END DO
         CALL VERIFYVAL(3+NCOVA,XVERIFY)
C        WRITE(37,16) SUBID,IDEVENT,'0.0',DURATION,
C    1   RBOL,'-1',-SIG(IDOSE),JDRUG,DOSESTRING,
C    2   (RS(IDOSE,2*NDRUG+K),K=1,NCOVA)
         WRITE(37,16) SUBID,IDEVENT,'0.0',XVERIFY(1),
     1   XVERIFY(2),'-1',XVERIFY(3),JDRUG,DOSESTRING,
     2   (XVERIFY(3+K),K=1,NCOVA)
        ENDIF

   16   FORMAT(A11,',',I1,',',A3,',',G14.7,',',G14.7,',',A2,',',
     1   G14.7,',',I1,A12,26(',',G14.7))


        IF(NCOVA .EQ. 0) THEN
         XVERIFY(1) = DURATION
         XVERIFY(2) = RBOL
         XVERIFY(3) = -SIG(IDOSE) 
         CALL VERIFYVAL(3,XVERIFY)
C        WRITE(37,17) SUBID,IDEVENT,'0.0',DURATION,
C    1   RBOL,'-1',-SIG(IDOSE),JDRUG,DOSESTRING
         WRITE(37,17) SUBID,IDEVENT,'0.0',XVERIFY(1),
     1   XVERIFY(2),'-1',XVERIFY(3),JDRUG,DOSESTRING
        ENDIF

   17   FORMAT(A11,',',I1,',',A3,',',G14.7,',',G14.7,',',A2,',',
     1   G14.7,',',I1,A12)

        BACKSPACE(37)
        READ(37,12) BIGLINE
   12   FORMAT(A1000)
        CLOSE(37)
        CALL REDUCE(BIGLINE,SMALLLINE)
        CALL CONDENSE(SMALLLINE)
        IDEVENT = 1
C  EVEN IF IDEVENT = 4, IT SHOULD BE CHANGED AFTER THE ABOVE WRITING,
C  SINCE EACH DOSE RESET ROW SHOULD HAVE JUST ONE IDEVENT = 4 ROW
C  IN THE .CSV FILE; ALL SUBSEQUENT ROWS FOR THIS EVENT SHOULD SHOW
C  IDEVENT = 1. 

          ENDIF

C THE ABOVE ENDIF IS FOR THE  IF(RIV .GT. 0.D0) CONDITION.


           
         END DO

C  THE ABOVE END DO IS FOR THE  DO JDRUG = 1,NDRUG  LOOP.



      RETURN
      END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
      SUBROUTINE VERIFYVAL(N,X)
      IMPLICIT REAL*8(A-H,O-Z)
      DIMENSION X(200)

C  THIS ROUTINE INPUTS X(I),I=1,N.

C  ON OUTPUT, EACH X(.) WHICH IS INSIDE [-1.D-99, 1.D-99] IS REPLACED
C  BY 0. THIS PREVENTS THIS VALUE FROM BEING WRITTEN OUT IMPROPERLY,
C  E.G., AS .934-106, RATHER THAN .934E-106.
C  ANY X(.) VALUE NOT INSIDE THE ABOVE RANGE WILL BE UNCHANGED ON
C  OUTPUT.

      DO I = 1,N
       IF(X(I) .GE. -1.D-99 .AND. X(I) .LE. 1.D-99) X(I) = 0.D0
      END DO

      RETURN
      END




