C  NPAG120.FOR                                             4/22/16

C  NPAG120 HAS THE FOLLOWING CHANGES FROM NPAG119:

C  1. THE INOPT1 = 1 CODE IS CHANGED TO ACCOMODATE THE INPUTTING OF INFO
C  FROM A FROMFIL (WHICH WAS CREATED BY AN IT2B RUN) WITH CODE
C  "REM_FRN MAR_16", WHICH MEANS IT ALLOWS RANFIX PARAMETERS. THE
C  FIRST IT2B "ENGINE" MODULE TO MAKE A FROMFIL WITH THIS CODE IS
C  it2branfix1.f.

C  2. SIMILARLY, THE CODE WHICH READS IN PRIOR DENSITY FILE HAS BEEN
C  UPDATED TO ALLOW DENSITY FILES MADE BY it2branfix1.f. THESE FILES
C  HAVE THE CODE "DENSITY MAR_16".

C  3. ALL 150's RELATED TO HOLDMAT IN SUBROUTINES CSVCHANGE AND 
C  ORDERCHANGE HAVE BEEN CHANGED TO BE 1000's ... SINCE OTHERWISE IT IS 
C  POSSIBLE FOR A PATIENT LINE WHICH HAS A LOT OF COVARIATE VALUES TO BE
C  CUT OFF. SEE EXAMPLE IN \ALAN3\VIRGINIA\VIRGINIA2.EXP.

C  AND SUBROUTINE CSVCHANGE NOW CALLS NEW SUBROUTINE CONDENSE TO WRITE 
C  EACH LINE INTO FILE 66 IN AS CONDENSED A FASHION AS POSSIBLE.

C-----------------------------------------------------------------------

C  NPAG119.FOR                                             10/23/15

C  NPAG119 HAS THE FOLLOWING CHANGES TO NPAG118:

C  1. THIS PROGRAM, WITH npagranfix4.f AS THE MAIN "ENGINE" MODULE, HAS
C  THE ADDED CAPABILITY TO ESTIMATE THE VALUES OF PARAMETERS WHICH ARE  
C  UNKNOWN BUT THE SAME FOR ALL SUBJECTS.

C  THIS MEANS THAT THE USER NOW DESIGNATES EACH PARAMETER AS FIXED
C  (IRAN(.) = 0), RANDOM (IRAN(.) = 1), OR RANFIX (IRAN(.) = 2).

C  BECAUSE ADDITIONAL INFORMATION (THE NO. OF RANFIX PARAMETERS, ALONG
C  WITH THEIR PARAMETER NAMES, AND INITIAL ESTIMATES) IS PROVIDED 
C  TO THE "ENGINE" PROGRAM, THE INFORMATION FILE PROVIDED TO THAT
C  PROGRAM HAS BEEN CHANGED FROM npag102.inp TO npag103.inp.

C  FORMATS 1109 AND 1111 ARE CHANGED TO SHOW THE NAME OF THE INST.
C  FILE HAS BEEN CHANGED TO npag103.inp. ALSO, THE EXAMPLE COMPILE,
C  LINK, AND EXECUTION COMMANDS HAVE BEEN REMOVED FROM THESE FORMATS, 
C  AS THEY WERE UNNECCESSARY.

C  WITH THE NEW INFORMATION REGARDING THE RANFIX PARAMETERS, ADDITIONAL
C  INFO IS PUT INTO THE OUTxxxx, DENxxxx, AND NP_RFxxxx.TXT FILES 
C  MADE BY THE "ENGINE". AS A CONSEQUENCE, THERE ARE NEW VERSION CODES
C  AT THE TOP OF THESE FILES (THE DATE IS EITHER OCT_15 OR OCT 2015)
C  AND THIS REQUIRES NEW CODE IN SUBROUTINE PREVRUN. ALSO THE CODE 
C  WHICH INPUTS A PRIOR DENSITY IF THE USER SO SELECTS IS CHANGED
C  CORRESPONDINGLY.

C  SIMILARLY, THE INSTRUCTION FILE FOR THIS PROGRAM WILL BE CHANGED
C  SINCE IT WILL CONTAIN THIS NEW INFORMATION. OF COURSE, THIS PROGRAM
C  WILL BE BACKWARDS COMPATIBLE TO ALLOW PREVIOUS INST. FILES (IN WHICH
C  CASE, THE NO. OF RANFIX PARAMETERS WILL BE SET = 0). THE SAVED 
C  INSTRUCTION FILE FROM THIS PROGRAM WILL BE SAVED IN THE NEW 
C  ALL-INCLUSIVE FORMAT, WITH A NEW CODE, REM_BAK OCT_15.

C  2. FORMATS 4352 AND 6426 IN MAIN, AND 128 IN SUBROUTINE STACK, HAVE 
C  BEEN CHANGED TO TAKE OUT THE "BOXES" COMMENT, WHICH IS NO LONGER 
C  APPLICABLE (AND HASN'T BEEN FOR SOME TIME).

C-----------------------------------------------------------------------

C  NPAG118.FOR                                             3/10/15 

C  NPAG118 HAS THE FOLLOWING CHANGES TO NPAG117.FOR.

C  1. THE MAIN MODULE FOR THE "ENGINE" FOR THIS PROGRAM IS CHANGED FROM
C  npageng29.f TO npageng30.f


C-----------------------------------------------------------------------

C  NPAG117.FOR                                             12/20/14

C  NPAG117 IS THE SAME AS NPAG116, EXCEPT THAT THE MAIN MODULE FOR
C  THE "ENGINE" FOR THIS PROGRAM IS CHANGED FROM npageng28.f TO 
C  npageng29.f; THIS IS REFLECTED IN FORMAT 1111.

C-----------------------------------------------------------------------

C  NPAG116.FOR                                             11/24/14

C  NPAG116 HAS THE FOLLOWING CHANGES FROM NPAG115:

C  1. FORMAT 6063 IN SUBROUTINE VERIF1 HAS THE I1 CHANGED TO I2.

C  2. THE MAIN MODULE FOR THE "ENGINE" FOR THIS PROGRAM IS CHANGED FROM
C  npageng27.f TO npageng28.f; THIS IS REFLECTED IN FORMAT 1111.

C  NOTE THAT THE MAIN CHANGE IN npageng28.f IS THAT THE PROGRAM NOW
C  HAS CODE WHICH ALLOWS IT TO BE RUN IN PARALLEL (IF THE USER
C  COMPILES USING gfortran RATHER THAN LF90).

C  3. NP_RFxxxx IS ADDED TO FORMATS 1109 AND 1111 (THIS SHOULD HAVE
C  BEEN DONE PREVIOUSLY).

C  4. FORMAT 919 REFERS NOW TO TSTMULTN.FOR, RATHER THAN TSTMULTM.FOR.

C-----------------------------------------------------------------------

C  NPAG114.FOR                                             8/4/14

C  NPAG114 HAS THE FOLLOWING CHANGES TO NPAG113:

C  1. A BUG IS FIXED IN SUBROUTINE VERIF1. READ(*,2) PRIFIL2 IS
C  REPLACED BY READ(*,102) PRIFIL2, AS IT SHOULD HAVE BEEN ALL ALONG.

C  2. THE MAIN "engine" MODULE, npageng25.f MODULE IS CHANGED TO BE
C  npageng26.f. THE CHANGES IN npageng26.f ARE THAT THE AIC AND BIC
C  ARE CALULATED DIFFERENTLY. ALSO NOTE THAT THE ID MODULES CALLED HAVE
C  BEEN UPDATED: idm1x15.f TO idm1x16.f; idm2x14.f TO idm2x15.f; AND
C  idm3x15.f TO idm3x16.f.

C  3. NPAG114.FOR IS NOW LINKED WITH SCAT72X2.FOR, UPDATED FROM 
C  SCAT72X1.FOR. SCAT72X2 CORRECTS A SUBTLE BUG WHICH CAN CAUSE THE
C  WRONG ASSAY COEFFICIENTS TO BE ASSIGNED TO PATIENTS PRECEDED BY
C  PATIENTS WHICH HAVE ALL MISSING VALUES FOR A GIVEN OUTPUT EQUATION
C  (WHEN OPTION 7 IS SELECTED FROM FORMAT 7186 IN SUBROUTINE PREVRUN,
C  AND STATISTICS FOR THE ENTIRE POPULATION - ISCAT = 3 IS CHOSEN).

C-----------------------------------------------------------------------

C  NPAG113.FOR                                             3/10/14

C  NPAG113 HAS THE FOLLOWING CHANGES FROM NPAG112:

C  1. ICENT WILL NOW BE IRRELEVANT. PREVIOUSLY, THE USER ENTERED ICENT
C  AS 1, 2, OR, 3 TO SELECT WHETHER HE WANTED THE PREDICTED VALUES 
C  WRITTEN TO PRTBxxxx TO BE BASED ON THE BAYESIAN MEANS, MEDIANS, OR
C  MODES, RESPECTIVELY. NOW, ICENT WILL BE UNUSED SINCE THE PRTBxxxx 
C  FILE WILL INCLUDE THE PREDICTED VALUES FOR ALL 3 OF THESE
C  MEASURES. SIMILARLY THE OUTPUT FILE WILL NOW HAVE AUC TABLES FOR ALL
C  3 OF THESE MEASURES (PREVIOUSLY IT JUST HAD THE AUC TABLE BASED ON
C  THE MEASURE SPECIFIED BY ICENT). NOTE THAT THE NEW "ENGINE" MAIN
C  MODULE IS npageng25.f.

C  2. A NEW FILE, "ERRORLOG" WILL BE WRITTEN IF THIS PROGRAM STOPS

C  WITHOUT COMPLETING. ESSENTIALLY AT EVERY PLACE THE PROGRAM HAS A
C  CALL PAUSE COMMAND BEFORE STOPPING, WHATEVER COMMENT IS WRITTEN TO
C  THE SCREEN WILL ALSO BE PLACED INTO "ERRORLOG". NOTE THAT
C  "ERRORLOG" IS PASSED TO SUBROUTINES VIA COMMON/ERROR/ERRFIL,
C  WHERE ERRFIL IS SET = 'ERRORLOG'.

C  3. THE MAXIMUM NO. OF OUTPUT EQUATIONS WILL BE CHANGED FROM 6 TO 7,
C  AND TO FACILITATE ANY FUTURE SUCH CHANGES, THIS NUMBER WILL BE SET
C  = MAXNUMEQ (SO ONLY THE PARAMETER STATEMENT WILL HAVE TO BE CHANGED
C  IN THE FUTURE). THIS MEANS THAT MAXNUMEQ WILL NOW BE PASSED TO ALL
C  THE SUBROUTINES THAT NEED IT; AND IN THOSE SUBROUTINES, ANY 6
C  REFERRING TO THE MAX. NO. OF OUTPUT EQUATIONS WILL BE CHANGED TO
C  MAXNUMEQ.

C  4. FORMAT 919 REFERS NOW TO TSTMULTM.FOR, RATHER THAN TSTMULTL.FOR.

C  5. THE NEW "engine" FOR THIS PROGRAM IS npageng25.f.

C-----------------------------------------------------------------------

C  NPAG112.FOR                                             6/7/13

C  NPAG112 HAS THE FOLLOWING CHANGES FROM NPAG111:

C  1. THE USER CAN NOW USE A NEW-STYLE, ALL-INCLUSIVED INSTRUCTION 
C  FILE. THE PREVIOUS INSTRUCTION FILE DID NOT INCLUDE THE FOLLOWING
C  INFORMATION, WHICH WILL BE INCLUDED IN THE NEW-STYLE FILE:
C  - THEN NAME OF THE THE FORTRAN MODEL FILE;
C  - THE NO. OF COMPARTMENTS;
C  - THE NO. OF PARAMETERS, INCLUDING WHICH ARE RANDOM, AND WHICH
C    ARE FIXED;
C  - INFORMATION ON THE PRIOR DENSITY FOR THE RUN (WHETHER IT IS TO BE
C    UNIFORM, OR A DENSITY FROM A PREVIOUS NPAG RUN, AND IF SO WHAT THE
C    NAME OF THAT DENSITY FILE IS);
C  - NAMES OF THE COVARIATES AND DESIGNATION OF WHICH ARE PIECEWISE 
C    CONTINUOUS AND WHICH ARE INTERPOLATED.
C  THE SAVED INSTRUCTION FILE FROM THIS PROGRAM WILL BE SAVED IN THE 
C  NEW ALL-INCLUSIVE FORMAT, WITH A NEW CODE, REM_BAK JUN_13.

C  NOTE THAT THE SECOND ENTRY IN THIS NEW INSTRUCTION FILE WILL BE
C  IVERIFY. IF IVERIFY = 0, IT MEANS THAT ALL THE INSTRUCTIONS WILL BE
C  USED WITH NO VERIFICATION (I.E., SUBROUTINE VERIF1 WILL NOT BE 
C  CALLED), AND THIS MEANS THAT ONCE THE USER ENTERS THE NAME OF THIS
C  INSTRUCTION FILE, IF IVERIFY = 0, THE PROGRAM WILL DO THE REST OF THE
C  RUN WITH NO ADDITIONAL USER INTERACTION. NOTE THAT IALLIN AND IVERIFY
C  ARE NOW PROVIDED TO SUBROUTINE READBLOCK VIA COMMON/TOWRITE. IF
C  IALLIN = 1 AND IVERIFY = 0, READBLOCK WILL KNOW TO ACCEPT THE VALUES
C  IN ICOVTYPE(.), ESTABLISHED IN THE INSTRUCTION FILE, AND NOT ASK
C  THE USER TO ENTER THEM.

C  NOTE THAT IF A USER HAS AN INSTRUCTION FILE WITH IVERIFY = 0, AND
C  HE WANTS TO RUN IT WITH VALIDATION OF THE VALUES, HE CAN SIMPLY
C  EDIT THE 2ND LINE AND CHANGE THE 0 TO 1.

C  THERE ARE QUITE A FEW CHANGES IN MAIN AND SUBROUTINES VERIF1 AND
C  WRITEINFILE TO AFFECT THIS CHANGE.

C  NOTE THAT IF A NEW-STYLE INSTRUCTION FILE IS USED, THE PATH WILL
C  AUTOMATICALLY BE SET = ' ', WHICH MEANS THAT THE EXECUTABLE PROGRAM,
C  NPAG112.EXE, WILL HAVE TO RESIDE IN THE WORKING DIRECTORY.

C  2. FORMAT 919 REFERS NOW TO TSTMULTL.FOR, RATHER THAN TSTMULTK.FOR.

C  3. FORMAT 401 IS ADDED TO LOOP 400 SINCE THIS LOOP CAN TAKE A LONG
C  TIME, AND WRITING SUBJECT NOS. TO THE SCREEN ASSURES USERS THE
C  PROGRAM HAS NOT HUNG.

C  4. THE MAIN MODULE FOR THE "ENGINE" FOR THIS PROGRAM IS CHANGED FROM
C  npageng23.f TO npageng24.f, SO FORMAT 1111 IS CHANGED TO REFER TO
C  npageng24 RATHER THAN npageng23.

C-----------------------------------------------------------------------

C  NPAG111.FOR                                             4/17/13

C  NPAG111 HAS THE FOLLOWING CHANGES FROM NPAG110:

C  1. FORMAT 919 REFERS NOW TO TSTMULTK.FOR, RATHER THAN TSTMULTJ.FOR.
C  THIS SHOULD HAVE BEEN DONE IN NPAG110.FOR.

C  2. IF THE USER ENTERS PATIENT DATA INFO IN A .csv FORMAT, THE PROGRAM
C  WILL CHECK TO SEE IF THERE ARE NSUBTOT WORKING COPY FILES,
C  XQZPJ001.ZMQ,... ALREADY IN THE WORKING DIRECTORY. IF SO, THE USER
C  WILL BE ASKED IF HE WANTS TO USE THESE FILES, AND AVOID CREATING 
C  THEM FROM THE .csv FILE. I.E., IF THE USER HAS ALREADY DONE AN NPAG
C  RUN WITH THE CURRENT .csv FILE, THE XQZPJ001.ZMQ,... FILES CAN BE
C  REUSED WITHOUT HAVING TO RECREATE THEM, AND THIS COULD SAVE A LOT OF
C  TIME IF THE .csv FILE IS LARGE. OF COURSE, IF THE USER USES THE SAME
C  WORKING DIRECTORY FOR MULTIPLE RUNS WITH DIFFERENT .csv FILES, HE
C  SHOULD MAKE SURE THE CURRENT XQZPJ001.ZMQ,... FILES ARE THE CORRECT
C  ONES BEFORE SELECTING THIS OPTION.

C  3. PREVIOUSLY, IF THE USER ENTERED INFO VIA THE KEYBOARD, AND THE
C  PATIENT DATA CAME IN VIA A .csv FILE, THIS FILE WOULD BE EXAMINED
C  TWICE BY SUBROUTINE READBLOCK, EACH TIME CALLING SUBROUTINE
C  GETMAXTIM TO FIND THE MAXIMUM TIME AMONG ALL THE SUBJECTS. BUT THE
C  CALLING OF GETMAXTIM DOES NOT NEED TO BE DONE WHEN READBLOCK IS
C  CALLED BY SUBROUTINE GETNUMEQ (I.E., WHEN ICALL = 2 IN THE ARG. LIST
C  TO READBLOCK). SO NOW, WHEN READBLOCK IS CALLED WITH ICALL = 2, THE
C  CALLING OF GETMAXTIM IS SKIPPED.

C  4. THE CONVERGENCE TOLERANCE WHICH IS READ IN AND PASSED TO THE
C  "ENGINE" (THE NEW "ENGINE" MAIN MODULE IS NOW npagen23.f) IS 
C  CHANGED FROM TOL (WHICH REMAINS HARDCODED IN THE "ENGINE" AS 1.D-4)
C  TO TOLC. THE DEFAULT VALUE FOR TOLC IS .01 BUT THE USER CAN CHANGE
C  IT. TOLC WILL BE THE VALUE AGAINST WHICH checkbig IS COMPARED IN
C  THE "ENGINE". PREVIOUSLY, IT WAS HARDCODED = .01.

C  BECAUSE OF THIS CHANGE, THE CODE FOR SAVED INSTRUCTION FILES IS
C  CHANGED FROM 'REM_BAK JUL_11' TO 'REM_BAK JAN_13').

C  5. OPEN(27) IN SUBROUTINE PUTASS IS REPLACED BY 
C  OPEN(27,STATUS='SCRATCH'). THE REASON IS EXPLAINED IN CHANGE NO. 1
C  IN NPAG108.FOR (WHERE THE SAME CHANGE HAD TO BE MADE FOR FILE 57).

C  6. THE MAIN MODULE FOR THE "ENGINE" FOR THIS PROGRAM IS CHANGED FROM
C  npageng22.f TO npageng23.f

C  7. FORMAT 1111 IS CHANGED TO REFER TO npageng23 RATHER THAN
C  npageng21.

C  8. A BUG IS CORRECTED IN SUBROUTINE CSVCHANGE. PREVIOUSLY, IF A .CSV
C  FILE HAD AN IDEVENT = 4 WITH IADDL > 0 (I.E., REPEATED DOSES STARTING
C  WITH A DOSE RESET EVENT), CSVCHANGE WOULD IMPROPERLY WRITE IADDL
C  REPEATED DOSE LINES TO FILE 66 ALL WITH IDEVENT = 4. IN FACT, THESE
C  REPEATED LINES MUST, OF COURSE, HAVE IDEVENT = 1 (SINCE THEY ARE
C  REGULAR DOSE LINES, NOT MORE DOSE RESET LINES).

C-----------------------------------------------------------------------

C  NPAG110.FOR                                             10/15/12

C  NPAG110 HAS THE FOLLOWING CHANGES TO NPAG109.FOR.

C  1. THE MAIN MODULE FOR THE "ENGINE" FOR THIS PROGRAM IS CHANGED FROM
C  npageng20.f TO npageng21.f


C  2. FORMAT 1111 IS CHANGED TO REFER TO npageng21 RATHER THAN
C  npageng20.

C-----------------------------------------------------------------------

C  NPAG109.FOR                                             10/04/12

C  NPAG109 HAS THE FOLLOWING CHANGES FROM NPAG108:

C  1. A NEW TEMPLATE MODEL FILE, TSTMULTJ.FOR, UPDATED FROM 
C  TSTMULTI.FOR, WILL NOW BE USED. THE DIFFERENCE IS THAT THE FOLLOWING
C  TWO DECLARATION STATEMENTS ...
C        DOUBLE PRECISION KE,KA,KCP,KPC     AND
C        COMMON /RATESV/ KE,KA,KCP,KPC,V       
C  WHICH WERE ONLY IN SUBROUTINES OUTPUT AND ANAL3, WILL NOW ALSO BE IN
C  SUBROUTINES DIFFEQ, GETFA, GETIX, AND GETTLAG. THIS WILL ALLOW THE
C  USER TO REFER TO THESE PARAMETERS BY NAME, RATHER THAN BY P(.), IN
C  ALL THE ROUTINES OF THE MODEL. 

C  FORMAT 919 NOW REFERS TO TSTMULTJ.FOR, RATHER THAN TSTMULTI.FOR.

C  2. THE MAIN MODULE FOR THE "ENGINE" FOR THIS PROGRAM IS CHANGED FROM
C  npageng19.f TO npageng20.f

C  3. FORMAT 1111 IS CHANGED TO REFER TO npageng20 RATHER THAN
C  npageng19.

C  4. IN THE LOOP WHICH EXAMINES ALL WORKING COPY PATIENT DATA FILES
C  TO VERIFY THEY HAVE THE CORRECT ASSAY COEFFICIENTS (SEE FORMAT 2401),
C  A NEW STATEMENT (FORMAT 8889) IS WRITTEN TO THE SCREEN WITH THE
C  SUBJECT NO. CURRENTLY BEING EXAMINED ... SO THE USER WON'T THINK THE
C  PROGRAM HAS HUNG IF THERE ARE A LOT OF SUBJECTS.

C  5. IN SUBROUTINE CSVCHANGE, FORMAT 103 IS WRITTEN TO THE SCREEN IN
C  CASE A RUN HAS A LOT OF SUBJECTS WITH A LOT OF DATA. OTHERWISE, 
C  THERE COULD BE A LONG "DEAD" TIME ON THE SCREEN, MAKING THE USER
C  THINK THE PROGRAM HAS "HUNG".

C  BECAUSE OF THIS THE WRITE OF FORMAT 1234 IS TAKEN OUT OF MAIN AND
C  SUBROUTINE GETNUMEQ (SINCE "DEAD" TIME IS REPLACED BY WRITING WHICH
C  SUBJECTS ARE BEING WORKED ON BY SUBROUTINE CSVCHANGE).


C  SIMILARLY, IN SUBROUTINE GETMAXTIM, FORMATS 103 AND 104 FILL THE
C  "DEAD" SCREEN TIME WITH INFORMATION ON MAXIMUM TIME AMONG THE 
C  SUBJECTS IN CASE THERE ARE A LOT OF SUBJECTS WITH A LOT OF DATA.

C  6. A BUG IS FIXED IN SUBROUTINE WRITEINFILE. NPAG106.FOR INTRODUCED
C  THIS BUG BY NOT SETTING NDRUG = 1 IF ENTRY .LT. 5. THIS WAS GOOD
C  IN THAT ONCE NENTRY = 3, NDRUG HAS BEEN READ IN AND SHOULD NOT BE
C  RESET, BUT IT IS BAD IN THAT IF NENTRY = 2, WHEN THE CODE GETS TO
C  THE IF(NENTRY .LT. 5) SECTION, IT WILL SET AF(I) = 1 FOR I = 1,NDRUG.
C  THIS IS NOT A PROBLEM IF NDRUG IS INITIALIZED BY THE PROGRAM TO BE
C  0 BEFORE IT IS READ, AS THIS DO LOOP WILL BE IGNORED. THIS IS WHAT
C  HAPPENS IN LAHEY FORTRAN COMPILED PROGRAMS. BUT IN gfortran COMPILED
C  PROGRAMS, VARIABLES NOT INITIALIZED CAN HAVE "GARBAGE" NUMBERS IN
C  THEM SOMETIMES. IN NPAG106.FOR,...,NPAG108.FOR, THE UNINITIALIZED
C  VALUE FOR NDRUG WAS 0, AND SO NO HARM WAS DONE. BUT IN NPAG109.FOR,
C  NDRUG'S UNINITIALIZED VALUE WAS, FOR ONE RUN, 919667248, AND THIS
C  OBVIOUSLY CAUSED AN ERROR SINCE THE MAXIMUM SIZE OF THE AF(.) ARRAY
C  IS JUST 6.

C  SO TO AVOID THIS ERROR, THE CODE IN WRITEINFILE IS REVERSED SO THAT
C  THE IF(ENTRY .LT. 1) SECTION COMES FIRST, AND THEN THE 
C  IF(ENTRY .LT. 2) SECTION, ETC.

C-----------------------------------------------------------------------

C  NPAG108.FOR                                             8/19/12

C  NPAG108 HAS THE FOLLOWING CHANGES TO NPAG107:

C  1. ALL OPEN(57) STATEMENTS ARE REPLACED BY OPEN(57,STATUS='SCRATCH') 
C  STATEMENTS. THE REASON IS THAT REPEATED OPENING AND CLOSING OF THE
C  SAME FILE CAN CAUSE A gfortran-COMPILED PROGRAM TO EVENTUALLY
C  HAVE A RUN-TIME ERROR AS FOLLOWS:

C  At line xxxx of file XXXXXX.FOR (unit = 57, file = 'fort.57')
C  Fortran runtime error: Cannot write to file opened for READ.


C  SEE TSTWRITE.EXP FOR A SIMPLE EXAMPLE OF WHEN THIS HAPPENS, AND
C  THE FACT THAT IT HAPPENS RANDOMLY.

C  BY INCLUDING THE STATUS='SCRATCH' SPECIFIER, THE ABOVE ERROR NO 
C  LONGER OCCURS.

C  ALSO, CLOSE(57) IS ADDED TWICE IN SUBROUTINE CSVCHANGE, BELOW WHERE
C  FILE 57 WAS OPENED, WRITTEN, AND THEN READ. THESE CLOSE STATEMENTS
C  SHOULD HAVE BEEN IN THE CODE BEFORE, BUT CAUSED NO PROBLEMS. 
C  NEVERTHELESS, THE CODE NOW IS CLEANER WITH THE ADDITION OF THESE
C  TWO CLOSE STATEMENTS.
 
C  2. A DIMENSION STMT. FOR C0P,..,C3P IS ADDED TO SUBROUTINE GETNUMEQ.
C  NOT HAVING IT THERE DID NOT CAUSE A PROBLEM, BUT IT SHOULD BE IN THE
C  ROUTINE SINCE THESE ARRAYS ARE ARGUMENTS IN A CALL TO SUBROUTINE
C  READBLOCK.



C  NOTE THAT A CHECK OF THE COMPILATION WARNINGS FOR THIS PROGRAM
C  (USING LF90 SINCE gfortran GIVES ALMOST NO MESSAGES (WHEN THE ONLY
C  SWITCH IS -o ANYWAY), SHOWS THAT THEY ARE ALL INNOCUOUS. THERE ARE
C  MANY REGARDING VARIABLES NOT USED, BUT THESE ARE HOLDOVERS FROM
C  PREVIOUS PROGRAMS. AND SOMETIMES VARIABLES WHICH ARE NO LONGER USED
C  ARE STILL READ FROM FILES SO THE FORMAT OF THE FILES DOES NOT HAVE
C  TO CHANGE. ALSO, THERE ARE A NUMBER OF WARNINGS FOR FLOATING-PT.
C  COMPARISONS FOR EQUALITY, ETC. BUT YEARS OF RUNNING THESE PROGRAMS
C  SHOW THAT THERE IS NO PROBLEM WITH THESE COMPARISONS.

C  3. THE MAIN MODULE FOR THE "ENGINE" FOR THIS PROGRAM IS CHANGED FROM
C  npageng18.f TO npageng19.f

C  4. FORMAT 1111 IS CHANGED TO REFER TO npageng19 RATHER THAN
C  npageng18.

 
C-----------------------------------------------------------------------

C  NPAG107.FOR                                             7/1/12

C  NPAG107 HAS THE FOLLOWING CHANGES FROM NPAG106:

C  1. IT CREATES AN npagdriv.f WITH AN ADDED ARRAY, CORDLAST, IN BOTH
C  THE DIMENSION STATEMENT, AND IN THE ARGUMENT LIST TO NPAG (WHICH
C  IS THE MAIN SUBROUTINE IN THE NEW MAIN "ENGINE" MODULE, npageng18.f).

C  2. FORMAT 1111 IS CHANGED TO REFER TO npageng18 RATHER THAN
C  npageng17.


C-----------------------------------------------------------------------

C  NPAG106.FOR                                             4/10/12

C  NPAG106 HAS THE FOLLOWING CHANGES TO NPAG105:


C  1. IT NO LONGER RESTRICTS STEADY STATE DOSES TO BE IVs. NOW THEY CAN
C  BE BOLUSES TOO. BUT, FOR EACH DRUG IN A STEADY STATE SET CAN HAVE 
C  EITHER AN IV OR A BOLUS, BUT NOT BOTH. THE REASON IS THAT THE DOSE 
C  COLUMN IN THE .CSV FILE IS USED FOR THE TOTAL AMOUNT OF DRUG GIVEN.
C  IF THE CORRESPONDING DURATION IS 0, THIS REPRESENTS A BOLUS; IF THE
C  CORRESPONDING DURATION > 0, THIS REPRESENTS THE TOTAL AMOUNT OF THE
C  IV (WITH THE INDICATED DURATION). IF THERE WERE TO BE BOTH AN IV AND
C  A BOLUS, THERE WOULD BE NO WAY TO IMPART THIS INFORMATION IN THE TWO
C  ENTRIES (DUR AND DOSE).

C  THE ONLY CHANGE REQUIRED IN THIS PROGRAM TO ALLOW STEADY STATE BOLUES
C  IS IN SUBROUTINE READBLOCK, WHERE THE IV RATE IS SET = 0 IF DUR = 0.

C  2. JUST BELOW THE START OF LOOP 1000 IN SUBROUTINE WRITEDOS, 
C  SUBROUTINE THESAME IS CALLED TO ESTABLISH THE VALUE FOR ISAMERESET.
C  THIS CALL HAD BEEN REMOVED IN NPAG104.FOR SINCE NRESET AND 
C  TIMERESET WERE SET IN THE  IF(TIME .GE. TIMADD*(NRESET+1))
C  BLOCK. BUT IT IS NECESSARY FOR ISAMERESET TO BE SET = 1 WHEN
C  TIME = TIMADD*(NRESET+1) ... SINCE IT IS USED BELOW TO PREVENT
C  INTERPOLATION OF COVARIATES ACROSS A TIME RESET.

C  3. THE G15.6 FORMAT IN FORMAT 1 IN SUBROUTINE WRITEDOS IS CHANGED
C  TO BE G19.9 (TO GIVE A LITTLE MORE PRECISION).

C  4. LOTS OF UNNEEDED ARRAYS AND VARIABLES HAVE BEEN REMOVED.

C  5. FORMAT 1111 IS CHANGED TO REFER TO npageng17 RATHER THAN
C  npageng16.

C  6. A BUG IS FIXED IN SUBROUTINE WRITEINFILE. PREVIOUSLY, NDRUG WAS 
C  DEFAULTED TO BE 1 (AND AF(1) SET = 1), WHEN NENTRY .LT. 5. BUT THIS
C  IS AN ERROR SINCE NDRUG IS READ IN BY SUBROUTINE GETNUMEQ BEFORE THE
C  CALL TO WRITEINFILE WHEN NENTRY IS 3. I.E., ONCE GETNUMEQ IS CALLED,
C  NDRUG SHOULD NOT BE CHANGED IN WRITEINFILE. SO NDRUG IS NOW SET = 1
C  WHEN NENTRY IS .LT. 3. BUT SINCE AF(I),I=1,NDRUG, ARE NOT READ IN
C  UNTIL BETWEEN NENTRY = 4 AND 5, ALL AF(I),I=1,NDRUG WILL BE SET = 1
C  IF NENTRY .LT. 5.

C-----------------------------------------------------------------------

C  NPAG105.FOR                                             2/13/12


C  NPAG105 HAS THE FOLLOWING CHANGE FROM NPAG104:

C  A BUG IS FIXED IN SUBROUTINE CSVCHANGE. PREVIOUSLY, THE 
C  SUBROUTINE WAS BASED ON CSVCHANGE.FOR, WHICH WORKED ONLY FOR
C  .csv FILES WITH 1 SUBJECT. NOW IT IS BASED ON CSVCHANGE2.FOR
C  WHICH WORKS ON ALL .csv FILES.

C-----------------------------------------------------------------------

C  NPAG104.FOR                                             01/18/12

C  NPAG104 HAS THE FOLLOWING CHANGES FROM NPAG103:

C  1. IT ALLOWS A NEW VERSION OF THE .csv FILE. THIS FILE WILL HAVE
C  THE CODE,"POPDATA DEC_11" AT THE TOP, RATHER THAN "POPDATA APR_11".
C  THIS NEW .csv FILE WILL HAVE TWO EXTRA COLUMNS, ADDL AND II, WHICH
C  ALLOW THE USER TO SPECIFY THAT THE CURRENT DOSE LINE IS TO BE
C  REPLICATED ADDL TIMES AT AN INTERDOSE INTERVAL OF II. IF ADDL IS
C  MISSING, IT IS ASSUMED TO BE 0 (WHICH MEANS THE LINE IS NOT TO BE
C  REPLICATED). IF ADDL = -1, IT INDICATES A STEADY STATE DOSE SET IS 
C  BEGINNING WITH THAT LINE.

C  TO HANDLE THE NEW .csv FILE, A NEW SUBROUTINE, CSVCHANGE, WILL BE
C  CALLED (AFTER SUBROUTINE NEWCSV IS CALLED AND BEFORE READBLOCK IS
C  CALLED) TO CHANGE THE NEW .csv FILE INTO THE CORRESPONDING ONE
C  WITH THE OLD FORMAT. THIS WILL MINIMIZE THE CHANGES TO SUBROUTINE
C  READBLOCK, WHICH WILL STILL NEED TO BE CHANGED TO DEAL WITH 
C  NEGATIVE DOSE TIMES (WHICH WILL NOW INDICATE THE BEGINNING OF A 
C  STEADY STATE DOSE SET) - SEE CODE IN READBLOCK.

C  ALSO NOTE THAT CSVCHANGE CONVERTS SCRATCH FILE 67 TO SCRATCH FILE
C  66, WHICH MEANS THAT ALL THE READ(67,..) STATEMENTS IN READBLOCK ARE
C  NOW CHANGED TO READ(66,...) STATEMENTS. SIMILARLY, THE READ(67,...)
C  IN SUBROUTINE GETMAXTIM IS CHANGED TO READ(66,...).


C  SOME NOTES REGARDING THE NEW .csv FORMAT:

C  a. THE COLUMNS WILL NOW BE:
C  ID,EVID,TIME,DUR,DOSE,ADDL,II,INPUT,OUT,OUTEQ,C0,C1,C2,C3,Covs if any

C  b. ADDL AND II ARE ONLY RELEVANT FOR EVID=1 AND EVID=4. FOR EVID=0,

C  (OBSERVATIONS) THEY ARE IGNORED.

C  c. ADDL CONTAINS THE NO. OF ADDITIONAL DOSES TO GIVE, AT THE 
C  INTERDOSE INTERVAL OF II.

C  d. If ADDL IS MISSING FOR AN EVID=1 OR EVID=4 EVENT, IT IS ASSUMED 
C  TO BE 0 --> NO ADDITIONAL DOSES ARE GIVE. IN THIS CASE, II IS
C  IRRELEVANT.

C  e. IF ADDL > 0, THEN ADDL ADDITIONAL DOSES ARE GIVEN (I.E., A TOTAL
C  OF ADDL + 1) AT INTERVAL II. A MISSING II IN THIS CASE WILL RESULT
C  IN THE PROGRAM STOPPING WITH AN ERROR MESSAGE TO THE USER.

C  f. ADDL > 0 CAN OCCUR ON ANY DOSE EVENT, BUT ADDL = -1 (A STEADY
C  STATE DOSE INDICATOR) CAN ONLY OCCUR AT T = 0 AT THE BEGINNING OF
C  A PATIENT'S FILE, OR AT A DOSE RESET TIME.

C  2. THE MAX. NO. OF DOSE EVENTS HAS BEEN CHANGED IN DIMENSIONS AND
C  CORRESPONDING CONDITIONAL STATEMENTS TO BE 5000 (500 IS NOW TOO LOW
C  WITH STEADY STATE DOSE SETS NOW ALLOWED) IN SUBROUTINES FILRED AND
C  STACK.

C  IN ADDITION, THE MAXIMUM NO. OF DOSE ROWS IN READBLOCK (AND ROUTINES
C  THAT IT CALLS) HAS BEEN CHANGED FROM 3000 TO 5000.

C  3. IN SUBROUTINE TIMESET, THE FIRST TIME IN THE DOSAGE BLOCK FOR EACH
C  SUBJECT IS NO LONGER TESTED TO MAKE SURE IT IS 0. THE REASON, OF
C  COURSE, IS THAT NOW THE FIRST TIME MAY BE NEGATIVE (WHICH SIGNIFIES
C  THAT THE DOSAGE REGIMEN BEGINS WITH A STEADY STATE OF DOSES).

C  4. A NEW SUBROUTINE CONVERTCSV IS CALLED BEFORE EACH CALL TO
C  SUBROUTINE NEWCSV TO CONVERT, IF NECESSARY, A "EUROPEAN" VERSION OF
C  A .CSV FILE TO THE FORM READBLOCK EXPECTS. IN THE "EURO" VERSION, THE
C  FIELD SEPARATORS ARE SEMICOLONS, RATHER THAN COMMAS, AND THE 
C  CHARACTER USED TO SEPARATE THE WHOLE PART OF A NUMBER FROM THE
C  FRACTIONAL PART IS A COMMA, RATHER THAN A PERIOD. TO DO THIS REQUIRES
C  READING THE SECONDS LINE OF THE .CSV FILE (THE FIRST LINE HAS THE
C  VERSION CODE) AND CHECKING FOR SEMICOLONS. IF THERE ARE ANY, THEN THE
C  FILE IS CHANGED SO THAT, IN ORDER, ALL COMMAS ARE CHANGED TO PERIODS,
C  AND THEN ALL SEMICOLONS ARE CHANGED TO COMMAS. NOTE THAT, EVEN IN THE
C  "EURO" VERSION, IT WILL STILL BE ASSUMED THAT A DOT REPRESENTS
C  A MISSING (OR UNNEEDED) VALUE.

C  NOTE THAT BLOCKPAT IS NOW OPENED AS SCRATCH FILE 87. THEN CONVERTCSV

C  WRITES THIS FILE AS THE CORRECTED VERSION TO SCRATCH FILE 77. THEN,
C  ROUTINE NEWCSV CONVERTS THIS FILE TO SCRATCH FILE 67. THEN ROUTINE
C  CSVCHANGE CONVERTS THIS FILE TO SCRATCH FILE 66, WHICH IS READ BY
C  ROUTINE READBLOCK.

C  5. A TYPO ON FORMAT 1234 IS FIXED (QUITE -> QUIET).

C  6. THE MAIN "ENGINE" MODULE FOR THIS PROGRAM IS STILL npageng16.f,
C  BUT THE 3 id MODULES ARE UPDATED (TO idm1x8.f, idm2x8.f, AND 
C  idm3x8.f). THIS WAS REQUIRED TO CORRECT A BUG WHICH OCCURRED IN
C  SUBROUTINES FUNC (OR FUNC2 OR FUNC3) FOR TIME RESETS NOT BEING
C  IDENTIFIED IF THE LAST DOSE TIME OCCURRED AFTER THE LAST OBSERVATION
C  TIME IN A SECTION OF THE PATIENT'S FILE - SEE CODE AND COMMENTS IN
C  THOSE ROUTINES).

C-----------------------------------------------------------------------

C  NPAG103.FOR                                             8/7/11

C  NPAG103 HAS THE FOLLOWING CHANGES FROM NPAG102:

C  1. IF THE USER WANTS TO SAVE THE INSTRUCTIONS TO A FILE (SEE FORMAT
C  4012), THE CONDITION IF(IFIL .EQ. 0) IS CHANGED TO BE
C  IF(IFIL .EQ. 0 .OR. INOPT1 .EQ. 1). THE REASON IS THAT FOR PC's, IF
C  IFIL IS NEVER SET, WHICH IT ISN'T IN THE INOPT1 = 1 CODE BELOW, IT
C  DEFAULTS TO 0, AND THE IF(IFIL .EQ. 0) CONDITION IS MET AS DESIRED.
C  BUT IN MAC's, IFIL CAN TAKE ON A RANDOM NUMBER, AND SO THE CODE
C  UNDER IF(IFIL .EQ. 0) WOULD BE SKIPPED. NOW IT WON'T BE.

C  2. BEFORE THE PROGRAM CALLS NEWCSV IN TWO PLACES, A NEW WRITE 
C  STATEMENT (FORMAT 1234) TELLS THE USER THAT THERE COULD BE A
C  SIGNIFICANT DELAY BEFORE HE SEES ANY MORE WRITING TO THE SCREEN.

C-----------------------------------------------------------------------

C  NPAG102.FOR                                             7/29/11

C  NPAG102 HAS THE FOLLOWING CHANGES FROM NPAG101:

C  1. THE ACTIVE (SALT) FRACTION, AF, WILL NOW BE A VECTOR. PREVIOUSLY,
C  IT WAS ASSUMED THAT ALL DRUGS HAD THE SAME AF; NOW EACH DRUG WILL
C  HAVE ITS OWN.

C  THE ABOVE CHANGE REQUIRES THE INSTRUCTION FILE TO BE CHANGED, AND
C  THIS REQUIRES A NEW CODE AT THE TOP (FROM 'REM_BAK APR 11' TO
C  'REM_BAK JUL_11'). THIS REQUIRES CHANGES IN THE CODE WHERE THE
C  INSTRUCTION FILE IS WRITTEN, AS WELL AS WHERE IT IS READ. 

C  NOTE THAT IN OLDER INSTRUCTION FILES, ALL AF(I), I=1,NDRUG, WILL
C  BE SET = THE INPUT VALUE OF AF (NOW CALLED AFSCALAR).

C  IN ADDITION, SINCE AF IS PROVIDED TO THE "ENGINE" (THE FIRST MAIN
C  MODULE FOR THIS PROGRAM IS npageng15.f), THE .inp FILE IS CHANGED
C  FROM npembg34.inp TO npag102.inp. 

C  ALSO NOTE THAT IN npageng15.f, THE SUBROUTINE BIGNPAG( ) STATEMENT
C  IS REPLACED BY A SUBROUTINE NPAG( ) STATEMENT. SO SUBROUTINE 
C  MAKEDRIV IN THIS PROGRAM NOW MAKES AN npagdriv.f FILE WITH A 
C  CALL NPAG( ) STATEMENT, RATHER THAN A CALL BIGNPAG( ) STATEMENT.


C  IN FACT, ALL REFERENCES TO "BIG" IT2B OR "BIG" NPAG ARE CHANGED TO
C  JUST IT2B OR NPAG. 

C  ALSO, SINCE THE AF VALUES ARE WRITTEN BY THE "ENGINE"TO THE OUTPUT
C  FILE AND READ IN BY SUBROUTINE PREVRUN, THE TOP OF THE OUTPUT FILE
C  WILL CHANGE FROM 

C   VERSION 41  ... Made by npageng14                 
C   VER_BAK APR_10   

C  TO ...


C   VERSION 42  ... Made by npageng15
C   VER_BAK JUL_11

C  THIS MEANS THAT VERSION 42 WILL BE ALLOWED IN PREVRUN. ALSO, THE
C  CODE IN PREVRUN WHICH ACCOMODATES VERSIONS .LT. 41 IS REMOVED.
C  AND CODE IS CHANGED TO READ IN AF(.) INSTEAD OF AF IF IVER .GE. 42.

C  NOTE THAT SUBROUTINE GETNUMEQ HAS BEEN EXPANDED TO ALSO OBTAIN THE
C  NO. OF DRUGS, NDRUG, SINCE THIS VALUE IS NEEDED WHEN AF(I),I=1,NDRUG
C  ARE READ ... AND FOR THIS REASON, SUBROUTINE GETNUMEQ IS ALSO NOW
C  CALLED BEFORE AF(I) ARE READ (OR ESTABLISHED FROM THE OLD AF, NOW 
C  CALLED AFSCALAR) IN AN INSTRUCTION FILE. AND FOR THIS REASON, 

C  SUBROUTINE READBLOCK ALSO RETURNS NDRUG IN ADDITION TO NUMEQT WHEN
C  CALLED BY GETNUMEQ.

C  2. FORMATS 1109 AND 1111 WILL CHANGE TO REFLECT UPDATED NAMES. IN
C  PARTICULAR, npembg34.inp IS REPLACED BY npag102.inp; npemdriv.f IS
C  REPLACED BY npagdriv.f (THIS NAME CHANGE IS LONG OVERDUE OF COURSE);
C  AND REFERENCE TO npageng13 (WHICH SHOULD HAVE BEEN npageng14) IS 
C  CHANGED TO npageng15). ALSO, bigmlt IN FORMAT 1109 IS CHANGED TO
C  npageng.

C  3. CODE IN SUBROUTINE STACK IS CHANGED WHERE THE RS(.,.) VALUES ARE
C  MULTIPLIED (NOW) BY AF(.). 


C  4. IF THIS PROGRAM READS AN INSTRUCTION FILE FROM AN IT2B RUN, 
C  FROMxxxx, THE FORMAT AND SUBSTANCE OF THE INPUT INFO WILL BE 
C  CHANGED. THIS MEANS THAT THE CODE AT THE TOP OF THE FILE WILL
C  BE CHANGED FROM 'REM_FRN FEB_04 TO 'REM_FRN JUL_11').

C  5. OPTION 0 IS CHANGED TO OPTION 4 FOR IASS(.) IN FORMATS 119 AND 
C  221 IN MAIN AND VERIF1. CORRESPONDING CODE IN MAIN AND VERIF1, AND
C  IN SUBROUTINE PUTASS IS CHANGED TO REFLECT THIS CHANGE.

C  6. DORIG IS REMOVED FROM FORMAT 4356; IT IS N/A, AND HAS BEEN FOR
C  SOME TIME.

C  7. FORMAT 141 IN MAIN AND VERIF1 IS CHANGED SO THAT THE 2ND LINE FOR 
C  EACH OPTION IS INDENTED PROPERLY.

C-----------------------------------------------------------------------


C  NPAG101.FOR                                             6/29/11

C  NPAG101 HAS THE FOLLOWING CHANGES TO NPAG100:

C  1. THE MAIN MODULE OF NPAG101'S "engine" IS NOW npageng14.f, updated
C  from npageng13.f. ONE OF THE CHANGES IN npageng14.f IS THAT TOL IS NO
C  LONGER USED. IN npageng13.f, IT WAS USED IN A COMPLICATED WAY IN
C  DECIDING WHETHER CYCLE CALCULATIONS HAD CONVERGED, BUT WAS NOT
C  ALLOWED TO BE < 1.D-4. TO SIMPLIFY THE CODE, TOL WILL NOW ALWAYS
C  BE SET = TO 1.D-4 IN THAT PROGRAM. SO, IN THIS PROGRAM, TOL WILL NO
C  LONGER BE INPUT. IT WILL BE HARDCODED TO BE 1.D-4 TO BE CONSISTENT
C  WITH npageng14.f (THOUGH IN REALITY, IT DOESN'T MATTER SINCE IT WILL
C  BE RESET = 1.D-4 IN npageng14.f). TOL, ALONG WITH JSTOP (WHICH HAS
C  NOT BEEN USED FOR A LONG TIME, AND CONTINUES TO BE SET = 3) WILL
C  STILL BE WRITTEN TO npembg34.inp, SO THE FORMAT OF THIS FILE WILL NOT
C  HAVE TO CHANGE.

C  NOTE THAT FORMAT 1247 IN MAIN AND VERIF1 IS CHANGED TO GIVE THE USER
C  SOME INFO ON HOW CONVERGENCE IS ACHIEVED IN npageng14.f.

C  2. IN SUBROUTINE PREVRUN, ONLY OUTPUT FILES WITH VERSION 41 ARE
C  NOW ALLOWED (SINCE THE INFORMATION IN THE OUTPUT FILE IS NOW
C  CHANGED IN FORMAT (AND SOME SUBSTANCE) IN THE NEW npageng14.f.

C-----------------------------------------------------------------------

C  NPAG100.FOR                                             4/18/11

C  NPAG100 HAS THE FOLLOWING CHANGES TO NPBG15E8:

C  1. A SMALL BUG IS REMOVED IN SUBROUTINE READBLOCK. IN FORMAT 11,
C  FILEIN IS NO LONGER REFERENCED - IT IS NOT PASSED TO THE ROUTINE,
C  AND SO WOULD BE PRINTED AS BLANKS IF FORMAT 11 WAS WRITTEN.

C  2. MANY CHANGES ARE MADE IN SUBROUTINES READBLOCK, WRITEDOS, ETC. 
C  SO THAT WT. AND CCR. ARE NO LONGER PUT IN AS DUMMY COVARIATES WHEN
C  THE WORKING COPY FILES ARE MADE FROM THE .CSV FILE. FROM NOW ON,
C  THE ONLY COVARIATES PUT INTO THE WORKING COPY FILES ARE THE ONES
C  SPECIFIED IN THE .CSV FILE. THIS WILL REQUIRE A NEW TEMPLATE MODEL
C  FILE (TSTMULTI.FOR, UPDATED FROM TSTMULTH.FOR) WHICH WILL NO LONGER
C  HAVE THE WARNINGS THAT THE USER SHOULDN'T REFER TO CV(1) AND CV(2)
C  IF THE PATIENT DATA INFO WAS INPUT VIA A .CSV FILE. ALSO THE DO 
C  LOOPS IN THAT FILE THAT WERE OVER I = 1,2+NADD WILL NOW BE OVER
C  I = 1,NADD (SINCE WT. AND CCR. WILL NOW BE INCLUDED AMONG THE NADD
C  ADDITIONAL COVARIATES). NOTE THAT FORMAT 919 IS CHANGED TO INDICATE
C  TSTMULTI.FOR RATHER THAN TSTMULTH.FOR.

C  ALSO NOTE THAT "NCOV" IN SUBROUTINES READBLOCK THROUGH THE REST OF

C  THE FILE HAS BEEN CHANGED TO "NCOVA". THIS STANDS FOR NO. OF 
C  ADDITIONAL COVARIATES - NOT INCLUDING THE 4 PERMANENT ONES AT THE
C  TOP OF ALL WORKING COPY FILES (AGE, SEX, HEIGHT, ETHNICITY FLAG). 
C  THIS WAS DONE TO AVOID POTENTIAL CONFUSION TO "NCOV" IN THE 


C  EARLIER PART OF THIS FILE, WHERE NCOV = 4 + NADD (NADD AND
C  NCOVA ARE THE SAME). THIS SHOULD HAVE BEEN DONE IN EARLIER PROGRAMS.

C  3. THE FORMAT OF THE .CSV FILE READ BY READBLOCK IS CHANGED. THERE
C  WILL BE 4 ADDITIONAL COLUMNS (COL. NOS. 9 - 12) TO CONTAIN THE
C  ASSAY COEFFICIENTS FOR EACH PATIENT/OUTPUT EQ. SO NOW THE 12
C  PERMANENT COLUMNS WILL BE, IN ORDER, #ID, EVENT ID, TIME,
C  INFUSION DURATION, TOTAL DOSE, INPUT (DRUG) NO., OUTPUT VALUE,
C  OUTPUT EQUATION, C0, C1, C2, C3. ANY ADDITIONAL COVARIATES (BEYOND
C  THE 4 AT THE TOP OF EACH WORKING COPY FILE (AGE, SEX, HEIGHT, 
C  ETHNICITY FLAG) WILL HAVE THEIR COLUMNS AFTER THE PERMANENT 12
C  ABOVE.

C  NOTE THAT EACH PATIENT NEEDS ONE SET OF ASSAY COEFFICIENTS FOR EACH
C  OF THE NUMEQT OUTPUT EQUATIONS. IF ANY OF THESE NUMEQT SETS IS
C  MISSING, THE CORRESPONDING POPULATION SET OF ASSAY C'S FOR THAT
C  OUPUT EQUATION WILL BE ASSIGNED TO THAT PATIENT. FOR THIS REASON,
C  THE ARGUMENT LIST FOR READBLOCK WILL BE EXPANDED TO CONTAIN
C  C0P,C1P,C2P, AND C3P.

C  NOTE THAT EACH ROW IN THE .CSV FILE WHICH HAS EVENT ID = 0 (I.E., IS
C  AN OUPUT VALUE ROW) CAN HAVE ASSAY COEFFICIENT INFO. IF THIS INFO
C  IS SUPPLIED FOR THE SAME SUBJECT AND OUTPUT EQ. MORE THAN ONCE, THE
C  LAST SUCH ROW OF VALUES WILL BE USED. ALSO NOTE THAT IF ANY SET OF
C  ASSAY C'S IS INCOMPLETE (I.E., IT HAS AT LEAST ONE VALUE BUT NOT ALL
C  4), THE PROGRAM WILL STOP WITH A MESSAGE TO THE USER THAT THIS TYPE
C  OF INCOMPLETE ASSAY INFO LINE IS IMPERMISSABLE.

C  BECAUSE OF THE NEW .CSV FORMAT, THE CODE ON LINE 1 OF THE .CSV
C  FILE WILL CHANGE FROM BIGNPAG NOV_09 TO POPDATA APR_11. AND NOTE
C  THAT BECAUSE OF ALL THE CHANGES TO THIS FILE, AS WELL AS THE 
C  CORRESPONDING CHANGES REQUIRED IN THE TSTMULTI.FOR TEMPLATE MODEL
C  FILE (SEE ABOVE), THERE WILL BE NO BACKWARDS COMPATIBILITY TO
C  .CSV FILES WITH THE OLD BIGNPAG NOV_09 CODE ON LINE 1.

C  4. BECAUSE OF THE NEW WAY COVARIATES ARE TREATED IN THE TEMPLATE 
C  MODEL FILE (SEE TSTMULTI.FOR ABOVE), THE MAIN "ENGINE" MODULE FOR
C  THIS PROGRAM WILL BE CHANGED FROM bigmlt12.f TO npageng13.f.
C  SIMILARLY, FORMAT 1111 WILL BE CHANGED TO REFER TO LINKNPAGENG13
C  RATHER THAN LINKMLT12, TO LINKNPAGENG13G RATHER THAN LINKMLT12G, AND
C  TO npageng13 and npageng13g RATHER THAN bigmlt12. AND NOTE THAT
C  ONE OF THE MODULES USED BY npageng13.f, shift5.f, HAS BEEN UPDATED
C  TO BE shift6.f.

C  5. THE INSTRUCTION FILE IS CHANGED TO HAVE A NEW CODE, REM_BAK APR_11
C  BECAUSE THE OPTION NOS. HAVE CHANGED FOR HOW PATIENT DATA INFO IS TO
C  BE READ IN. NOW IFORMTT WILL BE READ IN AND CONVERTED TO THE OLD
C  IFORMT (SEE CODE), BOTH IN AN INSTRUCTION FILE, AND VIA KEYBOARD.

C-----------------------------------------------------------------------

C  NPBG15E8.FOR                                            3/11/11

C  NPBG15E8 HAS ONE SET OF CHANGES FROM NPBG15E7. THE STRUCTURE OF THE
C  INSTRUCTION FILE IS CHANGED TO MAKE IT EASIER TO BE READ BY A GUI.
C  SPECIFICALLY, THE NAMES/DESCRIPTIONS OF THE VALUES READ, IN 
C  ADDITION TO THE VALUES THEMSELVES, ARE NOW INCLUDED IN THE FILE.

C  THIS MEANS THAT THE CODE AT THE TOP OF THE INSTRUCTION FILE WILL
C  BE CHANGED FROM REM_BAK MAY_09 TO REM_BAK MAR_11. ALSO, OF COURSE, 
C  BOTH THE CODE TO READ THE FILE, AND TO WRITE IT (IN SUBROUTINE

C  WRITEINFILE), WILL CHANGE.

C----------------------------------------------------------------------- 

C  NPBG15E7.FOR                                            2/10/11

C  NPBG15E7 HAS A SMALL BUG FIX TO NPBG15E6. IT IS IN SUBROUTINE
C  GETNUMEQ, AND IS THE CHANGING OF READ(67,7126) CODEPAT
C  TO READ(77,7126) CODEPAT ... SINCE IT WAS FILE 77 THAT WAS OPENED
C  PRIOR TO THIS READ, NOT FILE 67.


C-----------------------------------------------------------------------

C  NPBG15E6.FOR                                            1/18/11

C  NPBG15E6 HAS THE FOLLOWING DIFFERENCE FROM NPBG15E5:

C  IT CORRECTS A SUBTLE BUG IN SUBROUTINE READBLOCK. PREVIOUSLY IF AN IV 
C  STARTED AT EXACTLY THE ENDING TIME OF THE PREVIOUS IV, THIS WOULD
C  RESULT IN BOTH 0.0 AND THE NEW IV RATE BEING ASSIGNED TO THE SAME
C  TIME. THE RESULT, IN WRITEDOS, WOULD BE THAT 0.0 WOULD BE ASSIGNED
C  TO THIS TIME (I.E., THE NEW IV RATE WOULD BE LOST). NOW, THIS BUG
C  IS CORRECTED IN SUBROUTINE READBLOCK, WHERE THE BEGINNING TIME OF
C  EACH IV IS TESTED AGAINST THE ENDING TIME OF THE PREVIOUS (IF THERE
C  IS A PREVIOUS ONE), AND IF THEY ARE THE SAME, THEN THE NEW IV RATE
C  OVERWRITES THE 0.0 WHICH WOULD HAVE BEEN THE NEW IV RATE IF THERE
C  HADN'T BEEN ANOTHER STARTING IV AT THAT TIME.

C  ALSO NOTE THAT THIS PROGRAM REFERS TO bigmlt12.f RATHER THAN 
C  bigmlt11.f IN FORMAT 1111.

C-----------------------------------------------------------------------

C  NPBG15E5.FOR                                            12/20/10

C  NPBG15E5 HAS THE FOLLOWING CHANGE FROM NPBG15E4:

C  1. THE CALL TO SUBROUTINE DETECT IS COMMENTED OUT. THE REASON IS
C  THAT IT WILL NOW BE ASSUMED THAT THE USER CREATES HIS MODEL FILE 

C  FROM THE TEMPLATE MODEL FILE (CURRENTLY TSTMULTH.FOR) AND SO IT 

C  WILL AUTOMATICALLY HAVE THE CORRECT DECLARATION STATEMENTS AT THE

C  TOP OF EACH SUBROUTINE. PLUS, THIS WILL PREVENT THIS PROGRAM FROM
C  STRIPPING AWAY SPECIAL DECLARATION STATEMENTS THE USER MAY NEED TO
C  ADD TO THE ROUTINES FOR SPECIAL CASE ANALYSES.

C  NOTE THAT SUBROUTINE DETECT, AND THE ROUTINES IT CALLS, WILL BE LEFT
C  IN THE CODE FOR NOW (IN CASE THEY, OR MODIFIED VERSIONS OF THEM ARE
C  NEEDED IN A FUTURE VERSION OF THIS PROGRAM).

C  2. FORMATS 919 IS CHANGED TO EMPHASIZE THAT THE USER MUST CREATE
C  HIS FORTRAN MODEL FILE AS AN EDITED VERSION OF TSTMULTH.FOR. FORMAT
C  5001 IS ALSO CHANGED TO TAKE OUT THE "BOXES" COMMENT, WHICH IS NO
C  LONGER APPLICABLE (AND HASN'T BEEN FOR SOME TIME).

C  NOTE THAT THE MAIN "engine" MODULE IS CHANGED FROM bigmlt10.f TO
C  bigmlt11.f. AND SO FORMAT 1111 IS CHANGED ACCORDINGLY.


C-----------------------------------------------------------------------

C  NPBG15E4.FOR                                            12/11/10

C  NPBG15E4 HAS THE FOLLOWING CHANGES TO NPBG15E3:

C  1. BEFORE THE TWO CALLS TO SUBROUTINE READBLOCK, NEW CODE IS PUT IN
C  TO CALL NEW SUBROUTINE NEWCSV (BASED ON THE STAND-A-LONG PROGRAM,  

C  NEWCSV.FOR) WHICH CONVERTS THE .CSV FILE INTO A SCRATCH FILE WITH 
C  EACH MISSING VALUE DOT REPLACED BY AN n. THIS IS NECESSARY SINCE, 
C  WHEN THIS PROGRAM IS COMPILED/LINKED WITH gfortran, IT INTERPRETS
C  A DOT AS A 0 (I.E., A NUMBER RATHER THAN A NON-NUMBER). THE RESULT
C  IS THAT THE STATEMENT ...
C    READ(57,*,ERR=70) COVVAL
C  IS IMPROPERLY EVALUATED WHEN A DOT IS READ. I.E., RATHER THAN 
C  BRANCHING TO LABEL 70, THE PROGRAM SETS COVVAL = 0 AND CONTINUES.

C  SINCE THERE ARE OTHER SIMILAR READ STATEMENTS, RATHER THAN TRY TO
C  ADDRESS EACH ONE INDIVIDUALLY, READBLOCK WILL READ THE SCRATCH FILE
C  INSTEAD OF THE ORIGINAL .CSV FILE. SINCE gfortran SEES AN n AS A
C  NON-NUMBER, THE CODE WILL NOW BE EXECUTED CORRECTLY.

C  NOTE THAT BLOCKPAT WILL NOW BE OPENED AS FILE 77, AND THE SCRATCH 
C  FILE WILL BE FILE 67. 


C  2. A BUG CORRECTION IS MADE IN SUBROUTINE VERIF1. SINCE ISUBALL IS
C  NOT SET BEFORE THE CALL TO THIS ROUTINE IF AN INSTRUCTION FILE IS
C  USED, THE CODE INVOLVING ISUBALL IS CHANGED TO INVOLVE A  DIRECT
C  COMPARISON OF NSUB TO NSUBTOT.

C  3. A BUG CORRECTION IS MADE IN THE ARGUMENT LIST FOR THE CALL TO

C  PRNCOVAR. PREVIOUSLY WHEN CODE WAS ADDED TO MAKE THE PROGRAM
C  COMPATIBLE WITH UNIX AS WELL AS DOS, CLEARSCREEN WAS PASSED TO 
C  EVERY ROUTINE THAT USED THE OLD CALL SYSTEM('CLS') COMMAND. BUT
C  IT WAS OMITTED IN THE CALL TO PRNCOVAR. THIS HAS BEEN CORRECTED.


C  4. THE MAIN "engine" MODULE WHICH USES THE npemdriv.f AND
C  npembg34.inp FILES MADE BY THIS PROGRAM IS CHANGED FROM bigmlt9.f
C  TO bigmlt10.f. NOTE THAT FORMAT 1111 IS CHANGED TO REFLECT THIS
C  FACT.

C-----------------------------------------------------------------------

C  NPBG15E3.FOR                                        11/21/10

C  NPBG15E3 HAS THE FOLLOWING CHANGES FROM NPBG15E2. 

C  1. IN SUBROUTINE AFTERCOMMA, THE FREE FROMAT WRITE STATEMENT TO 
C  FILE 57 IS REPLACED BY A SERIES OF FORMATTED WRITE STATEMENTS,
C  BASED ON THE NO. OF CHARACTERS TO BE WRITTEN (1 - 11). IF THE NO. OF 
C  CHARACTERS IS > 11, A FREE FORMAT IS STILL USED. THE REASON IS THAT
C  WHEN THIS PROGRAM IS COMPILED AND LINKED UNDER gfortran, A FREE 
C  FORMAT WRITE HAS AN EXTRA SPACE INSERTED AT THE BEGINNING OF THE 
C  LINE. THIS MEANT THAT, WHEN A .CSV FILE HAD AN 11 CHARACTER 
C  SUBJECT ID, ONLY THE 1ST 11 WOULD BE WRITTEN TO FILE 57. THEN, IN
C  READBLOCK, WHEN FILE 57 WAS READ, TWO OR MORE SUBJECTS WHOSE FIRST
C  10 CHARACTERS WERE THE SAME (I.E., THEY HAD DIFFERENCES ONLY IN THE
C  11TH CHARACTER) WOULD HAVE THEIR DATA COMBINED INTO THE SAME WORKING
C  COPY PATIENT DATA FILE. THIS PROBLEM DID NOT OCCUR WHEN THIS PROGRAM
C  WAS COMPILED UNDER LAHEY F90.

C  2. FORMAT 1111 IS CHANGED TO REFLECT THE FACT THAT IT IS 
C  bigmlt9.f WHICH IS THE MAIN MODULE OF THE "ENGINE", RATHER THAN
C  bigmlt6.f. AND THIS FORMAT NOW ALSO WRITES THE COMPILE/LINK COMMAND
C  IF THE PROGRAM IS BEING CREATED BY gfortran.

C  3. A CALL TO NEW SUBROUTINE PAUSE REPLACES EACH PAUSE STATEMENT. 
C  THIS IS BECAUSE A PAUSE STATEMENT CAUSES A WARNING WHEN THE PROGRAM
C  IS COMPILED AND LINKED USING gfortran (AND IT FORCES THE USER TO 
C  TYPE "go" INSTEAD OF SIMPLY HITTING THE ENTER KEY). ALSO, SEVERAL
C  PAUSE STATEMENTS THAT WERE PREVIOUSLY COMMENTED OUT ARE NOW 
C  "REINSTATED" WITH CALL PAUSE COMMANDS.


c  4. ONE OF THE MODULES LINKED WITH THIS PROGRAM, SCAT72X.FOR, IS
C  UPDATED TO BE SCAT72X1.FOR. THE CHANGE IN THAT PROGRAM IS THE SAME
C  AS NO. 3. ABOVE.

C  5. THE MAIN "ENGINE" MODULE USED WITH THIS PROGRAM IS CHANGED TO BE
C  bigmlt9.f, UPDATED FROM bigmlt8.f. THE MAIN CHANGE IN THAT PROGRAM 
C  IS THE SAME AS NO. 3. ABOVE.

C  NOTE THAT BECAUSE OF THE CALLS TO SUBROUTINES GET_COMMAND_ARGUMENT 
C  AND GETCWD (SEE YAMADA CODE), THIS PROGRAM CAN NOT BE COMPILED BY
C  LAHEY LF90.

C-----------------------------------------------------------------------


C  NPBG15E2.FOR                                     11/5/10


C  NPBG15E2.FOR IS WALTER'S VERSION OF NPBG15E1.FOR WHICH WILL RUN
C  UNDER gfortran, INSTEAD OF LF90.

C  TO OBTAIN THE NPBG15E2.EXE, DO THE FOLLOWING:


C  1. gfortran -o NPBG15E2.EXE NPBG15E2.FOR DATABLK1.FOR SCAT72X.FOR
C  THIS WILL CAUSE LOTS OF WARNINGS ABOUT PAUSE STATEMENTS, BUT IT WILL
C  CREATE NPBG15E2.EXE

C  2. "NPBG15E2 DOS" IS THE EXECUTABLE COMMAND AT THE DOS PROMPT.

C  THE PROGRAM RUNS JUST AS NPBG15E1 DOES, EXCEPT THAT THE USER HAS
C  TO TYPE IN "go" WHENEVER A PAUSE COMMAND IS ENCOUNTERED (RATHER THAN
C  HIT THE ENTER KEY).


C  TO SEE THE CHANGES, SEARCH FOR "YAMADA" IN THE CODE.
 
C-----------------------------------------------------------------------


C  NPBG15E1.FOR						6/1/10

C  NPBG15E1 = NPBIG15E WITHOUT GRAPHICS. I.E., ALL INTERACTOR CALLS
C  ARE REMOVED. THIS MODULE IS THEREFORE LINKED ONLY WITH DATABLK1.FOR,
C  AND SCAT72X.FOR, A NON-GRAPHICS VERSION OF SCAT73.FOR WHICH PRINTS
C  CALCULATIONS (PREDICTED VALUES, REGRESSION COEFFICIENTF, ETC.) WHICH
C  CAN BE WRITTEN TO FILES, BUT DOES NOT CALL ANY INTERACTOR ROUTINES.

C  NOTE THAT GRAPHICS-RELATED ROUTINES, GETOUT, PLOTS, CALMAR, THREED1,
C  CONVERGE, PLTCON, MINMAX, AND EXTREME ARE ALL REMOVED.

C  NOTE THAT ALL PAUSE COMMANDS (EXCEPT THOSE THAT PRECEDE STOP
C  COMMANDS) HAVE BEEN REMOVED. THIS IS BECAUSE WE WILL SOMETIMES

C  BE USING GFORTRAN WHICH FORCES THE USER TO ENTER "GO" EVERYTIME
C  A PAUSE COMMAND OCCURS ... WHICH IS TEDIOUS.

C-----------------------------------------------------------------------

C  NPBIG15E.FOR						4/03/10




C  NPBIG15E HAS THE FOLLOWING CHANGES FROM NPBIG15D:

C  1. AFTER THE PROGRAM MAKES npemdriv.f AND npembg34.inp, IT WILL
C  MAKE SURE THAT THERE ARE NO EXTRA LINES WITH SPURIOUS CHARACTERS
C  (E.G., LITTLE BOXES) AT THE END OF THESE FILES, BY COPYING THESE
C  FILES LINE BY LINE TO .BAK FILES, AND THEN COPYING THE .BAK FILES
C  BACK TO THE ORIGINAL FILES. SEE CODE AROUND LABELS 3100 AND 4100.

C  2. NEW CODE IS PUT INTO SUBROUTINE READBLOCK (SEE FORMAT 8888) SO THE
C  PROGRAM WON'T SEEM TO HAVE "HUNG" WHEN IT CONVERTS A LARGE PATIENT
C  DATA POPULATION FROM A .CSV FILE TO WORKING COPY FILES.

C  3. THE USER NOW CAN HAVE HIS SAVED INSTRUCTIONS (WHICH HAVE BEEN
C  ALREADY SAVED INTO PATHFILAST) SAVED BACK TO THE ORIGINAL INSTRUCTION
C  FILE IF THERE WAS ONE, OR TO ANY OTHER FILE OF HIS CHOICE. SEE CODE
C  JUST AFTER LABEL 400 IN MAIN.

C  4. THE CODE FOR THE DENSITY FILE WILL NOW BE CHANGED SINCE NUMT WILL
C  NOT BE THE SAME FOR EACH SUBJECT. I.E., NUMT(JSUB) AND TTPRED(JSUB,J)
C  WILL HAVE TO BE READ FOR EACH SUBJECT (SEE CODE). THIS MEANS THAT
C  ALL CODE RELATED TO NUMTT+1 WILL NOW BE CHANGED TO BE NUMT(JSUB).
C  ALSO, SINCE THE COMBINED OUTPUT FILE INCLUDES THE DENSITY FILE, ITS
C  CODE WILL HAVE A NEW VERSION NO (40), WHICH WILL BE REQUIRED. I.E.,
C  NO OLDER OUTPUT FILES WILL BE ALLOWED SINCE THERE ARE SO MANY CHANGES
C  IN THE DENSITY FILE.

C  5. THE AUC TABLES AT THE END OF THE RUN WILL CHANGE IF THERE ARE
C  TIME RESETS IN A PATIENT'S DATA FILE. IN PARTICULAR, THERE WILL BE

C  ONE AUC TABLE FOR EACH SUBJECT x OUTPUT EQUATION x TIME RESET.
C  PREVIOUSLY, THE SINGLE TABLE FOR EACH SUBJECT x OUTPUT EQUATION
C  CALCULATED THE AUC THROUGH 24 HOURS PAST THE MAXIMUM OBSERVATION
C  TIME OVER ALL PATIENTS, BUT ONLY FOR THE FIRST SET OF DOSES (I.E.,
C  TIME RESETS WERE IGNORED). SIMILARLY THE PRTB FILE IS NOW CORRECTED
C  TO GIVE AS MANY SETS OF PREDICTED VALUES AS THERE ARE TIME RESETS
C  FOR EACH SUBJECT (IN ADDITION TO THE LAST SET AT THE ACTUAL
C  OBSERVED TIMES).

C  6. THE CALCULATION OF T_END HAS BEEN REMOVED SINCE IT IS NO LONGER
C  APPLICABLE IN THIS PROGRAM WHERE, BECAUSE OF POSSIBLE TIME RESETS
C  IN THE PATIENT DATA FILES, EACH SUBJECT WILL HAVE MULTIPLE POSSIBLE
C  T_ENDs (SEE bigmlt6.f CODE). SUBROUTINE FINDTEND HAS BEEN REMOVED,
C  AS HAS ALL REFERENCE TO TIMMAX (INCLUDING IN SUBROUTINE PUTASS).
C  NOTE THAT T_END = 99 WILL STILL BE WRITTEN TO npembg34.inp SO THE
C  FORMAT OF THIS FILE DOES NOT HAVE TO BE CHANGED.

C  7. THE "ENGINE" MAIN MODULE IS NOW bigmlt6.f, CHANGED FROM bigmlt5.f.
C  THE MAIN DIFFERENCE IS THAT THE PRTB FILE WAS NOT COMPLETELY WRITTEN
C  IN THE CASE WHERE THERE WERE DOSE RESETS IN THE PATIENT DATA FILES
C  (SEE bigmlt6.f CODE). NOTE THAT bigmlt5.f IS REPLACED BY bigmlt6.f
C  IN FORMAT 1111.

C  8. NOTE THAT bigmlt6.f WILL NOW BE LINKED WITH 3 NEW id MODULES
C  (idm1x5.f, idm2x5.f, and idm3x5.f). THE PREVIOUS id MODULES HAD A
C  BUG RELATED TO THE TIME RESETS (SEE CODE IN THE NEW id MODULES).

C-----------------------------------------------------------------------

C  NPBIG15D.FOR							12/06/09

C  NPBIG15D HAS THE FOLLOWING CHANGES FROM NPBIG15C:


C  1. SUBROUTINE READBLOCK, AND THE ROUTINES IT CALLS ARE CHANGED TO
C  REFLECT THAT, FOR EACH SUBJECT, THE ROWS IN THE BLOCK FORMAT FILE
C  WILL BE ENTERED IN ORDER, CHRONOLOGICALLY. THIS WILL MAKE THE USER
C  REQUIREMENTS FOR SPECIFYING A TIME RESET SIMPLER. ALSO, AN ADDITIONAL
C  ENTRY WILL NOW BE INCLUDED - EVENT ID WHICH WILL BE THE NEW COLUMN 2.
C  IF EVID = 1, IT WILL MEAN THE LINE HAS DOSE INFO; IF EVID = 4, IT
C  WILL MEAN THE LINE HAS DOSE INFO AND REPRESENTS A TIME RESET EVENT.
C  IF EVID = 0, IT WILL MEAN THE LINE HAS OBSERVED VALUE INFO.
C  SINCE THERE IS A NEW COLUMN IN THE BLOCK FORMAT FILE, THE FILE
C  WILL HAVE A NEW CODE IN LINE 1, BIGNPAG NOV_09.

C  NOTE THAT THE NEW CODE FOR READBLOCK, AND THE ROUTINES IT CALLS,
C  COMES DIRECTLY FROM TESTRD8.FOR, A STAND-A-LONE VERSION OF THE
C  CODE WHICH CONVERTS BLOCK FORMAT FILES TO WORKING COPY FILES.



C  NOTE THAT THERE ARE TWO NEW ROUTINES, FIXOUTIM AND GETMAXTIM, ADDED
C  TO THE PROGRAM (FROM TESTRD8.FOR).

C  NOTE THAT IN SUBROUTINE WRITEDOS, FORMAT 304 IS CHANGED. AN EXTRA
C  3 SPACES IS ADDED BETWEEN THE COV. NAMES AND THE 1ST COV. VALUE.

C  2. IN SUBROUTINE GETCOVAL, THE MEAN OF EACH COVARIATE IS
C  NOW READ IN WITH A FREE FORMAT TO MAKE SURE THAT IF THE VALUE
C  STARTS IN AN UNEXPECTED ENTRY IT STILL WILL BE READ CORRECTLY
C  (ASSUMING IT IS THE 3RD NUMBERIC VALUE ON THE LINE).

C  SIMILARLY IN SUBROUTINES GETCOVAR AND GETCOVR2, THE NAME OF
C  THE COVARIATE IS READ IN AS ALL CHARACTERS UP TO, BUT NOT INCLUDING,
C  THE FIRST SPACE.

C  3. THE USER WILL NOW SPECIFIY A FILE TO SAVE THE INPUT INSTRUCTIONS
C  AT THE START OF THE PROGRAM. THIS FILE WILL BE USED REGARDLESS OF
C  WHETHER THE USER ENTERS INFO VIA THE OUTPUT OF A BIG IT2B RUN, VIA AN
C  INSTRUCTION FILE MADE BY A PREVIOUS RUNNING OF THIS PROGRAM, OR VIA
C  THE KEYBOARD. IF THE USER USES KEYBOARD ENTRY, THE PROGRAM WILL SAVE
C  THE DATA AS THEY ARE INPUT (USING NEW SUBROUTINE WRITEINFILE). ALSO,
C  REGARDLESS OF HOW THE DATA ARE ENTERED, WHEN SUBROUTINE VERIF1 IS
C  CALLED, IT CALLS WRITEINFILE TO WRITE DATA TO THE SPECIFIED FILE
C  FOR SAVING. THIS WAY, IF THE PROGRAM SHOULD BOMB BEFORE THE USER
C  FINISHES ENTERING ALL DATA, OR WHILE HE IS CHANGING DATA IN
C  SUBROUTINE VERIF1, THE SAVED INSTRUCTION FILE WILL HAVE SAVED THE
C  MOST RECENT SET OF INPUT INFO.


C  4. MAXDIM IS CHANGED TO BE 30 IN THE PARAMETER STATEMENT, FROM
C  25. 30 IS THE VALUE USED BY THE LAST SINGLE DRUG PROGRAM,
C  NPBIG10L.FOR, AND SHOULD HAVE BEEN THE VALUE ALL ALONG IN THIS
C  SERIES.

C  5. THE 3 id MODULES OF THE "engine" ARE CHANGED. THEY ARE NOW
C  CALLED idm1x4.f, idm2x4.f, AND idm3x4.f. THESE CHANGES ARE TO

C  CORRECT A BUG IN THE CODE FOR THE CASE N = 0. THE OTHER MODULES
C  OF THE "engine" ARE UNCHANGED. BECAUSE THESE MODULES ARE CHANGED,


C  THE NAME OF THE MAIN "ENGINE" MODULE, bigmlt4.f, IS CHANGED TO
C  bigmlt5.f (EVEN THOUGH THERE ARE NO CODE CHANGES IN bigmlt5.f).

C-----------------------------------------------------------------------

C  NPBIG15C.FOR							9/18/09

C  NPBIG15C HAS THE FOLLOWING CHANGES FROM NPBIG15B:

C  1. SUBROUTINE DETECT IS CHANGED BECAUSE THE NEW npemdriv.f (BASED

C  NOW ON TSTMULTG.FOR) WILL NOW CONTAIN NEW ROUTINES, GETFA, GETIX, AND

C  GETTLAG. EACH ROUTINE HAS A SECTION WHICH THE USER CAN EDIT TO
C  SPECIFY EXPLICITLY THE VALUES FOR THE FA VECTOR, THE INITIAL
C  CONDITION VECTOR, AND THEN TIMELAG VECTOR, RESPECTIVELY. THIS
C  USER-SUPPLIED CODE MUST BE CONSISTENT, OF COURSE, WITH THE
C  USER-DEFINED PARAMETERS (JUST AS THE CODE IN SUBROUTINES DIFFEQ AND
C  OUTPUT MUST BE CONSISTENT WITH THE USER-DEFINED PARAMETERS).

C  2. BECAUSE OF 1., ALL REFERENCE TO IFA, IC, IVOL, AND NTLAG IN
C  THIS MODULE HAVE BEEN REMOVED. THIS INCLUDES REMOVING NTLAG FROM
C  COMMON/CNST.

C  3. NOTE THAT THIS TEMPLATE MODEL FILE, TSTMULTG.FOR, IS FIRST USED
C  WITH THE NPBIG15C.FOR PROGRAM, AND THE FIRST ID MODULES WHICH WILL
C  CALL THE ROUTINES FROM THIS FILE ARE idm1x3.f, idm2x3.f, AND
C  idm3x3.f, WHICH ARE PART OF THE bigmlt4.f "engine". ALSO, NOTE THAT
C  THE SHIFT MODULE CALLED BY THESE id ROUTINES IS NOW shift5.f, CHANGED
C  FROM shift4.f.

C  4. ALL REFERENCES TO TSTMULTF.FOR ARE CHANGED TO TSTMULTG.FOR.

C  5. LINKMLT2.BAT IS CHANGED TO LINKMLT4.BAT (AND bigmlt2 IS CHANGED
C  TO bigmlt4 IN FORMAT 1111.

C  6. THE CODE BELOW LABEL 120 IN SUBROUTINE READBLOCK IS CHANGED TO
C  CHECK FOR #id or "#id as well as #ID or "#ID.

C  7. IN READBLOCK, THE I/O FROM THE USER REGARDING TYPE OF COVARIATE

C  IS MOVED BELOW THE, IF(ICALL .EQ. 2) RETURN  STATEMENT. THIS IS
C  BECAUSE IF ICALL = 2, READBLOCK WAS CALLED BY SUBROUTINE GETNUMEQ
C  JUST TO OBTAIN THE NO. OF OUTPUT EQUATIONS. IN THE PREVIOUS PROGRAM,
C  THIS I/O WAS NEAR THE TOP OF READBLOCK --> THE I/O WAS PRESENTED TO
C  THE USER TWICE WHEN THE USER ENTERED INFO VIA THE KEYBOARD.


C  8. ALL OF THE STOP COMMANDS IN THE PROGRAM ARE NOW PRECEEDED BY A

C  PAUSE COMMAND ... SO THAT THE USER CAN SEE THE MESSAGE INDICATING
C  WHY THE PROGRAM STOPPED BEFORE THE SCREEN CLOSES.

C  9. SOME EXTRA DEBUG LINES WERE REMOVED FROM SUBROUTINE CHECKLIN. THEY
C  SHOULD HAVE BEEN REMOVED BEFORE NPBIG15B.FOR WAS COMPILED AND LINKED.

C-----------------------------------------------------------------------

C  NPBIG15B.FOR							9/06/09

C  NPBIG15B HAS THE FOLLOWING CHANGES FROM NPBIG15A:


C  1. THE TEMPLATE MODEL FILE WILL NOW BE TSTMULTF.FOR, CHANGED FROM
C  TSTMULTE.FOR. THE REASON IS THAT SUBROUTINES DIFFEQ AND OUTPUT IN
C  TSTMULTF.FOR WILL NOW INCLUDE COMMON/CNST2, WHICH WILL PROVIDE NDRUG
C  (THE NO. OF DRUGS IN THE PATIENT DATA FILES) AND NADD (THE NO. OF

C  ADDITIONAL COVARIATES IN THE PATIENT DATA FILES). WITH THIS INFO,
C  TSTMULTF.FOR WILL IDENTIFY, EXPLICITLY, WHICH ENTRIES OF R ARE THE
C  IV RATES AND WHICH ARE THE COVARIATE VALUES, TO MAKE THINGS CLEARER
C  FOR THE USER.

C  THE ABOVE CHANGE REQUIRES ADDITIONAL CODE IN SUBROUTINE DETECT
C  BEFORE THE CALLS TO WRITEDIF AND WRITEOUT ... TO CHECK THAT THE USER
C  IS USING THE APPROPRIATE TEMPLATE FORTRAN MODEL FILE, TSTMULTF.FOR.

C  2. THE CODE REQUIRED FOR THE BLOCK FORMAT FILE CAN BE AS IT WAS


C  IN PREVIOUS PROGRAMS, "BIGNPAG xxx_xx IN ENTRIES 1:15, OR THE NEWLY
C  ALLOWED  BIGNPAG xxx_xx  IN ENTRIES 1:14. THIS ALLOWABLE CHANGE
C  OCCURS IN MAIN (TWICE) AND SUBROUTINES VERIF1 AND GETNUMEQ.

C  3. SUBROUTINE READBLOCK IS CHANGED TO READ IN THE NO. OF COVARIATES
C  AS NCOMMA - 6 (NCOMMA IS THE NO. OF COMMAS ON EACH DATA LINE), SINCE
C  THE LINE WITH THE NO. OF COVARIATES WILL NOT, IN GENERAL, BE IN THE

C  BLOCK FORMAT PATIENT DATA FILE ANYMORE. THEN, THE TYPE OF COVARIATE

C  (PIECEWISE CONSTANT OR INTERPOLATED) WILL BE READ IN FROM THE USER
C  VIA THE KEYBOARD.

C  4. SUBROUTINE WRITEDOS IS CHANGED. THE CODE TO ESTABLISH COVARIATE
C  VALUES HAS BEEN ADJUSTED TO TAKE INTO ACCOUNT THAT IF A TIME RESET
C  OCCURS, THEN EVEN INTERPOLATED COVARIATE VALUES WILL SIMPLY BE
C  ASSIGNED THEIR PREVIOUS VALUE (SEE CODE FOR WHY IT IS IMPOSSIBLE TO
C  INTERPOLATE BETWEEN TWO TIMES IF THE 2ND TIME IS OUT OF ORDER ...
C  BECAUSE IN A TIME RESET, THE 2ND TIME GOES BACK TO 0.0).


C  NOTE THAT BEFORE WRITEDOS IS CALLED BY READBLOCK, A NEW SUBROUTINE,
C  TIMESET (WHICH CALLS A NEW ROUTINE, ORDER), IS CALLED. IT ESTABLISHES
C  THE COMPLETE SET OF TIMES IN THE DOSAGE REGIMEN FOR EACH SUBJECT,

C  WITH NO DUPLICATES, AND EACH SET OF TIMES, BEFORE THE NEXT TIME
C  RESET, IS ORDERED. TO MAKE THE LOGIC IN TIMESET WORK PROPERLY, THE
C  USER MUST NOW CODE TIME RESETS IN THE DOSAGE REGIMENT AS -99'S,
C  RATHER THAN 0'S. THIS IS BECAUSE TWO CONSECUTIVE LINES IN THE
C  DOSAGE REGIMENT WITH TIMES = 0 COULD HAVE MEANT EITHER THE 2ND WAS
C  A TIME RESET, OR JUST ANOTHER LINE WITH THE ORIGINAL INITIAL TIME

C  OF 0 (E.G., TWO LINES AT T = 0 WOULD BE REQUIRED IF THE USER HAD
C  A REGIMEN WITH TWO DRUGS, EACH GIVEN AT T = 0).

C  ALSO NOTE THAT THE CODE HAS BEEN FIXED WITH REGARD TO THE OUTPUT
C  VALUES. PREVIOUSLY, IF THERE WERE MULTIPLE OUTPUT EQUATIONS, WITH
C  TIME RESETS, THE PROGRAM WOULD NOT CORRECTLY ESTABLISH THE
C  WORKING COPY OBSERVED VALUE BLOCK. NOW, THIS IS FIXED.

C  NOTE ALSO, THAT A TIME RESET VALUE OF 0 IN THE BLOCK FORMAT FILE
C  WHICH APPLIES TO AN OUTPUT VALUE, APPLIES ONLY TO THE INDICATED
C  OUTPUT EQUATION; THE TIME FOR AN OUTPUT VALUE FROM A DIFFERENT OUTPUT
C  EQUATION IS ASSUMED TO BE BASED ON THE ORIGINAL TIME 0, OR THE LAST
C  TIME RESET FOR THAT EQUATION.

C  ON THE OTHER HAND, ANY TIME RESET INDICATOR OF -99 FOR A DOSE LINE

C  CAUSES ALL SUBSEQUENT DOSE LINE TIMES TO BE TIMES FROM THAT RESET
C  VALUE OF 0.


C  ALSO, THERE WAS A BUG IN THE PREVIOUS CODE, EVEN WITHOUT TIME RESETS.
C  IF ISAME = 0 AND ICOVTYPE(.) = 1, THE COVARIATE VALUE WAS NOT SET.
C  THIS HAS BEEN FIXED ALSO.

C  5. SUBROUTINE READBLOCK HAS ADDITIONAL CODE SO THAT ALL LINES WITH
C  A LEADING # OR "# ARE IGNORED ... EXCEPT THE LINE STARTING WITH
C  #ID OR "#ID. THIS LINE IS READ TO ESTABLISH THE NAMES OF THE
C  COVARIATES.


C  6. THE ORDER OF VALUES ENTERED IN THE BLOCK FORMAT IS CHANGED. NOW
C  IT WILL BE (ID, TIME, INFUSION DURATION, TOTAL DOSE, INPUT DRUG NO.,
C  OUTPUT VALUE, OUTPUT EQ., COVARIATES IF ANY). THIS CHANGE IS MADE
C  IN SUBRUTINE READBLOCK BY CHANGING THE 3RD ARGUMENT IN EACH CALL
C  TO SUBROUTINE AFTERCOMMA TO REFLECT HOW MANY COMMAS PRECEED AN
C  INPUT VARIABLE.

C  NOTE THAT THIS CHANGE WILL REQUIRE A NEW CODE AT THE TOP OF A
C  BLOCK FORMAT FILE; THE NEW CODE WILL BE BIGNPAG AUG_09. THIS CHANGE
C  IS PUT IN SEVERAL PLACES, AROUND EACH FORMAT 3131 IN THE PROGRAM.
C  ALSO ICODEPAT = 23 IS CHANGED TO ICODEPAT = 1 IF THE BLOCK FORMAT
C  PATIENT FILE HAS THE CORRECT DATE (AUG_09). THERE WAS NO REASON FOR
C  THE NUMBER, 23 (IT WAS ORIGINALLY 23 SINCE ICODE = 23 FOR AN
C  INSTRUCTION FILE WITH THE SAME FEB_08 DATE, BUT ICODE AND ICODEPAT
C  ARE INDEPENDENT).

C  7. THE "engine" MAIN MODULE IS NOW bigmlt3.f (WHICH IS THE SAME AS
C  bigmlt2.f EXCEPT FOR SOME COSMETIC CHANGES IN FORMAT STATEMENTS),
C  AND IT WILL NOW BE COMPILED AND LINKED WITH NEW MODULES, idm1x2.f,
C  idm2x2.f, idm3x2.f, AND shift4.f (AND blasnpag.f WHICH DOESN'T
C  CHANGE), ALONG WITH npemdriv.f. THE REASON IS THE NEW OPTIONS
C  AVAILABLE IN THE NEW TEMPLATE FILE, TSTMULTF.FOR. IN PARTICULAR:

C  THE USER CAN NOW SELECT NTLAG(I) = A NEGATIVE INDEX WHICH WILL MEAN
C  IN SUBROUTINE SHIFT (IN shift4.f), TAU(I) = EXP(P(-NTLAG(I)). I.E.,
C  A NEGATIVE VALUE OF NTLAG(I) --> USE A LOGNORMAL DIST. FOR TLAG.

C  A SIMILAR OPTION IS ADDED FOR IFA(I) IN TSTMULTF.FOR.
C  ALSO, CHANGE NO. 1 ABOVE MEANS THAT THE CODE TO SET INITIAL
C  CONDITIONS IS CHANGED IN THE idm_ MODULES SO THAT -IC(.) REFERS TO

C  THE INDEX OF COVARIATES NOT THE INDEX OF RS(1,.).

C  8. PAUSE STATEMENTS HAVE BEEN INSERTED AFTER THE 3 FORMATS IN
C  SUBROUTINE FINDTEND, SO THE USER CAN SEE WHAT THE LAST PREDICTED
C  OBSERVATION TIME WILL BE (FOR THE AUC TABLES, ETC.). THESE MESSAGES
C  WERE VIEWABLE ON THE SCREEN PREVIOUSLY, BUT NOW THEY WILL REQUIRE
C  AN EXTRA PRESSING OF THE ENTER KEY BY THE USER.

C-----------------------------------------------------------------------

C  NPBIG15A.FOR							5/29/09

C  NPBIG15A HAS THE CHANGES TO NPBIG15 THAT WERE MADE IN THE SINGLE
C  DRUG PROGRAM FROM NPBIG10G.FOR THROUGH NPBIG10L.FOR, NAMELY:

C  1. THE TIME INTERVAL FOR AUCs, INSTEAD OF BEING HARDCODED TO BE 24
C  HOURS, WILL BE SET BY THE USER. TO DO THIS, THE FOLLOWING CHANGES
C  HAVE BEEN MADE:

C  a. NEW KEYBOARD ENTRY OF THIS NEW VARIABLE, CALLED AUCINT HAS BEEN
C     ADDED (IN MAIN AND IN SUBROUTINE VERIF1).
C  b. THE SAVED INPUT FILE WILL HAVE A NEW CODE ('REM_BAK MAY_09') TO
C     ALLOW FOR THE NEW VARIABLE, AUCINT.
C  c. npembig33.inp HAS BEEN CHANGED TO npembg34.inp TO ALLOW FOR THE
C     NEW VARIABLE.
C  d. AUCINT HAS BEEN DEFAULTED TO 24 HOURS WHEN THE INSTRUCTIONS COME
C     VIA A FILE FROM THE BIG IT2B PROGRAM.
C  e. THE "engine" WHICH IS COMPATIBLE WITH THE NEW npembg34.inp WILL
C     BE bigmlt2.f, CHANGED FROM bigmlt1.f.


C  2. THE NO. OF RANDOM AND FIXED PARAMETERS IS CHECKED EXPLICITLY TO
C  MAKE SURE THAT THESE VALUES ARE WITHIN BOUNDS. THE NEW RESTRICTIONS
C  ARE:

C  NVAR (NO. OF RANDOM PARAMETERS) IS .LE. 30
C  NOFIX (NO. OF FIXED PARAMETERS) IS .LE. 20 (THIS COMMENT IS .LE. 13
C   IN NPBIG10L.FOR, BUT IT SHOULD BE 20.
C  NVAR + NOFIX .LE. 32

C  NOTE THAT NVAR WAS ALREADY CHECKED TO MAKE SURE IT IS .LE. MAXDIM,
C  WHICH IS 30, IN SUBROUTINE USERPREP. NOW, NOFIX IS ALSO CHECKED TO
C  MAKE SURE IT IS .LE. 20, AND NVAR + NOFIX IS CHECKED TO MAKE SURE
C  THE SUM IS .LE. 32 IN THE SAME ROUTINE. AND NOTE THAT PSYM(25) IS
C  CHANGED TO PSYM(32) IN SUBROUTINES USERPREP AND WRITESYM.

C  IN ADDITION, THE DIMENSIONS OF PAR, PARFIX, VALFIX, AND IRAN ARE
C  MADE CONSISTENT WITH THE MAXIMUM ALLOWED VALUES (A MAXIMUM OF 30
C  RANDOM PARAMETERS AND 20 FIXED PARAMETERS). IN PARTICULAR:
C  ALL ARRAYS RELATED TO THE NO. OF RANDOM VARIABLES ARE NOW DIMENSIONED
C  30; ALL ARRAYS RELATED TO THE NO. OF FIXED PARAMETERS ARE NOW

C  DIMENSIONED 20; AND IRAN IS NOW DIMENSIONED 32.

C  ALSO, ALL FORMATS RELATED TO THE NO. OF RANDOM VARIABLES ARE CHANGED
C  TO 30 FROM 25; SIMILARLY THOSE RELATED TO THE NO. OF FIXED VARIABLES

C  ARE CHANGED FROM 12 TO 20.

C  NOTE THAT THIS PROGRAM WILL BE COMPILED AND LINKED WITH A NEW MODEL
C  FILE TEMPLATE, TSTMULTE.FOR, WHICH DIFFERS FROM THE OLD TSTMULTD.FOR
C  IN THAT PSYM IS DIMENSIONED 32 (INCREASED FROM 25) IN SUBROUTINE
C  SYMBOL (SEE OTHER COMMENT ABOUT TSTMULTE.FOR BELOW).

C  THE "ENGINE" FOR THIS PROGRAM IS CHANGED FROM bigmlt2.f to bigmlt2.f.

C  THE CHANGES IN bigmlt2.f ARE SIMILAR TO THOSE ABOVE: ALL DIMENSIONS
C  AND FORMATS RELATED TO THE NO. OF RANDOM VARIABLES ARE CHANGED TO
C  30 FROM 25. AND THOSE RELATED TO THE NO. OF FIXED PARAMETERS ARE


C  CHANGED FROM 12 TO 20.

C  3. ALL *300 DECLARATIONS WILL BE CHANGED TO *1000. THIS IS TO
C  BE CONSISTENT WITH THE FORMAT THAT bigmlt2.f USES TO WRITE ITS
C  OUTPUT FILES (SEE bigmlt2.f CODE). THIS MEANS THAT ALL A300
C  FORMATS WILL BE CHANGED TO A1000.

C  4. FORMAT 1111 IS CHANGED TO REFLECT NEW PROGRAM AND FILE NAMES.

C  5. THE USER IS NOW ALLOWED TO REQUEST AN ANALYSIS WITH MAXCYC = 0.
C  IN THIS CASE, IT MEANS THAT THE "engine" WILL DO NO CYCLE
C  CALCULATIONS, BUT INSTEAD MOVE DIRECTLY TO THE END-OF-ANALYSIS
C  CALCULATIONS. THIS, IN EFFECT, WILL GIVE THE BAYESIAN RESULTS FOR
C  WHATEVER PATIENT DATA SET THE USER HAS CHOSEN, BASED ON THE PRIOR
C  DENSITY THE USER INPUTS. THIS IS SOMETIMES CALLED PROSPECTIVE
C  ANALYSIS.

C  SEE CODE CHANGES IN MAIN AND SUBROUTINE VERIF1, WHERE MAXCYC IS
C  ENTERED.

C  PREVIOUSLY, THE "engine", CURRENTLY bgmlt1.f, WOULD DO THE ABOVE
C  BAYESIAN ANALYSIS, BUT THE USER HAD TO MANUALLY EDIT npembig33.inp
C  AND CHANGE MAXCYC TO BE 0 BECAUSE NPBIG15 WOULD NOT ALLOW IT TO
C  BE SET = 0.

C  6. THIS PROGRAM NOW ALLOWS MARGINAL HISTOGRAMS TO ALSO BE PLOTTED AS
C  CUMULATIVE HISTOGRAMS.

C  7. FOR OPTION 6, THERE IS NOW AN ADDITIONAL SUB-OPTION ... TO PRINT
C  OUT A PLOT (AND VALUES TO THE OPTION 6 OUTPUT FILE IF DESIRED) OF
C  PREDICTED VALUES FOR THE MODEL BASED ON THE MEANS, MEDIANS, OR MODES
C  OF THE FINAL CYCLE POPULATION DENSITY. THESE PREDICTED VALUES ARE


C  CALCULATED AS A FUNCTION OF TIME, WHERE T HAS THE SAME TIME VALUES AS
C  ARE USED IN THE PRTB FILE - I.E., THE "engine", WHICH WILL NOW BE
C  bigmlt2.f, WILL STORE YPREDPOPT(JSUB,IEQ,J,ICENTER), WHERE

C  JSUB = 1,NSUB; IEQ = 1,NUMEQT; J = 1,NUMTT+1; ICENTER = 1,3, WHERE
C  THESE PREDICTED VALUES ARE STORED AT THE NUMTT+1 T'S = BETWEEN 0 AND
C  24 HOURS AFTER THE LAST OBSERVATION TIME OVER ALL THE POPULATION
C  PATIENT DATA FILES, USING THE SAME TIME INTERVAL AS IN THE PRTB FILE,
C  UNLESS THIS INTERVAL WOULD RESULT IN NUMTT > 7200. IN THIS CASE, THE
C  TIME INTEVAL IS INCREASED (SEE bigmlt2.f LOGIC).

C  NOTE: SINCE EACH PATIENT DATA FILE CAN HAVE ITS OWN DOSAGE REGIMEN,
C  EACH PATIENT GETS HIS OWN DOSAGE REGIMEN, BUT THE PARAMETERS
C  USED ARE THOSE OF THE MEAN/MEDIAN/MODE (AS SELECTED BY THE USER) OF
C  THE ENTIRE POPULATION FROM THE LAST CYCLE.

C  NOTE THAT THIS PROGRAM WILL NOW BE LINKED WITH SCAT73.FOR RATHER
C  THAT SCAT72XX.FOR. THE DIFFERENCE IS THAT SCAT73 HAS AN ADDITIONAL
C  SUBROUTINE, SCATPLOT2, TO PLOT THE ABOVE PRED. VALUES VS. T GRAPH.

C  NOTE ALSO THAT SCAT73.FOR HAS A BUG CORRECTION TO SCAT72XY.FOR
C  WHICH WAS USED IN THE SINGLE DRUG PROGRAM, NPBIG10L.FOR.

C  8. THIS PROGRAM ALLOWS THE ADDITIONAL INITIAL CONDITION LOGIC
C  I USED FOR MICHAEL NEELY'S AD-HOC PROGRAMS (SEE \ALAN3\NEELY\DOUBLE\
C  BIG2X.EXP, BIG2XX.EXP, BIG2XXX.EXP AND THE RELATED .FOR FILES). IN
C  PARTICULAR, THE USER CAN NOW SET THE INITIAL AMOUNT IN ANY
C  COMPARTMENT THE OLD WAY (DESIGNATING IT TO BE A PARTICULAR PARAMETER)
C  OR THE NEW WAY (SETTING IT = INITIAL COMP. CONCENTRATION * VOLUME,
C  WHERE VOLUME = A DESIGNATED PARAMETER AND INITIAL COMP. CONCENTRATION
C  IS THE FIRST VALUE FOR A SPECIFIED COVARIATE.

C  NOTE THAT THIS PROGRAM WILL BE COMPILED AND LINKED WITH A NEW MODEL
C  FILE TEMPLATE, TSTMULTE.FOR, WHICH DIFFERS FROM THE OLD TSTMULTD.FOR
C  IN SUBROUTINE SYMBOL WHERE THE NEW LOGIC FOR INITIAL CONDITIONS
C  RESIDES, AND WHERE COMMON/INITCOND NOW INCLUDES AN EXTRA VECTOR,
C  IVOL. (SEE OTHER COMMENT ABOUT TSTMULTE.FOR ABOVE).

C  THE ONLY CHANGE TO THIS MODULE DIRECTLY FOR, REGARDING THE NEW
C  TSTMULTE.FOR, IS IN SUBROUTINE WRITESYM, WHERE IVOL IS WRITTEN TWICE.

C  AS INDICATED ABOVE, THE NEW "engine" FOR THIS PROGRAM IS bigmlt2.f.
C  NOTE THAT ITS 3 ID MODULES ARE CHANGED TO INCLUDE THE NEW LOGIC
C  INDICATED HERE. IN PARTICULAR, idfix5g.f IS CHANGED TO idm1x1.f;

C  idcy_53g.f IS CHANGED TO idm2x1.f; and idcy_63g.f IS CHANGED TO
C  idm3x1.f.

C  9. THIS PROGRAM CALCULATES TIMMAX AS THE MAXIMUM TIME OVER ALL THE
C  OBSERVATION TIMES OVER ALL SUBJECTS, RATHER THAN AS THE MAXIMUM TIME
C  OVER THE LAST OBSERVATION TIME OVER ALL SUBJECTS. THE DIFFERENT
C  LOGIC IS REQUIRED BECAUSE NOW THE PATIENT DATA FILES ARE ALLOWED TO
C  HAVE OBSERVATION TIMES WHICH RESET TO 0 WHEN A LONG ENOUGH TIME HAS
C  PASSED BETWEEN DOSES THAT ALL COMPARTMENT AMOUNTS CAN ASSUMED TO BE

C  RESET TO 0. THIS MEANS THAT THE LAST OBSERVATION TIME IS NOW THE
C  MAXIMUM OBSERVATION TIME SINCE THE LAST RESET, BUT NOT NECESSARILY
C  THE MAXIMUM OVERALL OBSERVATION TIME. THE CHANGE IN CALCULATING
C  TIMMAX OCCURS IN SUBROUTINE PUTASS. NOTE THAT TWO NEW ARGUMENTS,
C  MAXOBDIM AND YO, ARE NOW PASSED TO PUTASS.

C  NOTE THAT IN SUBROUTINE WRITEDOS, FORMATS 11 AND 61 ARE CHANGED TO
C  ALLOW OUT-OF-ORDER TIMES, BUT THE USER IS WARNED NOT TO CONTINUE
C  IF THESE OUT-OF-ORDER TIMES ARE NOT TIME "RESETS".

C  NOTE THAT THE NEW "engine" id modules, idm1x1.f, idm2x1.f, AND

C  idm3x1.f (see above) INCLUDE NEW LOGIC TO HANDLE THESE TIME
C  RESETS.

C  10. IVERS IS HARDCODED TO BE 0 IN SUBROUTINE DETECT. THE IVERS = 1
C  OPTION WAS NEVER USED ANYMORE.

C  11. IN SUBROUTINE PREVRUN, READLIN2*78 IS USED SO THAT THE LINES
C  WRITTEN TO THE SCREEN WILL NOT HAVE A LOT OF BLANK LINES.

C  12. IN SUBROUTINE PREVRUN, THE CODE FEB_08 FOR AN OUTPUT FILE IS
C  CORRECTED TO BE NOV_07 (FEB_08 IS CODE FOR A SAVED INST. FILE).

C  13. MAXSUB IS CHANGED FROM 999 TO 800. THIS WAS NECESSARY BECAUSE
C  800 WAS NEAR THE MAXIMUM VALUE FOR THE PROGRAM TO RUN WITHOUT
C  CRASHING WHEN SUBROUTINE READBLOCK WAS CALLED WITH THE ERROR
C  MESSAGE, "Insufficient RAM to continue".

C  14. IN SUBROUTINE PRNLAST, THE COMMENT THAT CNTRL + C CAN BE USED
C  TO STOP THE PRINTING OF THE LAST CYCLE IS REMOVED (SINCE THIS IS
C  NO LONGER POSSIBLE). INSTEAD, THE USER GETS THE OPTION TO RETURN
C  AFTER EACH PAGE OF LINES. ALSO, FORMAT 11 IS CHANGED TO BE
C  A72 RATHER THAN A300 (WHICH CAUSES LOTS OF BLANK LINES TO GO TO
C  THE SCREEN).

C-----------------------------------------------------------------------

C  NPBIG15.FOR							1/3/08

C  NPBIG15 IS AN EXTENSION TO NPBIG14. IT HAS ALL THE CHANGES THAT
C  THE SINGLE DRUG SERIES (NPBIG10_.FOR) HAS MADE SINCE THE
C  NPBIG10E.FOR PROGRAM, IN ADDITION TO OTHER CHANGES:


C  1. THE USER NOW SELECTS A PATIENT DATA SET TO BE INPUT, BUT THEN
C     CAN SELECT SUBSETS OF THIS DATA SET FOR ANY PARTICULAR RUN. THE
C     MAIN I/O FOR THIS IS DONE VIA THE NEW SUBROUTINES GETIPAT AND
C     GETIPATF. NOTE THAT THE NEW VARIABLE NSUBTOT = THE TOTAL NO. OF
C     SUBJECTS IN THE DATA SET (NSUB REMAINS AS THE NO. OF SUBJECTS TO

C     BE ANALYZED IN A GIVEN RUN).

C  2. BECAUSE EXTRA INFO IS INCLUDED IN THE INSTRUCTION FILES (EITHER
C     FROM A PREVIOUS RUNNING OF THIS PROGRAM OR A BIG IT2B RUN), THE

C     CODE TO READ IN THOSE FILES IS CHANGED. NOTE THAT THE NEXT BIG
C     IT2B PROGRAM (ITBIG8) WILL HAVE TO WRITE THE SAME NEW CODE AS
C     EXPECTED IN THIS PROGRAM.

C  3. npembig3.inp IS CHANGED TO npembig33.inp. THE NEW FILE
C     (npembig33.inp) WILL INCLUDE NEW INFO, NSUBTOT AND IPATVEC, WHERE
C     IPATVEC HOLDS THE INDICES OF THE PATIENTS WHICH ARE TO BE USED
C     IN A RUN. NOTE THAT THE DATA FROM ALL NSUBTOT PATIENTS (NOT JUST
C     THE NSUB "ACTIVE" SUBJECTS) WILL BE INCLUDED IN npembig33.inp.
C     TO ACCOMODATE THIS CHANGE, TMPFILE IS CHANGED TO CHARACTER*13
C     (FROM CHARACTER*12), AND PATH FROM *61 TO *60 THROUGHOUT THE
C     PROGRAM.

C  4. SUBROUTINE PREVRUN HAS CHANGES SINCE IT WILL READ IN NSUBTOT
C     AND IPATVEC(I),I=1,NSUB TO TELL IT WHICH PATIENTS WERE USED IN THE
C     ANALYSIS. NOTE THAT ONLY THE DATA FROM THE NSUB "ACTIVE" SUBJECTS
C     ARE INCLUDED IN THE OUTPUT FILE OF A COMPLETED RUN.

C  5. THE "engine" WHICH WILL BE COMPATIBLE WITH THIS PC PREP PROGRAM
C     (AND FILE npembig33.inp) WILL BE bigmlt1.f, UPDATED FROM
C     bignpaglap4.f. IT WILL ALSO WRITE THE OUTPUT FILE WITH ADDITIONAL
C     INFO (SEE 4. ABOVE) AND THEREFORE WITH A DIFFERENT CODE (VERSION
C     38).

C  6. NOTE THAT MAJOR CHANGES OCCUR IN THE I/O IN MAIN AND VERIF1,
C     AND 9 NEW ROUTINES ARE ADDED ... GETIPAT, GETNUMS, GETSUB,
C     WRITEPAT, WRITEPT2, GETIPATF, GETIPATFF, GETNUMSF, AND GETNSUB2.

C  7. SUBROUTINE GETNSUB HAS A CORRECTED ERROR MESSAGE WRITTEN TO THE

C     SCREEN IF, SOMEHOW, THE USER IS READING IN AN OUTPUT FILE WITH

C     TOO LARGE (> 9999) A VALUE FOR NSUB. THIS SAME ERROR MESSAGE IS

C     USED IN NEW ROUTINE GETNSUB2 (FOR NSUBTOT).


C  8. IN SUBROUTINE SEPARATE, READLINE IS CHANGED FROM A *78 TO A
C     *300 CHARACTER. THIS REQUIRED CHANGES IN TWO PLACES (IN THE
C     CHARACTER STATEMENT AND IN THE FORMAT STATEMENT (LABEL 1). THIS

C     PREVENTS LONG LINES IN OUTPUT FILES MADE BY SOME COMPUTERS FROM
C     BEING TRUNCATED. SIMILARLY IN SUBROUTINE PUTASS, THIS CHANGE IS
C     NECESSARY TO PREVENT COPIED LINES FROM BEING CUTOFF. IN FACT,
C     SINCE THERE IS NO DOWNSIDE TO IT, ALL SUBROUTINES WILL HAVE
C     THEIR *78 PARAMETERS REPLACED BY *300 PARAMETERS (WHICH -->
C     THE CORRESPONDING FORMAT STATEMENTS ARE CHANGED TO A300).

C  9. CHARACTER PARM*11 IN SUBROUTINE CALMAR IS MOVED TO BELOW THE
C     IMPLICIT REAL*8 STATEMENT.

C 10. ALL OPTION BREAK STATEMENTS ARE COMMENTED OUT. LF90 DOESN'T ALLOW
C     THEM.

C 11. CALL TIME AND CALL DATE STATEMENTS ARE REPLACED BY THE
C     CALL DATE_AND_TIME(DATDAY,TIMDAY,ZONEDAY,IDTDAY) STATEMENT
C     IN SUBROUTINES FORMLC AND PREVRUN. DATDAY, TIMDAY, AND ZONEDAY
C     ARE ALL DECLARED TO BE CHARACTER*10 VARIABLES. AND IDTDAY IS
C     INTEGER IDTDAY(10). NOTE ALSO THAT FORMAT 101 IN SUBOUTINE FORMLC
C     HAS ITS FORMAT FOR DATDAY CHANGED FROM A8 TO A10.

C 12. IN SUBROUTINE PLTCON, AN EXTRA STATEMENT IS NEEDED TO SATISFY
C     LF90'S REQUIREMENT THAT THE ARGUMENT TO DLOG10 BE A REAL*8
C     VARIABLE (SEE  XP = XPLOT(I,1) LINE, AND THE FOLLOWING LINE).

C 13. IN SUBROUTINE SEPARATE, I HAD TO PUT PAUSE COMMANDS AFTER THE
C     OPENING OF FILES 25, 34, AND 27 (BUT NOT 47). WITHOUT THESE
C     EXTRA PAUSES, THE PROGRAM CRASHES AFTER I ENTER 1 IN RESPONSE
C     TO: "ENTER 1 IF THE OUTPUT FILE DESCRIBED ABOVE ..."
C     A TYPICAL ERROR MESSAGE IS ..."Cannot open file,
C     FILE=C:\DOCUME~1\MIKE\LOCALS~1\TEMP\TMPxxxxx.$$$,UNIT=27."

C 14. ALSO NOTE THAT ONE OF THE MODULES WITH WHICH THIS PROGRAM IS
C     LINKED IS SCAT72XX.FOR (CHANGED FROM SCAT72.FOR) WHICH NEEDED
C     SMALL CHANGES TO BE COMPATIBLE WITH THE LF90 COMPILER. SEE CODE
C     AT THE TOP OF THIS MODULE TO SEE WHAT CHANGES WERE NEEDED.

C 15. THIS PROGRAM NOW ALLOWS 25 RANDOM PARAMETERS AND 7 FIXED

C     PARAMETERS, RATHER THAN THE 20/12 OF NPBIG14.FOR. AS A RESULT,
C     ALL THE 20'S RELATED TO R.V. DIMENSIONS OR FORMATS HAVE BEEN
C     CHANGED TO 25'S.

C 16. NEW SUBROUTINE READBLOCK, ALONG WITH THE ROUTINES IT CALLS
C     (WRITEDOS, AFTERCOMMA, GETCHAR, THESAME, GETID) ARE ADDED TO
C     READ THE NEW PATIENT DATA BLOCK FORMAT, AND THEN PUT THIS INFO
C     INTO WORKING COPY PATIENT DATA FILES.
C     NOTE THAT IFORMT = 2 IS NO LONGER APPLICABLE (USC*PACK FORMAT)
C     AND SO IDRFIL AND INFIL ARE NOT USED ANYMORE.

C-----------------------------------------------------------------------

C  NPBIG14.FOR							8-28-03

C  NPBIG14 HAS THE FOLLOWING CHANGES TO NPBIG13:

C  1. A BUG IS CORRECTED IF NGRID > MAXACT. IN THIS CASE, THE
C  .f ENGINE PROGRAM RESETS NGRID TO MAXACT, BUT DOES NOT CHANGE

C  INDPTS. THEN, WHEN THE OUTPUT FILE IS READ BACK INTO THIS PROGRAM
C  IN SUBROUTINE PREVRUN, INDPTS IS READ FROM THE DENSITY PART OF THAT
C  FILE AND NGRID IS INCORRECTLY ESTABLISHED FROM INDPTS. THIS AFFECTS
C  ANY CALCULATION BASED ON NGRID. FOR EXAMPLE, IN SUBROUTINE FORMLC
C  (IOPT .EQ. 4) THE CALCULATION OF WORK(I) (THE DISCRETE PROBABILITIES)
C  DEPENDS ON NGRID, AND IF NGRID IS WRONG, THE PROBABILITIES TURN
C  OUT INCORRECT (AND DO NOT SUM TO 1.0). ALSO, CALMAR PRINTS GRAPHS
C  WHOSE VERTICAL VALUES ARE INCORRECT. ETC.

C  THE SOLUTION IS TO HAVE SUBROUTINE PREVRUN READ IN NGRID DIRECTLY
C  FROM THE OUTPUT FILE (RATHER THAN INDPTS FROM THE DENSITY FILE).
C  TO DO THIS, THE NEW .f PROGRAM, bignpaglap4.f, WILL WRITE NGRID
C  TO THE OUTPUT FILE IN AN EASY TO READ FORMAT, AND THIS OUTPUT
C  FILE WILL HAVE A NEW VERSION (VERSION 37) WHICH TELLS PREVRUN
C  THAT NGRID IS TO BE READ IN FROM THE OUTPUT FILE. IF PREVRUN
C  READS AN OUTPUT FILE WITH VERSION 36, IT WILL NOT READ NGRID
C  FROM THE OUTPUT FILE, BUT WILL STILL ESTABLISH NGRID FROM THE
C  READING OF INDPTS FROM THE DENSITY FILE.

C  2. THE FOLLOWING POTENTIAL BUG CORRECTION REGARDING IS MADE. IN THE

C  ENTIRE PROGRAM, READLINE*72 IS CHANGED TO READLINE*78, AND EACH
C  OCCURRENCE OF A72 IS CHANGED TO A78. THIS ELIMINATES THE "BUG"
C  WHICH OCCURS WHEN A LINE GREATER THAN 72 CHARACTERS (USUALLY IN
C  THE DENSITY PART OF THE COMBINED OUTPUT FILE) IS READ IN BY
C  SUBROUTINE PREVRUN). ALSO, TO AVOID INCOMPATIBILITIES, READLIN1 IN
C  SUBROUTINE PREVRUN AND READLIN2 IN SUBROUTINE DETECT ARE CHANGED
C  FROM *72 TO *78.

C  3. A BUG IS FIXED IN SUBROUTINE STAT TO REMOVE A POTENTIAL FOR A


C  DIVIDE BY 0 WHEN A MARGINAL DENSITY HAS POINTS AT THE UPPER

C  BOUNDARY. PREVIOUSLY, THESE POINTS WERE NEVER COUNTED, WHICH MEANT
C  THAT IT WAS POSSIBLE FOR IND975 (OR EVEN IND75, ETC.) NEVER TO
C  BE SET. AND IF THIS HAPPENED, THE SUBSEQUENT EQUATION FOR X975
C  COULD RESULT IN A DIVIDE BY 0 ERROR (THOUGH SOME COMPILERS WOULD
C  PROBABLY BOMB WITH AN "ARRAY OUT OF BOUNDS" MESSAGE). NOW, THESE

C  POINTS WILL BE COUNTED (SEE CODE IN SUBROUTINE STAT).

C  4. A SIMILAR BUG TO NO. 3 ABOVE IS FIXED IN SUBROUTINE CALMAR.
C  PREVIOUSLY, IF A GRID POINT HAD A COORDINATE EXACTLY = UPPER BOUND,
C  THIS POINT WOULD NOT BE COUNTED, AND SO WOULD NOT BE REFLECTED ON
C  THE MARGINAL DENSITY PLOTS. NOW, THESE POINTS WILL BE COUNTED
C  (SEE CODE IN SUBROUTINE CALMAR).


C-----------------------------------------------------------------------


C  NPBIG13.FOR							8-24-02

C  NPBIG13 HAS THE FOLLOWING CHANGES FROM NPBIG12:

C  IF THIS PROGRAM IS BEING USED TO PREPARE FILES FOR ANALYSIS, THERE
C  WILL BE MANY CHANGES IN THE I/O FROM THE USER. IN PARTICULAR, THESE
C  CHANGES WILL INCLUDE NEW I/O FOR ierrmod (AND STARTING ESTIMATES FOR
C  gamma OR lambda, IF APPLICABLE) TO SELECT THE ERROR MODEL TO BE USED.
C  PREVIOUSLY IT WAS ASSUMED THAT ierrmod = 1 -->
C  S.D. = C0 + C1*Y + C2*Y^2 + C3* Y^3. NOW, THE USER WILL HAVE 3
C  ADDITIONAL MODELS FROM WHICH TO CHOOSE (SEE CODE). NOTE THAT IT WILL
C  BE ASSUMED FOR NOW THAT ierrmod/gamma WILL BE THE SAME FOR ALL
C  OUTPUT EQUATIONS.

C  NOTE THAT THE INSTRUCTION FILE FOR THIS PROGRAM WILL NOW INCLUDE
C  AN UPDATED VERSION CODE, 'REM_BAK AUG_02', TO INDICATE THAT THE
C  FILE INCLUDES THE ABOVE INFO. THIS WILL REQUIRE CHANGES IN THE
C  CODE WHICH READS THE INSTRUCTION FILE, AS WELL AS THE CODE
C  WHICH MAKES THE INSTRUCTION FILE.

C  THE INFO ON ierrmod AND gamma/lambda WILL BE PASSED TO THE ANALYSIS
C  PROGRAM, bignpaglap3.f (UPDATED FROM bignpaglap2.f) VIA npembig3.inp,
C  CHANGED FROM npembig2.inp.

C  bignpaglap3.f WILL PRODUCE AN OUTPUT FILE WITH A VERSION CODE OF

C  VER_BAK AUG_02 (CHANGED FROM VER_BAK DEC_01) SO THAT SUBROUTINE
C  PREVRUN IN THIS MODULE WILL KNOW THAT ierrmod AND gamma/lambda
C  ARE PROVIDED TO IDENTIFY THE ERROR MODEL. THESE VALUES WILL BE
C  USED IN SCAT72.FOR (UPDATED FROM SCAT71.FOR) TO ESTABLISH THE
C  STANDARD DEVIATIONS FOR EACH SUBJECT'S OBSERVATIONS.

C-----------------------------------------------------------------------

C  NPBIG12.FOR							7-25-02

C  NPBIG12 HAS THE FOLLOWING CHANGES FROM NPBIG11:

C  1. OPTION 4 (IOPT .EQ. 4) HAS LOTS OF CHANGES TO PRODUCE A .MM FILE
C  HAVING THE FORMAT IN ANDREAS.MM (RATHER THAN COMPARE.M). IT WILL
C  NOW BE USABLE WITH THE BIGMM PROGRAM, RATHER THAN BY A matlab
C  PROGRAM.

C  THERE ARE MAJOR CHANGES IN SUBROUTINE FORMLC, TO PRODUCE A FILE
C  WITH THE REQUIRED FORMAT FOR THE MM PROGRAM.

C  2. THE NAME OF THE ANALYSIS PROGRAM (E.G., bignpaglap2.f) CAN BE

C  PRINTED TO THE SCREEN BY SUBROUTINE PREVRUN WHEN IT PRESENTS THE 8
C  OPTIONS TO THE USER TO EXAMINE PREVIOUS RUNS.


C  3. THERE IS A BUG CORRECTION. IN SUBROUTINE CONVERGE,
C  A PROBLEM WOULD ARISE IF 2 RANDOM VARIABLES HAD THE SAME NAME

C  THROUGH THE 1ST 4 CHARACTERS. IN THIS CASE, THE MEDIAN OF THE 2ND
C  PARAMETER WOULD NEVER BE READ (SEE COMMENTS IN THE CODE).


C  TO PREVENT THIS FROM HAPPENING, FROM NOW ON, THE CONDITION THAT
C  ESTABLISHES WHICH PARAMETER IS APPLICABLE MUST MATCH THE ENTIRE
C  11 CHARACTERS IN PAR(IVAR). I.E., ALLOWING A MATCHING OF 4 OR
C  7 CHARACTERS (TO MAKE THE PROGRAM BACKWARDS COMPATIBLE) HAS
C  BEEN REMOVED. THIS MEANS THAT VERY OLD OUTPUT FILES (THOSE WITH
C  7 OR 4 CHARACTER NAMES) WILL NO LONGER BE ABLE TO HAVE THEIR
C  MEDIANS PLOTTED. NOTE THAT AS OF m2_7calc.f (DATED 2/11/97),
C  PARAMETER NAMES HAVE HAD 11 CHARACTERS, SO THIS CHANGE ONLY
C  AFFECTS OUTPUT FILES MADE BY PROGRAMS MORE THAN 5 YEARS OLD.

C-----------------------------------------------------------------------

C  NPBIG11.FOR							5-31-02

C  NPBIG11 HAS THE FOLLOWING CHANGES FROM NPBIG10:


C  0. NPBIG11 WILL NO LONGER BE APPLICABLE FOR THE BIG NPEM PROGRAM,
C  OR FOR USE WITH OLDER-STYLE PATIENT DATA FILES (THOSE IN USC*PACK
C  FORMAT, OR OLDER-STYLE WORKING COPY FORMAT - SEE ITEM 2 BELOW).

C  1. IT NOW ALLOWS MULTIPLE DRUGS. CODING CHANGES ARE REQUIRED
C  IN SUBROUTINES FILRED, STACK, GETCOVAR, GETCOVR2, GETCOVAL, PUTASS,
C  GETNUMEQ, AND GETNUM TO READ IN MULTIPLE DRUG INFO. NOTE THAT EACH
C  DRUG WILL HAVE ONE COLUMN FOR IV VALUES AND ONE COLUMN FOR BOLUS
C  VALUES. IN ADDITION THERE ARE OTHER CHANGES TO THE FORMATTING
C  (SEE 2DRUG001 FOR AN EXAMPLE OF A TYPICAL NEW WORKING COPY PATIENT
C  DATA FILE).

C  NOTE THAT ONE DIMENSION IS CHANGED IN FILRED, BS(500,3) IS CHANGED
C  TO BS(500,7).

C  SUBROUTINE WRITESYM IS CHANGED TO PUT IN ADDITIONAL LINES TO REFLECT
C  THAT NTLAG, NBCOMP, AND IFA ARE VECTORS, AND THAT THE BOLUS

C  COMPARTMENT NOS. WILL NOW BE PASSED VIA COMMON/BOLUSCOMP.

C  2. PATIENT DATA FILES WILL NOW BE LIMITED TO JUST THE NEW WORKING
C  COPY FORMAT, OUTPUT BY ANDREAS' NEW BOXES PROGRAM. I.E., THE
C  IFORMT = 2 OPTION (USC*PACK FORMAT) HAS BEEN ELIMININATED. IFORMT
C  WILL STILL BE WRITTEN TO AND READ FROM THE INSTRUCTION FILE TO
C  MINIMIZE THE AMOUNT OF CODE WHICH MUST BE CHANGED.


C  NOTE THAT IN SEVERAL PLACES IN THE CODE, IFORMT IS NOW HARDCODED
C  TO 1, AND IDIRCT IS HARDCODED TO 0, AND CODE RELATED TO EITHER
C  IFORMT = 2 OR IDIRCT = 1 HAS BEEN REMOVED.

C  NOTE THAT CALL CONVRT IS NO LONGER NEEDED (I.E., THE PATIENT DATA
C  FILES WILL NEVER BE CONVERTED FROM USC*PACK FORMAT) --> THIS
C  PROGRAM WILL NO LONGER BE LINKED WITH CONVRTLO.FOR.


C  NOTE THAT PRFIX2 AND EXT2 ARE REMOVED FROM THE PROGRAM AS THEY
C  ARE NO LONGER NEEDED.

C  3. SEVERAL I/O CHANGES HAVE BEEN MADE. IN PARTICULAR, NPEM OR NPEM2
C  HAS BEEN CHANGED TO NPAG. ALSO, ALL REFERENCES TO "MAINFRAME"
C  HAS BEEN REMOVED SINCE NOW ANALYSES CAN BE DONE ON FAST PC'S.

C  4. IN SUBROUTINE MAKEDRIV, CALL BIGNPEM IS REPLACED BY CALL BIGNPAG
C  SINCE THIS PROGRAM WILL NOW BE PREPARING FILES FOR ONLY THE NEW

C  BIG NPAG PROGRAM WHICH ALLOWS MULTIPLE DRUG INPUTS (npbig8adapt.f


C  IS THE FIRST PROGRAM IN THIS SERIES).

C  5. A FEW OTHER COSMETIC I/O CHANGES HAVE BEEN MADE.

C  6. THE COMMENT ABOUT FA BEING FIXED = 1 IN SUBROUTINE USERPREP HAS
C  BEEN REMOVED; IT SHOULD HAVE BEEN REMOVED IN NPBIG10.FOR.

C  7. SEVERAL VARIABLES (E.G, PATNEW, PATHFIL2, ETC.) WHICH ARE NO
C  LONGER NEEDED IN CERTAIN ROUTINES HAVE BEEN REMOVED.

C-----------------------------------------------------------------------


C  NPBIG10.FOR							4-25-02

C  NPBIG10 HAS THE FOLLOWING CHANGES TO NPBIG9:

C  1. SUBROUTINE WRITESYM IS CHANGED TO ADD ANOTHER LINE TO THE TOP OF
C  SUBROUTINE SYMBOL (WHICH EVENTUALLY GETS PUT INTO npemdriv.f).

C  THIS LINE IS "COMMON/FRABS/IFA", AND ALLOWS THE PASSING OF
C  THE PARAMETER IFA TO THE id_____ MODULES WHEN THE npemdriv PROGRAM
C  IS RUN ON THE MAINFRAME. IFA = 0 IF FA IS NOT A PARAMETER, AND IS THE

C  INDEX OF THE PARAMETER REPRESENTING FA OTHERWISE.

C  NOTE THAT THE FIRST VERSIONS OF THE id____ MODULES WHICH ALSO HAVE
C  THE COMMON/FRABS/IFA LINE IN THEIR FUNC_ ROUTINES (AND CAN THEREFORE
C  USE THE IFA INFORMATION) ARE idfix5f.f, idcy_53f.f, AND idcy_63f.f
C  (npbig7adapt.f IS THE CURRENT BIG NPEM MAIN MODULE OF THE npemdriv
C  PROGRAM AND DOES NOT HAVE TO BE CHANGED).

C  2. MAXACT IS NO LONGER SET = .1*NGRID IN SUBROUTINE MAKEDRIV. THIS
C  WAS DONE TO LIMIT THE SIZE OF THE ARRAY PYJGX WHEN THE sun PROGRAM
C  WAS RUNNING. BUT IN THE BIG NPAG PROGRAM (UNLIKE THE BIG NPEM
C  PROGRAM), NGRID IS SET = MAXACT, WHICH MEANS THAT THE NGRID VALUE

C  WILL BE SET = 10% OF ITS INTENDED VALUE. THEREFORE, IN THIS PROGRAM,

C  MAXACT IS SET = NGRID, WHICH ESSENTIALLY MEANS THAT IT COULD BE
C  REPLACED BY NGRID, BUT I'LL LEAVE IT AS IS SO THE MAINFRAME PROGRAMS
C  WILL NOT HAVE TO BE CHANGED.


C  NOTE THAT ALL THE CODE AROUND THE CALLING OF SUBROUTINE CALCLIMIT
C  IN MAIN HAS BEEN REMOVED (AND SUBROUTINE CALCLIMIT HAS BEEN
C  DELETED). IN PARTICULAR, THE WARNINGS ABOUT THE SIZE OF THE GRID
C  HAVE BEEN REMOVED FROM THIS PROGRAM SINCE THEY ARE BASED ON
C  MAXACT = .1*NGRID, WHICH IS NO LONGER TRUE. ALSO, THE LIMITS WERE
C  PROBABLY OUTDATED ANYWAY.

C-----------------------------------------------------------------------

C  NPBIG9.FOR							11-23-01

C  NPBIG9 HAS THE FOLLOWING CHANGES TO NPBIG8:

C  1. SUBROUTINE PREVRUN IS CHANGED TO ALLOW ALL NECESSARY INFORMATION
C  TO BE READ IN FROM ONE FILE, OUTFIL. NOTE THAT THE NEW mainframe .f
C  MODULE (THE FIRST ONE WILL BE npbig7.f) WILL ESSENTIALLY CONCATENTATE
C  4 FILES WHICH WERE PREVIOUSLY KEPT SEPARATE, OUTFIL, npembig2.inp
C  (ACTUALLY, JUST THE PATIENT DATA PORTION OF NPEMBIG2.INP), DENFIL,
C  AND npemdriv.f. BY INCLUDING THE PATIENT DATA INFO PART OF
C  npembig2.inp, NPBIG9 WILL NOW BE ABLE TO EXAMINE THE RESULTS OF A
C  PREVIOUS RUN BY INPUTTING JUST THIS ONE OUTPUT FILE.
C??? NOTE ADDED 8/30/02: I COULD DELETE FORMAT 1112, AND CHANGE FORMAT
C    1111 SINCE FROM NOW ON, THIS PROGRAM ONLY NEEDS THE COMBINED OUTPUT
C    FILE (WHICH DOESN'T HAVE TO BE IN THE SAME DIRECTORY AS THE PATIENT
C    DATA FILES), BUT I WILL LEAVE AS IS FOR NOW, SINCE IT IS POSSIBLE
C    THAT THIS PC PREP PROGRAM COULD BE RUN WITH AN OLDER .f "engine"
C    WHICH DOESN'T MAKE A COMBINED OUTPUT FILE.

C  SEE CHANGE NO. 5 BELOW FOR WHY npemdriv.f IS NEEDED.
C  NOTE THAT THE FIRST PART OF THIS COMBINED OUTPUT FILE IS
C  THE OLD OUTPUT FILE, WHICH WILL BE COPIED INTO A TEMPORARY FILE
C  SO IT CAN BE READ AS NECESSARY FOR OPTIONS IOPT = 1 AND 5.
C  SIMILARLY, THE OLD DENFIL, AND THE CONCATENATED PATIENT DATA FILE
C  (FILE 27) CAN BE ESTABLISHED BY READING THE APPROPRIATE PARTS OF
C  THE COMBINED OUTPUT FILE. NOTE THAT PREVRUN WILL KNOW WHETHER
C  THE OUTPUT FILE ENTERED BY THE USER IS OF THE OLD TYPE OR THE NEW
C  COMBINED TYPE BY THE CODE AT THE TOP OF THE FILE.


C  2. MINOR CHANGES ARE ALSO REQUIRED IN SUBROUTINE CONVERGE

C  BECAUSE THE VERSION NO. OF THE OUTPUT FILE IS NOW CHANGED FROM
C  35 TO 36.

C  3. THIS PROGRAM IS NOW LINKED WITH SCAT71 RATHER THAN SCAT6.
C  SCAT71 HAS A COUPLE OF I/O CHANGES FROM SCAT6 REGARDING THE
C  REPORTING OF PRECISION. BUT IT ALSO CORRECTS A "BUG" WHICH BOMBS
C  THE PROGRAM IN SUBROUTINE SCATGRAM IF THE NO. OF PAIRS TO BE
C  PLOTTED IS EXACTLY 2.

C  4. FORMAT 221 IN SUBROUTINE FORMLC HAS BEEN CHANGED COSMETICALLY.

C  5. SUBROUTINE FORMLC HAS A SIGNIFICANT CHANGE. THE npemdriv.f CODE,
C  WHICH IS THE 4TH PART OF THE COMBINED OUTPUT FILE IN THE NEW
C  PROGRAM, WILL BE COPIED TO THE FILE WHICH IS CREATED BY FORMLC.
C  THIS FORTRAN CODE SHOWS THE USER WHAT THE MODEL OF THE RUN WAS.

C-----------------------------------------------------------------------


C  NPBIG8.FOR							1-11-01

C  NPBIG8 HAS THE FOLLOWING CHANGES FROM NPBIG7:

C  1. SUBROUTINE DETECT NOW RETURNS TO MAIN THE ARGUMENT IVERS WHICH
C  = 1 (IF THE RUN IS TO BE DONE AT SDSC/USC LAB) OR 0 (IF THE RUN IS
C  TO BE DONE ON THE USC sun). THEN FORMAT 1111 (WHICH IS ALTERED
C  SLIGHTLY) WILL BE WRITTEN IF IVERS = 0, AND NEW FORMAT 1118 WILL BE
C  WRITTEN IF IVERS = 1.

C  2. IN OPTIONS 6 AND 7 IN SUBROUTINE PREVRUN, TWO NEW MEASURES OF
C  PRECISION, (BIAS-ADJUSTED) PRECISION AND (BIAS-ADJUSTED) WEIGHTED
C  PRECISION ARE CALCULATED AND DISPLAYED. THIS REQUIRES A CHANGE IN

C  SCAT5.FOR WHICH BECOMES SCAT6.FOR.

C-----------------------------------------------------------------------

C  NPBIG7.FOR							1-3-01


C  NPBIG7 HAS THE FOLLOWING CHANGES FROM NPBIG6:

C  1. A NEW SUBROUTINE, DETECT, IS CALLED BY MAIN JUST BELOW THE CALL
C  TO USERPREP TO MAKE SURE THE USER'S FORTRAN MODEL FILE IS THE CORRECT
C  VERSION FOR THE LOCATION HE IS RUNNING IT (I.E., EITHER THE
C  PARALLELIZED VERSION AT SDSC AND USC/LAB, OR THE NON-PARALLELIZED

C  "BETA" VERSION ON THE USC sun). ADDITIONAL NEW SUBROUTINES ARE
C  CHECKLIN, WRITEDIF, WRITEOUT, WRITESYM, AND SKIPLINE.

C  2. IN OPTIONS 6,7, AND 8 (IN SUBROUTINE PREVRUN), THE USER IS NOW
C  ASKED EACH TIME HE SELECTS ONE OF THESE OPTIONS WHETHER OR NOT HE
C  WISHES TO STORE INFO TO A FILE. THIS REPLACES THE IWR31/ISCATPLT
C  LOGIC IN OPTIONS 6 AND 7. IN OPTION 8, IPUT LOGIC IS ADDED SO THE
C  PROGRAM WILL KNOW WHETHER OR NOT TO STORE INFO TO A FILE. BECAUSE OF

C  THIS, SCAT4.FOR IS REPLACED BY SCAT5.FOR WITH AN ALTERED SUBROUTINE
C  SCATGRAM WHICH HAS THE ADDITIONAL ARGUMENT IPUT. NOTE THAT ISUBANAL
C  LOGIC IS NO LONGER NEEDED.

C  3. FORMAT 8513 IS CHANGED IN SUBROUTINE PREVRUN (OPTIONS

C  1 AND 3 ARE INTERCHANGED).

C  4. FORMAT 8503 IS CHANGED IN SUBROUTINE PREVRUN (OPTIONS
C  1 AND 3 ARE INTERCHANGED). IN ADDITION, A LOT OF RELATED CODE IS
C  CORRESPONDINGLY CHANGED.

C  5. FORMAT 819 IN SUBROUTINE VERIF1 IS CHANGED TO MAKE MORE
C  EXPLICIT WHAT THE USER SHOULD DO WITH REGARD TO THE ASSAY
C  COEFFICIENTS IF HE USES A 'FROM...' FILE FROM AN IT2B RUN.

C  6. FORMATS 119 AND 221 ARE CHANGED SLIGHTLY IN MAIN AND SUBROUTINE
C  VERIF1.

C  7. FORMAT 4066 IN MAIN AND PREVRUN HAS AN "INVISIBLE" SPACE REMOVED.
C  PREVIOUSLY, USC*PACK WAS WRITTEN OUT AS USC*PAC K. TO REMOVE THIS
C  SPACE REQUIRED COPYING THE CODE TO ANOTHER FILE, EDITING IT WITH
C  THE DOS EDIT COMMAND AND THEN COPYING IT BACK INTO THIS FILE. WHY
C  THIS WORKS I DON'T KNOW.

C  NOTE THAT A NEW npbig6.f WILL REPLACE npbig5. THE ONLY DIFFERENCES
C  BETWEEN THE TWO PROGRAM WILL BE THAT "MADE BY npbig6" WILL BE ADDED
C  TO THE FIRST LINES OF THE OUTPUT AND DENSITY FILES.

C-----------------------------------------------------------------------

C  NPBIG6.FOR							10-29-00

C  NPBIG6 HAS THE FOLLOWING CHANGES FROM NPBIG5.FOR.

C  1. AN ADDITIONAL SUBROUTINE, GETNSUB, IS CALLED TO READ IN NSUB IN
C  SUBROUTINE PREVRUN. GETNSUB READS IN NSUB FROM ANY POSITION ON ITS
C  LINE IN THE OUTPUT FILE. THIS ELIMINATES THE CHANCE THE PREVIOUS CODE

C  HAD OF NOT READING IT IN PROPERLY (WHICH COULD HAPPEN IF THE OUTPUT
C  FILE WAS PRODUCED BY A COMPILER/OPERATING SYSTEM WHICH HANDLES
C  UNFORMATTED WRITE STATEMENTS DIFFERENTLY THAN THE sun (I.E., WHICH

C  PUTS NOS. IN DIFFERENT POSITIONS ON A LINE).

C  2. SUBROUTINE CONVERGE IS CHANGED TO CORRECT THE INCORRECT
C  WAY IT READS IN VALUES WHEN ONE CYCLE HAS A VARIANCE .LE. 0 BUT
C  A SUBSEQUENT CYCLE DOES NOT. THIS SCENARIO, WHICH DIDN'T SEEM TO
C  OCCUR IN REGULAR NPEM, WOULD CAUSE VALUES READ INTO THE VARIOUS
C  ARRAYS TO BE ASSIGNED INCORRECT CYCLE NOS. ALSO, "DIFF" IS NO LONGER
C  AVAILABLE IN THE ADAPTIVE NPEM PROGRAMS, AND IS NO LONGER PLOTTED.
C  SUBROUTINE PLTCON HAS CORRESPONDING CHANGES.


C  3. SUBROUTINE MINMAX IS ALTERED SLIGHTLY TO ALLOW FOR THE CASE WHERE
C  ALL VALUES ARE THE SAME.

C  4. FORMAT 6063 IS CHANGED TO ALLOW > 9 PARAMETERS.


C-----------------------------------------------------------------------

C  NPBIG5.FOR							4-6-00

C  NPBIG5 HAS THE FOLLOWING CHANGES TO NPBIG4.

C  1. IN SUBROUTINES CONVERGE AND PLTCON, THE PLOTTING OPTIONS FOR
C  IPLOT = 6 AND 7 HAVE BEEN CHANGED. THE OPTION TO PLOT NORMALIZED
C  DATA IS REMOVED (IT WAS UNNECESSARY SINCE NORMALIZED DATA IS USEFUL
C  ONLY IF THERE IS MORE THAN ONE LINE TO BE PLOTTED). ALSO, FOR IPLOT
C  = 6, THE USER HAS THE OPTION NOW TO PLOT THE COMMON LOG OF THE NO.
C  OF ACTIVE GRID POINTS IN ADDITION TO THE ACTUAL NO. OF ACTIVE
C  GRID POINTS.

C  2. ALL REFERENCES TO USC*TOOLS FOR OUTPUT FILE OUTSINGL HAVE BEEN
C  REMOVED. THE OUTPUT FILE IS STILL CREATED, BUT IT WILL NOT BE
C  USED FOR USC*TOOLS.

C  3. SCAT3.FOR HAS BEEN REPLACED BY SCAT4.FOR, WHICH HAS AN UPDATED
C  SUBROUTINE SCATGRAM. THE 95% CONFIDENCE LINES FOR THE SCATGRAM PLOT
C  WILL NO LONGER ALWAYS BE FOR E(Y|X) AS IN SCAT3. INSTEAD, IT WILL BE
C  FOR E(Y|X) IF ICONF = 1 (ICONF IS ADDED TO THE ARGUMENT LIST FOR
C  SUBROUTINE SCATGRAM), AND FOR Y|X IF ICONF = 0. ICONF IS READ IN
C  FROM THE USER.

C  ALSO, IN SUBROUTINE SCATGRAM, ADDITIONAL STATISTICS WILL BE
C  OUTPUT ... 99%, 95%, AND 80% C.I. FOR E(Y|X) IF ICONF = 1, OR
C  Y|X IF ICONF = 0.

C  4. MAXOBDIM, IN THE PARAMATER STATEMENT, HAS BEEN CHANGED FROM
C  26 TO 150. THE 26 WAS THE LIMIT WITH MY OLD 386 COMPUTER WHEN RUN
C  UNDER WINDOWS (SEE M2_18 NOTES), BUT WITH THE POWER/MEMORY OF THE

C  NEWER COMPUTERS, WE WILL SET MAXOBDIM = 150.

C-----------------------------------------------------------------------

C  NPBIG4.FOR							2-18-00

C  NPBIG4 HAS THE FOLLOWING CHANGES FROM NPBIG3:

C  1. THERE IS ONE MAJOR IMPROVEMENT TO NPBIG3. AN ADDITIONAL OPTION
C  IS ADDED IN SUBROUTINE PREVRUN TO PLOT ANY OR ALL POSSIBLE

C  SCATTERPLOTS BETWEEN ANY TWO RANDOM VARIABLES AND/OR DESCRIPTORS IN
C  THE PATIENT DATA FILES. THIS OPTION IS NEW OPTION, IOPT = 8.


C  NOTE THAT FOR THE PURPOSES OF THE ABOVE PLOTS, FOR SUBJECT I, EACH
C  RANDOM VARIABLE WILL BE ASSIGNED THE VALUE EQUAL TO ITS BAYESIAN
C  POSTERIOR ESTIMATE (MEAN, MEDIAN, OR MODE AS SELECTED BY THE USER).

C  3 NEW SUBROUTINES ARE NEEDED, GETCOVAL, GETCOVAR, AND PRNCOVAR.



C  THE ROUTINE WHICH DOES THE ABOVE PLOTS IS SCATGRAM, WHICH IS IN
C  MODULE SCAT3.FOR, WHICH REPLACES SCTPL12A.FOR (ALL THE ROUTINES FROM

C  SCTPL12A ARE IN SCAT3.FOR).

C  2. FORMAT 141 AND SURROUNDING CODE IS CHANGED SO THAT THE USER NOW
C  ENTERS 1 FOR USC*PACK FORMAT AND 2 FOR WORKING COPY FORMAT. THIS IS

C  DONE IN BOTH MAIN AND VERIF1.

C-----------------------------------------------------------------------

C  NPBIG3.FOR							11-12-99

C  NPBIG3 HAS THE FOLLOWING CHANGE FROM NPBIG2:

C  A "BUG" IS FIXED. THE ARGUMENT, PATH, WHICH WAS ADDED TO THE
C  CALLING ARGUMENTS OF SUBROUTINE FORMLC IN NPBIG1.FOR WAS NEVER ADDED

C  TO THE CALL FORMLC(...) STATEMENT. THIS HAS NOW BEEN DONE.

C  NOTE: THIS PROGRAM ALLOWS TIME-LAG PARAMETERS, BUT THE SUN PROGRAM
C  IS STILL CALLED npemdriv_obs.exe ( = npbig2.f + idfix5c.f +
C  idcy_53c.f + idcy_63c.f + shift2.f + vodtot.f), AND IT SUPERCEDES THE
C  PREVIOUS TIME-LAG VERSION (M2_20C.FOR/m2_19bca.f,...), WHICH WAS
C  CALLED npemdriv_obs_tlag.exe.

C-----------------------------------------------------------------------


C  NPBIG2.FOR							10-28-99


C  NPBIG2 HAS THE FOLLOWING CHANGES FROM NPBIG1:

C  1. FORMAT 7 IN SUBROUTINE VERIF1 IS CORRECTED (PREVIOUSLY, THE 1ST
C  CHARACTER OF THE 1ST NAME WAS CUT OFF).


C  2. IALLPAT(I) IS CHANGED. IALLPAT(I) WILL ALWAYS BE SET = 0 INITIALLY
C  --> THE USER WILL GET TO SEE THE NEW C'S WHICH WILL BE PUT INTO EACH
C  PATIENT'S DATA FILE, BUT THE USER CAN CHANGE IALLPAT(I) TO = 1 AT ANY
C  TIME, WHICH MEANS THAT THE REST OF THE MULTIPLICATIONS WILL HAPPEN
C  AUTOMATICALLY W/O THE USER'S INVOLVEMENT.

C  3. SUBROUTINE CONVERGE HAS A BUG FIX. DUE TO CHANGE 5 IN npbig1.f.
C  CONVERGE HAS AN ALTERED TEST FOR A VARIANCE NUMERICALLY .LE. 0.
C  THIS HAS NOW BEEN REFLECTED IN THE CORRESPONDING TEST IN CONVERGE.

C  4. THIS PROGRAM IS NOW LINKED WITH CONVRTLO.FOR, UPDATED FROM
C  CONVRTLN.FOR (CONVRTLO CORRECTS A SUBTLE BUG IN THE CASE WHETHER
C  THERE IS NO BOLUS INPUT).

C-----------------------------------------------------------------------



C  NPBIG1.FOR (NEW SERIES OF NAMES)				10-10-99

C  NPBIG1.FOR HAS THE FOLLOWING CHANGES FROM M2_20B:


C  1. THERE WAS A BUG IN THE READING OF MAXOBS IN SUBROUTINE PUTASS IF
C  A DOSE EVENT TOOK MORE THAN ONE LINE; IT HAS BEEN CORRECTED.


C  2. ASSMULT(I) = GAMMA(I), I=1,NUMEQT IS NOW READ FROM FROMFIL
C  (OUTPUT BY A BIG IT2B RUN) SO THAT THIS PROGRAM CAN READ IT TO USE IN
C  THE DEFAULT SETTING OF THE ASSAY COEFS. THIS --> CODE AT TOP OF
C  FROMFIL CHANGES FROM  'REM_FRN JUN_98'  TO   'REM_FRN OCT_99'.

C  THE REASON FOR THIS IS THAT THE MODIFIED POPULATION C'S (I.E.,
C  THE ORIGINAL C'S MULTIPLIED BY GAMMA(IEQ)) HAVE ALWAYS BEEN WRITTEN
C  TO FROMFIL, BUT IN EACH INDIVIDUAL PATIENT FILE, THE ORIGINAL C'S
C  REMAIN, AND THERE WAS NO WAY FOR THE USER TO HAVE THESE MULTIPLIED BY
C  GAMMA(IEQ) UNLESS HE MANUALLY ENTERED THE GAMMA(IEQ) AFTER READING
C  THE OUTPUT OF THE IT2B PROGRAM. BY PROVIDING THESE GAMMA(IEQ), THE

C  PROGRAM WILL HAVE THE DEFAULT OPTION OF HAVING EACH PATIENT'S C'S
C  MULTIPLIED BY GAMMA(IEQ). TO BE CONSISTENT, THE GENERAL C'S WILL NO
C  LONGER BE MULTIPLIED BY THE GAMMA(S) IN FROMFIL (AND FORMAT 1967 IS
C  REMOVED).

C  ALSO NOTE THAT WHEN INFO IS INPUT VIA FROMFIL, IASS(IEQ), IEQ =
C  1,NUMEQT, ARE ALL SET = 3 (REGARDLESS OF THE VALUE READ IN) AND
C  ALL THE IALLPAT(IEQ) ARE SET = 1. ALSO, EACH ASSMULT(IEQ) IS SET =


C  GAMMA(IEQ). SETTING THESE VALUES GIVES THE BEST DEFAULT SITUATION FOR
C  INFO COMING VIA FROMFIL, NAMELY THAT THE ASSAY COEFFICIENTS IN EACH
C  PATIENT'S FILE WILL BE MULTIPLIED BY THE VALUE OF GAMMA FOR EACH
C  OUTPUT EQ.


C  3. THE GRID POINT SELECTION PROCEDURE IS CHANGED. THE ONLY EFFECT IN
C  THIS PROGRAM IS THAT ALL REFERENCES TO THE NUMBER THEORETIC APPROACH

C  ARE REMOVED.
C  THIS CHANGE --> NEW CODE IN CONVERGE TO READ IN THE LOG-LIK'S.

C  4. SEVERAL I/O CHANGES ARE MADE.

C  5. ALL IBEEP'S ARE HARDCODED TO = 1 (SO NO BEEPING WILL BE HEARD
C  WHILE THE PROGRAM IS RUNNING, OR PLOTS ARE GOING TO THE SCREEN).

C  6. IN SUBROUTINE MAIN OR VERIF1, IF THE USER HAS ENTERED PATIENT
C  FILES WITHOUT ASSAY COEFFICIENTS (E.G., USC*PACK FILES ENTERED, WHICH
C  HAVE NO ASSAY COEFFICIENTS), HE HAS THE EXTRA OPTION OF HAVING THE
C  GENERAL C'S HE ENTERS BE MULTIPLIED BY GAMMA (PREVIOUSLY, THE USER
C  EITHER ACCEPTED THE GENERAL COEFF'S OR ENTERED OTHERS).
C  FORMATS 119 AND 4147 IN MAIN AND VERIF1, AND 719 AND 819 IN VERIF1,
C  ARE CHANGED. ALSO, SUBROUTINE PUTASS HAS CHANGES TO AFFECT THIS
C  MODIFICATION.


C  7. IN SUBROUTINE VERIF1, WHEN THE USER IS CHANGING THE ASSAY COEFF.
C  OPTION, HE NOW HAS THE OPTION TO LEAVE THE VALUES FOR
C  {C0P,C1P,C2P,C3P] UNCHANGED (I.E., HE WON'T HAVE TO RE-ENTER THEM).
C  SEE ICHCS CODE IN VERIF1.

C  8. SUBROUTINE STAT NO LONGER ALWAYS USES NINT = 100. INSTEAD, NINT
C  WILL BE THE MAX(100,2*NSUB). THE REASON IS THAT THE MARGINAL SCALED
C  INFO HAS A DENOMINATOR OF LN(NINT/NSUB) IN THE CALCULATION, WHICH
C  RESULTS IN A DIVIDE BY 0 ERROR IF NSUB = 100 (AND RESULTS IN
C  NEGATIVE SCALED INFO (WHICH IS SUPPOSED TO BE BETWEEN 0 AND 100),
C  WHEN NSUB > 100. BY MAKING NINT .GE. 2*NSUB, THIS PROBLEM WILL
C  DISAPPEAR.


C  9. IN SUBROUTINE FORMLC, THE FILE WILL AUTOMATICALLY HAVE A .M
C  EXTENSION.

C  10. THE DEFAULT STOPPING CRITERION FOR THE ANALYSES HAS BEEN CHANGED
C  TO JSTOP = 3, WITH TOL = 1.D-8, AND THE ONLY OPTION THE USER NOW HAS
C  IS TO CHANGE TOL. I.E., THE JSTOP = 1 AND 2 OPTIONS HAVE BEEN
C  REMOVED. THIS REQUIRES CHANGES TO THE CODE NEAR LABEL 4165 IN MAIN


C  AND VERIF1, AND RESETTING JSTOP IN INSTRUCTION FILES FROMFIL
C  AND FROMLAST.

C  11. A CHANGE IS MADE TO FORMAT 1652 (IN SUBROUTINE SUBRES), AND THE
C  VALUES SK AND KU ARE SET TO WHEN ICOVL0 = 1 (WHICH OCCURS WHEN AT
C  LEAST ONE PARAMETER HAS VARIANCE NUMERICALLY .LE. 0). NOW KU AND SK
C  WILL BE WRITTEN OUT AS -99999999, RATHER THAN 1.D30. IT USED TO BE
C  THAT 1.D30 WOULD PRINT OUT AS *'S, BUT NOW WITH THE G FORMAT IT
C  PRINTS OUT AS A LEGITIMATE NUMBER, AND -99999999 IS A BETTER WAY TO
C  EXPRESS THAT THESE VALUES DO NOT EXIST.

C 12. USER NOW ENTERS THE LOCATION (PATH) OF HIS INSTRUCTION AND PATIENT
C  FILES (I.E., THEY NO LONGER HAVE TO BE IN THE WORKING DIRECTORY). ALL
C  OUTPUT FILES WILL BE PUT THERE ALSO. NEW SUBROUTINES GETPATH AND
C  FULLNAME ARE USED.

C  PATH AND NOB MUST NOW BE SUPPLIED TO SUBROUTINES PREVRUN, VERIF1,
C  MAKEDRIV, GETNUMEQ, AND SEEDIR. PATH MUST BE SUPPLIED TO SUBROUTINE
C  STACK.

C  SUBROUTINE PUTASS ALSO HAS LOTS OF CHANGES, BECAUSE PATHFILE (*73)

C  INSTEAD OF PATFIL (*20) IS PASSED TO IT.

C  CONVRTLM.FOR IS CHANGED TO CONVRTLN.FOR. THE DIFFERENCE IS THAT THE
C  FILENAMES INPUT TO CONVRTLN ARE *73 RATHER THAN *20.

C-----------------------------------------------------------------------

C  M2_20B.FOR							6-18-99


C  M2_20B HAS THE FOLLOWING CHANGES FROM M2_20A:

C  1. SUBROUTINE PUTASS NOW CALLS NEW SUBROUTINE USECS SEVERAL TIMES,
C  WHENEVER THE USER IS PROMPTED TO ENTER A NEW SET OF COEFFICIENTS.
C  USECS ALLOWS THE USER TO SEE UP TO 5 SETS OF PREVIOUSLY STORED
C  C'S FOR EACH OUTPUT EQUATION, AND TO STORE ADDITIONAL SETS (UP TO
C  THE LIMIT OF 5).

C  2. THERE IS AN ADDED OPTION TO ALLOW THE USER TO HAVE ALL PATIENT
C  DATA FILES, IN WORKING COPY FORMAT, TO HAVE THEIR ASSAY COEFFICIENTS
C  (FOR EACH OUTPUT EQ.) ALL MULTIPLIED BY A CONSTANT. THIS CONSTANT
C  COULD BE, FOR EXAMPLE, THE ESTIMATE OF GAMMA(IEQ) FOUND BY THE IT2B
C  PROGRAM.


C  NOTE THAT THERE ARE SEVERAL CHANGES IN THE I/O FOR THE C'S, IN MAIN
C  AND SUBROUTINE VERIF1. ALSO, THERE ARE MANY CHANGES IN SUBROUTINE
C  PUTASS, INCLUDING 4 NEW ARGUMENTS PASSED TO THIS ROUTINE.

C  3. MAXOBDIM IS THE MAX. NO. OF OBSERVED VALUES (HARDCODED IN A
C  PARAMETER STATEMENT). RATHER THAN ASSUME THE USER WILL ONLY ANALYZE
C  SUBJECTS WITH .LE. MAXOBDIM OBSERVATION TIMES, THIS WILL BE TESTED
C  IN SUBROUTINE STACK (MAXOBDIM WILL BE PASSED TO STACK).

C-----------------------------------------------------------------------

C  M2_20A.FOR							5-20-99

C  M2_20A HAS ALL THE CHANGES M2_21 THRU M2_21C MADE TO M2_20, EXCEPT
C  THE ASSAY S.D.'S ARE STILL FUNCTIONS OF THE OBSERVED VALUES, RATHER
C  THAN THE PREDICTED VALUES.

C  THE CHANGES ARE:

C  1. IT IS NOW LINKED WITH CONVRTLM.FOR, RATHER THAN CONVRTL.FOR.
C  CONVRTLM ALLOWS 30 USER-SUPPLIED COVARIATES RATHER THAN JUST
C  10 AS IN CONVRTL (AND THIS LIMIT IS EXPLICITLY CHECKED FOR NOW).
C  ALSO, CONVRTL HAD A BUG WHICH CAUSED A DIVIDE BY 0 ERROR IF THERE WAS
C  JUST ONE DOSE TIME. THIS HAS BEEN CORRECTED.

C  2. THE MAXIMUM NO. OF CYCLES FOR THE PROGRAM HAS BEEN CHANGED TO
C  9997. PREVIOUSLY, THERE WAS NO EXPLICIT LIMIT WHEN THE PROGRAM
C  READ IN MAXCYC (NOW THE LIMIT IS 9997), BUT THERE WAS AN IMPLICIT
C  LIMIT OF 10000 IN SUBROUTINES CONVERGE, PLTCON, AND MINMAX WHICH HAD
C  CORRESPONDING DIMENSIONS OF 10000. NOW, THESE DIMENSIONS HAVE BEEN

C  CHANGED TO 9997. THIS LIMIT WILL BE IMPOSED WHETHER THE USER USES
C  AN INPUT FILE OR THE KEYBOARD TO ENTER THE INSTRUCTIONS. NOTE THAT IF
C  THE FILE, FROMxxxx FROM A BIG IT2B RUN IS USED TO INPUT VALUES,
C  MAXCYC WILL BE DEFAULTED TO 9997.

C  3. RS(500,14) DIMENSIONS ARE CHANGED TO RS(500,34), TO ALLOW THE
C  EXTRA 20 COVARIATES OF CHANGE 1 ABOVE.

C  4. THE CALLS TO SCATPLOT FOR THE ENTIRE POPULATION HAS THE ARGUMENT
C  JSUB CHANGED FROM 0 TO -NSUB. THIS WAY, SCATPLOT CAN WRITE OUT NSUB
C  = NO. OF SUBJECTS. THIS PROGRAM WILL NOW BE LINKED WITH SCTPL12A.FOR

C  (UPDATED FROM SCATPL10.FOR), WHICH WILL WRITE OUT NSUB AS INDICATED.

C  5. A BUG IN THE CALCULATION OF ENTROPY IS CORRECTED. THE ENTROPY
C  ENTROPY CALCULATION IS MOVED TO BE AFTER SUM=SUM/DL2 STATEMENT.


C  - MODULE SCATPL10.FOR IS CHANGED TO SCTPL12A.FOR.

C-----------------------------------------------------------------------

C  M2_20.FOR							9-24-98


C  M2_20.FOR HAS THE FOLLOWING CHANGES FROM M2_19.FOR:

C  1. NEW CODE IN SUBROUTINE CONVERGE (BELOW LABEL 109) ALLOWS PROGRAM
C  TO READ IN SCALED INFO FROM OUTPUT FILES OF OLDER PROGRAMS.


C  2. FORMAT 31 IN SUBRES HAS ALREADY BEEN CHANGED TO BE SAME AS IN
C  m2_19cal.f.

C  3. A "BUG" IS CORRECTED IN SUBROUTINE GETNUMEQ. TO READ NUMEQT,
C  THE ROUTINE ASSUMED THAT EACH LINE IN THE DOSAGE INFO BLOCK
C  REPRESENTED ONE DOSE EVENT. BUT EACH DOSE EVENT CAN BE TWO OR MORE
C  LINES. TO MAKE SURE THIS INFO IS READ CORRECTLY, THE SAME CODE
C  USED IN SUBROUTINE FILRED IS NOW USED.

C  4. FORMAT 3214 HAS BEEN CHANGED (COSMETIC IMPROVEMENT). THIS CHANGE
C  WAS MADE 9-26-98, AFTER THE M2_20.EXP FILE WAS WRITTEN, SO THAT FILE
C  DOES NOT HAVE THIS CHANGE, AND THE SIZE OF M2_20.FOR, .OBJ, .EXE MAY
C  ALL NOW BE A LITTLE BIT DIFFERENT.


C-----------------------------------------------------------------------

C  M2_19.FOR							7-30-98


C  M2_19.FOR HAS THE FOLLOWING CHANGES FROM M2_19.FOR:

C  1. IN SUBROUTINE CONVERGE, A POTENTIAL "BUG" IS REMOVED. STD. DEV'S
C  AND % C.V.'S ARE UNAVAILABLE FOR A CYCLE IF ANY PARAMETER VARIANCE
C  FOR THAT CYCLE WAS NUMERICALLY .LE. 0. PREVIOUSLY, IF THIS HAPPENED,
C  THE PROGRAM WOULD "BOMB" SINCE THE EXPECTED NUMBERS WOULD NOT BE
C  IN THE OUTPUT FILE. NOW, THE PROGRAM TESTS FOR VARIANCES .LE. 0.
C  IF THIS HAPPENS, THE PROGRAM KNOWS NOT TO TRY TO READ STD. DEV.'S

C  OR % C.V.'S FOR THIS CYCLE. ALSO, FOR THE PLOTS, ONLY STD. DEV.'S AND
C  % C.V.'S UP TO THE CYCLE HAVING THE FIRST OCCURENCE OF THIS WILL BE
C  PLOTTED.

C  2.  IN SUBROUTINE PRNLAST, A POTENTIAL DISPLAY "BUG" IS REMOVED.
C  PREVIOUSLY, IF THE LAST CYCLE HAD CHARACTERS BEYOND 72 COLUMNS, THEY
C  WOULD NOT BE PRINTED. NOW THEY ARE.

C  3. IN SUBROUTINE PREVRUN, A "BUG" IS REMOVED. IN LOOPS 7000 AND
C  5000, COEFF(JSUB,1), WHICH IS THE ACTUAL NO. OF OBSERVATIONS IS NOW
C  SET = NACTUAL, RATHER THAN NOBSER (NOBSER IS THE TOTAL NO. OF
C  OBSERVATION TIMES, NOT NECESSARILY THE NO. OF OBSERVATIONS FOR THE
C  OUTPUT EQ. UNDER CONSIDERATION).

C  4. THIS PROGRAM IS COMPILED WITH CONVRTL.FOR (UPDATED FROM
C  CONVRTK.FOR). THE ONLY DIFFERENCE IS THAT CONVRTL HARDCODES NUMEQT
C  = 1, WHEREAS CONVRTK READS NUMEQT FROM THE USC*PACK FILE. BUT,
C  THE NEW XPAST... PROGRAM IS NOT YET AVAILABLE WHICH WRITES NUMEQT


C  TO USC*PACK FILES, SO, FOR NOW, NUMEQT MUST BE HARDCODED.

C  5. REAL-TIME ENTERING OF XMIC CAN NOW BE DONE BY DEFAULT, BOTH IN
C  MAIN AND VERIF1.

C  6. FORMATS 2123 AND 2126 HAVE BEEN IMPROVED SLIGHTLY, COSMETICALLY.

C  7. TIM IS REMOVED FROM THE ARGUMENT LIST OF SUBROUTINE FILRED. IT IS
C  NOT NEEDED IN SUBROUTINE PREVRUN. THE ONLY REASON IT WAS INCLUDED IN

C  M2_18.FOR WAS SO IT COULD BE VARIABLY DIMENSIONED. BUT, INSTEAD OF
C  READING TIM(I), T (A SCALAR) CAN BE READ. ALSO, IN MAIN AND

C  SUBROUTINE PREVRUN, TIM IS REMOVED FROM THE DIMENSION DECLARATION,
C  AND TIM IS REMOVED FROM THE ARGUMENT LIST OF SUBROUTINE PREVRUN.

C  8. SOME COMMENTS ARE CORRECTED FROM M2_18.FOR.

C-----------------------------------------------------------------------

C  M2_18.FOR							6-18-98

C  M2_18.FOR HAS THE FOLLOWING CHANGES FROM M2_17.FOR:

C  1. IT ALLOWS MULTIPLE OUTPUTS. THERE WILL BE NUMEQT OUTPUT EQUATIONS,
C  AND FOR EACH OF THESE EQUATIONS, THE USER MUST ENTER NUMEQT SETS
C  OF ASSAY COEFFICIENTS. THEN, FOR IANAL=1, THESE NUMEQT SETS ARE
C  PASSED TO THE MAINFRAME PROGRAM IN THE FILE npembig2.inp (CHANGED
C  FROM npembig1.inp)

C  MODULE CONVRTJ.FOR IS CHANGED TO CONVRTK.FOR (SUBROUTINE CONVRT). THE

C  NEW MODULE HANDLES MUTLIPLE OUTPUTS.

C  A NEW SUBROUTINE GETNUMEQ IS USED TO GET THE NO. OF OUTPUT EQUATIONS
C  (NUMEQT) FROM A PATIENT DATA FILE.

C  C0P,C1P,C2P,C3P AND IASS ARE NOW NO LONGER SCALARS, BUT ARE VECTORS
C  OF DIMENSION 6 (THE MAXIMUM NO. OF OUTPUT EQUATIONS).

C  SUBROUTINE PREVRUN HAS LOTS OF CHANGES. AMONG THEM ARE 1) YPREDPOP
C  AND YPREDBAY HAVE AN EXTRA DIMENSION (TO IDENTIFY THE OUTPUT EQ.),
C  AND 2) THE USER MUST SELECT THE DESIRED OUTPUT EQUATION AT THE

C  OUTSET OF OPTION 6 OR 7.


C  SUBROUTINES CALCLIMIT AND MAKEDRIV HAVE CHANGES DUE TO THE INCREASED
C  DIMENSIONS FOR YPREDPOP AND YPREDBAY.

C  THERE ARE MAJOR CHANGES TO OTHER ROUTINES, SUCH AS FILRED, STACK,
C  VERIF1, AND PUTASS

C  A NEW PARAMETER, MAXOBDIM, IS SET IN THE PARAMETER STATEMENT IN
C  MAIN. IT, ALONG WITH VARIABLES WHOSE DIMENSIONS DEPEND ON IT ARE
C  PASSED TO SUBROUTINE PREVRUN. MAXOBDIM IS THE MAX. NO. OF OBSERVATION
C  TIMES IN A PATIENT DATA FILE. NOMINALLY, IT SHOULD BE 6*99 = 594,
C  BECAUSE THE MAXIMUM NO. OF OUTPUT EQUATION IS 6, AND THE MAXIMUM NO.
C  OF OBSERVED VALUES PER OUTPUT EQUATIONS IS 99. BUT 594 IS TOO BIG,
C  IN TERMS OF THE SIZE OF THIS PC PROGRAM, SO IT IS LIMITED. ACTUALLY,
C  594 IS O.K. IF THE PROGRAM IS RUN IN DOS MODE (USING THE COMMAND,
C  RUN386 -VMM VM.EXP M2_18.EXE, BUT IN WINDOWS MODE, THE MAXIMUM VALUE
C  OF MAXOBDIM (ASSUMING MAXDIM=20, MAXGRD=1500, AND MAXSUB=999 IS 26.

C  2. THERE IS A SMALL BUG FIX. IF INOPT1=1 (I.E., USING AN INPUT FILE
C  FROM THE OUTPUT OF THE "BIG" IT2B), IASS, WHICH IS NOW A VECTOR
C  (WHICH IS NOT READ IN) IS DEFAULTED TO 1 IN ALL ITS ENTRIES.
C  PREVIOUSLY, IT WAS NOT SET --> IT DEFAULTED TO 0.

C  3. ANOTHER SMALL BUG FIX: IN SUBROUTINE PUTASS, PREVIOUSLY, JUST
C  BELOW LABEL 10, A "2" WAS SEARCHED FOR IN COLUMN 1; IT WAS
C  SUPPOSED TO BE THE "2" WHICH SIGNIFIES THAT THE ASSAY COEFFICIENTS

C  ARE FOLLOWING. BUT THE ETHNICITY FLAG NEAR THE TOP OF THE FILE COULD
C  ALSO BE A "2" IN COLUMN 1. IN THIS CASE, THE FILE WOULD ONLY BE

C  COPIED DOWN TO THAT POINT (I.E., THE REST OF THE FILE WOULDN'T BE
C  COPIED). TO ELIMINATE THIS POSSIBILITY, THE "2" SIGNIFYING THAT ASSAY
C  COEFFICIENTS FOLLOW WILL BE REPLACED BY THE WORDS "ASSAY COEFFICIENTS
C  FOLLOW". IF NO ASSAY COEFFICIENTS ARE INCLUDED, THE LAST LINE OF THE
C  FILE WILL BE "ASSAY COEFFICIENTS ARE NOT INCLUDED".

C  4. THE FILE TO BE USED BY THE USC*TOOLS PROGRAM WILL NOW BE THE
C  OVERALL FILE OUTPUT BY OPTIONS 6/7 (OUTSINGL), AND NOT THE FILE
C  (OPT7FIL) CREATED IN OPTION 7 TO STORE THE MEANS, MEDIANS, OR MODES
C  OF THE INDIVIDUAL SUBJECT BAYESIAN POSTERIOR JOINT P.D.F.'S.

C  OPT7FIL WILL STILL BE CREATED, BUT NOW OUTSINGL WILL BE STORED INTO
C  THE INPUT FILE RATHER THAN OPT7FIL. COMMENTS TO THE USER WILL BE
C  CHANGED APPROPRIATELY.


C  5. ANOTHER VERY SMALL BUG FIX. A "];" WAS WRITTEN AT THE END OF
C  FILE 33 IN SUBROUTINE PREVRUN. IT WAS A HOLDOVER FROM A PREVIOUS
C  VERSION, AND SHOULD HAVE BEEN REMOVED. IT NOW HAS BEEN.


C  6. THE MAINFRAME PROGRAM IS CHANGED FROM m2_17cal.f TO m2_18cal.f.

C-----------------------------------------------------------------------


C  M2_17.FOR							4-28-98

C  M2_17.FOR HAS THE FOLLOWING CHANGES FROM M2_16.FOR:

C  1. THE FILE CREATED (IF THE USER DESIRES), DURING OPTION 7 IN
C  SUBROUTINE PREVRUN, HAS BEEN MODIFIED. NOW, INSTEAD OF BEING
C  INPUTTABLE AS A MATLAB FILE TO THE MMLQ PROGRAM, IT WILL BE
C  INPUTTABLE TO THE USC*TOOLS PROGRAM (SIMILAR TO THE FILE IN OPTION 6
C  OF THE M1_4.FOR PROGRAM). THE NAME OF THIS FILE WILL BE PUT INTO
C  THE INPUT FILE FOR THIS PROGRAM (IF AN INPUT FILE WAS SAVED BY THE

C  USER, IT WILL BE REWRITTEN WITH THIS FILENAME REPLACING
C  'NOT SELECTED' ON THE LAST LINE).

C  SUBROUTINE TOPFIL IS MODIFIED, AS DESCRIBED ABOVE.

C  2. IN FORMAT 1111, THE NAME OF THE SHELL COMMAND TO COMPILE AND LINK
C  THE PROGRAM HAS BEEN CHANGED. ALSO, THE FILE TO BE UPLOADED TO THE
C  MAINFRAME HAS BEEN CHANGED TO npembig1.inp FROM fil01.inp, AND THIS
C  INFORMATION IS INCLUDED IN FORMAT 1111.

C  3. THERE ARE COSMETIC CHANGES TO THE I/O, INCLUDING REPLACING
C  "Adapt-Like" WITH WORKING COPY.

C  4. CODE HAS BEEN SIMPLIFIED NEAR LABEL 4070, IN MAIN AND VERIF1.

C  5. FORMAT 161 REPLACES * FORMAT WHEN WRITING OUT THE C'S TO A FILE,


C  TO AVOID POSSIBILITY THAT PART OF LINE WRITTEN WILL BE TRUNCATED IF
C  IT EXTENDS PAST COLUMN 72.



C  NOTE: THE MAINFRAME PROGRAM WHICH DOES THE ANALYSIS IS CHANGED FROM
C  m2_16cal.f TO m2_17cal.f.

C-----------------------------------------------------------------------

C  M2_16.FOR							2-13-98

C  M2_16 HAS THE FOLLOWING CHANGES FROM M2_15:

C  1. IT WILL BE LINKED WITH CONVRTJ.FOR, RATHER THAN CONVRTI.FOR (WHICH
C  HAD A 'BUG' RELATED TO THE FLAG AT THE TOP OF THE PATIENT FILE).



C  2. ALL F AND E FORMATS WILL BE CHANGED TO G FORMATS. SINCE THE G
C  FORMAT REQUIRES AT LEAST 6 SPACES IN ADDITION TO THE DECIMAL SPACES +
C  THE SPACE FOR THE DECIMAL POINT ITSELF (TO REPRESENT ALL POSSIBLE
C  NUMBERS, INCLUDING THE NEGATIVE SIGN IF THERE IS A NEGATIVE NO.),
C  THE FORMAT WILL BE Gw.d, WHERE w MUST BE AT LEAST 6 BIGGER THAN d.

C  THEREFORE, THE FOLLOWING LOGIC WILL BE USED TO CONVERT THE FORMATS.
C  GIVEN AN F OR E FORMAT w.d, THE REPLACING G FORMAT WILL BE ww.d,
C  WHERE ww = MAX(w,d+6). IF ANY ACCOMPANYING FORMATS ARE DEPENDENT ON
C  THE REPLACED FORMAT, IT WILL BE CHANGED ACCORDINGLY. FOR EXAMPLE,

C  FORMAT 5104 IS USED TO PLACE THE PARAMETER NAMES ABOVE MEANS,

C  MEDIANS, ETC. USING FORMAT 5103. PREVIOUSLY, THE FORMATS WERE:

C  5104   FORMAT(5X,20(A11,5X))
C  5103   FORMAT(1X,20(F11.6,5X))


C  IN THIS PROGRAM, SINCE 11.6 MUST BE CHANGED TO 12.6 FOR THE G FORMAT
C  (I.E., ww = MAX(11,6+6) = 12), AND SINCE 5X HAS BEEN CHANGED TO 1X,
C  FORMAT 5104 MUST BE CHANGED TO BE COMPATIBLE.

C  5104   FORMAT(5X,20(A11,2X))
C  5103   FORMAT(1X,20(G12.6,1X))


C  EXCEPTION: FORMAT 16 IN SUBROUTINE PUTASS HAS BEEN CHANGED FROM
C  F18.14 TO G16.10,2X (A G FORMAT WITHOUT X'S CAUSES THE C'S TO RUN
C  TOGETHER ON THE LINE (SOMETIMES), AND 10 DECIMAL PLACES IS PLENTY).


C  A COUPLE OF OTHER EXCEPTIONS FROM THE ABOVE RULE HAVE BEEN MADE FOR

C  COSMETIC REASONS, INCLUDING PRINTING OUT % VALUES.

C  3. THERE IS A COSMETIC CHANGE TO FORMAT 7 IN SUBROUTINE USERPREP.

C  4. THE sun COMPANION PROGRAM WILL BE CHANGED TO m2_16cal.f, WHICH
C  WILL DIFFER FROM m2_15cal.f IN THE FORMATS, AS DESCRIBED ABOVE, AND
C  IN A CHANGED ORDER IN COMMON/DESCR. BECAUSE THE FORTRAN COMPILER
C  'LIKES' REAL*8 VARIABLES TO PRECEED INTEGER VARIABLES IN COMMON
C  STATEMENTS, THE ORDER HAS BEEN CHANGED.


C  NOTE THAT THE PROGRAM WHICH CAN CREATE THE FORTRAN MODEL FILE
C  INPUT TO THIS PROGRAM, BOXNEW3.PAS, HAS BEEN CHANGED TO
C  BOXNEW3.PAS. THE ONLY CHANGE IS THE ORDER OF THE ARGUMENTS IN
C  COMMON /DESCR/ AGE,HEIGHT,ISEX,IETHFLG <-- NEW ORDER.

C  (SEE RELATED COMMENTS TO THIS IN M2_15.FOR COMMENT 2 AT TOP).

C-----------------------------------------------------------------------



C  M2_15.FOR							1-25-98

C  M2_15 HAS THE FOLLOWING CHANGES FROM M2_14:

C  1. THERE ARE MAJOR CHANGES RELATED TO THE NEW PASTRXII (XPAST.EXE)
C  USC*PACK FILES; IN PARTICULAR, THE FORMAT OF THE USC*PACK FILES

C  IS CHANGED (NEW COVARIATES ARE ALLOWED), AND THIS CHANGES
C  SUBSTANTIALLY THE FORMAT OF THE "ADAPT-LIKE" FILES.

C  IN PARTICULAR, INSTEAD OF JUST 2 "COVARIATES" (WT AND CCR), THERE ARE
C  NOW UP TO 16 "COVARIATES" AVAILABLE (WT, CCR, 10 ADDITIONAL
C  COVARIATES ENTERED IN THE DOSAGE REGIMEN COLUMNS, ALONG WITH THE 4
C  DISCRETE DESCRIPTORS AGE, SEX, HEIGHT, AND ETHNICITY FLAG).

C  MAJOR CODE CHANGES INCLUDE:

C   a. CONVRTH.FOR HAS BEEN MODIFIED TO CONVRTI.FOR TO READ THE NEW

C   USC*PACK FILES, AND CONVERT THEM TO THE NEW "ADAPT-LIKE" FILES.

C   b. SUBROUTINES FILRED, STACK, PUTASS HAVE MAJOR CHANGES TO READ
C   THE NEW "ADAPT-LIKE" FILES.

C  NOTE: THE USER MAY USE THIS PROGRAM WITH PATIENT FILES WHICH WERE
C	 CREATED EITHER BY THE OLD PASTRX PROGRAM OR THE NEW PASTRXII
C 	 PROGRAM (XPAST.EXE). BUT, IT IS NOT POSSIBLE TO USE THIS
C  	 PROGRAM WITH ADAPT-LIKE FILES WHICH WERE CONVERTED FROM A
C	 PREVIOUS VERSION OF CONVRTI.FOR (1ST USED IN M2_15.FOR).
C	 THIS IS BECAUSE PREVIOUS VERSION ADAPT-LIKE FILES DON'T HAVE
C	 ALL THE PRELIMINARY INFO (E.G., AGE, SEX, ETC.) THAT
C 	 THIS PROGRAM EXPECTS TO SEE.


C  NOTE THE ORDER OF PATIENT FILE MANIPULATION:



C --  SUBROUTINE CONVRT (CONVRTI.FOR) READS IN THE USC*PACK FILES AND
C     CONVERTS THEM TO THE NEW ADAPT-LIKE FORMAT, INCLUDING NAME,
C     WARD NO., AGE, SEX, HEIGHT, AND ETHNICITY FLAG AT TOP. ALSO, THE
C     NAMES OF ANY ADDITIONAL COVARIATES SELECTED BY THE USER PRECEDE
C     THE DOSAGE INFO. FOLLOWING THE DOSAGE INFO, AND THE CONCENTRATION
C     INFO, IS THE LIST OF COVARIATE NAMES AND VALUES (1ST, LAST, AND
C     MEAN VALUES FOR THAT SUBJECT).

C --  SUBROUTINE PUTASS READS ABOVE ADAPT-LIKE FILES AND APPENDS THE

C     USER-DESIRED ASSAY NOISE COEFFICIENTS AT THE END. IF COEFFICIENTS
C     ARE ALREADY THERE, PUTASS MAKES SURE THEY ARE THE ONES THE USER
C     DESIRES FOR THE CURRENT RUN.

C --  SUBROUTINE STACK READS THE ADAPT-LIKE FILES, WHICH NOW HAVE ASSAY
C     NOISE COEFFICIENT AT THE END, AND STACKS THEM ONTO FILE 27. NOTE
C     THAT THE "2" ON THE LINE WHICH PRECEDES THE C'S IS TAKEN OUT.
C     ALSO, EACH IV RATE AND BOLUS INPUT IS MULTIPLIED BY AF.

C --  SUBROUTINE FILRED READS EACH PATIENT'S INFO FROM THE PORTION OF

C     FILE 27 ASSIGNED TO THAT PATIENT. THIS HAPPENS IN THE  m2_15cal.f
C     PROGRAM, OR IN THIS PROGRAM IN SUBROUTINE PREVRUN.


C  2. NOTE THAT THE PROGRAM WHICH CAN CREATE THE FORTRAN MODEL FILE


C  INPUT TO THIS PROGRAM, BOXESNEW.PAS, HAS BEEN CHANGED TO BOXNEW2.PAS.
C  THE CHANGE IS THAT  COMMON /DESCR/ AGE,ISEX,HEIGHT,IETHFLG  IS
C  PROVIDED TO SUBROUTINES DIFFEQ AND OUTPUT, SO THE USER CAN USE THESE
C  4 DESCRIPTORS IF HE CHOOSES, IN HIS D.E.'S AND OUTPUT EQ.
C  RECALL THAT THE FORTAN MODEL FILE INCLUDES SUBROUTINES DIFFEQ,
C  OUTPUT, AND SYMBOL, AND THIS FILE IS CALLED FORFILE, AND IT IS
C  APPENDED TO THE END OF npemdriv.f (SEE CHANGE 1 IN M2_14.FOR).

C  3. THE OPTION 7 MEAN/MEDIAN/MODE FILE (IN SUBROUTINE PREVRUN) HAS
C  ITS FORMAT CHANGED TO BE JUST LIKE THE FILE CREATED BY FORMLC. THIS
C  ALLOWS THIS FILE, ALSO, TO BE INPUT TO THE MMLQ PROGRAM.

C  4. IN IOPT .EQ. 7, WHEN THE MEANS/MEDIANS/MODES ARE WRITTEN TO THE
C  SCREEN (ISCAT .EQ. 4 OPTION), INCLUDED ARE ALSO THE ASSOCIATED
C  PROBABILITIES (=1/NSUB FOR EACH SUBJECT).


C  NOTE: THIS PROGRAM PREPARES THE INPUT FILE TO BE UPLOADED TO BE RUN
C  BY m2_15cal.f, WHICH INCLUDES THE NEW MODULES idfixed3.f, idcy_52.f,
C  AND idcy_62.f, ALONG WITH THE UNCHANGED MODULE vodtot.f.

C-----------------------------------------------------------------------

C  M2_14.FOR							11-4-97

C  M2_14 HAS THE FOLLOWING CHANGES FROM M2_13:

C  1. A NEW SUBROUTINE, MAKEDRIV, CREATES npemdriv.f, WHICH WILL BE
C  THE "MAIN" OF THE WHOLE 'BIG NPEM2'. FORFILE, THE MODEL FILE INPUT
C  BY THE USER, WILL BE APPENDED TO THE END OF npemdriv.f, SO ONLY
C  ONE .f FILE WILL HAVE TO BE UPLOADED TO THE MAINFRAME.


C  THIS "MAIN" HAS A PARAMETER STATEMENT WHICH DEFINES THE PARAMETERS
C  WHICH ESTABLISH THE DIMENSIONS IN THE VARIABLY DIMENSIONED ARRAYS,
C  ALONG WITH A DIMENSION STATEMENT WITH ALL ARRAYS WHICH DEPEND ON
C  THESE VALUES. IT THEN HAS THE STATEMENT:

C  CALL BIGNPEM( ...) , WHERE ALL VARIABLY DIMENSIONED ARRAYS (AND THE
C  VARIABLE PARAMETER DIMENSIONS) ARE PASSED TO BIGNPEM, WHICH IS NOW
C  THE MAIN MODULE IN m2_14cal.f.

C  2. ANOTHER NEW SUBROUTINE, CALCLIMIT, INPUTS NVAR AND NSUB, AND
C  THEN CALCULATES THE MAXIMUM VALUE FOR INDPTS (BASED ON HOW BIG THE
C  'SIZE' OF THE PROGRAM IS TO BE ON almaak, AND ON THE MAXIMUM NO. OF
C  ENTRIES ALLOWED IN ARRAYS ON m2_14cal.f). THIS ENSURES THE USER
C  WILL SELECT AN APPROPRIATE VALUE FOR INDPTS.

C  3. THE PARAMETER MAXDIM IS PASSED TO SUBROUTINE USERPREP TO MAKE SURE
C  THAT THE MODEL THE USER HAS SELECTED (IN FORFILE) HAS
C  NVAR .LE. MAXDIM.

C  4. INFORMATION CAN BE INPUT DIRECTLY FROM THE OUTPUT OF THE 'BIG
C  FRONT-END' (CURRENT PROGRAM = m1_2calc.f), VIA FILE FROMxxxx, WHERE
C  xxxx IS THE JOB NUMBER ON THE MAINFRAME.

C  5. MAXSUB IS PUT INTO THE PARAMETER STATEMENT, AND THEN PASSED TO
C  SUBROUTINES PREVRUN, CALCSER, SUBRES, AND EXTREME, AS A DIMENSION FOR
C  VARIABLY DIMENSIONED ARRAYS. ALL 999'S AND 200'S, WHICH REPRESENTED
C  THE MAXIMUM NO. OF SUBJECTS, HAVE BEEN CHANGED TO MAXSUB ... WITH
C  TWO EXCEPTIONS: COEFF(999,5), SINCE COEFF IS PASSED IN COMMON/TOSCAT,

C  AND LEAVING THE DIMENSION AS 999 --> NO CHANGE IN SCATPL10.FOR.;
C  AND NUMBER(999), SINCE NUMBER IS PASSED IN COMMON/TOBLK, AND LEAVING
C  THE DIMENSION AS 999 --> NO CHANGE IN DATABLK1.FOR.

C  6. REDIMENSION ATOL(3) TO ATOL(20), WHICH IT SHOULD HAVE BEEN ALL

C  ALONG.

C  7. THE COMMENTS TO USER REGARDING THE UPLOADING AND DOWNLOADING OF
C  FILES ARE IMPROVED (EASIER TO UNDERSTAND).


C  8. WHEN INPUTTING FILES FROM PREVIOUS RUNS, IN SUBROUTINE PREVRUN,
C  THE COMMENTS TO THE USER REGARDING WHICH FILES TO INPUT ARE
C  IMPROVED (EASIER TO UNDERSTAND).

C  9. ALL THE USC*PACK FILENAMES ARE STORED INTO NAME_OF.PST --
C  IF IFORMT = 2, EVEN IF ALL FILENAMES HAVE THE SAME PREFIX/EXTENSION
C  (IDIRCT=0), OR THEY ARE ALREADY IN A FILE (IDIRCT=1/IDRFIL=1).
C  PREVIOUSLY, THE USER GOT TO CHOOSE WHETHER TO STORE THESE NAMES, AND,
C  IF SO, THE NAME OF THE FILE WHICH WAS TO STORE THEM.

C  10. IN SUBROUTINE PLTCON, A 'BUG' MUST BE FIXED. SINCE NVAR .LE. 20,
C  RATHER THAN 7, ADDITIONAL CALL PGSTYL LINES ARE NEEDED FOR ALL
C  POSSIBLITIES. ALSO, GO TO (...) ICOL LINE MUST BE EXTENDED.

C  11. IN SUBROUTINE PREVRUN, THE FORMAT FOR OUTPUTTING PARAMATER VALUES
C  (MEANS, MEDIANS, OR MODES) TO A FILE IN THE IOPT=7 OPTION HAS BEEN
C  IMPROVED.

C-----------------------------------------------------------------------

C  M2_13.FOR							9-1-97

C  M2_13 IS THE SAME AS M2_12, EXCEPT THAT THE LIMITS ON THE SIZE OF
C  THE PROGRAM ARE CHANGED AS FOLLOWS:

C  THE MAXIMUM NO. OF GRID POINTS IS INCREASED FROM 16*80021 TO
C  100*80021;
C  THE MAXIMUM NO. OF SUBJECTS IS INCREASED FROM 100 TO 200;
C  THE MAXIMUM NO. OF DIMENSIONS IS INCREASED FROM 8 TO 10.

C  SEE COMMENTS AT TOP OF m2_13cal.f TO SEE WHAT LIMITS ARE ON THE
C  SIZES OF THAT PROGRAM.

C  THE LARGER CAPACITY OF m2_13cal.f IS DUE TO THE CONCEPT OF AN ADDED
C  PARAMETER, MAXACT = MAXIMUM NO. OF GRID POINTS WHICH ARE STORED TO
C  PYJGX. CURRENTLY, MAXACT = 100000. SEE DETAILS IN m2_13cal.f CODE.


C  THE FUNCTIONAL CHANGES IN THIS PROGRAM ARE:

C  1. THE CODE ON INPUTTING INDPTS IS CHANGES TO ALLOW UP TO 100


C  MULTIPLES OF 80021 GRID POINTS (INSTEAD OF JUST 16 MULTIPLES).


C  NOTE THAT MAXGRD FOR THIS (PC) PROGRAM IS LIMITED TO 10,000, BUT
C  THE ASSOCIATED sun PROGRAM, m2_13cal.f WILL HAVE A LIMIT OF
C  100*80021.


C  2. MAXDIM IS CHANGED FROM 8 TO 10 IN THE PARAMETER STATEMENT
C  (BUT NO OTHER CHANGES ARE MADE TO REDUCE DIMENSIONS FROM 20 TO 10).

C  3. PYJGX(100,MAXGRD) IS CHANGED TO PYJGX(200,MAXGRD) IN THREE PLACES,
C  MAIN, SUBROUTINE PREVRUN, AND SUBROUTINE SUBRES.

C-----------------------------------------------------------------------

C  M2_12.FOR							8-27-97

C  M2_12 IS THE SAME AS M2_11, EXCEPT THAT IT ALLOWS FEWER SUBJECTS
C  (100 VS. 999), AND DIMENSIONS (8 VS. 20), BUT MORE GRID POINTS

C  (16*80021 VS. 2*80021 - EVEN THOUGH THE CODE STATED THAT
C  M2_11.FOR ALLOWED 16*80021 GRID POINTS, m2_11cal.f WOULD NOT
C  RUN MORE THAN 2*80021).

C  NOTE THAT THE CHANGES ARE JUST:


C  1. MAXDIM IS CHANGED FROM 20 TO 8 IN THE PARAMETER STATEMENT
C  (BUT NO OTHER CHANGES ARE MADE TO REDUCE DIMENSIONS FROM 20 TO 8).

C  2. PYJGX(999,MAXGRD) IS CHANGED TO PYJGX(100,MAXGRD) IN THREE PLACES,
C  MAIN, SUBROUTINE PREVRUN, AND SUBROUTINE SUBRES.

C  NOTE THAT MAXGRD FOR THIS (PC) PROGRAM IS LIMITED TO 10,000, BUT
C  THE ASSOCIATED sun PROGRAM, m2_12cal.f WILL HAVE A LIMIT OF
C  16*80021.


C-----------------------------------------------------------------------

C  M2_11.FOR							8-15-97

C  M2_11 HAS THE FOLLOWING CHANGES FROM M2_10:


C  1. THE NO. OF GRID POINTS MAY NOW BE > 80021. IN FACT, THE USER
C  MAY SELECT UP TO 16 MULTIPLES OF 80021 POINTS. EACH MULTIPLE WILL BE
C  PUT INTO A 'SLICE' OF THE GRID SPACE, DEFINED BY THE 1ST PARAMETER'S
C  BOUNDARIES.

C  THE RELATED CHANGE IN THIS PROGRAM IS THAT PREVIOUSLY INDPTS HAD TO
C  BE INSIDE [1,6], WITH NGRID DEFINED AS BEFORE, BUT NOW IT CAN ALSO
C  BE [101,116], WHERE NGRID = 80021*(INDPTS-100).


C  THE CHANGES TO m2_11cal.f (THE sun ANALYSIS PROGRAM) ARE DESCRIBED
C  IN THAT PROGRAM.


C  2. THE USER IS REMINDED THAT ANY LOWER BOUNDARIES = 0 SHOULD BE
C  CHANGED TO A POSITIVE NO. IF THAT PARAMETER IS IN A DENOMINATOR
C  IN THE MODEL FILE. THIS I/O CHANGE IS MADE TO PAR_6.INP (UPDATED
C  FROM PAR_5.INP), WHICH IS THEN PUT INTO MAIN AND VERIF1 OF THIS
C  PROGRAM.

C  3. A 'BUG' WAS CORRECTED. IF USER PREPARES A FILE FOR UPLOADING TO
C  THE MAINFRAME (IANAL = 1), SELECTS A PRIOR DENSITY FROM THE OUTPUT
C  OF A PREVIOUS RUN, AND THEN ASKS TO SEE MARGINAL PLOTS FROM THIS
C  PRIOR DENSITY, PREVIOUSLY, IT WOULDN'T HAVE WORKED, SINCE VOLSPA
C  WAS NOT CALCULATED BEFORE CALLS TO ROUTINES CALMAR AND NOTINT.
C  NOW VOLSPA IS ESTABLISHED, SO THE PLOTS WILL BE O.K.


C  4. SINCE THIS PROGRAM MUST BE COMPATIBLE WITH m2_11cal.f WHICH ALLOWS

C  999 SUBJECTS, THE 1ST DIMENSION OF PYJGX MUST BE 999. BECAUSE OF
C  SPACE LIMITATIONS, I'LL RESET THE VALUE OF MAXGRD TO BE AS HIGH AS
C  IT CAN BE FOR THIS PROGRAM.

C  IF THE USER TRIES TO RUN A PRIOR DENSITY WITH MORE THAN 1000 GRID
C  POINTS (EITHER IN MAIN AS A PRIOR DENSITY FILE, OR IN PREVRUN AS A
C  DENSITY FILE TO BE EXAMINED), HE WILL GET THE MESSAGE THAT HE MUST
C  REDUCE DENSITIES FILES TO HAVE NO MORE THAN MAXGRD POINTS.

C  5. THE MAXIMUM NO. OF PARAMETERS IS INCREASED FROM 7 TO 20. THIS

C  AFFECTS MOSTLY THE DIMENSION STATEMENTS OF THE AFFECTED ROUTINES.
C  BUT ALSO SOME FORMATS ARE CHANGED.

C  6. A 'BUG' WAS CORRECTED IN READING IN THE PRIOR DENSITY FILE
C  IF THE USER WANTS A PRIOR DENSITY, RATHER THAN A UNIFORM DENSITY
C  TO START A RUN. PREVIOUSLY, THIS PROGRAM DID NOT READ IN NDIM; NOW
C  IT DOES. ALSO, THE READING OF IRAN HAS BEEN REMOVED SINCE IT IS NOT
C  PUT INTO THE DENSITY FILE.

C-----------------------------------------------------------------------

C  M2_10_2.FOR							7-6-97




C  M2_10_2.FOR (PC PROGRAM) HAS THE FOLLOWING CHANGES FROM M2_10_1.FOR:

C  1. PREVIOUS SAVED INPUT FILES ARE NOW ALLOWED (I.E., THOSE WITH
C  PREVIOUS VERSIONS AT THE TOP OF THEIR FILES). ANY NEW REQUIRED INFO
C  IS FILLED IN WITH DEFAULT INFO, WHICH THE USER CAN THEN CHANGE AS
C  DESIRED IN SUBROUTINE VERIF1.

C  PREVIOUS VERSIONS ALLOWED:

C  M2_5.FOR			'VER_BAK AUG_96'
C  M2_6.FOR			'REM_BAK JAN_97'
C  M2_8.FOR			'REM_BAK JUN_97'
C  M2_10.FOR			'REM_BAK JUL_97'


C  2. COSMETIC CHANGE: THE I/O FOR OBTAINING THE ASSAY COEFFICIENTS IS
C     CHANGED (SAME AS THE CHANGE MADE IN MXEM2N62.FOR).

C  3. COSMETIC CHANGE: IT'S MADE CLEAR THAT ANY CHANGES TO THE ASSAY
C  COEFFICIENTS IN THE PATIENT DATA FILES ARE MADE TO THE Adapt-Like
C  FILES ONLY.



C  4. DEFAULT CONVERGENCE TOLERANCE IS CHANGED FROM .00001 TO .000001.
C  ALSO THE DEFAULT NO. OF CYCLES TO RUN IS CHANGED FROM 100 T0 10,000.


C  IN THIS REGARD, THE DIMENSIONS IN SUBROUTINES CONVERGE, PLTCON,
C  AND MINMAX MUST BE CHANGED TO ALLOW UP TO 10,000 CYCLES.

C  ALSO, ALL WRITE STATEMENTS FOR CYCLE NO. MUST BE AT LEAST I5.

C-----------------------------------------------------------------------


C  M2_10_1.FOR						6-29-97

C  M2_10_1.FOR (PC PROGRAM) HAS THE FOLLOWING CHANGES FROM M2_10.FOR:

C 1.  IT IS LINKED WITH SCATPL10.FOR INSTEAD OF SCATPLT9.FOR. THIS
C     CHANGE CONTAINS NO CODE CHANGES IN THIS MODULE (ONLY IN
C     MODULE SCATPL10.FOR).



C 2.  IN SUBROUTINE PREVRUN, OPTION 7 IS MADE MORE FLEXIBLE, SIMILAR
C     TO THE FLEXIBILITY IN MXEM2N64.FOR (IN PARTICULAR, THE USER CAN
C     NOW SEE THE SCATTERPLOT FOR THE POPULATION WITHOUT HAVING TO SEE
C     INDIVIDUAL SUBJECT SCATTERPLOTS). ALSO NOTE, UNLIKE MXEM2N64,
C     THE INDIVIDUAL SUBJECT ANALYSES ARE NOT REQUIRED TO SEE THE
C     POPULATION SCATTERPLOT, SINCE EXX IS READ IN FROM DENSITY FILE
C     COMPLETED FROM THE PRIOR RUN.

C-----------------------------------------------------------------------

C  M2_10.FOR						6-13-97

C  M2_10.FOR (PC PROGRAM) HAS THE FOLLOWING CHANGES FROM M2_9.FOR:

C     THE USER NO LONGER ENTERS T_END. INSTEAD, IT IS SET = 24
C     HOURS AFTER THE MAX OBSERVATION TIME AMONG ALL THE SUBJECTS.
C     THIS MEANS THAT THE CODE FOR THE SAVED FILE WILL BE CHANGED ...
C     TO REM_BAK JUL_97 FROM REM_BAK JUN_97. SO CODE.EXP WILL BE
C     UPDATED.


C     NOTE THAT m2_10cal.f IS THE SAME AS m2_9calc.f.

C-----------------------------------------------------------------------

C  M2_9.FOR						6-11-97


C  M2_9.FOR (PC PROGRAM) HAS THE FOLLOWING CHANGES FROM M2_8.FOR:


C  1. THE ASSAY NOISE COEFFICIENTS, WRITTEN TO fil01.inp, WILL BE
C     WRITTEN ON TWO LINES, INSTEAD OF ONE. THIS PREVENTS THE
C     POSSIBILITY THAT C2, IF WRITTEN WITH A "D-xxx" AT THE END



C     (e.g., D-003) WILL BE TOO LONG FOR THE LINE, AND THEREFORE NOT
C     READ PROPERLY BY THE sun PROGRAM (WHICH APPARENTLY CAN'T READ


C     A LINE IF IT'S TOO LONG).

C  2. IN SUBROUTINE USERPREP, THE USER MAY NOW SELECT A PARAMETER TO
C     BE RANDOM WITH AN "r" DECLARATION, AS WELL AS AN "R". SIMILARLY,

C     "f", AS WELL AS "F", WILL DECLARE A PARAMATER TO BE FIXED.

C-----------------------------------------------------------------------

C  M2_8.FOR						6-3-97

C  M2_8.FOR (PC PROGRAM) HAS THE FOLLOWING CHANGES FROM M2_7.FOR:

C 1.  NAME CHANGES:

C   user_4.f IS CHANGED TO mod01.f.
C   m2__calc.inp IS CHANGED TO fil01.inp.

C  2. NEW INFO IS INPUT BY USER:

C   IDELTA, T_END, XMIC, AND MEAN/MEDIAN/MODE SELECTION. THESE VALUES

C   WILL BE USED BY m2_8calc.f TO CALCULATE PREDICTED VALUES FOR EACH
C   SUBJECT AT TIMES 0, IDELTA, 2*IDELTA, ..., T_END, ALONG WITH AUC'S
C   (AREAS UNDER CURVES) AND AUC/MIC'S. SEE DETAILS IN m2_8calc.f.

C   NOTE THAT THE SAVED INPUT FILE CODE WILL CHANGE FROM
C   'REM_BAK JAN_97' TO 'REM_BAK JUN_97' (BECAUSE OF ABOVE NEW INFO
C   TO BE SAVED).


C   NOTE THAT THE NSUB TABLES OF PREDICTED VALUES WILL BE PUT INTO
C   THE FILE PRTBxxxx, WHERE xxxx IS THE SAME AS xxxx FOR THE OUTxxxx
C   AND DENxxxx OUTPUT FILES. THE AUC'S AND AUC/MIC'S WILL ACCOMPANY

C   EACH SUBJECT'S BAYESIAN POSTERIOR INFO (AT THE END OF THE RUN).


C-----------------------------------------------------------------------

C  M2_7.FOR							2-11-97

C  M2_7.FOR (PC PROGRAM) HAS THE FOLLOWING CHANGES FROM M2_6.FOR:

C  1. IT IS NO LONGER LINKED WITH IDUSER_4.FOR (WHICH THE USER TO
C     HAVE TO COMPLETE PRIOR TO RUNNING THIS PROGRAM). INSTEAD,
C     SUBROUTINE USERPREP IS ADDED TO READ THE .FOR FILE (CREATED BY A

C     BOXES PROGRAM, CURRENTLY BOXESNEW.EXE), AND THEN COPY IT TO
C     user_4.f, WHERE  user_4.f + idfixed.f =  iduser_4.f (EXCEPT FOR
C     SOME CHANGES IN COMMON STATEMENTS, DIMENSIONS, ARGUMENT LISTS,
C     ETC).


C  idfixed.f = THE PART OF IDUSER_4.FOR THAT DOESN'T CHANGE =
C	       MAIN, FUNC, SUMSQ, WEIGHT, USERANAL.

C  user_4.f = THE PART THAT THE USER COMPLETES FOR EACH NEW PROBLEM
C		(SUBROUTINES DIFFEQ, OUTPUT, SYMBOL). NOTE THAT
C		SUBROUTINE JACOB HAS BEEN ELIMINATED FOR NOW, AND
C		MF HAS BEEN HARDCODED TO BE 22 (I.E., THE JACOBIAN
C		WILL BE CALCULATED NUMERICALLY).


C     THEN, THE USER UPLOADS user_4.f (ALONG WITH
C     m2__calc.inp) TO THE MAINFRAME TO RUN m2_7calc.exe (NOTE THAT
C     idfixed.f IS ALREADY ON THE MAINFRAME - IT NEEDED TO BE UPLOADED
C     JUST ONCE, SINCE IT DOESN'T CHANGE, ANALYSIS TO ANALYSIS).


C  2. IN SUBROUTINE PREVRUN, SINCE THIS PROGRAM IS NO LONGER LINKED WITH
C     IDUSER_4.FOR (WHICH CONTAINED SUBROUTINE IDPC), SUBROUTINE IDPC
C     WILL NO LONGER BE CALLED IN LOOP 800 TO GET PYJGX(JSUB,IG).

C     INSTEAD THESE VALUES WILL BE READ FROM THE DENSITY FILE CREATED
C     BY m2_7calc.exe (CHANGED FROM m2_6calc.exe) ON THE MAINFRAME.

C  3. THIS PROGRAM CAN NO LONGER BE LINKED WITH IDCY_5.FOR
C     (WHICH INCLUDES IDCALCY). THAT MODULE CALLS SUBROUTINE OUTPUT
C     OF MODULE user_4.f, WHICH CHANGES ANALYSIS - TO - ANALYSIS (SEE
C     ABOVE). SINCE THE USER WON'T BE ABLE TO RECOMPILE user_4.f ON

C     HIS PC AND RELINK WITH THIS PROGRAM (I.E., HE WON'T HAVE ACCESS
C     TO LAHEY FORTRAN), IDCY_5.FOR CANNOT BE A PART OF THIS PROGRAM.

C     THEREFORE, THE CALLS TO IDCALCY HAVE BEEN MADE A PART OF
C     m2_7calc.f. THE APPROPRIATE PREDICTED VALUES RETURNED BY
C     IDCALCY WILL BE STORED BY m2_7calc.f INTO THE DENSITY FILE,
C     AND THEN READ INTO THIS PROGRAM IN SUBROUTINE PREVRUN.


C     ALSO, THE MEANS, MEDIANS, AND MODES FOR THE BAYESIAN POSTERIOR
C     DENSITIES IS READ IN FROM THE DENSITY FILE (IN PREVRUN). THESE
C     VALUES COULD BE OBTAINED IN PREVRUN (IN THE CALLS TO
C     SUBROUTINE SUBRES), BUT THERE IS NO NEED TO. THEY ARE UNUSED IN
C     THIS PROGRAM, EXCEPT THAT THEY ARE WRITTEN OUT TO THE SCREEN AND
C     OUTPUT FILES.

C-----------------------------------------------------------------------

C  M2_6.FOR							1-15-97



C  M2_6.FOR (PC PROGRAM) + m2_6calc.f (sun/mtha program) MAKE THE
C  SAME CHANGES TO M2_5.FOR + m2_5calc.f THAT MXEM2N60.FOR MADE TO
C  MXEM2N59.FOR. THE DETAILS ARE:

C  THE PROGRAM NOW ALLOWS EACH PATIENT FILE TO INCLUDE ITS OWN
C  ASSSAY NOISE COEFFICIENTS (BUT PATIENT FILES WITHOUT THEIR OWN
C  INDIVIDUAL COEFFICIENTS CAN STILL BE ANALYZED).

C  FOR EACH PATIENT, THE ASSAY COEFFICIENTS TO BE USED WILL BE EITHER
C  THE ONES ALREADY IN ITS FILE (IF ANY), THE DEFAULT (POPULATION)
C  VALUES, OR A SPECIFIC SET FOR THAT PATIENT.

C  AT THE BEGINNING OF THE RUN, THE C'S TO BE USED FOR EACH PATIENT WILL
C  BE WRITTEN AT THE END OF HIS/HER ADAPT-LIKE DATA FILE (IF THEY'RE NOT


C  ALREADY THERE).

C  MODULE CONVRTG.FOR IS CHANGED TO CONVRTH.FOR (THIS MODULE CONTAINS
C  SUBROUTINE CONVRT, WHICH CONVERTS USC*PACK FILES TO ADAPT-LIKE
C  FILES. CONVRT IS CHANGED TO READ THE C'S IN A USC*PACK FILE, IF
C  IF THEY'RE THERE, AND WRITE THEM INTO AN ADAPT-FILE.

C  NOTE THAT THE 'POPULATION' ASSAY NOISE COEFFICIENTS WILL BE CALLED
C  [C0P,C1P,C2P,C3P]. [C0,C1,C2,C3] WILL BE USED FOR THE INDIVIDUAL
C  VALUES FOR EACH PATIENT, IN TURN.


C  NOTE THAT SUBROUTINE SCATPLOT MUST BE CHANGED SO THAT IT CAN
C  INPUT THE ASSAY COEFFICIENTS, [C0,C1,C2,C3], FOR EACH SUBJECT
C  IF JSUB=0. NEW MATRIX COEFF STORES THESE VALUES AND IS PASSED VIA
C  COMMON/TOSCAT TO SCATPLT9.FOR (CHANGED FROM SCATPLT8.FOR).

C-----------------------------------------------------------------------

C M2_5.FOR ... NEW					12-9-96

C  THE ONLY CHANGE FROM THE ORIGINAL M2_5 IS THAT THE RESTRICTION THAT
C  NGRID, SELECTED BY THE USER, BE .LE. MAXGRD (SET IN THE PARAMETER
C  STATEMENT BELOW) IS REMOVED. SINCE THE ANALYSIS WILL BE DONE BY THE
C  sun PROGRAM, m2_5calc.exe, ANY RESTRICTION ON NGRID SHOULD COME FROM
C  m2_5calc (WHICH CURRENTLY HAS MAXGRD SET = 80021).

C  M2_5.FOR						11-17-96

C  M2_5.FOR (PC PROGRAM) + m2_5calc.f (sun/mtha program) ARE EQUIVALENT
C  TO MXEM2_5.FOR. M2_5.FOR DOES THE PREPARATION PART OF THE PROGRAM,
C  AS WELL AS THE EXAMINATION OF THE OUTPUT FILES FROM THE ANALYSIS. THE
C  ANALYSIS IS DONE ON THE SUN BY m2_5calc.f.


C  IN THE PREPARATION PHASE, M2_5.FOR DOES ALL THE USER I/O AND
C  CONCATENATING OF PATIENT FILES. IT OUTPUTS ONE FILE, m2__calc.inp,
C  WHICH CONTAINS THE INPUT INFO FOR THIS RUN, AS WELL AS THE
C  CONCATENATED PATIENT DATA FILES FOR THIS RUN.

C  m2_5calc.f CAN THEN BE RUN ON A SUPERCOMPUTER AFTER UPLOADING
C  m2__calc.inp TO IT.

C  THE SEPARATION OF MX3M2_5.FOR INTO THE M2_5.FOR AND m2_5calc.f IS AS
C  FOLLOWS:

C  M2_5.FOR <-- I/O PART OF MAIN + SUBROUTINES FILRED, STACK, VERIF1,
C		CHANGE, CALMAR, THREED1, FORMLC, CONVERGE, PLTCON,
C		MINMAX, PLOTS, SUBRES, GETOUT, PREVRUN, PRNLAST, SEEDIR,
C		CALCSER, NOTINT, STAT, DELAY, AND EXTREME, ... PLUS
C               MODULES DATABLK1 IDUSER_4 CONVRTG GHCSEL IDCY_4 SCATPLT8
C               AND VODTOT.

C  m2_5calc.f <-- CALCULATION PART OF MAIN + SUBROUTINES FILRED, GETCOF,
C		CALGRD, NOTINT, STAT, PREDCYC, AND PRNTOP, ... PLUS
C	        MODULES iduser_4.f, idcy_4.f, AND vodtot.f (= IDUSER.FOR
C		IDCY_4.FOR, AND VODTOT.FOR, RESPECTIVELY).



C  NOTE THAT SUBROUTINE DELAY IS NOT USED.

C-----------------------------------------------------------------------

C  REFER TO THE CODE OF MXEM2_5.FOR FOR THE COMMENTS REGARDING THIS
C  SERIES OF PROGRAMS.


C-----------------------------------------------------------------------


      IMPLICIT REAL*8(A-H,O-Z)

CCCCCCCCCCCCC

	PARAMETER(MAXDIM=30, MAXGRD=1500, MAXSUB = 800, MAXOBDIM=150,
     1          MAXNUMEQ = 7)

C  NOTE THAT MAXOBDIM IS HARDCODED INTO npbig8adapt.f TO BE 150. SO IF
C  THIS VALUE CHANGES HERE, IT SHOULD BE CHANGED THERE.

CCCCCCCCCCCCC

      COMMON/TOWRITE/IALLIN,IVERIFY,NCOVA,ICOVTYPE,COVNAME

C  AS OF NPAG112.FOR, COMMON/TOWRITE IS PROVIDED TO 
C  SUBROUTINE WRITEINFILE FROM READBLOCK, OR PROVIDED TO READBLOCK

C  FROM MAIN.

      DIMENSION WORK(MAXGRD),IRAN(32),AB(30,2),VALFIX(20),
     1PYJGX(MAXSUB,MAXGRD),
     4AAB(30,2),IJUNK(MAXGRD),VVALFX(20),PYJGXX(MAXGRD),
     5CORDEN(MAXGRD,MAXDIM+1),CORHOLD(MAXGRD,MAXDIM+1),ATOL(20),
     6EXX(MAXSUB,3,30),YPREDPOP(MAXSUB,MAXNUMEQ,MAXOBDIM,3),
     7YPREDBAY(MAXSUB,MAXNUMEQ,MAXOBDIM,3),SERNUM(MAXSUB),
     8IASS(MAXNUMEQ),C0P(MAXNUMEQ),C1P(MAXNUMEQ),C2P(MAXNUMEQ),
     9C3P(MAXNUMEQ),YO(MAXOBDIM,MAXNUMEQ),IALLPAT(MAXNUMEQ),
     1ASSMULT(MAXNUMEQ),NCSTORE(MAXNUMEQ),GENCOEF(MAXNUMEQ,5,4),
     2IPATVEC(MAXSUB),YPREDPOPT(MAXSUB,MAXNUMEQ,7201,3),AF(7),
     4ICOVTYPE(26),RANFIXEST(20),RRANFIXEST(20)

C  THE MAXIMUM ALLOWABLE NO. OF GRID POINTS IS MAXGRD WHICH IS
C  SET IN THE PARAMETER STATEMENT ABOVE.

      CHARACTER NUMBER(999)*3,PATFIL*20,PREFIX*5,PAR(30)*11,PPAR(30)*11,
     1 FROMFIL*20,READLINE*1000,EXT*3,PPARFX(20)*11,PRIFIL2*20,
     2 PARFIX(20)*11,FROMLAST*20,CODE*14,FORFILE*20,PATH*60,TMPFILE*13,
     3 PATHFILE*73,ESTNAM*6,BLOCKPAT*20,CODEPAT*15,PATHFILAST*73,
     4 PATHFIL2*73,ALLINSTRUCT*20,COVNAME(26)*11,ERRFIL*20,
     5 PARRANFIX(20)*11,PPARRANFIX(20)*11

C Yamada 5/5/2010
C NOTE length of char array should be at least max expected + 1

      CHARACTER(LEN=20) :: OSName
      CHARACTER(LEN=5) :: CopyFile
      CHARACTER(LEN=4) :: DeleteFile
      CHARACTER(LEN=6) :: ClearScreen
      CHARACTER(LEN=10) :: ListDir
C
C Yamada 5/5/2010 ... The above are used for distinguishing
C    the Operating System and creating appropriate system calls.
C
	COMMON/TOBLK/NUMBER
C  COMMON/TOBLK/ IS SUPPLIED FROM DATABLK1.FOR, AND PASSED TO
C   SUBROUTINE READBLOCK ALSO.

      COMMON/ERROR/ERRFIL
C  COMMON/ERROR/ IS SUPPLIED TO ALL THE ROUTINES WHICH COULD WRITE TO
C  ERRFIL. NOTE THAT ERRFIL IS SET = 'ERRORLOG' BELOW.

      ERRFIL = 'ERRORLOG'


	WRITE(*,3214) MAXSUB,MAXOBDIM,MAXDIM,MAXGRD,MAXNUMEQ
 3214   FORMAT(//' IN THIS "PC" PROGRAM, BECAUSE OF PC SPACE LIMITATIONS
     1,'/
     1' THE NUMBER OF POPULATION SUBJECTS IS CURRENTLY LIMITED TO ',I4,'
     2,'//
     2' THE NUMBER OF OBSERVATIONS PER SUBJECT IS LIMITED TO ',I4,','//
     2' THE NUMBER OF RANDOM PARAMETERS IS LIMITED TO ',I2,','//
     3' THE NUMBER OF ACTIVE GRID POINTS IN THE JOINT DENSITY RESULTS'/
     4' 	   FILE IS LIMITED TO ',I10,','//
     5' THE NUMBER OF OUTPUT EQUATIONS IS LIMITED TO ',I2,'.'//)



C ------------------------------------------------------------
C Yamada 5/5/2010
C
C Initialize system calls here, e.g.:
C 1. CopyFile = COPY or cp
C 2. DeleteFile = DEL or rm
C
C NOTE the use of INDEX; be careful what substrings are allowed
C    for the ID of an operating system
C NOTE the extra space after each command; this makes it easier
C    to concatenate arguments to the system command.


       CALL GET_COMMAND_ARGUMENT(1,OSName)
       IF ((INDEX(OSName,"MacOSX",.TRUE.).EQ.1)
     $ .OR.(INDEX(OSName,"Darwin",.TRUE.).EQ.1)
     $ .OR.(INDEX(OSName,"BSD",.TRUE.).EQ.1)) THEN
          PRINT *,"Requested OS is ", OSName
          OSName="UNIX"
          PRINT *,"Setting OS to ", OSName

          PRINT *,""
          CopyFile="cp "
          DeleteFile="rm "
          ClearScreen="clear "
          ListDir="ls -tp "
       ELSE IF ((INDEX(OSName,"DOS",.TRUE.).EQ.1)
     $ .OR.(INDEX(OSName,"WinXP",.TRUE.).EQ.1)
     $ .OR.(INDEX(OSName,"XP",.TRUE.).EQ.1)

     $ .OR.(INDEX(OSName,"WinXP",.TRUE.).EQ.1)
     $ .OR.(INDEX(OSName,"Vista",.TRUE.).EQ.1)
     $ .OR.(INDEX(OSName,"Win7",.TRUE.).EQ.1)) THEN
          PRINT *,"Requested OS is ", OSName
          OSName="DOS"
          PRINT *,"Setting OS to ", OSName
          CopyFile="COPY "
          DeleteFile="DEL "
          ClearScreen="CLS "
          ListDir="DIR /OD "
       ELSE
          PRINT *,"WARNING: Operating system not declared."
          PRINT *,"WARNING: Can not initialize system calls."
          PRINT *,""

          PRINT *,"Possible command line error, try:"
          PRINT *,"C:\> npbig.exe <DOS,Win,XP,Vista,or Win7>"
          PRINT *,"unix$ npbig <MacOSX,Darwin,BSD>"
          PRINT *,""
          PRINT *,"NPAG Exiting with status 2"


          PRINT *,""
          CALL EXIT(2)
       END IF
C ------------------------------------------------------------

C  SET IVERIFY = 1. IF IALLIN = 1 BELOW, THE USER WILL SUPPLY AN
C  INSTRUCTION FILE FROM WHICH IVERIFY WILL BE READ. BUT IF IALLIN = 0,
C  SETTING IVERIFY = 1 HERE MEANS THAT, WHETHER THE USER ENTERS INFO
C  FROM A PREVIOUS IT2B RUN, FROM A PREVIOUS INSTRUCTION FILE FROM
C  AN NPAG111.FOR OR EARLIER PROGRAM, OR FROM THE KEYBOARD, HE WILL
C  BE ASKED IF HE WANTS TO SAVE THE INFO INTO AN INSTRUCTION FILE
C  AT THE END (THIS INSTRUCTION FILE WILL BE A NEW-STYLE ALL-INCLUSIVE
C  VERSION).

      IVERIFY = 1

C  AS OF NPAG112.FOR, THE FIRST QUESTION WILL BE WHETHER OR NOT THE
C  USER HAS AN ALL-INCLUSIVE INSTRUCTION FILE WHICH CONTAINS ALL THE
C  INFORMATION FOR THE RUN, INCLUDING VALUES THAT USED TO HAVE TO BE
C  ENTERED VIA THE KEYBOARD, EVEN WHEN AN INSTRUCTION FILE WAS USED.
C  THIS FILE MUST BE IN THE CURRENT DIRECTORY, WHICH MEANS THAT IN THIS
C  CASE, GETPATH WILL NOT BE CALLED BELOW.

 9880 WRITE(*,9876)
 9876 FORMAT(//' ENTER 1 IF YOU HAVE AN INSTRUCTION FILE IN THE '/
     1'         CURRENT DIRECTORY WHICH HAS ALL THE INSTRUCTIONS FOR'/
     2'         AN NPAG ANALYSIS (THIS FILE MUST HAVE "REM_BAK JUN_13"'/
     3'         OR A LATER DATE ON THE FIRST LINE). AND NOTE THAT IF'/
     4'         YOU USE THIS OPTION, AND THE ENTRY ON THE SECOND LINE'/
     5'         IS 0, THE PROGRAM WILL RUN WITH NO FURTHER USER INPUT.'/
     6'         BUT IF THE ENTRY ON THE 2ND LINE IS 1, YOU WILL HAVE'/
     7'         THE CHANCE TO EDIT YOUR INSTRUCTIONS BELOW.'//
     8' ENTER 0 OTHERWISE (THIS INCLUDES THE OPTION OF USING AN '/
     9'         OLDER INSTRUCTION FILE): ')
      READ(*,*,ERR=9880) IALLIN
      IF(IALLIN .NE. 1 .AND. IALLIN .NE. 0) GO TO 9880


	IF(IALLIN .EQ. 1) THEN


C  SINCE IALLIN = 1, IT MEANS THE CURRENT DIRECTORY IS THE WORKING 

C  DIRECTORY. SO SET PATH AND NOB AS THEY WOULD HAVE BEEN SET IN GETPATH
C  WHICH WILL NOT BE CALLED NOW.

       PATH = ' '
       NOB = 0


       WRITE(*,*)
       WRITE(*,*)' ENTER THE NAME OF THE INSTRUCTION FILE; '
       WRITE(*,*)' ENTER -99 TO SEE ALL OR A PART OF YOUR DIRECTORY: '
       READ(*,2) ALLINSTRUCT
       IF(ALLINSTRUCT(1:3) .EQ. '-99') 
     1  CALL SEEDIR(PATH,NOB,ALLINSTRUCT,OSName,ListDir)

C  CALL FULLNAME WHICH CONVERTS THE FILENAME TO PATHFILE, THE COMPLETE
C  NAME OF THE FILE, WHICH INCLUDES THE PATH (IF THE PATH IS NOT THE

C  CURRENT DIRECTORY).

     	 TMPFILE = ' '
       TMPFILE = ALLINSTRUCT
       CALL FULLNAME(PATH,TMPFILE,PATHFILE)
       OPEN(25,FILE=PATHFILE,ERR=9810,STATUS='OLD')
       GO TO 9820
 9810  WRITE(*,5316) PATHFILE
       GO TO 9880


 9820   CONTINUE


C  READ ALL INPUT DATA FROM FILE ALLINSTRUCT, WHICH WAS FILLED FROM A
C  PREVIOUS RUNNING OF THIS PROGRAM. 

C  THE 1ST LINE IN ALLINSTRUCT IS THE CODE WHICH
C  GIVES THE VERSION NO. OF THE PROGRAM. IF THE VERSION IS NOT CORRECT,
C  TELL THE USER AND HAVE HIM TRY AGAIN.

       READ(25,7123) CODE

C  CHECK FOR PREVIOUS VERSIONS. IF A PREVIOUS VERSION INPUT FILE IS
C  USED, PUT IN DEFAULT VALUES FOR UNINPUT INFO.
C  ALLOWABLE VERSIONS ARE:

C  NPAG119.FOR                'REM_BAK OCT_15'
C  NPAG112.FOR                'REM_BAK JUN_13'

C  IF A TOO-OLD VERSION IS USED, PRINT A MESSAGE TO USER, AND HAVE HIM
C  TRY AGAIN.

	 ICODE1 = 0
       IF(CODE .EQ. 'REM_BAK JUN_13') ICODE1 = 1
       IF(CODE .EQ. 'REM_BAK OCT_15') ICODE1 = 2

       IF(ICODE1 .EQ. 0) THEN
        WRITE(*,9821)
 9821   FORMAT(//' YOUR INSTRUCTION FILE IS NOT FROM THE ALLOWABLE '/
     1' SET OF INSTRUCTION FILES.'//
     2' FOR THIS OPTION, YOU MUST USE A FILE WITH REM_BAK XXX_XX IN '/
     3' COLUMNS 1 THROUGH 14 ON LINE 1, WHERE  XXX_XX  IS JUN_13 OR'/
     4' A MORE RECENT DATE.'//)
        GO TO 9880
       ENDIF

C  SKIP THIS LINE. IT CONTAINS 'IVERIFY: 1 --> YES; 0 --> NO'.
      READ(25,*) 
      READ(25,*) IVERIFY

C  IF IVERIFY = 1, THE USER WILL GET THE CHANCE TO MODIFY THESE 
C  INSTRUCTIONS AS THE PROGRAM WILL CALL SUBROUTINE VERIF1. AND IN
C  VERIF1, SUBROUTINE WRITEINFILE WILL BE CALLED TO WRITE THE 
C  INSTRUCTIONS TO PATHFILAST, WHICH WILL THEN BE COPIED BACK TO
C  WHATEVER INSTRUCTION FILE THE USER WANTS TO SAVE THE NEW 
C  INSTRUCTIONS TO (IF HE DESIRES). SO MUST ESTABLISH PATHFILAST
C  NOW. 

C  ALSO, IF IVERIFY = 1, THERE WILL BE CODE BELOW ABOUT SAVING 
C  INSTRUCTIONS TO A NEW INSTRUCTION FILE. THIS QUESTION COULD BE
C  ASKED TWICE IF IFIL = 0 OR INOPT1 = 1. SO SET IFIL = 1 AND
C  INOPT1 = 0 HERE.


C  NOTE THAT IF IVERIFY = 0, VERIF1 AND WRITEINFILE WILL NEVER
C  BE CALLED, AND THE QUESTION OF SAVING INFO TO ANOTHER INSTRUCTION
C  FILE WILL NOT COME UP, SO IT IS NOT NECESSARY TO ESTABLISH
C  THESE VALUES IN THIS CASE.

      IF(IVERIFY .EQ. 1) THEN

       FROMLAST = 'SAVEINST.TMP'
     	 TMPFILE = ' '
	 TMPFILE = FROMLAST
	 CALL FULLNAME(PATH,TMPFILE,PATHFILAST)
       IFIL = 1
       INOPT1 = 0
      ENDIF
  
C  SKIP THIS LINE. IT CONTAINS 'FORTRAN MODEL FILE'
      READ(25,*)
      READ(25,2) FORFILE

C  SKIP THIS LINE. IT CONTAINS 'NDIM'.
      READ(25,*) 
      READ(25,*) NDIM

C  SKIP THIS LINE. IT CONTAINS 'NP'.
      READ(25,*)
      READ(25,*) NP

C  SKIP THIS LINE. IT CONTAINS 'IRAN INDICES'.
      READ(25,*)
      READ(25,*) (IRAN(I),I=1,NP)

C  SKIP THIS LINE. IT CONTAINS 'NVAR'.
      READ(25,*)
      READ(25,*) NVAR

C  NVAR COULD BE > MAXDIM IF THE USER HAS MANUALLY EDITED THE
C  INSTRUCTION FILE. IF SO, WRITE MESSAGE TO THE USER AND STOP.

      IF(NVAR .GT. MAXDIM) THEN

	 WRITE(*,111) NVAR,MAXDIM
  111    FORMAT(//' YOUR INSTRUCTION FILE, SHOWS ',I2,' PARAMETERS TO'/
     1' BE RANDOM VARIABLES. THE LIMIT IS CURRENTLY ',I2,'. PLEASE'/

     2' RERUN THIS PROGRAM AFTER EDITING YOUR INSTRUCTION FILE AND'/
     3' MAKING THE CORRECTION. '//)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,111) NVAR,MAXDIM 
        CLOSE(42)

       CALL PAUSE
       STOP

      ENDIF

C  SKIP THIS LINE. IT CONTAINS 'PAR(I),I=1,NVAR'
      READ(25,*)

      DO I = 1,NVAR
       READ(25,1717) PAR(I)
      END DO

C  SKIP THIS LINE. IT CONTAINS 'AB ARRAY'
         READ(25,*)
     
      DO I=1,NVAR
       READ(25,*) (AB(I,J),J=1,2)
      END DO


C  SKIP THIS LINE. IT CONTAINS 'NOFIX'.
      READ(25,*)
      READ(25,*) NOFIX

      IF(NOFIX .GT. 20) THEN

       WRITE(*,112) NOFIX
  112  FORMAT(//' YOUR INSTRUCTION FILE SHOWS ',I2,' PARAMETERS TO BE'/
     1' FIXED PARAMETERS. THE LIMIT IS CURRENTLY 20. PLEASE RERUN'/
     2' THIS PROGRAM AFTER EDITING YOUR INSTRUCTION FILE AND MAKING'/
     3' THE CORRECTION. '//)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,112) NOFIX
        CLOSE(42)

       CALL PAUSE
       STOP

      ENDIF

     
C  SKIP THIS LINE. IT CONTAINS 'PARFIX(I),I=1,NOFIX, IF NOFIX > 0'.
      READ(25,*)

      IF(NOFIX .GT. 0) THEN
       DO I = 1,NOFIX
        READ(25,1717) PARFIX(I)
       END DO
      ENDIF

C  SKIP THIS LINE. IT CONTAINS 'VALFIX ARRAY IF NOFIX > 0'.
      READ(25,*)
      IF(NOFIX .GT. 0) READ(25,*) (VALFIX(I),I=1,NOFIX)



C  IF ICODE1 = 1, SET NRANFIX = 0.
      IF(ICODE1 .EQ. 1) NRANFIX = 0

      IF(ICODE1 .EQ. 2) THEN

C  SKIP THIS LINE. IT CONTAINS 'NRANFIX'.
       READ(25,*)
       READ(25,*) NRANFIX

      IF(NRANFIX .GT. 20) THEN

        WRITE(*,3112) NRANFIX
 3112  FORMAT(//' YOUR INSTRUCTION FILE SHOWS ',I2,' PARAMETERS TO BE'/
     1' RANFIX PARAMETERS. THE LIMIT IS CURRENTLY 20. PLEASE RERUN'/
     2' THIS PROGRAM AFTER EDITING YOUR INSTRUCTION FILE AND MAKING'/
     3' THE CORRECTION. '//)

         OPEN(42,FILE=ERRFIL)
          WRITE(42,3112) NRANFIX
         CLOSE(42)

        CALL PAUSE
        STOP

       ENDIF

C  SKIP THIS LINE. IT CONTAINS 'PARRANFIX(I),I=1,NOFIX, IF 
C  NRANFIX > 0'.
      READ(25,*)

      IF(NRANFIX .GT. 0) THEN
       DO I = 1,NRANFIX
        READ(25,1717) PARRANFIX(I)
       END DO
      ENDIF

C  SKIP THIS LINE. IT CONTAINS 'RANFIXEST ARRAY IF NRANFIX > 0'.
       READ(25,*)
       IF(NRANFIX .GT. 0) READ(25,*) (RANFIXEST(I),I=1,NRANFIX)


      ENDIF
C  ABOVE ENDIF IS FOR THE  IF(ICODE1 .EQ. 2)  CONDITION.

	IF(NVAR + NOFIX + NRANFIX .GT. 32) THEN

	 WRITE(*,113) NVAR + NOFIX + NRANFIX
  113    FORMAT(//' YOUR INSTRUCTION FILE SHOWS A TOTAL OF ',I2/
     1' PARAMETERS. THE LIMIT IS CURRENTLY 32. PLEASE RERUN THIS '/
     2' PROGRAM AFTER EDITING YOUR INSTRUCTION FILE (AND MODEL FILE IF'/
     3' NECESSARY) AND MAKING THE CORRECTION. '//)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,113) NVAR+NOFIX+NRANFIX 
        CLOSE(42)

       CALL PAUSE
       STOP

      ENDIF


C  SKIP THIS LINE. IT CONTAINS 'O.D.E. TOLERANCE'.
      READ(25,*)
      READ(25,*) TOLER

      RTOL = TOLER
      DO I = 1,NDIM
       ATOL(I) = TOLER
      END DO

C  MF IS HARDCODED TO BE 22.

      MF = 22


C  SKIP THIS LINE. IT CONTAINS 'IFORMT'.
         READ(25,*)
         READ(25,*) IFORMTT

C  IFORMTT MUST BE CHANGED TO BE THE SAME AS THE
C  OLD IFORMT AS FOLLOWS:
C  IFORMTT = 1 --> IFORMT = 3 --> PATIENT INFO IS INPUT VIA BLOCK FORMAT
C                                 (.CSV FILES);
C  IFORMTT = 2 --> IFORMT = 1 --> PATIENT INFO IS INPUT VIA WORKING COPY
C                                 FILES.

         IF(IFORMTT .EQ. 1) IFORMT = 3
         IF(IFORMTT .EQ. 2) IFORMT = 1
    
         IF(IFORMT .EQ. 2) THEN

          WRITE(*,1231)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,1231) 
        CLOSE(42)

          CALL PAUSE
          STOP
 
         ENDIF

         IF(IFORMT .EQ. 1) THEN

          IDIRCT = 0

C  SKIP THIS LINE. IT CONTAINS 'PREFIX'.
          READ(25,*)
          READ(25,2222) PREFIX

C  SKIP THIS LINE. IT CONTAINS 'EXT'.
          READ(25,*)
          READ(25,222) EXT

         ENDIF


         IF(IFORMT .EQ. 3) THEN

C  SKIP THIS LINE. IT CONTAINS 'BLOCKPAT', THE .CSV FILENAME.
          READ(25,*)
          READ(25,2) BLOCKPAT
          TMPFILE = ' '
          TMPFILE = BLOCKPAT
          CALL FULLNAME(PATH,TMPFILE,PATHFILE)
          OPEN(67,FILE=PATHFILE,STATUS='OLD')

          ICODE1PAT = 0
          READ(67,7126) CODEPAT

          IF(CODEPAT .EQ. '"POPDATA APR_11') ICODE1PAT = 1
          IF(CODEPAT(1:14) .EQ. 'POPDATA APR_11') ICODE1PAT = 1

          IF(CODEPAT .EQ. '"POPDATA DEC_11') ICODE1PAT = 1

          IF(CODEPAT(1:14) .EQ. 'POPDATA DEC_11') ICODE1PAT = 1

          IF(ICODE1PAT .EQ. 0) THEN

           WRITE(*,3131)
           WRITE(*,*)' THE PROGRAM STOPS.'
           CLOSE(67)

        OPEN(42,FILE=ERRFIL)


         WRITE(42,3131)
         WRITE(42,*)' THE PROGRAM STOPS.' 

        CLOSE(42)

           CALL PAUSE
           STOP

          ENDIF

          CLOSE(67)

C  SKIP THIS LINE. IT CONTAINS 'NCOVA', THE NO. OF COVARIATES.
          READ(25,*)
          READ(25,*) NCOVA
  
C  SKIP THIS LINE. IT CONTAINS 'COVNAME(I),I=1,NCOVA, IF NCOVA > 0'.
      READ(25,*)

      IF(NCOVA .GT. 0) THEN
       DO I = 1,NCOVA
        READ(25,1717) COVNAME(I)
       END DO
      ENDIF

C  SKIP THIS LINE. IT CONTAINS 'ICOVTYPE ARRAY IF NCOVA > 0'.
         READ(25,*)
         IF(NCOVA .GT. 0) READ(25,*) (ICOVTYPE(I),I=1,NCOVA)

         ENDIF
C  ABOVE ENDIF IS FOR THE  IF(IFORMT .EQ. 3)  CONDITION.


C  READ IN BOTH NSUBTOT AND NSUB AND THEN CALL
C  ROUTINE GETIPATF WHICH READS THIS PORTION OF FILE 25 TO OBTAIN
C  IPATVEC. NOTE THE 1ST ARGUMENT TELLS GETIPATF TO READ FILE 25.

C  NOTE THAT IF IERRR RETURNS AS -1, THERE IS A PROBLEM WITH THE
C  PATIENT NO. INFO IN THE FILE. IN THIS CASE, THE USER HAS ALREADY
C  BEEN INFORMED OF THE PROBLEM IN GETIPATF, SO JUST WRITE A MESSAGE
C  AND STOP.

C  SKIP THIS LINE. IT CONTAINS 'NSUBTOT'.
         READ(25,*)
         READ(25,*) NSUBTOT

C  SKIP THIS LINE. IT CONTAINS 'NSUB'.

         READ(25,*)
         READ(25,*) NSUB

C  SKIP THIS LINE. IT CONTAINS "ACTIVE PATIENT NUMBERS, FOLLOWED BY
C  A LINE WITH '0'"

         READ(25,*)       
         CALL GETIPATF(25,NSUBTOT,NSUB,MAXSUB,IPATVEC,IERRR)

        IF(IERRR .EQ. -1) THEN

          WRITE(*,2127)
 2127     FORMAT(/' ... OR EDIT THE INSTRUCTION FILE USED IN THIS'/
     1'     RUN, AND MAKE THE INDICATED CORRECTION.'/)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,2128)
 2128   FORMAT(//' THERE WAS AN ERROR IN THE READING OF PATIENT NOS.'/
     1' TO BE USED FOR THIS ANALYSIS. PLEASE ENTER DATA VIA THE '/
     2' KEYBOARD OR USING ANOTHER INSTRUCTION FILE.'/)
         WRITE(42,2127)
         CLOSE(42)

         CALL PAUSE
         STOP

        ENDIF


C  SKIP THIS LINE. IT CONTAINS 'NUMEQT'.
         READ(25,*)
         READ(25,*) NUMEQT

C  SKIP THIS LINE. IT CONTAINS 'NUMEQT LINES OF ASSAY COEFFICIENTS'.
         READ(25,*)

         DO IEQ=1,NUMEQT
          READ(25,*) C0P(IEQ),C1P(IEQ),C2P(IEQ),C3P(IEQ)
         END DO

C  SKIP THIS LINE. IT CONTAINS 'IERRMOD'.
         READ(25,*)
         READ(25,*) IERRMOD


C  SKIP THIS LINE. IT CONTAINS 'GAMLAM0
         READ(25,*)
         READ(25,*) GAMLAM0

C  SKIP THIS LINE. IT CONTAINS 'IASS(I),I=1,NUMEQT'.
         READ(25,*)
         READ(25,*) (IASS(I),I=1,NUMEQT)


C  NOTE THAT IF THE USER SELECTED IASS(IEQ) = 3 IN A PREVIOUS RUN, IT
C  MEANS THAT SOME OF HIS PATIENT DATA FILES PROBABLY HAD THEIR ASSAY
C  SD'S MULTIPLIED BY A CONSTANT (ASSMULT(IEQ)). IT IS UNLIKELY THE USER
C  WOULD WANT THESE DATA FILES TO BE FURTHER MUTLIPLIED BY THIS CONSTANT
C  SO DEFAULT ASSMULT(IEQ) = 1. ALSO, IALLPAT(IEQ) WILL BE DEFAULTED
C  TO 0.

         DO IEQ=1,NUMEQT
          ASSMULT(IEQ) = 1.D0
          IALLPAT(IEQ) = 0
         END DO

C  SKIP THIS LINE. IT CONTAINS 'NDRUG'.
         READ(25,*)
         READ(25,*) NDRUG

C  SKIP THIS LINE. IT CONTAINS 'AF(I),I=1,NDRUG'.
         READ(25,*)
         READ(25,*) (AF(I),I=1,NDRUG)
         IAF = 1

C  SKIP THIS LINE. IT CONTAINS 'INDPTS'.
         READ(25,*)
         READ(25,*) INDPTS

C  SKIP THIS LINE. IT CONTAINS 'MAXCYC'.
         READ(25,*)
         READ(25,*) MAXCYC

C  MAXCYC MUST BE .LE. 9997. IF NOT, RESET IT.

         IF(MAXCYC .GT. 9997) MAXCYC = 9997

C  AS OF NPBIG1, JSTOP = 1 AND 2 ARE ELIMINATED. IF THE USER IS USING
C  AN INPUT FILE WITH JSTOP = 1 OR 2, RESET JSTOP TO 3, AND SET TOLC
C  TO THE DEFAULT VALUE OF .01

C  SKIP THIS LINE. IT CONTAINS 'JSTOP'.
         READ(25,*)
         READ(25,*) JSTOP

C  SKIP THIS LINE. IT CONTAINS 'IF JSTOP .NE. 1, TOLC IS ON NEXT LINE'.
         READ(25,*)
         IF(JSTOP .NE. 1) READ(25,*) TOLC

         IF(JSTOP .EQ. 1 .OR. JSTOP .EQ. 2) THEN
          JSTOP = 3
          TOLC = .01D0
         ENDIF

         NINT=100

C  SKIP THIS LINE. IT CONTAINS 'IDELTA'.
         READ(25,*)
         READ(25,*) IDELTA

C  SKIP THIS LINE. IT CONTAINS 'XMIC'.
         READ(25,*)
         READ(25,*) XMIC

C SKIP THIS LINE. IT CONTAINS 'ICENT ...'.
         READ(25,*)
         READ(25,*) ICENT

C  SKIP THIS LINE. IT CONTAINS 'AUCINT'.
         READ(25,*)
	   READ(25,*) AUCINT

C  SKIP THIS LINE. IT CONTAINS 'INPRI'
         READ(25,*)
         READ(25,*) INPRI

C  SKIP THIS LINE. IT CONTAINS 'NAME OF APRIORI DENSITY FILE IF 
C  INPRI = 0'.
         READ(25,*)
         IF(INPRI .EQ. 0) READ(25,2) PRIFIL2

       CLOSE(25)


C  GO TO LABEL 1230 TO SKIP ALL THE CODE WHICH ENTERS INFO VIA 
C  A FILE FROM AN IT2B RUN; A PREVIOUS INSTRUCTION FILE, WHICH WAS
C  NOT ALL-INCLUSIVE (I.E., WITH A DATE OF AUG_96 TO JAN_13 ON LINE 1);
C  OR THE KEYBOARD.

       GO TO 1230

      ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(IALLIN .EQ. 1)  CONDITION.
    

C  TO GET HERE MEANS THE USER IS NOT USING THE NEW-STYLE ALL-INCLUSIVE
C  INSTRUCTION FILE. 

C  CALL GETPATH TO GET FROM THE USER THE PATH WHERE THE INPUT FILES ARE
C  LOCATED (AND WHERE THE OUTPUT FILES WILL GO). NOTE THAT PATH IS THE
C  PATH WITH A TRAILING BACKSLASH, AND NOB IS THE NO. OF THE ENTRY WITH
C  THE LAST NON-BLANK ENTRY.

     	CALL GETPATH(PATH,NOB, OSName)

C  IF THE USER HAS ALREADY RUN IT2B, THE INPUT DATA MAY
C  COME FROM 'FROMxxxx', WHERE xxxx WAS THE 4-DIGIT JOB NUMBER FOR
C  THE it2b RUN ON THE MAINFRAME.

C  OTHERWISE, THE INPUT DATA WILL COME FROM AN INPUT FILE (MADE BY A
C  PREVIOUS RUNNING OF THIS PROGRAM) OR KEYBOARD ENTRY.

 6280   WRITE(*,6278)
 6278   FORMAT(//' ENTER 1 TO DO AN ANALYSIS; '/
     2' ENTER 2 TO EXAMINE THE RESULTS FROM A PREVIOUS RUN: ')
	READ(*,*,ERR=6280) IANAL
	IF(IANAL .NE. 1 .AND. IANAL .NE. 2) GO TO 6280

C  IF IANAL .EQ. 2, CALL SUBROUTINE PREVRUN TO INPUT PRIOR DENSITY
C  FILE AND OUTPUT FILE FROM A PREVIOUS RUN, AND ALLOW ALL 7 OPTIONS
C  INDICATED BELOW LABEL 7185 FOR THAT RUN. NOTE THAT CORDEN,CORHOLD,
C  WORK, AND IJUNK ARE DUMMY ARGUMENTS AT THIS POINT

        IF(IANAL .EQ. 2) THEN

         CALL PREVRUN(PATH,NOB,MAXSUB,MAXDIM,MAXGRD,CORDEN,CORHOLD,WORK,
     1    IJUNK,PYJGX,PYJGXX,EXX,YPREDPOP,YPREDPOPT,YPREDBAY,
     2    SERNUM,MAXOBDIM,YO,IPATVEC,OSName,ClearScreen,ListDir,
     3    MAXNUMEQ)


         STOP

        ENDIF


C  EVERYTHING BELOW IS THE IANAL = 1 OPTION.

        WRITE(*,919)

  919   FORMAT(//' ***************** VERY IMPORTANT *****************'//

     1' YOUR FORTRAN MODEL FILE MUST BE AN EDITED VERSION OF TSTMULTN.FO
     2R.'//
     3' IF THIS IS NOT SO, PLEASE STOP THE PROGRAM NOW. THEN CREATE '/
     4' YOUR MODEL FILE BY EDITING TSTMULTN.FOR AND PLACING YOUR CODE'/
     5' AS INSTRUCTED BY THE COMMENTS IN THAT FILE. AT THAT POINT, YOU'/
     6' WILL BE READY TO RERUN THIS PROGRAM.'//
     7' ***************** VERY IMPORTANT *****************'//)

        CALL PAUSE

C  INPUT THE NAME OF THE FORTRAN FILE CREATED BY THE RUNNING OF THE

C  BOXES PROGRAM (WHICH IDENTIFIES THE MODEL AND THE PARAMETERS FOR THE
C  USER'S ANALYSIS. THEN CALL SUBROUTINE USERPREP TO INPUT VALUES FROM
C  THIS FILE.

        WRITE(*,5001)
 5001   FORMAT(/' ENTER THE NAME OF YOUR FORTRAN MODEL FILE: ')
     	  READ(*,2) FORFILE


C  CALL FULLNAME WHICH CONVERTS THE FILENAME TO PATHFILE, THE COMPLETE
C  NAME OF THE FILE, WHICH INCLUDES THE PATH (IF THE PATH IS NOT THE
C  CURRENT DIRECTORY).

 5010	TMPFILE = ' '
      TMPFILE = FORFILE
      CALL FULLNAME(PATH,TMPFILE,PATHFILE)
      OPEN(28,FILE=PATHFILE,ERR=50,STATUS='OLD',POSITION='APPEND')
      GO TO 30
   50   WRITE(*,4406) FORFILE
 4406    FORMAT(//' THE FOLLOWING FILE DOES NOT EXIST ... '/
     1'    ',A73/
     2' ENTER THE CORRECT FILENAME OR ... '/
     2' ENTER -99 TO SEE ALL OR A PART OF YOUR DIRECTORY: ')
	READ(*,2) FORFILE
	IF(FORFILE(1:3) .EQ. '-99') THEN
           CALL SEEDIR(PATH,NOB,FORFILE,OSName,ListDir)
	ENDIF
      GO TO 5010

   30	CALL USERPREP(NDIM,NP,NVAR,MAXDIM,PAR,NOFIX,PARFIX,NRANFIX,
     1 PARRANFIX,IRAN)

	CLOSE(28)

C  THE ABOVE CALL OBTAINS THE FOLLOWING VALUES:

C  NDIM = NO. OF STATES FOR THE O.D.E.



C  NP = TOTAL NO. OF PARAMETERS = NVAR + NOFIX + NRANFIX.
C  NVAR = NO. OF R.V.'S (1 .LE. NVAR .LE. MAXDIM).


C  PAR(I),I=1,NVAR = NAMES OF THE RANDOM VARIABLES FOR THIS RUN.
C  NOFIX = NO. OF FIXED AND KNOWN PARAMETERS WHOSE FIXED VALUES ARE
C          TO BE SET BY THE USER.
C  PARFIX(I),I=1,NOFIX = NAMES OF THE FIXED PARAMETERS FOR THIS RUN.
C  NRANFIX = NO. OF PARAMETERS WHICH ARE THE SAME FOR ALL SUBJECTS,
C          BUT UNKNOWN (AND ARE TO BE ESTIMATED).
C  PARRANFIX(I),I=1,NRANFIX = NAMES OF THE RANFIX PARAMETERS FOR THIS 
C          RUN.
C  IRAN(I) = 1 IF PARAMATER I IS RANDOM;
C            0 IF PARAMETER I IS FIXED AND KNOWN;
C            2 IF PARAMETER I FIXED AND UNKNOWN (TO BE ESTIMATED);
C            I = 1,NVAR+NOFIX+NRANFIX.



C  CALL SUBROUTINE DETECT WHICH MAKES SURE THAT THE USER'S FORTRAN FILE
C  IS THE CORRECT VERSION FOR THE LOCATION WHERE IT IS TO BE RUN.

C  NO! AS OF NPBG15E5.FOR, DETECT IS NO LONGER CALLED. THE REASON IS
C  THAT IT WILL NOW BE ASSUMED THAT THE USER CREATES HIS MODEL FILE 
C  FROM THE TEMPLATE MODEL FILE (CURRENTLY TSTMULTH.FOR) AND SO IT 
C  WILL AUTOMATICALLY HAVE THE CORRECT DECLARATION STATEMENTS AT THE
C  TOP OF EACH SUBROUTINE. PLUS, THIS WILL PREVENT THIS PROGRAM FROM

C  STRIPPING AWAY SPECIAL DECLARATION STATEMENTS THE USER MAY NEED TO
C  ADD TO THE ROUTINES FOR SPECIAL CASE ANALYSES.

C	CALL DETECT(NOB,PATH,FORFILE,IVERS,CopyFile,
C     1     DeleteFile,ClearScreen)


C  READ IN VALUES FOR MF, RTOL, AND ATOL, WHICH ARE NEEDED FOR THE
C  O.D.E. SOLVER USED BY ROUTINE USERANAL (IN MODULE IDUSER__.FOR).

C MF     = Method flag.  Standard values are..
C          10 for nonstiff (Adams) method, no Jacobian used.
C          21 for stiff (BDF) method, user-supplied full Jacobian.
C          22 for stiff method, internally generated full Jacobian.

C	   FOR NOW MF = 22 WILL BE HARDCODED (SINCE THERE IS NO
C	   JACOBIAN SUBROUTINE (JACOB HAS BEEN TAKEN OUT FOR NOW).

C          24 for stiff method, user-supplied banded Jacobian.
C          25 for stiff method, internally generated banded Jacobian.
C RTOL   = Relative tolerance parameter (scalar).

C ATOL   = Absolute tolerance parameter.
C          The estimated local error in X(i) will be controlled so as
C          to be roughly less (in magnitude) than
C             EWT(i) = RTOL*abs(X(i)) + ATOL(i)  SINCE ITOL = 2.

C          Thus the local error test passes if, in each component,
C          either the absolute error is less than ATOL (or ATOL(i)),
C          or the relative error is less than RTOL.
C          Use RTOL = 0.0 for pure absolute error control, and
C          use ATOL = 0.0 (or ATOL(i) = 0.0) for pure relative error
C          control.  Caution.. Actual (global) errors may exceed these
C          local tolerances, so choose them conservatively.


  915   WRITE(*,913)
  913   FORMAT(/' ENTER 1 TO SET ALL TOLERANCES (FOR THE O.D.E. '/
     1'         SOLVER) TO THE DEFAULT VALUE ... 1.D-4.'/
     2' ENTER 0 TO SELECT A DIFFERENT VALUE FOR THE TOLERANCES: ')
	READ(*,*,ERR=915) ITOL
	IF(ITOL .NE. 0 .AND. ITOL .NE. 1) GO TO 915

	TOLER=1.D-4


	IF(ITOL .EQ. 0) THEN

  910	WRITE(*,914)
  914  FORMAT(/' ENTER A POSITIVE VALUE FOR THE TOLERANCE PARAMETERS: ')
	READ(*,*,ERR=910) TOLER

	IF(TOLER .LE. 0.D0) GO TO 910

	ENDIF

	RTOL = TOLER
	DO I=1,NDIM
	 ATOL(I) = TOLER
	END DO

C 930	WRITE(*,917)
C 917   FORMAT(/' ENTER 10 IF THE PROBLEM IS NON-STIFF (NO JACOBIAN'/
C    1' 	WILL BE NEEDED;'/
C    2' ENTER 21 FOR A STIFF PROBLEM, IN WHICH YOU WILL SUPPLY'/
C    3'		THE FULL JACOBIAN IN SUBROUTINE JACOB (IN MODULE'/
C    4'		USER.FOR;'/
C    5' ENTER 22 FOR A STIFF PROBLEM, IN WHICH YOU WANT THE PROGRAM'/
C    6'		TO CALCULATE THE JACOBIAN INTERNALLY: ')
C	READ(*,*,ERR=930) MF
C	IF(MF .NE. 10 .AND. MF .NE. 21 .AND. MF .NE. 22) GO TO 930

	MF = 22



C#######################################################################
C#######################################################################

C-----------------------------------------------------------------------

 4076   FORMAT(/' SEE ABOVE; PLEASE ENTER A POSITIVE INTEGER: ')
 4035     FORMAT(/' SEE ABOVE; PLEASE ENTER 0 OR 1: ')
  138   FORMAT(/' PLEASE ENTER ONE OF THE REQUESTED VALUES: ')
    2 FORMAT(A20)
  222 FORMAT(A3)
 2222 FORMAT(A5)

	WRITE(*,4362)
 4362   FORMAT(/' BEFORE YOU ENTER INPUT INSTRUCTIONS BELOW, YOU MUST'/
     1' NOW SPECIFY A FILE TO SAVE THESE INSTRUCTIONS AS THEY ARE '/
     2' BEING ENTERED (IF YOU USE KEYBOARD ENTRY), OR AS THEY ARE'/
     3' BEING READ BACK TO YOU (REGARDLESS OF HOW YOU ENTER THE DATA).'/
     4/
     5' IF YOU INTEND TO USE AN INSTRUCTION FILE TO ENTER DATA, BE '/
     6' SURE NOT TO GIVE THIS CURRENT FILE THE SAME NAME AS YOUR'/
     7' INSTRUCTION FILE.'//)

C  OPEN A FILE TO SAVE INFO AS THE USER ENTERS IT. THEN, IF THE PROGRAM
C  SHOULD BOMB BEFORE THE USER FINISHES ENTERING ALL HIS INFO, AT LEAST
C  THE INFO HE SUCCESSFULLY ENTERED WILL BE SAVED FOR THE NEXT RUN.


 4360   WRITE(*,4361)
 4361   FORMAT(//' ALL THE USER-INPUT INFORMATION WILL BE SAVED TO'/
     1' A FILE AS IT IS ENTERED. BY DEFAULT THIS FILE WILL BE CALLED'/
     2' SAVEINST.TMP. '//
     3' ENTER 1 TO USE THIS DEFAULT FILENAME; '/
     4' ENTER 0 TO SAVE INPUT INFO TO A DIFFERENT FILE: ')
	READ(*,*,ERR=4360) ISAVE
	IF(ISAVE .NE. 0 .AND. ISAVE .NE. 1) GO TO 4360

	IF(ISAVE .EQ. 1) FROMLAST = 'SAVEINST.TMP'

	IF(ISAVE .EQ. 0) THEN

 4365   WRITE(*,*)' ENTER THE DESIRED FILENAME: '
	READ(*,2) FROMLAST

	ENDIF

C  CALL FULLNAME WHICH CONVERTS THE FILENAME TO PATHFILE, THE COMPLETE
C  NAME OF THE FILE, WHICH INCLUDES THE PATH (IF THE PATH IS NOT THE
C  CURRENT DIRECTORY).


     	TMPFILE = ' '

	TMPFILE = FROMLAST

	CALL FULLNAME(PATH,TMPFILE,PATHFILAST)
	OPEN(29,FILE=PATHFILAST,ERR=4375,STATUS='NEW')
	GO TO 4380
 4375   WRITE(*,9826) PATHFILAST
 9826   FORMAT(/' THE FOLLOWING FILE ALREADY EXISTS ....'/
     1'    ',A73/
     1' ENTER 0 TO ENTER A NEW FILENAME;'/
     2' ENTER 1 TO OVERWRITE THIS FILE: ')

	READ(*,*,ERR=4375) IFILE
	IF(IFILE .NE. 0 .AND. IFILE .NE. 1) GO TO 4375
	IF(IFILE .EQ. 0) GO TO 4360
	IF(IFILE .EQ. 1) OPEN(29,FILE=PATHFILAST)
 4380   CLOSE(29)


 6310 WRITE(*,38)
   38 FORMAT(//' ENTER 1 TO ENTER INSTRUCTIONS FROM THE OUTPUT OF AN'/
     1'         IT2B RUN;'/
     2' ENTER 0 TO ENTER INSTRUCTIONS WITHOUT FIRST RUNNING IT2B: ')
      READ(*,*,ERR=6310) INOPT1
      IF(INOPT1 .NE. 1 .AND. INOPT1 .NE. 0) GO TO 6310


      IF(INOPT1 .EQ. 1) THEN


 6340	WRITE(*,6341)
 6341   FORMAT(//' ENTER THE NAME OF THE FILE CREATED BY AN IT2B RUN'/
     2' WHICH CONTAINS INPUT INSTRUCTIONS FOR THIS PROGRAM.'/
     4' IT WILL BE OF THE FORM  FROMxxxx, WHERE xxxx WAS THE JOB'/
     5' NUMBER ASSIGNED TO THE RUN.'//)

      WRITE(*,*)' ENTER -99 TO SEE ALL OR A PART OF YOUR DIRECTORY: '
      READ(*,2) FROMFIL
      IF(FROMFIL(1:3) .EQ. '-99') THEN
       CALL SEEDIR(PATH,NOB,FROMFIL,OSName,ListDir)
      ENDIF

C  CALL FULLNAME WHICH CONVERTS THE FILENAME TO PATHFILE, THE COMPLETE
C  NAME OF THE FILE, WHICH INCLUDES THE PATH (IF THE PATH IS NOT THE
C  CURRENT DIRECTORY).

     	TMPFILE = ' '

	TMPFILE = FROMFIL
	CALL FULLNAME(PATH,TMPFILE,PATHFILE)
        OPEN(23,FILE=PATHFILE,ERR=5315,STATUS='OLD')
	GO TO 6350
 5315   WRITE(*,5316) PATHFILE
 5316   FORMAT(//' THE FOLLOWING FILE DOES NOT EXIST ... '/
     1'    ',A73)
	GO TO 6310

C  IF THE 1ST (AND ONLY) ENTRY = -1, THE IT2B TERMINATED
C  ABNORMALLY (IT EITHER BOMBED OR WAS DELIBERATELY HALTED DUE TO A
C  COVARIANCE MATRIX NOT BEING POSITIVE DEFINITE, ETC). IN THIS CASE,
C  RETURN TO LABEL 6310.

 6350	READ(23,*,ERR=6360) IFORMT

	IF(IFORMT .EQ. -1) THEN
	 WRITE(*,6352)
 6352  FORMAT(//' THIS FILE IS FROM AN IT2B RUN WHICH'/
     1' TERMINATED ABNORMALLY. IT CANNOT BE USED AS INPUT TO THIS'/
     2' PROGRAM.')
	 GO TO 6310
	ENDIF

	GO TO 6370

 6360   WRITE(*,6353) FROMFIL
 6353   FORMAT(//' FILE ',A20,' IS NOT A FILE CREATED BY AN '/
     1' IT2B RUN TO BE USED AS INPUT TO THIS PROGRAM.'//
     2' SUCH A FILE MUST HAVE THE NUMBER, 1, ON LINE 1.'/)
	GO TO 6310

C  CHECK FOR PREVIOUS VERSIONS. IF A PREVIOUS VERSION INPUT FILE IS
C  USED, PUT IN DEFAULT VALUES FOR UNINPUT INFO.
C  ALLOWABLE VERSIONS ARE:


C  M2_14.FOR			'REM_FRN OCT_97'
C  M2_18.FOR			'REM_FRN JUN_98'
C  NPBIG1.FOR			'REM_FRN OCT_99'
C  NPBIG10F.FOR			'REM_FRN FEB_04'
C  NPAG102.FOR                'REM_FRN JUL_11'
C  NPAG120.FOR                'REM_FRN MAR_16'

    3 FORMAT(A1000)
 6370 READ(23,3) READLINE
	ICODE = -1
	IF(READLINE(1:14) .EQ. 'REM_FRN OCT_97') ICODE=14
	IF(READLINE(1:14) .EQ. 'REM_FRN JUN_98') ICODE=18
	IF(READLINE(1:14) .EQ. 'REM_FRN OCT_99') ICODE=101
	IF(READLINE(1:14) .EQ. 'REM_FRN FEB_04') ICODE=102
	IF(READLINE(1:14) .EQ. 'REM_FRN JUL_11') ICODE=103
	IF(READLINE(1:14) .EQ. 'REM_FRN MAR_16') ICODE=104

      IF(ICODE .EQ. -1) THEN
       WRITE(*,5311) FROMFIL
 5311  FORMAT(//' FILE ',A20,' IS NOT A FILE CREATED BY AN '/
     1' IT2B RUN TO BE USED AS INPUT TO THIS PROGRAM.'//
     2' SUCH A FILE MUST HAVE "REM_FRN OCT_97", OR A MORE RECENT DATE'/
     3' ON LINE 2, STARTING AT COLUMN 1.'/)
       GO TO 6310
      ENDIF


C  NRANFIX WAS OBTAINED BY SUBROUTINE USERPREP ABOVE. IF THE USER
C  SPECIFIED NRANFIX > 0, THEN INSTRUCTIONS CAN ONLY COME FROM A
C  FROMFIL MADE BY THE IT2B PROGRAM IF ICODE .GE. 104 (I.E., 
C  "REM_FRN MAR_16 WAS THE CODE FOR THE FIRST IT2B PROGRAM, 
C  it2branfix1.f, WHICH ALLOWED RANFIX PARAMETERS).

      IF(NRANFIX .GT. 0 .AND. ICODE .LT. 104) THEN
       WRITE(*,9197) FROMFIL
 9197  FORMAT(//' BECAUSE YOU SELECTED SOME PARAMETERS TO BE RANFIX,'/
     1' YOU MAY NOT USE ',A20,' AS AN INSTRUCTION FILE, SINCE THAT'/
     2' FILE CAME FROM AN IT2B RUN WHICH DID NOT ALLOW RANFIX '/
     3' PARAMETERS. '/)
       CALL PAUSE
       GO TO 6310
      ENDIF 



C  IF ICODE .LE. 102:
C  NOTE THAT THE IT2B PROGRAM JUST WRITES THE PREFIX AND
C  THE EXTENSION OF THE WORKING COPY FILES (I.E., IF, IN IT2B,
C  THE INPUT DATA FILES WERE IN ORIGINAL USC*PACK FORMAT, THEY ARE
C  SUBSEQUENTLY CONVERTED TO WORKING COPY TYPE FILES, AND THE NAMES OF
C  THOSE FILES ARE WRITTEN) INTO FROMxxxx.

C  IF ICODE .GE. 103:
C  PREFIX AND EXT ARE NOT WRITTEN; JUST BLOCKPAT, THE NAME OF THE .CSV
C  FILE WITH PATIENT INFO IS WRITTEN.


        IF(ICODE .LE. 102) THEN
         READ(23,2222) PREFIX
         READ(23,222) EXT
        ENDIF


        IF(ICODE .GE. 103) THEN
         READ(23,2) BLOCKPAT

C  NOTE THAT FOR ICODE .GE. 103, INFO WILL ALWAYS COME IN VIA
C  BLOCKPAT. SO IFORMT WHICH IS HARDCODED TO BE 1 IN FROMxxxx MUST BE
C  CHANGE TO BE 3 (WHICH INDICATES PATIENT INFO COMES IN VIA BLOCKPAT.

         IFORMT = 3

        ENDIF


	IF(ICODE .LE. 101) THEN
	 READ(23,*) NSUB
	 NSUBTOT = NSUB
	 DO I=1,NSUB
	  IPATVEC(I) = I
	 END DO
	ENDIF

C  NOTE THAT FOR ICODE .LE. 101, ALL SUBJECTS ARE ASSUMED TO BE USED
C  IN THE ANALYSIS, SO IPATVEC IS FILLED WITH ALL THE INDICES FROM
C  1 TO NSUB.


C  IF ICODE .GE. 102, READ IN BOTH NSUBTOT AND NSUB AND THEN CALL
C  ROUTINE GETIPATF WHICH READS THIS PORTION OF FILE 23 TO OBTAIN
C  IPATVEC. NOTE THE 1ST ARGUMENT TELLS GETIPATF TO READ FILE 23.

C  NOTE THAT IF IERRR RETURNS AS -1, THERE IS A PROBLEM WITH THE
C  PATIENT NO. INFO ON THE FILE. IN THIS CASE, THE USER HAS ALREADY
C  BEEN INFORMED OF THE PROBLEM IN GETIPATF, SO JUST TRANSFER
C  CONTROL TO LABEL 6310 ABOVE.


	IF(ICODE .GE. 102) THEN
	 READ(23,*) NSUBTOT
	 READ(23,*) NSUB

	 CALL GETIPATF(23,NSUBTOT,NSUB,MAXSUB,IPATVEC,IERRR)
	 IF(IERRR .EQ. -1) GO TO 6310
	ENDIF

      IF(NOFIX .GT. 0) READ(23,*) (VALFIX(I),I=1,NOFIX)
      IF(NRANFIX .GT. 0) READ(23,*) (RANFIXEST(I),I=1,NRANFIX)

	DO I=1,NVAR
         READ(23,*) (AB(I,J),J=1,2)
	END DO

	IF(ICODE .EQ. 14) NUMEQT=1
	IF(ICODE .GT. 14) READ(23,*) NUMEQT

	 DO IEQ=1,NUMEQT
	  IF(ICODE .LT. 101) ASSMULT(IEQ) = 1.D0
	  IF(ICODE .GE. 101) READ(23,*) ASSMULT(IEQ)
	  READ(23,*) C0P(IEQ),C1P(IEQ),C2P(IEQ),C3P(IEQ)
	 END DO

C  AS OF NPBIG13.FOR, THE ASSAY S.D. CAN BE ESTIMATED IN TERMS OF THE
C  PARAMETER GAMMA (SEE CODE DURING KEYBOARD ENTRY). FOR INFO COMING
C  FROM A PREVIOUS IT2B RUN, DEFAULT TO THE IERRMOD = 1 OPTION.

	IERRMOD = 1


C DEFAULT IASS(I), I=1,NUMEQT = 3 AND IALLPAT(I),I=1,NUMEQT = 0, SO
C DEFAULT IS TO USE THE UPDATED C'S (MULTIPLIED BY THE MULTIPLIER
C ESTIMATE FROM IT2B) FOR ANY PATIENT THE USER CHOOSES (THE USER CAN
C CHANGE IALLPAT(I) = 1 IN PUTASS TO AUTOMATICALLY MULTIPLY THE C'S OF
C SUBSEQUENT PATIENTS AFTER ANY PATIENT).

	DO IEQ=1,NUMEQT
	 IASS(IEQ) = 3
	 IALLPAT(IEQ) = 0
	END DO


        IF(ICODE .LE. 102) READ(23,*) AFSCALAR
        IAF = 0

C  NOTE THAT AF(I), I=1,NDRUG, WILL BE SET = AFSCALAR JUST ABOVE THE
C  CALL TO VERIF1 BELOW.

        IF(ICODE .GE. 103) THEN
         READ(23,*) NDRUG
         READ(23,*) (AF(I),I=1,NDRUG)
         IAF = 1
        ENDIF

	CLOSE(23)

C  ALL OTHER INFO, ENTERED VIA KEYBOARD, WILL NOW BE AUTOMATICALLY

C  HARDCODED TO DEFAULT VALUES THEN THE USER MAY CHANGE THESE VALUES
C  WHEN SUBROUTINE VERIF1 IS CALLED.


	INDPTS=6
	MAXCYC=9997
	JSTOP=3
	TOLC = .01D0


	NINT=100
	IDELTA=12
	XMIC=1.D0
	ICENT=2
	AUCINT = 24.D0

	ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(INOPT1 .EQ. 1)  OPTION.


 6315 IF(INOPT1 .EQ. 0) THEN

C  IF NRANFIX > 0, THE USER MUST ENTER INSTRUCTIONS VIA THE KEYBOARD
C  SINCE NO INST. FILE FROM AN NPAG PROGRAM UP TO NPAG111.FOR
C  ALLOWED RANFIX PARAMETERS (THE FIRST VERSION TO DO WAS WAS
C  NPAG119.FOR). 

      IF(NRANFIX .GT. 0) THEN
       IFIL = 0
       GO TO 9700
      ENDIF   

 6320   WRITE(*,6311)
 6311   FORMAT(//' ENTER 0 TO ENTER INSTRUCTIONS FROM THE KEYBOARD;'/
     1' ENTER 1 TO ENTER INSTRUCTIONS FROM A FILE CREATED BY A '/
     2'         PREVIOUS RUNNING OF THIS PROGRAM (UP THROUGH VERSION'/
     3'         NPAG111.FOR); THIS FILE MUST HAVE A DATE ON LINE 1'/
     4'         WHICH IS BETWEEN AUG_96 AND JAN_13: ')


	READ(*,*,ERR=6320) IFIL
	IF(IFIL .NE. 0 .AND. IFIL .NE. 1) GO TO 6320

	IF(IFIL .EQ. 1) THEN

	WRITE(*,*)
	WRITE(*,*)' ENTER THE NAME OF THE INSTRUCTION FILE; '
	WRITE(*,*)' ENTER -99 TO SEE ALL OR A PART OF YOUR DIRECTORY: '
      READ(*,2) FROMLAST
	IF(FROMLAST(1:3) .EQ. '-99') THEN
           CALL SEEDIR(PATH,NOB,FROMLAST,OSName,ListDir)
        ENDIF
C  CALL FULLNAME WHICH CONVERTS THE FILENAME TO PATHFILE, THE COMPLETE
C  NAME OF THE FILE, WHICH INCLUDES THE PATH (IF THE PATH IS NOT THE
C  CURRENT DIRECTORY).

     	TMPFILE = ' '
	TMPFILE = FROMLAST
	CALL FULLNAME(PATH,TMPFILE,PATHFILE)
	OPEN(25,FILE=PATHFILE,ERR=6330,STATUS='OLD')
	GO TO 6335
 6330   WRITE(*,5316) PATHFILE
	GO TO 6320

 6335   CONTINUE


C  READ ALL INPUT DATA FROM FILE FROMLAST, WHICH WAS FILLED FROM A
C  PREVIOUS RUNNING OF THIS PROGRAM.

C  THE 1ST LINE IN FROMLAST IS THE CODE WHICH
C  GIVES THE VERSION NO. OF THE PROGRAM. IF THE VERSION IS NOT CORRECT,
C  TELL THE USER AND HAVE HIM TRY AGAIN.

	 READ(25,7123) CODE
 7123    FORMAT(A14)

C  CHECK FOR PREVIOUS VERSIONS. IF A PREVIOUS VERSION INPUT FILE IS
C  USED, PUT IN DEFAULT VALUES FOR UNINPUT INFO.
C  ALLOWABLE VERSIONS ARE:

C  M2_5.FOR		            'VER_BAK AUG_96'
C  M2_6.FOR			      'REM_BAK JAN_97'
C  M2_8.FOR			      'REM_BAK JUN_97'
C  M2_10.FOR			'REM_BAK JUL_97'
C  M2_17.FOR			'REM_BAK APR_98'
C  M2_18.FOR			'REM_BAK JUN_98'
C  NPBIG13.FOR			'REM_BAK AUG_02'
C  NPBIG15.FOR			'REM_BAK FEB_08'
C  NPBIG15A.FOR			'REM_BAK MAY_09'
C  NPBG15E8.FOR               'REM_BAK MAR_11'
C  NPAG100.FOR                'REM_BAK APR_11'
C  NPAG102.FOR                'REM_BAK JUL_11'
C  NPAG111.FOR                'REM_BAK JAN_13'

C  IF A TOO-OLD VERSION IS USED, PRINT A MESSAGE TO USER, AND HAVE HIM
C  TRY AGAIN.

	ICODE = 0
      IF(CODE .EQ. 'REM_BAK JAN_13') ICODE = 28
      IF(CODE .EQ. 'REM_BAK JUL_11') ICODE = 27
      IF(CODE .EQ. 'REM_BAK APR_11') ICODE = 26	
      IF(CODE .EQ. 'REM_BAK MAR_11') ICODE = 25
	IF(CODE .EQ. 'REM_BAK MAY_09') ICODE = 24
	IF(CODE .EQ. 'REM_BAK FEB_08') ICODE = 23
	IF(CODE .EQ. 'REM_BAK AUG_02') ICODE = 22
	IF(CODE .EQ. 'REM_BAK JUN_98') ICODE = 18
	IF(CODE .EQ. 'REM_BAK APR_98') ICODE = 17
	IF(CODE .EQ. 'REM_BAK JUL_97') ICODE = 10
	IF(CODE .EQ. 'REM_BAK JUN_97') ICODE = 8
	IF(CODE .EQ. 'REM_BAK JAN_97') ICODE = 6
	IF(CODE .EQ. 'VER_BAK AUG_96') ICODE = 5

	IF(ICODE .EQ. 0) THEN
	 WRITE(*,7321)
 7321    FORMAT(//' YOUR INSTRUCTION FILE IS NOT FROM THE ALLOWABLE '/
     1' SET OF INSTRUCTION FILES.'//
     2' EITHER ENTER INSTRUCTIONS FROM THE KEYBOARD, OR USE A FILE '/
     3' WITH   REM_BAK XXX_XX   IN COLUMNS 1 THROUGH 14 ON LINE 1,'/
     4' WHERE  XXX_XX  IS AUG_96 UP TO JAN_13.'//)
	  GO TO 6320
	ENDIF



C  READ AN INSTRUCTION FILE WITH ICODE .GE. 25 SEPARATELY, SINCE THE 
C  CHANGES ARE SO EXTENSIVE.
  
        IF(ICODE .GE. 25) THEN


C  SKIP THIS LINE. IT CONTAINS 'IFORMT'.
         READ(25,*)
         READ(25,*) IFORMTT

C  IF ICODE .GE. 26, IFORMTT MUST BE CHANGED TO BE THE SAME AS THE
C  OLD IFORMT AS FOLLOWS:
C  IFORMTT = 1 --> IFORMT = 3 --> PATIENT INFO IS INPUT VIA BLOCK FORMAT
C                                 (.CSV FILES);
C  IFORMTT = 2 --> IFORMT = 1 --> PATIENT INFO IS INPUT VIA WORKING COPY
C                                 FILES.

        IF(ICODE .GE. 26) THEN
         IF(IFORMTT .EQ. 1) IFORMT = 3
         IF(IFORMTT .EQ. 2) IFORMT = 1
        ENDIF



        IF(ICODE .EQ. 25) IFORMT = IFORMTT
    
         IF(IFORMT .EQ. 2) THEN

          WRITE(*,1231)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,1231) 

        CLOSE(42)

          CALL PAUSE
          STOP

         ENDIF


         IF(IFORMT .EQ. 1) THEN

          IDIRCT = 0


C  SKIP THIS LINE. IT CONTAINS 'PREFIX'.
          READ(25,*)
          READ(25,2222) PREFIX

C  SKIP THIS LINE. IT CONTAINS 'EXT'.
          READ(25,*)
          READ(25,222) EXT

         ENDIF


         IF(IFORMT .EQ. 3) THEN

C  SKIP THIS LINE. IT CONTAINS 'BLOCKPAT', THE .CSV FILENAME.
          READ(25,*)

          READ(25,2) BLOCKPAT
          TMPFILE = ' '
          TMPFILE = BLOCKPAT
          CALL FULLNAME(PATH,TMPFILE,PATHFILE)
          OPEN(67,FILE=PATHFILE,STATUS='OLD')

          ICODEPAT = 0
          READ(67,7126) CODEPAT

          IF(CODEPAT .EQ. '"POPDATA APR_11') ICODEPAT = 1
          IF(CODEPAT(1:14) .EQ. 'POPDATA APR_11') ICODEPAT = 1

          IF(CODEPAT .EQ. '"POPDATA DEC_11') ICODEPAT = 1

          IF(CODEPAT(1:14) .EQ. 'POPDATA DEC_11') ICODEPAT = 1

          IF(ICODEPAT .EQ. 0) THEN

           WRITE(*,3131)
           WRITE(*,*)' THE PROGRAM STOPS.'
           CLOSE(67)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,3131)
         WRITE(42,*)' THE PROGRAM STOPS.' 
        CLOSE(42)

           CALL PAUSE
           STOP

          ENDIF


          CLOSE(67)

         ENDIF


C  ABOVE ENDIF IS FOR THE  IF(IFORMT .EQ. 3)  CONDITION.


C  SINCE ICODE .GE. 23, READ IN BOTH NSUBTOT AND NSUB AND THEN CALL
C  ROUTINE GETIPATF WHICH READS THIS PORTION OF FILE 25 TO OBTAIN
C  IPATVEC. NOTE THE 1ST ARGUMENT TELLS GETIPATF TO READ FILE 25.

C  NOTE THAT IF IERRR RETURNS AS -1, THERE IS A PROBLEM WITH THE
C  PATIENT NO. INFO IN THE FILE. IN THIS CASE, THE USER HAS ALREADY
C  BEEN INFORMED OF THE PROBLEM IN GETIPATF, SO JUST TRANSFER
C  CONTROL TO LABEL 6310 ABOVE.

C  SKIP THIS LINE. IT CONTAINS 'NSUBTOT'.
         READ(25,*)
         READ(25,*) NSUBTOT

C  SKIP THIS LINE. IT CONTAINS 'NSUB'.

         READ(25,*)
         READ(25,*) NSUB

C  SKIP THIS LINE. IT CONTAINS "ACTIVE PATIENT NUMBERS, FOLLOWED BY
C  A LINE WITH '0'"

         READ(25,*)     
         CALL GETIPATF(25,NSUBTOT,NSUB,MAXSUB,IPATVEC,IERRR)
         IF(IERRR .EQ. -1) GO TO 6310

C  SKIP THREE LINES; THE FIRST CONTAINS 'NOFIX'; THE SECOND CONTAINS
C  THE VALUE OF NOFIX. THE THIRD CONTAINS 'VALFIX ARRAY IF NOFIX > 0'.
         READ(25,*)
         READ(25,*)
         READ(25,*)
         IF(NOFIX .GT. 0) READ(25,*) (VALFIX(I),I=1,NOFIX)

C  SKIP THREE LINES; THE FIRST CONTAINS 'NVAR'; THE SECOND CONTAINS
C  THE VALUE OF NVAR. THE THIRD CONTAINS 'AB ARRAY'
         READ(25,*)
         READ(25,*)
         READ(25,*)

       
         DO I=1,NVAR
          READ(25,*) (AB(I,J),J=1,2)
         END DO

C  SKIP THIS LINE. IT CONTAINS 'NUMEQT'.
         READ(25,*)
         READ(25,*) NUMEQT


C  SKIP THIS LINE. IT CONTAINS 'NUMEQT LINES OF ASSAY COEFFICIENTS'.
         READ(25,*)

         DO IEQ=1,NUMEQT
          READ(25,*) C0P(IEQ),C1P(IEQ),C2P(IEQ),C3P(IEQ)
         END DO

C  SKIP THIS LINE. IT CONTAINS 'IERRMOD'.
         READ(25,*)
         READ(25,*) IERRMOD


C  SKIP THIS LINE. IT CONTAINS 'GAMLAM0
         READ(25,*)
         READ(25,*) GAMLAM0

C  SKIP THIS LINE. IT CONTAINS 'IASS(I),I=1,NUMEQT'.
         READ(25,*)
         READ(25,*) (IASS(I),I=1,NUMEQT)


C  NOTE THAT IF THE USER SELECTED IASS(IEQ) = 3 IN A PREVIOUS RUN, IT
C  MEANS THAT SOME OF HIS PATIENT DATA FILES PROBABLY HAD THEIR ASSAY
C  SD'S MULTIPLIED BY A CONSTANT (ASSMULT(IEQ)). IT IS UNLIKELY THE USER
C  WOULD WANT THESE DATA FILES TO BE FURTHER MUTLIPLIED BY THIS CONSTANT
C  SO DEFAULT ASSMULT(IEQ) = 1. ALSO, IALLPAT(IEQ) WILL BE DEFAULTED
C  TO 0.

         DO IEQ=1,NUMEQT
          ASSMULT(IEQ) = 1.D0
          IALLPAT(IEQ) = 0
         END DO

        IF(ICODE .LT. 27) THEN

C  SKIP THIS LINE. IT CONTAINS 'AF'.
         READ(25,*)
         READ(25,*) AFSCALAR
         IAF = 0

C  NOTE THAT AF(I), I=1,NDRUG, WILL BE SET = AFSCALAR JUST ABOVE THE
C  CALL TO VERIF1 BELOW.
       
        ENDIF


        IF(ICODE .GE. 27) THEN

C  SKIP THIS LINE. IT CONTAINS 'NDRUG'.
         READ(25,*)
         READ(25,*) NDRUG

C  SKIP THIS LINE. IT CONTAINS 'AF(I),I=1,NDRUG'.
         READ(25,*)
         READ(25,*) (AF(I),I=1,NDRUG)
         IAF = 1

        ENDIF

C  SKIP THIS LINE. IT CONTAINS 'INDPTS'.
         READ(25,*)
         READ(25,*) INDPTS

C  SKIP THIS LINE. IT CONTAINS 'MAXCYC'.
         READ(25,*)
         READ(25,*) MAXCYC

C  MAXCYC MUST BE .LE. 9997. IF NOT, RESET IT.

         IF(MAXCYC .GT. 9997) MAXCYC = 9997

C  AS OF NPBIG1, JSTOP = 1 AND 2 ARE ELIMINATED. IF THE USER IS USING
C  AN INPUT FILE WITH JSTOP = 1 OR 2, RESET JSTOP TO 3, AND SET TOLC
C  TO THE DEFAULT VALUE OF .01

C  SKIP THIS LINE. IT CONTAINS 'JSTOP'.
         READ(25,*)
         READ(25,*) JSTOP


C  SKIP THIS LINE. IT CONTAINS 'IF JSTOP .NE. 1, TOL OR TOLC IS ON NEXT
C  LINE'.
         READ(25,*)

C  NOTE THAT IF ICODE = 27, TOL IS ON THE NEXT LINE, AND IF ICODE .GE.
C  28, TOLC IS ON THE NEXT LINE. IN THE LATTER CASE, SET TOLC TO ITS 
C  DEFAULT VALUE. IN THE FORMER CASE, TOL DOES NOT NEED TO BE SET SINCE
C  IT IS NO LONGER PASSED TO THE "ENGINE".

         IF(JSTOP .NE. 1 .AND. ICODE .GE. 28) THEN
          READ(25,*) TOLC
         ENDIF

         IF(JSTOP .NE. 1 .AND. ICODE .EQ. 27) THEN
          READ(25,*) TOL
          TOLC = .01D0
         ENDIF


         IF(JSTOP .EQ. 1 .OR. JSTOP .EQ. 2) THEN
          JSTOP = 3
          TOLC = .01D0
         ENDIF

         NINT=100

C  SKIP THIS LINE. IT CONTAINS 'IDELTA'.
         READ(25,*)
         READ(25,*) IDELTA

C  SKIP THIS LINE. IT CONTAINS 'XMIC'.
         READ(25,*)
         READ(25,*) XMIC

C  SKIP THIS LINE. IT CONTAINS 'ICENT ...'.
         READ(25,*)
         READ(25,*) ICENT


C  SKIP THIS LINE. IT CONTAINS 'AUCINT'.
         READ(25,*)
	   READ(25,*) AUCINT


        ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(ICODE .GE. 25)  CONDITION.


        IF(ICODE .LT. 25) THEN
 

         READ(25,*) IFORMT


C  AS OF NPBIG11.FOR, IFORMT=2 IS NOT ALLOWED. I.E., ALL PATIENT DATA
C  FILES WILL BE IN THE NEW WORKING COPY FORMAT (IFORMT = 1) OR ANDREAS'
C  NEW MATRIX STYLE BLOCK FORMAT (IFORMT = 3) - THIS NEW IFORMT = 3
C  OPTION IS AS OF NPBIG15.FOR.


	IF(IFORMT .EQ. 2) THEN

	 WRITE(*,1231)
 1231    FORMAT(/' YOUR INSTRUCTION FILE INDICATES THAT YOUR PATIENT'/
     1' DATA FILES ARE IN USC*PACK FORMAT, WHICH IS NO LONGER ALLOWED'/
     2' BY THIS PROGRAM. '//

     3' PLEASE RERUN THE PROGRAM AND ENTER PATIENT DATA INFO EITHER'/
     4' IN THE NEW-STYLE WORKING COPY FORMAT FOR MULTIPLE DRUGS'/
     5' (IFORMT = 2), OR IN THE MATRIX STYLE BLOCK FORMAT'/
     6' (IFORMT = 1).'//)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,1231) 
        CLOSE(42)

	 CALL PAUSE
	 STOP

	ENDIF

	IF(IFORMT .EQ. 1) THEN
	 IDIRCT = 0
	 READ(25,2222) PREFIX
	 READ(25,222) EXT
	ENDIF


	IF(IFORMT .EQ. 3) THEN

        READ(25,2) BLOCKPAT
     	TMPFILE = ' '
	TMPFILE = BLOCKPAT
	CALL FULLNAME(PATH,TMPFILE,PATHFILE)

	OPEN(67,FILE=PATHFILE,STATUS='OLD')

	 ICODEPAT = 0


 7126    FORMAT(A15)
	 READ(67,7126) CODEPAT

	 IF(CODEPAT .EQ. '"POPDATA APR_11') ICODEPAT = 1
	 IF(CODEPAT(1:14) .EQ. 'POPDATA APR_11') ICODEPAT = 1

       IF(CODEPAT .EQ. '"POPDATA DEC_11') ICODEPAT = 1
       IF(CODEPAT(1:14) .EQ. 'POPDATA DEC_11') ICODEPAT = 1


	IF(ICODEPAT .EQ. 0) THEN

	 WRITE(*,3131)
	 WRITE(*,*)' THE PROGRAM STOPS.'
	 CLOSE(67)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,3131)
         WRITE(42,*)' THE PROGRAM STOPS.' 
        CLOSE(42)

	 CALL PAUSE
	 STOP

	ENDIF



	CLOSE(67)

	ENDIF

C  ABOVE ENDIF IS FOR THE  IF(IFORMT .EQ. 3)  CONDITION.


	IF(ICODE .LE. 22) THEN
	 READ(25,*) NSUB
	 NSUBTOT = NSUB
	 DO I=1,NSUB
	  IPATVEC(I) = I

	 END DO
	ENDIF

C  NOTE THAT FOR ICODE .LE. 22, ALL SUBJECTS ARE ASSUMED TO BE USED
C  IN THE ANALYSIS, SO IPATVEC IS FILLED WITH ALL THE INDICES FROM
C  1 TO NSUB.

C  IF ICODE .GE. 23, READ IN BOTH NSUBTOT AND NSUB AND THEN CALL
C  ROUTINE GETIPATF WHICH READS THIS PORTION OF FILE 25 TO OBTAIN
C  IPATVEC. NOTE THE 1ST ARGUMENT TELLS GETIPATF TO READ FILE 25.

C  NOTE THAT IF IERRR RETURNS AS -1, THERE IS A PROBLEM WITH THE
C  PATIENT NO. INFO IN THE FILE. IN THIS CASE, THE USER HAS ALREADY
C  BEEN INFORMED OF THE PROBLEM IN GETIPATF, SO JUST TRANSFER
C  CONTROL TO LABEL 6310 ABOVE.



	IF(ICODE .GE. 23) THEN
	 READ(25,*) NSUBTOT
	 READ(25,*) NSUB
	 CALL GETIPATF(25,NSUBTOT,NSUB,MAXSUB,IPATVEC,IERRR)
	 IF(IERRR .EQ. -1) GO TO 6310
	ENDIF

	IF(NOFIX .GT. 0) READ(25,*) (VALFIX(I),I=1,NOFIX)

	DO I=1,NVAR
	 READ(25,*) (AB(I,J),J=1,2)
	END DO
	

C  THE DIFFERENCES BETWEEN THE DIFFERENT ALLOWABLE VERSIONS OF THE
C  SAVED INPUT FILES (SEE ICODE ABOVE) IS ENTIRELY IN THE FOLLOWING
C  BLOCK OF READ(25, ... STMTS. NO; THERE ARE SOME DIFFERENCE ABOVE
C  TOO.


C  DEPENDING ON ICODE, FILL IN DEFAULT INFO FOR UN-INPUT INFO.

C  NOTE THAT IN VERSION ICODE = 5, THE USER SAVED
C  WHAT WERE CALLED [C0,C1,C2,C3]. BUT, FOR THIS PROGRAM, THESE VALUES
C  WILL BE ASSIGNED TO THE POPULATION VALUES [C0P,C1P,C2P,C3P].


C  FOR ICODE=18, MULTIPLE OUTPUTS (AND MULTIPLE SETS OF IASS AND
C  ASSAY COEFFICIENTS) ARE USED FOR 1ST TIME.

	IF(ICODE .LT. 18) NUMEQT=1

	IF(ICODE .GE. 18) READ(25,*) NUMEQT

	DO IEQ=1,NUMEQT
	 READ(25,*) C0P(IEQ),C1P(IEQ),C2P(IEQ),C3P(IEQ)
	END DO

	IERRMOD = 1


	IF(ICODE .GE. 22) THEN
	 READ(25,*) IERRMOD
	 READ(25,*) GAMLAM0
	ENDIF

	IF(ICODE .GE. 6) READ(25,*) (IASS(I),I=1,NUMEQT)

	IF(ICODE .EQ. 5) IASS(1) = 1

C  NOTE THAT IF THE USER SELECTED IASS(IEQ) = 3 IN A PREVIOUS RUN, IT
C  MEANS THAT SOME OF HIS PATIENT DATA FILES PROBABLY HAD THEIR ASSAY

C  SD'S MULTIPLIED BY A CONSTANT (ASSMULT(IEQ)). IT IS UNLIKELY THE USER
C  WOULD WANT THESE DATA FILES TO BE FURTHER MUTLIPLIED BY THIS CONSTANT
C  SO DEFAULT ASSMULT(IEQ) = 1. ALSO, IALLPAT(IEQ) WILL BE DEFAULTED
C  TO 0.


	DO IEQ=1,NUMEQT
	 ASSMULT(IEQ) = 1.D0
	 IALLPAT(IEQ) = 0
	END DO

	READ(25,*) AFSCALAR
      IAF = 0

	READ(25,*) INDPTS
	READ(25,*) MAXCYC

C  MAXCYC MUST BE .LE. 9997. IF NOT, RESET IT.

	IF(MAXCYC .GT. 9997) MAXCYC = 9997


C  AS OF NPBIG1, JSTOP = 1 AND 2 ARE ELIMINATED. IF THE USER IS USING
C  AN INPUT FILE WITH JSTOP = 1 OR 2, RESET JSTOP TO 3, AND SET TOLC
C  TO THE DEFAULT VALUE OF .01. NOTE THAT IF JSTOP = 3, TOL IS READ IN,
C  AND IN THIS CASE, SIMPLY SET TOLC TO ITS DEFAULT VALUE OF .01.

C  NOTE THAT TOL DOES NOT NEED TO BE SET SINCE IT IS NO LONGER PASSED TO
C  THE "ENGINE".

	READ(25,*) JSTOP
	IF(JSTOP .NE. 1) THEN
       READ(25,*) TOL
       TOLC = .01D0
      ENDIF

	 IF(JSTOP .EQ. 1 .OR. JSTOP .EQ. 2) THEN
	  JSTOP = 3
        TOLC = .01D0
	 ENDIF

	READ(25,*) IJUNKK
	READ(25,*) IJUNKK
	READ(25,*) IJUNKK


C  IN THIS PROGRAM IPLOT, IOUT, ISCROL HAVE ALL BEEN REMOVED, BUT THEY
C  WILL CONTINUE TO BE READ IN (AND PUT INTO THE SAVED INPUT FILE) SO
C  THE FORMAT OF THE SAVED INPUT FILE DOESN'T HAVE TO BE CHANGED.
C  SIMILARLY FOR ICENT, AS OF NPAG113.FOR.

	NINT=100


	IF(ICODE .GE. 8) READ(25,*) IDELTA
	IF(ICODE .LE. 6) IDELTA = 12

	IF(ICODE .EQ. 8) READ(25,*) XJUNK

	IF(ICODE .GE. 8) READ(25,*) XMIC
	IF(ICODE .LE. 6) XMIC = 1.D0

	IF(ICODE .GE. 8) READ(25,*) ICENT
	IF(ICODE .LE. 6) ICENT = 2

	IF(ICODE .GE. 24) READ(25,*) AUCINT
	IF(ICODE .LE. 23) AUCINT = 24

C  NOTE THAT IF ICODE .GE. 17, THERE IS ONE MORE LINE, WHICH HAS EITHER
C  'NOT SELECTED' OR THE NAME OF A FILE. EVEN IF THERE IS A FILENAME ON
C  THE NEXT LINE, IT IS NO LONGER USED BY THIS PROGRAM, SO IT WON'T BE
C  READ.


        ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(ICODE .LT. 25)  CONDITION.


	CLOSE(25)

	ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(IFIL .EQ. 1)  OPTION.

 9700 CONTINUE





	IF(IFIL .EQ. 0) THEN

C  ENTER INPUT INFO VIA THE KEYBOARD.



C  AS OF NPBIG11.FOR, IFORMT IS HARDCODED = 1 (I.E., USC*PACK FORMAT
C  FILE IS NO LONGER ALLOWED), AND IDIRCT IS HARDCODED TO 0. ALSO,

C  CODE RELATED TO IFORMT = 2 AND IDIRCT = 1 IS REMOVED.

C  AS OF NPBIG15.FOR, IFORMT MAY = 1 OR 3. 1 --> PATIENT INFO WILL BE
C  INPUT IN THE NEW MULTIPLE-DRUG WORKING COPY FORMAT. 3 --> PATIENT
C  INFO WILL BE INPUT IN ANDREAS'S NEW MATRIX BLOCK FORMAT.

C  WRITE ALL INPUT DATA INTO FILE PATHFILAST AS IT IS BEING INPUT. DO
C  THIS BY CALLING WRITEINFILE AFTER EACH INCREMENTAL SET OF INFO IS
C  READ IN. NOTE THAT AFTER EACH CALL TO WRITEINFILE, ALL THE INFO
C  ALREADY READ HAS BEEN WRITTEN TO PATHFILE, AND THE PIECES OF INFO
C  NOT YET READ IN HAVE DEFAULT VALUES OR -99'S IN THEIR PLACES.


 4005	WRITE(*,141)
  141   FORMAT(/' ENTER 1 IF THE PATIENT DATA INFO WILL BE SUPPLIED'/
     1'         IN A MATRIX BLOCK FORMAT; '/
     2' ENTER 2 IF THE PATIENT DATA INFO WILL BE INPUT USING A'/
     3'         WORKING COPY FORMAT: ')
	READ(*,*,ERR=4005) IFORMTT

	IF(IFORMTT .NE. 1 .AND. IFORMTT .NE. 2) GO TO 4005

C  IFORMTT MUST BE CHANGED TO BE THE SAME AS THE
C  OLD IFORMT AS FOLLOWS:
C  IFORMTT = 1 --> IFORMT = 3 --> PATIENT INFO IS INPUT VIA BLOCK FORMAT

C                                 (.CSV FILES);

C  IFORMTT = 2 --> IFORMT = 1 --> PATIENT INFO IS INPUT VIA WORKING COPY
C                                 FILES.

         IF(IFORMTT .EQ. 1) IFORMT = 3
         IF(IFORMTT .EQ. 2) IFORMT = 1


	IF(IFORMT .EQ. 3) THEN


         WRITE(*,3111)
 3111    FORMAT(/' ENTER THE NAME OF THE FILE WHICH CONTAINS ALL THE'/
     1' PATIENT DATA INFO IN BLOCK FORMAT (ENTER -99 TO SEE ALL OR A '/


     2' PART OF YOUR DIRECTORY: ')
        READ(*,2) BLOCKPAT
	IF(BLOCKPAT(1:3) .EQ. '-99') THEN
           CALL SEEDIR(PATH,NOB,BLOCKPAT,OSName,ListDir)
        ENDIF
C  CALL FULLNAME WHICH CONVERTS THE FILENAME TO PATHFILE, THE COMPLETE
C  NAME OF THE FILE, WHICH INCLUDES THE PATH (IF THE PATH IS NOT THE
C  CURRENT DIRECTORY).

     	TMPFILE = ' '
	TMPFILE = BLOCKPAT
	CALL FULLNAME(PATH,TMPFILE,PATHFILE)
	OPEN(67,FILE=PATHFILE,ERR=3120,STATUS='OLD')
	GO TO 3130
 3120   WRITE(*,5316) PATHFILE
	GO TO 4005
 3130   CONTINUE

	 ICODEPAT = 0
	 READ(67,7126) CODEPAT
	 IF(CODEPAT .EQ. '"POPDATA APR_11') ICODEPAT = 1
	 IF(CODEPAT(1:14) .EQ. 'POPDATA APR_11') ICODEPAT = 1
       IF(CODEPAT .EQ. '"POPDATA DEC_11') ICODEPAT = 1
       IF(CODEPAT(1:14) .EQ. 'POPDATA DEC_11') ICODEPAT = 1

	IF(ICODEPAT .EQ. 0) THEN
	 WRITE(*,3131)
 3131    FORMAT(//' YOUR PATIENT DATA BLOCK FORMAT FILE IS NOT FROM '/
     1' THE ALLOWABLE SET OF SUCH FILES.'//
     2' A PATIENT DATA BLOCK FORMAT FILE MUST HAVE "POPDATA XXX_XX IN'/
     3' COLUMNS 1 THROUGH 15 ON LINE 1, WHERE  XXX_XX  IS APR_11 OR A '/
     4' MORE RECENT DATE.'//)
	  CLOSE(67)
	  GO TO 4005
	ENDIF

	CLOSE(67)

	ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(IFORMT .EQ. 3)  CONDITION.



	IF(IFORMT .EQ. 1) THEN

 7505	  WRITE(*,4041)
 4041     FORMAT(/' ENTER THE 5-CHAR PREFIX FOR PATIENT FILENAMES: ')
	  READ(*,2222) PREFIX
	  WRITE(*,4043)
 4043     FORMAT(/' IF THERE IS A 3-CHAR EXTENSION FOR THE PATIENT '/
     1' FILENAMES, ENTER IT NOW; OTHERWISE, HIT CARRIAGE RETURN: ')
	  READ(*,222) EXT

C  VERIFY THAT THE USER ENTERED AT LEAST 5 CHARACTERS FOR THE PREFIX. IF
C  NOT, VERIFY THAT THIS IS NOT A MISTAKE ... BUT ALLOW SUCH A PREFIX
C  IF THE USER INSISTS -- THE RUN WILL STILL WORK PROPERLY.

	  IF(PREFIX(1:1) .EQ. ' ' .OR. PREFIX(2:2) .EQ. ' ' .OR.
     1       PREFIX(3:3) .EQ. ' ' .OR. PREFIX(4:4) .EQ. ' ' .OR.
     2       PREFIX(5:5) .EQ. ' ') THEN

     	PATFIL = PREFIX//'001.'//EXT
 7500   WRITE(*,7501) PATFIL(1:12)
 7501   FORMAT(/' ARE YOUR SUBJECT FILES REALLY CALLED ',A12,' ... ?'//

     1' ENTER 1 TO REENTER YOUR SUBJECT FILENAMES; '/
     2' ENTER 0 IF THESE NAMES ARE ACCURATE: ')
	READ(*,*,ERR=7500) IOK
	IF(IOK .NE. 0 .AND. IOK .NE. 1) GO TO 7500

	IF(IOK .EQ. 1) GO TO 7505

	   ENDIF

	ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(IFORMT .EQ. 1) THEN  CONDITION.



      CALL WRITEINFILE(1,PATHFILAST,IDELTA,XMIC,ICENT,
     1   AUCINT,AF,INDPTS,MAXCYC,JSTOP,TOLC,NUMEQT,C0P,C1P,C2P,C3P,

 
     2   IERRMOD,GAMLAM0,IASS,NOFIX,VALFIX,NVAR,AB,NSUB,NSUBTOT,MAXSUB,
     3   IPATVEC,IFORMT,BLOCKPAT,PREFIX,EXT,NDRUG,FORFILE,NDIM,NP,IRAN,
     4   PAR,PARFIX,TOLER,INPRI,PRIFIL2,MAXNUMEQ,NRANFIX,PARRANFIX,
     5   RANFIXEST)


C  CALL SUBROUTINE GETIPAT TO OBTAIN THE NO. OF SUBJECTS IN THE

C  ENTIRE DATA SET, NSUBTOT, THE NO. OF THESE SUBJECTS TO BE USED
C  IN THE CURRENT ANALYSIS, NSUB, AND THE INDICES OF THESE "ACTIVE"
C  SUBJECTS, IPATVEC(I),I=1,NSUB. NOTE THAT ISUBALL = 1 IF ALL

C  SUBJECTS ARE USED (I.E., NSUB = NSUBTOT) AND 0 OTHERWISE.

	CALL GETIPAT(NSUBTOT,NSUB,ISUBALL,MAXSUB,IPATVEC)

      CALL WRITEINFILE(2,PATHFILAST,IDELTA,XMIC,ICENT,
     1   AUCINT,AF,INDPTS,MAXCYC,JSTOP,TOLC,NUMEQT,C0P,C1P,C2P,C3P,
     2   IERRMOD,GAMLAM0,IASS,NOFIX,VALFIX,NVAR,AB,NSUB,NSUBTOT,MAXSUB,
     3   IPATVEC,IFORMT,BLOCKPAT,PREFIX,EXT,NDRUG,FORFILE,NDIM,NP,IRAN,
     4   PAR,PARFIX,TOLER,INPRI,PRIFIL2,MAXNUMEQ,NRANFIX,PARRANFIX,
     5   RANFIXEST)


C  CALL SUBROUTINE GETNUMEQ, WHICH READS ONE PATIENT DATA FILE, OR THE
C  PATIENT INFO IN BLOCKPAT, TO GET THE NO. OF OUTPUT EQUATIONS
C  (NUMEQT), AND THE NO. OF DRUGS (NDRUG). THE 3RD ARGUMENT TO GETNUMEQ
C  IS 1 --> THE CALL IS FROM MAIN.

        CALL GETNUMEQ(PATH,NOB,1,IFORMT,PREFIX,EXT,BLOCKPAT,NUMEQT,
     1   NDRUG,MAXSUB,MAXNUMEQ)


C  CHECK THAT NUMEQT IS .LE. MAXNUMEQ.

      IF(NUMEQT .GT. MAXNUMEQ) THEN

       WRITE(*,8317) NUMEQT,MAXNUMEQ
 8317  FORMAT(/' YOUR PATIENT FILES HAVE ',I3,' OUTPUT EQUATIONS. '/
     1' THIS IS MORE THAN THE MAXIMUM ALLOWED NO. OF ',I2,'.'//
     2' PLEASE CORRECT YOUR PATIENT FILES AND THEN RERUN THE PROGRAM.'/) 

       OPEN(42,FILE=ERRFIL)
        WRITE(42,8317) NUMEQT,MAXNUMEQ 
       CLOSE(42)

       CALL PAUSE
       STOP

      ENDIF


C////////////////////////   ENTER PARAMETER INFO.  /////////////////////
C///////////////////////////  BELOW  ///////////////////////////////////

C  THIS CODE IS SIMILAR IN MAIN AND VERIF1 -- SEE PAR_6.INP.


        WRITE(*,1117)
 1117   FORMAT(/' ENTER THE BOUNDS OF THE RANGE FOR EACH PARAMETER.'//
     1' CAUTION: IF ANY OF YOUR PARAMETERS CANNOT = 0, BE SURE TO MAKE'/

     2'		 ITS LOWER BOUNDARY A POSITIVE NUMBER, RATHER THAN 0.'/

     3' 	 (ONE SUCH EXAMPLE IS FOR VOL WHICH SHOWS UP IN THE'/

     4'		 DENOMINATOR OF THE OUTPUT EQUATION IN THE MODEL'/
     5'		 FILE.)'//)

	DO 6060 I=1,NVAR

	WRITE(*,34) PAR(I)
   34   FORMAT(/' ',A11,' : ')



 7110   READ(*,*,ERR=7115) (AB(I,J),J=1,2)
	GO TO 6060
 7115   WRITE(*,7116)
 7116   FORMAT(/' SEE ABOVE; PLEASE ENTER TWO REAL NUMBERS: ')
	GO TO 7110

 6060   CONTINUE


C  ENTER THE FIXED VALUES FOR THE PARAMETERS.

      IF(NOFIX .GT. 0) THEN

     	 WRITE(*,4836)
 4836  FORMAT(/' ENTER THE VALUE FOR EACH FIXED PARAMETER: ')

       DO 4855 I=1,NOFIX
       WRITE(*,34) PARFIX(I)
 4840  READ(*,*,ERR=4845) VALFIX(I)
       GO TO 4855
 4845  WRITE(*,4841)
 4841  FORMAT(/' SEE ABOVE; ENTER A POSITIVE VALUE: ')
       GO TO 4840
 4855  CONTINUE


      ENDIF


C  ENTER THE RANFIX VALUES FOR THE PARAMETERS.

      IF(NRANFIX .GT. 0) THEN

     	  WRITE(*,5836)
 5836   FORMAT(/' ENTER THE INITIAL EST. FOR EACH RANFIX PARAMETER: ')
        DO 5855 I=1,NRANFIX
        WRITE(*,34) PARRANFIX(I)
 5840   READ(*,*,ERR=5845) RANFIXEST(I)
        GO TO 5855
 5845   WRITE(*,4841)
        GO TO 5840
 5855   CONTINUE

      ENDIF




C  IN PAR_6.INP, THE MENU STUFF IS NOT USED. THE USER CODES EXPLICITLY

C  INTO SUBROUTINE SYMBOL WHICH DESCRIPTOR(S) IS (ARE) TO BE
C  USED WITH THE RANDOM VARIABLES.

      CALL WRITEINFILE(3,PATHFILAST,IDELTA,XMIC,ICENT,
     1   AUCINT,AF,INDPTS,MAXCYC,JSTOP,TOLC,NUMEQT,C0P,C1P,C2P,C3P,
     2   IERRMOD,GAMLAM0,IASS,NOFIX,VALFIX,NVAR,AB,NSUB,NSUBTOT,MAXSUB,
     3   IPATVEC,IFORMT,BLOCKPAT,PREFIX,EXT,NDRUG,FORFILE,NDIM,NP,IRAN,
     4   PAR,PARFIX,TOLER,INPRI,PRIFIL2,MAXNUMEQ,NRANFIX,PARRANFIX,
     5   RANFIXEST)


C/////////////   ENTER RANDOM AND FIXED PARAMETER INFO.  ///////////////
C///////////////////////////  ABOVE  ///////////////////////////////////


	CALL SYSTEM(ClearScreen)

 1110   WRITE(*,118)
  118 FORMAT(//' SELECT HOW YOU WOULD LIKE TO MODEL THE ASSAY ERROR'/
     1' FUNCTION, S.D. ASSUME SD1 = C0+C1*Y+C2*Y**2+C3*Y**3; THEN ...'//
     2' ENTER 1 IF S.D. = SD1;'/

     3' ENTER 2 IF S.D. = GAMMA*SD1, WITH GAMMA TO BE ESTIMATED;'/
     4' ENTER 3 IF S.D. = SQRT(SD1**2 + LAMBDA**2), WITH LAMBDA TO BE ES
     5TIMATED;'/
     6' ENTER 4 IF S.D. = GAMMA, WITH GAMMA TO BE ESTIMATED: ')
	READ(*,*,ERR=1110) IERRMOD
	IF(IERRMOD .LT. 1 .OR. IERRMOD .GT. 4) GO TO 1110


	IF(IERRMOD .GE. 2) THEN

	 ESTNAM = ' GAMMA'
	 IF(IERRMOD .EQ. 3) ESTNAM = 'LAMBDA'



  220	 WRITE(*,219) ESTNAM
  219    FORMAT(/' ENTER 1 TO START WITH AN INITIAL ESTIMATE OF 1 FOR ',
     1A6,';'/
     2' ENTER 0 TO ENTER A DIFFERENT INITIAL ESTIMATE FOR ',A6,': ')
	 READ(*,*,ERR=220) IGG
	 IF(IGG .NE. 1 .AND. IGG .NE. 0) GO TO 220

	 IF(IGG .EQ. 1) GAMLAM0 = 1.D0

	 IF(IGG .EQ. 0) THEN
  225     WRITE(*,223) ESTNAM
  223     FORMAT(/' ENTER THE INITIAL ESTIMATE FOR ',A6,' (A POSITIVE NO
     1.): ')
	  READ(*,*,ERR=220) GAMLAM0
	  IF(GAMLAM0 .LE. 0.D0) GO TO 225
	 ENDIF

	ENDIF



C  IF IERRMOD = 4, THE ASSAY ERROR FUNCTION WILL NOT DEPEND ON THE ASSAY
C  ERROR COEFFICIENTS IN EACH SUBJECT'S DATA FILE. IN THIS CASE, SKIP
C  THE IASS CODE BELOW SINCE IT'S IRRELEVANT. BUT SET
C  IASS(K) AND C0P(K), C1P(K), C2P(K), C3P(K) = 1, K=1,NUMEQT. THIS IS

C  REQUIRED TO MAKE SURE THAT ALL SUBJECTS HAVE REASONABLE COEFFICIENTS
C  AT THE BOTTOM OF THEIR FILES (SEE SUBROUTINE PUTASS BELOW).

	IF(IERRMOD .EQ. 4) THEN


	 DO KK = 1,NUMEQT
	  IASS(KK) = 1
	  C0P(KK) = 1.D0
	  C1P(KK) = 1.D0
	  C2P(KK) = 1.D0
	  C3P(KK) = 1.D0
	 END DO

	 WRITE(*,218)
  218    FORMAT(/' NOTE THAT THIS RUN WILL NOT USE THE ASSAY'/
     1' COEFFICIENTS IN YOUR PATIENT DATA FILES, BUT ANY PATIENT DATA'/
     2' FILES WITHOUT ASSAY COEFFICIENTS WILL HAVE A "1" PLACED IN '/
     3' EACH ASSAY COEFFICIENT LOCATION (AS A PLACEHOLDER).')

	 GO TO 4150

	ENDIF


      CALL SYSTEM(ClearScreen)

      WRITE(*,119)
  119 FORMAT(//' NOW SELECT HOW TO ESTABLISH THE COEFFICIENTS FOR'/
     1' SD1 = C0 + C1*Y + C2*Y**2 + C3*Y**3.'//
     3' FOR EACH OF THE OUTPUT EQUATION(S), SELECT ONE OF THE FOLLOWING'
     4/

     5' OPTIONS FOR THE ASSAY COEFFICIENTS [C0,C1,C2,C3]: '//
     4' ENTER 1 FOR THE DEFAULT OPTION ...'/
     5'         FOR EACH PATIENT, IF THE DATA FILE ALREADY INCLUDES ASSA
     6Y'/
     7'         COEFFICIENTS, THOSE COEFFICIENTS WILL BE USED. OTHERWISE

     8 THE'/
     9'		COEFFICIENTS YOU ENTER BELOW WILL BE USED; '//
     8' ENTER 2 IF YOU WOULD LIKE THE ASSAY COEFFICIENTS YOU ENTER BELOW
     1 TO BE'/
     2'         USED FOR ALL PATIENTS, EVEN FOR THOSE WHOSE DATA FILES A
     3LREADY'/
     4'		INCLUDE COEFFICIENTS;'//
     2' ENTER 3 IF YOU WOULD LIKE THE ASSAY COEFFICIENTS ALREADY IN SOME
     3 OR ALL'/
     4'         OF THE PATIENT DATA FILES (OR THE GENERAL VALUES YOU ENT
     5ER BELOW)'/
     6'         TO BE MULTIPLIED BY A GIVEN CONSTANT;'//
     7' ENTER 4 IF YOU WOULD LIKE TO BE PROMPTED SO YOU MAY CHOOSE THE A
     8SSAY'/
     9'         COEFFICIENTS ON A PATIENT - BY - PATIENT BASIS. YOU MAY
     1CHOOSE'/
     2'         GENERAL VALUES (WHICH YOU WILL ENTER BELOW), COEFFICIENT

     3S ALREADY'/
     4'         IN THE PATIENT DATA FILE, IF ANY, OR ANY OTHER SET OF CO
     5EFFICIENTS. ')

C  FOR EACH OUTPUT, INPUT IASS AND [C0P,...,C3P].

	DO 2200 IEQ = 1,NUMEQT

 1120   WRITE(*,221) IEQ
  221   FORMAT(/' FOR OUTPUT EQUATION ',I1,':'//
     4' ENTER 1 FOR THE DEFAULT OPTION;'//
     8' ENTER 2 IF YOU WOULD LIKE THE ASSAY COEFFICIENTS YOU ENTER '/
     9' 	BELOW TO BE USED FOR ALL PATIENTS;'//
     1' ENTER 3 IF YOU WANT THE COEFFICIENTS IN SOME OR ALL OF YOUR '/
     2'		FILES MULITPLIED BY A SPECIFIED CONSTANT;'//
     7' ENTER 4 TO BE PROMPTED: ')
	READ(*,*,ERR=1120) IAS

	IF(IAS .LT. 1 .OR. IAS .GT. 4) GO TO 1120
	IASS(IEQ) = IAS

	WRITE(*,1119) IEQ
 1119   FORMAT(/' ENTER THE GENERAL VALUES FOR [C0,C1,C2,C3] FOR '/
     1' OUTPUT EQUATION ',I1,'. THESE ')
	IF(IAS .EQ. 1) WRITE(*,1121)
	IF(IAS .EQ. 2) WRITE(*,1122)
	IF(IAS .EQ. 4 .OR. IAS .EQ. 3) WRITE(*,1123)
 1121   FORMAT(' WILL BE USED FOR ALL PATIENTS WHOSE DATA FILES DO '/
     1' NOT ALREADY INCLUDE ASSAY COEFFICIENTS: ')
 1122   FORMAT(' WILL BE USED FOR ALL PATIENTS: ')
 1123   FORMAT(' WILL BE USED FOR THOSE PATIENTS YOU SELECT BELOW: ')
 4140   READ(*,*,ERR=4145) C0P(IEQ),C1P(IEQ),C2P(IEQ),C3P(IEQ)
   	GO TO 2120
 4145   WRITE(*,4146)
 4146   FORMAT(/' SEE ABOVE; PLEASE ENTER FOUR REAL NUMBERS: ')
	GO TO 4140

 2120	IF(IAS .EQ. 3) THEN

	 IALLPAT(IEQ) = 0

 4260	 WRITE(*,4148)
 4148    FORMAT(/' ENTER THE ASSAY COEFFICIENT MULTIPLIER TO BE USED'/
     1' FOR THOSE PATIENTS YOU SELECT BELOW: ')
	 READ(*,*,ERR = 4260) ASSMULT(IEQ)


	ENDIF

 2200   CONTINUE


     	WRITE(*,2119)

 2119   FORMAT(//' NOTE: DURING THIS RUN, EACH SUBJECT WILL HAVE '/
     1'	      HIS/HER ASSAY COEFFICIENTS WRITTEN TO THE END OF HIS/HER'/

     2'       WORKING COPY PATIENT FILE. IF COEFFICIENTS ARE ALREADY '/
     3'	      THERE FROM A PREVIOUS RUN, THEY WILL BE OVERWRITTEN.'//)


      CALL WRITEINFILE(4,PATHFILAST,IDELTA,XMIC,ICENT,
     1   AUCINT,AF,INDPTS,MAXCYC,JSTOP,TOLC,NUMEQT,C0P,C1P,C2P,C3P,
     2   IERRMOD,GAMLAM0,IASS,NOFIX,VALFIX,NVAR,AB,NSUB,NSUBTOT,MAXSUB,
     3   IPATVEC,IFORMT,BLOCKPAT,PREFIX,EXT,NDRUG,FORFILE,NDIM,NP,IRAN,
     4   PAR,PARFIX,TOLER,INPRI,PRIFIL2,MAXNUMEQ,NRANFIX,PARRANFIX,
     5   RANFIXEST)

4150   WRITE(*,129)
  129   FORMAT(//' ENTER THE ACTIVE (SALT) FRACTION OF EACH DRUG. AS '/
     1' AN EXAMPLE, THE A.F. OF THEOPHYLLINE IS 1.0, WHILE THAT OF'/
     2' AMINOPHYLLINE IS TYPICALLY BETWEEN .79 AND .85, DEPENDING ON'/
     3' THE PREPARATION. '//
     4' EACH AF MUST BE A POSITIVE NUMBER LESS THAN OR EQUAL TO 1.0.'/)
       
        DO I = 1,NDRUG
         WRITE(*,1129) I
 1129    FORMAT(' AF FOR DRUG ',I1,': ')


         READ(*,*,ERR=4150) AF(I)


         IF(AF(I) .LE. 0.0 .OR. AF(I) .GT. 1.0) GO TO 4150
        END DO

        IAF = 1


C  ESTABLISH THE 'SUGGESTED' NO. OF GRID POINTS FOR THIS RUN. NOTE THAT
C  THIS IS JUST A 'RULE-OF-THUMB', BASED ON RATHER LIMITED EXPERIENCE.

	IF(NVAR .EQ. 1 .OR. NVAR .EQ. 2) INDSUG=1

	IF(NVAR .EQ. 3) INDSUG=3
	IF(NVAR .EQ. 4) INDSUG=4
	IF(NVAR .EQ. 5) INDSUG=6
	IF(NVAR .GE. 6) INDSUG=7

	WRITE(*,6063) NVAR,INDSUG


 6063   FORMAT(//' *****************      NOTE      *****************'//
     1' YOU HAVE SELECTED ',I2,' PARAMETERS FOR THIS RUN.'/
     1' IT IS LIKELY THAT YOU WILL NEED AT LEAST AN INDEX OF GRID'/
     2' POINTS EQUAL TO  ',I1,'  TO ANALYZE YOUR DATA ADEQUATELY. A '/
     3' SMALLER INDEX MAY LEAD TO SIGNIFICANTLY POORER ESTIMATIONS.'/
     4' THE DISADVANTAGE TO MORE POINTS, OF COURSE, IS THAT THE '/
     5' PROGRAM TAKES PROPORTIONATELY LONGER TO RUN, BUT ONLY IN THE'/
     6' EARLY CYCLES UNTIL IT HAS DISCARDED UNNEEDED POINTS.'//
     4' *****************      NOTE      *****************'//)

 6670   WRITE(*,6062)
 6062   FORMAT(/' ENTER THE INDEX FOR THE NO. OF GRID POINTS DESIRED.'/
     1' ENTER 1,2,3,4,5,6 OR 7, RESPECTIVELY, FOR, 2129, 5003, 10007,'/
     2' 20011, 40009, 80021, OR MULTIPLES OF 80021 POINTS: ')

 6065   READ(*,*,ERR=6670) INDPTS
	IF(INDPTS .LT. 1 .OR. INDPTS .GT. 7) GO TO 6670

	IF(INDPTS .EQ. 7) THEN


 6075	 WRITE(*,6064)
 6064    FORMAT(/' ENTER 2, 3, ...  FOR THE NO. OF MULTIPLES OF '/

     1' 80021 GRID POINTS YOU WOULD LIKE: ')
	 READ(*,*,ERR=6075) MULT
	 IF(MULT .LT. 1) GO TO 6075
	 INDPTS = 100+MULT

	ENDIF

C  NOTE FROM THE ABOVE LOGIC, IF USER WANTS MULTIPLES OF 80021 GRID
C  POINTS, INDPTS IS NOW A NUMBER BETWEEN 101 AND INDMAX, AND THE NUMBER
C  OF GRID POINTS IS 80021*(INDPTS-100).
C  NOTE ALSO THAT MULT=1 (SO INDPTS = 101) IS ALLOWED (THOUGH THE USER
C  THINKS THAT MULT HAS TO BE BETWEEN 2 AND 100) SO I CAN CHECK THAT THE
C  RESULTS ARE THE SAME AS WHEN INDPTS = 6.


 4160 	WRITE(*,123)
  123   FORMAT(/' ENTER THE MAX. NO. OF CYCLES DESIRED (LESS THAN OR'/
     1' EQUAL TO 9997)'//
     2' NOTE THAT IF YOU ENTER 0, IT MEANS THAT THE "engine" WILL DO'/
     3' NO CYCLE CALCULATIONS, BUT INSTEAD MOVE DIRECTLY TO THE '/
     4' END-OF-ANALYSIS SECTION TO CALCULATE VALUES NEEDED TO GIVE '/

     5' THE BAYESIAN POSTERIOR RESULTS FOR WHATEVER PATIENT DATA SET'/
     6' YOU CHOOSE, BASED ON THE PRIOR DENSITY YOU SELECT BELOW.'/
     7' THESE RESULTS CAN BE VIEWED BY RERUNNING THIS PROGRAM AND'/
     8' INPUTTING THE OUTPUT FILE FROM THE "engine". THIS IS'/
     9' SOMETIMES CALLED PROSPECTIVE ANALYSIS.'//
     1' ENTER THE MAX. NO. OF CYCLES NOW: ')

        READ(*,*,ERR=4160) MAXCYC
	IF(MAXCYC .LT. 0 .OR. MAXCYC .GT. 9997) GO TO 4160



C  AS OF NPBIG1.FOR, JSTOP = 3 IS REQUIRED (I.E., JSTOP = 1 AND 2
C  HAVE BEEN ELIMINATED).

	TOLC = .01D0




	IF(MAXCYC .GT. 0) THEN

C  SET JSTOP = 3. IT WON'T BE USED BUT MUST BE IN THE FILE,
C  npag102.inp (now npag103.inp) SO THE FORMAT OF THE FILE WON'T HAVE 
C  TO CHANGE.

         JSTOP = 3

C  AS OF NPAG111.FOR, THE USER INPUTS TOLC, RATHER THAN TOL (WHICH WILL
C  STILL BE HARDCODED IN THE "ENGINE TO BE 1.D-4).

 1250    WRITE(*,1247)
 1247    FORMAT(/' NOTE THAT THE ANALYSIS WILL STOP BEFORE THE MAX.'/
     1' NO. OF CYCLES HAVE BEEN RUN IF CONVERGENCE IS ACHIEVED, AND'/
     2' CONVERGENCE IS ACHIEVED BASED ON LOGIC AND PRE-SET TOLERANCE'/
     3' PARAMETERS WHICH ARE APPROPRIATE FOR THE "INTERIOR POINT'/
     4' ALGORITHM" USED BY THIS PROGRAM. THIS ALGORITM WAS DEVELOPED'/
     5' BY JIM BURKE AT THE UNIVERSITY OF WASHINGTON, AND ADAPTED FOR'/
     6' THIS PROGRAM BY BOB LEARY.'//
     1' BUT YOU MAY SET THE TOLERANCE PARAMETER, TOLC. THE NPAG '/
     2' ANALYSIS WILL BE CONVERGE IF THE LOG-LIK BETWEEN 2 CONSECUTIVE'/
     3' "MAJOR CYCLES" IS LESS THAN OR EQUAL TO TOLC.'//
     4' ENTER A POSITIVE VALUE FOR TOLC NOW; .01 IS A TYPICAL VALUE: ')
         READ(*,*,ERR= 1250) TOLC
         IF(TOLC .LE. 0.D0) GO TO 1250 


	ENDIF

C  THE ABOVE ENDIF IS FOR THE   IF(MAXCYC .GT. 0) THEN  CONDITION.


      CALL WRITEINFILE(5,PATHFILAST,IDELTA,XMIC,ICENT,
     1   AUCINT,AF,INDPTS,MAXCYC,JSTOP,TOLC,NUMEQT,C0P,C1P,C2P,C3P,
     2   IERRMOD,GAMLAM0,IASS,NOFIX,VALFIX,NVAR,AB,NSUB,NSUBTOT,MAXSUB,
     3   IPATVEC,IFORMT,BLOCKPAT,PREFIX,EXT,NDRUG,FORFILE,NDIM,NP,IRAN,
     4   PAR,PARFIX,TOLER,INPRI,PRIFIL2,MAXNUMEQ,NRANFIX,PARRANFIX,
     5   RANFIXEST)

C  NINT IS HARDCODED TO BE 100, BUT, AS OF NPBIG1.FOR, NINT CAN BE
C  CHANGED IN SUBROUTINE STAT FOR THE PURPOSES OF THAT ROUTINE ONLY.

	NINT=100


C  AS OF NPAG113.FOR, HARDCODE ICENT = 2, AND REMOVE THE KEYBOARD I/O
C  FOR IT.

      ICENT = 2

	WRITE(*,2011) NSUB
 2011   FORMAT(/' ',I4,' TABLES OF PREDICTED CONCENTRATIONS, ONE FOR'/
     1' EACH SUBJECT, WILL BE GENERATED TO BE USED AS INPUTS FOR AN'/
     2' "EFFECTS" MODEL.'//

     2' EACH TABLE WILL GIVE THE PREDICTED CONCENTRATIONS OF THE DRUG'/
     3' FOR A GIVEN SUBJECT, ASSUMING PARAMETER VALUES EQUAL TO THE  '/
     4' MEANS OF THE BAYESIAN POSTERIOR DISTRIBUTION OF THAT SUBJECT.'
     5/
     6' THIS WILL BE REPEATED FOR BOTH THE MEDIANS AND THE MODES OF'/
     7' THE BAYESIAN POSTERIOR DISTRIBUTION FOR EACH SUBJECT.'//
     8' THE PREDICTED CONCENTRATIONS WILL BE AT THE TIMES YOU SELECT'/
     9' BELOW. IN ADDITION, AUC (AREA UNDER THE CURVE) AND AUC/MIC'/
     1' WILL BE CALCULATED FOR EACH USER SELECTED INTERVAL, AND FOR'/
     2' THE TOTAL TIME PERIOD.'//)

 2015   WRITE(*,2013)
 2013   FORMAT(/' ENTER THE TIME INTERVAL (IN MINUTES) BETWEEN'/
     1' PREDICTED CONCENTRATIONS. THIS VALUE MUST BE 2, 4, 6, OR 12:  ')
	READ(*,*,ERR=2015) IDELTA

	IF(IDELTA .NE. 2 .AND. IDELTA .NE. 4 .AND. IDELTA .NE. 6
     1  .AND. IDELTA .NE. 12) GO TO 2015

        WRITE(*,2014) NSUB
 2014   FORMAT(/' THE ENDING TIME (IN HOURS), FOR THE PREDICTED'/
     1' CONCENTRATIONS WILL BE 24 HOURS AFTER THE LAST OBSERVATION'/
     2' TIME AMONG ALL ',I4,' SUBJECTS.')

C  THE ENDING TIME IS T_END, WHICH IS NO LONGER USED, AS OF bigmlt6.f.
C  BUT IT WILL STILL BE WRITTEN TO npag102.inp (NOW npag103.inp)
C  (FIXED VALUE = 99) SO THAT THE FORMAT OF THE FILE DOESN'T CHANGE.

 2025   WRITE(*,2016)
 2016   FORMAT(/' THE DEFAULT FOR THE MIC (MINIMUM INHIBITORY '/
     1' CONCENTRATION) IS 1.0; '/
     2' ENTER 1 FOR THIS DEFAULT VALUE;'/
     3' ENTER 0 TO ENTER A DIFFERENT VALUE: ')
	READ(*,*,ERR=2025) IXMIC
	IF(IXMIC .NE. 1 .AND. IXMIC .NE. 0) GO TO 2025


	IF(IXMIC .EQ. 1) XMIC = 1.D0

	IF(IXMIC .EQ. 0) THEN
 2030	 WRITE(*,2023)
 2023    FORMAT(/' ENTER THE MIC (IT MUST BE A POSITIVE NUMBER):  ')
	 READ(*,*,ERR=2030) XMIC
	 IF(XMIC .LE. 0.D0) GO TO 2030
	ENDIF

 3025   WRITE(*,3016)

 3016   FORMAT(/' THE AUC (AREA UNDER THE CURVE) AND AUC/MIC WILL BE'/

     9' CALCULATED OVER EACH AUCINT-HOUR INTERVAL, AND FOR THE TOTAL '/
     1' TIME PERIOD.'//
     2' ENTER 1 FOR THE DEFAULT VALUE FOR AUCINT OF 24 HOURS;'/
     3' ENTER 0 TO ENTER A DIFFERENT VALUE FOR AUCINT: ')
	READ(*,*,ERR=3025) IAUCINT
	IF(IAUCINT .NE. 1 .AND. IAUCINT .NE. 0) GO TO 3025


	IF(IAUCINT .EQ. 1) AUCINT = 24.D0

	IF(IAUCINT .EQ. 0) THEN
 3030	 WRITE(*,3023)
 3023    FORMAT(/' ENTER THE DESIRED VALUE FOR AUCINT (IN HOURS):  ')
	 READ(*,*,ERR=3030) AUCINT
	 IF(AUCINT .LE. 0.D0) GO TO 3030
	ENDIF

      CALL WRITEINFILE(6,PATHFILAST,IDELTA,XMIC,ICENT,
     1   AUCINT,AF,INDPTS,MAXCYC,JSTOP,TOLC,NUMEQT,C0P,C1P,C2P,C3P,
     2   IERRMOD,GAMLAM0,IASS,NOFIX,VALFIX,NVAR,AB,NSUB,NSUBTOT,MAXSUB,
     3   IPATVEC,IFORMT,BLOCKPAT,PREFIX,EXT,NDRUG,FORFILE,NDIM,NP,IRAN,
     4   PAR,PARFIX,TOLER,INPRI,PRIFIL2,MAXNUMEQ,NRANFIX,PARRANFIX,
     5   RANFIXEST)

C  END OF INPUTTING INFO VIA THE KEYBOARD.


	ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(IFIL .EQ. 0)  OPTION.


	ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(INOPT1 .EQ. 0)  OPTION.



C  IF IAF = 0, IT MEANS THAT AFSCALAR WAS READ IN, BUT ALL THE 
C  AF(I), I=1,NDRUG, HAVE NOT YET BEEN SET = AFSCALAR,
C  SINCE NDRUG WAS NOT AVAILABLE AT THE TIME. IN THIS CASE, CALL
C  GETNUMEQ TO ESTABLISH NDRUG, AND THEN SET ALL AF(I) = AFSCALAR.

C  NOTE THAT SUBROUTINE GETNUMEQ READS ONE PATIENT DATA FILE, OR THE
C  PATIENT INFO IN BLOCKPAT, TO GET THE NO. OF OUTPUT EQUATIONS
C  (NUMEQT), AND THE NO. OF DRUGS (NDRUG). THE 3RD ARGUMENT TO GETNUMEQ
C  IS 1 --> THE CALL IS FROM MAIN.

        IF(IAF .EQ. 0) THEN

         CALL GETNUMEQ(PATH,NOB,1,IFORMT,PREFIX,EXT,BLOCKPAT,NUMEQT,
     1    NDRUG,MAXSUB,MAXNUMEQ)


C  CHECK THAT NUMEQT IS .LE. MAXNUMEQ.

      IF(NUMEQT .GT. MAXNUMEQ) THEN

       WRITE(*,8317) NUMEQT,MAXNUMEQ

       OPEN(42,FILE=ERRFIL)
        WRITE(42,8317) NUMEQT,MAXNUMEQ 
       CLOSE(42)

       CALL PAUSE
       STOP

      ENDIF



          DO I = 1,NDRUG
           AF(I) = AFSCALAR
          END DO         

         ENDIF


C  USER MAY DECIDE TO USE THE DEFAULT APRIORI DENSITY (UNIFORM), OR A
C  DENSITY TO BE READ IN.

        WRITE(*,4311) NVAR
 4311   FORMAT(///' THE APRIORI DENSITY IS DEFINED ON A ',I1,'  ' /
     1' DIMENSIONAL GRID BOUNDED BY THE LIMITS ENTERED ABOVE.'//
     2' ENTER 1 IF A UNIFORM PRIOR IS DESIRED;'/
     3' ENTER 0 IF A SPECIFIED PRIOR IS TO BE READ IN FROM A '/
     4'         USER-SUPPLIED FILE OF DENSITY VALUES '/
     5'         FROM THE OUTPUT OF A PREVIOUS RUN.'//
     6' (CAUTION: BEFORE USING A PREVIOUS JOINT DENSITY, THE USER'/
     7' SHOULD VERIFY THAT IT WAS DEFINED FOR THE SAME NO. OF GRID'/
     8' POINTS, AND FOR THE SAME PARAMETERS AND RANGES AS ENTERED'/
     9' ABOVE FOR THIS RUN):  ')
 4315   READ(*,*,ERR=4320) INPRI
        GO TO 4325
 4320   WRITE(*,4035)
        GO TO 4315

 4325   IF (INPRI .NE. 0 .AND. INPRI .NE. 1) THEN
         WRITE(*,138)
         GO TO 4315
        ENDIF


	IF(INPRI .EQ. 0) THEN

 4340	WRITE(*,4341)
 4341   FORMAT(/' ENTER THE NAME OF THE FILE HAVING THE '/
     1' DENSITY VALUES FROM THE END OF A PREVIOUS RUN (THIS'/
     2' FILE ALSO HAS ASSOCIATED INSTRUCTIONS); ')


	WRITE(*,*)' ENTER -99 TO SEE ALL OR A PART OF YOUR DIRECTORY: '
        READ(*,2) PRIFIL2
	IF(PRIFIL2(1:3) .EQ. '-99') THEN
       CALL SEEDIR(PATH,NOB,PRIFIL2,OSName,ListDir)

      ENDIF

      ENDIF 
C  THE ABOVE ENDIF IS FOR THE  IF(INPRI .EQ. 0)  CONDITION.


      CALL WRITEINFILE(7,PATHFILAST,IDELTA,XMIC,ICENT,
     1   AUCINT,AF,INDPTS,MAXCYC,JSTOP,TOLC,NUMEQT,C0P,C1P,C2P,C3P,
     2   IERRMOD,GAMLAM0,IASS,NOFIX,VALFIX,NVAR,AB,NSUB,NSUBTOT,MAXSUB,
     3   IPATVEC,IFORMT,BLOCKPAT,PREFIX,EXT,NDRUG,FORFILE,NDIM,NP,IRAN,
     4   PAR,PARFIX,TOLER,INPRI,PRIFIL2,MAXNUMEQ,NRANFIX,PARRANFIX,
     5   RANFIXEST)


1230   CONTINUE
C  1230 IS THE LABEL TO WHICH CONTROL IS TRANSFERRED IF THE USER
C  ENTERED INFO USING THE IALLIN = 1 OPTION ABOVE.


C  PRINT TO THE SCREEN ALL INPUT INFO FOR VERIFICATION IF IVERIFY = 1.

      IF(IVERIFY .EQ. 1)
     1 CALL VERIF1(PATHFILAST,IDIRCT,PREFIX,EXT,IFORMT,NVAR,PAR,AB,C0P,
     1   C1P,C2P,C3P,IASS,AF,MAXCYC,JSTOP,TOLC,INDPTS,NOFIX,VALFIX,
     2   PARFIX,IDELTA,XMIC,ICENT,NUMEQT,IALLPAT,ASSMULT,PATH,NOB,
     3   IERRMOD,GAMLAM0,NSUBTOT,NSUB,ISUBALL,MAXSUB,IPATVEC,BLOCKPAT,
     4   AUCINT,OSName,ClearScreen,ListDir,NDRUG,TOLER,INPRI,PRIFIL2,
     5   NDIM,RTOL,ATOL,IRAN,FORFILE,MAXNUMEQ,NRANFIX,PARRANFIX,
     6   RANFIXEST)


C  IF IFORMT = 1, THE PATIENT DATA FILES ARE READY TO BE READ IN BY
C  THE PROGRAM (THEY ARE ALREADY IN WORKING COPY FORMAT).
C  IF IFORMT = 3, THE PATIENT DATA INFO IS IN FILE BLOCKPAT, IN
C  BLOCK FORMAT, AND MUST NOW BE CONVERTED INTO WORKING COPY PATIENT
C  FORMAT.

	IF(IFORMT .EQ. 3) THEN

C  AS OF NPAG111.FOR:
C  CHECK TO SEE IF THERE ARE NSUBTOT FILES, XQZPJ001.ZMQ,... IN THE
C  WORKING DIRECTORY. IF NOT, CONTINUE AS ALWAYS. BUT IF SO, THESE
C  MAY BE WORKING COPY FILES ALREADY CREATED FROM THE .csv FILE INPUT
C  ABOVE INTO BLOCKPAT. AND IN THIS CASE, CHECK WITH THE USER TO SEE IF
C  THE PROGRAM CAN SIMPLY USE THESE FILES, RATHER THAN CREATING THEM
C  AGAIN FROM THE .csv FILE (WHICH CAN TAKE A LOT OF TIME IF THERE IS A
C  LARGE PATIENT POPULATION).

      DO ISUB = 1,NSUBTOT

       PATFIL="XQZPJ"//NUMBER(ISUB)//'.ZMQ'

C  CALL FULLNAME WHICH CONVERTS THE FILENAME TO PATHFILE, THE COMPLETE
C  NAME OF THE FILE, WHICH INCLUDES THE PATH (IF THE PATH IS NOT THE
C  CURRENT DIRECTORY).

       TMPFILE = ' '
       TMPFILE = PATFIL
       CALL FULLNAME(PATH,TMPFILE,PATHFILE)
       OPEN(81,FILE=PATHFILE,ERR=7770,STATUS='OLD')
       CLOSE(81)


      END DO

C  THE ABOVE END DO IS FOR THE  DO ISUB = 1,NSUBTOT  LOOP.

C  TO GET TO THIS POINT MEANS THAT NSUBTOT WORKING COPY FILES,
C  XQZPJ001.ZMQ,... EXIST IN THE WORKING DIRECTORY. SO ASK THE USER IF
C  THESE ARE, INDEED, WORKING COPY FILES CREATED FROM HIS .csv FILE. IF
C  SO, THE PROGRAM CAN USE THEM RATHER THAN RECREATE THEM FROM THE .csv
C  FILE.

C  BUT DON'T DO THIS IF IALLIN = 1 AND IVERIFY = 0, BECAUSE IN THIS
C  CASE THE PROGRAM IS TO RUN WITHOUT AND MORE USER INTERACTION. IN THIS
C  CASE, MUST TAKE THE SAFE ROUTE AND PROCEED AS IF ILONG = 1.

      IF(IALLIN .EQ. 1 .AND. IVERIFY .EQ. 0) GO TO 7770

 7780 WRITE(*,7771) NSUBTOT,BLOCKPAT,BLOCKPAT,BLOCKPAT,BLOCKPAT
 7771 FORMAT(//' THERE ARE ALREADY ',I6,' WORKING COPY FILES BY THE '/
     1' NAMES OF XQZPJ001.ZMQ,... IN THE CURRENT WORKING DIRECTORY.'//
     2' IF THESE WERE THE ONES CREATED BY THE PROGRAM FROM A PREVIOUS'/
     3' RUN WITH YOUR .csv FILE, ',A20,' YOU CAN SIMPLY USE THEM '/
     4' AGAIN, RATHER THAN RECREATE THEM FROM ',A20//
     5' THIS COULD SAVE A LOT OF TIME IF YOU HAVE A LARGE PATIENT '/
     6' POPULATION. OF COURSE IF THESE WORKING COPY FILES DID NOT COME'/
     7' FROM ',A20,' ENTER 1 BELOW.'//
     8' ENTER 1 TO CREATE ANOTHER SET OF WORKING COPY FILES FROM YOUR'/
     9'         .csv FILE, ',A20/
     1' ENTER 0 TO SAVE TIME BY USING THE XQZPJ001.ZMQ,... FILES WHICH'/
     2'         ALREADY EXIST IN YOUR WORKING DIRECTORY: ')
      READ(*,*,ERR=7780) ILONG
      IF(ILONG .NE. 1 .AND. ILONG .NE. 0) GO TO 7780

C  IF ILONG = 1, SIMPLY CONTINUE, AND RECREATE THE XQZPJ001.ZMQ FILES
C  AGAIN. IF ILONG = 0, GO TO 7790, WHICH SKIPS THE REST OF THIS
C  IF(IFORMT .EQ. 3)  SECTION, SINCE THE XQZPJ001.ZMQ FILES WHICH
C  ALREADY EXIST ARE GOING TO BE USED.

      IF(ILONG .EQ. 0) GO TO 7790
          

 7770  CONTINUE

C  TO GET TO THIS POINT MEANS THAT AT LEAST ONE OF THE NSUBTOT WORKING 
C  COPY FILES, XQZPJ001.ZMQ,..., DOES NOT EXIST, OR IALLIN = 1 AND
C  IVERIFY = 0 (WHICH MEANS THAT THE XQZPJ001.ZMQ FILES ARE BEING
C  RECREATED JUST TO BE SAFE), OR USER CHOSE ILONG = 1 ABOVE, AGAIN
C  TO BE SAFE. IN THIS CASE, SIMPLY CONTINUE, LEAVING IFORMT = 3.

C  CALL SUBROUTINE READBLOCK TO READ ALL PATIENT DATA INFO FROM FILE,
C  BLOCKPAT, AND CONVERT IT INTO NSUBTOT WORKING COPY PATIENT DATA
C  FILES. FIRST OPEN BLOCKPAT AS FILE 87. NOTE THAT THE 1ST ARGUMENT
C  TO READBLOCK --> CALL IS FROM MAIN.

      TMPFILE = ' '
	TMPFILE = BLOCKPAT
	CALL FULLNAME(PATH,TMPFILE,PATHFILE)
	OPEN(87,FILE=PATHFILE,STATUS='OLD')

C  AS OF NPAG104.FOR, BEFORE CALLING NEWCSV, MUST CALL CONVERTCSV,
C  WHICH CONVERTS A "EUROPEAN" .CSV FILE TO THE TYPICAL "AMERICAN"
C  VERSION. IF THE .CSV FILE IS ALREADY IN THE "AMERICAN" FORMAT,
C  CONVERTCSV SIMPLY REWRITES FILE 87 TO SCRATCH FILE 77. NOTE THAT
C  NEWCSV CONVERTS FILE 77 TO FILE 67.

        CALL CONVERTCSV

C  CALL SUBROUTINE NEWCSV WHICH CONVERTS THE .CSV FILE IN FILE 77 TO
C  A NEW .CSV FILE IN FILE 67, WITH ALL MISSING VALUE DOTS CHANGED TO
C  n's. THEN CALL CSVCHANGE WHICH CHANGES .csv FILES WITH CODE OF
C  POPDATA DEC_11 (I.E., THOSE WITH 2 EXTRA COLUMNS FOR ADDL AND II)
C  TO EQUIVALENT .csv FILES WITH CODE OF POPDATA APR_11 (THOSE WITHOUT
C  THE TWO EXTRA COLUMNS). CSVCHANGE READS FILE 67, AND WRITES THE 

C  INFORMATION TO SCRATCH FILE 66. NOTE THAT IF THE .csv FILE READ IN
C  ALREADY IS THE OLDER VERSION (WITH CODE POPDATA APR_11), CSVCHANGE

C  SIMPLY REWRITES IT TO FILE 66, WHICH IS THEN READ BY SUBROUTINE
C  READBLOCK.

        OPEN(67)

C        WRITE(*,1234)
C1234   FORMAT(/' IF YOU HAVE A LARGE DATA SET, THERE COULD BE A LONG'/
C    1' DELAY (SEVERAL SECONDS TO A MINUTE OR MORE) BEFORE YOU SEE AN'/
C    2' INDICATION THAT THE PROGRAM IS EXAMINING YOUR PATIENT DATA. '//
C    3' THE PROGRAM HAS NOT "HUNG". THIS MIGHT BE A GOOD TIME FOR SOME'/
C    4' QUIET INTROSPECTION ... ')


        CALL NEWCSV
        CALL CSVCHANGE
        REWIND(66)
        CALL READBLOCK(1,NSUBR,MAXSUB,NOUT,NDRUG,PATH,C0P,C1P,C2P,C3P,
     1   MAXNUMEQ)

        CLOSE(66)


C  READBLOCK HAS NOW CONVERTED THE BLOCKPAT FILE INFO INTO NSUBR
C  WORKING COPY PATIENT DATA FILES, WITH THE NAMES,
C  XQZPJ001.ZMQ, XQZPJ002.ZMQ.

C  NOTE THAT NSUBTOT AND NSUB HAVE ALREADY BEEN READ IN ABOVE, SO THERE
C  MUST BE COMPATIBILITY WITH THOSE VALUES AND THE NO. OF PATIENTS IN
C  THE BLOCK FORMAT - I.E., NSUBTOT SHOULD BE THE SAME AS THE NO. OF
C  PATIENTS IN THE BLOCK FORMAT, NSUBR. IF THIS IS NOT TRUE, INFORM
C  THE USER AND STOP.


	 IF(NSUBTOT .NE. NSUBR) THEN

	  WRITE(*,1011) NSUBTOT,BLOCKPAT,NSUBR
 1011     FORMAT(/' THE NO. OF TOTAL SUBJECTS IN YOUR PATIENT DATA'/
     1' SET WAS READ IN AS ',I4,' BUT THE NO. OF SUBJECTS IN YOUR'/
     2' BLOCK PATIENT DATA FILE, ',A20,' IS ',I4,'. THESE NUMBERS'/
     3' MUST BE THE SAME. PLEASE CHECK YOUR PATIENT DATA AND RERUN'/
     4' THIS PROGRAM.'/)
	  CALL PAUSE

        OPEN(42,FILE=ERRFIL)
         WRITE(42,1011) NSUBTOT,BLOCKPAT,NSUBR 
        CLOSE(42)

	  STOP

	 ENDIF


C  AS OF NPAG112.FOR, MUST CALL WRITEINFILE WITH FIRST ENTRY = 8 SO
C  THAT ROUTINE WILL WRITE THE CORRECT VALUES FOR ICOVTYPE AND
C  COVNAME (WHICH HAVE JUST BEEN READ BY SUBROUTINE READBLOCK, AND
C  PUT INTO COMMON/TOWRITE FOR WRITEINFILE). ... BUT DON'T DO THIS
C  IF IALLIN = 1 AND IVERIFY = 0, SINCE IT THAT CASE THE FILE THAT
C  WRITEINFILE MAKES IS IRRELEVANT, SINCE THE USER IS RUNNING THE
C  PROGRAM WITH AN INSTRUCTION FILE THAT IS NOT CHANGED.

      IF(IALLIN .EQ. 0 .OR. IVERIFY .EQ. 1)
     1 CALL WRITEINFILE(8,PATHFILAST,IDELTA,XMIC,ICENT,
     1   AUCINT,AF,INDPTS,MAXCYC,JSTOP,TOLC,NUMEQT,C0P,C1P,C2P,C3P,
     2   IERRMOD,GAMLAM0,IASS,NOFIX,VALFIX,NVAR,AB,NSUB,NSUBTOT,MAXSUB,
     3   IPATVEC,IFORMT,BLOCKPAT,PREFIX,EXT,NDRUG,FORFILE,NDIM,NP,IRAN,
     4   PAR,PARFIX,TOLER,INPRI,PRIFIL2,MAXNUMEQ,NRANFIX,PARRANFIX,
     5   RANFIXEST)

	ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(IFORMT .EQ. 3)  CONDITION.

7790  CONTINUE



C  GO THROUGH ALL NSUBTOT SUBJECTS AND MAKE SURE ALL FILES HAVE THE
C  DESIRED ASSAY COEFFICENTS AT THE END OF THEIR WORKING COPY FILES. IF
C  THEY DON'T, PUT THEM THERE.

	WRITE(*,2401)
 2401   FORMAT(//' EXAMINING ALL WORKING COPY PATIENT DATA FILES TO '/
     1' MAKE SURE THEY ALL HAVE THE APPROPRIATE ASSAY COEFFICIENTS '/
     2' WRITTEN TO THEIR FILES ... '/)

	MAXOBS = 0


C  MAXOBS WILL BE THE RUNNING MAX NO. OF OBSERVATION TIMES AMONG ALL THE
C  SUBJECTS; IT WILL BE USED IN THE CALL TO CALCLIMIT BELOW.

C  INITIALIZE NCSTORE(IEQ) = 0. DURING THE DO 2400 LOOP, NCSTORE(IEQ) IS
C  THE RUNNING NO. OF EXTRA SETS OF GENERAL COEFFICIENTS THAT THE USER
C  HAS CHOSEN TO SAVE IN GENCOEF(IEQ,.,.) FOR ASSIGNMENT TO SUBSEQUENT
C  PATIENT DATA FILES, FOR OUTPUT EQ. IEQ.

	DO I=1,NUMEQT
	 NCSTORE(IEQ) = 0
	END DO

C    CONSIDER ONLY USING PUTASS TO CHECK THE NSUB SUBJECTS THAT ARE

C    GOING TO BE USED IN THE ANALYSIS, NOT ALL NSUBTOT.

      DO ISUB=1,NSUBTOT

       WRITE(*,8889) ISUB
 8889  FORMAT(' SUBJECT NO. ',I6)

C  CALL SUBROUTINE PUTASS TO MAKE SURE THAT ALL THE WORKING COPY PATIENT
C  FILES HAVE ASSAY COEFFICIENTS WRITTEN AT THE END OF THEM.


       IF(IFORMT .EQ. 1) PATFIL=PREFIX//NUMBER(ISUB)//'.'//EXT
       IF(IFORMT .EQ. 3) PATFIL="XQZPJ"//NUMBER(ISUB)//'.ZMQ'

C  CALL FULLNAME WHICH CONVERTS THE FILENAME TO PATHFILE, THE COMPLETE
C  NAME OF THE FILE, WHICH INCLUDES THE PATH (IF THE PATH IS NOT THE
C  CURRENT DIRECTORY).

      TMPFILE = ' '
      TMPFILE = PATFIL
      CALL FULLNAME(PATH,TMPFILE,PATHFILE)

      CALL PUTASS(PATHFILE,IASS,C0P,C1P,C2P,C3P,MAXOBS,NUMEQT,
     1 IALLPAT,ASSMULT,GENCOEF,NCSTORE,MAXOBDIM,YO,MAXNUMEQ)


      END DO


C  AS OF NPBIG10.FOR, SUBROUTINE CALCLIMIT WILL NO LONGER BE CALLED AND
C  THE SUBSEQUENT WRITE STATEMENTS WILL NO LONGER BE WRITTEN TO THE
C  SCREEN. THESE VALUES WERE PROBABLY OUTDATED ANYWAY.


 	IF(INDPTS .EQ. 1) NGRID=2129
	IF(INDPTS .EQ. 2) NGRID=5003
	IF(INDPTS .EQ. 3) NGRID=10007
	IF(INDPTS .EQ. 4) NGRID=20011
	IF(INDPTS .EQ. 5) NGRID=40009
	IF(INDPTS .EQ. 6) NGRID=80021
	IF(INDPTS .GT. 6) NGRID = 80021*(INDPTS - 100)


C  NOTE: STARTING WITH M2_11.FOR, INDPTS MAY BE .GT. 6. IN SUCH A CASE,
C        THE BOUNDARY OF THE 1ST VARIABLE IS DIVIDED INTO (INDPTS-100)
C	 REGIONS, EACH OF WHICH GETS 80021 GRID POINTS.


C  CALL SUBROUTINE MAKEDRIV, WHICH CREATES npagdriv.f, WHICH WILL BE
C  THE "MAIN" OF THE WHOLE NPAG "ENGINE". FORFILE, THE MODEL FILE
C  ENTERED BY THE USER, WILL BE APPENDED TO THE END OF npagdriv.f, SO
C  ONLY ONE .f FILE WILL HAVE TO BE UPLOADED TO THE MAINFRAME.

C  THIS "MAIN" HAS A PARAMETER STATEMENT WHICH DEFINES THE PARAMETERS
C  WHICH DEFINE THE DIMENSIONS IN THE VARIABLY DIMENSIONED ARRAYS, ALONG
C  WITH A DIMENSION STATEMENT WITH ALL ARRAYS WHICH DEPEND OF THESE
C  VALUES. IT THEN HAS THE STATEMENT:
C  CALL NPAG( ...) , WHERE ALL VARIABLY DIMENSIONED ARRAYS (AND THE
C  VARIABLE PARAMETER DIMENSIONS) ARE PASSED TO NPAG, WHICH IS NOW
C  THE MAIN MODULE OF THE "ENGINE".

	CALL MAKEDRIV(PATH,NOB,FORFILE,NSUBTOT,NVAR,NGRID,NUMEQT,
     1MAXOBS,OSName,CopyFile,DeleteFile)

C  NOTE THAT ALL PATIENT DATA FILES WILL BE CONCATENATED ONTO THE END
C  OF npag103.inp.


      IF(INPRI .EQ. 0) THEN


C  CALL FULLNAME WHICH CONVERTS THE FILENAME TO PATHFILE, THE COMPLETE
C  NAME OF THE FILE, WHICH INCLUDES THE PATH (IF THE PATH IS NOT THE
C  CURRENT DIRECTORY).

     	TMPFILE = ' '
	TMPFILE = PRIFIL2

	CALL FULLNAME(PATH,TMPFILE,PATHFILE)
	OPEN(34,FILE=PATHFILE,ERR=4345,STATUS='OLD')
	GO TO 4350
 4345 WRITE(*,5316) PATHFILE
	
C  SINCE THIS FILE DOESN'T EXIST, DEFAULT TO A UNIFORM PRIOR, BUT TELL
C  THE USER SO HE CAN STOP THE PROGRAM IF HE WANTS TO.

      WRITE(*,7181)
      CALL PAUSE
      GO TO 7180

C  READ THE DENSITY VALUES INTO CORDEN. ALSO READ OTHER VALUES.

 4350   CONTINUE


C  THE ALLOWABLE CODES ON THE FIRST LINE OF FILE 34, THE PRIOR DENSITY
C  FILE, ARE DENSITY FEB_97, DENSITY JUN_09, DENSITY APR_10, AND
C  DENSITY OCT_15. THE LAST ONE DIFFERS FROM THE FIRST 3 IN THAT IT
C  CONTAINS INFO ON THE RANFIX PARAMETERS.

C  IF THE PRIOR DENSITY FILE DOES NOT HAVE ONE OF THESE 4 CODES, TELL
C  THE USER THE FILE IS DISALLOWED.

      READ(34,7123) CODE

      ICODEPRI = 0
      IF(CODE .EQ. 'DENSITY FEB_97') ICODEPRI = 1
      IF(CODE .EQ. 'DENSITY JUN_09') ICODEPRI = 1
      IF(CODE .EQ. 'DENSITY APR_10') ICODEPRI = 1
      IF(CODE .EQ. 'DENSITY OCT_15') ICODEPRI = 2
      IF(CODE .EQ. 'DENSITY MAR_16') ICODEPRI = 2
C  NOTE THAT A CODE OF "DENSITY MAR_16" COMES FROM A DENSITY FILE
C  MADE BY AN IT2B RUN (it2branfix1.f WAS THE FIRST IN THE "ENGINE"
C  MODULES TO MAKE A DENSITY FILE WITH THIS CODE).


      IF(ICODEPRI .EQ. 0) THEN

       WRITE(*,8181)
 8181  FORMAT(//' YOU ARE TRYING TO USE A DENSITY FILE MADE BY AN'/
     1' OBSOLETE VERSION OF THE PROGRAM.'//
     2' A SAVED DENSITY FILE MUST HAVE DENSITY XXX_XX ON LINE 1, WHERE'/
     3' XXX_XX IS FEB_97, JUN_09, APR_10, OR OCT_15.'/)


      WRITE(*,7181) 
 7181 FORMAT(/' THIS RUN WILL BE CHANGED TO USE A UNIFORM DENSITY.'/
     1' IF THIS IS NOT WHAT YOU WANT, STOP THE PROGRAM NOW, AND RERUN'/
     2' WITH A DENSITY FILE WITH ONE OF THE ABOVE CODES ON THE 1ST'/
     3' LINE. '//)
      CALL PAUSE

      GO TO 7180
      
      ENDIF


	READ(34,*) NNDIM

	IF(NNDIM .NE. NDIM) THEN
	 NDIM=NNDIM
	  WRITE(*,4371) NDIM
 4371     FORMAT(/' THE NO. OF COMPARTMENTS ENTERED ABOVE DOES NOT'/
     1' MATCH THE NO. FROM THE PREVIOUS RUN. THE NO. OF COMPARTMENTS'/
     2' HAS BEEN CHANGED TO BE ',I5,'.')


	ENDIF


	READ(34,*) IIND

	IF(IIND .NE. INDPTS) THEN

	  INDPTS=IIND
	  IF(INDPTS .EQ. 1) NGRID=2129
	  IF(INDPTS .EQ. 2) NGRID=5003
	  IF(INDPTS .EQ. 3) NGRID=10007
	  IF(INDPTS .EQ. 4) NGRID=20011
	  IF(INDPTS .EQ. 5) NGRID=40009
	  IF(INDPTS .EQ. 6) NGRID=80021
	  IF(INDPTS .GT. 6) NGRID=80021*(INDPTS-100)

	  WRITE(*,4351) NGRID
 4351     FORMAT(/' THE NO. OF GRID POINTS ENTERED ABOVE DOES NOT'/
     1' MATCH THE NO. FROM THE PREVIOUS RUN. THE NO. OF GRID POINTS'/
     2' HAS BEEN CHANGED TO BE ',I5,'.')

	ENDIF

	READ(34,*) NACTVE

C  NOTE THAT NACTVE MUST BE .LE. MAXGRD BECAUSE OF CORDEN'S DIMENSIONS
C  (CORDEN BELOW READS IN THE NACTVE GRID POINTS).

	IF(NACTVE .GT. MAXGRD) THEN

	 WRITE(*,1718) NACTVE,MAXGRD,MAXGRD
 1718    FORMAT(//' THE NO. OF ACTIVE GRID POINTS IS ',I7,' WHICH IS'/
     1' MORE THAN THE MAXIMUM ALLOWED FOR THIS PROGRAM (',I7,'). RERUN'/
     2' THIS PROGRAM AFTER YOU HAVE REDUCED THE NO. OF GRID POINTS IN'/
     3' THE DENSITY FILE TO NO MORE THAN ',I7//)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,1718) NACTVE,MAXGRD,MAXGRD 
        CLOSE(42)

	 CALL PAUSE
	 STOP

	ENDIF

	READ(34,*) NNVA
	DO I=1,NNVA
	 READ(34,1717) PPAR(I)
	END DO
 1717   FORMAT(A11)

	ICHANG=0
	IF(NNVA .NE. NVAR) ICHANG=1
	DO I=1,NNVA
	IF(PPAR(I) .NE. PAR(I)) ICHANG=1
	END DO

	IF(ICHANG .EQ. 1) THEN

	WRITE(*,4352) (PPAR(I),I=1,NNVA)
 4352   FORMAT(/' THE RANDOM PARAMETERS DO NOT MATCH THOSE FROM THE'/
     1' PREVIOUS RUN. PLEASE ENSURE COMPATIBILITY BETWEEN THE APRIORI'/
     2' DENSITY FILE AND THE MODEL AND PARAMETERS YOU SELECT. THEN'//
     3' RERUN THIS PROGRAM.'//)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,4352) (PPAR(I),I=1,NNVA) 
        CLOSE(42)

	CALL PAUSE
	STOP

	ENDIF


	READ(34,*) NNOF
	DO I=1,NNOF
	 READ(34,1717) PPARFX(I)
	END DO

	ICHANG=0
	IF(NNOF .NE. NOFIX) ICHANG=1
	DO I=1,NNOF
	IF(PPARFX(I) .NE. PARFIX(I)) ICHANG=1
	END DO

	IF(ICHANG .EQ. 1) THEN

	WRITE(*,6426)
 6426   FORMAT(/' THE FIXED PARAMETERS DO NOT MATCH THE ONES FROM THE'/
     1' PREVIOUS RUN. PLEASE ENSURE COMPATIBILITY BETWEEN THE APRIORI'/
     2' DENSITY FILE AND THE MODEL AND PARAMETERS YOU SELECT. THEN '/
     3' RERUN THIS PROGRAM.'//)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,6426) 
        CLOSE(42)

	CALL PAUSE
	STOP

	ENDIF


      IF(ICODEPRI .EQ. 1) THEN

C  CHECK THAT NRANFIX (ENTERED ABOVE IN THE INSTRUCTION FILE OR VIA
C  THE KEYBOARD) = 0. OTHERWISE IS TRYING TO USE A PRIOR DENSITY FILE
C  WITHOUT RANFIX PARAMETERS EVEN THOUGH HE HAS SPECIFIED THAT THERE
C  ARE RANFIX PARAEMTERS IN THIS RUN.

       IF(NRANFIX .GT. 0) THEN
        WRITE(*,8182) NRANFIX
 8182   FORMAT(/' THIS RUN IS SET TO HAVE ',I2,' RANFIX PARAMETERS, '/
     1' AND YET YOU HAVE JUST SPECIFIED A PRIOR DENSITY WHICH HAS NO'/
     2' RANFIX PARAMETERS. SO ...'/)
        WRITE(*,7181) 
        CALL PAUSE
        GO TO 7180
       ENDIF

      ENDIF



      IF(ICODEPRI .EQ. 2) THEN
      
       READ(34,*) NNRANFIX
       DO I=1,NNRANFIX
        READ(34,1717) PPARRANFIX(I)
       END DO

       ICHANG=0
       IF(NNRANFIX .NE. NRANFIX) ICHANG=1
       DO I=1,NNRANFIX
        IF(PPARRANFIX(I) .NE. PARRANFIX(I)) ICHANG=1
       END DO

       IF(ICHANG .EQ. 1) THEN

        WRITE(*,7426)
 7426   FORMAT(/' THE RANFIX PARAMETERS DO NOT MATCH THE ONES FROM THE'/
     1' PREVIOUS RUN. PLEASE ENSURE COMPATIBILITY BETWEEN THE APRIORI'/
     2' DENSITY FILE AND THE MODEL AND PARAMETERS YOU SELECT. THEN'/
     3' RERUN THIS PROGRAM.'//)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,7426) 
        CLOSE(42)

        CALL PAUSE
        STOP

       ENDIF

      ENDIF
C  THE ABOVE ENDIF IS FOR THE  IF(ICODEPRI .EQ. 2)  CONDITION.


	ICHANG = 0
	DO I=1,NNVA
	READ(34,*) (AAB(I,J),J=1,2)
	IF(AAB(I,1) .NE. AB(I,1) .OR. AAB(I,2) .NE. AB(I,2)) THEN
	  AB(I,1)=AAB(I,1)
	  AB(I,2)=AAB(I,2)
	  ICHANG=1
	ENDIF
	END DO

	IF(ICHANG .EQ. 1) THEN

	  WRITE(*,4354)
 4354   FORMAT(/' THE RANDOM PARAMETER RANGES ENTERED ABOVE DO NOT '/
     1' MATCH THE ONES FROM THE PREVIOUS RUN. THE RANGES HAVE BEEN '/
     2' CHANGED TO THE FOLLOWING: ')

	DO I=1,NVAR
	WRITE(*,1217) PAR(I),AB(I,1),AB(I,2)
	END DO
 1217   FORMAT(/' ',A11,': ',G17.10,'   TO   ',G17.10)

	ENDIF

	ICHANG=0
	READ(34,*) (VVALFX(I),I=1,NOFIX)

	DO I=1,NOFIX

	IF(VALFIX(I) .NE. VVALFX(I)) THEN
	VALFIX(I)=VVALFX(I)
	ICHANG=1
	ENDIF

	END DO

	IF(ICHANG .EQ. 1) THEN

	WRITE(*,6422)
 6422   FORMAT(/' THE FIXED PARAMETER VALUES ENTERED ABOVE DO NOT '/
     1' MATCH THE ONES FROM THE PREVIOUS RUN. THE VALUES HAVE BEEN'/
     2' CHANGED TO THE FOLLOWING: ')

	DO I=1,NOFIX
	WRITE(*,6423) PARFIX(I),VALFIX(I)
	END DO
 6423   FORMAT(' ',A11,':  ',G17.10)

	ENDIF


      IF(ICODEPRI .EQ. 2) THEN

       ICHANG=0
       READ(34,*) (RRANFIXEST(I),I=1,NRANFIX)

       DO I=1,NRANFIX
        IF(RANFIXEST(I) .NE. RRANFIXEST(I)) THEN
         RANFIXEST(I) = RRANFIXEST(I)
         ICHANG=1
        ENDIF
       END DO

       IF(ICHANG .EQ. 1) THEN
        WRITE(*,7422)
 7422   FORMAT(/' THE RANFIX PARAMETER VALUES ENTERED ABOVE DO NOT '/
     1' MATCH THE ONES FROM THE PREVIOUS RUN. THE VALUES HAVE BEEN'/
     2' CHANGED TO THE FOLLOWING: ')
        DO I=1,NRANFIX
         WRITE(*,6423) PARRANFIX(I),RANFIXEST(I)
        END DO
       ENDIF

      ENDIF
C  THE ABOVE ENDIF IS FOR THE  IF(ICODEPRI .EQ. 2)  CONDITION.




C  AS OF MXEM2N36.FOR, NINT IS HARDCODED TO BE 100.

C  BUT THE READ TO AND WRITE FROM THE PRIOR DENSITY FILE WILL STILL
C  INCLUDE NINT ... SO THAT PRIOR DENSITY FILES FROM PREVIOUS PROGRAMS
C  CAN STILL BE RUN.

	READ(34,*) NNINT

	IF(NINT .NE. NNINT) THEN

	NINT=NNINT
	WRITE(*,6424) NINT
 6424   FORMAT(' THE NUMBER OF INTERVALS TO BE USED IN CALCULATING THE'/
     1' MARGINAL DENSITIES DOES NOT MATCH THAT OF THE PREVIOUS RUN. '/
     2' THIS NUMBER HAS BEEN CHANGED TO: ',I3)


	ENDIF

	READ(34,*) ICYCLE
	READ(34,*) DORIG

	DO I=1,NACTVE
	READ(34,*) (CORDEN(I,J),J=1,NVAR+1)
	END DO


C  NOTE THAT THE REST OF THE DENSITY FILE (PYJGX, YPREDPOP, YPREDPOPT
C  AND YPREDBAY VALUES) IS NOT NEEDED.

	CLOSE(34)




	WRITE(*,4356) ICYCLE,ICYCLE+1,MAXCYC+ICYCLE
 4356   FORMAT(/' THE PREVIOUS RUN COMPLETED ',I5,' CYCLES, SO THIS'/
     1' RUN WILL START WITH CYCLE NO. ',I5,', AND GO THROUGH CYCLE '/
     2' NO. ',I5,', UNLESS STOPPED FIRST BY THE TOLERANCE CRITERION.'//)

C  IF MAXCYC = 0, DO NOT CHANGE IT. OTHERWISE, SET IT = TO
C  MAXCYC + ICYCLE, SO MAXCYC NEW CYCLES WILL BE DONE.


	IF(MAXCYC .GT. 0) MAXCYC = MAXCYC + ICYCLE


	ENDIF

C  THE ENDIF ABOVE IS FOR THE  IF(INPRI .EQ. 0)  OPTION.


      GO TO 7185

C  NOTE THAT IF CONTROL IS TRANSFERRED TO 7180 FROM THE ABOVE 
C  IF(INPRI .EQ. 0) SECTION, INPRI WILL CHANGE TO 1. OTHERWISE,
C  CONTROL GOES TO 7185 WHERE INPRI IS UNCHANGED.

 7180 INPRI = 1

 7185 IF(INPRI .EQ. 1) ICYCLE=0


C  STORE THE INPUT VALUES INTO THE FILE npag103.inp, WHICH WILL BE
C  INPUT BY THE NPAG "engine".

C  CALL FULLNAME WHICH CONVERTS THE FILENAME TO PATHFILE, THE COMPLETE

C  NAME OF THE FILE, WHICH INCLUDES THE PATH (IF THE PATH IS NOT THE
C  CURRENT DIRECTORY).

     	TMPFILE = ' '
	TMPFILE = 'npag103.inp'
	CALL FULLNAME(PATH,TMPFILE,PATHFILE)
	OPEN(27,FILE=PATHFILE,ERR=5375,STATUS='NEW')
	GO TO 5380

 5375   WRITE(*,5376)
 5376   FORMAT(/' FILE npag103.inp, WHICH WILL STORE THE NEW '/
     1' INSTRUCTIONS AND THE PATIENT DATA FILES TO BE READ BY THE '/
     2' NPAG "ENGINE", ALREADY EXISTS. npag103.inp WILL BE'/
     3' COPIED TO npag103.bak. THEN THE VALUES FOR THIS RUN WILL BE'/
     4' WRITTEN INTO npag103.inp.'/)

        CALL SYSTEM(CopyFile//PATH(1:NOB)//'npag103.inp '//
     1PATH(1:NOB)//'npag103.bak')

	OPEN(27,FILE=PATHFILE)

 5380   CONTINUE


C  WRITE ALL INPUT DATA INTO FILE 'npag103.inp' (NEW FOR NPAG119.FOR).

		WRITE(27,*) NDIM
		WRITE(27,*) MF
		WRITE(27,*) RTOL
		WRITE(27,*) (ATOL(I),I=1,NDIM)
		WRITE(27,*) IFORMT

		IF(IFORMT .EQ. 1) THEN
		 WRITE(27,2222) PREFIX
		 WRITE(27,222) EXT
		ENDIF

		IF(IFORMT .EQ. 3) THEN
		 WRITE(27,2222) "XQZPJ"
		 WRITE(27,222) "ZMQ"
		ENDIF

		WRITE(27,*) NVAR
		WRITE(27,1717) (PAR(I),I=1,NVAR)
		WRITE(27,*) NOFIX
		WRITE(27,1717) (PARFIX(I),I=1,NOFIX)
            WRITE(27,*) NRANFIX
            WRITE(27,1717) (PARRANFIX(I),I=1,NRANFIX)


		WRITE(27,*) (IRAN(I),I=1,NP)
		WRITE(27,*) NSUBTOT
		WRITE(27,*) NSUB

C  CALL SUBROUTINE WRITEPT2 TO WRITE THE PATIENT NOS. TO BE USED IN
C  THE ANALYSIS TO FILE 27 ... IN AN "EFFICIENT" WAY, AS OPPOSED TO
C  ONE INDEX PER LINE. NOTE THAT THE FIRST ARGUMENT TELLS WRITEPT2
C  TO WRITE TO FILE 27. NOTE THAT THE '    0' AFTER THE CALL TO
C  WRITEPT2 TELLS THE PROGRAM READING THIS FILE THAT THE PATIENT
C  NOS. HAVE ENDED.

		CALL WRITEPT2(27,NSUB,MAXSUB,IPATVEC)
		WRITE(27,*) '    0'

            IF(NOFIX .GT. 0) WRITE(27,*) (VALFIX(I),I=1,NOFIX)
            IF(NRANFIX .GT. 0) WRITE(27,*) (RANFIXEST(I),I=1,NRANFIX)
		DO I=1,NVAR
		 WRITE(27,*) (AB(I,J),J=1,2)
		END DO

C  NOTE: THE ONLY REASON THE POPULATION C'S [C0P,C1P,C2P,C3P] ARE
C        NEEDED IN  "NPAG" IS SO THEY CAN BE WRITTEN TO THE OUTPUT
C 	   FILE.

		WRITE(27,*) NUMEQT
		DO IEQ=1,NUMEQT
		 WRITE(27,161) C0P(IEQ),C1P(IEQ),C2P(IEQ),C3P(IEQ)
		END DO
 161    	FORMAT(4(G16.10,2X))

		WRITE(27,*) IERRMOD,GAMLAM0
            WRITE(27,*) NDRUG
		WRITE(27,*) (AF(I),I=1,NDRUG)
		WRITE(27,*) INDPTS
		WRITE(27,*) MAXCYC
		WRITE(27,*) JSTOP
		IF(JSTOP .NE. 1) WRITE(27,*) TOLC

		WRITE(27,*) IDELTA
		T_END = 99.D0
		WRITE(27,*) T_END
		WRITE(27,*) XMIC
		WRITE(27,*) ICENT
		WRITE(27,*) AUCINT


		WRITE(27,*) ICYCLE

		IF(ICYCLE .GE. 1) THEN

		  WRITE(27,*) DORIG

		  WRITE(27,*) NACTVE

		  DO I=1,NACTVE
		   WRITE(27,*) (CORDEN(I,J),J=1,NVAR+1)
		  END DO

		  WRITE(27,2) PRIFIL2

		ENDIF

C  NOTE THAT ALL SUBJECTS IN THE SERIES (ISUB = 1,NSUBTOT) HAVE THEIR
C  INFO PUT INTO THE FILE, npag103.inp. OF THESE SUBJECTS, ONLY
C  SUBJECTS IPATVEC(I),I=1,NSUB, WILL BE USED IN THIS RUN. THIS
C  ENABLES THE USER TO EDIT npag103.inp AND HAVE THE "engine" RERUN
c  A DIFFERENT SUBJECT SUBSET WITHOUT RERUNNING THIS PC PREP PROGRAM.
C  CONSIDER ONLY STORING THE SUBJECTS ACTUALLY BEING USED.
C  SEE IF THIS, HERE, AND WHEREVER CALL READBLOCK IS CALLED WILL
C  SHORTEN THE TIME FOR PREPARATION. AS IT IS NOW, EVEN IF THE USER
C  ONLY USES 10 SUBJECTS OUT OF 154, ALL 154 MUST BE EXAMINED.


	DO 400 ISUB=1,NSUBTOT

C  CALL SUBROUTINE STACK TO OPEN THIS SUBJECT'S DATA FILE AND ADD THE
C  INFO INTO FILE 27. NOTE THAT EACH SUBJECT WILL BE TESTED TO VERIFY
C  THAT THE NO. OF OBSERVATION TIMES IS .LE. MAXOBDIM.

      WRITE(*,401) ISUB
  401 FORMAT(' WRITING SUBJECT ',I6,' TO npag103.inp ')

	IF(IFORMT .EQ. 1) PATFIL=PREFIX//NUMBER(ISUB)//'.'//EXT
	IF(IFORMT .EQ. 3) PATFIL="XQZPJ"//NUMBER(ISUB)//'.ZMQ'

        CALL STACK(PATH,MAXOBDIM,MAXNUMEQ,PATFIL,AF)

  400   CONTINUE

	CLOSE(27)


C  THE ABOVE DATA FILE, npag103.inp, STORES DATA FOR THE CALCULATION
C  PART OF THIS PROGRAM. ASK THE USER IF HE WISHES TO STORE THE
C  INSTRUCTIONS FOR THE I/O PART OF THE PROGRAM.


      IF(IVERIFY .EQ. 1) THEN

 4020	WRITE(*,4012) PATHFILAST
 4012   FORMAT(/' THE SAVED INSTRUCTIONS ARE CURRENTLY IN FILE ',
     1A73//
     2' ENTER 1 IF YOU WOULD LIKE TO HAVE THESE INSTRUCTIONS ALSO'/
     3'         SAVED TO A FILE OF ANOTHER NAME; '/
     4' ENTER 0 IF YOU DO NOT WANT TO SAVE INSTRUCTIONS TO ANOTHER FILE:
     5 ')
	READ(*,*,ERR=4020) ISAVE
	IF(ISAVE .NE. 0 .AND. ISAVE .NE. 1) GO TO 4020

	IF(ISAVE .EQ. 1) THEN

C  SET IORIGFILE = 0. IF IT CHANGES TO 1, IT MEANS THAT THE USER DID
C  THIS RUN WITH AN INSTRUCTION FILE. 

C  NOTE THAT IF IALLIN = 1, THE ORIGINAL INSTRUCTION FILE IS IN 
C  ALLINSTRUCT. AND IF IALLIN = 0 AND IFIL = 1, THE ORIGINAL 
C  INSTRUCTION FILE IS IN FROMLAST.

       IORIGFILE = 0

       IF(IALLIN .EQ. 1) THEN
     	  TMPFILE = ' '
        TMPFILE = ALLINSTRUCT
        IORIGFILE = 1
       ENDIF

       IF(IALLIN .EQ. 0 .AND. IFIL .EQ. 1) THEN
     	  TMPFILE = ' '
        TMPFILE = FROMLAST
        IORIGFILE = 1
       ENDIF

       IF(IORIGFILE .EQ. 1) THEN
      

        CALL FULLNAME(PATH,TMPFILE,PATHFILE)
 4030   WRITE(*,4013) PATHFILE

 4013   FORMAT(/' YOUR ORIGINAL INSTRUCTION FILE FOR THIS RUN WAS '/
     12X,A73//
     2' ENTER 1 TO SAVE THE FINAL SET OF INSTRUCTIONS BACK TO THIS FILE;
     3 '/
     5' ENTER 0 TO SAVE THE FINAL SET OF INSTRUCTIONS TO ANOTHER FILE: '
     6)
	 READ(*,*,ERR=4030) IORIG

	 IF(IORIG .NE. 0 .AND. IORIG .NE. 1) GO TO 4030

	 IF(IORIG .EQ. 0) THEN
	  WRITE(*,4014)
 4014     FORMAT(/' ENTER THE NAME OF THE FILE (WITHOUT THE PATH) TO'/
     1' WHICH YOU WANT TO SAVE THE FINAL SET OF INSTRUCTIONS: ')
	  READ(*,2) FROMLAST
     	  TMPFILE = ' '
	  TMPFILE = FROMLAST
	  CALL FULLNAME(PATH,TMPFILE,PATHFILE)
	 ENDIF

	ENDIF
C  THE ABOVE ENDIF IS FOR THE IF(IORIGFILE .EQ. 1) CONDITION.


	IF(IFIL .EQ. 0 .OR. INOPT1 .EQ. 1) THEN
	 WRITE(*,4014)
	 READ(*,2) FROMLAST
     	 TMPFILE = ' '
	 TMPFILE = FROMLAST
	 CALL FULLNAME(PATH,TMPFILE,PATHFILE)
	 IORIG = 0
	ENDIF


C  COPY PATHFILAST TO PATHFILE (IF PATHFILE ALREADY EXISTS, AND
C  IORIG .EQ. 0, WRITE A WARNING FIRST TO THE USER).


	IF(IORIG .EQ. 0) THEN
	 OPEN(25,FILE=PATHFILE,ERR=4040,STATUS='NEW')
	 GO TO 4050
 4040  WRITE(*,9826) PATHFILE
	 READ(*,*,ERR=4040) IFILE
	 IF(IFILE .NE. 0 .AND. IFILE .NE. 1) GO TO 4040
	 IF(IFILE .EQ. 0) GO TO 4020
	 IF(IFILE .EQ. 1) OPEN(25,FILE=PATHFILE)
 4050  CLOSE(25)
	ENDIF


C  NOW COPY PATHFILAST TO PATHFILE.

        CALL SYSTEM(CopyFile//PATHFILAST//' '//PATHFILE)



	ENDIF
C  THE ABOVE ENDIF IS FOR THE  IF(ISAVE .EQ. 1)  CONDITION.

      ENDIF
C  THE ABOVE ENDIF IS FOR THE  IF(IVERIFY .EQ. 1)  CONDITION.


C  COPY npag103.inp LINE BY LINE TO npag103.bak, AND THEN COPY
C  npag103.bak BACK TO npag103.inp. THIS SHOULD STRIP AWAY ANY
C  SPURIOUS CHARACTERS (WHICH LOOK LIKE LITTLE BOXES IN WORD, BUT ARE
C  INVISIBLE IN WORDSTAR) FROM THE END OF THE FILE (THESE CHARACTERS CAN
C  RESULT FROM EDITING OF THE FILE BY SOME WORD PROCESSORS. IF THEY ARE
C  NOT REMOVED NOW, THEY CAN SHOW UP IN THE FINAL OUTPUT FILE, AND THEN
C  CAUSE THE PC PREP PROGRAM (NPBIG15E.EXE CURRENTLY) TO BOMB WHEN
C  READING THE OUTPUT FILE SINCE IT CAN'T "SEE" ANY LINES BEYOND A LINE
C  WITH SPURIOUS CHARACTERS IN IT. ACTUALLY, THIS ONLY SEEMS TO HAPPEN
C  WHEN THE "ENGINE" IS COMPILED AND LINKED WITH g95 (I.E., IT DOESN'T

C  HAPPEN WHEN THE "ENGINE" IS COMPILED BY LAHEY LF90).

C  THEN DO THE SAME LOGIC TO REMOVE SPURIOUS CHARACTERS FROM npagdriv.f
C  FOR THE SAME REASON.

     	TMPFILE = ' '
	TMPFILE = 'npag103.inp'
	CALL FULLNAME(PATH,TMPFILE,PATHFILE)
	OPEN(21,FILE=PATHFILE)

     	TMPFILE = ' '
	TMPFILE = 'npag103.bak'
	CALL FULLNAME(PATH,TMPFILE,PATHFIL2)
	OPEN(22,FILE=PATHFIL2)


	OPEN(21,FILE=PATHFILE)
	OPEN(22,FILE=PATHFIL2)

 3010   READ(21,3,IOSTAT=IEND) READLINE
	IF(IEND .LT. 0) GO TO 3100
	WRITE(22,3) READLINE
	GO TO 3010

 3100   CLOSE(21)
	CLOSE(22)


        CALL SYSTEM(CopyFile//PATH(1:NOB)//'npag103.bak '//

     1PATH(1:NOB)//'npag103.inp')


     	TMPFILE = ' '
	TMPFILE = 'npagdriv.f'
	CALL FULLNAME(PATH,TMPFILE,PATHFILE)
	OPEN(21,FILE=PATHFILE)

     	TMPFILE = ' '
	TMPFILE = 'npagdriv.bak'


	CALL FULLNAME(PATH,TMPFILE,PATHFIL2)
	OPEN(22,FILE=PATHFIL2)


	OPEN(21,FILE=PATHFILE)
	OPEN(22,FILE=PATHFIL2)

 4010   READ(21,3,IOSTAT=IEND) READLINE
	IF(IEND .LT. 0) GO TO 4100
	WRITE(22,3) READLINE
	GO TO 4010

 4100   CLOSE(21)
	CLOSE(22)

        CALL SYSTEM(CopyFile//PATH(1:NOB)//'npagdriv.bak '//
     1PATH(1:NOB)//'npagdriv.f')


        IF (INDEX(OSName,"UNIX",.TRUE.).eq.1) THEN
          WRITE(*,1109)
        ELSE IF (INDEX(OSName,"DOS",.TRUE.).eq.1) THEN
          WRITE(*,1111)
        ENDIF



 1109   FORMAT(//' YOU HAVE COMPLETED THE PREPARATION PHASE FOR THIS'/
     1' PROGRAM. PLEASE DO THE FOLLOWING:'//
     2' 1. PLACE THE FOLLOWING TWO FILES INTO THE "WORKING" DIRECTORY'/
     3'    (WHICH MUST CONTAIN THE PERMANENT MODULES FOR THE '/
     4'    NPAG, MULTIPLE DRUG "ENGINE"):'/
     3'    OF THE COMPUTER WHICH WILL DO THE ANALYSIS:'/
     5'      npag103.inp <-- INPUT INSTRUCTIONS + PATIENT DATA;'/
     7'      npagdriv.f  <-- DRIVER MODULE + MODEL CODE;'//
     1' 2. COMPILE AND LINK THE PROGRAM IN THE WORKING DIRECTORY ...'/
     3' 3. EXECUTE THE PROGRAM ...'//
     9' 4. AFTER THE RUN HAS FINISHED, YOU WILL HAVE SEVERAL OUTPUT'/
     1'    FILES, OUTxxxx  OUTTxxxx  DENxxxx  PRTBxxxx  NP_RFxxxx '/
     2'    WHERE xxxx IS THE 4-DIGIT JOB NUMBER ASSIGNED TO YOUR RUN.'/)

 1111   FORMAT(//' YOU HAVE COMPLETED THE PREPARATION PHASE FOR THIS'/
     1' PROGRAM. PLEASE DO THE FOLLOWING:'//
     2' 1. PLACE THE FOLLOWING TWO FILES INTO THE "WORKING" DIRECTORY'/
     3'    (WHICH MUST CONTAIN THE PERMANENT MODULES FOR THE '/
     4'    NPAG, MULTIPLE DRUG "ENGINE"):'/
     3'    OF THE COMPUTER WHICH WILL DO THE ANALYSIS:'/
     5'      npag103.inp <-- INPUT INSTRUCTIONS + PATIENT DATA;'/
     7'      npagdriv.f  <-- DRIVER MODULE + MODEL CODE;'//
     1' 2. COMPILE AND LINK THE PROGRAM IN THE WORKING DIRECTORY ...'/
     3' 3. EXECUTE THE PROGRAM ...'//
     9' 4. AFTER THE RUN HAS FINISHED, YOU WILL HAVE SEVERAL OUTPUT'/
     1'    FILES, OUTxxxx  OUTTxxxx  DENxxxx  PRTBxxxx  NP_RFxxxx '/
     2'    WHERE xxxx IS THE 4-DIGIT JOB NUMBER ASSIGNED TO YOUR RUN.'/)


	IF(IFORMT .EQ. 3) WRITE(*,1112)
 1112   FORMAT(///' CAUTION     CAUTION     CAUTION     CAUTION   '//
     2' THE FOLLOWING WORKING COPY FILES HAVE BEEN CREATED AND PLACED'/
     3' INTO YOUR WORKING COPY DIRECTORY. YOU MAY WISH TO CHECK THAT'/
     4' THESE FILES WERE CREATED CORRECTLY. '//
     5' XQZPJ001.ZMQ, ... '//
     5' NOTE THAT IF YOU RERUN THIS NPAG PC PREP PROGRAM AGAIN WITH'/
     6' THE SAME WORKING DIRECTORY, AND YOU INPUT PATIENT DATA INFO'/
     7' VIA A BLOCK PATIENT FILE, THESE FILES WILL BE OVERWRITTEN.'//
     6' CAUTION     CAUTION     CAUTION     CAUTION'///)

C  DON'T CALL PAUSE IF IALLIN = 1 AND IVERIFY = 0, BECAUSE IN THIS
C  CASE THE PROGRAM IS SUPPOSED TO RUN WITHOUT ANY MORE USER
C  INTERACTION.

      IF(IALLIN .EQ. 1 .AND. IVERIFY .EQ. 0) STOP

	CALL PAUSE


	STOP
	END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
	SUBROUTINE FILRED(NOBSER,YO,C0,C1,C2,C3,MAXOBDIM,MAXNUMEQ)

C  FILRED IS CALLED BY SUBROUTINE PREVRUN TO READ THE PORTION OF
C  SCRATCH FILE 27 WHICH APPLIES TO THE SUBJECT UNDER CONSIDERATION. THE

C  'POINTER' FOR FILE 27 IS IN THE PROPER POSITION TO BEGIN READING THE
C  INFO FOR THE DESIRED SUBJECT.

        IMPLICIT REAL*8(A-H,O-Z)
        DIMENSION SIG(5000),RS(5000,34),YO(MAXOBDIM,MAXNUMEQ),
     1  BS(5000,7),C0(MAXNUMEQ),C1(MAXNUMEQ),C2(MAXNUMEQ),C3(MAXNUMEQ)

        CHARACTER ERRFIL*20

      COMMON/ERROR/ERRFIL
C  COMMON/ERROR/ IS SUPPLIED TO ALL THE ROUTINES WHICH COULD WRITE TO
C  ERRFIL. 


C  THE MAJOR CHANGE AS OF NPBIG11.FOR (WHICH ALLOWS MULTIPLE DRUGS)
C  OCCURS IN THE DOSAGE REGIMEN BLOCK WHICH WILL NOW HAVE THE FOLLOWING
C  COLUMNS, IN ORDER:

C     COL 1 = TIME
C     COL 2 = IV FOR DRUG 1; COL 3 = PO FOR DRUG 1;
C     COL 4 = IV FOR DRUG 2; COL 5 = PO FOR DRUG 2;
C     ... EACH SUCCEEDING DRUG HAS AN IV FOLLOWED BY A PO COLUMN.

C     NEXT COL = WEIGHT
C     NEXT COL = CCR
C     NEXT NADD COLUMNS = ONE FOR EACH ADDITIONAL COVARIATE.

	CHARACTER SEX*1,READLINE*1000


C  INPUT IS: SCRATCH FILE 27, WHICH IS POSITIONED AT THE BEGINNING OF
C  THE INFO FOR THE SUBJECT DESIRED.


C  OUTPUT ARE:

C  NOBSER = THE NO. OF OBSERVATIONS FOR THIS SUBJECT.
C  YO(I,J),I=1,M; J=1,NUMEQT = NO. OF OUTPUT EQS; I=1,M, WHERE M = NO.
C	OF OBSERVATION TIMES.
C  [C0(J),C1(J),C2(J),C3(J)] = ASSAY NOISE COEFFICIENTS FOR OUTPUT EQ.
C	J; J=1,NUMEQT.


C  AGE, SEX, HEIGHT, AND ETHNICITY FLAG ARE ON LINES 8-11.

	DO I=1,7
	 READ(27,*)
	END DO

	READ(27,*) AGE
	READ(27,2) SEX
    2   FORMAT(A1)
	ISEX=1
	IF(SEX .EQ. 'F') ISEX=2
	READ(27,*) HEIGHT
	READ(27,*) IETHFLG

C  READ THE NO. OF DRUGS FROM THE LINE WITH 'NO. OF DRUGS' AS ENTRIES
C  12:23. THEN READ NO. OF ADDITIONAL COVARIATES, AND THE NO. OF DOSE
C  EVENTS, ETC.

    1   FORMAT(A1000)
   10	READ(27,1) READLINE
	IF(READLINE(12:23) .NE. 'NO. OF DRUGS') GO TO 10
	BACKSPACE(27)

    3   FORMAT(T2,I5)
        READ(27,3) NDRUG

	IF(NDRUG .GT. 7) THEN

	 WRITE(*,124)
  124    FORMAT(' YOUR PATIENT DATA FILES CANNOT HAVE MORE THAN 7'/
     1' DRUGS. THE PROGRAM IS NOW STOPPING. '/)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,124) 
        CLOSE(42)


	 CALL PAUSE
	 STOP

	ENDIF

        READ(27,3) NADD

C  NOTE THAT THE NO. OF "RATES" INCLUDES 2 FOR EACH DRUG (THE IV AND

C  THE PO COLUMNS) + NADD (1 COLUMN FOR EACH ADDITIONAL COVARIATE 
C  BEYOND THE FIRST 4 ABOVE, AGE, SEX, HEIGHT, AND ETHNICITY FLAG).

	NI = 2*NDRUG + NADD

	IF(NI .GT. 34) THEN

  	 WRITE(*,123)
  123    FORMAT(/' YOUR PATIENT DATA FILES HAVE TOO MANY COLUMNS IN '/
     1' THE DOSAGE REGIMEN BLOCK. THE NO. OF ADDITIONAL COVARIATES '/
     2' PLUS TWICE THE NO. OF DRUGS CANNOT EXCEED 34. THE PROGRAM IS'/
     3' NOW STOPPING. '/)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,123) 
        CLOSE(42)


	 CALL PAUSE
	 STOP

	ENDIF


        READ(27,3) ND

	IF(ND .GT. 5000) THEN

	 WRITE(*,125)
  125    FORMAT(' YOUR PATIENT DATA FILES CANNOT HAVE MORE THAN 5000'/
     1' DOSE EVENTS. THE PROGRAM IS NOW STOPPING. '/)


        OPEN(42,FILE=ERRFIL)
         WRITE(42,125) 
        CLOSE(42)

	 CALL PAUSE
	 STOP

	ENDIF

	READ(27,*)
	READ(27,*)

        IF(ND.EQ.0) GO TO 40


	DO I = 1,ND
         READ(27,*) SIG(I),(RS(I,J),J=1,NI)
	END DO

C  ASSIGN THE VALUES IN EACH DRUG'S PO COLUMN TO THE CORRESPONDING
C  COLUMN IN ARRAY BS.

        DO I=1,ND
         DO J=1,NDRUG
          BS(I,J)=RS(I,2*J)
	 END DO
	END DO



C  READ THE NO. OF OUTPUT EQUATIONS FROM THE LINE WITH 'NO. OF TOTAL'
C  AS ENTRIES 12:23. THEN READ NO. OF OBSERVED VALUE TIMES, ETC.

   40	READ(27,1) READLINE
	IF(READLINE(12:23) .NE. 'NO. OF TOTAL') GO TO 40
	BACKSPACE(27)

        READ(27,3) NUMEQT
        READ(27,3) M

	IF(M .GT. MAXOBDIM) THEN

  	 WRITE(*,126) MAXOBDIM
  126    FORMAT(/' AT LEAST ONE OF YOUR PATIENT DATA FILES HAS TOO'/
     1' MANY OBSERVED VALUE TIMES. THIS NO. CANNOT EXCEED ',I5,'.'/
     2' THE PROGRAM IS NOW STOPPING. '/)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,126) MAXOBDIM 
        CLOSE(42)


	 CALL PAUSE
	 STOP

	ENDIF

	IF(NUMEQT .GT. MAXNUMEQ) THEN

  	 WRITE(*,127) MAXNUMEQ
  127    FORMAT(/' AT LEAST ONE OF YOUR PATIENT DATA FILES HAS TOO'/
     1' MANY OUTPUT EQUATION COLUMNS. THIS NO. CANNOT EXCEED ',I2,'.'/
     2' THE PROGRAM IS NOW STOPPING. '/)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,127) MAXNUMEQ 
        CLOSE(42)

	 CALL PAUSE
	 STOP

	ENDIF


	DO I=1,M
         READ(27,*) T,(YO(I,J),J=1,NUMEQT)
	END DO

	NOBSER = M

C  AT THIS POINT, MUST SKIP THE COVARIATE INFO IN THE FILE, AND PROCEED

C  TO READ THE ASSAY NOISE COEFFICIENTS BELOW THAT.


C  READ THE NUMEQT SETS OF ASSAY COEFFICIENTS JUST BELOW THE LINE
C  WHICH HAS "ASSAY COEFFICIENTS FOLLOW" IN ENTRIES 1:25.

   50	READ(27,1) READLINE
	IF(READLINE(1:25) .NE. 'ASSAY COEFFICIENTS FOLLOW') GO TO 50

	DO IEQ = 1,NUMEQT
	 READ(27,*) C0(IEQ),C1(IEQ),C2(IEQ),C3(IEQ)
	END DO

	RETURN
	END

C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
      SUBROUTINE STACK(PATH,MAXOBDIM,MAXNUMEQ,PATFIL,AF)

C  THIS ROUTINE, CALLED BY MAIN, READS THE INFO IN FILE PATFIL, AND
C  APPENDS IT ONTO THE END OF FILE 27.

        IMPLICIT REAL*8(A-H,O-Z)
        DIMENSION SIG(5000),RS(5000,34),AF(7)
        CHARACTER PATFIL*20,READLINE*1000,PATH*60,TMPFILE*13,PATHFILE*73
        CHARACTER ERRFIL*20

      COMMON/ERROR/ERRFIL
C  COMMON/ERROR/ IS SUPPLIED TO ALL THE ROUTINES WHICH COULD WRITE TO
C  ERRFIL. 



C  SEE SUBROUTINE FILRED FOR SOME DETAILS ON THE MAJOR CHANGES AS
C  OF NPBIG11.FOR.

C  INPUT IS:

C  PATH = LOCATION (DIRECTORY) OF PATIENT DATA FILES.
C  PATFIL = PATIENT DATA FILE.
C  AF(I),I=1,NDRUG = ACTIVE FRACTION OF THE DRUG I. EACH IV RATE AND 
C        BOLUS VALUE FOR DRUG I MUST BE MULTIPLIED BY AF(I).

C  OUTPUT IS:

C  FILE 27 WHICH NOW HAS PATFIL APPENDED ONTO ITS END.

C  COPY LINE-BY-LINE PATFIL TO FILE 27 EXCEPT FOR THE DOSAGE REGIMEN
C  (BECAUSE EACH IV RATE AND BOLUS INPUT MUST BE MULTIPLIED BY AF(I)
C  BEFORE BEING WRITTEN TO FILE 27).


    1   FORMAT(A1000)

C  CALL FULLNAME WHICH CONVERTS THE FILENAME TO PATHFILE, THE COMPLETE
C  NAME OF THE FILE, WHICH INCLUDES THE PATH (IF THE PATH IS NOT THE
C  CURRENT DIRECTORY).

     	TMPFILE = ' '
	TMPFILE = PATFIL
	CALL FULLNAME(PATH,TMPFILE,PATHFILE)
      OPEN(21,FILE=PATHFILE)
   10	READ(21,1,IOSTAT=IEND) READLINE


C  NOTE THAT IEND .LT. 0 --> END OF FILE REACHED.

	IF(IEND .LT. 0) THEN

	 WRITE(*,128) PATFIL
  128  FORMAT(/' PATIENT DATA FILE ',A20,' HAS AN OLD-STYLE WORKING'/
     1' COPY FORMAT.'//
     2' FOR THIS PROGRAM, A PATIENT DATA FILE MUST HAVE "NO OF DRUGS"'/
     3' IN ENTRIES 12 THROUGH 23 ON OR NEAR LINE 18.'//
     5' THE PROGRAM STOPS. '/)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,128) PATFIL 
        CLOSE(42)

	 CALL PAUSE
	 STOP

	ENDIF

	WRITE(27,1) READLINE
	IF(READLINE(12:23) .NE. 'NO. OF DRUGS') GO TO 10

C  READLINE NOW CONTAINS THE NO. OF DRUGS, NDRUG. BACKSPACE AND READ
C  NDRUG; THEN READ THE NO. OF ADDITIONAL COVARIATES, AND THE NO. OF
C  DOSE EVENTS.

        BACKSPACE(21)

    3   FORMAT(T2,I5)

        READ(21,3) NDRUG

	IF(NDRUG .GT. 7) THEN

	 WRITE(*,124) PATFIL
  124    FORMAT(' PATIENT DATA FILE ',A20,' HAS TOO MANY DRUGS'/
     1' (I.E, MORE THAN 7). THE PROGRAM IS NOW STOPPING. '/)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,124) PATFIL 
        CLOSE(42)

	 CALL PAUSE
	 STOP

	ENDIF


        READ(21,3) NADD

C  NOTE THAT THE NO. OF "RATES" INCLUDES 2 FOR EACH DRUG (THE IV AND
C  THE PO COLUMNS) + NADD (1 COLUMN FOR EACH ADDITIONAL COVARIATE).

	NI = 2*NDRUG + NADD


	IF(NI .GT. 34) THEN

  	 WRITE(*,123) PATFIL
  123    FORMAT(/' YOUR PATIENT DATA FILES HAVE TOO MANY COLUMNS IN '/
     1' THE DOSAGE REGIMEN BLOCK. THE NO. OF ADDITIONAL COVARIATES '/
     2' PLUS TWICE THE NO. OF DRUGS CANNOT EXCEED 34. THE PROGRAM IS'/
     3' NOW STOPPING. '/)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,123) PATFIL
        CLOSE(42)

	 CALL PAUSE
	 STOP


	ENDIF


        READ(21,3) ND

        IF(ND .GT. 5000) THEN

         WRITE(*,125) PATFIL
  125    FORMAT(' PATIENT DATA FILE ',A20,' HAS TOO MANY DOSE EVENTS'/
     1' (I.E., MORE THAN 5000). THE PROGRAM IS NOW STOPPING. '/)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,125) PATFIL 
        CLOSE(42)

         CALL PAUSE
         STOP

        ENDIF

C  BACKSPACE TWICE AND PUT THE LAST TWO LINES, AND THE NEXT TWO LINES
C  ONTO FILE 27 (THE NEXT LINE AFTER THAT STARTS THE DOSAGE REGIMEN).

	BACKSPACE(21)
	BACKSPACE(21)

	DO I=1,4
	 READ(21,1) READLINE
	 WRITE(27,1) READLINE
	END DO


        IF(ND.EQ.0) GO TO 40

C  THE FIRST NDRUG*2 COLUMNS OF R HAVE THE IV AND BOLUS VALUES FOR
C  THE NDRUG DRUGS IN THE FILE. THESE VALUES MUST BE MULTIPLIED BY 
C  AF(I), WHERE I IS THE DRUG NO.

        DO I = 1,ND

         READ(21,*) SIG(I),(RS(I,J),J=1,NI)

         DO J = 1,2*NDRUG


C  THE DRUG NO., IDRUG, IS THE INTEGER VALUE OF (J+1)/2. EX: (J+1)/2
C  WILL BE 1 IF J = 1 OR 2 SINCE INTEGER ARITHMETIC TRUNCATES.

          IDRUG = (J+1)/2
          RS(I,J) = RS(I,J)*AF(IDRUG)

         END DO

  
         WRITE(27,*) SIG(I),(RS(I,J),J=1,NI)


        END DO

C  READ THE NO. OF OUTPUT EQUATIONS FROM THE LINE WITH 'NO. OF TOTAL'
C  AS ENTRIES 12:23. THEN READ NO. OF OBSERVED VALUE TIMES, ETC. CHECK
C  THAT THESE ENTRIES ARE NOT TOO BIG. IF NOT, WRITE THE REST OF THE
C  FILE 21 TO FILE 27.


   40	READ(21,1) READLINE
	WRITE(27,1) READLINE

	IF(READLINE(12:23) .NE. 'NO. OF TOTAL') GO TO 40
	BACKSPACE(21)


        READ(21,3) NUMEQT
        READ(21,3) M

	IF(M .GT. MAXOBDIM) THEN

	 WRITE(*,126) PATFIL,M,MAXOBDIM,MAXOBDIM
  126    FORMAT(/' PATIENT ',A20,' HAS ',I3,' OBSERVATION TIMES. THIS '/

     1' IS MORE THAN THE ALLOWABLE MAXIMUM OF ',I3,'. PLEASE RERUN THE'/
     2' PROGRAM AFTER ENSURING THAT ALL YOUR PATIENTS HAVE NO MORE '/
     3' THAN ',I3,' OBSERVATION TIMES. '/)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,126) PATFIL,M,MAXOBDIM,MAXOBDIM  
        CLOSE(42)

	 CALL PAUSE
	 STOP

	ENDIF


	IF(NUMEQT .GT. MAXNUMEQ) THEN

	 WRITE(*,127) PATFIL,NUMEQT,MAXNUMEQ,MAXNUMEQ
  127    FORMAT(/' PATIENT ',A20,' HAS ',I3,' OUTPUT EQUATION COLUMNS,'/
     1' WHICH IS MORE THAN THE MAXIMUM ALLOWABLE NO. OF ',I2,'.'/
     2' PLEASE RERUN THE PROGRAM AFTER ENSURING THAT ALL YOUR PATIENTS'/
     3' HAVE NO MORE THAN ',I2,' OUTPUT EQUATION COLUMNS. '/)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,127) PATFIL,NUMEQT,MAXNUMEQ,MAXNUMEQ 
        CLOSE(42)

	 CALL PAUSE
	 STOP

	ENDIF

C  BACKSPACE JUST ONCE TO THE LINE WITH M ON IT, SINCE THE LINE WITH
C  NUMEQT ON IT WAS ALREADY PUT INTO FILE 27. THEN COPY LINE FOR LINE
C  THE REST OF THE FILE TO FILE 27. NOTE THAT IEND .LT. 0 --> END OF
C  FILE REACHED.

	BACKSPACE(21)


   20	READ(21,1,IOSTAT=IEND) READLINE
	IF(IEND .LT. 0) GO TO 100
	WRITE(27,1) READLINE
	GO TO 20

  100	CLOSE(21)

	RETURN
	END

C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
	SUBROUTINE VERIF1(PATHFILAST,IDIRCT,PREFIX,EXT,IFORMT,NVAR,PAR,
     1   AB,C0P,C1P,C2P,C3P,IASS,AF,MAXCYC,JSTOP,TOLC,INDPTS,NOFIX,
     2   VALFIX,PARFIX,IDELTA,XMIC,ICENT,NUMEQT,IALLPAT,ASSMULT,PATH,
     3   NOB,IERRMOD,GAMLAM0,NSUBTOT,NSUB,ISUBALL,MAXSUB,IPATVEC,
     4   BLOCKPAT,AUCINT,OSName,ClearScreen,ListDir,NDRUG,TOLER,INPRI,
     5   PRIFIL2,NDIM,RTOL,ATOL,IRAN,FORFILE,MAXNUMEQ,NRANFIX,PARRANFIX,
     6   RANFIXEST)



	IMPLICIT REAL*8(A-H,O-Z)
	DIMENSION AB(30,2),VALFIX(20),IASS(MAXNUMEQ),C0P(MAXNUMEQ),
     1 C1P(MAXNUMEQ),C2P(MAXNUMEQ),C3P(MAXNUMEQ),IALLPAT(MAXNUMEQ),
     2 ASSMULT(MAXNUMEQ),IPATVEC(MAXSUB),AF(7),ATOL(20),IRAN(32),
     3 RANFIXEST(20)

      COMMON/ERROR/ERRFIL
C  COMMON/ERROR/ IS SUPPLIED TO ALL THE ROUTINES WHICH COULD WRITE TO
C  ERRFIL. 


	CHARACTER PREFIX*5,EXT*3,PAR(30)*11,TMPFILE*13,PATHFILE*73,
     1   PARFIX(20)*11,PATFIL*20,PATH*60,ESTNAM*6,BLOCKPAT*20,
     2   CODEPAT*15,PATHFILAST*73,OSName*20,ClearScreen*6,ListDir*10,
     3   PRIFIL2*20,FORFILE*20,ERRFIL*20,PARRANFIX(20)*11


C  NOTE THAT NP = NVAR + NOFIX + NRANFIX WILL BE NEEDED IN THE CALLS TO
C  WRITEINFILE BELOW.



      NP = NVAR + NOFIX + NRANFIX

C  SUBROUTINE VERIF1 IS CALLED BY MAIN TO PRINT TO THE SCREEN THE INPUT
C  INFO, SO THE USER CAN VERIFY THAT THE VALUES WERE ENTERED CORRECTLY.
C  IF NOT, THE USER MAY CHANGE THESE VALUES.
C
C  NOTE: SUBROUTINE CHANGE BELOW IS CALLED SEVERAL TIMES. ITS ARGUMENT,
C        ICHANG, RETURNS AS 1 IF THE PREVIOUS INFORMATION PRINTED TO THE
C        SCREEN IS VALIDATED BY THE USER; IT RETURNS AS 0 IF THE USER
C        WANTS TO CHANGE SOMETHING.

  102   FORMAT(A20)
  103   FORMAT(A3)
  104   FORMAT(A5)



 5020   WRITE(*,1)
    1   FORMAT(///' THE FOLLOWING INFO WAS READ IN; IF ANY OF IT IS '/

     1' INCORRECT, MAKE THE DESIRED CHANGES.')


C  WRITE ALL INPUT DATA INTO FILE PATHFILAST AS IT IS BEING INPUT. DO
C  THIS BY CALLING WRITEINFILE AFTER EACH INCREMENTAL SET OF INFO IS
C  READ IN (WITH A FIRST ARGUMENT OF 6, MEANING THAT ALL INFO IS
C  WRITTEN AS CURRENTLY KNOWN, THOUGH THE USER CAN CONTINUE TO CHANGE
C  THE INFO THROUGHOUT THIS SUBROUTINE).

      WRITE(*,919) TOLER
  919 FORMAT(/' THE TOLERANCES FOR THE O.D.E. SOLVER ARE ALL ',G16.8)

	CALL CHANGE(ICHANG)
	IF(ICHANG .EQ. 0) THEN

 915   WRITE(*,913)
 913   FORMAT(/' ENTER 1 TO SET ALL TOLERANCES (FOR THE O.D.E. '/
     1'         SOLVER) TO THE DEFAULT VALUE ... 1.D-4.'/
     2' ENTER 0 TO SELECT A DIFFERENT VALUE FOR THE TOLERANCES: ')
       READ(*,*,ERR=915) ITOL

       IF(ITOL .NE. 0 .AND. ITOL .NE. 1) GO TO 915

       TOLER=1.D-4

      IF(ITOL .EQ. 0) THEN
  910	 WRITE(*,914)
  914  FORMAT(/' ENTER A POSITIVE VALUE FOR THE TOLERANCE PARAMETERS: ')
       READ(*,*,ERR=910) TOLER
       IF(TOLER .LE. 0.D0) GO TO 910
      ENDIF

      RTOL = TOLER
      DO I=1,NDIM
       ATOL(I) = TOLER
      END DO

      ENDIF
C  ABOVE ENDIF IS FOR THE  IF(ICHANG .EQ. 0)  CONDITION.



	IF(IFORMT .EQ. 1) THEN
	 WRITE (*,2) PREFIX,EXT
    2    FORMAT(/' THE PATIENT DATA FILES ARE CALLED: ',A5,'001.',A3,' .
     1..')
	 WRITE(*,3)
    3    FORMAT(/' THESE FILES ARE IN WORKING COPY FORMAT.')
	ENDIF

	IF(IFORMT .EQ. 3) WRITE(*,22) BLOCKPAT
   22   FORMAT(/' THE PATIENT DATA INFORMATION WILL BE INPUT IN '/
     1' BLOCK FORMAT FROM FILE ',A20)
C
C
C
	CALL CHANGE(ICHANG)
	IF(ICHANG .EQ. 0) THEN
C
C
C

4005	WRITE(*,141)
  141   FORMAT(/' ENTER 1 IF THE PATIENT DATA INFO WILL BE SUPPLIED'/
     1'         IN A MATRIX BLOCK FORMAT; '/
     2' ENTER 2 IF THE PATIENT DATA INFO WILL BE INPUT USING A'/
     3'         WORKING COPY FORMAT: ')
	READ(*,*,ERR=4005) IFORMTT
	IF(IFORMTT .NE. 1 .AND. IFORMTT .NE. 2) GO TO 4005

C  IFORMTT MUST BE CHANGED TO BE THE SAME AS THE
C  OLD IFORMT AS FOLLOWS:

C  IFORMTT = 1 --> IFORMT = 3 --> PATIENT INFO IS INPUT VIA BLOCK FORMAT
C                                 (.CSV FILES);
C  IFORMTT = 2 --> IFORMT = 1 --> PATIENT INFO IS INPUT VIA WORKING COPY
C                                 FILES.

         IF(IFORMTT .EQ. 1) IFORMT = 3
         IF(IFORMTT .EQ. 2) IFORMT = 1


	IF(IFORMT .EQ. 3) THEN

         WRITE(*,3111)

 3111    FORMAT(/' ENTER THE NAME OF THE FILE WHICH CONTAINS ALL THE'/


     1' PATIENT DATA INFO IN BLOCK FORMAT (ENTER -99 TO SEE ALL OR A '/
     2' PART OF YOUR DIRECTORY: ')
        READ(*,102) BLOCKPAT
	IF(BLOCKPAT(1:3) .EQ. '-99') CALL SEEDIR(PATH,NOB,BLOCKPAT,OSName,
     1      ListDir)


C  CALL FULLNAME WHICH CONVERTS THE FILENAME TO PATHFILE, THE COMPLETE
C  NAME OF THE FILE, WHICH INCLUDES THE PATH (IF THE PATH IS NOT THE
C  CURRENT DIRECTORY).

     	TMPFILE = ' '
	TMPFILE = BLOCKPAT
	CALL FULLNAME(PATH,TMPFILE,PATHFILE)
	OPEN(67,FILE=PATHFILE,ERR=3120,STATUS='OLD')
	GO TO 3130
 3120   WRITE(*,5316) PATHFILE
 5316   FORMAT(//' THE FOLLOWING FILE DOES NOT EXIST ... '/
     1'    ',A73)
	GO TO 4005
 3130   CONTINUE

	 ICODEPAT = 0
	 READ(67,7126) CODEPAT

 7126    FORMAT(A15)
	 IF(CODEPAT .EQ. '"POPDATA APR_11') ICODEPAT = 1
	 IF(CODEPAT(1:14) .EQ. 'POPDATA APR_11') ICODEPAT = 1

       IF(CODEPAT .EQ. '"POPDATA DEC_11') ICODEPAT = 1
       IF(CODEPAT(1:14) .EQ. 'POPDATA DEC_11') ICODEPAT = 1


	IF(ICODEPAT .EQ. 0) THEN
	 WRITE(*,3131)
 3131    FORMAT(//' YOUR PATIENT DATA BLOCK FORMAT FILE IS NOT FROM '/
     1' THE ALLOWABLE SET OF SUCH FILES.'//
     2' A PATIENT DATA BLOCK FORMAT FILE MUST HAVE "POPDATA XXX_XX IN'/
     3' COLUMNS 1 THROUGH 15 ON LINE 1, WHERE  XXX_XX  IS APR_11 OR A '/
     4' MORE RECENT DATE.'//)

	  CLOSE(67)
	  GO TO 4005
	ENDIF


	CLOSE(67)

	ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(IFORMT .EQ. 3)  CONDITION.


	IF(IFORMT .EQ. 1) THEN

 7505	  WRITE(*,4041)
 4041     FORMAT(/' ENTER THE 5-CHAR PREFIX FOR PATIENT FILENAMES: ')
	  READ(*,104) PREFIX
	  WRITE(*,4043)
 4043     FORMAT(/' IF THERE IS A 3-CHAR EXTENSION FOR THE PATIENT '/
     1' FILENAMES, ENTER IT NOW; OTHERWISE, HIT CARRIAGE RETURN: ')
	  READ(*,103) EXT


C  VERIFY THAT THE USER ENTERED AT LEAST 5 CHARACTERS FOR THE PREFIX. IF
C  NOT, VERIFY THAT THIS IS NOT A MISTAKE ... BUT ALLOW SUCH A PREFIX
C  IF THE USER INSISTS -- THE RUN WILL STILL WORK PROPERLY.


	  IF(PREFIX(1:1) .EQ. ' ' .OR. PREFIX(2:2) .EQ. ' ' .OR.
     1       PREFIX(3:3) .EQ. ' ' .OR. PREFIX(4:4) .EQ. ' ' .OR.
     2       PREFIX(5:5) .EQ. ' ') THEN

     	PATFIL = PREFIX//'001.'//EXT
 7500   WRITE(*,7501) PATFIL(1:12)
 7501   FORMAT(/' ARE YOUR SUBJECT FILES REALLY CALLED ',A12,' ... ?'//
     1' ENTER 1 TO REENTER YOUR SUBJECT FILENAMES; '/
     2' ENTER 0 IF THESE NAMES ARE ACCURATE: ')
	READ(*,*,ERR=7500) IOK

	IF(IOK .NE. 0 .AND. IOK .NE. 1) GO TO 7500

	IF(IOK .EQ. 1) GO TO 7505

	   ENDIF

	ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(IFORMT .EQ. 1) THEN  CONDITION.

C  CHECK THAT NUMEQT FOR THESE NEW PATIENTS IS THE SAME AS NUMEQT
C  FOR THE OLD FILES. IF NOT CHANGE NUMEQT AND TELL THE USER.
C  SUBROUTINE GETNUMEQ READS THE NO. OF OUTPUT EQUATIONS (NUMEQT2).
C  THE 3RD ARGUMENT TO GETNUMEQ IS 0 --> THE CALL IS NOT FROM MAIN.
C  SIMILARLY FOR NDRUG2, COMPARED TO NDRUG FOR THE ORIGINAL PATIENTS.

         CALL GETNUMEQ(PATH,NOB,0,IFORMT,PREFIX,EXT,BLOCKPAT,NUMEQT2,
     1    NDRUG2,MAXSUB,MAXNUMEQ)

C  CHECK THAT NUMEQT IS .LE. MAXNUMEQ.

      IF(NUMEQT .GT. MAXNUMEQ) THEN

       WRITE(*,8317) NUMEQT,MAXNUMEQ
 8317  FORMAT(/' YOUR PATIENT FILES HAVE ',I3,' OUTPUT EQUATIONS. '/
     1' THIS IS MORE THAN THE MAXIMUM ALLOWED NO. OF ',I2,'.'//
     2' PLEASE CORRECT YOUR PATIENT FILES AND THEN RERUN THE PROGRAM.'/) 

       OPEN(42,FILE=ERRFIL)
        WRITE(42,8317) NUMEQT,MAXNUMEQ 
       CLOSE(42)

       CALL PAUSE
       STOP

      ENDIF



	IF(NUMEQT .NE. NUMEQT2) THEN

	 WRITE(*,7512) NUMEQT2,NUMEQT
 7512    FORMAT(//' YOUR NEW PATIENT DATA FILES HAVE ',I4,' OUTPUT'/
     1' EQUATION(S), RATHER THAN THE ',I4,' OUTPUT EQUATION(S) THAT '/
     2' YOUR ORIGINAL PATIENT FILES HAD. BE SURE TO CHANGE THE ASSAY'/
     3' COEFFICIENT INFORMATION BELOW, IF NEEDED.')

C  IF NUMEQT (OLD) < NUMEQT2 (NEW), PUT 1'S IN ALL NEW ENTRIES OF
C  IASS AND C0P,...,C3P. THEY CAN BE CHANGED BY USER BELOW.

	 IF(NUMEQT .LT. NUMEQT2) THEN
	  DO IEQ = NUMEQT+1,NUMEQT2
	   IASS(IEQ) = 1
	   C0P(IEQ) = 1
	   C1P(IEQ) = 1
	   C2P(IEQ) = 1
	   C3P(IEQ) = 1
	  END DO

	 ENDIF

	NUMEQT = NUMEQT2

	ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(NUMEQT .NE. NUMEQT2)  CONDITION.

	IF(NDRUG .NE. NDRUG2) THEN

	 WRITE(*,7513) NDRUG2,NDRUG
 7513    FORMAT(//' YOUR NEW PATIENT DATA FILES HAVE ',I4,' DRUGS,'/
     1' RATHER THAN THE ',I4,' DRUGS THAT YOUR ORIGINAL PATIENT FILES'/
     2' HAD. BE SURE TO CHANGE THE AF VALUES BELOW, IF NEEDED.')

C  IF NDRUG (OLD) < NDRUG2 (NEW), PUT 1'S IN ALL NEW ENTRIES OF

C  AF. THEY CAN BE CHANGED BY USER BELOW.

	 IF(NDRUG .LT. NDRUG2) THEN
	  DO ID = NDRUG+1,NDRUG2
         AF(ID) = 1.D0
	  END DO

	 ENDIF

	NDRUG = NDRUG2

	ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(NDRUG .NE. NDRUG2)  CONDITION.

C
C
C
	ENDIF
C
C
C

      CALL WRITEINFILE(7,PATHFILAST,IDELTA,XMIC,ICENT,
     1   AUCINT,AF,INDPTS,MAXCYC,JSTOP,TOLC,NUMEQT,C0P,C1P,C2P,C3P,
     2   IERRMOD,GAMLAM0,IASS,NOFIX,VALFIX,NVAR,AB,NSUB,NSUBTOT,MAXSUB,
     3   IPATVEC,IFORMT,BLOCKPAT,PREFIX,EXT,NDRUG,FORFILE,NDIM,NP,IRAN,
     4   PAR,PARFIX,TOLER,INPRI,PRIFIL2,MAXNUMEQ,NRANFIX,PARRANFIX,
     5   RANFIXEST)


C  BUG CORRECTION IN NPBG15E3.FOR. ISUBALL IS NOT SET BEFORE THE CALL
C  TO THIS ROUTINE IF AN INSTRUCTION FILE IS USED. SO USED A DIRECT
C  COMPARISON OF NSUB TO NSUBTOT IN CODE BELOW.

      IF(NSUB .EQ. NSUBTOT) WRITE(*,6) NSUBTOT,NSUB
C	IF(ISUBALL .EQ. 1) WRITE(*,6) NSUBTOT,NSUB
    6   FORMAT(/' YOU HAVE ',I5,' SUBJECTS IN YOUR ENTIRE DATA SET. '/
     1' OF THESE, ALL ',I5,' WILL BE USED IN THIS ANALYSIS. ')

      IF(NSUB .LT. NSUBTOT) THEN
C	IF(ISUBALL .EQ. 0) THEN
	 WRITE(*,16) NSUBTOT,NSUB
   16    FORMAT(/' YOU HAVE ',I5,' SUBJECTS IN YOUR ENTIRE DATA SET. '/
     1' OF THESE, ',I5,' WILL BE USED IN THIS ANALYSIS. THE INDICES'/
     2' OF THE PATIENTS TO BE USED ARE AS FOLLOWS: ')

	 CALL WRITEPAT(NSUB,MAXSUB,IPATVEC)

	ENDIF

C
C
	CALL CHANGE(ICHANG)
	IF(ICHANG .EQ. 0) THEN

C
C
C  CALL SUBROUTINE GETIPAT TO OBTAIN THE NO. OF SUBJECTS IN THE
C  ENTIRE DATA SET, NSUBTOT, THE NO. OF THESE SUBJECTS TO BE USED
C  IN THE CURRENT ANALYSIS, NSUB, AND THE INDICES OF THESE "ACTIVE"
C  SUBJECTS, IPATVEC(I),I=1,NSUB. NOTE THAT ISUBALL = 1 IF ALL
C  SUBJECTS ARE USED (I.E., NSUB = NSUBTOT) AND 0 OTHERWISE.

	CALL GETIPAT(NSUBTOT,NSUB,ISUBALL,MAXSUB,IPATVEC)
C
C
        ENDIF
C
C
      CALL WRITEINFILE(7,PATHFILAST,IDELTA,XMIC,ICENT,
     1   AUCINT,AF,INDPTS,MAXCYC,JSTOP,TOLC,NUMEQT,C0P,C1P,C2P,C3P,
     2   IERRMOD,GAMLAM0,IASS,NOFIX,VALFIX,NVAR,AB,NSUB,NSUBTOT,MAXSUB,
     3   IPATVEC,IFORMT,BLOCKPAT,PREFIX,EXT,NDRUG,FORFILE,NDIM,NP,IRAN,
     4   PAR,PARFIX,TOLER,INPRI,PRIFIL2,MAXNUMEQ,NRANFIX,PARRANFIX,
     5   RANFIXEST)
C
C
C
	WRITE(*,7) (PAR(I),I=1,NVAR)
    7   FORMAT(/' THE PARAMETERS TO BE ESTIMATED ARE: '/
     1' ',30A11)

	WRITE(*,9)
    9   FORMAT(//' THEIR RANGES ARE: ')

	DO 100 I=1,NVAR
  100   WRITE(*,11) PAR(I),AB(I,1),AB(I,2)
   11   FORMAT(/' ',A11,': ',G17.10,'  TO  ',G17.10)

      WRITE(*,201)
  201 FORMAT(/' THE USER-ENTERED FIXED PARAMETER VALUE(S) IS (ARE):')

      IF(NOFIX .EQ. 0) WRITE(*,*)' ... NONE SELECTED.'

      IF(NOFIX .GT. 0) THEN
       DO 210 I=1,NOFIX
  210  WRITE(*,211) PARFIX(I),VALFIX(I)
	ENDIF

  211 FORMAT(/' ',A11,': ',G17.10)


      WRITE(*,1201)
 1201 FORMAT(/' THE USER-ENTERED RANFIX PARAMETER VALUE(S) IS (ARE):')

      IF(NRANFIX .EQ. 0) WRITE(*,*)' ... NONE SELECTED.'

      IF(NRANFIX .GT. 0) THEN
       DO I=1,NRANFIX
        WRITE(*,211) PARRANFIX(I),RANFIXEST(I)
       END DO
	ENDIF


C
C
	CALL CHANGE(ICHANG)
	IF(ICHANG .EQ. 0) THEN
C
C
C  IN THIS PROGRAM, THE USER CAN ONLY CHANGE THE RANGES, SINCE THE
C  NAMES OF THE FIXED, RANFIX, AND RANDOM VARIABLES ARE HARDCODED INTO
C  SUBROUTINE SYMBOL. SO HARDCODE IPB=1.



	IPB=1


C  IF IPB = 1, GO TO LABEL 4970 AND SIMPLY CHANGE THE BOUNDARIES. THEN
C              GO TO LABEL 7220 (WHICH SKIPS THE DESCRIPTOR STUFF).
C  IF IPB = 2, GO TO LABEL 7210 AND SIMPLY CHANGE THE DESCRIPTORS.
C  IF IPB = 3, GO TO LABEL 4970 AND CHANGE THE BOUNDARIES; THEN PROCEED

C	       TO LABEL 7210 AND CHANGE THE DESCRIPTORS.
C  IF IPB = 0, START IMMEDIATELY BELOW WITH NEW PARAMETERS.

	GO TO 4970

C/////////////   ENTER RANDOM AND FIXED PARAMETER INFO.  ///////////////
C///////////////////////////  BELOW  ///////////////////////////////////

C  THIS CODE IS SIMILAR IN MAIN AND VERIF1 -- SEE PAR_6.INP.


 4970   WRITE(*,1117)
 1117   FORMAT(/' ENTER THE BOUNDS OF THE RANGE FOR EACH PARAMETER.'//
     1' CAUTION: IF ANY OF YOUR PARAMETERS CANNOT = 0, BE SURE TO MAKE'/
     2'		 ITS LOWER BOUNDARY A POSITIVE NUMBER, RATHER THAN 0.'/
     3' 	 (ONE SUCH EXAMPLE IS FOR VOL WHICH SHOWS UP IN THE'/
     4'		 DENOMINATOR OF THE OUTPUT EQUATION IN THE MODEL'/
     5'		 FILE.)'//)

	DO 6060 I=1,NVAR

	WRITE(*,34) PAR(I)


   34   FORMAT(/' ',A11,' : ')

 7110   READ(*,*,ERR=7115) (AB(I,J),J=1,2)
	GO TO 6060
 7115   WRITE(*,7116)
 7116   FORMAT(/' SEE ABOVE; PLEASE ENTER TWO REAL NUMBERS: ')
	GO TO 7110

 6060   CONTINUE


C  ENTER THE FIXED VALUES FOR THE PARAMETERS.

      IF(NOFIX .GT. 0) THEN

     	  WRITE(*,4836)
 4836   FORMAT(/' ENTER THE VALUE FOR EACH FIXED PARAMETER: ')

        DO 4855 I=1,NOFIX
	  WRITE(*,34) PARFIX(I)
 4840   READ(*,*,ERR=4845) VALFIX(I)
        GO TO 4855
 4845   WRITE(*,4841)
 4841   FORMAT(/' SEE ABOVE; ENTER A POSITIVE VALUE: ')
	  GO TO 4840
 4855   CONTINUE

      ENDIF


C  ENTER THE RANFIX VALUES FOR THE PARAMETERS.

      IF(NRANFIX .GT. 0) THEN

     	  WRITE(*,5836)
 5836   FORMAT(/' ENTER THE INITIAL EST. FOR EACH RANFIX PARAMETER: ')
        DO 5855 I=1,NRANFIX
        WRITE(*,34) PARRANFIX(I)
 5840   READ(*,*,ERR=5845) RANFIXEST(I)
        GO TO 5855
 5845   WRITE(*,4841)
        GO TO 5840
 5855   CONTINUE

      ENDIF



	IF(IPB .EQ. 1) GO TO 7220

 7210   CONTINUE




C  IN PAR_6.INP, THE MENU STUFF IS NOT USED. THE USER CODES EXPLICITLY
C  INTO SUBROUTINE SYMBOL WHICH DESCRIPTOR(S) IS (ARE) TO BE
C  USED WITH THE RANDOM VARIABLES.



 7220   CONTINUE



C/////////////   ENTER RANDOM AND FIXED PARAMETER INFO.  ///////////////
C///////////////////////////  ABOVE  ///////////////////////////////////


C
C
	ENDIF
C
C



      CALL WRITEINFILE(7,PATHFILAST,IDELTA,XMIC,ICENT,
     1   AUCINT,AF,INDPTS,MAXCYC,JSTOP,TOLC,NUMEQT,C0P,C1P,C2P,C3P,
     2   IERRMOD,GAMLAM0,IASS,NOFIX,VALFIX,NVAR,AB,NSUB,NSUBTOT,MAXSUB,
     3   IPATVEC,IFORMT,BLOCKPAT,PREFIX,EXT,NDRUG,FORFILE,NDIM,NP,IRAN,
     4   PAR,PARFIX,TOLER,INPRI,PRIFIL2,MAXNUMEQ,NRANFIX,PARRANFIX,
     5   RANFIXEST)

	CALL SYSTEM(ClearScreen)

	WRITE(*,2112)
 2112   FORMAT(/' YOU HAVE CHOSEN TO MODEL THE ASSAY ERROR FUNCTION,'/
     1' S.D. AS FOLLOWS (ASSUMING SD1 = C0+C1*Y+C2*Y**2+C3*Y**3):')

     	IF(IERRMOD .EQ. 1) WRITE(*,2113)
     	IF(IERRMOD .EQ. 2) WRITE(*,2114) GAMLAM0
     	IF(IERRMOD .EQ. 3) WRITE(*,2116) GAMLAM0

     	IF(IERRMOD .EQ. 4) WRITE(*,2117) GAMLAM0
 2113   FORMAT(/' S.D. = SD1')

 2114   FORMAT(/' S.D. = GAMMA*SD1, WITH GAMMA TO BE ESTIMATED, AND'/
     1'                  THE INITIAL GAMMA ESTIMATE TO BE ',G16.10)
 2116   FORMAT(/' S.D. = SQRT(SD1**2 + LAMBDA**2), WITH LAMBDA TO BE EST
     1IMATED'/
     2'                  AND THE INITIAL LAMBDA ESTIMATE TO BE ',G16.10)
 2117   FORMAT(/' S.D. = GAMMA, WITH GAMMA TO BE ESTIMATED, AND'/
     1'                  THE INITIAL GAMMA ESTIMATE TO BE ',G16.10)

	IF(IERRMOD .EQ. 4) THEN
	 WRITE(*,218)
  218    FORMAT(/' NOTE THAT THIS RUN WILL NOT USE THE ASSAY'/
     1' COEFFICIENTS IN YOUR PATIENT DATA FILES, BUT ANY PATIENT DATA'/

     2' FILES WITHOUT ASSAY COEFFICIENTS WILL HAVE A "1" PLACED IN '/

     3' EACH ASSAY COEFFICIENT LOCATION (AS A PLACEHOLDER).')

	ENDIF

	IF(IERRMOD .LT. 4) THEN



	WRITE(*,12) NUMEQT
   12   FORMAT(/' NOTE THAT THE GENERAL VALUES FOR [C0,C1,C2,C3] '/
     1' FOR EACH OF THE ',I2,' OUTPUT EQUATION(S), ARE SHOWN BELOW: '/)

	DO IEQ = 1,NUMEQT
	 WRITE(*,162) IEQ,C0P(IEQ),C1P(IEQ),C2P(IEQ),C3P(IEQ)
	 IAS = IASS(IEQ)
	 IF(IAS .EQ. 1) WRITE(*,419)
	 IF(IAS .EQ. 2) WRITE(*,519)
	 IF(IAS .EQ. 4) WRITE(*,619)
	 IF(IAS .EQ. 3 .AND. IALLPAT(IEQ) .EQ. 0) WRITE(*,819)
     1   ASSMULT(IEQ),ASSMULT(IEQ)
	END DO

  162   FORMAT(' EQ. ',I2,': ',4(G16.10,1X))

  419   FORMAT(/' EACH PATIENT WILL BE ASSIGNED THE ASSAY COEFFICIENTS'/
     1' IN HIS/HER DATA FILE; IF THERE ARE NO COEFFICIENTS IN THE DATA'/

     2' FILE, THE PATIENT WILL BE ASSIGNED THE ABOVE GENERAL VALUES.'/)

  519   FORMAT(/' EACH PATIENT WILL BE ASSIGNED THE ABOVE GENERAL'/
     1' ASSAY COEFFICIENTS (I.E., INDIVIDUAL ASSAY COEFFICIENTS IN ANY'/
     2' WORKING COPY PATIENT DATA FILE WILL BE OVERWRITTEN BY THE '/
     3' ABOVE VALUES.)'/)

  619   FORMAT(/' YOU WILL BE PROMPTED TO ENTER ASSAY COEFFICIENTS '/
     1' ON A PATIENT - BY - PATIENT BASIS (YOU MAY CHOOSE THE ABOVE'/
     2' GENERAL VALUES, COEFFICIENTS ALREADY IN THE PATIENT DATA'/
     3' FILE - IF ANY, OR ANY OTHER DESIRED SET). '/)

  819   FORMAT(/' YOU WILL BE PROMPTED TO ENTER ASSAY COEFFICIENTS '/
     1' ON A PATIENT - BY - PATIENT BASIS. YOU MAY CHOOSE TO HAVE '/
     2' THE CURRENT COEFFICIENTS (OR THE GENERAL VALUES FOR THOSE '/
     3' FILES WHICH HAVE NO COEFFICIENTS) MULTIPLIED BY ',G12.6
     4/
     3' TO LEAVE THEM UNCHANGED, OR TO SELECT A NEW SET OF VALUES.'//
     4' AT ANY POINT DURING THE PATIENT - BY - PATIENT ASSIGNMENT, YOU'/

     5' WILL BE ABLE TO HAVE THE COEFFICIENTS IN THE REMAINING PATIENT'/
     6' FILES MULTIPLIED BY ',G12.6,' AUTOMATICALLY.'///
     7' *******************  CAUTION  **********************************
     8***'//
     8' IF YOU HAVE ALREADY MULTIPLIED THE ASSAY COEFFICIENTS IN YOUR '/
     9' WORKING COPY FILES BY A CONSTANT FROM A PREVIOUS RUNNING OF THIS
     1 '/
     1' PROGRAM, SELECT  0  HERE TO CHANGE OPTIONS, AND THEN SELECT  1'/
     2' WHICH MEANS THAT EACH SUBJECT WILL BE ASSIGNED THE ASSAY '/

     3' COEFFICIENTS WHICH ARE CURRENTLY IN ITS FILE.'//
     7' *******************  CAUTION  **********************************
     8***')

	ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(IERRMOD .LT. 4)  CONDITION.

C
C
	CALL CHANGE(ICHANG)
	IF(ICHANG .EQ. 0) THEN
C
C
	CALL SYSTEM(ClearScreen)

 1110   WRITE(*,118)
  118 FORMAT(//' SELECT HOW YOU WOULD LIKE TO MODEL THE ASSAY ERROR'/
     1' FUNCTION, S.D. ASSUME SD1 = C0+C1*Y+C2*Y**2+C3*Y**3; THEN ...'//
     2' ENTER 1 IF S.D. = SD1;'/
     3' ENTER 2 IF S.D. = GAMMA*SD1, WITH GAMMA TO BE ESTIMATED;'/
     4' ENTER 3 IF S.D. = SQRT(SD1**2 + LAMBDA**2), WITH LAMBDA TO BE ES
     5TIMATED;'/
     6' ENTER 4 IF S.D. = GAMMA, WITH GAMMA TO BE ESTIMATED: ')
	READ(*,*,ERR=1110) IERRMOD

	IF(IERRMOD .LT. 1 .OR. IERRMOD .GT. 4) GO TO 1110


	IF(IERRMOD .GE. 2) THEN


	 ESTNAM = ' GAMMA'
	 IF(IERRMOD .EQ. 3) ESTNAM = 'LAMBDA'

  220	 WRITE(*,219) ESTNAM
  219    FORMAT(/' ENTER 1 TO START WITH AN INITIAL ESTIMATE OF 1 FOR ',
     1A6,';'/
     2' ENTER 0 TO ENTER A DIFFERENT INITIAL ESTIMATE FOR ',A6,': ')
	 READ(*,*,ERR=220) IGG
	 IF(IGG .NE. 1 .AND. IGG .NE. 0) GO TO 220

	 IF(IGG .EQ. 1) GAMLAM0 = 1.D0


	 IF(IGG .EQ. 0) THEN
  225     WRITE(*,223) ESTNAM
  223     FORMAT(/' ENTER THE INITIAL ESTIMATE FOR ',A6,' (A POSITIVE NO
     1.): ')
	  READ(*,*,ERR=220) GAMLAM0
	  IF(GAMLAM0 .LE. 0.D0) GO TO 225
	 ENDIF

	ENDIF


C  IF IERRMOD = 4, THE ASSAY ERROR FUNCTION WILL NOT DEPEND ON THE ASSAY

C  ERROR COEFFICIENTS IN EACH SUBJECT'S DATA FILE. IN THIS CASE, SKIP
C  THE IASS CODE BELOW SINCE IT'S IRRELEVANT. BUT SET

C  IASS(K) AND C0P(K), C1P(K), C2P(K), C3P(K) = 1, K=1,NUMEQT. THIS IS
C  REQUIRED TO MAKE SURE THAT ALL SUBJECTS HAVE REASONABLE COEFFICIENTS
C  AT THE BOTTOM OF THEIR FILES (SEE SUBROUTINE PUTASS BELOW).

	IF(IERRMOD .EQ. 4) THEN

	 DO KK = 1,NUMEQT
	  IASS(KK) = 1
	  C0P(KK) = 1.D0
	  C1P(KK) = 1.D0
	  C2P(KK) = 1.D0
	  C3P(KK) = 1.D0
	 END DO

	 WRITE(*,218)

	 GO TO 4150


	ENDIF


      CALL SYSTEM(ClearScreen)

      WRITE(*,119)
  119 FORMAT(//' NOW SELECT HOW TO ESTABLISH THE COEFFICIENTS FOR'/
     1' SD1 = C0 + C1*Y + C2*Y**2 + C3*Y**3.'//
     3' FOR EACH OF THE OUTPUT EQUATION(S), SELECT ONE OF THE FOLLOWING'
     4/

     5' OPTIONS FOR THE ASSAY COEFFICIENTS [C0,C1,C2,C3]: '//
     4' ENTER 1 FOR THE DEFAULT OPTION ...'/

     5'         FOR EACH PATIENT, IF THE DATA FILE ALREADY INCLUDES ASSA
     6Y'/
     7'         COEFFICIENTS, THOSE COEFFICIENTS WILL BE USED. OTHERWISE
     8 THE'/

     9'		COEFFICIENTS YOU ENTER BELOW WILL BE USED; '//
     8' ENTER 2 IF YOU WOULD LIKE THE ASSAY COEFFICIENTS YOU ENTER BELOW
     1 TO BE'/
     2'         USED FOR ALL PATIENTS, EVEN FOR THOSE WHOSE DATA FILES A
     3LREADY'/
     4'		INCLUDE COEFFICIENTS;'//
     2' ENTER 3 IF YOU WOULD LIKE THE ASSAY COEFFICIENTS ALREADY IN SOME
     3 OR ALL'/
     4'         OF THE PATIENT DATA FILES (OR THE GENERAL VALUES YOU ENT
     5ER BELOW)'/
     6'         TO BE MULTIPLIED BY A GIVEN CONSTANT;'//
     7' ENTER 4 IF YOU WOULD LIKE TO BE PROMPTED SO YOU MAY CHOOSE THE A
     8SSAY'/
     9'         COEFFICIENTS ON A PATIENT - BY - PATIENT BASIS. YOU MAY

     1CHOOSE'/
     2'         GENERAL VALUES (WHICH YOU WILL ENTER BELOW), COEFFICIENT

     3S ALREADY'/
     4'         IN THE PATIENT DATA FILE, IF ANY, OR ANY OTHER SET OF CO
     5EFFICIENTS. ')

C  FOR EACH OUTPUT, INPUT IASS AND [C0P,...,C3P].

	DO 2200 IEQ = 1,NUMEQT

 1120   WRITE(*,221) IEQ

  221   FORMAT(/' FOR OUTPUT EQUATION ',I1,':'//
     4' ENTER 1 FOR THE DEFAULT OPTION;'//
     8' ENTER 2 IF YOU WOULD LIKE THE ASSAY COEFFICIENTS YOU ENTER '/
     9' 	BELOW TO BE USED FOR ALL PATIENTS;'//
     1' ENTER 3 IF YOU WANT THE COEFFICIENTS IN SOME OR ALL OF YOUR '/
     2'		FILES MULITPLIED BY A SPECIFIED CONSTANT;'//
     7' ENTER 4 TO BE PROMPTED: ')

	READ(*,*,ERR=1120) IAS
	IF(IAS .LT. 1 .OR. IAS .GT. 4) GO TO 1120
	IASS(IEQ) = IAS

 2140   WRITE(*,2141) C0P(IEQ),C1P(IEQ),C2P(IEQ),C3P(IEQ)
 2141   FORMAT(/' ENTER 1 TO LEAVE THE GENERAL VALUES FOR [C0,C1,C2,C3]
     1UNCHANGED; '/
     2' 	THEY ARE CURRENTLY:'/
     3'	        ',4(G12.6,1X)//
     2' ENTER 0 TO CHANGE THESE GENERAL VALUES: ')
	READ(*,*,ERR=2140) ICHCS
	IF(ICHCS .NE. 0 .AND. ICHCS .NE. 1) GO TO 2140

	IF(ICHCS .EQ. 1) GO TO 2120

	WRITE(*,1119) IEQ
 1119   FORMAT(/' ENTER THE GENERAL VALUES FOR [C0,C1,C2,C3] FOR '/
     1' OUTPUT EQUATION ',I1,'. THESE ')
	IF(IAS .EQ. 1) WRITE(*,1121)

	IF(IAS .EQ. 2) WRITE(*,1122)
	IF(IAS .EQ. 4 .OR. IAS .EQ. 3) WRITE(*,1123)
 1121   FORMAT(' WILL BE USED FOR ALL PATIENTS WHOSE DATA FILES DO '/
     1' NOT ALREADY INCLUDE ASSAY COEFFICIENTS: ')

 1122   FORMAT(' WILL BE USED FOR ALL PATIENTS: ')
 1123   FORMAT(' WILL BE USED FOR THOSE PATIENTS YOU SELECT BELOW: ')
 4140   READ(*,*,ERR=4145) C0P(IEQ),C1P(IEQ),C2P(IEQ),C3P(IEQ)

   	GO TO 2120
 4145   WRITE(*,4146)
 4146   FORMAT(/' SEE ABOVE; PLEASE ENTER FOUR REAL NUMBERS: ')
	GO TO 4140

 2120	IF(IAS .EQ. 3) THEN

	 IALLPAT(IEQ) = 0


 4260	 WRITE(*,4148)
 4148    FORMAT(/' ENTER THE ASSAY COEFFICIENT MULTIPLIER TO BE USED'/
     1' FOR THOSE PATIENTS YOU SELECT BELOW: ')
	 READ(*,*,ERR = 4260) ASSMULT(IEQ)

	ENDIF

 2200   CONTINUE

        WRITE(*,2119)
 2119   FORMAT(//' NOTE: DURING THIS RUN, EACH SUBJECT WILL HAVE '/
     1'       HIS/HER ASSAY COEFFICIENTS WRITTEN TO THE END OF HIS/HER'/
     2'       WORKING COPY PATIENT FILE. IF COEFFICIENTS ARE ALREADY '/
     3'       THERE FROM A PREVIOUS RUN, THEY WILL BE OVERWRITTEN.'//)


	ENDIF

      CALL WRITEINFILE(7,PATHFILAST,IDELTA,XMIC,ICENT,
     1   AUCINT,AF,INDPTS,MAXCYC,JSTOP,TOLC,NUMEQT,C0P,C1P,C2P,C3P,
     2   IERRMOD,GAMLAM0,IASS,NOFIX,VALFIX,NVAR,AB,NSUB,NSUBTOT,MAXSUB,
     3   IPATVEC,IFORMT,BLOCKPAT,PREFIX,EXT,NDRUG,FORFILE,NDIM,NP,IRAN,
     4   PAR,PARFIX,TOLER,INPRI,PRIFIL2,MAXNUMEQ,NRANFIX,PARRANFIX,
     5   RANFIXEST)
C
C
C
 4150   WRITE(*,112) NDRUG
  112   FORMAT(/' THE ACTIVE (SALT) FRACTION OF EACH OF THE ',I1,' DRUG(
     1S) FOLLOWS.')
        
        DO I = 1,NDRUG
         WRITE(*,113) I,AF(I)
  113    FORMAT(' AF FOR DRUG ',I1,' IS ',G12.6)
        END DO

	CALL CHANGE(ICHANG)
	IF(ICHANG .EQ. 0) THEN


5150   WRITE(*,129)
  129   FORMAT(//' ENTER THE ACTIVE (SALT) FRACTION OF EACH DRUG. AS '/
     1' AN EXAMPLE, THE A.F. OF THEOPHYLLINE IS 1.0, WHILE THAT OF'/
     2' AMINOPHYLLINE IS TYPICALLY BETWEEN .79 AND .85, DEPENDING ON'/
     3' THE PREPARATION. '//
     4' EACH AF MUST BE A POSITIVE NUMBER LESS THAN OR EQUAL TO 1.0.'/)
       
        DO I = 1,NDRUG
         WRITE(*,1129) I
 1129    FORMAT(' AF FOR DRUG ',I1,': ')


         READ(*,*,ERR=5150) AF(I)
         IF(AF(I) .LE. 0.0 .OR. AF(I) .GT. 1.0) GO TO 5150

        END DO

	ENDIF



C  ESTABLISH THE 'SUGGESTED' NO. OF GRID POINTS FOR THIS RUN. NOTE THAT
C  THIS IS JUST A 'RULE-OF-THUMB', BASED ON RATHER LIMITED EXPERIENCE.

	IF(NVAR .EQ. 1 .OR. NVAR .EQ. 2) INDSUG=1
	IF(NVAR .EQ. 3) INDSUG=3
	IF(NVAR .EQ. 4) INDSUG=4
	IF(NVAR .EQ. 5) INDSUG=6
	IF(NVAR .GE. 6) INDSUG=7


	WRITE(*,6063) NVAR,INDSUG
 6063   FORMAT(//' *****************     WARNING    *****************'//
     1' YOU HAVE SELECTED ',I2,' PARAMETERS FOR THIS RUN.'/
     1' IT IS LIKELY THAT YOU WILL NEED AT LEAST AN INDEX OF GRID'/
     2' POINTS EQUAL TO  ',I1,'  TO ANALYZE YOUR DATA ADEQUATELY. A '/
     3' SMALLER INDEX MAY LEAD TO SIGNIFICANTLY POORER ESTIMATIONS.'/
     4' THE DISADVANTAGE TO MORE POINTS, OF COURSE, IS THAT THE '/
     5' PROGRAM TAKES PROPORTIONATELY LONGER TO RUN, BUT ONLY IN THE'/
     6' EARLY CYCLES UNTIL IT HAS DISCARDED UNNEEDED POINTS.'//
     4' *****************     WARNING    *****************'//)


	IF(INDPTS .LE. 6) WRITE(*,6061) INDPTS
 6061   FORMAT(/' THE INDEX OF THE NO. OF GRID POINTS IS ',I3)

	IF(INDPTS .GT. 6) WRITE(*,6066) INDPTS - 100
 6066    FORMAT(/' THE INDEX OF THE NO. OF GRID POINTS IS 7.'/
     1'  IN PARTICULAR, YOU HAVE CHOSEN ',I4,' MULTIPLES OF'/
     1'  80021 GRID POINTS FOR YOUR RUN.')

C
C
	CALL CHANGE(ICHANG)
	IF(ICHANG .EQ. 0) THEN
C
C
 6670   WRITE(*,6062)
 6062   FORMAT(/' ENTER THE INDEX FOR THE NO. OF GRID POINTS DESIRED.'/

     1' ENTER 1,2,3,4,5,6 OR 7, RESPECTIVELY, FOR, 2129, 5003, 10007,'/

     2' 20011, 40009, 80021, OR MULTIPLES OF 80021 POINTS: ')
 6065   READ(*,*,ERR=6670) INDPTS
	IF(INDPTS .LT. 1 .OR. INDPTS .GT. 7) GO TO 6670

	IF(INDPTS .EQ. 7) THEN
 6075	 WRITE(*,6064)
 6064    FORMAT(/' ENTER 2, 3, ... FOR THE NO. OF MULTIPLES OF '/

     1' 80021 GRID POINTS YOU WOULD LIKE: ')
	 READ(*,*,ERR=6075) MULT
	 IF(MULT .LT. 1) GO TO 6075

	 INDPTS = 100+MULT
	ENDIF


C  NOTE FROM THE ABOVE LOGIC, IF USER WANTS MULTIPLES OF 80021 GRID
C  POINTS, INDPTS IS NOW A NUMBER BETWEEN 101 AND INDMAX, AND THE NUMBER
C  OF GRID POINTS IS 80021*(INDPTS-100).
C  NOTE ALSO THAT MULT=1 (SO INDPTS = 101) IS ALLOWED (THOUGH THE USER
C  THINKS THAT MULT HAS TO BE BETWEEN 2 AND 100) SO I CAN CHECK THAT THE
C  RESULTS ARE THE SAME AS WHEN INDPTS = 6.


C
C
	ENDIF
C
C
	IF(MAXCYC .EQ. 0) WRITE(*,133)
  133   FORMAT(/' YOU HAVE CHOSEN THE MAX. NO. OF CYCLES TO BE 0.'/
     1' THIS MEANS THAT THE "engine" WILL DO NO CYCLE CALCULATIONS, '/
     2' BUT INSTEAD MOVE DIRECTLY TO THE END-OF-ANALYSIS SECTION TO '/
     3' CALCULATE VALUES NEEDED TO GIVE THE BAYESIAN POSTERIOR RESULTS'/
     4' FOR WHATEVER PATIENT DATA SET YOU CHOOSE, BASED ON THE PRIOR '/
     5' DENSITY YOU SELECT BELOW. THESE RESULTS CAN BE VIEWED BY '/
     6' RERUNNING THIS PROGRAM AND INPUTTING THE OUTPUT FILE FROM '/
     7' THE "engine". THIS IS SOMETIMES CALLED PROSPECTIVE ANALYSIS.')



	IF(MAXCYC .GT. 0) WRITE(*,13) MAXCYC,TOLC
   13   FORMAT(/' THE MAX NO. OF CYCLES IS ',I5//
     1' AND TOLC IS ',F20.17)

	CALL CHANGE(ICHANG)
	IF(ICHANG .EQ. 0) THEN
C
C
 4160 	WRITE(*,123)
  123   FORMAT(/' ENTER THE MAX. NO. OF CYCLES DESIRED (LESS THAN OR'/
     1' EQUAL TO 9997)'//
     2' NOTE THAT IF YOU ENTER 0, IT MEANS THAT THE "engine" WILL DO'/
     3' NO CYCLE CALCULATIONS, BUT INSTEAD MOVE DIRECTLY TO THE '/
     4' END-OF-ANALYSIS SECTION TO CALCULATE VALUES NEEDED TO GIVE '/
     5' THE BAYESIAN POSTERIOR RESULTS FOR WHATEVER PATIENT DATA SET'/
     6' YOU CHOOSE, BASED ON THE PRIOR DENSITY YOU SELECT BELOW.'/
     7' THESE RESULTS CAN BE VIEWED BY RERUNNING THIS PROGRAM AND'/
     8' INPUTTING THE OUTPUT FILE FROM THE "engine". THIS IS'/
     9' SOMETIMES CALLED PROSPECTIVE ANALYSIS.'//
     1' ENTER THE MAX. NO. OF CYCLES NOW: ')

        READ(*,*,ERR=4160) MAXCYC
	IF(MAXCYC .LT. 0 .OR. MAXCYC .GT. 9997) GO TO 4160


C  AS OF NPBIG1.FOR, JSTOP = 3 IS REQUIRED (I.E., JSTOP = 1 AND 2
C  HAVE BEEN ELIMINATED).

      TOLC = .01D0

	IF(MAXCYC .GT. 0) THEN

C  SET JSTOP = 3. IT WON'T BE USED BUT MUST BE IN THE FILE,
C  npag102.inp (NOW npag103.inp) SO THE FORMAT OF THE FILE WON'T HAVE 
C  TO CHANGE.


         JSTOP = 3

C  AS OF NPAG111.FOR, THE USER INPUTS TOLC, RATHER THAN TOL (WHICH WILL

C  STILL BE HARDCODED IN THE "ENGINE TO BE 1.D-4).

 1250    WRITE(*,1247)
 1247    FORMAT(/' NOTE THAT THE ANALYSIS WILL STOP BEFORE THE MAX.'/
     1' NO. OF CYCLES HAVE BEEN RUN IF CONVERGENCE IS ACHIEVED, AND'/
     2' CONVERGENCE IS ACHIEVED BASED ON LOGIC AND PRE-SET TOLERANCE'/
     3' PARAMETERS WHICH ARE APPROPRIATE FOR THE "INTERIOR POINT'/
     4' ALGORITHM" USED BY THIS PROGRAM. THIS ALGORITM WAS DEVELOPED'/
     5' BY JIM BURKE AT THE UNIVERSITY OF WASHINGTON, AND ADAPTED FOR'/
     6' THIS PROGRAM BY BOB LEARY.'//
     1' BUT YOU MAY SET THE TOLERANCE PARAMETER, TOLC. THE NPAG '/
     2' ANALYSIS WILL BE CONVERGE IF THE LOG-LIK BETWEEN 2 CONSECUTIVE'/
     3' "MAJOR CYCLES" IS LESS THAN OR EQUAL TO TOLC.'//
     4' ENTER A POSITIVE VALUE FOR TOLC NOW; .01 IS A TYPICAL VALUE: ')
         READ(*,*,ERR= 1250) TOLC

         IF(TOLC .LE. 0.D0) GO TO 1250 

	ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(MAXCYC .GT. 0) THEN  CONDITION.

C
C
C
	ENDIF
C
C
C
      CALL WRITEINFILE(7,PATHFILAST,IDELTA,XMIC,ICENT,
     1   AUCINT,AF,INDPTS,MAXCYC,JSTOP,TOLC,NUMEQT,C0P,C1P,C2P,C3P,
     2   IERRMOD,GAMLAM0,IASS,NOFIX,VALFIX,NVAR,AB,NSUB,NSUBTOT,MAXSUB,
     3   IPATVEC,IFORMT,BLOCKPAT,PREFIX,EXT,NDRUG,FORFILE,NDIM,NP,IRAN,
     4   PAR,PARFIX,TOLER,INPRI,PRIFIL2,MAXNUMEQ,NRANFIX,PARRANFIX,
     5   RANFIXEST)
C
C

C  AS OF NPAG113.FOR, HARDCODE ICENT = 2, AND REMOVE THE KEYBOARD I/O
C  FOR IT.

      ICENT = 2

      WRITE(*,2021) NSUB, IDELTA
 2021   FORMAT(/' ',I4,' INPUT TABLES (ONE FOR EACH SUBJECT) WILL BE'/
     1' CREATED FOR AN "EFFECTS" MODEL. '//
     2' EACH TABLE WILL GIVE THE PREDICTED CONCENTRATIONS OF THE DRUG'/
     3' FOR A GIVEN SUBJECT, ASSUMING PARAMETER VALUES EQUAL TO THE'/
     4' MEANS OF THE BAYESIAN POSTERIOR DISTRIBUTION FOR THAT SUBJECT,'/
     5' AT MULTIPLES OF ',I3,' MINUTES UNTIL THE ENDING TIME IS '/
     6' REACHED. THIS WILL BE REPEATED FOR BOTH THE MEDIANS AND THE'/
     7' MODES OF THE BAYESIAN POSTERIOR DISTRIBUTION FOR EACH SUBJECT.'/
     8)
     
	WRITE(*,2022) AUCINT,XMIC
 2022   FORMAT(/' IN ADDITION, AUC (AREA UNDER THE CURVE) AND AUC/MIC '/
     1' WILL BE CALCULATED FOR EACH ',F6.2,' HOUR PERIOD, AND FOR THE'/
     2' TOTAL TIME PERIOD, WHERE MIC = ',G12.6//)
C
C
	CALL CHANGE(ICHANG)
	IF(ICHANG .EQ. 0) THEN
C
C

	WRITE(*,2011) NSUB
 2011   FORMAT(/' ',I4,' TABLES OF PREDICTED CONCENTRATIONS, ONE FOR'/
     1' EACH SUBJECT, WILL BE GENERATED TO BE USED AS INPUTS FOR AN'/

     2' "EFFECTS" MODEL.'//
     2' EACH TABLE WILL GIVE THE PREDICTED CONCENTRATIONS OF THE DRUG'/
     3' FOR A GIVEN SUBJECT, ASSUMING PARAMETER VALUES EQUAL TO THE  '/
     4' MEANS OF THE BAYESIAN POSTERIOR DISTRIBUTION OF THAT SUBJECT.'
     5/

     6' THIS WILL BE REPEATED FOR BOTH THE MEDIANS AND THE MODES OF'/
     7' THE BAYESIAN POSTERIOR DISTRIBUTION FOR EACH SUBJECT.'//
     8' THE PREDICTED CONCENTRATIONS WILL BE AT THE TIMES YOU SELECT'/
     9' BELOW. IN ADDITION, AUC (AREA UNDER THE CURVE) AND AUC/MIC'/
     1' WILL BE CALCULATED FOR EACH USER SELECTED INTERVAL, AND FOR'/
     2' THE TOTAL TIME PERIOD.'//)


 2015   WRITE(*,2013)
 2013   FORMAT(/' ENTER THE TIME INTERVAL (IN MINUTES) BETWEEN'/
     1' PREDICTED CONCENTRATIONS. THIS VALUE MUST BE 2, 4, 6, OR 12:  ')
	READ(*,*,ERR=2015) IDELTA

	IF(IDELTA .NE. 2 .AND. IDELTA .NE. 4 .AND. IDELTA .NE. 6
     1  .AND. IDELTA .NE. 12) GO TO 2015


        WRITE(*,2014) NSUBTOT
 2014   FORMAT(/' THE ENDING TIME (IN HOURS), FOR THE PREDICTED'/
     1' CONCENTRATIONS WILL BE 24 HOURS AFTER THE LAST OBSERVATION'/
     2' TIME AMONG ALL ',I4,' SUBJECTS.')

C  THE ENDING TIME IS T_END; IT WILL BE DETERMINED AS THE

C  PATIENT DATA FILES ARE BEING CONCATENATED ONTO npag103.inp.

 2025   WRITE(*,2016)
 2016   FORMAT(/' THE DEFAULT FOR THE MIC (MINIMUM INHIBITORY '/

     1' CONCENTRATION) IS 1.0; '/
     2' ENTER 1 FOR THIS DEFAULT VALUE;'/
     3' ENTER 0 TO ENTER A DIFFERENT VALUE: ')
	READ(*,*,ERR=2025) IXMIC
	IF(IXMIC .NE. 1 .AND. IXMIC .NE. 0) GO TO 2025

	IF(IXMIC .EQ. 1) XMIC = 1.D0

	IF(IXMIC .EQ. 0) THEN
 2030	 WRITE(*,2023)
 2023    FORMAT(/' ENTER THE MIC (IT MUST BE A POSITIVE NUMBER):  ')
	 READ(*,*,ERR=2030) XMIC
	 IF(XMIC .LE. 0.D0) GO TO 2030
	ENDIF

 3025   WRITE(*,3016)
 3016   FORMAT(/' THE AUC (AREA UNDER THE CURVE) AND AUC/MIC WILL BE'/
     9' CALCULATED OVER EACH AUCINT-HOUR INTERVAL, AND FOR THE TOTAL '/
     1' TIME PERIOD.'//

     2' ENTER 1 FOR THE DEFAULT VALUE FOR AUCINT OF 24 HOURS;'/
     3' ENTER 0 TO ENTER A DIFFERENT VALUE FOR AUCINT: ')
	READ(*,*,ERR=3025) IAUCINT
	IF(IAUCINT .NE. 1 .AND. IAUCINT .NE. 0) GO TO 3025

	IF(IAUCINT .EQ. 1) AUCINT = 24.D0

	IF(IAUCINT .EQ. 0) THEN
 3030	 WRITE(*,3023)
 3023    FORMAT(/' ENTER THE DESIRED VALUE FOR AUCINT (IN HOURS):  ')
	 READ(*,*,ERR=3030) AUCINT
	 IF(AUCINT .LE. 0.D0) GO TO 3030
	ENDIF
C
C
	ENDIF
C
C

        IF(INPRI .EQ. 1) WRITE(*,7182)
 7182   FORMAT(/' THE APRIORI DENSITY FOR YOUR RUN IS UNIFORM.')
        IF(INPRI .EQ. 0) WRITE(*,7183) PRIFIL2
 7183   FORMAT(/' THE APRIORI DENSITY FOR YOUR RUN IS FROM THE '/
     1' DENSITY FILE, ',A20)
  
      CALL CHANGE(ICHANG)
      IF(ICHANG .EQ. 0) THEN

        WRITE(*,4311) NVAR
 4311   FORMAT(///' THE APRIORI DENSITY IS DEFINED ON A ',I1,'  ' /
     1' DIMENSIONAL GRID BOUNDED BY THE LIMITS ENTERED ABOVE.'//
     2' ENTER 1 IF A UNIFORM PRIOR IS DESIRED;'/
     3' ENTER 0 IF A SPECIFIED PRIOR IS TO BE READ IN FROM A '/
     4'         USER-SUPPLIED FILE OF DENSITY VALUES '/
     5'         FROM THE OUTPUT OF A PREVIOUS RUN.'//
     6' (CAUTION: BEFORE USING A PREVIOUS JOINT DENSITY, THE USER'/
     7' SHOULD VERIFY THAT IT WAS DEFINED FOR THE SAME NO. OF GRID'/
     8' POINTS, AND FOR THE SAME PARAMETERS AND RANGES AS ENTERED'/
     9' ABOVE FOR THIS RUN):  ')
 4315   READ(*,*,ERR=4320) INPRI
        GO TO 4325
 4320   WRITE(*,4035)
 4035   FORMAT(/' SEE ABOVE; PLEASE ENTER 0 OR 1: ')

        GO TO 4315

 4325   IF (INPRI .NE. 0 .AND. INPRI .NE. 1) THEN
	   WRITE(*,138)
  138   FORMAT(/' PLEASE ENTER ONE OF THE REQUESTED VALUES: ')

	   GO TO 4315
	ENDIF

      IF(INPRI .EQ. 0) THEN

 4340	WRITE(*,4341)
 4341   FORMAT(/' ENTER THE NAME OF THE FILE HAVING THE '/
     1' DENSITY VALUES FROM THE END OF A PREVIOUS RUN (THIS'/
     2' FILE ALSO HAS ASSOCIATED INSTRUCTIONS); ')

       WRITE(*,*)' ENTER -99 TO SEE ALL OR A PART OF YOUR DIRECTORY: '
       READ(*,102) PRIFIL2

       IF(PRIFIL2(1:3) .EQ. '-99') THEN
       CALL SEEDIR(PATH,NOB,PRIFIL2,OSName,ListDir)

      ENDIF


      ENDIF 
C  THE ABOVE ENDIF IS FOR THE  IF(INPRI .EQ. 0)  CONDITION.

      ENDIF
C  THE ABOVE ENDIF IS FOR THE  IF(ICHANG .EQ. 0)  CONDITION.


      CALL WRITEINFILE(7,PATHFILAST,IDELTA,XMIC,ICENT,
     1   AUCINT,AF,INDPTS,MAXCYC,JSTOP,TOLC,NUMEQT,C0P,C1P,C2P,C3P,
     2   IERRMOD,GAMLAM0,IASS,NOFIX,VALFIX,NVAR,AB,NSUB,NSUBTOT,MAXSUB,
     3   IPATVEC,IFORMT,BLOCKPAT,PREFIX,EXT,NDRUG,FORFILE,NDIM,NP,IRAN,
     4   PAR,PARFIX,TOLER,INPRI,PRIFIL2,MAXNUMEQ,NRANFIX,PARRANFIX,
     5   RANFIXEST)

 5005   WRITE(*,5001)
 5001   FORMAT(///' ENTER 1 IF ALL INSTRUCTIONS ARE NOW CORRECT;'/
     2' ENTER 0 OTHERWISE: ')
        READ(*,*,ERR=5005) ICHANG
	IF(ICHANG .NE. 0 .AND. ICHANG .NE. 1) GO TO 5005
	IF(ICHANG .EQ. 0) GO TO 5020


	RETURN
	END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
	SUBROUTINE CHANGE(ICHANG)
C
C  THIS SUBROUTINE IS CALLED BY SUBROUTINE VERIF1 TO HAVE THE USER CHECK
C  WHETHER HIS INPUT INFO IS CORRECT OR NEEDS TO BE CHANGED.
C
C  INPUT: NOTHING
C
C  OUTPUT:
C
C  ICHANG = 1 IF INFO PRINTED PREVIOUSLY TO THE SCREEN IS CORRECT.
C         = 0 IF INFO PRINTED PREVIOUSLY TO THE SCREEN SHOULD BE
C             CHANGED.
C
   10   WRITE(*,1)

    1   FORMAT(//' ENTER 1 IF THE ABOVE INFORMATION IS CORRECT;'/
     1' ENTER 0 IF IT SHOULD BE CHANGED: ')
	READ(*,*,ERR=10) ICHANG
	IF(ICHANG .NE. 0 .AND. ICHANG .NE. 1) GO TO 10
	RETURN
	END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
        SUBROUTINE FORMLC(PATH,NGRID,NACTVE,VOLSPA,MAXGRD,MAXDIM,CORDEN,
     1  WORK,ICAT,NVAR,PAR,NOFIX,PARFIX,VALFIX,AF,IVER,NDRUG,NRANFIX,
     2  PARRANFIX,RANFIXEST)

	IMPLICIT REAL*8(A-H,O-Z)
	DIMENSION CORDEN(MAXGRD,MAXDIM+1),WORK(MAXGRD),PCAT(21),
     1  VALFIX(20),AF(7),RANFIXEST(20)

	INTEGER ICAT(MAXGRD),NPTCAT(21)
	CHARACTER PAR(30)*11,PARFIX(20)*11,PREFIX*8,PATH*60,
     1  TMPFILE*13,PATHFILE*73,READLINE*1000,DRUG*20,
     2  YOURNAME*20,PARRANFIX(20)*11


	CHARACTER*10 DATDAY,TIMDAY,ZONEDAY
	INTEGER IDTDAY(10)



C  THIS ROUTINE PRINTS TO THE SCREEN THE 'SIGNIFICANT' PROBABILITIES AND
C  THEIR ASSOCIATED GRID POINTS. IF THE USER DESIRES, THESE VALUES CAN
C  BE PUT INTO AN M-FILE. THE USER DECIDES THE 'SIGNIFICANT' THRESHOLD
C  BELOW.

C  INPUT ARE:

C  PATH = LOCATION (DIRECTORY) OF PATIENT DATA FILES.
C  NGRID = NO. OF GRID POINTS.
C  NACTVE = NO. OF CURRENTLY ACTIVE GRID POINTS.
C  VOLSPA = VOLUME OF THE INTEGRATION SPACE.
C  MAXGRD = MAXIMUM ALLOWABLE NO. OF GRID POINTS (PASSED SO VARIABLE
C           VECTORS MAY BE DIMENSIONED PROPERLY.
C  MAXDIM = DIMENSION FOR CORDEN.
C  CORDEN(I,J) = JTH COORDINATE FOR THE ITH GRID POINT, J=1,NVAR;

C		 I=1,NACTVE;
C		 DENSITY FOR THE ITH GRID POINT, J=NVAR+1;I=1,NACTVE.
C  WORK(I) = DUMMY VECTOR; PASSED SO THAT IT CAN BE VARIABLY DIMENSIONED
C            IN THIS ROUTINE, I=1,NGRID.
C  ICAT(I) = DUMMY VECTOR; PASSED SO THAT IT CAN BE VARIABLY DIMENSIONED

C            IN THIS ROUTINE, I=1,NGRID.
C  NVAR = NO. OF RANDOM VARIABLES.
C  PAR(I) = NAME OF VARIABLE I, I=1,NVAR.
C  NOFIX = NO. OF PARAMETERS WHOSE FIXED VALUES WERE SET BY THE USER.
C  PARFIX(I) = NAME OF FIXED PARAMETER I, I=1,NOFIX.
C  VALFIX(I) = VALUE OF FIXED PARAMETER I, I=1,NOFIX.
C  NRANFIX = NO. OF PARAMETERS WHOSE RANFIX VALUES WERE ESTIMATED.
C  PARRANFIX(I) = NAME OF RANFIX PARAMETER I, I=1,NRANFIX.
C  RANFIXEST(I) = ESTIMATE OF RANFIX PARAMETER I, I=1,NRANFIX.



C  NDRUG = NO. OF DRUGS. NOTE THAT IF NDRUG = -1, IT MEANS THAT THE

C   NO. OF DRUGS IS UNKNOWN, BUT THAT ALL AF VALUES ARE THE SAME, AND
C   EQUAL TO AF(1) (SEE CODE IN SUBROUTINE EXTRAOPT).
C  IF NDRUG .NE. -1, THEN
C   AF(I), I=1,NDRUG = ACTIVE (SALT) FRACTION FOR THE DRUG FOR DRUG I.

C  OUTPUT ARE:


C  TABLE TO SCREEN SUMMARIZING THE NO. OF JOINT DENSITY GRID POINTS
C  WITH PROBABILITIES IN 21 DIFFERENT REGIONS.


C  IF USER DESIRES:

C  OUTPUT FILE (WITH EXTENSION .MM, SO IT CAN BE READ IN BY THE BIGMM
C  PROGRAM) CONTAINING A LOT OF INFO, INCLUDING ALL THE GRID POINTS
C  AND ASSOCIATED PROBABILITIES OF THOSE POINTS WHOSE PROBABILITIES
C  EXCEED A MINIMUM VALUE REQUESTED BY THE USER (WHO SELECTS THIS
C  'THRESHOLD' VALUE AFTER EXAMINING THE TABLE ABOVE).

C  CONVERT THE CONTINUOUS PROBABILITY VALUES IN COLUMN NVAR+1 OF
C  CORDEN TO THE CORRESPONDING DISCRETE VALUES. PUT THESE VALUES INTO
C  WORK. I.E., THE SUM OF NACTVE VALUES IN WORK WILL SUM TO 1.0.

	FACT=VOLSPA/NGRID

	DO I=1,NACTVE
	 WORK(I)=CORDEN(I,NVAR+1)*FACT
	END DO

C  ESTABLISH OUTPUT TABLE. 1ST 0-OUT VECTORS.
C  ICAT(I) WILL BE THE CATEGORY (1,2,...,21) FOR GRID POINT I.
C  PCAT(IC) WILL BE THE SUM OF THE PROBABILITES OF ALL THE GRID POINTS
C  IN CATEGORY IC (IC=1,...,21).
C  NPTCAT(IC) WILL BE THE NO. OF GRID POINTS IN CATEGORY IC.



	DO I=1,NACTVE
	 ICAT(I)=0
	END DO




	DO IC=1,21
	 PCAT(IC)=0.D0
	 NPTCAT(IC)=0
	END DO


	DO 100 I=1,NACTVE


	W=WORK(I)


	 DO IC=1,20


C  NOTE THAT THE PROBABILITY RANGES FOR CATEGORIES  1,2,...,21 ARE,


C  RESPECTIVELY, (1.D-1, 1.0], (1.D-2, 1.D-1], ..., (1.D-20, 1.D-19],
C  AND [0, 1.D-20].

	  IF(W .GT. 10.D0**(-IC) .AND. W .LE. 10.D0**(1-IC)) THEN

	   ICAT(I)=IC
	   PCAT(IC)=PCAT(IC)+W
	   NPTCAT(IC)=NPTCAT(IC)+1
	   GO TO 100

	  ENDIF

	 END DO


C  PUT ANY POINT NOT ALREADY ASSIGNED INTO CATEGORY 21.




	 ICAT(I)=21
	 PCAT(21)=PCAT(21)+W

	 NPTCAT(21)=NPTCAT(21)+1


  100   CONTINUE

  150   WRITE(*,1)
    1   FORMAT(///' THE FOLLOWING TABLE SUMMARIZES, FOR THE FINAL'/
     1' DENSITY, THE NO. OF GRID POINTS WHICH HAVE ASSOCIATED DISCRETE'/
     2' PROBABILITIES IN EACH OF THE RANGES INDICATED. ALSO,'/
     3' CUMULATIVE VALUES ARE SHOWN: ')

	WRITE(*,2)
    2   FORMAT(//' CAT     PROB.  RANGE   NO. PTS  CUM NO. PTS  PROB(CAT
     1) CUM PROB OF PTS.')


	NPTCUM=0
	CURLOW=1.D0

	CURHI =1.D1
	CUMPRB=0.D0

	DO IC=1,21
	 CURLOW=CURLOW/10.D0
	 IF(IC .EQ. 21) CURLOW=0.D0
	 CURHI =CURHI/10.D0
	 NPTCUM=NPTCUM+NPTCAT(IC)
	 CUMPRB=CUMPRB+PCAT(IC)
	 WRITE(*,3) IC,CURLOW,CURHI,NPTCAT(IC),NPTCUM,PCAT(IC),CUMPRB
	END DO

    3   FORMAT(1X,I2,2X,'(',G7.1,',',G8.1,']',1X,I5,5X,I5,7X,G12.6,3X,
     1  G12.6)



  220 	WRITE(*,221)
  221   FORMAT(/' ENTER 1 TO CREATE A FILE WITH THE ABOVE GRID POINT'/
     1'		AND PROBABILITY INFORMATION, ALONG WITH RELATED'/
     2'		STATISTICS FROM THE FINAL POPULATION JOINT DENSITY.'/

     3'		THIS FILE CAN BE INPUT TO THE     BIGMM     PROGRAM. '/
     2' ENTER 0 OTHERWISE: ')
	READ(*,*,ERR=220) IWRITE
	IF(IWRITE .NE. 1 .AND. IWRITE .NE. 0) GO TO 220


	IF(IWRITE .EQ. 0) RETURN

  110   WRITE(*,4)
    4   FORMAT(//' ENTER THE CUT-OFF CATEGORY. ALL POINTS AND THEIR'/
     1' ASSOCIATED DISCRETE PROBABILITIES IN CATEGORIES 1 DOWN TO'/
     2' THIS CATEGORY WILL BE OUTPUT INTO A FILE BELOW.'//

     4' ENTER AN INTEGER FROM 1 TO 21;'//
     5' ENTER 0 TO SEE THE SUMMARY TABLE AGAIN: ')
	READ(*,*,ERR=110) ICUT
	IF(ICUT .LT. 0 .OR. ICUT .GT. 21) GO TO 110


	IF(ICUT .EQ. 0) GO TO 150

  300	WRITE(*,6)
    6   FORMAT(//' ENTER THE PREFIX NAME OF THE FILE TO HOLD THE '/
     1' INFORMATION INDICATED ABOVE (THE EXTENSION WILL BE ".MM"): ')
	READ(*,77) PREFIX
   77   FORMAT(A8)

C  MAKE SURE THAT PREFIX HAS NO "."'S IN IT, IN CASE THE USER ENTERED
C  A FULL FILENAME INSTEAD OF JUST A PREFIX.


	DO IA = 1,8
	 IF(PREFIX(IA:IA) .EQ. '.') THEN
	  WRITE(*,76)
   76     FORMAT(/' PLEASE ENTER YOUR FILE PREFIX WITH NO DOTS (".") ')
	  GO TO 300
	 ENDIF

	END DO

C  CALL FULLNAME WHICH CONVERTS THE FILENAME TO PATHFILE, THE COMPLETE
C  NAME OF THE FILE, WHICH INCLUDES THE PATH (IF THE PATH IS NOT THE
C  CURRENT DIRECTORY).

	TMPFILE = ' '

	TMPFILE = PREFIX//'.MM'
	CALL FULLNAME(PATH,TMPFILE,PATHFILE)
	OPEN(32,FILE=PATHFILE,ERR=310,STATUS='NEW')
	GO TO 315
  310   WRITE(*,9826) PATHFILE
 9826   FORMAT(/' THE FOLLOWING FILE ALREADY EXISTS ....'/
     1'    ',A73/
     1' ENTER 0 TO ENTER A NEW FILENAME;'/
     2' ENTER 1 TO OVERWRITE THIS FILE: ')

	READ(*,*,ERR=310) IFILE
	IF(IFILE .NE. 0 .AND. IFILE .NE. 1) GO TO 310
	IF(IFILE .EQ. 0) GO TO 300
	IF(IFILE .EQ. 1) OPEN(32,FILE=PATHFILE)
  315   CONTINUE

    7   FORMAT(A20)


	WRITE(*,1316) PATHFILE
 1316   FORMAT(//' FILE  ',A73/
     1' SHOULD INCLUDE YOUR NAME, AND THE NAME OF THE DRUG ANALYZED IN'/
     2' THIS RUN. PLEASE ENTER THIS INFORMATION ...'//
     3' ENTER YOUR NAME: ')
	READ(*,7) YOURNAME
	WRITE(*,1317)
 1317   FORMAT(/' ENTER THE NAME OF THE DRUG: ')
	READ(*,7) DRUG


C     FOR NPBIG15, TIME AND DATE ROUTINES REPLACED BY DATE_AND_TIME.
 	CALL DATE_AND_TIME(DATDAY,TIMDAY,ZONEDAY,IDTDAY)

	WRITE(32,101) DRUG,DATDAY,YOURNAME
  101   FORMAT(/'#-BEGIN-FILE-------------------------------------------
     1-----'/
     2'#'/
     3'# USCPACK for Windows population model file'/
     4'# File revision 1.0'/
     5'#'/
     6'#-BEGIN-LOCKED-SECTION--------------------------------------'/
     7'#'/
     8'# The drug modeled                  : ',A20/

     9'# Date file was generated           : ',A10/
     1'# File genererated by program       : -9.9'/
     1'# This file was made by             : ',A20/
     2'# File authorized by                : Roger Jelliffe, LAPK'/
     3'# File lock code                    : 1'/
     4'#'/
     5'#-END-LOCKED-SECTION-(    -9.9      )----------------------- ')

	WRITE(32,102)
  102   FORMAT(/'#'/

     1'# File update list'/
     2'#'/
     3'# 11/20/2001 - Andreas Botnen'/
     4'#	       Manually converted from old file'/
     5'#')

	WRITE(32,103)
  103   FORMAT(/'# START DESCRIPTION')



C  AS OF NPBIG9, IF IVER .GE. 36, PUT THE CODE FROM npagdriv.f (WHICH
C  IS IN FILE 47) INTO FILE 32.

	IF(IVER .GE. 36) THEN
	 WRITE(32,13)

   13    FORMAT(//' FOLLOWING IS THE npagdriv.f CODE FROM THIS RUN.'//)
   11    FORMAT(A1000)
  350	 READ(47,11,IOSTAT=IEND) READLINE
	 IF(IEND .LT. 0) GO TO 400
	 WRITE(32,11) READLINE
	 GO TO 350
	ENDIF

	IF(IVER .LT. 36) WRITE(32,106)
  106   FORMAT(/'No description for this population model')


  400	WRITE(32,104)

  104   FORMAT(/'# END DESCRIPTION')



	WRITE(32,107)
  107   FORMAT(/'# The drug used in this analysis was')
	WRITE(32,7) DRUG

	WRITE(32,108)
  108   FORMAT(/'# The units to be used with this drug are'/
     1'-9.9')

	WRITE(32,109)
  109   FORMAT(/'# The molecular weight is'/
     1'-9.9')


        IF(NDRUG .EQ. -1) WRITE(32,211) AF(1)
  211   FORMAT(/' ALL DRUGS IN THE ANALYSIS HAD THE SAME AF, ',G12.6)


        IF(NDRUG .NE. -1) THEN  
         WRITE(32,111) NDRUG
  111    FORMAT(/'# The active salt fraction for each of the ',I2/
     1' drug(s) follow: ')
        
         DO I = 1,NDRUG
          WRITE(32,*) AF(I)

         END DO
        ENDIF

	WRITE(32,112)
  112   FORMAT(/'# The bioavailability is'/
     1'-9.9')

	WRITE(32,113)
  113   FORMAT(/'# The valid routes are'/
     1'-9.9')

	WRITE(32,114)
  114   FORMAT(/'# The ranges for the central compartment (peak and trou
     1gh)'/
     2'# use the value -1 if this selection is not valid for this model'
     3/
     4'# Usual ranges (peak min, peak max, trough min, trough max)'/
     5'-9.9'/
     6'# Not to exceede ranges (peak min, peak max, trough min, trough m
     7ax)'/
     8'-9.9')

	WRITE(32,116)

  116   FORMAT(/'# The ranges for the peripheral compartment (peak and t
     1rough)'/
     2'# use the value -1 if this selection is not valid for this model'
     3/

     4'# Usual ranges (peak min, peak max, trough min, trough max)'/
     5'-9.9'/

     6'# Not to exceede ranges (peak min, peak max, trough min, trough m
     7ax)'/
     8'-9.9')

	WRITE(32,117)

  117   FORMAT(/'# The assay polynomial (as1, as2, as3, as4)'/
     1'-9.9')


	WRITE(32,118)
  118   FORMAT(/'# The process noise (wsqrt, de1, de2, de3, de4, terr)'/
     1'-9.9')

	WRITE(32,119) NVAR
  119   FORMAT(/'# The number of random parameters'/
     1I2)

	WRITE(32,121) (PAR(I),I=1,NVAR)
  121   FORMAT(/'# The random parameters used were'/
     130(A11,1X))

	WRITE(32,127)

	WRITE(32,122) NOFIX
  122   FORMAT(/'# The number of fixed parameters'/
     1I2)

	WRITE(32,123)
  123   FORMAT(/'# The fixed parameters used were')
	IF(NOFIX .GE. 1) WRITE(32,124) (PARFIX(I),I=1,NOFIX)
  124   FORMAT(30(A11,1X))
	IF(NOFIX .EQ. 0) WRITE(32, 126)
  126   FORMAT('N/A')
	WRITE(32,127)
  127   FORMAT('-9.9')

	WRITE(32,128)
  128   FORMAT(/'# The values of the fixed parameters')
	IF(NOFIX .GE. 1) WRITE(32,129) (VALFIX(I),I=1,NOFIX)
  129   FORMAT(30(G12.4,1X))
	IF(NOFIX .EQ. 0) WRITE(32,127)

	WRITE(32,1122) NRANFIX
 1122   FORMAT(/'# The number of ranfix parameters'/
     1I2)

	WRITE(32,1123)
 1123   FORMAT(/'# The ranfix parameters used were')
      IF(NRANFIX .GE. 1) WRITE(32,124) (PARRANFIX(I),I=1,NRANFIX)
	IF(NRANFIX .EQ. 0) WRITE(32,126)
	WRITE(32,127)

	WRITE(32,1128)
 1128 FORMAT(/'# The values of the ranfix parameters')
      IF(NRANFIX .GE. 1) WRITE(32,129) (RANFIXEST(I),I=1,NRANFIX)
	IF(NRANFIX .EQ. 0) WRITE(32,127)





C  DETERMINE HOW MANY OF THE NACTVE GRID POINTS ARE TO BE INCLUDED
C  IN THE FILE (I.E., THOSE THAT "MAKE THE CUT").

	NOIN = 0

	DO I=1,NACTVE
	 IF(ICAT(I) .LE. ICUT) NOIN = NOIN + 1
	END DO

	WRITE(32,131) NOIN


  131   FORMAT(/'# The number of probability points'/
     1I10)

C  WRITE, FOR EACH SIGNIFICANT GRID POINT, THE PROBABILITY FOLLOWED
C  BY THE COORDINATES (IN SAME ORDER AS THE NAMES WRITTEN ABOVE).

	WRITE(32,132) (PAR(I),I=1,NVAR)
  132   FORMAT(/'# The probability matrix'/

     1'  PROBABILITY',3X,30(A11,2X))

	DO I=1,NACTVE

	 IF(ICAT(I) .LE. ICUT) THEN


C  INCLUDE POINT I. THE COORDINATES OF THIS POINT ARE CORDEN(I,J),
C  J=1,NVAR.

	  WRITE(32,18) WORK(I),(CORDEN(I,J),J=1,NVAR)


	 ENDIF

	END DO

   18   FORMAT(1X,G12.4,3X,30(G12.5,1X))

	WRITE(32,133)
  133   FORMAT(/'#-END-FILE----(       -9.9         )-------------------

     1-----'/)

     	CLOSE(32)



	RETURN
	END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
	SUBROUTINE PREVRUN(PATH,NOB,MAXSUB,MAXDIM,MAXGRD,CORDEN,CORHOLD,
     1  WORK,IJUNK,PYJGX,PYJGXX,EXX,YPREDPOP,YPREDPOPT,YPREDBAY,
     2  SERNUM,MAXOBDIM,YO,IPATVEC,OSName,ClearScreen,ListDir,MAXNUMEQ)

C  THIS ROUTINE, CALLED BY MAIN, EXAMINES THE RESULTS FROM A PREVIOUS
C  RUN. IN PARTICULAR, IT READS IN INFO FROM THE DENSITY FILE AND THE
C  OUTPUT FILE FROM A PREVIOUS RUN. IT ALSO CONCATENATES PATIENT DATA
C  FILES HAVING NAMES INDICATED IN THE OUTPUT FILE.

C  NOTE BELOW THAT MANY COMMENTS HAVE BEEN SUPPRESSED. TO SEE
C  DETAILS, EXAMINE SIMILAR CODE IN THE PC VERSION.


      IMPLICIT REAL*8(A-H,O-Z)

      DIMENSION YO(MAXOBDIM,MAXNUMEQ),WORK(MAXGRD),PYJGX(MAXSUB,MAXGRD),
     1 AB(30,2),VALFIX(20),PYJGXX(MAXGRD),EXX(MAXSUB,3,30),
     2 IJUNK(MAXGRD),YPREDPOP(MAXSUB,MAXNUMEQ,MAXOBDIM,3),
     3 YPREDBAY(MAXSUB,MAXNUMEQ,MAXOBDIM,3),CORDEN(MAXGRD,MAXDIM+1),
     4 CORHOLD(MAXGRD,MAXDIM+1),CENTER(3,30),SERNUM(MAXSUB),
     5 COEFF(999,5),C0(MAXNUMEQ),C1(MAXNUMEQ),C2(MAXNUMEQ),C3(MAXNUMEQ),
     6 COVAL(999,26),IPATVEC(MAXSUB),AF(7),RANFIXEST(20),
     7YPREDPOPT(MAXSUB,MAXNUMEQ,7201,3),TTPRED(MAXSUB,7200),NUMT(MAXSUB)

C    NOTE THAT COEFF HAS 1ST DIMENSION = 999, RATHER THAN MAXSUB ...
C    BECAUSE IT IS PASSED IN COMMON/TOSCAT, AND THIS ELIMINATES
C    HAVING TO PASS MAXSUB TO SCATPL10.FOR. IF MAXSUB EVER IS
C    INCREASED BEYOND 999, MUST INCREASE DIMENSION OF COEFF.

C    SIMILARLY FOR NUMBER(MAXSUB) --> NUMBER(999), SO DATABLK1.FOR
C    WON'T HAVE TO BE CHANGED.


	REAL YYPRED(150000),YYJ(150000),AMIN,AMAX,XCOV(999),YCOV(999)

      CHARACTER NUMBER(999)*3,PATFIL*20,PREFIX*5,PAR(30)*11,
     1EXT*3,PRIFIL2*20,PARFIX(20)*11,OUTFIL*20,
     3CODE*14,OUTSINGL*20,READLINE*1000,MNAME*7,OPT7FIL*20,
     4PATH*60,TMPFILE*13,PATHFILE*73,
     5XLABEL*20,YLABEL*20,XLABEL2*10,YLABEL2*10,OUTOPT8*20,DESCR(26)*20,
     6READLIN1*1000,BLOCKPAT*20,READLIN2*78,
     7OSName*20,ClearScreen*6,ListDir*10,PARRANFIX(20)*11

	CHARACTER*10 DATDAY,TIMDAY,ZONEDAY,ERRFIL*20

	INTEGER IDTDAY(10)

	COMMON/TOBLK/NUMBER
	COMMON/TOSCAT/MAXSER,MINSER,SERMEN,SERSD,COEFF

      COMMON/ERROR/ERRFIL
C  COMMON/ERROR/ IS SUPPLIED TO ALL THE ROUTINES WHICH COULD WRITE TO

C  ERRFIL. 



    1   FORMAT(A20)

  170   WRITE(*,5321)
 5321   FORMAT(//' ENTER THE NAME OF THE OUTPUT FILE FROM A PREVIOUS'/
     1' RUN.'//
     4' IT WILL BE OF THE FORM OUTxxxx, WHERE xxxx WAS THE JOB NUMBER'/
     5' ASSIGNED TO THE RUN.'//)
	WRITE(*,*)' ENTER -99 TO SEE ALL OR A PART OF YOUR DIRECTORY: '
        READ(*,1) OUTFIL
	IF(OUTFIL(1:3) .EQ. '-99') CALL SEEDIR(PATH,NOB,OUTFIL,OSName,
     1        ListDir)


C  CALL FULLNAME WHICH CONVERTS THE FILENAME TO PATHFILE, THE COMPLETE
C  NAME OF THE FILE, WHICH INCLUDES THE PATH (IF THE PATH IS NOT THE
C  CURRENT DIRECTORY).



     	TMPFILE = ' '
	TMPFILE = OUTFIL
	CALL FULLNAME(PATH,TMPFILE,PATHFILE)
	OPEN(45,FILE=PATHFILE,STATUS='OLD',ERR=95)
	GO TO 110
   95   WRITE(*,5316) PATHFILE
 5316   FORMAT(//' THE FOLLOWING FILE DOES NOT EXIST ... '/
     1'    ',A73)
	GO TO 170

C  1ST PRINT TO THE SCREEN A SUMMARY OF THE INPUT INFO FOR THE RUN, SO
C  THE USER CAN VERIFY THAT THIS RUN IS THE ONE HE WANTS.


  110	WRITE(*,*)
	WRITE(*,*)
       WRITE(*,*)' THE FOLLOWING INFO SUMMARIZES THE INPUT INSTRUCTIONS'
	WRITE(*,*)' FOR THE RUN WHOSE OUTPUT FILE YOU JUST ENTERED: '
	WRITE(*,*)

	ILINES=3

C  ILINES IS THE RUNNING TOTAL OF LINES PRINTED TO THE SCREEN SINCE THE
C  LAST PAUSE. EVERYTIME IT GETS TO 20, PAUSE THE OUTPUT.

    2   FORMAT(A1000)
  202   FORMAT(A78)

  150	READ(45,202) READLIN2
	ILINES=ILINES+1
	WRITE(*,1102) READLIN2
 1102   FORMAT(' ',A78)

	IF(ILINES .EQ. 20) THEN

	  ILINES=0
	ENDIF

	IF(READLIN2(5:15) .NE. '***********') GO TO 150

  160	WRITE(*,12)
   12   FORMAT(//' ENTER 1 IF THE OUTPUT FILE DESCRIBED ABOVE IS THE'/
     1'         ONE FROM THE RUN YOU WISH TO EXAMINE IN DETAIL;'/

     2' ENTER 0 IF YOU WISH TO ENTER ANOTHER OUTPUT FILE: ')
	READ(*,*,ERR=160) IANOT
	IF(IANOT .NE. 0 .AND. IANOT .NE. 1) GO TO 160

	IF(IANOT .EQ. 0) THEN
	  CLOSE(45)
	  GO TO 170
	ENDIF


	REWIND(45)


C  STARTING WITH NPAG101.FOR/npageng14.f/read14.f, THE VERSION 
C  REQUIRED WILL BE 41 OR NEWER.

	IVER=0
	READ(45,2) READLINE

	IF(READLINE(2:11) .EQ. 'VERSION 43') IVER=43   
	IF(READLINE(2:11) .EQ. 'VERSION 42') IVER=42   
	IF(READLINE(2:11) .EQ. 'VERSION 41') IVER=41

        IF(IVER .EQ. 0) THEN

         WRITE(*,3013)
 3013    FORMAT(/' THIS PROGRAM CANNOT READ YOUR OUTPUT FILE. YOU MUST'/
     1' INPUT AN OUTPUT FILE WITH "VERSION 41 ...", OR A MORE RECENT'/
     2' VERSION NO. ON THE FIRST LINE.'//
     3' THE PROGRAM STOPS.')

        OPEN(42,FILE=ERRFIL)
         WRITE(42,3013)  
        CLOSE(42)

        CALL PAUSE
        STOP

       ENDIF

C  STORE READLINE INTO READLIN1, WHICH CAN BE WRITTEN TO THE SCREEN
C  BELOW SO THE USER WILL KNOW WHICH ANALYSIS PROGRAM MADE THE OUTPUT
C  FILE.

	READLIN1 = READLINE

C  SEPARATE OUTFIL INTO 4 FILES, FILE 25 (WHICH
C  WILL BE THE SAME AS THE OLD OUTPUT FILE), FILE 34 (WHICH WILL BE THE
C  SAME AS THE OLD DENSITY FILE), FILE 27 (WHICH WILL BE THE
C  CONCATENATED PATIENT DATA FILE), AND FILE 47 (WHICH WILL BE THE
C  npagdriv.f file). CALL ROUTINE SEPARATE TO DO THIS.

C  THEN CALL GENNUM TO READ DOWN IN FILE 27 TO GET THE VALUE, NUMEQT
C  (NO. OF OUTPUT EQUATIONS).

        CALL SEPARATE
        CALL GETNUM(NUMEQT)

C OBTAIN THE NAME AND NUMBER OF THE PATIENT DATA FILES.

   50   READ(25,2) READLINE

        IF(READLINE(2:19) .NE. 'THE NEXT FEW LINES') GO TO 50


   80   READ(25,2) READLINE


        IF(READLINE(2:7) .EQ. 'PREFIX') THEN
         PREFIX = READLINE(9:13)
         EXT    = READLINE(24:26)

C  READ IN BOTH NSUBTOT AND NSUB AND THEN CALL ROUTINE GETIPATFF WHICH
C  READS THIS PORTION OF FILE 25 TO OBTAIN IPATVEC. NOTE THE 1ST
C  ARGUMENT TELLS GETIPATFF TO READ FILE 25.

C  NOTE THAT IF IERRR RETURNS AS -1, THERE IS A PROBLEM WITH THE
C  PATIENT NO. INFO ON THE FILE. IN THIS CASE, THE PROBLEM HAS ALREADY
C  BEEN WRITTEN TO THE SCREEN. SO STOP.

         CALL GETNSUB2(NSUBTOT)
         CALL GETNSUB(NSUB)
         CALL GETIPATFF(25,NSUBTOT,NSUB,MAXSUB,IPATVEC,IERRR)
         IF(IERRR .EQ. -1) STOP
         GO TO 200
        ENDIF

C  THE ABOVE ENDIF IS FOR THE
C  IF(READLINE(2:7) .EQ. 'PREFIX')  CONDITION.

        GO TO 80

  200	  CONTINUE

        IF(IVER .EQ. 41) THEN

  210   READ(25,2) READLINE
        IF(READLINE(2:10) .EQ. 'ACTIVE (S') THEN
         BACKSPACE(25)
         READ(25,164) AFSCALAR
  164    FORMAT(T27,G12.6)
         GO TO 165
        ENDIF

        GO TO 210


       ENDIF


C  THE ABOVE ENDIF IS FOR THE  IF(IVER .EQ. 41)  CONDITION.


        IF(IVER .GE. 42) THEN

 1210   READ(25,2) READLINE
        IF(READLINE(2:17) .EQ. 'THE NO. OF DRUGS') THEN
         READ(25,*) NDRUG
         READ(25,*) 
         READ(25,*)

         READ(25,*)
         READ(25,*) (AF(I),I=1,NDRUG)
         GO TO 165
        ENDIF

        GO TO 1210

        ENDIF




C  THE ABOVE ENDIF IS FOR THE  IF(IVER .GE. 42)  CONDTITION.



  165	CONTINUE

C  NOTE THAT IF IVER .LT. 42, NDRUG IS UNKNOWN, BUT THE AF FOR ALL THE
C  NDRUG DRUGS WAS THE SAME (AFSCALAR). IN THIS CASE, SET NDRUG = -1
C  AND AF(1) = AFSCALAR SO TOPFIL AND FORMLC WILL BE ABLE TO WRITE 
C  ACCURATE INFO IF THEY ARE CALLED BELOW.

C  NOTE THAT IF IVER .GE. 42, NDRUG WAS READ IN FROM THE OUTPUT FILE.

      IF(IVER .LT. 41) THEN
       NDRUG = -1
       AF(1) = AFSCALAR
      ENDIF


C  READ IN THE NO. OF GRID POINTS.

        REWIND(25)
  310   READ(25,2) READLINE

        IF(READLINE(2:26) .EQ. 'THE NO. OF GRID POINTS IS') THEN
         READ(25,*) NGRID
         GO TO 265
        ENDIF

        GO TO 310

  265   CONTINUE

C  IERRMOD AND THE LAST VALUE OF GAMLAM ARE NEAR THE END OF THE OUTPUT
C  FILE, SO READ TO THE END OF THE FILE, AND THEN BACKSPACE TO READ
C  IN THIS INFORMATION.


 5450   READ(25,2,IOSTAT=IEND) READLINE
        IF(IEND .GE. 0) GO TO 5450
 5550	  BACKSPACE(25)
        BACKSPACE(25)
        READ(25,2) READLINE
        IF(READLINE(2:25) .NE. 'IERRMOD AND THE ESTIMATE') GO TO 5550
        READ(25,*) IERRMOD, GAMLAM
	

C  THE 1ST LINE IN PRIFIL2 IS THE CODE WHICH
C  GIVES THE VERSION NO. OF THE DENSITY FILE. IF THE VERSION IS NOT
C  CORRECT, TELL THE USER AND HAVE HIM TRY AGAIN.

	READ(34,7123) CODE
 7123 FORMAT(A14)



        ICODEDEN = 0
        IF(CODE .EQ. 'DENSITY APR_10') ICODEDEN = 1
        IF(CODE .EQ. 'DENSITY OCT_15') ICODEDEN = 2

        IF(ICODEDEN .EQ. 0) THEN
         WRITE(*,7124)
 7124    FORMAT(//' SOMEHOW THE DENSITY PART OF THE FILE IN YOUR'/
     1' COMBINED OUTPUT FILE DOES NOT HAVE A CORRECT CODE ON THE'/
     2' FIRST LINE. THIS CODE MUST BE "DENSITY XXX_XX", WHERE XXX_XX'/
     3' IS APR_10 OR A MORE CURRENT DATE. '//
     3' IF YOU HAVE MANUALLY EDITED YOUR OUTPUT FILE, RERUN THE '/
     4' PROGRAM WITH THE ORIGINAL UNEDITED OUTPUT FILE. OTHERWISE,'/
     5' PLEASE SEND THE DETAILS OF YOUR RUN TO THE LAPK.'//)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,7124)  
        CLOSE(42)

        CALL PAUSE
        STOP

       ENDIF


        READ(34,*) NDIM
        READ(34,*) INDPTS


C  NOTE: STARTING WITH M2_11.FOR, INDPTS MAY BE .GT. 6. IN SUCH A CASE,
C        THE BOUNDARY OF THE 1ST VARIABLE IS DIVIDED INTO (INDPTS-100)
C	 REGIONS, EACH OF WHICH GETS 80021 GRID POINTS.

	READ(34,*) NACTVE

C  NOTE THAT NACTVE MUST BE .LE. MAXGRD SINCE PYJGX IS DIMENSIONED
C  (100,MAXGRD) AND MUST READ IN NACTVE GRID POINTS FOR EACH SUBJECT.
C  SEE BELOW.

	IF(NACTVE .GT. MAXGRD) THEN

	 WRITE(*,1718) NACTVE,MAXGRD,MAXGRD
 1718    FORMAT(//' THE NO. OF ACTIVE GRID POINTS IS ',I7,' WHICH IS'/
     1' MORE THAN THE MAXIMUM ALLOWED FOR THIS PROGRAM (',I7,'). RERUN'/
     2' THIS PROGRAM AFTER YOU HAVE REDUCED THE NO. OF GRID POINTS IN'/
     3' THE DENSITY FILE TO NO MORE THAN ',I7//)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,1718) NACTVE,MAXGRD,MAXGRD 
        CLOSE(42)

	 CALL PAUSE
	 STOP

	ENDIF

	READ(34,*) NVAR
	READ(34,1717) (PAR(I),I=1,NVAR)
 1717 FORMAT(A11)
	READ(34,*) NOFIX
	READ(34,1717) (PARFIX(I),I=1,NOFIX)



      IF(ICODEDEN .EQ. 2) THEN
       READ(34,*) NRANFIX
       READ(34,1717) (PARRANFIX(I),I=1,NRANFIX)
      ENDIF



	DO I=1,NVAR
	READ(34,*) (AB(I,J),J=1,2)
	END DO

	READ(34,*) (VALFIX(I),I=1,NOFIX)
      IF(ICODEDEN .EQ. 2) READ(34,*) (RANFIXEST(I),I=1,NRANFIX)



	READ(34,*) NINT
	READ(34,*) ICYCLE
	READ(34,*)
C DORIG IS NOT NEEDED, AND SO IS NOT READ IN IN ABOVE LINE.

	DO I=1,NACTVE
	READ(34,*) (CORDEN(I,J),J=1,NVAR+1)
	END DO

C  ALSO READ IN:

C   PYJGX(J,I) = P(YJ|XI), I=1,NACTVE, J=1,NSUB.

C   YPREDPOP(JSUB,IEQ,IOBS,ICEN) = THE PREDICTED VALUE FOR Y FOR SUBJECT
C     JSUB, FOR OUTPUT EQUATION IEQ, FOR OBSERVATION IOBS, FOR ICEN =
C     1 (MEANS), 2 (MEDIANS), AND 3 (MODES), WHERE THE MEANS, MEDIANS,
C     AND MODES ARE FROM THE FINAL CYCLE POPULATION DENSITY.

C   NUMT(J), J=1,NSUB, = THE NO. OF TOTAL OBSERVATION TIMES (OVER ALL
C    TIME RESETS) FOR SUBJECT J.

C   YPREDPOPT(JSUB,IEQ,J,ICEN) = THE PREDICTED VALUE FOR Y FOR SUBJECT
C     JSUB, FOR OUTPUT EQUATION IEQ, FOR THE JTH TIME IN TTPRED (SEE
C     BELOW, AND THE CODE IN THE NPAG "engine"), FOR
C     ICEN = 1 (MEANS), 2 (MEDIANS), AND 3 (MODES), WHERE THE MEANS,
C     MEDIANS, AND MODES ARE FROM THE FINAL CYCLE POPULATION DENSITY.

C   TTPRED(JSUB,J) = THE JTH OBSERVATION TIME FOR SUBJECT JSUB,
C    J=1,NUMT(JSUB).

C   YPREDBAY(JSUB,IEQ,IOBS,ICEN) = THE PREDICTED VALUE FOR Y FOR SUBJECT
C     JSUB, FOR OUTPUT EQUATION IEQ, FOR OBSERVATION IOBS, FOR ICEN =
C     1 (MEANS), 2 (MEDIANS), AND 3 (MODES), WHERE THE MEANS, MEDIANS,
C     AND MODES ARE FROM SUBJECT'S JSUB BAYESIAN POSTERIOR DENSITY
C     (CALCULATED BY SUBROUTINE SUBRES).

C   EXX(JSUB,ICEN,J) = THE JTH MEAN (ICEN=1), MEDIAN (ICEN=2), AND
C     MODE (ICEN=3), FOR SUBJECT JSUB, WHERE THE MEANS, MEDIANS, AND
C     MODES ARE FROM SUBJECT'S JSUB BAYESIAN POSTERIOR DENSITY
C     (CALCULATED BY SUBROUTINE SUBRES).

	DO JSUB=1,NSUB
	 DO I=1,NACTVE
	  READ(34,*) PYJGX(JSUB,I)
	 END DO
	END DO

	REWIND(27)
	DO JSUB=1,NSUB

	 CALL FILRED(NOBSER,YO,C0,C1,C2,C3,MAXOBDIM,MAXNUMEQ)
	 DO IEQ=1,NUMEQT
	  DO J=1,NOBSER
	   READ(34,*) (YPREDPOP(JSUB,IEQ,J,ICENTER),ICENTER=1,3)
	  END DO
	 END DO
	END DO

	 DO JSUB = 1,NSUB
	  READ(34,*) NUMT(JSUB)
	 END DO

	 DO JSUB=1,NSUB
	  DO IEQ=1,NUMEQT
	   DO J=1,NUMT(JSUB)
	    READ(34,*) (YPREDPOPT(JSUB,IEQ,J,ICENTER),ICENTER=1,3)
	   END DO
	  END DO
	 END DO

	 DO JSUB=1,NSUB
	  DO J=1,NUMT(JSUB)
	   READ(34,*) TTPRED(JSUB,J)
	  END DO
	 END DO

	REWIND(27)
	DO JSUB=1,NSUB

	 CALL FILRED(NOBSER,YO,C0,C1,C2,C3,MAXOBDIM,MAXNUMEQ)
	 DO IEQ=1,NUMEQT
	  DO J=1,NOBSER
	   READ(34,*) (YPREDBAY(JSUB,IEQ,J,ICENTER),ICENTER=1,3)

	  END DO
	 END DO
	END DO

	DO JSUB=1,NSUB
	 DO ICENTER=1,3
	  READ(34,*) (EXX(JSUB,ICENTER,J),J=1,NVAR)
	 END DO
	END DO

	CLOSE(34)

        VOLSPA=1.D0
        DO I=1,NVAR
        VOLSPA = VOLSPA*(AB(I,2)-AB(I,1))
	END DO


C  NOW ALLOW THE END OF ANALYSIS OPTIONS. SEE MAIN OF LITTLE NPEM
C  PROGRAM FOR DETAILED COMMENTS.


	NNACTVE=NACTVE

	DO I=1,NACTVE
	DO J=1,NVAR+1

	 CORHOLD(I,J) = CORDEN(I,J)

	END DO
	END DO

	ICOVHAVE = 0

 7185   CONTINUE

	NACTVE=NNACTVE
	DO I=1,NACTVE
	DO J=1,NVAR+1
	 CORDEN(I,J) = CORHOLD(I,J)
	END DO
	END DO


	CALL SYSTEM(ClearScreen)


        WRITE(*,7186)
 7186   FORMAT(/' ENTER 0 TO SEE THE VERSION NO. OF THE OUTPUT FILE;'/
     1' ENTER 1 TO SEE THE LAST CYCLE VALUES AGAIN;'/
     3' ENTER 4 TO SEE A SUMMARY TABLE OF THE GRID POINTS AND THEIR'/
     4'         PROBABILITIES (AND PRODUCE A MATLAB .M FILE OF THE DETAI
     5LS);'/
     7' ENTER 6 TO USE THE FINAL CYCLE POPULATION ESTIMATES TO PREDICT'/
     8'         CONCENTRATION VALUES FOR EACH SUBJECT;'/
     3' ENTER 7 TO OBTAIN THE BAYESIAN POSTERIOR DENSITY FOR EACH '/
     4'         INDIVIDUAL SUBJECT, USING THE FINAL CYCLE JOINT P.D.F.'/
     5'         OF THE ENTIRE POPULATION AS THE PRIOR DENSITY FOR EACH.'

     6/
     4' ENTER 8 TO SEE REGRESSION STATISTICS OF ANY DESCRIPTOR OR '/


     4'         RANDOM VARIABLE VS. ANY OTHER DESCRIPTOR OR RANDOM '/
     5'         VARIABLE (ACROSS ALL SUBJECTS);'/
     4' ENTER 9 TO STOP THE PROGRAM: ')

	READ(*,*,ERR=7185) IOPT
	IF(IOPT .NE. 1 .AND. IOPT .NE. 4 .AND. IOPT .NE. 6 .AND. IOPT
     1   .NE. 7 .AND. IOPT .NE. 8 .AND. IOPT .NE. 9 .AND. IOPT .NE. 0)
     2   GO TO 7185

	IF(IOPT .EQ. 0) THEN
	 WRITE(*,7187)
 7187    FORMAT(//' NOTE: THE OUTPUT FILE YOU ENTERED ABOVE HAS THE'/
     1'       FOLLOWING VERSION NO., AND WAS PRODUCED BY THE INDICATED'/
     2'       ANALYSIS PROGRAM ...'//)

	 WRITE(*,2) READLIN1

C  TO AVOID THE USE OF A PAUSE COMMAND (TO WHICH A GFORTRAN COMPILED
C  PROGRAM REQUIRES A "GO" IN RESPONSE), PUT IN FOLLOWING WRITE/READ
C  STATEMENTS.

	 WRITE(*,7188)

 7188  FORMAT(/' ENTER ANY CHARACTER TO CONTINUE: ')

       READ(*,*,ERR=7185) JUNK

       GO TO 7185
      ENDIF


	IF(IOPT .EQ. 9) THEN
 	  RETURN
	ENDIF


	IF(IOPT .EQ. 1) THEN

C  TO SEE THE LAST CYCLE VALUES, POSITION THE OUTPUT FILE TO THE LAST

C  LINE, AND THEN CALL SUBROUTINE PRNLAST, WHICH PRINTS THE LAST CYCLE.
C  NOTE: AS OF M2_7.FOR, IT ALSO PRINTS THE BAYESIAN POSTERIOR DENSITY

C        RESULTS FOR EACH SUBJECT.

  180	READ(25,2,IOSTAT=IEND) READLINE

	IF(IEND .GE. 0) GO TO 180


	CALL PRNLAST

	GO TO 7185

	ENDIF


	IF(IOPT .EQ. 4) THEN

C  PRINT TO A FILE THE 'SIGNIFICANT' PROBABILITIES AND THEIR ASSOCIATED
C  GRID POINTS. THIS FILE WILL BE USED BY THE MMLQ PROGRAM. CALL
C  SUBROUTINE FORMLC TO DO THIS.

	CALL FORMLC(PATH,NGRID,NACTVE,VOLSPA,MAXGRD,MAXDIM,CORDEN,WORK,
     1  IJUNK,NVAR,PAR,NOFIX,PARFIX,VALFIX,AF,IVER,NDRUG,NRANFIX,
     2  PARRANFIX,RANFIXEST)

	GO TO 7185

	ENDIF


	IF(IOPT .EQ. 6) THEN


 6550	WRITE(*,6546)
 6546   FORMAT(/' ENTER 0 IF YOU WOULD LIKE TO WRITE ALL THE NUMERICAL'/
     1'         RESULTS FROM THIS OPTION TO A FILE; '/
     2' ENTER 1 IF YOU DO NOT WANT TO WRITE THE RESULTS TO A FILE: ')
	READ(*,*,ERR=6550) ISAVFIL
	IF(ISAVFIL .NE. 0 .AND. ISAVFIL .NE. 1) GO TO 6550

C  IF THE USER DOES NOT WANT TO WRITE NUMERICAL RESULTS TO A FILE,
C  SET IPUT = 0.

	IF(ISAVFIL .EQ. 1) IPUT = 0

	IF(ISAVFIL .EQ. 0) THEN

C  SET IPUT = 1 WHICH MEANS THAT ALL NUMERICAL RESULTS WILL BE WRITTEN
C  TO THE FILE THE USER SELECTS BELOW.


	IPUT = 1

 5980   WRITE(*,5981)
 5981   FORMAT(/' ENTER THE NAME OF THE OUTPUT FILE TO SAVE ALL THE'/
     1' RESULTS: ')
	READ(*,1) OUTSINGL

C  CALL FULLNAME WHICH CONVERTS THE FILENAME TO PATHFILE, THE COMPLETE
C  NAME OF THE FILE, WHICH INCLUDES THE PATH (IF THE PATH IS NOT THE

C  CURRENT DIRECTORY).

     	TMPFILE = ' '
	TMPFILE = OUTSINGL
	CALL FULLNAME(PATH,TMPFILE,PATHFILE)
	OPEN(31,FILE=PATHFILE,ERR=5970,STATUS='NEW')
	GO TO 5975
 5970   WRITE(*,9826) PATHFILE
 9826   FORMAT(/' THE FOLLOWING FILE ALREADY EXISTS ....'/
     1'    ',A73/
     1' ENTER 0 TO ENTER A NEW FILENAME;'/

     2' ENTER 1 TO OVERWRITE THIS FILE: ')
	READ(*,*,ERR=5970) IFILE
	IF(IFILE .NE. 0 .AND. IFILE .NE. 1) GO TO 5970
	IF(IFILE .EQ. 0) GO TO 5980
	IF(IFILE .EQ. 1) OPEN(31,FILE=PATHFILE)
 5975   CONTINUE

C  PUT THE TIME AND DATE AT THE TOP OF THIS FILE.

C     FOR NPBIG15, TIME AND DATE ROUTINES REPLACED BY DATE_AND_TIME.
 	CALL DATE_AND_TIME(DATDAY,TIMDAY,ZONEDAY,IDTDAY)

	WRITE(31,*)
	WRITE(31,*)' TODAY IS ',DATDAY,'; THE TIME IS ',TIMDAY
	WRITE(31,*)
	WRITE(31,*)


	ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(ISAVFIL .EQ. 0)  CONDITION.


 9500   WRITE(*,9501) NUMEQT
 9501   FORMAT(//' YOUR PATIENT DATA FILES HAVE ',I2,' OUTPUT '/
     1' EQUATION(S). FOR EACH OUTPUT EQUATION, YOU MAY PREDICT LEVELS '/
     2' FOR EACH SUBJECT ASSUMING THAT SUBJECT HAS PARAMETER VALUES '/
     3' EQUAL TO EITHER THE POPULATION MEANS, THE POPULATION MEDIANS, '/
     4' OR THE POPULATION MODES FROM THE FINAL CYCLE. '//
     5' ENTER THE NO. OF THE OUTPUT EQUATION WHOSE LEVELS ARE TO BE'/
     6' PREDICTED: ')
	READ(*,*,ERR=9500) IOUTEQ
	IF(IOUTEQ .LT. 1 .OR. IOUTEQ .GT. NUMEQT) GO TO 9500

 9510   WRITE(*,9502)
 9502   FORMAT(/' ENTER 1 TO USE THE POPULATION MEANS; '/
     1' ENTER 2 TO USE THE POPULATION MEDIANS;'/
     2' ENTER 3 TO USE THE POPULATION MODES: ')
	READ(*,*,ERR=9510) ICENTER
	IF(ICENTER .LT. 1 .OR. ICENTER .GT. 3) GO TO 9510


 9505   CONTINUE


C  FOR NPBIG15.FOR, COMPILED UNDER LF90, OPTION COMMANDS REMOVED.
C  OPTION BREAK

C  THE ABOVE STATEMENT TELLS THE PROGRAM TO HALT IF THE USER
C  HITS A CNTRL+C (THIS IS THE DEFAULT OPTION). BELOW, JUST ABOVE
C  THE START OF LOOP 6000, OPTION BREAK(*9505) RETURNS CONTROL OF
C  THE PROGRAM TO LABEL 9505 IF THE USER PRESSES CNTRL+C.

C  NOW, ALLOW THE USER TO SPECIFY WHICH VALUES WILL BE CALCULATED.


        WRITE(*,8513)
 8513   FORMAT(//' ENTER 1 TO CALCULATE THE PREDICTED CONCENTRATION '/
     1'         LEVELS FOR THE ENTIRE POPULATION OF SUBJECTS AS A WHOLE;

     2'/
     2' ENTER 2 TO CALCULATE THE PREDICTED LEVELS FOR A SELECTED'/
     4'         SUBSET OF SUBJECTS;'/

     4' ENTER 3 TO CALCULATE THE PREDICTED LEVELS FOR EACH SUBJECT, IN'/
     5'         TURN;'/
     6' ENTER 0 TO RETURN TO THE PREVIOUS MENU:  ')

	READ(*,*,ERR=9505) ISCT
	IF(ISCT .LT. 0 .OR. ISCT .GT. 3) GO TO 9505

	IF(ISCT .EQ. 0) THEN
	 IF(ISAVFIL .EQ. 0) CLOSE(31)
	 GO TO 7185
	ENDIF

	IF(ISCT .EQ. 1) ISCAT = 3
	IF(ISCT .EQ. 3) ISCAT = 1
	IF(ISCT .EQ. 2) ISCAT = 2

C  REWIND SUBJECT FILE (27). SUBJECT INFO WILL BE READ IN THE
C  APPROPRIATE ORDER DEPENDING ON THE VALUE OF ISCAT.

	REWIND(27)


	IF(ISCAT .EQ. 1) THEN

C  FOR EACH SUBJECT, IN TURN, READ THE OBSERVED VALUES, ESTABLISH THE

C  PREDICTED VALUES (VIA YPREDPOP READ IN ABOVE), CALCULATE THE
C  LEAST SQUARES LINE  OBS = A + B*PRED, ALONG WITH ASSOCIATED
C  STATISTICS, AND THEN CONSTRUCT THE SCATTERGRAM OF VALUES.



	DO 6000 JSUB=1,NSUB


	CALL FILRED(NOBSER,YO,C0,C1,C2,C3,MAXOBDIM,MAXNUMEQ)

C  STORE PREDICTED AND ACTUAL OBSERVATIONS INTO REAL VECTORS YYPRED AND
C  YYJ. THEY WILL BE SUPPLIED TO SUBROUTINE SCATPLOT (WHICH CALCULATES
C  THE STATISTICS.

C  IT IS POSSIBLE THAT YO MAY HAVE -99'S IN SOME OF ITS NOBSER ENTRIES.
C  -99 --> AN OBSERVATION WAS NOT TAKEN FOR THAT OUTPUT EQUATION AT
C  A PARTICULAR TIME. WHEN STORING THE VALUES IN YO INTO YYJ, IGNORE
C  ANY -99'S. HAVE YYPRED IGNORE THE CORRESPONDING ENTRY FROM
C  YPREDPOP.

	NACTUAL = 0

	DO I=1,NOBSER
	 IF(YO(I,IOUTEQ) .NE. -99.) THEN
	  NACTUAL = NACTUAL + 1
	  YYPRED(NACTUAL) = YPREDPOP(JSUB,IOUTEQ,I,ICENTER)
	  YYJ(NACTUAL) = YO(I,IOUTEQ)
	 ENDIF
	END DO

C  STORE THE C'S FOR THE SELECTED OUTPUT EQUATION INTO C0I,...,C3I,
C  SCALAR VALUES TO BE PASSED TO SUBROUTINE SCATPLOT.


	C0I = C0(IOUTEQ)
	C1I = C1(IOUTEQ)
	C2I = C2(IOUTEQ)
	C3I = C3(IOUTEQ)

	IF(IPUT .EQ. 1) WRITE(31,8518) IOUTEQ

 8518 	FORMAT(//' ... FOR OUTPUT EQUATION ',I2,' ...'/)


       CALL SCATPLOT(1,ICENTER,IIOUT,IQUAL,JSUB,IPUT,NACTUAL,YYPRED,YYJ,
     1  C0I,C1I,C2I,C3I,AMIN,AMAX,0,IERRMOD,GAMLAM)

C  NOTE THAT AMIN AND AMAX ARE RETURNED FROM SCATPLOT. THEY ARE THE MIN
C  AND MAX VALUES (RESPECTIVELY) FOR THE SCALES OF THE PLOT JUST DONE.
C  AS OF NPBG15E1.FOR, NO SCATTERPLOTS ARE DONE, SO THE MIN AND
C  MAX VALUES ARE NOT USED.


 6000   CONTINUE


C  GO TO THE MAIN SCATPLOT MENU.

	GO TO 9505


	ENDIF

C  THE ABOVE ENDIF IS FOR THE   IF(ISCAT .EQ. 1)  CONDITION.


	IF(ISCAT .EQ. 2) THEN

 9520	WRITE(*,8514)
 8514   FORMAT(//' ENTER THE SUBJECT NO. WHOSE CALCULATIONS ARE DESIRED;

     1'/
     1' ENTER 0 TO RETURN TO THE PREVIOUS MENU: ')

	READ(*,*,ERR=9520) JSUB
	IF(JSUB .LT. 0 .OR. JSUB .GT. NSUB) GO TO 9520

	IF(JSUB .EQ. 0) GO TO 9505


C  REWIND SUBJECT FILE (27); THEN READ THROUGH JSUB-1
C  SUBJECTS TO REACH THE DESIRED SUBJECT.

	REWIND(27)


	IF(JSUB .GT. 1) THEN
	 DO J=1,JSUB-1
   	  CALL FILRED(NOBSER,YO,C0,C1,C2,C3,MAXOBDIM,MAXNUMEQ)
	 END DO
	ENDIF


	CALL FILRED(NOBSER,YO,C0,C1,C2,C3,MAXOBDIM,MAXNUMEQ)

C  STORE PREDICTED AND ACTUAL OBSERVATIONS INTO REAL VECTORS YYPRED AND
C  YYJ. THEY WILL BE SUPPLIED TO SUBROUTINE SCATPLOT (WHICH CALCULATES
C  THE STATISTICS INDICATED ABOVE).

C  IT IS POSSIBLE THAT YO MAY HAVE -99'S IN SOME OF ITS NOBSER ENTRIES.
C  -99 --> AN OBSERVATION WAS NOT TAKEN FOR THAT OUTPUT EQUATION AT
C  A PARTICULAR TIME. WHEN STORING THE VALUES IN YO INTO YYJ, IGNORE
C  ANY -99'S. HAVE YYPRED IGNORE THE CORRESPONDING ENTRY FROM
C  YPREDPOP.

	NACTUAL = 0
	DO I=1,NOBSER
	 IF(YO(I,IOUTEQ) .NE. -99.) THEN
	  NACTUAL = NACTUAL + 1
	  YYPRED(NACTUAL) = YPREDPOP(JSUB,IOUTEQ,I,ICENTER)
	  YYJ(NACTUAL) = YO(I,IOUTEQ)
	 ENDIF
	END DO


C  STORE THE C'S FOR THE SELECTED OUTPUT EQUATION INTO C0I,...,C3I,
C  SCALAR VALUES TO BE PASSED TO SUBROUTINE SCATPLOT.

	C0I = C0(IOUTEQ)
	C1I = C1(IOUTEQ)
	C2I = C2(IOUTEQ)
	C3I = C3(IOUTEQ)

	IF(IPUT .EQ. 1) WRITE(31,8518) IOUTEQ

C  IF NSUB .LT. NSUBTOT, THEN THE NSUB SUBJECTS USED
C  IN THE ANALYSIS WERE A SUBSET OF THE TOTAL OF NSUBTOT. TELL THE
C  USER WHICH SUBJECT JSUB IS OUT OF THE ENTIRE POPULATION.

        IF(NSUB .LT. NSUBTOT) THEN
         WRITE(*,8516) JSUB,NSUB,IPATVEC(JSUB),NSUBTOT
 8516    FORMAT(/' SUBJECT NO. ',I4,' AMONG THE ',I4,' "ACTIVE" '/

     1' SUBJECTS ANALYZED IN YOUR RUN, IS SUBJECT NO. ',I4,' IN THE'/
     2' ENTIRE POPULATION OF ',I4,' SUBJECTS.')
        ENDIF

       CALL SCATPLOT(1,ICENTER,IIOUT,IQUAL,JSUB,IPUT,NACTUAL,YYPRED,YYJ,
     1  C0I,C1I,C2I,C3I,AMIN,AMAX,0,IERRMOD,GAMLAM)

C  NOTE: AMIN AND AMAX ARE NOT USED UNLESS ISCAT = 1.


C  GO TO THE ISCAT=2 MENU.

	GO TO 9520



	ENDIF


C  THE ABOVE ENDIF IS FOR THE  IF(ISCAT .EQ. 2)  CONDITION


	IF(ISCAT .EQ. 3) THEN


C  STORE THE OBSERVED AND PREDICTED CONCENTRATION VALUES FOR ALL

C  SUBJECTS, AND THEN CALL SCATPLOT.

C  ALSO STORE INTO MATRIX COEFF THE ASSAY NOISE COEFFICIENTS FOR EACH
C  SUBJECT. THEY'LL BE NEEDED IN SUBROUTINE SCATPLOT (COEFF IS PASSED
C  TO SCATPLOT VIA COMMON/TOSCAT).

C  JSUBST = RUNNING INDEX OF THE NO. OF CONCENTRATION VALUES ALREADY
C  IN VECTORS YYPRED AND YYJ.

	JSUBST = 0

	DO 7000 JSUB=1,NSUB


	CALL FILRED(NOBSER,YO,C0,C1,C2,C3,MAXOBDIM,MAXNUMEQ)

C  STORE VALUES IN YPREDPOP AND YO INTO THE NEXT NACTUAL LOCATIONS OF
C  REAL VECTORS YYPRED AND YYJ, WHICH WILL BE SUPPLIED TO SUBROUTINE
C  SCATPLOT (WHICH CALCULATES THE STATISTICS INDICATED ABOVE) AFTER
C  LOOP 7000.

C  IT IS POSSIBLE THAT YO MAY HAVE -99'S IN SOME OF ITS NOBSER ENTRIES.
C  -99 --> AN OBSERVATION WAS NOT TAKEN FOR THAT OUTPUT EQUATION AT
C  A PARTICULAR TIME. WHEN STORING THE VALUES IN YO INTO YYJ, IGNORE
C  ANY -99'S. HAVE YYPRED IGNORE THE CORRESPONDING ENTRY FROM
C  YPREDPOP.

	NACTUAL = 0
	DO I=1,NOBSER
	 IF(YO(I,IOUTEQ) .NE. -99.) THEN
	  NACTUAL = NACTUAL + 1
	  YYPRED(JSUBST+NACTUAL) = YPREDPOP(JSUB,IOUTEQ,I,ICENTER)
	  YYJ(JSUBST+NACTUAL) = YO(I,IOUTEQ)
	 ENDIF
	END DO


C  NOTE THAT COEFF(JSUB,1) = NO. OF VALUES FOR THIS OUTPUT EQUATION.

	COEFF(JSUB,1) = NACTUAL
	COEFF(JSUB,2) = C0(IOUTEQ)
	COEFF(JSUB,3) = C1(IOUTEQ)
	COEFF(JSUB,4) = C2(IOUTEQ)
	COEFF(JSUB,5) = C3(IOUTEQ)

	JSUBST = JSUBST + NACTUAL

C  STORE NACTUAL INTO SERNUM(JSUB). BELOW, STATISTICS WILL BE CALCULATED
C  FOR THE NO. OF SERUM LEVELS OVER ALL SUBJECTS.


	SERNUM(JSUB)=NACTUAL

 7000   CONTINUE

C  CALL SUBROUTINE CALCSER TO FIND THE MAX,MIN,MEAN, AND STD. DEV. FOR
C  THE NO. OF OBSERVATIONS (SERUM LEVELS) OVER ALL THE SUBJECTS. THIS
C  INFO IS PASSED IN COMMON/TOSCAT TO SUBROUTINE SCATPLOT (ONLY IN THIS
C  CASE -- ISCAT=3 [ALL SUBJECTS ANALYZED]).

	CALL CALCSER(MAXSUB,NSUB,SERNUM,MAXSER,MINSER,SERMEN,SERSD)

C  JSUBST IS NOW THE TOTAL NO. OF VALUES IN EACH OF YYPRED AND YYJ.

C  NOTE IN THE CALL TO SCATPLOT BELOW, THE 5TH ARGUMENT, -NSUB, MEANS
C  THAT THIS CALL IS FOR ALL THE SUBJECTS TOGETHER.

	IF(IPUT .EQ. 1) WRITE(31,8518) IOUTEQ

C  NOTE THAT C0I,...,C3I ARE NOT USED IN THIS CASE, SO THEIR VALUES

C  HAVE NO MEANING FOR THIS CALL TO SCATPLOT.

 	CALL SCATPLOT(1,ICENTER,IIOUT,IQUAL,-NSUB,IPUT,JSUBST,YYPRED,
     1  YYJ,C0I,C1I,C2I,C3I,AMIN,AMAX,0,IERRMOD,GAMLAM)

C  NOTE: AMIN AND AMAX ARE NOT USED UNLESS ISCAT = 1.


C  GO TO THE MAIN SCATPLOT MENU, 9505.


	GO TO 9505


	ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(ISCAT .EQ. 3)  CONDITION



	ENDIF


C  THE ABOVE ENDIF IS FOR THE  IF(IOPT .EQ. 6) CONDITION.


	IF(IOPT .EQ. 7) THEN


 6560	WRITE(*,6546)
	READ(*,*,ERR=6560) ISAVFIL
	IF(ISAVFIL .NE. 0 .AND. ISAVFIL .NE. 1) GO TO 6560

C  IF THE USER DOES NOT WANT TO WRITE NUMERICAL RESULTS TO A FILE,
C  SET IPUT = 0.

	IF(ISAVFIL .EQ. 1) IPUT = 0

	IF(ISAVFIL .EQ. 0) THEN

C  SET IPUT = 1 WHICH MEANS THAT ALL NUMERICAL RESULTS WILL BE WRITTEN
C  TO THE FILE THE USER SELECTS BELOW.

	IPUT = 1

 4980   WRITE(*,5981)
	READ(*,1) OUTSINGL

C  CALL FULLNAME WHICH CONVERTS THE FILENAME TO PATHFILE, THE COMPLETE
C  NAME OF THE FILE, WHICH INCLUDES THE PATH (IF THE PATH IS NOT THE
C  CURRENT DIRECTORY).

     	TMPFILE = ' '
	TMPFILE = OUTSINGL
	CALL FULLNAME(PATH,TMPFILE,PATHFILE)
	OPEN(31,FILE=PATHFILE,ERR=4970,STATUS='NEW')
	GO TO 4975
 4970   WRITE(*,9826) PATHFILE
	READ(*,*,ERR=4970) IFILE
	IF(IFILE .NE. 0 .AND. IFILE .NE. 1) GO TO 4970
	IF(IFILE .EQ. 0) GO TO 4980
	IF(IFILE .EQ. 1) OPEN(31,FILE=PATHFILE)
 4975   CONTINUE


C  PUT THE TIME AND DATE AT THE TOP OF THIS FILE.

C  FOR NPBIG15, TIME AND DATE ROUTINES REPLACED BY DATE_AND_TIME.
      CALL DATE_AND_TIME(DATDAY,TIMDAY,ZONEDAY,IDTDAY)


	WRITE(31,*)
	WRITE(31,*)' TODAY IS ',DATDAY,'; THE TIME IS ',TIMDAY
	WRITE(31,*)
	WRITE(31,*)

	ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(ISAVFIL .EQ. 0)  CONDITION.



 8500   WRITE(*,8501) NUMEQT
 8501   FORMAT(//' YOUR PATIENT DATA FILES HAVE ',I2,' OUTPUT '/
     1' EQUATION(S). FOR EACH OUTPUT EQUATION, YOU MAY PREDICT LEVELS '/
     2' FOR EACH SUBJECT ASSUMING THAT SUBJECT HAS PARAMETER VALUES '/

     3' EQUAL TO EITHER THE MEANS, MEDIANS, OR MODES OF ITS INDIVIDUAL'/
     4' BAYESIAN POSTERIOR JOINT P.D.F. ENTER THE NO. OF THE OUTPUT '/
     5' EQUATION WHOSE LEVELS ARE TO BE PREDICTED: ')
	READ(*,*,ERR=8500) IOUTEQ
	IF(IOUTEQ .LT. 1 .OR. IOUTEQ .GT. NUMEQT) GO TO 8500

 8515   WRITE(*,8507)
 8507   FORMAT(/' ENTER 1 TO USE THE MEANS OF THE BAYESIAN P.D.F.; '/
     6' ENTER 2 TO USE THE MEDIANS OF THE BAYESIAN P.D.F.;'/
     7' ENTER 3 TO USE THE MODES OF THE BAYESIAN P.D.F.:  ')
	READ(*,*,ERR=8515) ICENTER
	IF(ICENTER .LT. 1 .OR. ICENTER .GT. 3) GO TO 8515

	IF(ICENTER .EQ. 1) MNAME = 'MEANS'
	IF(ICENTER .EQ. 2) MNAME = 'MEDIANS'
	IF(ICENTER .EQ. 3) MNAME = 'MODES'

	ITIM=1

C  ITIM WILL CHANGE TO 2 BELOW (SEE COMMENTS BELOW).


 8510 WRITE(*,8517) MNAME
 8517	FORMAT(//' THE PROGRAM IS ABOUT TO CALCULATE THE INDIVIDUAL '/
     1' SUBJECT BAYESIAN POSTERIOR JOINT P.D.F. FOR EACH '/
     2' SUBJECT IN TURN, USING THE FINAL JOINT DISTRIBUTION OF THE '/

     3' ENTIRE POPULATION AS THE PRIOR FOR EACH. '//
     8' ENTER 1 TO STORE THE  ',A7,' FROM THESE P.D.F. INTO A FILE; '/
     9' ENTER 0 OTHERWISE:  ')


	READ(*,*,ERR=8510) IFILSTR
	IF(IFILSTR .NE. 0 .AND. IFILSTR .NE. 1) GO TO 8510


	IF(IFILSTR .EQ. 1) THEN

 8780 WRITE(*,*)
	WRITE(*,*)' ENTER THE NAME OF THE FILE WHICH WILL STORE'
	WRITE(*,*)' THE FINAL CYCLE  ',MNAME,'  FOR EACH SUBJECT:  '


	READ(*,1) OPT7FIL

C  CALL FULLNAME WHICH CONVERTS THE FILENAME TO PATHFILE, THE COMPLETE
C  NAME OF THE FILE, WHICH INCLUDES THE PATH (IF THE PATH IS NOT THE
C  CURRENT DIRECTORY).

     	TMPFILE = ' '
	TMPFILE = OPT7FIL
	CALL FULLNAME(PATH,TMPFILE,PATHFILE)
	OPEN(33,FILE=PATHFILE,ERR=8770,STATUS='NEW')
	GO TO 8775
 8770   WRITE(*,9826) PATHFILE
	READ(*,*,ERR=8770) IFILE
	IF(IFILE .NE. 0 .AND. IFILE .NE. 1) GO TO 8770
	IF(IFILE .EQ. 0) GO TO 8780
	IF(IFILE .EQ. 1) OPEN(33,FILE=PATHFILE)

 8775   CONTINUE

C  SUBROUTINE TOPFIL WRITES TO FILE 33 EVERYTHING EXCEPT
C  THE "PROBABILITIES" AND MAP BAYESIAN ESTIMATES FOR EACH SUBJECT.
C  THESE VALUES WILL BE PUT INTO FILE 33 BELOW.

	CALL TOPFIL(NDRUG,AF,NSUB,NVAR,PAR,NOFIX,PARFIX,NRANFIX,
     1 PARRANFIX)

	ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(IFILSTR .EQ. 1)  CONDITION.


   	ISCAT=1
	ISCATSEE = 1
	GO TO 8900

 8505	IF(ITIM .EQ. 1 .AND. IFILSTR .EQ. 1) THEN
	 CLOSE(33)
	ENDIF

	ITIM=2

C  ITIM=2 TELLS PROGRAM THIS IS NOT 1ST TIME THROUGH, SO THERE WILL
C  BE NO STORING OF BAYESIAN POSTERIOR ESTIMATES (AND THE FILE
C  WILL NOT HAVE TO BE CLOSED BELOW).

C  FOR NPBIG10FX.FOR, COMPILED UNDER LF90, OPTION COMMANDS REMOVED.
C  OPTION BREAK

C  THE ABOVE STATEMENT TELLS THE PROGRAM TO HALT IF THE USER
C  HITS A CNTRL+C (THIS IS THE DEFAULT OPTION). BELOW, JUST ABOVE
C  THE START OF LOOP 8000, OPTION BREAK(*8505) RETURNS CONTROL OF

C  THE PROGRAM TO LABEL 8505 IF THE USER PRESSES CNTRL+C.


        WRITE(*,8503) MNAME
 8503   FORMAT(//' ENTER 1 TO CALCULATE THE PREDICTED CONCENTRATION'/
     1'		LEVELS FOR THE ENTIRE POPULATION OF SUBJECTS AS A WHOLE;
     3'/
     5' ENTER 2 TO CALCULATE THE PREDICTED LEVELS FOR A SELECTED'/
     6'		 SUBSET OF SUBJECTS;'/
     8' ENTER 3 TO CALCULATE THE PREDICTED LEVELS FOR EACH SUBJECT, IN'/
     4'		TURN;'/
     1' ENTER 4 TO SEE THE ',A7,' OF THE INDIVIDUAL SUBJECT BAYESIAN'/
     2'		POSTERIOR JOINT PROBABILITY DENSITY FUNCTIONS; '/
     1' ENTER 0 TO RETURN TO THE PREVIOUS MENU:  ')




	READ(*,*,ERR=8505) ISCT
	IF(ISCT .LT. 0 .OR. ISCT .GT. 4) GO TO 8505

	IF(ISCT .EQ. 0) THEN
	 IF(ISAVFIL .EQ. 0) CLOSE(31)
	 GO TO 7185
	ENDIF


	IF(ISCT .EQ. 1) ISCAT = 3
	IF(ISCT .EQ. 3) ISCAT = 1
	IF(ISCT .EQ. 2) ISCAT = 2
	IF(ISCT .EQ. 4) ISCAT = 4

	IF(ISCAT .EQ. 1) ISCATSEE = 0


	IF(ISCAT .EQ. 4) THEN

C  WRITE EACH SUBJECT'S MEANS, MEDIANS, OR MODES (FROM ITS BAYESIAN
C  POSTERIOR P.D.F) TO THE SCREEN.

	WRITE(*,8502) MNAME
	WRITE(*,8523) 'SUBJECT','   PROB.      ', (PAR(I),I=1,NVAR)

	ILINES=5

C  ILINES IS THE RUNNING TOTAL OF LINES PRINTED TO THE SCREEN SINCE THE
C  LAST PAUSE. EVERYTIME IT GETS TO 20, PAUSE THE OUTPUT.

	DO J=1,NSUB

	 ILINES=ILINES+1
	 WRITE(*,8522) J,1.D0/NSUB,(EXX(J,ICENTER,K),K=1,NVAR)



	IF(ILINES .EQ. 20) THEN

	  ILINES=0

	 ENDIF

	END DO



	GO TO 8505

	ENDIF


C  THE ABOVE ENDIF IS FOR THE IF(ISCAT .EQ. 4) OPTION


C  REWIND SUBJECT FILE (27). SUBJECT INFO WILL BE READ IN THE
C  APPROPRIATE ORDER DEPENDING ON THE VALUE OF ISCAT.

 8900	REWIND(27)


	IF(ISCAT .EQ. 1) THEN


C  IF ISCATSEE = 1, THIS CODE IS BEING DONE FOR THE FIRST TIME (AFTER
C  THE USER PICKED OPTION 7), SO DO THE CALCULATIONS.
C  IF ISCATSEE = 0, THIS CODE IS BEING DONE AFTER
C  LABEL 8503 --> SKIP DIRECTLY TO THE SCATTERPLOTS BELOW (THE
C  SCATTERPLOTS WILL NOT BE DONE, BUT SCATPLOT WILL BE CALLED).



	IF(ISCATSEE .EQ. 1) THEN

C  FOR EACH SUBJECT IN TURN, FIND THE BAYESIAN POSTERIOR P.D.F., GIVEN
C  THE FINAL JOINT P.D.F. OF THE ENTIRE POPULATION (IN CORDEN) AS THE
C  PRIOR.

C  AS OF NPBIG7, HARDCODE ISCROL = 1, AND REMOVE REQUEST FOR ISCATSEE
C  FROM USER.

	ISCROL = 1


	DO 4000 JSUB=1,NSUB


	NACTVE=NNACTVE
	DO I=1,NACTVE
	DO J=1,NVAR+1
	 CORDEN(I,J) = CORHOLD(I,J)
	END DO
	END DO

	IF(IPUT .EQ. 1) WRITE(31,8506) JSUB

 8506   FORMAT(////' THE FOLLOWING RESULTS ARE FOR SUBJECT ',I4)
	WRITE(*,8506) JSUB


C  SEE DETAILED COMMENTS FOR THE FOLLOWING LOGIC IN THE PART OF THE
C  NPLIT63.FOR PROGRAM WHICH DOES THE ANALYSIS FOR THE ENTIRE POPULATION
C  OF SUBJECTS (STARTING WITH LABEL 1001).

C  CALL SUBROUTINE SUBRES WHICH DOES THE ACTUAL CALCULATIONS FOR
C  THIS SUBJECT. SUBRES CALCULATES THE BAYESIAN POSTERIOR P.D.F. FOR
C  THIS SUBJECT. IT CALCULATES P(XI|Y), WHERE Y IS THE VECTOR OF
C  OBSERVED VALUES FOR THIS SUBJECT, AND XI, I=1,NACTVE, ARE THE
C  REMAINING GRID POINTS FROM THE FINAL CYCLE OF THE POPULATION
C  ANALYSIS.

	CALL SUBRES(MAXSUB,JSUB,CORDEN,WORK,MAXGRD,MAXDIM,NVAR,
     1AB,PAR,NACTVE,IPUT,NGRID,VOLSPA,ISCROL,CENTER,PYJGX,PYJGXX)

C  FINAL CYCLE MEANS, MEDIANS, AND MODES FOR THIS SUBJECT ARE ALREADY
C  STORED IN EXX (READ IN FROM THE DENSITY FILE), AND SO DON'T HAVE
C  TO BE SAVED FROM CENTER. THE ONLY REASON SUBRES IS CALLED IS TO
C  OBTAIN, IN CORDEN, THE BAYESIAN POSTERIOR DENSITY FOR THIS SUBJECT.

	IF(IFILSTR .EQ. 1 .AND. ITIM .EQ. 1) THEN

	WRITE(33,5113) 1.D0/NSUB,
     1  (EXX(JSUB,ICENTER,I),I=1,NVAR),(VALFIX(K),K=1,NOFIX),
     2  (RANFIXEST(K),K=1,NRANFIX)
 5113   FORMAT(1X,G13.7,3X,32(G12.6,1X))

	ENDIF

 4000   CONTINUE


C  WRITE EACH SUBJECT'S MEANS, MEDIANS, OR MODES (FROM ITS BAYESIAN
C  POSTERIOR P.D.F) TO THE SCREEN.

	WRITE(*,8502) MNAME
 8502   FORMAT(/' FOLLOWING ARE THE ',A7,' FROM THE BAYESIAN'/
     1' POSTERIOR J.D.F: '/)
	WRITE(*,8523) 'SUBJECT','   PROB.       ', (PAR(I),I=1,NVAR)
 8523   FORMAT(1X,A7,2X,A15,2X,30(A11,6X))
 8522   FORMAT(2X,I4,2X,G12.6,5X,30(G12.6,5X))

	ILINES=5

C  ILINES IS THE RUNNING TOTAL OF LINES PRINTED TO THE SCREEN SINCE THE
C  LAST PAUSE. EVERYTIME IT GETS TO 20, PAUSE THE OUTPUT ... IF ISCROL

C  = 2.

	DO J=1,NSUB

	 ILINES=ILINES+1
	 WRITE(*,8522) J,1.D0/NSUB,(EXX(J,ICENTER,K),K=1,NVAR)

	 IF(ILINES .EQ. 20) THEN

	  IF(ISCROL .EQ. 2) CALL PAUSE
	  ILINES=0
	 ENDIF

	END DO


       IF(ISCROL .EQ. 2) CALL PAUSE

	GO TO 8505


	ENDIF


C  THE ABOVE ENDIF IS FOR THE  IF(ISCATSEE .EQ. 1)  CONDITION. THE
C  CODE BELOW IS FOR THE ISCATSEE = 0 CASE.


C  THE FOLLOWING  OPTION BREAK(*8505) STATEMENT TRANSFERS CONTROL TO
C  STATEMENT LABEL 8505 IF THE USER HITS A  CNTRL+C DURING THE DO
C  8000 LOOP BELOW. NOTE THAT JUST BELOW THE 8505 STATEMENT LABEL, THERE

C  IS AN OPTION BREAK STATEMENT WHICH RESETS THE PROGRAM TO THE DEFAULT
C  ACTION (HALTING) AFTER THE USER HITS CNTRL+C.

C  FOR NPBIG15.FOR, COMPILED UNDER LF90, OPTION COMMANDS REMOVED.

C  OPTION BREAK(*8505)


C  FOR EACH SUBJECT, IN TURN, READ THE OBSERVED VALUES, ESTABLISH
C  THE PREDICTED VALUES (VIA MATRIX YPREDBAY), CALCULATE THE
C  LEAST SQUARES LINE  OBS = A + B*PRED, ALONG WITH ASSOCIATED
C  STATISTICS.


	REWIND(27)


	DO 8000 JSUB=1,NSUB


	CALL FILRED(NOBSER,YO,C0,C1,C2,C3,MAXOBDIM,MAXNUMEQ)

C  STORE PREDICTED AND ACTUAL OBSERVATIONS INTO REAL VECTORS YYPRED AND
C  YYJ. THEY WILL BE SUPPLIED TO SUBROUTINE SCATPLOT (WHICH CALCULATES
C  THE STATISTICS AND CONSTRUCTS THE SCATTERPLOT INDICATED ABOVE).

C  IT IS POSSIBLE THAT YO MAY HAVE -99'S IN SOME OF ITS NOBSER ENTRIES.
C  -99 --> AN OBSERVATION WAS NOT TAKEN FOR THAT OUTPUT EQUATION AT
C  A PARTICULAR TIME. WHEN STORING THE VALUES IN YO INTO YYJ, IGNORE
C  ANY -99'S. HAVE YYPRED IGNORE THE CORRESPONDING ENTRY FROM
C  YPREDBAY.

	NACTUAL = 0
	DO I=1,NOBSER
	 IF(YO(I,IOUTEQ) .NE. -99.) THEN
	  NACTUAL = NACTUAL + 1
	  YYPRED(NACTUAL) = YPREDBAY(JSUB,IOUTEQ,I,ICENTER)
	  YYJ(NACTUAL) = YO(I,IOUTEQ)
	 ENDIF
	END DO

C  STORE THE C'S FOR THE SELECTED OUTPUT EQUATION INTO C0I,...,C3I,
C  SCALAR VALUES TO BE PASSED TO SUBROUTINE SCATPLOT.

	C0I = C0(IOUTEQ)
	C1I = C1(IOUTEQ)
	C2I = C2(IOUTEQ)
	C3I = C3(IOUTEQ)

	IF(IPUT .EQ. 1) WRITE(31,8518) IOUTEQ

C  NOTE THAT THE 1ST ARGUMENT BELOW IS 3 WHICH TELLS SCATPLOT THAT THIS
C  CALL IS FROM MXEM2N__.FOR, AND IS THE IMETH=2 CASE.

       CALL SCATPLOT(3,ICENTER,IIOUT,IQUAL,JSUB,IPUT,NACTUAL,YYPRED,YYJ,
     1  C0I,C1I,C2I,C3I,AMIN,AMAX,0,IERRMOD,GAMLAM)


 8000   CONTINUE



C  GO TO THE MAIN SCATPLOT MENU.

	GO TO 8505


	ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(ISCAT .EQ. 1)  CONDITION.


	IF(ISCAT .EQ. 2) THEN



 8520   WRITE(*,8504)

 8504   FORMAT(//' ENTER THE SUBJECT NO. WHOSE MARGINAL DENSITY'/
     1' CALCULATIONS ARE DESIRED;'/
     2' ENTER 0 TO RETURN TO THE PREVIOUS MENU: ')
	READ(*,*,ERR=8520) JSUB
	IF(JSUB .LT. 0 .OR. JSUB .GT. NSUB) GO TO 8520


	IF(JSUB .EQ. 0) GO TO 8505

C  REWIND SUBJECT FILE (27); THEN READ THROUGH JSUB-1
C  SUBJECTS TO REACH THE DESIRED SUBJECT.

	REWIND(27)

	IF(JSUB .GT. 1) THEN
	 DO J=1,JSUB-1
	  CALL FILRED(NOBSER,YO,C0,C1,C2,C3,MAXOBDIM,MAXNUMEQ)
	 END DO
	ENDIF



	CALL FILRED(NOBSER,YO,C0,C1,C2,C3,MAXOBDIM,MAXNUMEQ)

C  FILRED NEEDED TO BE CALLED ABOVE TO OBTAIN NOBSER AND YO FOR THIS
C  SUBJECT (SEE BELOW).


C  IREDO BELOW = 1 IF THIS SUBJECT IS TO BE 'REDONE' OR DONE FOR THE
C  1ST TIME. IF IREDO=0, THIS SUBJECT HAS BEEN ANALYZED PREVIOUSLY, AND
C  THE USER DOES NOT WANT TO SEE HIS BAYESIAN POSTERIOR DENSITY VALUES
C  AGAIN.

	IREDO=1

 8610	 WRITE(*,8607)
 8607    FORMAT(/' ENTER 1 TO CALCULATE ONLY THE PREDICTED '/
     1'		CONCENTRATION LEVELS FOR THIS SUBJECT;'/
     3' ENTER 2 TO SEE THE BAYESIAN POSTERIOR DENSITY FOR THIS SUBJECT'/
     4' 	AS WELL AS THE CALCULATIONS INDICATED ABOVE: ')
	 READ(*,*,ERR=8610) IDO
	 IF(IDO .NE. 1 .AND. IDO .NE. 2) GO TO 8610
	 IF(IDO .EQ. 1) IREDO=0


C  IF NSUB .LT. NSUBTOT, THEN THE NSUB SUBJECTS USED

C  IN THE ANALYSIS WERE A SUBSET OF THE TOTAL OF NSUBTOT. TELL THE
C  USER WHICH SUBJECT JSUB IS OUT OF THE ENTIRE POPULATION.

        IF(NSUB .LT. NSUBTOT) THEN
         WRITE(*,8516) JSUB,NSUB,IPATVEC(JSUB),NSUBTOT
        ENDIF

C  IF IREDO=0, GO TO 8525 TO PREPARE TO CALL SCATPLOT.

	IF(IREDO .EQ. 0) GO TO 8525

C  IREDO=1 --> DO THE CYCLE ANALYSIS FOR SUBJECT, JSUB.


	NACTVE=NNACTVE
	DO I=1,NACTVE
	DO J=1,NVAR+1


	 CORDEN(I,J) = CORHOLD(I,J)
	END DO
	END DO

	IF(IPUT .EQ. 1) WRITE(31,8506) JSUB
	WRITE(*,8506) JSUB


C  SEE DETAILED COMMENTS FOR THE FOLLOWING LOGIC IN THE PART OF THE
C  NPLIT63 PROGRAM WHICH DOES THE ANALYSIS FOR THE ENTIRE POPULATION OF
C  SUBJECTS (STARTING WITH LABEL 1001).


C  CALL SUBROUTINE SUBRES WHICH DOES THE ACTUAL CALCULATIONS FOR
C  THIS SUBJECT. SUBRES CALCULATES THE BAYESIAN POSTERIOR P.D.F. FOR
C  THIS SUBJECT. IT CALCULATES P(XI|Y), WHERE Y IS THE VECTOR OF
C  OBSERVED VALUES FOR THIS SUBJECT, AND XI, I=1,NACTVE, ARE THE
C  REMAINING GRID POINTS FROM THE FINAL CYCLE OF THE POPULATION
C  ANALYSIS.

C HARDCODE ISCROL = 2 FOR THIS CASE.

	ISCROL=2

	CALL SUBRES(MAXSUB,JSUB,CORDEN,WORK,MAXGRD,MAXDIM,NVAR,AB,
     1PAR,NACTVE,IPUT,NGRID,VOLSPA,ISCROL,CENTER,PYJGX,PYJGXX)

C  SUBRES WAS CALLED ONLY TO OBTAIN THE BAYESIAN POSTERIOR DENSITY
C  IN CORDEN FOR THIS SUBJECT; IT IS NEEDED IN CALL TO PLOTS BELOW.
C  AS OF NPBG15E1.FOR, SUBROUTINE PLOTS IS NOT CALLED.




C  STORE PREDICTED AND ACUTAL CONCENTRATIONS INTO REAL VECTORS YYPRED
C  AND YYJ. THEY WILL BE SUPPLIED TO SUBROUTINE SCATPLOT (WHICH
C  CALCULATES THE STATISTICS AND CONSTRUCTS THE SCATTERPLOT INDICATED

C  ABOVE).

C  IT IS POSSIBLE THAT YO MAY HAVE -99'S IN SOME OF ITS NOBSER ENTRIES.
C  -99 --> AN OBSERVATION WAS NOT TAKEN FOR THAT OUTPUT EQUATION AT
C  A PARTICULAR TIME. WHEN STORING THE VALUES IN YO INTO YYJ, IGNORE
C  ANY -99'S. HAVE YYPRED IGNORE THE CORRESPONDING ENTRY FROM
C  YPREDBAY.

 8525   CONTINUE

	NACTUAL = 0
	DO I=1,NOBSER

	 IF(YO(I,IOUTEQ) .NE. -99.) THEN
	  NACTUAL = NACTUAL + 1
	  YYPRED(NACTUAL) = YPREDBAY(JSUB,IOUTEQ,I,ICENTER)
	  YYJ(NACTUAL) = YO(I,IOUTEQ)
	 ENDIF
	END DO


C  STORE THE C'S FOR THE SELECTED OUTPUT EQUATION INTO C0I,...,C3I,
C  SCALAR VALUES TO BE PASSED TO SUBROUTINE SCATPLOT.

	C0I = C0(IOUTEQ)
	C1I = C1(IOUTEQ)
	C2I = C2(IOUTEQ)

	C3I = C3(IOUTEQ)

	IF(IPUT .EQ. 1) WRITE(31,8518) IOUTEQ

C  NOTE THAT THE 1ST ARGUMENT BELOW IS 3 WHICH TELLS SCATPLOT THAT THIS
C  CALL IS FROM MXEM2N__.FOR, AND IS THE IMETH=2 CASE.

       CALL SCATPLOT(3,ICENTER,IIOUT,IQUAL,JSUB,IPUT,NACTUAL,YYPRED,YYJ,
     1  C0I,C1I,C2I,C3I,AMIN,AMAX,0,IERRMOD,GAMLAM)

C  NOTE: AMIN AND AMAX ARE NOT USED UNLESS ISCAT = 1.



C  GO TO THE ISCAT=2 MENU.

	GO TO 8520


	ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(ISCAT .EQ. 2)  CONDITION



	IF(ISCAT .EQ. 3) THEN


C  STORE THE OBSERVED AND PREDICTED CONCENTRATION VALUES FOR ALL
C  SUBJECTS, AND THEN CALL SCATPLOT.

C  ALSO STORE INTO MATRIX COEFF THE ASSAY NOISE COEFFICIENTS FOR EACH

C  SUBJECT. THEY'LL BE NEEDED IN SUBROUTINE SCATPLOT (COEFF IS PASSED

C  TO SCATPLOT VIA COMMON/TOSCAT).


C  JSUBST = RUNNING INDEX OF THE NO. OF CONCENTRATION VALUES ALREADY
C  IN VECTORS YYPRED AND YYJ.

	JSUBST = 0

	DO 5000 JSUB=1,NSUB

	CALL FILRED(NOBSER,YO,C0,C1,C2,C3,MAXOBDIM,MAXNUMEQ)

C  STORE VALUES IN YPREDBAY AND YO INTO THE NEXT NACTUAL LOCATIONS OF
C  REAL VECTORS YYPRED AND YYJ, WHICH WILL BE SUPPLIED TO SUBROUTINE
C  SCATPLOT (WHICH CALCULATES THE STATISTICS INDICATED ABOVE) AFTER LOOP
C  5000.

C  IT IS POSSIBLE THAT YO MAY HAVE -99'S IN SOME OF ITS NOBSER ENTRIES.
C  -99 --> AN OBSERVATION WAS NOT TAKEN FOR THAT OUTPUT EQUATION AT
C  A PARTICULAR TIME. WHEN STORING THE VALUES IN YO INTO YYJ, IGNORE

C  ANY -99'S. HAVE YYPRED IGNORE THE CORRESPONDING ENTRY FROM
C  YPREDPOP.

	NACTUAL = 0
	DO I=1,NOBSER
	 IF(YO(I,IOUTEQ) .NE. -99.) THEN
	  NACTUAL = NACTUAL + 1
	  YYPRED(JSUBST+NACTUAL) = YPREDBAY(JSUB,IOUTEQ,I,ICENTER)
	  YYJ(JSUBST+NACTUAL) = YO(I,IOUTEQ)
	 ENDIF
	END DO

C  NOTE THAT COEFF(JSUB,1) = NO. OF VALUES FOR THIS OUTPUT EQUATION.

	COEFF(JSUB,1) = NACTUAL
	COEFF(JSUB,2) = C0(IOUTEQ)
	COEFF(JSUB,3) = C1(IOUTEQ)
	COEFF(JSUB,4) = C2(IOUTEQ)
	COEFF(JSUB,5) = C3(IOUTEQ)


	JSUBST = JSUBST + NACTUAL

C  STORE NACTUAL INTO SERNUM(JSUB). BELOW, STATISTICS WILL BE CALCULATED
C  FOR THE NO. OF SERUM LEVELS OVER ALL SUBJECTS.

	SERNUM(JSUB)=NACTUAL


 5000   CONTINUE

C  CALL SUBROUTINE CALCSER TO FIND THE MAX,MIN,MEAN, AND STD. DEV. FOR
C  THE NO. OF OBSERVATIONS (SERUM LEVELS) OVER ALL THE SUBJECTS. THIS
C  INFO IS PASSED IN COMMON/TOSCAT TO SUBROUTINE SCATPLOT (ONLY IN THIS
C  CASE -- ISCAT=3 [ALL SUBJECTS ANALYZED]).

	CALL CALCSER(MAXSUB,NSUB,SERNUM,MAXSER,MINSER,SERMEN,SERSD)

C  JSUBST IS NOW THE TOTAL NO. OF VALUES IN EACH OF YYPRED AND YYJ.
C  NOTE IN THE CALL TO SCATPLOT BELOW, THE 5TH ARGUMENT, -NSUB, MEANS
C  THAT THIS CALL IS FOR ALL THE SUBJECTS TOGETHER.


	IF(IPUT .EQ. 1) WRITE(31,8518) IOUTEQ

C  NOTE THAT THE 1ST ARGUMENT BELOW IS 3 WHICH TELLS SCATPLOT THAT THIS

C  CALL IS FROM MXEM2N__.FOR, AND IS THE IMETH=2 CASE.


C  NOTE THAT C0I,...,C3I ARE NOT USED IN THIS CASE, SO THEIR VALUES
C  HAVE NO MEANING FOR THIS CALL TO SCATPLOT.

 	CALL SCATPLOT(3,ICENTER,IIOUT,IQUAL,-NSUB,IPUT,JSUBST,YYPRED,
     1  YYJ,C0I,C1I,C2I,C3I,AMIN,AMAX,0,IERRMOD,GAMLAM)

C  NOTE: AMIN AND AMAX ARE NOT USED UNLESS ISCAT = 1.



C  GO TO THE MAIN SCATPLOT MENU, 8505.

	GO TO 8505


	ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(ISCAT .EQ. 3)  CONDITION


	ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(IOPT .EQ. 7) CONDITION.


	IF(IOPT .EQ. 8) THEN


 6570	WRITE(*,6546)
	READ(*,*,ERR=6570) ISAVFIL
	IF(ISAVFIL .NE. 0 .AND. ISAVFIL .NE. 1) GO TO 6570

C  IF THE USER DOES NOT WANT TO WRITE NUMERICAL RESULTS TO A FILE,

C  SET IPUT = 0.

	IF(ISAVFIL .EQ. 1) IPUT = 0

	IF(ISAVFIL .EQ. 0) THEN

C  SET IPUT = 1 WHICH MEANS THAT ALL NUMERICAL RESULTS WILL BE WRITTEN
C  TO THE FILE THE USER SELECTS BELOW.

	IPUT = 1



 7980   WRITE(*,7981)
 7981   FORMAT(/' ENTER THE NAME OF THE OUTPUT FILE TO SAVE ALL THE'/
     1' STATISTICS CALCULATIONS YOU CHOOSE BELOW: ')
	  READ(*,1) OUTOPT8

C  CALL FULLNAME WHICH CONVERTS THE FILENAME TO PATHFILE, THE COMPLETE
C  NAME OF THE FILE, WHICH INCLUDES THE PATH (IF THE PATH IS NOT THE
C  CURRENT DIRECTORY).

     	TMPFILE = ' '
	TMPFILE = OUTOPT8
	CALL FULLNAME(PATH,TMPFILE,PATHFILE)

	OPEN(35,FILE=PATHFILE,ERR=7970,STATUS='NEW')
	GO TO 7975
 7970   WRITE(*,9826) PATHFILE
	READ(*,*,ERR=7970) IFILE
	IF(IFILE .NE. 0 .AND. IFILE .NE. 1) GO TO 7970
	IF(IFILE .EQ. 0) GO TO 7980
	IF(IFILE .EQ. 1) OPEN(35,FILE=PATHFILE)
 7975   CONTINUE

C  PUT THE TIME AND DATE AT THE TOP OF THIS FILE.

C  FOR NPBIG10FX, TIME AND DATE ROUTINES REPLACED BY DATE_AND_TIME.
 	CALL DATE_AND_TIME(DATDAY,TIMDAY,ZONEDAY,IDTDAY)

	WRITE(35,*)

	WRITE(35,*)' TODAY IS ',DATDAY,'; THE TIME IS ',TIMDAY
	WRITE(35,*)
	WRITE(35,*)


	ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(ISAVFIL .EQ. 0)  CONDITION.

 7700   WRITE(*,7676)
 7676   FORMAT(//' FROM THE FOLLOWING LIST OF COVARIATES AND RANDOM'/
     1' VARIABLE NAMES, CHOOSE THE TWO WHOSE STATISTICS ACROSS ALL'/
     2' SUBJECTS YOU WOULD LIKE TO VIEW. ')

C  CALL GETCOVR2 TO GET THE NO. OF COVARIATES (DESCRIPTORS), NCOV, AND
C  THEIR NAMES, DESCR(I),I=1,NCOV.


        CALL GETCOVR2(NCOV,DESCR)

C  FROM CALL TO GETCOVAR, NCOV = NO. OF COVARIATES AND
C  DESCR = NAMES OF THESE COVARIATES, AS FOLLOWS:
C  IF NCOV = 4, DESCR(1:4) = 'AGE', 'SEX','HEIGHT', 'ETHNICITY FLAG'.
C  IF NCOV > 4, DESCR(1:NCOV-4) = OTHER COVARIATE(S);
C		    DESCR(NCOV-3:NCOV) = 'AGE', 'SEX', 'HEIGHT', 

C               'ETHNICITY FLAG'.
C  I.E., THE LAST 4 COVARIATES ARE ALWAYS 'AGE','SEX','HEIGHT',
C					  'ETHNICITY FLAG'.


C  CALL PRNCOVAR TO PRINT A MENU OF DESCRIPTORS AND PARAMTER NAMES.

 7680	CALL PRNCOVAR(NCOV,DESCR,NVAR,PAR,CLEARSCREEN)


 7685	WRITE(*,7679)
 7679   FORMAT(//' FROM THE ABOVE LIST OF COVARIATES AND RANDOM'/
     1' VARIABLE NAMES, CHOOSE THE TWO WHOSE STATISTICS (ACROSS ALL'/


     2' SUBJECTS) YOU WOULD LIKE TO VIEW. '//
     3' ENTER THE TWO INDICES NOW (OR "AGAIN" TO SEE THE ABOVE LIST OF'/
     4' COVARIATES AND RANDOM VARIABLES AGAIN): ')
 	READ(*,*,ERR=7680) IND1,IND2

C  NOTE THAT IF THE USER INPUTS "AGAIN", OR ANY NON-NUMERIC ENTRY, HE
C  WILL BE TRANSFERRED BACK TO LABEL 7680. ALSO TRANSFER HIM BACK IF
C  HE INPUTS ANY NUMBER < 1 OR > NCOV+NVAR.

	NCV = NCOV + NVAR
	IF(IND1 .LT. 1 .OR. IND2 .LT. 1 .OR. IND1 .GT. NCV .OR. IND2
     1     .GT. NCV) GO TO 7680


C  IF EITHER IND1 OR IND2 IS .LE. NCOV, IT MEANS THAT THE USER HAS
C  CHOSEN TO PLOT A COVARIATE. IF ICOVHAVE = 0, IT MEANS THAT THE
C  COVARIATE VALUES HAVE NOT ALREADY BEEN STORED INTO ARRAY COVAL
C  (FROM A PREVIOUS IOPT = 8 CALLING). IN THIS CASE, GO THROUGH ALL
C  THE SUBJECTS AND STORE COV. VALUES INTO COVAL.

	IF(IND1 .LE. NCOV .OR. IND2 .LE. NCOV) THEN

	 IF(ICOVHAVE .EQ. 0) THEN


	  WRITE(*,6502)
 6502     FORMAT(//' STORING COVARIATE VALUES FOR EACH SUBJECT ... ')

	  REWIND(27)

	  DO JSUB = 1,NSUB
	   CALL GETCOVAL(NUMEQT,JSUB,COVAL,NCOV)
	  END DO

	  ICOVHAVE = 1

C  NOTE THAT ANY MEANS UNAVAILABLE HAVE VALUE = -99.

	 ENDIF

	ENDIF




C  IF EITHER IND1 OR IND2 IS > NCOV, IT MEANS THAT THE USER HAS CHOSEN

C  TO PLOT A RANDOM VARIABLE. IN THIS CASE, THE VALUES USED WILL BE THE
C  MEANS, MEDIANS, OR MODES FROM THE BAYESIAN POSTERIOR DENSITIES; THESE
C  VALUES WERE READ INTO EXX FROM THE DENSITY FILE.


	IF(IND1 .GT. NCOV .OR. IND2 .GT. NCOV) THEN


 6500   WRITE(*,6501)
 6501   FORMAT(//' FOR THE PARAMETER VALUE FOR EACH SUBJECT, YOU MAY'/
     1' USE THE MEAN, MEDIAN, OR MODE FROM THE BAYESIAN POSTERIOR'/
     2' DENSITY.'//

     5' ENTER 1 TO USE THE MEAN; '/
     6' ENTER 2 TO USE THE MEDIAN;'/
     7' ENTER 3 TO USE THE MODE:  ')
	READ(*,*,ERR=6500) ICENTER
	IF(ICENTER .LT. 1 .OR. ICENTER .GT. 3) GO TO 6500

	IF(ICENTER .EQ. 1) MNAME = 'MEANS'

	IF(ICENTER .EQ. 2) MNAME = 'MEDIANS'

	IF(ICENTER .EQ. 3) MNAME = 'MODES'

	ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(IND1 .GT. NCOV .OR. IND2 .GT. NCOV)
C  CONDITION.

 6510	WRITE(*,6503)
 6503   FORMAT(//' THE STATISTICS WILL INCLUDE 95% CONFIDENCE LINES.'//
     1' ENTER 1 TO MAKE THESE STATISTICS FOR THE EXPECTED VALUE OF Y GIV
     2EN X;'/
     3' ENTER 0 TO MAKE THESE STATISTICS FOR AN ADDITIONAL VALUE OF Y GI
     4VEN X: ')
	READ(*,*,ERR= 6510) ICONF

	IF(ICONF .NE. 0 .AND. ICONF .NE. 1) GO TO 6510



C  STORE INTO XCOV THE NSUB VALUES FOR R.V./COVARIATE WITH INDEX
C  IND1; SIMILARLY, STORE INTO YCOV THE NSUB VALUES FOR R.V./COVARIATE
C  WITH INDEX IND2. RECALL THAT IF IND1 .LE. NCOV, THE VALUES
C  ARE FOR COVARIATE WITH INDEX IND1, AND IF IND1 .GT. NCOV, THE VALUES
C  ARE FOR R.V. WITH INDEX IND1-NCOV (SEE SUBROUTINE PRNCOVAR).
C  SIMILARLY, FOR INDEX IND2. ALSO, STORE INTO XLABEL AND YLABEL THE
C  R.V. OR DESCRIPTOR NAMES. ALSO, BLANK OUT XLABEL2 AND YLABEL2. THEY
C  WILL BE RESET = 'MEANS OF', 'MEDIANS OF', OR 'MODES OF' IF A R.V. IS
C  ONE OF THE PARAMATERS.




	XLABEL2 = '          '

	YLABEL2 = '          '

	IF(IND1 .LE. NCOV) THEN
	 DO JSUB = 1,NSUB
	  XCOV(JSUB) = COVAL(JSUB,IND1)
	  XLABEL = DESCR(IND1)
	 END DO
	ENDIF


	IF(IND1 .GT. NCOV) THEN
	 DO JSUB = 1,NSUB
	  XCOV(JSUB) = EXX(JSUB,ICENTER,IND1-NCOV)
	  XLABEL = PAR(IND1-NCOV)
	  XLABEL2 = MNAME//' OF'
	 END DO

	ENDIF

	IF(IND2 .LE. NCOV) THEN
	 DO JSUB = 1,NSUB
	  YCOV(JSUB) = COVAL(JSUB,IND2)
	  YLABEL = DESCR(IND2)
	 END DO


      ENDIF

	IF(IND2 .GT. NCOV) THEN
	 DO JSUB = 1,NSUB
	  YCOV(JSUB) = EXX(JSUB,ICENTER,IND2-NCOV)
	  YLABEL = PAR(IND2-NCOV)

	  YLABEL2 = MNAME//' OF'
	 END DO
	ENDIF


C  CALL SCATGRAM TO PRINT A SCATTERGRAM OF THE NSUB PAIR OF VALUES IN
C  XCOV AND YCOV.

C  DEFAULT ILOWER = 1 --> BOUNDARIES ARE CALCULATED AUTOMATICALLY FROM
C  THE DATA POINTS. BELOW, USER WILL HAVE CHANCE TO RERUN WITH
C  ILOWER = 0 --> (0,0) INCLUDED IN THE PLOT FOR SURE.

	ILOWER = 1


 7990	CALL SCATGRAM(IIOUT,IQUAL,NSUB,XLABEL,YLABEL,XLABEL2,YLABEL2,
     1  XCOV,YCOV,ILOWER,ICONF,IPUT)

 7785	WRITE(*,7891)
 7891   FORMAT(/' ENTER 1 TO SEE THE STATISTICS OF ONE DESCRIPTOR'/
     2'         OR RANDOM VARIABLE VS. ANY OTHER;'/
     3' ENTER 0 OTHERWISE: ')


	READ(*,*,ERR=7785) IAGAIN
	IF(IAGAIN .NE. 0 .AND. IAGAIN .NE. 1) GO TO 7785

	IF(IAGAIN .EQ. 1) GO TO 7700


	IF(IAGAIN .EQ. 0) THEN
	 IF(ISAVFIL .EQ. 0) CLOSE(35)
	 GO TO 7185
	ENDIF


	ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(IOPT .EQ. 8) CONDITION.


	END

C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C

	SUBROUTINE PRNLAST
	CHARACTER READLINE*144

C  THIS ROUTINE, CALLED BY PREVRUN, PRINTS THE LAST CYCLE OF FILE 25
C  TO THE SCREEN, ONE SCREENFUL AT A TIME. FILE 25 IS ALREADY OPENED,
C  AND POSITIONED AT THE LAST RECORD. AS OF M2_7.FOR, EACH SUBJECT'S
C  BAYESIAN POSTERIOR DENSITY RESULTS ARE AT THE END OF FILE 25, SO
C  THESE RESULTS ARE ALSO OUTPUT TO THE SCREEN.

C  BACKSPACE UNTIL THE BEGINNING OF THE LAST CYCLE.


    2   FORMAT(A144)
   90	BACKSPACE(25)
	BACKSPACE(25)
	READ(25,2) READLINE
	IF(READLINE(2:9) .NE. 'CYCLE NO') GO TO 90
	BACKSPACE(25)

	ILINES=0

C  ILINES IS THE RUNNING TOTAL OF LINES PRINTED TO THE SCREEN SINCE

C  THE LAST PAUSE. WHEN IT GETS TO 20, PAUSE THE SCREEN AND RESET IT
C  TO 0.


   80   READ(25,2,IOSTAT=IEND) READLINE
	IF(IEND .LT. 0) GO TO 100




C  NOTE THAT IEND .LT. 0 --> END OF FILE REACHED.

C  IF READLINE HAS ANY NON-BLANK CHARACTERS IN LOCATIONS 73:144, USE
C  FORMAT 111 TO WRITE READLINE TO SCREEN; OTHERWISE, USE FORMAT 11.


	IEXT = 0
	DO I=73,144
	 IF(READLINE(I:I) .NE. ' ') IEXT = 1
	END DO

	IF(IEXT .EQ. 0) WRITE(*,11) READLINE(1:72)
	IF(IEXT .EQ. 1) WRITE(*,111) READLINE
   11   FORMAT(' ',A72)
  111   FORMAT(' ',A144)
	ILINES=ILINES+1

	IF(ILINES .EQ. 20) THEN

	 ILINES=0
  110	 WRITE(*,101)
  101    FORMAT(' ENTER 1 TO CONTINUE PRINTING THE LAST CYCLE INFO; '/
     1' ENTER 0 TO RETURN TO THE PREVIOUS MENU: ')
 	 READ(*,*,ERR=110) ICONT
	 IF(ICONT .NE. 0 .AND. ICONT .NE. 1) GO TO 110
	 IF(ICONT .EQ. 0) RETURN
	ENDIF

	GO TO 80

  100   CONTINUE



	RETURN

	END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
	SUBROUTINE OLDSEEDIR(PATH,NOB,FILENAME)

	CHARACTER FILENAME*20,PATH*60,PRTDIR*47,TEMP*72,PRTDIR2*47

C  NOTE THAT PATH(1:NOB) IS THE CONDENSED (WITHOUT BLANKS) PATH.

   10	PRTDIR = ' '
	WRITE(*,6)

    6   FORMAT(/' PRESS THE ENTER KEY TO SEE YOUR ENTIRE DIRECTORY;'//
     1' ENTER A PARTIAL FILENAME (WITH THE * WILDCARD) TO SEE A '/
     2'       PARTICULAR SUBSET OF FILENAMES IN YOUR DIRECTORY. '/
     3'       e.g., ENTER  "TO*.INS TO SEE A LIST OF ALL FILES WHICH'/
     4'       BEGIN WITH "TO" AND HAVE A .INS SUFFIX '//

     5' NOTE THAT THE FILES WILL AUTOMATICALLY BE TIME-ORDERED FROM '/
     6' OLDEST TO NEWEST.'//
     7' ENTER YOUR CHOICE NOW: ')
	READ(*,1) PRTDIR

    1   FORMAT(A47)

C  REMOVE ANY BLANKS FROM PRTDIR SINCE THERE CAN BE NO BLANKS BETWEEN
C  THE END OF THE PATH AND THE BEGINNING OF THE "OBJECT" OF THE

C  DIR COMMAND FOR SUBDIRECTORIES. PRTDIR, WITHOUT BLANKS, WILL BE
C  PRTDIR2.

	IF(PRTDIR .EQ. ' ') TEMP = 'DIR/OD '//PATH(1:NOB)//' |MORE'

	IF(PRTDIR .NE. ' ') THEN
	 PRTDIR2 = ' '
	 J = 0
	 DO I=1,47
	  IF(PRTDIR(I:I) .NE. ' ') THEN

	   J = J+1
	   PRTDIR2(J:J) = PRTDIR(I:I)
	  ENDIF

	 END DO
	 TEMP = 'DIR/OD '//PATH(1:NOB)//PRTDIR2(1:J)//' |MORE'

	ENDIF

        CALL SYSTEM(TEMP)

     	WRITE(*,3)
    3   FORMAT(/' ENTER THE NAME OF THE DESIRED FILE (WITHOUT THE PATH);
     1'/
     2' ENTER -99 TO ENTER A DIFFERENT FILE SPECIFICATION: ')
	READ(*,2) FILENAME
    2   FORMAT(A20)
	IF(FILENAME(1:3) .EQ. '-99') GO TO 10

	RETURN
	END
C
C NEW SEEDIR() for UNIX
C
        SUBROUTINE SEEDIR(PATH,NOB,FILENAME,OSName,ListDir)
        CHARACTER FILENAME*20,PATH*60,PRTDIR*47,TEMP*72,PRTDIR2*47,
     1  OSName*20,ListDir*10



C  NOTE THAT PATH(1:NOB) IS THE CONDENSED (WITHOUT BLANKS) PATH.

   10   PRTDIR = ' '
        IF (INDEX(OSName,"UNIX",.TRUE.).eq.1) THEN
          WRITE(*,7)
        ELSE IF (INDEX(OSName,"DOS",.TRUE.).eq.1) THEN
          WRITE(*,6)
        END IF
    7   FORMAT(/' Press the ENTER key to call system(ls -t). '//
     1' Or type a partial filename (use the * wildcard) to call '/
     2'       system(ls -t arg_1), '/
     3'       e.g., type "to*.f ENTER" to see a list of all files '/
     4'       that begin with "to" and have a .f suffix. '//
     5' ENTER YOUR CHOICE NOW: ')
    6   FORMAT(/' PRESS THE ENTER KEY TO SEE YOUR ENTIRE DIRECTORY;'//

     1' ENTER A PARTIAL FILENAME (WITH THE * WILDCARD) TO SEE A '/
     2'       PARTICULAR SUBSET OF FILENAMES IN YOUR DIRECTORY. '/
     3'       e.g., ENTER  "TO*.INS TO SEE A LIST OF ALL FILES WHICH'/
     4'       BEGIN WITH "TO" AND HAVE A .INS SUFFIX '//
     5' NOTE THAT THE FILES WILL AUTOMATICALLY BE TIME-ORDERED FROM '/
     6' OLDEST TO NEWEST.'//
     7' ENTER YOUR CHOICE NOW: ')
        READ(*,1) PRTDIR
    1   FORMAT(A47)

C  REMOVE ANY BLANKS FROM PRTDIR SINCE THERE CAN BE NO BLANKS BETWEEN
C  THE END OF THE PATH AND THE BEGINNING OF THE "OBJECT" OF THE
C  DIR COMMAND FOR SUBDIRECTORIES. PRTDIR, WITHOUT BLANKS, WILL BE
C  PRTDIR2.

        IF (INDEX(OSName,"UNIX",.TRUE.).eq.1) THEN
           IF(PRTDIR .EQ. ' ') THEN
             TEMP = ListDir//PATH(1:NOB)
           ENDIF
        ELSE IF (INDEX(OSName,"DOS",.TRUE.).eq.1) THEN
           IF(PRTDIR .EQ. ' ') THEN
             TEMP = ListDir//PATH(1:NOB)//' |MORE'
           ENDIF
        ENDIF

        IF(PRTDIR .NE. ' ') THEN
         PRTDIR2 = ' '
         J = 0
         DO I=1,47
          IF(PRTDIR(I:I) .NE. ' ') THEN
           J = J+1
           PRTDIR2(J:J) = PRTDIR(I:I)
          ENDIF
         END DO

         IF (INDEX(OSName,"UNIX",.TRUE.).eq.1) THEN
           TEMP = ListDir//PATH(1:NOB)//PRTDIR2(1:J)
         ELSE IF (INDEX(OSName,"DOS",.TRUE.).eq.1) THEN

           TEMP = ListDir//PATH(1:NOB)//PRTDIR2(1:J)//' |MORE'
         ENDIF

        ENDIF

        CALL SYSTEM(TEMP)

        WRITE(*,3)
    3   FORMAT(/' ENTER THE NAME OF THE DESIRED FILE (WITHOUT THE PATH);
     1'/

     2' ENTER -99 TO ENTER A DIFFERENT FILE SPECIFICATION,'/
     3' OR TO VIEW THE DIRECTORY LISTING AGAIN ')


        READ(*,2) FILENAME
    2   FORMAT(A20)

        IF(FILENAME(1:3) .EQ. '-99') GO TO 10


        RETURN
        END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C

       SUBROUTINE CALCSER(MAXSUB,NSUB,SERNUM,MAXSER,MINSER,SERMEN,SERSD)


C  THIS ROUTINE, CALLED BY PREVRUN, FINDS THE MAX,MIN,MEAN,
C  AND STD. DEV. FOR THE NSUB NOS. IN VECTOR SERNUM. THE VALUES ARE
C  RETURNED IN MAXSER,MINSER,SERMEN, AND SERSD, RESPECTIVELY.


	IMPLICIT REAL*8(A-H,O-Z)
	DIMENSION SERNUM(MAXSUB)

	SUM=0.D0
	SUMSQ=0.D0
	MINSER = SERNUM(1)
	MAXSER = SERNUM(1)

	  DO J=1,NSUB
	    SUM = SUM + SERNUM(J)
	    SUMSQ = SUMSQ + SERNUM(J)*SERNUM(J)

	    IF(SERNUM(J) .GT. MAXSER) MAXSER=SERNUM(J)
	    IF(SERNUM(J) .LT. MINSER) MINSER=SERNUM(J)
	  END DO

	SERMEN = SUM/NSUB


	IF(NSUB .EQ. 1) THEN
	  WRITE(*,*)' THE NO. OF OBSER = 1; NO S.D. CAN BE FOUND.'
	  SERSD=-999.
	  RETURN
	ENDIF


	VAR = (SUMSQ - NSUB*SERMEN*SERMEN)/(NSUB-1.D0)
	SERSD = DSQRT(VAR)

	RETURN
	END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
	SUBROUTINE STATZ(VOLSPA,NGRID,NACTVE,NVAR,IND,CORDEN,PROD,MAXGRD,
     1  NINT,X1,X2,XMODE,X025,X25,X50,X75,X975,SCALINFO,NSUB,MAXDIM)
	IMPLICIT REAL*8(A-H,O-Z)
	DIMENSION CORDEN(MAXGRD,MAXDIM+1),PROD(MAXGRD),X(1999),
     1  PROB(1998),CUMPRO(0:1998)

C  THIS SUBROUTINE, CALLED BY MAIN, CALCULATES THE MODE AND 5 %-TILE
C  VALUES OF THE APPROXIMATE MARGINAL DENSITY OF R.V. IND, WHOSE
C  BOUNDARIES [X1,X2] ARE INPUT. ALSO, THE
C  SCALED 'INFO' FOR THIS MARGINAL DENSITY IS CALCULATED.



C  INPUT ARE:
C
C  VOLSPA = 'VOLUME' OF THE INTEGRATION SPACE.

C  NGRID = THE NO. OF GRID POINTS.
C  NACTVE = THE NO. OF CURRENTLY ACTIVE GRID POINTS.
C  NVAR = NO. OF R.V.'S.
C  IND = INDEX OF THE R.V. WHOSE STATISTICS ARE BEING FOUND.
C  CORDEN(I,J) = JTH COORDINATE FOR THE ITH GRID POINT, J=1,NVAR;
C		 I=1,NACTVE;
C		 DENSITY FOR THE ITH GRID POINT, J=NVAR+1;I=1,NACTVE.
C  PROD(I), I=1,NACTVE = DUMMY ARRAY; IN ARGUMENT LIST SO IT CAN BE
C                       VARIABLY DIMENSIONED.
C  MAXGRD = DIMENSION OF CORDEN AND PROD -- SEE EXPLANATION IN MAIN.
C  NINT = THE NO. OF INTERVALS TO BE USED IN CALCULATING THE APPROXIMATE
C         MARGINAL DENSITY OF R.V. INDICATED ABOVE (CHANGED -SEE BELOW).
C  [X1,X2] = BOUNDS ON THE R.V. INDICATED ABOVE.
C  NSUB = NO. OF SUBJECTS.
C  MAXDIM = DIMENSION OF CORDEN.


C  OUTPUT IS:
C
C  XMODE = MODE OF THE APPROXIMATE DISTRIBUTION OF R.V. INDICATED ABOVE.
C  X025 =  2.5 %-TILE VALUE OF ABOVE APPROXIMATE DISTRIBUTION.
C  X25 =    25 %-TILE VALUE OF ABOVE APPROXIMATE DISTRIBUTION.
C  X50 =    50 %-TILE VALUE OF ABOVE APPROXIMATE DISTRIBUTION (MEDIAN).
C  X75 =    75 %-TILE VALUE OF ABOVE APPROXIMATE DISTRIBUTION.
C  X975 = 97.5 %-TILE VALUE OF ABOVE APPROXIMATE DISTRIBUTION.
C  SCALINFO = SCALED 'INFO' FOR THIS MARGINAL DENSITY.


C  AS OF NPBIG1.FOR, THE NO. OF INTERVALS USED IN THIS ROUTINE IS
C  NO LONGER HARDCODED TO BE NINT = 100. THE REASON IS THAT THE
C  SCALED INFO HAS A DENOMINATOR OF LOG(NINT/NSUB) WHICH = 0 IF

C  NSUB = NINT = 100 (--> DIVIDE BY 0 ERROR), AND IF NSUB > 100, THIS
C  PRODUCES A NEGATIVE SCALED INFO (WHICH IS SUPPOSED TO VARY FROM 0
C  TO 100). SO MAKE THE NO. OF INTERVALS = MAX(100,2*NSUB).

C  NOTE THAT NINT IS PASSED TO THIS ROUTINE AS ALWAYS 100; DON'T

C  CHANGE NINT; USE NEWINT BELOW.


	NEWINT = NINT
	IF(2*NSUB .GT. NEWINT) NEWINT = 2*NSUB


C  FIND THE NEWINT INTERVALS OF INTEGRATION -- EQUALLY SPACED -- BETWEEN

C  X1 AND X2.
C
	XINT=(X2-X1)/NEWINT
	X(1)=X1
	X(NEWINT+1) = X2

	DO 5 I=1,NEWINT-1
    5   X(I+1)=X(I)+XINT
C

C  FIND THE APPROXIMATE PROBABILITY THAT THE R.V. IS IN EACH OF THE
C  NEWINT INTERVALS.

	DO 1000 INTR=1,NEWINT


C  FIND PROB{ R.V. IN [X(INTR),X(INTR+1)] } = PROB(INTR).

C  INTEGRATE (CORDEN(I,NVAR+1)*W(X(INTR),X(INTR+1))), WHERE W(A,B) = 1
C  IF R.V. IS IN [X(INTR),X(INTR+1)], AND = 0 IF NOT.

C  FIND W EVALUATED AT EACH GRID POINT AND MULTIPLY IT BY
C  CORDEN(I,NVAR+1)

	DO IG=1,NACTVE
	  W = 0.D0
	  XX = CORDEN(IG,IND)
	  IF(XX .GE. X(INTR) .AND. XX .LT. X(INTR+1)) W = 1.D0
	  IF(INTR .EQ. NEWINT .AND. XX .GE. X(INTR)) W = 1.D0
          PROD(IG) = CORDEN(IG,NVAR+1)*W
	END DO


 1000  CALL NOTINT(VOLSPA,NGRID,NACTVE,PROD,MAXGRD,PROB(INTR))

C  WITH PROB(.), CALCULATE THE MODE.

	INTMAX=1
	DO INTR=2,NEWINT

	  IF(PROB(INTR) .GT. PROB(INTMAX)) INTMAX=INTR
	END DO


	XMODE=(X(INTMAX)+X(INTMAX+1))/2.D0


C  CALCULATE THE 'SCALED INFORMATION' FOR THIS CYCLE (STARTING WITH
C  PROGRAM m234calc.f, 11-6-94; BUT THE SCALED 'INFO' IS CHANGED
C  IN PROGRAM MXEM2N35.FOR/m235calc.f, 11-19-94):



C  INFO = SUM(PI*LOG(PI)), WHERE THE SUM IS OVER I=1,NEWINT, THE LOG
C    	  IS TO BASE 2, PI*LOG(PI) --> 0 IF PI = 0, AND
C	  PI = PROB(I).

C  THEN INFO IS SCALED: y = 100*ln(2)/ln(n/N)*(x + ln(n)/ln(2)), WHERE
C  y = SCALED INFO, x = ABOVE INFO, n = NEWINT, N = NO. OF SUBJECTS. SO
C  y = 0 (%) IF DENSITY IS UNIFORM, and y = 100 (%) if DENSITY IS
C  CONCENTRATED AT N EQUALLY LIKELY POINTS, ... I.E., SCALED INFO = 0 %
C  FOR NO INFO, AND SCALED INFO = 100 % FOR PERFECT INFO.


	SUM=0.D0

	DO I=1,NEWINT

	IF (PROB(I) .GT. 0.D0) THEN
	  PI=PROB(I)
	  SUM=SUM+PI*DLOG(PI)
	ENDIF

	END DO

	DL2=DLOG(2.D0)
	SUM = SUM/DL2

C  SUM IS NOW THE INFO FOR THIS MARGINAL DENSITY. SCALE IT AS SHOWN
C  ABOVE.

        DINT=NEWINT
	FACT=100.D0*DL2/DLOG(DINT/NSUB)
	SCALINFO = FACT*(SUM + DLOG(DINT)/DL2)


C  FIND THE 5 %-TILE VALUES.

C  X025 IS THE X-VALUE BELOW WHICH IS 2.5 % OF THE DISTRIBUTION.
C  X25  IS THE X-VALUE BELOW WHICH IS 25 % OF THE DISTRIBUTION.
C  X50  IS THE X-VALUE BELOW WHICH IS 50 % OF THE DISTRIBUTION.
C  X75  IS THE X-VALUE BELOW WHICH IS 75 % OF THE DISTRIBUTION.
C  X975 IS THE X-VALUE BELOW WHICH IS 97.5 % OF THE DISTRIBUTION.


C  ACTUALLY, X025 WILL BE THE WEIGHTED X-VALUE IN THE INTERVAL WHERE
C  THE CUMULATIVE PROBABILITY EXCEEDS 2.5%. SIMILARLY FOR THE OTHER
C  %-TILE VALUES.


C  FIND THE INTERVALS WHERE THE CUMULATIVE PROBABILITES EXCEED 2.5%,
C  25%, 50%, 75%, AND 97.5%.


C  CUMPRO(I) BELOW IS THE CUMULATIVE PROBABILITY OF THE DISTRIBUTION
C  THROUGH INTERVAL I.


	CUMPRO(0)=0.D0

	DO 1200 INTR=1,NEWINT
	CUMPRO(INTR)=CUMPRO(INTR-1)+PROB(INTR)

	IF(CUMPRO(INTR-1) .LT. .025D0 .AND. CUMPRO(INTR) .GE. .025D0)
     1  IND025=INTR

	IF(CUMPRO(INTR-1) .LT. .25D0 .AND. CUMPRO(INTR) .GE. .25D0)
     1  IND25=INTR
	IF(CUMPRO(INTR-1) .LT. .50D0 .AND. CUMPRO(INTR) .GE. .50D0)
     1  IND50=INTR
	IF(CUMPRO(INTR-1) .LT. .75D0 .AND. CUMPRO(INTR) .GE. .75D0)
     1  IND75=INTR
	IF(CUMPRO(INTR-1) .LT. .975D0 .AND. CUMPRO(INTR) .GE. .975D0)
     1  IND975=INTR

 1200 CONTINUE
C
C  NOW IND025 IS THE INTERVAL WHERE THE CUMULATIVE PROBABILITY EXCEEDS
C  .025 (SIMILARLY FOR THE OTHER IND'S).
C
	X025 = X(IND025)+(X(IND025+1)-X(IND025))*
     1  (.025D0-CUMPRO(IND025-1))/(CUMPRO(IND025)-CUMPRO(IND025-1))

	X25 = X(IND25)+(X(IND25+1)-X(IND25))*
     1  (.25D0-CUMPRO(IND25-1))/(CUMPRO(IND25)-CUMPRO(IND25-1))

	X50 = X(IND50)+(X(IND50+1)-X(IND50))*
     1  (.50D0-CUMPRO(IND50-1))/(CUMPRO(IND50)-CUMPRO(IND50-1))

	X75 = X(IND75)+(X(IND75+1)-X(IND75))*
     1  (.75D0-CUMPRO(IND75-1))/(CUMPRO(IND75)-CUMPRO(IND75-1))


	X975 = X(IND975)+(X(IND975+1)-X(IND975))*
     1  (.975D0-CUMPRO(IND975-1))/(CUMPRO(IND975)-CUMPRO(IND975-1))


	RETURN

	END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

C
	SUBROUTINE NOTINT(VOLSPA,NGRID,NACTVE,FUNC,MAXGRD,ESTINT)
	IMPLICIT REAL*8(A-H,O-Z)
	DIMENSION FUNC(MAXGRD)
C
C  THIS SUBROUTINE, CALLED BY MAIN, IS A MULTI-DIMENSIONAL INTEGRATOR.
C
C  INPUT ARE:

C
C  VOLSPA = 'VOLUME' OF THE INTEGRATION SPACE.
C  NGRID = NO. OF GRID POINTS OVER WHICH THE INTEGRATION IS DONE.
C  NACTVE = NO. OF CURRENTLY ACTIVE GRID POINTS.
C  FUNC(I), I=1,NACTVE = VALUE OF THE FUNCTION TO BE INTEGRATED AT
C                       THE ITH GRID POINT.
C  MAXGRD = DIMENSION OF FUNC -- SEE EXPLATION IN MAIN.

C

C  OUTPUT IS:
C

C  ESTINT = THE ESTIMATE OF THE NVAR-DIM INTEGRAL OF THE FUNCTION WHOSE
C           VALUES ARE GIVEN IN FUNC.
C
	SUM=0.D0
	DO 100 IG=1,NACTVE
  100   SUM=SUM+FUNC(IG)
	ESTINT=VOLSPA*SUM/NGRID
	RETURN
	END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

C

	SUBROUTINE DELAY(DEL)

C  THIS SUBROUTINE, CALLED BY MAIN, CALMAR, AND THREED1, DELAYS THE
C  PROGRAM DEL SECONDS.

C
C Yamada 5/5/2010 ... I'm not sure why this code is here ... but
C gfortran doesn't have timer()
C


C	CALL TIMER(ISTART)

 	SEC1=ISTART/100.

C  ISTART GIVES THE NO. OF HUNDREDTHS OF SECONDS SINCE MIDNIGHT (?).

C   10	CALL TIMER(IEND)
C	SEC2=IEND/100.
C	IF(SEC2-SEC1 .LT. DEL) GO TO 10


	RETURN
	END

C

CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
        SUBROUTINE PUTASS(PATHFILE,IASS,C0P,C1P,C2P,C3P,MAXOBS,
     1  NUMEQT,IALLPAT,ASSMULT,GENCOEF,NCSTORE,MAXOBDIM,YO,MAXNUMEQ)

C  THIS ROUTINE, CALLED BY MAIN, READS THE INFO IN FILE PATFIL,

C  AND MAKES SURE THE CORRECT ASSAY ERROR COEFFICIENTS ARE AT THE
C  END OF THE FILE, AS FOLLOWS:

C  IASS(I) = 1 --> IF A FILE ALREADY HAS C'S, THEY REMAIN FOR OUTPUT
C		EQUATION I; IF A FILE DOESN'T HAVE C'S,
C	        [C0P(I),C1P(I),C2P(I),C3P(I)] ARE PUT INTO THE FILE
C		FOR OUTPUT EQUATION I; I=1,NUMEQT.

C  IASS(I) = 2 --> [C0P(I),C1P(I),C2P(I),C3P(I)] ARE PUT INTO EACH FILE
C		FOR OUTPUT EQUATION I, OVERWRITING C'S IF THEY'RE
C		ALREADY THERE; I=1,NUMEQT.

C  IASS(I) = 4 --> USER GETS PROMPTED AND ENTERS C'S OF HIS CHOICE FOR
C		EACH FILE, FOR OUTPUT EQUATION I; I=1,NUMEQT.

C  IASS(I) = 3 -->
C   IF A FILE HAS C'S (FOR OUTPUT EQ. I):
C    IALLPAT(I) = 1 --> MULTIPLY THESE C'S BY ASSMULT(I);

C    IALLPAT(I) = 0 --> ASK USER WHETHER TO MULTIPLY BY ASSMULT(I), OR
C                       ENTER NEW C'S.
C   IF A FILE HAS NO C'S (FOR OUTPUT EQ. I):
C    IALLPAT(I) = 1 --> MULTIPLY GENERAL VALUES BY ASSMULT(I);
C    IALLPAT(I) = 0 --> ASK USER WHETHER TO MULTIPLY GENERAL VALUES BY
C                       ASSMULT(I) OR ENTER NEW C'S.


C  NOTE THAT IASS(I) CANNOT = -1 IN THIS PROGRAM SINCE, UNLIKE IN THE
C  SERIES MEM2__.FOR, THERE IS NO SUBROUTINE NEWPAT.

C  ALSO, MAXOBS IS THE CURRENT MAX. NO. OF OBSERVATION TIMES AMONG THE
C  SUBJECTS. BELOW, IT WILL BE RESET IF THE MAX. NO. OF OBSERVATION
C  TIMES FOR THIS SUBJECT IS GREATER THAN THE CURRENT MAXOBS.


        IMPLICIT REAL*8(A-H,O-Z)
	DIMENSION IASS(MAXNUMEQ),C0P(MAXNUMEQ),C1P(MAXNUMEQ),
     1 C2P(MAXNUMEQ),C3P(MAXNUMEQ),GENCOEF(MAXNUMEQ,5,4),
     2 IALLPAT(MAXNUMEQ),ASSMULT(MAXNUMEQ),NCSTORE(MAXNUMEQ),
     3 YO(MAXOBDIM,MAXNUMEQ)

        CHARACTER PATHFILE*73,READLINE*1000,ERRFIL*20

      COMMON/ERROR/ERRFIL
C  COMMON/ERROR/ IS SUPPLIED TO ALL THE ROUTINES WHICH COULD WRITE TO
C  ERRFIL. 


C  FIRST, DETERMINE IF FILE 21 HAS ASSAY COEFFICIENTS AT THE END. OPEN
C  THE FILE AND READ UNTIL THE LINE STARTING WITH
C  "ASSAY COEFFICIENTS ..." IS ENCOUNTERED. IF THE NEXT WORD IS
C  "FOLLOWS", THE LAST NUMEQT LINES CONTAIN ASSAY COEFFICIENTS.

    3   FORMAT(A1000)


	OPEN(21,FILE=PATHFILE,STATUS='OLD')
    5	READ(21,3,IOSTAT=IEND) READLINE


C  IF THERE IS NO LINE WITH "ASSAY COE" ON IT, THIS IS NOT AN
C  ACCEPTABLE WORKING COPY FILE.

	IF(IEND .LT. 0) THEN

	 WRITE(*,56) PATHFILE
   56    FORMAT(//' PATIENT FILE '/
     1'    ',A73/
     2' IS NOT AN ACCEPTABLE WORKING COPY FILE. SUCH A FILE MUST HAVE '/
     2' "ASSAY COEFFICIENTS ... " NEAR THE BOTTOM OF THE FILE.'//
     3' THE PROGRAM STOPS. '//)

        OPEN(42,FILE=ERRFIL)

         WRITE(42,56) PATHFILE 
        CLOSE(42)

	 CALL PAUSE
	 STOP

	ENDIF

	IF(READLINE(1:9) .NE. 'ASSAY COE') GO TO 5

	IF(READLINE(20:25) .EQ. 'FOLLOW' ) ICOFF = 1
	IF(READLINE(20:25) .NE. 'FOLLOW' ) ICOFF = 0

C  NOTE THAT ICOFF = 1 IF ASSAY COEFFS. ARE AT THE END OF FILE 21;
C	             0 IF ASSAY COEFFS. ARE NOT AT END OF THE FILE.


C  READ THE NO. OF OF OBSERVATION TIMES, AND THE TIMES THEMSELVES TO
C  UPDATE MAXOBS.

C  READ THE NO. OF OBSERVATION TIMES, WHICH IS ON THE LINE WITH
C  "NO. OF OBSERVED VALUE TIMES" IN COLUMNS 12:38. NOTE THAT IF
C  NO LINE HAS THESE WORDS, THIS IS NOT AN ACCEPTABLE NEW-STYLE
C  PATIENT DATA FILE FROM ANDREAS' NEW BOXES PROGRAM.

	REWIND(21)

   35	READ(21,3,IOSTAT=IEND) READLINE

	IF(IEND .LT. 0) THEN

	 WRITE(*,57) PATHFILE
   57    FORMAT(//' PATIENT FILE '/
     1'    ',A73/

     2' IS NOT AN ACCEPTABLE WORKING COPY FILE. SUCH A FILE MUST HAVE '/
     2' A LINE WITH "NO. OF OBSERVED VALUE TIMES" IN COLUMNS 12:38.'//
     3' THE PROGRAM STOPS. '//)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,57) PATHFILE 
        CLOSE(42)

	 CALL PAUSE
	 STOP

	ENDIF

	IF(READLINE(12:38) .NE. 'NO. OF OBSERVED VALUE TIMES') GO TO 35
	BACKSPACE(21)
   13   FORMAT(T2,I5)
        READ(21,13) NOBS

C  MAXOBS IS THE CURRENT MAX. NO. OF OBSERVATION TIMES AMONG THE
C  SUBJECTS. SET IT = NOBS IF NOBS > MAXOBS.


	IF(NOBS .GT. MAXOBS) MAXOBS = NOBS

         DO I=1,NOBS
          READ(21,*) TIMM,(YO(I,J),J=1,NUMEQT)
	 END DO


C  IF ICOFF=0, WRITE ALL OF FILE 21 TO FILE 27;
C  IF ICOFF=1, WRITE ALL OF FILE 21, EXCEPT FOR ASSAY COEFFICIENT INFO,

C	       TO FILE 27.

	OPEN(27,STATUS='SCRATCH')
	REWIND(21)


   10	READ(21,3,IOSTAT=IEND) READLINE
	IF(IEND .LT. 0 .OR. READLINE(1:5) .EQ. 'ASSAY' ) GO TO 25
	WRITE(27,3) READLINE
	GO TO 10


   25	READLINE = 'ASSAY COEFFICIENTS FOLLOW, ONE SET FOR EACH OUTPUT EQU
     1ATION:'
        WRITE(27,3) READLINE


C  NOW PUT IN THE APPROPRIATE C'S, DEPENDING ON THE VALUE OF ICOFF.



C********** PUT C'S IN FILE CURRENTLY HAVING NO C'S (BELOW) ************

	IF(ICOFF .EQ. 0) THEN


	DO IEQ = 1,NUMEQT

	IF(IASS(IEQ) .EQ. 1 .OR. IASS(IEQ) .EQ. 2) WRITE(27,16)
     1  C0P(IEQ),C1P(IEQ),C2P(IEQ),C3P(IEQ)

   16    FORMAT(4(F16.8,2X))

	IF(IASS(IEQ) .EQ. 4) THEN

   20	WRITE(*,18) PATHFILE,IEQ
   18   FORMAT(///' ****************************************************
     1********************'/
     1' PATIENT FILE ',A73/
     2' CURRENTLY HAS NO ASSAY COEFFICIENTS. FOR OUTPUT EQUATION ',I2,/
     3' THE GENERAL ASSAY COEFFICIENTS ARE: ')
	WRITE(*,16) C0P(IEQ),C1P(IEQ),C2P(IEQ),C3P(IEQ)
	WRITE(*,19)

   19   FORMAT(/' ENTER 1 TO USE THESE GENERAL COEFFICIENTS;'/
     1' ENTER 0 TO USE A DIFFERENT SET OF VALUES:  ')
	READ(*,*,ERR=20) IUSE
	IF(IUSE .NE. 0 .AND. IUSE .NE. 1) GO TO 20

	IF(IUSE .EQ. 1) WRITE(27,16) C0P(IEQ),C1P(IEQ),C2P(IEQ),C3P(IEQ)

	IF(IUSE .EQ. 0) THEN

C  CALL USECS TO GET [C0,C1,C2,C3] TO WRITE INTO THIS PATIENT'S FILE.
C  ALSO NOTE THAT NCSTORE AND GENCOEF WILL GET UPDATED IF THE USER
C  WANTS TO STORE THESE C'S (IF NCSTORE IS NOT ALREADY = 5).

	 CALL USECS(IEQ,NCSTORE,GENCOEF,C0,C1,C2,C3,MAXNUMEQ)

	 WRITE(27,16) C0,C1,C2,C3

	ENDIF

	ENDIF

C  THE ABOVE ENDIF IS FOR THE   IF(IASS(IEQ) .EQ. 4)  CONDITION.

	IF(IASS(IEQ) .EQ. 3 .AND. IALLPAT(IEQ) .EQ. 1)
     1  WRITE(27,16) ASSMULT(IEQ)*C0P(IEQ), ASSMULT(IEQ)*C1P(IEQ),
     2               ASSMULT(IEQ)*C2P(IEQ), ASSMULT(IEQ)*C3P(IEQ)

	IF(IASS(IEQ) .EQ. 3 .AND. IALLPAT(IEQ) .EQ. 0) THEN

  240	 WRITE(*,227) PATHFILE,IEQ,C0P(IEQ),C1P(IEQ),C2P(IEQ),C3P(IEQ),
     1   ASSMULT(IEQ),ASSMULT(IEQ)*C0P(IEQ),ASSMULT(IEQ)*C1P(IEQ),
     2   ASSMULT(IEQ)*C2P(IEQ),ASSMULT(IEQ)*C3P(IEQ)
  227   FORMAT(///' ****************************************************
     1********************'/
     1' FILE  ',A73/
     2' HAS NO ASSAY COEFFICIENTS FOR OUTPUT EQUATION ',I1,'; THE GENERA
     1L (DEFAULT)'/
     2' COEFFICIENTS ARE:  ' ,4(G12.6,1X),//
     1' ENTER 1 TO MULTIPLY THESE GENERAL COEFFICIENTS BY ',G12.6,/
     2'         I.E., USE ',4(G12.6,1X)/

     2' ENTER 2 TO USE THE GENERAL COEFFICIENTS; '/
     3' ENTER 0 TO USE A DIFFERENT SET OF VALUES:  ')


	READ(*,*,ERR=240) IUSE
	IF(IUSE .NE. 0 .AND. IUSE .NE. 1 .AND. IUSE .NE. 2) GO TO 240

	IF(IUSE .EQ. 1) WRITE(27,16) ASSMULT(IEQ)*C0P(IEQ),ASSMULT(IEQ)*
     1    C1P(IEQ),ASSMULT(IEQ)*C2P(IEQ),ASSMULT(IEQ)*C3P(IEQ)
	IF(IUSE .EQ. 2) WRITE(27,16) C0P(IEQ),C1P(IEQ),C2P(IEQ),C3P(IEQ)

	IF(IUSE .EQ. 0) THEN

C  CALL USECS TO GET [C0,C1,C2,C3] TO WRITE INTO THIS PATIENT'S FILE.
C  ALSO NOTE THAT NCSTORE AND GENCOEF WILL GET UPDATED IF THE USER
C  WANTS TO STORE THESE C'S (IF NCSTORE IS NOT ALREADY = 5).

	 CALL USECS(IEQ,NCSTORE,GENCOEF,C0,C1,C2,C3,MAXNUMEQ)

	 WRITE(27,16) C0,C1,C2,C3

	ENDIF

  250	WRITE(*,228) ASSMULT(IEQ)
  228   FORMAT(/' ENTER 1 TO CONTINUE EXAMINING ASSAY COEFFICIENTS ON'/
     1' 	A PATIENT - BY - PATIENT BASIS; '/
     2' ENTER 0 TO MULTIPLY THE ASSAY COEFFICIENTS OF ALL SUBSEQUENT'/
     3'		PATIENTS (OR THE GENERAL COEFFICIENTS FOR THOSE PATIENTS
     4'/
     5'		WITHOUT COEFFICIENTS) BY ',G12.6,': ')
	READ(*,*,ERR=250) ICONT
	IF(ICONT .NE. 0 .AND. ICONT .NE. 1) GO TO 250

	IF(ICONT .EQ. 0) IALLPAT(IEQ) = 1

C  NOTE THAT IF ICONT = 1, IALLPAT(IEQ) WILL REMAIN 0.


	ENDIF

C ABOVE ENDIF IS FOR THE  IF(IASS(IEQ) .EQ. 3 .AND. IALLPAT(IEQ) .EQ. 0)
C CONDITION.


	END DO

C  THE ABOVE END DO IS FOR THE  DO IEQ = 1,NUMEQT  LOOP.


	ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(ICOFF .EQ. 0) CONDITION.

C********** PUT C'S IN FILE CURRENTLY HAVING NO C'S (ABOVE) ************



C********** PUT C'S IN FILE CURRENTLY HAVING C'S (BELOW) ***************

	IF(ICOFF .EQ. 1) THEN


	 DO IEQ = 1,NUMEQT

C  THIS FILE HAS C'S ON THE NEXT LINE.

	READ(21,*) C0,C1,C2,C3

	IF(IASS(IEQ) .EQ. 1) WRITE(27,16) C0,C1,C2,C3
	IF(IASS(IEQ) .EQ. 2) WRITE(27,16) C0P(IEQ),C1P(IEQ),C2P(IEQ),
     1  C3P(IEQ)


	IF(IASS(IEQ) .EQ. 3 .AND. IALLPAT(IEQ) .EQ. 1)

     1  WRITE(27,16) ASSMULT(IEQ)*C0, ASSMULT(IEQ)*C1, ASSMULT(IEQ)*C2,
     2               ASSMULT(IEQ)*C3

	IF(IASS(IEQ) .EQ. 3 .AND. IALLPAT(IEQ) .EQ. 0) THEN
  140	 WRITE(*,127) PATHFILE,IEQ,C0,C1,C2,C3,ASSMULT(IEQ),ASSMULT(IEQ)
     1   *C0,ASSMULT(IEQ)*C1,ASSMULT(IEQ)*C2,ASSMULT(IEQ)*C3
  127   FORMAT(///' ****************************************************
     1********************'/
     1' FILE ',A73/


     2' CURRENTLY CONTAINS THE FOLLOWING ASSAY COEFFICIENTS FOR OUTPUT'/
     3' EQUATION ',I1,': '/
     2'  ',4(G12.6,1X),//
     1' ENTER 1 TO MULTIPLY THESE COEFFICIENTS BY ',G12.6,/

     2'         I.E., USE ',4(G12.6,1X)/
     2' ENTER 2 TO LEAVE THESE COEFFICIENTS UNCHANGED; '/
     3' ENTER 0 TO USE A DIFFERENT SET OF VALUES:  ')

	READ(*,*,ERR=140) IUSE
	IF(IUSE .NE. 0 .AND. IUSE .NE. 1 .AND. IUSE .NE. 2) GO TO 140

	IF(IUSE .EQ. 1) WRITE(27,16) ASSMULT(IEQ)*C0,ASSMULT(IEQ)*C1,
     1				     ASSMULT(IEQ)*C2,ASSMULT(IEQ)*C3
	IF(IUSE .EQ. 2) WRITE(27,16) C0,C1,C2,C3

	IF(IUSE .EQ. 0) THEN

C  CALL USECS TO GET [C0,C1,C2,C3] TO WRITE INTO THIS PATIENT'S FILE.
C  ALSO NOTE THAT NCSTORE AND GENCOEF WILL GET UPDATED IF THE USER
C  WANTS TO STORE THESE C'S (IF NCSTORE(IEQ) IS NOT ALREADY = 5).

	 CALL USECS(IEQ,NCSTORE,GENCOEF,C0,C1,C2,C3,MAXNUMEQ)

	 WRITE(27,16) C0,C1,C2,C3


	ENDIF

  260	WRITE(*,228) ASSMULT(IEQ)
	READ(*,*,ERR=260) ICONT
	IF(ICONT .NE. 0 .AND. ICONT .NE. 1) GO TO 260

	IF(ICONT .EQ. 0) IALLPAT(IEQ) = 1

C  NOTE THAT IF ICONT = 1, IALLPAT(IEQ) WILL REMAIN 0.


	ENDIF

C ABOVE ENDIF IS FOR THE
C IF(IASS(IEQ) .EQ. 3 .AND. IALLPAT(IEQ) .EQ. 0) CONDITION.


	IF(IASS(IEQ) .EQ. 4) THEN

   40	 WRITE(*,28) PATHFILE,IEQ
   28   FORMAT(///' ****************************************************
     1********************'/
     1' FOR PATIENT FILE ',A73/
     2' AND OUTPUT EQUATION ',I2,' THE CURRENT COEFFICIENTS ARE: ')
	 WRITE(*,16) C0,C1,C2,C3

	 WRITE(*,29)
   29    FORMAT(/' ... AND THE GENERAL COEFFICIENTS ARE: ')
	 WRITE(*,16) C0P(IEQ),C1P(IEQ),C2P(IEQ),C3P(IEQ)
	 WRITE(*,31)
   31    FORMAT(/' ENTER 1 TO CONTINUE USING THE CURRENT COEFFICIENTS;'/
     2' ENTER 2 TO USE THE GENERAL COEFFICIENTS;'/
     3' ENTER 0 TO USE A DIFFERENT SET OF VALUES:  ')

	READ(*,*,ERR=40) IUSE
	IF(IUSE .NE. 0 .AND. IUSE .NE. 1 .AND. IUSE .NE. 2) GO TO 40

	IF(IUSE .EQ. 1) WRITE(27,16) C0,C1,C2,C3

	IF(IUSE .EQ. 2) WRITE(27,16) C0P(IEQ),C1P(IEQ),C2P(IEQ),C3P(IEQ)

	IF(IUSE .EQ. 0) THEN


C  CALL USECS TO GET [C0,C1,C2,C3] TO WRITE INTO THIS PATIENT'S FILE.
C  ALSO NOTE THAT NCSTORE AND GENCOEF WILL GET UPDATED IF THE USER
C  WANTS TO STORE THESE C'S (IF NCSTORE(IEQ) IS NOT ALREADY = 5).

	 CALL USECS(IEQ,NCSTORE,GENCOEF,C0,C1,C2,C3,MAXNUMEQ)

	 WRITE(27,16) C0,C1,C2,C3

	ENDIF

	ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(IASS(IEQ) .EQ. 4) CONDITION.

	END DO

C  THE ABOVE END DO IS FOR THE  DO IEQ = 1,NUMEQT  LOOP.


	ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(ICOFF .EQ. 1) CONDITION.

C********** PUT C'S IN FILE CURRENTLY HAVING C'S (ABOVE) ***************

C  NOW COPY FILE 27 BACK INTO FILE 21.


	CLOSE(21)
        OPEN(21,FILE=PATHFILE)
	REWIND(27)

   60	READ(27,3,IOSTAT=IEND) READLINE


	IF(IEND .LT. 0) THEN

	 CLOSE(27)
         CLOSE(21)
	 RETURN

	ENDIF

	WRITE(21,3) READLINE
	GO TO 60


	END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C


      SUBROUTINE USERPREP(NDIM,NP,NVAR,MAXDIM,PAR,NOFIX,PARFIX,NRANFIX,
     1 PARRANFIX,IRAN)



C  THIS SUBROUTINE, CALLED BY MAIN, READS THE FORTRAN FILE, FORFILE,
C  OPENED IN MAIN (FILE 28), WHICH WAS CREATED BY A 'BOXES'- TYPE
C  PROGRAM, AND RETURNS THE VALUES IN THE ABOVE ARGUMENT LIST.
 
C  NOTE: WHEN THIS PROGRAM STARTS READING THE NEW BOXES PROGRAM, MAKE
C      SURE THAT THE MICHAELIS-MENTIN EQUATION IS CORRECT - IT SHOULD
C	 BE  (SEE PAGE *1 OF M2_7/m2_7calc.f NOTES OR NOTES FROM PG. 5.
C  	 OF PHARMACOKINETICS AND PHARMACODYNAMICS, VOL 2).

C	 dX/dT = (VM x X) / (KM x V1 + X), WHERE VM = V1 * Vmax, AND
C	  THE UNITS ARE: X --> grams; T --> hours; VM --> grams/hour;
C			 V1 --> liters; KM --> grams/liter;
C			 Vmax --> grams/(liter * hour)

C  NOTE: THE ABOVE EQUATION IS EXACTLY THE SAME AS
C	 dC/dT = (Vmax * C)/(KM + C), WHERE C = X/V1, WHICH IS
C	  EQUATION 3 ON PG. 5 OF PHARMACOKINETICS AND PHARMACODYNAMICS,
C         VOL 2, WHERE:
C	  Vmax = dC/dT AS C--> infinity;

C	  KM = C WHEN dC/dT = Vmax/2.

C	  ABOVE COMMENTS WERE IMPROVED 7/27/99 AFTER
C         CONVERSATION WITH ROGER AND DARRYL CLARDY.
C 

      IMPLICIT REAL*8(A-H,O-Z)
      DIMENSION IRAN(32)
      CHARACTER PAR(MAXDIM)*11,PARFIX(20)*11,READLINE*1000,
     1 PSYM(32)*11,RR*1,TEMP*11,C*1,ERRFIL*20,PARRANFIX(20)*11

      COMMON/ERROR/ERRFIL
C  COMMON/ERROR/ IS SUPPLIED TO ALL THE ROUTINES WHICH COULD WRITE TO

C  ERRFIL. 


C  FILE 28 WAS OPENED (IN MAIN) AT THE END OF THE FILE. BACKSPACE AND
C  THEN READ IN NDIM, NP AND PSYM(I),I=1,NP.

    2   FORMAT(A1000)

   30	BACKSPACE(28)
	BACKSPACE(28)

	READ(28,2) READLINE
	IF(READLINE(8:9) .NE. 'N=') GO TO 30
	BACKSPACE(28)
	READ(28,3) NDIM
    3   FORMAT(T10,I3)

   40	READ(28,2) READLINE

	IF(READLINE(8:9) .NE. 'NP') GO TO 40
	BACKSPACE(28)
	READ(28,4) NP
    4   FORMAT(T11,I3)

   50	READ(28,2) READLINE
	IF(READLINE(8:11) .NE. 'PSYM') GO TO 50
	BACKSPACE(28)


	DO 70 I=1,NP

	IF(I .LE. 9) READ(28,14) TEMP
	IF(I .GE. 10 .AND. I .LE. 99) READ(28,6) TEMP

C  WRITE TEMP INTO PSYM, STRIPPING OFF THE ENDING QUOTE MARK, IF ONE
C  IS THERE.

	C = ''''
	PSYM(I) = TEMP

	DO J=1,11

	 IF(TEMP(J:J) .EQ. C) THEN

	  PSYM(I) = TEMP(1:J-1)
	  GO TO 70
	 ENDIF


	END DO


   70   CONTINUE

   14   FORMAT(T17,A11)
    6   FORMAT(T18,A11)


C  NOW QUIZ THE USER TO SEE WHICH PARAMETERS ARE FIXED, AND WHICH ARE
C  RANDOM.

C  SET IRAN(I) = 1 IF PSYM(I) = RANDOM;
C                0 IF PSYM(I) = FIXED;
C                2 IF PSYM(I) = RANFIX.


   80	WRITE(*,7) NP


    7   FORMAT(/' FOR EACH OF THE ',I2,' PARAMETERS, '//
     1' ENTER "R" IF IT IS TO BE A RANDOM VARIABLE;'/
     2' ENTER "F" IF IT IS TO BE A FIXED AND KNOW PARAMETER;'/
     3' ENTER "U" IF IT IS TO BE A FIXED BUT UNKNOWN PARAMETER'/
     4'           TO BE ESTIMATED.'//)

	NVAR = 0
	NOFIX = 0
      NRANFIX = 0



	DO I=1,NP

   8     FORMAT(1X,A11,':  ')
   60	 WRITE(*,8) PSYM(I)
	 READ(*,9) RR

    9    FORMAT(A1)
	 IF(RR .NE. 'R' .AND. RR .NE. 'r' .AND. RR .NE. 'F'
     1      .AND. RR .NE. 'f' .AND. RR .NE. 'U' .AND. RR .NE. 'u') 
     2    GO TO 60

	 IF(RR .EQ. 'R' .OR. RR .EQ. 'r') THEN
	  NVAR = NVAR+1

C  NOTE THAT THIS PROGRAM RESETS NP TO A VERY LARGE VALUE
C  IF NVAR > THE DIMENSION LIMIT OF PAR. THIS IS BIZARRE. IT DOESN'T
C  HAPPEN IF NOFIX > THE DIMENSION LIMIT OF PARFIX, AND IT DOESN'T
C  HAPPEN IN MONTBIG8.FOR WHICH HAS THE SAME CODE AS HERE.
C  BUT SINCE IT HAPPENS HERE, CHECK TO SEE IF NVAR > MAXDIM, AND IF
C  SO TRANSFER CONTROL TO LABEL 110 WITHOUT SETTING PAR(MAXDIM+1) TO
C  PSYM(I).

	  IF(NVAR .GT. MAXDIM) GO TO 110
	  PAR(NVAR) = PSYM(I)
	  IRAN(I) = 1
	 ENDIF


	 IF(RR .EQ. 'F' .OR. RR .EQ. 'f') THEN
	  NOFIX = NOFIX+1
	  PARFIX(NOFIX) = PSYM(I)
	  IRAN(I) = 0
	 ENDIF

	 IF(RR .EQ. 'U' .OR. RR .EQ. 'u') THEN
	  NRANFIX = NRANFIX+1
	  PARRANFIX(NRANFIX) = PSYM(I)
	  IRAN(I) = 2
	 ENDIF

	END DO

C  IF NVAR .GT. MAXDIM, PRINT MESSAGE TO USER AND HAVE HIM TRY AGAIN.
C  SIMILARLY IF NOFIX .GT. 20, NRANFIX .GT. 20, OR IF 
C  NVAR + NOFIX + NRANFIX .GT. 32.

  110	IF(NVAR .GT. MAXDIM) THEN
	 WRITE(*,111) NVAR,MAXDIM
  111    FORMAT(//' YOU HAVE SELECTED ',I2,' PARAMETERS TO BE RANDOM'/
     1' VARIABLES. THE LIMIT IS CURRENTLY ',I2,'. PLEASE RESPECIFY'/
     2' YOUR PARAMETERS WITH THIS LIMIT IN MIND.'//)
	 GO TO 80
	ENDIF

	IF(NOFIX .GT. 20) THEN
	 WRITE(*,112) NOFIX
  112    FORMAT(//' YOU HAVE SELECTED ',I2,' PARAMETERS TO BE FIXED'/
     1' AND KNOWN PARAMETERS. THE LIMIT IS CURRENTLY 20. PLEASE'/
     2' RESPECIFY YOUR PARAMETERS WITH THIS LIMIT IN MIND.'//)
	 GO TO 80
	ENDIF

	IF(NRANFIX .GT. 20) THEN
	 WRITE(*,114) NRANFIX
  114    FORMAT(//' YOU HAVE SELECTED ',I2,' PARAMETERS TO BE FIXED'/
     1' BUT UNKNOWN PARAMETERS. THE LIMIT IS CURRENTLY 20. PLEASE'/
     2' RESPECIFY YOUR PARAMETERS WITH THIS LIMIT IN MIND.'//)
	 GO TO 80
	ENDIF


	IF(NVAR + NOFIX + NRANFIX .GT. 32) THEN


	 WRITE(*,113) NVAR + NOFIX + NRANFIX
  113    FORMAT(//' YOUR MODEL FILE HAS A TOTAL OF ',I2,' PARAMETERS.'/
     1' THE LIMIT IS CURRENTLY 32. PLEASE EDIT YOUR MODEL FILE SO '/
     2' THAT IT HAS .LE. 32 PARAMETERS. '//)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,113) NVAR + NOFIX 
        CLOSE(42)

	 CALL PAUSE
	 STOP

	ENDIF


	RETURN
	END
C

CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
	SUBROUTINE SUBRES(MAXSUB,JSUB,CORDEN,WORK,MAXGRD,MAXDIM,NVAR,
     1AB,PAR,NACTVE,IPUT,NGRID,VOLSPA,ISCROL,CENTER,PYJGX,PYJGXX)
	IMPLICIT REAL*8(A-H,O-Z)
      DIMENSION AB(30,2),EX(30),COV(30,30),
     1E(30,30),STD(30),CORR(30,30),COFVR(30),
     1WORK(MAXGRD),CORDEN(MAXGRD,MAXDIM+1),CENTER(3,30),
     2PYJGX(MAXSUB,MAXGRD),PYJGXX(MAXGRD)
	REAL*8 KU
	CHARACTER PAR(30)*11

C  AS OF MXEM2N54, SUBRES IS CHANGED. RATHER THAN CALCULATE THE

C  'FINAL FITTED JOINT P.D.F.' FOR EACH SUBJECT, IT CALCULATES
C  THE BAYESIAN POSTERIOR DENSITY FOR EACH SUBJECT. IN PARTICULAR, FOR
C  A SUBJECT WITH OBSERVATIONS Y, THE  BAYESIAN POSTERIOR DENSITY IS
C  P(XI|Y) FOR EACH REMAINING GRID POINT (XI) IN THE POPULATION FINAL
C  CYCLE JOINT DENSITY, WHERE P(XI|Y) = PF(XI) * P(Y|XI) / P(Y),
C  P(Y) = INTEGRAL OF P(Y|XI)*PF(XI), AND PF(XI) IS THE POPULATION
C  FINAL CYCLE JOINT DENSITY VALUE AT XI.

C  THIS ROUTINE, CALLED BY SUBROUTINE PREVRUN,
C  INPUTS THE FINAL JOINT DENSITY (CORDEN)
C  FROM THE PROGRAM (FOR THE ENTIRE POPULATION) AS THE APRIORI DENSITY
C  FOR A SINGLE SUBJECT WHOSE CONCENTRATION LEVELS, ETC. HAVE ALREADY
C  BEEN READ INTO COMMON STATEMENTS FOR MODULE IDPC, AND CALCULATES THAT
C  SUBJECT'S BAYESIAN POSTERIOR JOINT DENSITY. IT OUTPUTS LOG-LIKS,

C  EXPECTED VALUES, ETC. FOR THIS DENSITY.

C  NOTE THAT PYJGX(JSUB,IG) = P(YJ|IGTH GRID PT) IS INPUT ABOVE, AND
C  THEN 'CONDENSED' INTO PYJGXX(IG) BELOW. THIS MEANS THAT IT DOESN'T
C  HAVE TO BE CALCULATED IN LOOP 800.

C  NOTE: THE RESULTS ARE OUTPUT TO THE SCREEN. IF IPUT=1, THEY
C	 ARE ALSO OUTPUT TO FILE 31 (IF IAGAIN = 0 -- SEE BELOW).


C  FOR DETAILED COMMENTS ON THE FOLLOWING CODE, SEE THE SIMILAR CODE

C  IN PROGRAMS MXEM2N64.FOR, ...





   	NSUB=1
	NINT=100


	WRITE(*,5432)
 5432   FORMAT('1')

	DENMAX=CORDEN(1,NVAR+1)
	DO I=1,NACTVE
	  D=CORDEN(I,NVAR+1)
	  IF(D .GT. DENMAX) DENMAX=D
	END DO

	SUMD=0.
	NEWIND=0

	DO I=1,NACTVE

	  D=CORDEN(I,NVAR+1)

	  IF(D .GT. 1.D-10*DENMAX) THEN
	    SUMD=SUMD+D
	    NEWIND=NEWIND+1
	      DO J=1,NVAR
		CORDEN(NEWIND,J)=CORDEN(I,J)
	      END DO
	    CORDEN(NEWIND,NVAR+1)=D
	    PYJGXX(NEWIND)=PYJGX(JSUB,I)
	  ENDIF


	END DO

	NACTVE=NEWIND

	FACT = NGRID/VOLSPA/SUMD

	DO I=1,NACTVE
	  CORDEN(I,NVAR+1)=CORDEN(I,NVAR+1)*FACT
	END DO


C  INITIALIZE IAGAIN = 0, MEANING THAT THE RESULTS BELOW ARE BEING
C  OUTPUT TO THE SCREEN (AND FILE 31, IF IPUT=1) FOR THE 1ST TIME.

	IAGAIN = 0

 3000	WRITE(*,1241) JSUB

 1241   FORMAT(//' THE BAYESIAN POSTERIOR DENSITY RESULTS FOLLOW FOR '/
     1' SUBJECT NO. ',I4/)


	IF(IAGAIN .EQ. 1) GO TO 3010


	DO 800 IG=1,NACTVE
  800   WORK(IG)=PYJGXX(IG)*CORDEN(IG,NVAR+1)


C  WORK(IG) = P(YJ,XIG), FOR IG=1,NACTVE.
C  PYJ = P(YJ) = INTEGRAL OF WORK.

      CALL NOTINT(VOLSPA,NGRID,NACTVE,WORK,MAXGRD,PYJ)

C  THE BAYESIAN POSTERIOR DENSITY OF THIS SUBJECT IS, FOR GRID PT. IG,
C  P(XIG|YJ) = P(YJ,XIG)/P(YJ). PUT THESE VALUES INTO CORDEN(IG,NVAR+1).

	DO IG=1,NACTVE

	 CORDEN(IG,NVAR+1) = WORK(IG)/PYJ
	END DO

	SLPYJ=DLOG(PYJ)

 3010	WRITE(*,8)
    8   FORMAT(/' THE TRUE (NUMERICAL) LOG-LIKELIHOOD OF THE BAYESIAN'/
     1' POSTERIOR DENSITY FOR THIS SUBJECT, ASSUMING THE PRIOR DENSITY'/
     2' IS THE FINAL CYCLE DENSITY FROM THE POPULATION ANALYSIS, IS: ')
	WRITE(*,*) SLPYJ

	WRITE(*,*)

	WRITE(*,*)' THE NO. OF ACTIVE GRID POINTS IS NOW ',NACTVE
	WRITE(*,*)
	WRITE(*,*)' THE INITIAL NO. OF GRID POINTS WAS ',NGRID
	WRITE(*,*)


	IF(IPUT .EQ. 1 .AND. IAGAIN .EQ. 0) THEN
	 WRITE(31,8)
	 WRITE(31,*) SLPYJ
	 WRITE(31,*)
	 WRITE(31,*)' THE NO. OF ACTIVE GRID POINTS IS NOW ',NACTVE
	 WRITE(31,*)
	 WRITE(31,*)' THE INITIAL NO. OF GRID POINTS WAS ',NGRID
	 WRITE(31,*)
	ENDIF


	IF(IAGAIN .EQ. 1) CALL PAUSE

C  IF IAGAIN=1 (OUTPUTTING VALUES AGAIN) GO TO NEXT WRITE STATEMENT.

	IF(IAGAIN .EQ. 1) GO TO 3020

	FACT=VOLSPA/NGRID
	SUM=0.D0


	DO I=1,NACTVE

	PI=CORDEN(I,NVAR+1)*FACT


	IF (PI .GT. 1.D-200) THEN
	  SUM=SUM+PI*DLOG(PI)
	ENDIF

	END DO

	DL2=DLOG(2.D0)
	SUM = SUM/DL2
	ENT = -SUM

        DGRID=NGRID


	FACT=100.D0*DL2/DLOG(DGRID/NSUB)
	SUM = FACT*(SUM + DLOG(DGRID)/DL2)

 3020   WRITE(*,31) SUM
	WRITE(*,131) ENT
	IF(IPUT .EQ. 1 .AND. IAGAIN .EQ. 0) WRITE(31,31) SUM
	IF(IPUT .EQ. 1 .AND. IAGAIN .EQ. 0) WRITE(31,131) ENT
   31 FORMAT(/' THE SCALED INFO FOR THIS DENSITY IS ',F10.2,' %'/)
  131 FORMAT(/' THE ENTROPY FOR THIS DENSITY IS ',G11.4/)

C  IF IAGAIN=1 (OUTPUTTING VALUES AGAIN) GO TO NEXT WRITE STATEMENT.

	IF(IAGAIN .EQ. 1) GO TO 3030

	DO 1100 I=1,NVAR

	DO IG=1,NACTVE
	  WORK(IG)=CORDEN(IG,I)*CORDEN(IG,NVAR+1)
	END DO

	II=I

        CALL NOTINT(VOLSPA,NGRID,NACTVE,WORK,MAXGRD,EX(II))

	DO 1100 J=1,I

	DO IG=1,NACTVE
	  WORK(IG)=CORDEN(IG,I)*CORDEN(IG,J)*CORDEN(IG,NVAR+1)
	END DO

	JJ=J
 1100   CALL NOTINT(VOLSPA,NGRID,NACTVE,WORK,MAXGRD,E(II,JJ))


      DO 190 I=1,NVAR
      DO 190 J=1,I
  190 COV(I,J)=E(I,J)-EX(I)*EX(J)

 3030	WRITE(*,*)' THE MEANS ARE: '
	IF(IPUT .EQ. 1 .AND. IAGAIN .EQ. 0) WRITE(31,*)' THE MEANS ARE: '
	WRITE(*,5104) (PAR(I),I=1,NVAR)
	IF(IPUT .EQ. 1 .AND. IAGAIN .EQ. 0)
     1  WRITE(31,5104) (PAR(I),I=1,NVAR)
 5104   FORMAT(5X,30(A11,2X))


	WRITE(*,5103) (EX(I),I=1,NVAR)
	IF(IPUT .EQ. 1 .AND. IAGAIN .EQ. 0)
     1  WRITE(31,5103) (EX(I),I=1,NVAR)
 5103   FORMAT(1X,30(G12.6,1X))

	IF(IAGAIN .EQ. 1) CALL PAUSE



	ICOVL0=0

	DO I=1,NVAR


	IF(COV(I,I) .LE. 0.D0) THEN

	 ICOVL0=1
	 WRITE(*,1652) I
	 IF(IPUT .EQ. 1 .AND. IAGAIN .EQ. 0) WRITE(31,1652) I


	IF(IAGAIN .EQ. 1) CALL PAUSE

	ENDIF

	END DO

 1652   FORMAT(/' THE VARIANCE FOR PARAMETER NO. ',I2,' IS NUMERICALLY'/
     1' .LE. 0; ALL COVARIANCE-RELATED OUTPUT WILL BE SUPPRESSED FOR '/
     2' THIS CYCLE (ALSO, SKEWNESS AND KURTOSIS WILL HAVE -99999999'/
     3' IN THEIR LOCATIONS.)')


	IF(ICOVL0 .EQ. 0) THEN

      WRITE(*,13)
	IF(IPUT .EQ. 1 .AND. IAGAIN .EQ. 0) WRITE(31,13)
   13 FORMAT(/' THE COV MATRIX IS, IN LOWER TRI FORM:')

	WRITE(*,5104) (PAR(I),I=1,NVAR)
	IF(IPUT .EQ. 1 .AND. IAGAIN .EQ. 0)
     1  WRITE(31,5104) (PAR(I),I=1,NVAR)

      DO 200 I=1,NVAR
      IF(IPUT .EQ. 1 .AND. IAGAIN .EQ. 0)WRITE(31,5103) (COV(I,J),J=1,I)
  200 WRITE(*,5103) (COV(I,J),J=1,I)



C  IF IAGAIN=1 (OUTPUTTING VALUES AGAIN) GO TO NEXT WRITE STATEMENT.

	IF(IAGAIN .EQ. 1) GO TO 3040



	DO 6070 I=1,NVAR
	STD(I)=DSQRT(COV(I,I))
	COFVR(I)=STD(I)*1.D2/EX(I)
	DO 6070 J=1,I
 6070   CORR(I,J)=COV(I,J)/STD(I)/STD(J)


 3040	WRITE(*,6071)
	IF(IPUT .EQ. 1 .AND. IAGAIN .EQ. 0) WRITE(31,6071)
 6071   FORMAT(/' THE STANDARD DEVIATIONS ARE, RESPECTIVELY: ')



	WRITE(*,5104) (PAR(I),I=1,NVAR)

	IF(IPUT .EQ. 1 .AND. IAGAIN .EQ. 0)
     1  WRITE(31,5104) (PAR(I),I=1,NVAR)

	WRITE(*,5103) (STD(I),I=1,NVAR)
	IF(IPUT .EQ. 1 .AND. IAGAIN .EQ. 0)
     1  WRITE(31,5103) (STD(I),I=1,NVAR)



	IF(IAGAIN .EQ. 1) CALL PAUSE


	WRITE(*,6072)
	IF(IPUT .EQ. 1 .AND. IAGAIN .EQ. 0) WRITE(31,6072)
 6072   FORMAT(/' THE PERCENT COEFFICIENTS OF VARIATION ARE, RESP.: ')


	WRITE(*,5104) (PAR(I),I=1,NVAR)
	IF(IPUT .EQ. 1 .AND. IAGAIN .EQ. 0)
     1  WRITE(31,5104) (PAR(I),I=1,NVAR)

	WRITE(*,5103) (COFVR(I),I=1,NVAR)
	IF(IPUT .EQ. 1 .AND. IAGAIN .EQ. 0)

     1  WRITE(31,5103) (COFVR(I),I=1,NVAR)


	WRITE(*,6073)
	IF(IPUT .EQ. 1 .AND. IAGAIN .EQ. 0) WRITE(31,6073)
 6073   FORMAT(/' THE CORR. MATRIX IS, IN LOWER TRIANGULAR FORM: ')

	WRITE(*,5104) (PAR(I),I=1,NVAR)
	IF(IPUT .EQ. 1 .AND. IAGAIN .EQ. 0)
     1  WRITE(31,5104) (PAR(I),I=1,NVAR)




	DO 6080 I=1,NVAR

	IF(IPUT .EQ. 1 .AND. IAGAIN .EQ. 0)
     1  WRITE(31,5103) (CORR(I,J),J=1,I)
 6080   WRITE(*,5103) (CORR(I,J),J=1,I)



	IF(IAGAIN .EQ. 1) CALL PAUSE


	ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(ICOVL0 .EQ. 0) CONDITION.

	WRITE(*,6091) NVAR
	IF(IPUT .EQ. 1 .AND. IAGAIN .EQ. 0) WRITE(31,6091) NVAR
 6091   FORMAT(//' THE FOLLOWING ',I2,' SETS OF LINES GIVE ADDITIONAL'/
     1' STATISTICS FOR THE VARIABLES. FOR EACH SET:'//
     2' THE 1ST LINE GIVES THE MODE, THE SKEWNESS, THE KURTOSIS, AND '/
     3' THE 2.5 %-TILE VALUE OF THE DISTRIBUTION. '//
     4' THE 2ND LINE GIVES THE 25, 50, 75, AND 97.5 %-TILE VALUES OF '/
     5' THE DISTRIBUTION. '//
     6' THE 3RD LINE GIVES THREE ADDITIONAL AD-HOC ESTIMATES OF THE '/
     6' STANDARD DEVIATION FOR THAT MARGINAL DENSITY. THE 1ST S.D. '/
     7' ESTIMATE IS THE STANDARD DEVIATION OF A NORMAL DISTRIBUTION '/
     8' HAVING THE SAME [25, 75] %-TILE RANGE AS THAT VARIABLE. THE'/
     9' 2ND ESTIMATE IS THE STANDARD DEVIATION OF A NORMAL DIST.'/

     1' HAVING THE SAME [2.5, 97.5] %-TILE RANGE AS THAT VARIABLE. THE'/
     2' 3RD ESTIMATE IS THE AVERAGE OF THE FIRST TWO. THE 4TH VALUE'/
     3' IN THE LINE IS THE THE % SCALED INFO FOR THAT MARGINAL DENS.'//)

	IF(IAGAIN .EQ. 1) CALL PAUSE



	DO 6090 I=1,NVAR
	IND=I

	IF(I .EQ. 4 .OR. I .EQ. 7) THEN

	IF(IAGAIN .EQ. 1) CALL PAUSE

	ENDIF

	CALL STATZ(VOLSPA,NGRID,NACTVE,NVAR,IND,CORDEN,WORK,MAXGRD,NINT,
     1  AB(IND,1),AB(IND,2),XMODE,X025,X25,X50,X75,X975,SCALINFO,NSUB,
     2  MAXDIM)

C  STORE THE MEDIANS AND MODES.

	CENTER(2,IND)=X50
	CENTER(3,IND)=XMODE

	SDEST1 = (X75-X25)/1.349

	SDEST2 = (X975-X025)/3.92
	SDEST3 = .5D0*(SDEST1+SDEST2)

	IF(ICOVL0 .EQ. 1) THEN
	  SK = -99999999

	  KU = -99999999
	ENDIF


	IF(ICOVL0 .EQ. 0) THEN

	DO IG=1,NACTVE
	  XX = CORDEN(IG,IND)
          WORK(IG) = CORDEN(IG,NVAR+1)*(XX-EX(IND))**3
	END DO

        CALL NOTINT(VOLSPA,NGRID,NACTVE,WORK,MAXGRD,SK)
	SK=SK/STD(I)**3

	DO IG=1,NACTVE

	  XX = CORDEN(IG,IND)
          WORK(IG) = CORDEN(IG,NVAR+1)*(XX-EX(IND))**4
	END DO


        CALL NOTINT(VOLSPA,NGRID,NACTVE,WORK,MAXGRD,KU)
	KU=KU/STD(I)**4


	ENDIF


	WRITE(*,6092) PAR(IND)
	IF(IPUT .EQ. 1 .AND. IAGAIN .EQ. 0) WRITE(31,6092) PAR(IND)

 6092   FORMAT(/' ',A11,':')

	WRITE(*,6093) XMODE,SK,KU,X025
	WRITE(*,6093) X25,X50,X75,X975
	WRITE(*,6093) SDEST1,SDEST2,SDEST3,SCALINFO
 6093   FORMAT(1X,4(G15.8,2X))

	IF(IPUT .EQ. 1 .AND. IAGAIN .EQ. 0) THEN
          WRITE(31,6093) XMODE,SK,KU,X025
          WRITE(31,6093) X25,X50,X75,X975
          WRITE(31,6093) SDEST1,SDEST2,SDEST3,SCALINFO
	ENDIF


 6090   CONTINUE
	WRITE(*,*)
	IF(IPUT .EQ. 1 .AND. IAGAIN .EQ. 0) WRITE(31,*)

	IF(NVAR .EQ. 3 .OR. NVAR .EQ. 6) THEN
	 IF(IAGAIN .EQ. 1) CALL PAUSE

	ENDIF

	IF(ISCROL .EQ. 1) GO TO 3110


 3050	 WRITE(*,3041)
 3041    FORMAT(//' ENTER 0 TO SEE THE ABOVE VALUES AGAIN;'/
     2' ENTER 1 TO PROCEED: ')
	 READ(*,*,ERR=3050) IA
	 IF(IA .NE. 0 .AND. IA .NE. 1) GO TO 3050

	 IF(IA .EQ. 0) THEN
	  IAGAIN=1
	  GO TO 3000
	 ENDIF


C  STORE THE MEANS INTO CENTER(1,.). CENTER(2,.) AND CENTER(3,.)
C  WERE STORED JUST BELOW THE CALL TO STAT.


 3110	 DO I=1,NVAR
	  CENTER(1,I)=EX(I)

	 END DO


	END

C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C

	SUBROUTINE MAKEDRIV(PATH,NOB,FORFILE,MAXSUB,MAXDIM,MAXGRD,
     1  NUMEQT,MAXOBS,OSName,CopyFile,DeleteFile)
	IMPLICIT REAL*8(A-H,O-Z)
	CHARACTER FORFILE*20,PATH*60,TMPFILE*13,PATHFILE*73,
     1  OSName*20,CopyFile*5,DeleteFile*4

C  THIS ROUTINE, CALLED BY MAIN, CREATES npagdriv.f, WHICH WILL BE
C  THE "MAIN" OF THE WHOLE 'NPAG'. FORFILE, ENTERED BY USER IN
C  MAIN, WILL BE APPENDED TO THE END OF npagdriv.f, SO ONLY ONE .f
C  FILE WILL HAVE TO BE UPLOADED TO THE MAINFRAME (OR PUT INTO THE
C  WORKING COPY AREA OF THE COMPUTER WHICH WILL DO THE ANALYSIS).

C  THIS "MAIN" INCLUDES A PARAMETER STATEMENT WHICH DEFINES
C  MAXSUB (= NSUB), MAXGRD(= NGRID), MAXDIM (= NVAR),
C  MAXACT (= MAXGRD), NUMEQT, AND MAXOBS, AND A DIMENSION STATEMENT
C  WITH ALL ARRAYS WHICH DEPEND OF THESE VALUES. IT THEN HAS THE
C  STATEMENT:
C  CALL NPAG(MAXSUB,MAXGRD,MAXDIM,MAXACT,NUMEQT,MAXOBS,... ),
C  WHERE ALL VARIABLY DIMENSIONED ARRAYS ARE PASSED TO NPAG, WHICH IS
C  NOW THE MAIN MODULE THE "ENGINE".

	MAXACT = MAXGRD

C  CALL FULLNAME WHICH CONVERTS THE FILENAME TO PATHFILE, THE COMPLETE
C  NAME OF THE FILE, WHICH INCLUDES THE PATH (IF THE PATH IS NOT THE

C  CURRENT DIRECTORY).

      TMPFILE = ' '
	TMPFILE = 'npagdriv.f'
	CALL FULLNAME(PATH,TMPFILE,PATHFILE)
	OPEN(31,FILE=PATHFILE,ERR=5475,STATUS='NEW')
	GO TO 5480

 5475   WRITE(*,*)' FILE   npagdriv.f ALREADY EXISTS. IT WILL BE'
	WRITE(*,*)' COPIED TO   npagdriv.bak.   THEN THE npagdriv.f'
  	WRITE(*,*)' FOR THIS RUN WILL BE CREATED.'



        CALL SYSTEM(CopyFile//PATH(1:NOB)//'npagdriv.f '//PATH(1:NOB)
     1//'npagdriv.bak')
	OPEN(31,FILE=PATHFILE)


 5480   write(31,5)
    5   format(/'      USE npag_utils,only:max_pop_rand_varbs') 


        WRITE(31,6)
    6   FORMAT(/'      IMPLICIT REAL*8(A-H,O-Z)')

        WRITE(31,1) MAXSUB,MAXDIM,MAXGRD,MAXACT,NUMEQT,MAXOBS
    1   FORMAT(/'      PARAMETER(MAXSUB = ',I4,', MAXDIM = ',I2,','/
     1'     1  MAXGRD=',I9,', MAXACT = ',I8,','/
     2'     1  NUMEQT=',I2,', MAXOBS = ',I5,')')


	WRITE(31,2)
    2   FORMAT(/'      DIMENSION WORK(MAXGRD),WORKK(MAXGRD),'/
     1'     1  SPXGYJ(MAXGRD),DXI(MAXGRD),PYJGX(MAXSUB,MAXACT),'/
     2'     2  PYJGXX(MAXACT),DENSTOR(MAXGRD,4),'/
     3'     3  EXX(MAXSUB,3,max_pop_rand_varbs),'/
     4'     4  CORDEN(MAXGRD,MAXDIM+1),CORHOLD(MAXGRD,MAXDIM+1),'/
     5'     5  YPREDPOP(MAXSUB,NUMEQT,MAXOBS,3),'/
     6'     6  YPREDPOPT(MAXSUB,NUMEQT,7201,3),'/
     7'     7  YPREDBAY(MAXSUB,NUMEQT,MAXOBS,3),'/
     8'     8  CORDLAST(MAXGRD,MAXDIM+1)')

	WRITE(31,3)
    3   FORMAT(/'      CALL NPAG(MAXSUB,MAXGRD,MAXDIM,MAXACT,'/
     1'     1  NUMEQT,MAXOBS,WORK,WORKK,SPXGYJ,DXI,PYJGX,PYJGXX,'/
     2'     2  DENSTOR,EXX,CORDEN,CORHOLD,YPREDPOP,YPREDPOPT,'/
     3'     3  YPREDBAY,CORDLAST)')

	WRITE(31,4)
    4   FORMAT(/'      STOP'/
     1'      END'/
     2'C'/
     3'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'/
     4'C'/)

	CLOSE(31)


C  APPEND FORFILE TO THE END OF npagdriv.f.

C  IF NOB = 0, THE DIRECTORY OF THIS NPBIG PROGRAM IS THE SAME AS THE
C  DIRECTORY WHERE THE FILES FOR THIS RUN ARE LOCATED. IF NOB > 0,
C  THESE TWO DIRECTORIES ARE DIFFERENT.
C  IF NOB = 0, DO THE 1ST STEP BELOW ONLY; IF NOB > 0, DO ALL 3 STEPS:

C  1. USE SYSTEM COPY COMMAND TO DO THE APPENDING IN THE DIRECTORY WHERE
C     THIS NPBIG PROGRAM RESIDES;
C  2. COPY THE NEW npagdriv.f BACK INTO THE DESIRED DIRECTORY;
C  3. DELETE npagdriv.f FROM THIS NPBIG PROGRAM DIRECTORY.


        IF (INDEX(OSName,"UNIX",.TRUE.).eq.1) THEN
          CALL SYSTEM('cat '//PATH(1:NOB)//'npagdriv.f  '//


     1       PATH(1:NOB)//FORFILE//' >npem.tmp;mv npem.tmp npagdriv.f')
C          CALL SYSTEM('cat npagdriv.f model.for > npem.tmp');
C          CALL SYSTEM('cp npem.tmp npagdriv.f')
C          print *,"conCATenated npagdriv.f"
        ELSE IF (INDEX(OSName,"DOS",.TRUE.).eq.1) THEN
          CALL SYSTEM(CopyFile//PATH(1:NOB)//'npagdriv.f + '//
     1       PATH(1:NOB)//FORFILE)

        ENDIF
        print *,OSName

	IF(NOB .NE. 0) THEN

	 CALL SYSTEM(CopyFile//' npagdriv.f '//PATH(1:NOB)//'npagdriv.f')
C
C Yamada 5/10/2010
C If the user specifies the current working directory verbatim, rather than
C responding w/"0", then NOB is > 0 and this block is called ... the result is
C that npagdriv.f gets erased! So I want to leave the file in the directory.
C
C        CALL SYSTEM(DeleteFile//' npagdriv.f')
C
	ENDIF


	RETURN

	END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
      SUBROUTINE TOPFIL(NDRUG,AF,NSUB,NVAR,PAR,NOFIX,PARFIX,NRANFIX,
     1 PARRANFIX)

	IMPLICIT REAL*8(A-H,O-Z)
      DIMENSION AF(7)
	CHARACTER PAR(30)*11,PARFIX(20)*11,PARRANFIX(20)*11

C  THIS ROUTINE PRINTS THE TOP PART OF A FILE. IT IS CALLED BY
C  SUBROUTINE PREVRUN, IN THE OPTION 7 PART OF THE CODE.

C  INPUT ARE:

C  NSUB = NO. OF SUBJECTS.
C  NVAR = NO. OF RANDOM VARIABLES.
C  PAR(I) = NAME OF VARIABLE I, I=1,NVAR.
C  NOFIX = NO. OF PARAMETERS WHOSE FIXED VALUES WERE SET BY THE USER.
C  PARFIX(I) = NAME OF FIXED PARAMETER I, I=1,NOFIX.
C  NRANFIX = NO. OF PARAMETERS WHOSE RANFIX VALUES WERE ESTIMATED.
C  PARRANFIX(I) = NAME OF RANFIX PARAMETER I, I=1,NRANFIX.

C  NDRUG = NO. OF DRUGS. NOTE THAT IF NDRUG = -1, IT MEANS THAT THE
C   NO. OF DRUGS IS UNKNOWN, BUT THAT ALL AF VALUES ARE THE SAME, AND
C   EQUAL TO AF(1) (SEE CODE IN SUBROUTINE PREVRUN).
C  IF NDRUG .NE. -1, THEN
C   AF(I), I=1,NDRUG = ACTIVE (SALT) FRACTION FOR THE DRUG FOR DRUG I.

C  OUTPUT ARE:

C  TOP OF AN OUTPUT FILE.
C  SEE THE CALLING ROUTINE FOR WHAT ELSE IS INCLUDED IN THIS FILE.

C  WRITE TO THIS FILE: AF, RANDOM VARIABLE NAMES, AND THE FIXED
C  PARAMETER NAMES.


        IF(NDRUG .EQ. -1) WRITE(33,1) AF(1)
    1   FORMAT(/' ALL DRUGS IN THE ANALYSIS HAD THE SAME AF, ',G12.6)


        IF(NDRUG .NE. -1) THEN
         WRITE(33,6) NDRUG
    6    FORMAT(/' THE AF VALUES FOR THE ',I2,' DRUG(S) FOLLOW, ONE TO'/
     1' A LINE: ')
         DO I = 1,NDRUG
          WRITE(33,*) AF(I)
         END DO
        ENDIF

        WRITE(33,7) NVAR
    7   FORMAT(/' THERE ARE ',I2,' RANDOM VARIABLES. THEIR NAMES ARE: ')


	DO I=1,NVAR
	 WRITE(33,2) PAR(I)
	END DO

    2   FORMAT(3X,A11)

	WRITE(33,3) NOFIX
    3   FORMAT(/' THE NUMBER OF FIXED PARAMETER(S) IS ',I2,/
     1' ITS (THEIR) NAME(S) IS (ARE): ')

	DO I=1,NOFIX
	 WRITE(33,2) PARFIX(I)
	END DO

      WRITE(33,13) NRANFIX
   13 FORMAT(/' THE NUMBER OF RANFIX PARAMETER(S) IS ',I2,/
     1' ITS (THEIR) NAME(S) IS (ARE): ')

      DO I=1,NRANFIX
	 WRITE(33,2) PARRANFIX(I)
	END DO


	WRITE(33,4) NSUB
    4   FORMAT(/' EACH OF THE FOLLOWING ',I4,' LINES GIVES THE VALUES'/
     1' FOR ONE SUBJECT ... PROB., RANDOM VALUES, FIXED VALUES, AND '/
     2' RANFIX ESTIMATES, IN ORDER: ')

	RETURN
	END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C

	SUBROUTINE GETNUMEQ(PATH,NOB,ICALL,IFORMT,PREFIX,EXT,BLOCKPAT,
     1   NUMEQT,NDRUG,MAXSUB,MAXNUMEQ)

	IMPLICIT REAL*8(A-H,O-Z)
	DIMENSION C0P(MAXNUMEQ),C1P(MAXNUMEQ),C2P(MAXNUMEQ),C3P(MAXNUMEQ)

	CHARACTER PREFIX*5,EXT*3,READLINE*1000,PATNEW*20,PATH*60,
     1   TMPFILE*13,PATHFIL2*73,BLOCKPAT*20,CODEPAT*15,ERRFIL*20

      COMMON/ERROR/ERRFIL
C  COMMON/ERROR/ IS SUPPLIED TO ALL THE ROUTINES WHICH COULD WRITE TO

C  ERRFIL. 



C  NOTE THAT IF ICALL = 1, THIS CALL IS FROM MAIN;
C                       0, THIS CALL IS FROM EXTRAOPT OR VERIF1.
C  THE ONLY DIFFERENCE IS THAT IF ICALL = 0, WRITE(*,4) IS NOT
C  EXECUTED BELOW.

C  THIS SUBROUTINE READS THE 1ST PATIENT DATA FILE (IF IFORMT = 1) OR
C  THE BLOCK FORMAT FILE BLOCKPAT (IF IFORMT = 3) TO FIND THE NO. OF
C  OUTPUT EQUATIONS (NUMEQT), AND THE NO. OF DRUGS (NDRUG).

    2   FORMAT(A20)

C  PRINT MESSAGE TO THE USER THAT IF HE CHANGES HIS PATIENT FILENAMES
C  IN SUBROUTINE VERIF1, HE MUST MAKE SURE THAT THE NEW PATIENT FILES
C  HAVE THE SAME NO. OF OUTPUT EQUATIONS AS THE ORIGINAL PATIENT FILES.
C  THIS IS N/A IF THE CALL IS FROM PREVRUN (ICALL=0).

	IF(ICALL .EQ. 1) THEN

        IF(IFORMT .EQ. 1) WRITE(*,4)
    4   FORMAT(//' ONE OF YOUR PATIENT FILES WILL NOW BE OPENED TO'/
     1' READ THE NUMBER OF OUTPUT EQUATIONS, AND THE NUMBER OF DRUGS.'/
     2' LATER, YOU WILL HAVE THE OPTION TO CHANGE YOUR PATIENT '/
     3' FILENAMES. IF YOU DO THIS, MAKE SURE THAT THE NEW SET OF FILES'/
     4' HAVE THE SAME NUMBER OF OUTPUT EQUATIONS AND THE SAME NUMBER'/
     5' OF DRUGS.'//)

	 IF(IFORMT .EQ. 3) WRITE(*,14) BLOCKPAT
   14    FORMAT(//' YOUR BLOCK FORMAT PATIENT FILE, ',A20,' WILL NOW'/
     1' BE OPENED TO READ THE NUMBER OF OUTPUT EQUATIONS, AND THE '/
     2' NUMBER OF DRUGS. LATER YOU WILL HAVE THE OPTION TO CHANGE THE'/
     3' PATIENT INFORMATION. IF YOU DO THIS, MAKE SURE THAT THE NEW'/
     4' PATIENT INFORMATION HAS THE SAME NUMBER OF OUTPUT EQUATIONS'/
     5' AND THE SAME NUMBER OF DRUGS.'//)


	ENDIF


	IF(IFORMT .EQ. 1) THEN


	 PATNEW=PREFIX//'001'//'.'//EXT

C  CALL FULLNAME WHICH CONVERTS THE FILENAME TO PATHFIL2, THE COMPLETE
C  NAME OF THE FILE, WHICH INCLUDES THE PATH (IF THE PATH IS NOT THE
C  CURRENT DIRECTORY).


       TMPFILE = ' '
	 TMPFILE = PATNEW
	 CALL FULLNAME(PATH,TMPFILE,PATHFIL2)

C  AT THIS POINT, THE FIRST PATIENT FILENAME, IN WORKING COPY FORMAT,
C  IS PATHFIL2. OPEN THIS FILE AND READ NUMEQT.

	 OPEN(21,FILE=PATHFIL2)

C  NOTE THAT NUMEQT IS ON THE LINE WITH "NO. OF TOTAL OUTPUT EQUATIONS"
C  IN COLUMNS 12:40. IF NO LINE HAS THESE WORDS, THIS PATIENT DATA
C  FILE IS NOT A NEW-STYLE WORKING COPY FILE FROM ANDREAS' NEW
C  BOXES PROGRAM.

    3    FORMAT(A1000)
   35	 READ(21,3,IOSTAT=IEND) READLINE


        IF(IEND .LT. 0) THEN

         WRITE(*,58) PATHFIL2
   58    FORMAT(//' PATIENT FILE '/
     1'    ',A73/
     2' IS NOT AN ACCEPTABLE WORKING COPY FILE. SUCH A FILE MUST HAVE '/
     2' A LINE WITH "NO. OF DRUGS" IN COLUMNS 12:23.'//
     3' THE PROGRAM STOPS. '//)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,58) PATHFIL2 
        CLOSE(42)

C???DEBUG
	WRITE(*,*)' IN GETNUMEQ; PREFIX IS ',PREFIX

         CALL PAUSE
         STOP

        ENDIF

        IF(READLINE(12:23) .NE. 'NO. OF DRUGS') GO TO 35


        BACKSPACE(21)
   13   FORMAT(T2,I5)
        READ(21,13) NDRUG


   45	  READ(21,3,IOSTAT=IEND) READLINE

        IF(IEND .LT. 0) THEN

         WRITE(*,57) PATHFIL2
   57    FORMAT(//' PATIENT FILE '/
     1'    ',A73/
     2' IS NOT AN ACCEPTABLE WORKING COPY FILE. SUCH A FILE MUST HAVE '/
     2' A LINE WITH "NO. OF TOTAL OUTPUT EQUATIONS" IN COLUMNS 12:40.'//
     3' THE PROGRAM STOPS. '//)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,57) PATHFIL2 
        CLOSE(42)

         CALL PAUSE
         STOP

        ENDIF

        IF(READLINE(12:40) .NE. 'NO. OF TOTAL OUTPUT EQUATIONS') 
     1   GO TO 45
        BACKSPACE(21)
        READ(21,13) NUMEQT
        CLOSE(21)

       
        ENDIF

C  THE ABOVE ENDIF IS FOR THE   IF(IFORMT .EQ. 1)  CONDITION.


	IF(IFORMT .EQ. 3) THEN

C  CALL FULLNAME WHICH CONVERTS "BLOCKPAT" TO PATHFIL2, THE COMPLETE

C  NAME OF THE FILE, WHICH INCLUDES THE PATH (IF THE PATH IS NOT THE
C  CURRENT DIRECTORY).

       TMPFILE = ' '
	 TMPFILE = BLOCKPAT
	 CALL FULLNAME(PATH,TMPFILE,PATHFIL2)
	 OPEN(87,FILE=PATHFIL2,STATUS='OLD')

C  AS OF NPAG104.FOR, BEFORE CALLING NEWCSV, MUST CALL CONVERTCSV,
C  WHICH CONVERTS A "EUROPEAN" .CSV FILE TO THE TYPICAL "AMERICAN"
C  VERSION. IF THE .CSV FILE IS ALREADY IN THE "AMERICAN" FORMAT,
C  CONVERTCSV SIMPLY REWRITES FILE 87 TO SCRATCH FILE 77. NOTE THAT
C  NEWCSV CONVERTS FILE 77 TO FILE 67.

        CALL CONVERTCSV

	 ICODEPAT = 0

 7126  FORMAT(A15)

	 READ(77,7126) CODEPAT
	 IF(CODEPAT .EQ. '"POPDATA APR_11') ICODEPAT = 1
	 IF(CODEPAT(1:14) .EQ. 'POPDATA APR_11') ICODEPAT = 1

       IF(CODEPAT .EQ. '"POPDATA DEC_11') ICODEPAT = 1
       IF(CODEPAT(1:14) .EQ. 'POPDATA DEC_11') ICODEPAT = 1



	 IF(ICODEPAT .EQ. 0) THEN

	  WRITE(*,3131)
 3131     FORMAT(//' YOUR PATIENT DATA BLOCK FORMAT FILE IS NOT FROM '/
     1' THE ALLOWABLE SET OF SUCH FILES.'//
     2' A PATIENT DATA BLOCK FORMAT FILE MUST HAVE "POPDATA XXX_XX IN'/
     3' COLUMNS 1 THROUGH 15 ON LINE 1, WHERE  XXX_XX  IS APR_11 OR A '/
     4' MORE RECENT DATE.'//)
	  WRITE(*,*)' THE PROGRAM STOPS.'

        OPEN(42,FILE=ERRFIL)
         WRITE(42,3131) 
         WRITE(42,*)' THE PROGRAM STOPS.'
        CLOSE(42)

	  CALL PAUSE
	  STOP

 	 ENDIF

C  CALL SUBROUTINE READBLOCK TO RETURN NUMEQT, THE NO. OF OUTPUT EQS,
C  AND NDRUG, THE NO. OF DRUGS, IN THE BLOCK PATIENT DATA SET. NOTE THAT
C  THE 1ST ARGUMENT TO READBLOCK --> CALL IS FROM GETNUMEQ.


C  CALL SUBROUTINE NEWCSV WHICH CONVERTS THE .CSV FILE IN FILE 77 TO
C  A NEW .CSV FILE IN FILE 67, WITH ALL MISSING VALUE DOTS CHANGED TO
C  n's. THEN CALL CSVCHANGE WHICH CHANGES .csv FILES WITH CODE OF
C  POPDATA DEC_11 (I.E., THOSE WITH 2 EXTRA COLUMNS FOR ADDL AND II)
C  TO EQUIVALENT .csv FILES WITH CODE OF POPDATA APR_11 (THOSE WITHOUT
C  THE TWO EXTRA COLUMNS). CSVCHANGE READS FILE 67, AND WRITES THE 

C  INFORMATION TO SCRATCH FILE 66. NOTE THAT IF THE .csv FILE READ IN
C  ALREADY IS THE OLDER VERSION (WITH CODE POPDATA APR_11), CSVCHANGE

C  SIMPLY REWRITES IT TO FILE 66, WHICH IS THEN READ BY SUBROUTINE
C  READBLOCK.

       OPEN(67)
       REWIND(77)


C       WRITE(*,1234)
C1234   FORMAT(/' IF YOU HAVE A LARGE DATA SET, THERE COULD BE A LONG'/
C    1' DELAY (SEVERAL SECONDS TO A MINUTE OR MORE) BEFORE YOU SEE AN'/
C    2' INDICATION THAT THE PROGRAM IS EXAMINING YOUR PATIENT DATA. '//
C    3' THE PROGRAM HAS NOT "HUNG". THIS MIGHT BE A GOOD TIME FOR SOME'/
C    4' QUIET INTROSPECTION ... ')

       CALL NEWCSV
       CALL CSVCHANGE 
       REWIND(66)
       CALL READBLOCK(2,NSUBR,MAXSUB,NUMEQT,NDRUG,PATH,C0P,C1P,C2P,C3P,
     1  MAXNUMEQ)


       CLOSE(66)


	ENDIF

C  THE ABOVE ENDIF IS FOR THE   IF(IFORMT .EQ. 3)  CONDITION.

	RETURN
	END

C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
      SUBROUTINE USECS(IEQ,NCSTORE,GENCOEF,C0,C1,C2,C3,MAXNUMEQ)

	IMPLICIT REAL*8(A-H,O-Z)
	DIMENSION GENCOEF(MAXNUMEQ,5,4),NCSTORE(MAXNUMEQ)

C  THIS ROUTINE, CALLED BY PUTASS, OBTAINS ASSAY COEFFICIENTS,
C  [C0,C1,C2,C3] FROM THE USER TO PUT INTO THE CURRENT PATIENT'S
C  DATA FILE, FOR OUTPUT EQ. IEQ. NCSTORE(IEQ) IS THE CURRENT NO. OF
C  ROWS OF GENCOEF(IEQ,.,.) WHICH HAVE PREVIOUS STORED SETS OF C'S. THE
C  USER CAN PICK FROM THESE STORED SETS OR SELECT A NEW SET. THE USER
C  CAN STORE A NEW SET INTO GENCOEF, UP TO A LIMIT OF NCSTORE(IEQ) =
C  5 SETS.


C  IF NCSTORE(IEQ) = 0 --> NO EXTRA SETS OF ASSAY COEFFICIENTS HAVE BEEN
C  SAVED FROM PREVIOUS SUBJECTS. IN THIS CASE, SET IOLD = 0, WHICH MEANS
C  THE USER WILL HAVE TO ENTER 4 ASSAY COEFFS. BELOW.

	IF(NCSTORE(IEQ) .EQ. 0) IOLD = 0


	IF(NCSTORE(IEQ) .GT. 0) THEN

   35	 WRITE(*,24)

   24    FORMAT(' YOU MAY USE A PREVIOUSLY STORED SET OF COEFFICIENTS'/
     1' OR YOU MAY ENTER ANOTHER SET NOW.'/)

	  DO I=1,NCSTORE(IEQ)
	   WRITE(*,23) I, (GENCOEF(IEQ,I,J),J=1,4)
	  END DO

   23    FORMAT(' ','ENTER ',I1,' TO USE: ',4(G12.6,1X))


	 WRITE(*,26)

   26    FORMAT(/' ENTER 0 TO ENTER A NEW SET OF COEFFICIENTS: ')

	 READ(*,*,ERR=35) IOLD
	 IF(IOLD .LT. 0 .OR. IOLD .GT. NCSTORE(IEQ)) GO TO 35


	ENDIF

C  ABOVE ENDIF IS FOR THE  IF(NCSTORE9IEQ) .GT. 0)  CONDITION.


	IF(IOLD .GT. 0) THEN
	 C0 = GENCOEF(IEQ,IOLD,1)
	 C1 = GENCOEF(IEQ,IOLD,2)
	 C2 = GENCOEF(IEQ,IOLD,3)

	 C3 = GENCOEF(IEQ,IOLD,4)
	ENDIF

	IF(IOLD .EQ. 0) THEN

   30	 WRITE(*,21)
   21    FORMAT(' ENTER THE DESIRED ASSAY COEFFICIENTS, [C0,C1,C2,C3]'/

     1' FOR THIS FILE (RECALL ASSAY SD = C0+C1*Y+C2*Y**2+C3*Y**3): ')
	 READ(*,*,ERR=30) C0,C1,C2,C3


	 IF(NCSTORE(IEQ) .EQ. 5) WRITE(*,27) IEQ
   27    FORMAT(/' FOR OUTPUT EQUATION ',I1,' YOU HAVE ALREADY STORED'/
     1' 5 SETS OF ADDITIONAL COEFFICIENTS FOR POSSIBLE USE WITH '/
     2' SUBSEQUENT PATIENT DATA FILES. THESE COEFFICIENTS CANNOT BE '/

     3' STORED.'/)
	 IF(NCSTORE(IEQ) .EQ. 5) CALL PAUSE

	 IF(NCSTORE(IEQ) .LT. 5) THEN

   45	  WRITE(*,28) IEQ
   28     FORMAT(/' ENTER 1 TO STORE THESE COEFFS. FOR POSSIBLE USE'/
     1' 	WITH SUBSEQUENT PATIENT DATA FILES (FOR EQ. ',I1,'); '/


     2' ENTER 0 IF YOU DO NOT WANT TO SAVE THESE COEFFICIENTS: ')
	  READ(*,*,ERR=45) ISTORE
	  IF(ISTORE .NE. 0 .AND. ISTORE .NE. 1) GO TO 45

	  IF(ISTORE .EQ. 1) THEN
	   NCSTORE(IEQ) = NCSTORE(IEQ) + 1
	   GENCOEF(IEQ,NCSTORE(IEQ),1) = C0
	   GENCOEF(IEQ,NCSTORE(IEQ),2) = C1
	   GENCOEF(IEQ,NCSTORE(IEQ),3) = C2
	   GENCOEF(IEQ,NCSTORE(IEQ),4) = C3
	  ENDIF

	 ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(NCSTORE(IEQ) .LT. 5)  CONDITION.


	ENDIF

C  ABOVE ENDIF IS FOR THE  IF(IOLD .EQ. 0)  CONDITION.


	RETURN
	END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
	SUBROUTINE GETPATH(PATH,NOB,OSName)

C  THIS ROUTINE OBTAINS FROM THE USER THE PATH WHERE THE INPUT FILES
C  ARE LOCATED (AND WHERE THE OUTPUT FILES WILL BE SENT). NOTE THAT
C  PATH RETURNS AS THE PATH WITH A TRAILING BACKSLASH.

C  NOB RETURNS AS THE NO. OF THE LAST NON-BLANK ENTRY IN PATH.


	CHARACTER PATH*60,OSName*20,DIRIN*62,cwd*255
        INTEGER path_len
        LOGICAL dir_exists
        LOGICAL dup_dir


   10	WRITE(*,1)
    1   FORMAT(/' ENTER 1 IF THE FILES FOR THIS RUN ARE IN THE CURRENT D
     1IRECTORY; '/
     1' ENTER 0 OTHERWISE: ')
	READ(*,*,ERR=10) IPATH
	IF(IPATH .NE. 0 .AND. IPATH .NE. 1) GO TO 10

	IF(IPATH .EQ. 1) PATH = ' '
	NOB = 0

C  IF THE USER ENTERS A NON-NULL PATH BELOW, NOB WILL BE THE NO. OF
C  CHARACTERS IN THE PATH. IF HE ENTERS NOTHING, NOB STAYS 0, WHICH IS
C  THE CORRECT NO. OF CHARACTERS IN A NULL PATH.

	IF(IPATH .EQ. 0) THEN
          CALL getcwd(cwd)
          IF (INDEX(OSName,"UNIX",.TRUE.).eq.1) THEN
             WRITE(*,"(A14,A72)") "Your pwd is:",TRIM(cwd)
C             CALL SYSTEM('pwd')
             WRITE(*,4)
          ELSE IF (INDEX(OSName,"DOS",.TRUE.).eq.1) THEN
             WRITE(*,3)
          ENDIF
    4    FORMAT(/' Enter the PATH, begining from root, e.g. /Users/UserN
     1ame/DirName,'/

     1' of your input files. Note that strlen(PATH) must be < 60 char.'/

     2' ENTER THE PATH NOW: ')
    3    FORMAT(/' ENTER THE LOCATION (PATH) OF YOUR INPUT FILES. NOTE'/
     1' THAT THE PATH IS LIMITED TO 60 CHARACTERS AND THAT EACH SUB-DIRE
     2CTORY'/
     3' CAN HAVE AT MOST 8 CHARACTERS (E.G, INSTEAD OF " \DIRECTORY ", U
     4SE '/
     5' THE DOS-EQUIVALENT NAME, WHICH MIGHT BE " \DIRECT~1 "). '//
     6' ENTER THE PATH NOW: ')
   20	 READ(*,2) PATH
    2    FORMAT(A60)


C  IF THE USER DIDN'T END HIS PATH WITH A '\', PUT ONE IN FOR PATH.

C  NOTE THAT IF THE USER ENTERED A BLANK PATH, IT WILL BE ASSUMED THAT
C  HE WANTS THE CURRENT (WORKING) DIRECTORY.

C This block is the original code for Win7 machines
C	 DO I=1,60

C	  J = 60 + 1 - I
C	  IF(PATH(J:J) .NE. ' ') THEN
C	   NOB = J
C	   IF(PATH(J:J) .NE. '\') THEN
C	    PATH(J+1:J+1) = '\'

C	    NOB = J+1
C	   ENDIF
C	   RETURN
C	  ENDIF
C	 END DO
C
C Following code replaces the Win 7 block directly above.
C
C Yamada 5/5/2010 ... add UNIX forwardslash instead of DOS backslash
C                     according to OSName commadn argument.
C Yamada 5/10/2010 ... replace RETURN w/EXIT; and then check for dir
C                     existance
C Yamada 5/12/2010 ... set DO I=1,59 ... instead of 60

         DO I=1,59
          J = 59 + 1 - I
          IF(PATH(J:J) .NE. ' ') THEN
            NOB = J
            IF (INDEX(OSName,"UNIX",.TRUE.).eq.1) THEN
              IF(PATH(J:J) .NE. '/') THEN
                PATH(J+1:J+1) = '/'
                NOB = J+1
              ENDIF
            ELSE IF (INDEX(OSName,"DOS",.TRUE.).eq.1) THEN
              IF(PATH(J:J) .NE. '\') THEN
                PATH(J+1:J+1) = '\'
                NOB = J+1
              ENDIF
            ENDIF
C           RETURN
            EXIT
          ENDIF
         END DO

C
C Yamada 11/5/2010 ... I am including the following UNIX specific code
C w/in the current IF block.
C
C Following ENDIF ends IF(PATH .EQ. 0 ) THEN
C
C        ENDIF

        IF (INDEX(OSName,"UNIX",.TRUE.).eq.1) THEN
          DIRIN=PATH(1:NOB)//'.'
          INQUIRE(FILE=DIRIN,EXIST=dir_exists)
C          WRITE(*,"(A75)") "Checking for FILE: "//DIRIN
          IF (dir_exists.eqv..FALSE.) THEN
             WRITE(*,"(A72)") "Requested PATH does not exist: "//PATH
             WRITE(*,"(A17)") "Enter PATH again:"
             PATH = ' '
             GO TO 20
          ENDIF
C       Now check if entered PATH == cwd
          dup_dir=.TRUE.
          path_len = LEN_TRIM(PATH)-1
          DO I=1,path_len
            IF (PATH(I:I) .NE. cwd(I:I)) THEN
              dup_dir=.FALSE.
              EXIT
            ENDIF
          END DO
          IF (dup_dir .eqv. .TRUE.) THEN
            write(*,*) "You have input the current working directory"
            DO I=1,60
              PATH(I:I)=' '
            END DO
            NOB=0
          ENDIF
        ENDIF
C
C END of Yamada 5/12/2010 edit to GETPATH()
C

C
C Yamada 11/5/2010
C  This ENDIF was moved here from above so that the MacOSX correction
C  can be included w/in the PATH declaration.

C
C Following ENDIF ends IF(PATH .EQ. 0 ) THEN
C
        ENDIF
	RETURN
	END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
	SUBROUTINE FULLNAME(PATH,FILE,FILE2)


C  FULLNAME CONVERTS FILE TO FILE2, THE COMPLETE NAME OF
C  THE FILE, WHICH INCLUDES THE PATH (IF THE PATH IS NOT THE CURRENT
C  DIRECTORY).

	CHARACTER PATH*60,FILE2*73,FILE*13,FILE1*73

C  INITIALIZE FILE1 AND FILE2 AS ALL BLANKS, IN CASE THE USER IS
C  RE-ENTERING HIS FILENAME (SO THERE WON'T BE SOMETHING ALREADY IN
C  THESE FILENAMES).

	FILE2 = ' '
	FILE1 = ' '
	FILE1 = PATH//FILE


C  ESTABLISH FILE2 AS FILE1 WITHOUT ANY BLANKS.

	J = 0
        DO I=1,73
	 IF(FILE1(I:I) .NE. ' ') THEN
	  J= J+1

	  FILE2(J:J) = FILE1(I:I)
	 ENDIF
	END DO

	RETURN
	END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
        SUBROUTINE GETCOVAR(PATH,PATFIL,NCOV,DESCR)
        IMPLICIT REAL*8(A-H,O-Z)
        CHARACTER PATFIL*20,READLINE*1000,DESCR(26)*20,PATH*60,
     1   TMPFILE*13,PATHFILE*73

C  THIS ROUTINE IS CALLED BY SUBROUTINE PREVRUN TO OBTAIN, FROM THE
C  INPUT PATIENT FILE, PATFIL (HAVING PATH), THE NO. OF COVARIATES
C  (NCOV), AND THEIR NAMES (DESCR(I),I=1,NCOV).

    2   FORMAT(A20)
   33   FORMAT(A1000)

C  OPEN PATFIL, AND ESTABLISH NCOV (THE NO. OF COVARIATES), AND
C  DESCR(I), I=1,NCOV (THE COVARIATE NAMES).

C  CALL FULLNAME WHICH CONVERTS THE FILENAME TO PATHFILE, THE COMPLETE
C  NAME OF THE FILE, WHICH INCLUDES THE PATH (IF THE PATH IS NOT THE
C  CURRENT DIRECTORY).

        TMPFILE = ' '
	TMPFILE = PATFIL
	CALL FULLNAME(PATH,TMPFILE,PATHFILE)
	OPEN(21,FILE=PATHFILE)

C  VERIFY THAT PATFIL IS A 'CURRENT' TYPE WORKING COPY-LIKE FILE (I.E.,
C  CREATED BY CONVRTI.FOR OR LATER VERSION). IF NOT, IT DOESN'T HAVE ANY
C  EXTRA COVARIATE INFO, OR EVEN AGE, SEX, HEIGHT, ETHNICITY FLAG,
C  AND SO IT IS A WASTE TO USE THIS PROGRAM WITH ITS EXPANDED MENU
C  ON FILES WHICH (BECAUSE THEY HAVE NO EXTRA COVARIATES/DESCRIPTORS)
C  CAN'T POSSIBLY TAKE ADVANTAGE OF IT.

C  AS OF NPBIG11.FOR, THE WORKING COPY FILES REQUIRED ARE THE NEWEST
C  TYPE (FROM THE NEW BOXES PROGRAM BY ANDREAS). BUT THE PROGRAM WOULD
C  NOT HAVE GOTTEN TO THIS POINT (I.E., PAST SUBROUTINE STACK, CALLED
C  BY SUBROUTINE PREVRUN) IF THE FILES WERE NOT THE CORRECT TYPE. SO
C  NO CHECKING OF THE FILE FORMAT IS REQUIRED HERE.


C  THE NO. OF ADDITIONAL COVARIATES IS ON THE LINE HAVING
C  "NO. OF ADDITIONAL COVARIATES" STARTING IN ENTRY 12.



   10	READ(21,33) READLINE
	IF(READLINE(12:28) .NE. 'NO. OF ADDITIONAL') GO TO 10
	BACKSPACE(21)
    3   FORMAT(T2,I5)
        READ(21,3) NADD


C  THE TOTAL NO. OF COVARIATES WILL BE 4 + NADD, SINCE THERE WILL
C  ALWAYS BE THE STANDARD 4 COVARIATES (AGE, SEX, HEIGHT,

C  ETHNICITY FLAG), IN ADDITION TO THE EXTRA ONES.

	NCOV = 4 + NADD



C  READ THE 1ST NCOV - 4 COVARIATE NAMES FROM BELOW THE LINE HAVING
C  "COVARIATE NAMES" STARTING IN COLUMN 2. IF NCOV = 4, NO NAMES
C  WILL BE READ.


   20	READ(21,33) READLINE
	IF(READLINE(2:16) .NE. 'COVARIATE NAMES') GO TO 20



        IF(NCOV .GT. 4) THEN


         DO J = 1,NCOV-4

          READ(27,33) READLINE

C  FOR THIS COVARIATE, ESTABLISH DESCR(J) AS THE PORTION OF THE

C  CURRENT READLINE UP TO THE  FIRST SPACE, WHICH WILL BE ASSUMED TO BE
C  THE END OF THE COV. NAME. IN CASE THERE IS A SPACE OR TWO AT THE
C  BEGINNING OF READLINE FOR SOME REASON, START CHECKING FOR SPACES AT
C  ENTRY 3.

          DO I = 3,20
           IF(READLINE(I:I) .EQ. ' ') GO TO 30
          END DO

   30     DESCR(J) = READLINE(1:I-1)

         END DO

        ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(NCOV .GT. 4)  CONDITION.



     	  DESCR(NCOV-3) = 'AGE'
        DESCR(NCOV-2) = 'SEX'
        DESCR(NCOV-1) = 'HEIGHT'
        DESCR(NCOV) = 'ETHNICITY FLAG'

        CLOSE(21)

	RETURN
	END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
	SUBROUTINE PRNCOVAR(NCOV,DESCR,NVAR,PAR,ClearScreen)
	CHARACTER DESCR(26)*20,PAR(30)*11,ClearScreen*6

C THIS SUBROUTINE IS CALLED BY PREVRUN TO PRINT OUT THE
C COVARIATES AVAILABLE IN THE USER'S PATIENT DATA FILES, ALONG WITH THE
C RANDOM VARIABLES USED IN THE CURRENT RUN.

C ILINES IS THE RUNNING NO. OF LINES PRINTED TO THE SCREEN. PAUSE
C EVERY 18 LINES (ILINES IS THE RUNNING CURRENT TOTAL OF LINES WHICH
C HAVE GONE TO THE SCREEN SINCE THE LAST PAUSE).

C CLEAR THE SCREEN BEFORE EACH PRINTOUT, FOR CLARITY.

	CALL SYSTEM(ClearScreen)

	WRITE(*,7133)
 7133   FORMAT(/' THE COVARIATES AVAILABLE IN YOUR PATIENT DATA FILES'/

     1' ARE THE FOLLOWING:'//
     2'   NO.   COVARIATE')

	ILINES = 4


        IF(NCOV .GT. 4) THEN
         DO I=1,NCOV-4
          WRITE(*,7134) I,DESCR(I)
          ILINES = ILINES + 1
          IF( ILINES/18 .EQ. 1.0*ILINES/18) CALL PAUSE
         END DO
        ENDIF


 7134   FORMAT('   ',I2,'   ',A20)


C  NOTE THAT THE LAST 4 ENTRIES IN DESCR() ARE , AGE, SEX,
C  HEIGHT, AND ETHNICITY FLAG. THEY'RE PRINTED BELOW WITH EXTRA INFO.

C  FOR SEX AND ETHNICITY FLAG.

	WRITE(*,7136) NCOV-3
 7136   FORMAT('   ',I2,'   AGE')
	ILINES = ILINES + 1
	IF( ILINES/18 .EQ. 1.0*ILINES/18) CALL PAUSE
	WRITE(*,7137) NCOV-2
 7137   FORMAT('   ',I2,'   SEX -- 1 (MALE) OR 2 (FEMALE)')
	ILINES = ILINES + 1
	IF( ILINES/18 .EQ. 1.0*ILINES/18) CALL PAUSE
	WRITE(*,7138) NCOV-1
 7138   FORMAT('   ',I2,'   HEIGHT')
	ILINES = ILINES + 1
	IF( ILINES/18 .EQ. 1.0*ILINES/18) CALL PAUSE
	WRITE(*,7139) NCOV
 7139   FORMAT('   ',I2,'   ETHNICITY FLAG -- 1,...,9 FOR, RESPECTIVELY
     1,'/
     4'           NOT KNOWN, CAUCASIAN, BLACK, HISPANIC, NATIVE AMER.'/
     5'           INDIAN, ASIAN, MIDDLE EASTERN, OTHER.')


	WRITE(*,6133)
 6133   FORMAT(/' THE AVAILABLE RANDOM VARIABLES ARE THE FOLLOWING:'//
     2'   NO.   R.V.'/)

	ILINES = 4

	DO I=1,NVAR
   	 WRITE(*,6134) NCOV+I,PAR(I)
	 ILINES = ILINES + 1
	 IF( ILINES/18 .EQ. 1.0*ILINES/18) CALL PAUSE
	END DO
 6134   FORMAT('   ',I2,'   ',A11)



	RETURN
	END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
	SUBROUTINE GETCOVAL(NUMEQT,JSUB,COVAL,NCOV)

C  GETCOVAL IS CALLED BY MAIN TO READ THE PORTION OF FILE 27 WHICH

C  APPLIES TO THE SUBJECT UNDER CONSIDERATION. THE 'POINTER' FOR FILE 27

C  IS IN THE PROPER POSITION TO BEGIN READING THE INFO FOR THE DESIRED
C  SUBJECT.

        IMPLICIT REAL*8(A-H,O-Z)
        DIMENSION COVAL(999,26)
	CHARACTER SEX*1,READLINE*1000

C  INPUT IS: FILE 27, WHICH IS POSITIONED AT THE BEGINNING OF
C  THE INFO FOR THE SUBJECT DESIRED.


C  OUTPUT ARE:


C  COVAL(JSUB,J),J=1,NCOV = THE VALUES ASSOCIATED WITH EACH OF THE
C    NCOV COVARIATES. NOTE THAT THE LAST 4 ARE ALWAYS AGE, ISEX, HEIGHT,
C    AND ETHNICITY FLAG, WHICH HAVE FIXED VALUES AT THE TOP OF THE FILE.
C    ALSO NOTE THAT FOR ANY OF THE 1ST NCOV-4 COVARIATES, A VALUE OF
C    -99 MEANS THAT VALUE WAS UNAVAILABLE.

C  AGE, SEX, HEIGHT, AND ETHNICITY FLAG ARE ON LINES 8-11.

	DO I=1,7
	 READ(27,*)
	END DO

	READ(27,*) COVAL(JSUB,NCOV-3)
	READ(27,2) SEX
    2   FORMAT(A1)
	COVAL(JSUB,NCOV-2) = 1
	IF(SEX .EQ. 'F') COVAL(JSUB,NCOV-2) = 2
	READ(27,*) COVAL(JSUB,NCOV-1)
	READ(27,*) COVAL(JSUB,NCOV)

C  SKIP TO THE COVARIATE (1ST, LAST, AND MEAN) INFO NEAR BOTTOM OF FILE.

    1   FORMAT(A1000)
   20	READ(27,1) READLINE
	IF(READLINE(2:27) .NE. 'COVARIATE NAMES AND VALUES') GO TO 20


        IF(NCOV .GT. 4) THEN
         
         DO J = 1,NCOV-4

          READ(27,1) READLINE

C  FOR THIS COVARIATE, WRITE THE PORTION OF THE CURRENT LINE WHICH IS
C  PAST THE COVARIATE NAME INTO SCRATCH FILE 53. THEN REWIND FILE 53
C  AND READ IN THE 3RD VALUE AS THE COV. VALUE. NOTE THAT IT IS
C  ASSUMED THAT ANY ENTRY WHICH IS A SPACE AT OR AFTER ENTRY 10 IS
C  PAST THE COVARIATE NAME.


          OPEN(53)

          DO I = 10,300
           IF(READLINE(I:I) .EQ. ' ') GO TO 10
          END DO

   10     WRITE(53,1) READLINE(I:300)

          REWIND(53)
          READ(53,*) XJUNK1,XJUNK2,COVAL(JSUB,J)
          CLOSE(53)

         END DO

        ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(NCOV .GT. 4) CONDITION.

 
C  READ TO THE END OF THE FILE SO THE NEXT CALL TO THIS ROUTINE WILL
C  START WITH THE BEGINNING LINE OF THE NEXT PATIENT'S INFO.
C  THERE ARE JUST 2 + NUMEQT MORE LINES: ONE BLANK LINE; ONE HAS
C  "ASSAY COEFFICIENTS FOLLOW:"; AND THE LAST NUMEQT HAVE THE ASSAY
C  COEFFICIENTS FOR EACH OUTPUT EQ.

	READ(27,*)
	READ(27,*)
	DO I=1,NUMEQT
	 READ(27,*)
	END DO


	RETURN
	END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
	SUBROUTINE GETNSUB(NSUB)

C  THIS ROUTINE IS A VARIATION OF TEST38.FOR, WHICH READS AN INTEGER
C  ANYWHERE ON A GIVEN LINE WITH A PARTICULAR SET OF WORDS AT THE START
C  OF THAT LINE.

	CHARACTER READLINE*1000,ERRFIL*20

      COMMON/ERROR/ERRFIL
C  COMMON/ERROR/ IS SUPPLIED TO ALL THE ROUTINES WHICH COULD WRITE TO
C  ERRFIL. 

    2   FORMAT(A1000)

C  READ UNTIL THE LINE WHICH HAS THE WORDS "THE NO. OF SUBJECTS IS" ON
C  IT SOMEWHERE.

   10   READ(25,2) READLINE

	ILINE=0
	 DO I=1,51
	  IF(READLINE(I:I+21) .EQ. 'THE NO. OF SUBJECTS IS') THEN
	   ILINE=1
	   GO TO 20
	  ENDIF
	 END DO
   20   IF(ILINE .EQ. 0) GO TO 10

C  SOMEWHERE AFTER THE CHARACTERS IN ENTRIES I:I+21 IS THE INTEGER.
C  READ THE CHARACTERS FOR THIS INTEGER, AND THEN CONVERT IT TO
C  AN INTEGER VALUE. AFTER THE FOLLOWING LOOP, THESE CHARACTERS WILL BE
C  IN READLINE(ISTART:IEND).

	 IEND = 0
	 ISTART = 0
	  DO J = I+22, 72

	   IF(ISTART .EQ. 0 .AND. READLINE(J:J) .NE. ' ') ISTART = J
	   IF(ISTART .NE. 0 .AND. READLINE(J:J) .EQ. ' ') THEN
	    IEND = J-1
	    GO TO 30
	   ENDIF
	  END DO


C  CHECK TO MAKE SURE THAT THE NO. OF CHARACTERS READ IN FOR THE INTEGER
C  IS NOT MORE THAN 4 (I.E., 4 CHARACTERS ALLOW A MAXIMUM SIZE OF 9999
C  WHICH IS MORE THAN THE LARGEST VALUE THIS INTEGER CAN BE).

   30	ISIZE = IEND-ISTART

	IF(ISIZE .GT. 3) THEN

	 WRITE(*,*)' NSUB IS ',NSUB,' WHICH IS TOO LARGE. '
	 WRITE(*,*)' THE PROGRAM STOPS. '

        OPEN(42,FILE=ERRFIL)
        WRITE(42,*)' NSUB IS ',NSUB,' WHICH IS TOO LARGE. '
        WRITE(42,*)' THE PROGRAM STOPS. '
        CLOSE(42)

	 CALL PAUSE
	 STOP

	ENDIF

C  CONVERT AS INDICATED ABOVE.

	NSUB = 0
	 DO K=ISTART,IEND
	  IF(READLINE(K:K) .EQ. '0') IVAL = 0
	  IF(READLINE(K:K) .EQ. '1') IVAL = 1
	  IF(READLINE(K:K) .EQ. '2') IVAL = 2
	  IF(READLINE(K:K) .EQ. '3') IVAL = 3
	  IF(READLINE(K:K) .EQ. '4') IVAL = 4

	  IF(READLINE(K:K) .EQ. '5') IVAL = 5
	  IF(READLINE(K:K) .EQ. '6') IVAL = 6
	  IF(READLINE(K:K) .EQ. '7') IVAL = 7
	  IF(READLINE(K:K) .EQ. '8') IVAL = 8
	  IF(READLINE(K:K) .EQ. '9') IVAL = 9
	  NSUB = NSUB + IVAL*10**ISIZE
	  ISIZE = ISIZE-1

	 END DO


	RETURN
	END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
	SUBROUTINE DETECT(NOB,PATH,FORFILE,IVERS,CopyFile,

     1     DeleteFile,ClearScreen)

	CHARACTER READLINE*1000,FORFILE*20,TMPFILE*13,PATHFILE*73,
     1  PATH*60,READLIN2*1000,CopyFile*5,DeleteFile*4,
     2  ClearScreen*6,ERRFIL*20

      COMMON/ERROR/ERRFIL
C  COMMON/ERROR/ IS SUPPLIED TO ALL THE ROUTINES WHICH COULD WRITE TO
C  ERRFIL. 



C  SUBROUTINE DETECT INPUTS A FORTRAN MODEL FILE, FORFILE, ALONG WITH
C  ITS PATH, PATH, AND WITHOUT CHECKING WHAT IS CURRENTLY AT THE TOP OF
C  THE 3 ROUTINES (DIFFEQ, OUTPUT, AND SYMBOL), WRITES THE CORRECT
C  ARGUMENT LIST, COMMON STATEMENTS, AND DIMENSION STATEMENTS FOR THE
C  PROGRAM AND LOCATION THE USER DESIRES.


C  NOTE THAT, AS OF NPBIG15C.FOR, THERE ARE 3 MORE ROUTINES WHICH ARE


C  PART OF FORFILE, GETFA, GETIX, AND GETTLAG. THESE ROUTINES ARE
C  CHECKED ONLY TO SEE IF THEY ARE IN THE FILE, BUT THEY ARE COPIED
C  LINE FOR LINE INTO npagdriv.f WITHOUT CHECKING THE DETAILS SINCE IT
C  IS ASSUMED THAT THE USER SIMPLY EDITED THE TEMPLATE MODEL FILE,
C  CURRENTLY TSTMULTG.FOR, TO PUT IN HIS/HER CODE.

C  NOTE: BIG IT2B REQUIRES A DIFFERENT STRUCTURE IN THE .FOR FILE
C  THAN DOES BIG NPAG. ALSO, THE VERSIONS AVAILABLE NOW ON THE
C  USC DELL COMPUTERS AND THE SDSC T3E (WHICH RUN PARALLELIZED VERSIONS
C  OF THE PROGRAMS) ARE DIFFERENT THAN THOSE AVAILABLE ON MY USC sun
C  (WHICH RUN UNPARALLIZED VERSIONS OF THE PROGRAMS). SEE VERSION.DET.


C  AS OF NPBIG15A.FOR, IVERS IS HARDCODED TO BE 0.

	IVERS = 0

C   10	WRITE(*,1)
C    1   FORMAT(/'ENTER 1 TO DO THE ANALYSIS ON A PARALLEL PROCESSOR MAC
C     2HINE;'/
C     3' ENTER 0 TO DO THE ANALYSIS ON A SINGLE PROCESSOR MACHINE: ')
C	READ(*,*,ERR=10) IVERS
C	IF(IVERS .NE. 1 .AND. IVERS .NE. 0) GO TO 10


C  CALL FULLNAME WHICH CONVERTS THE FILENAME TO PATHFILE, THE COMPLETE

C  NAME OF THE FILE, WHICH INCLUDES THE PATH (IF THE PATH IS NOT THE
C  CURRENT DIRECTORY). NOTE THAT THIS FILE DOES NOT HAVE TO BE TESTED
C  TO MAKE SURE IT EXISTS SINCE IT WAS OPENED AND READ BEFORE BEING
C  PASSED TO THIS ROUTINE.

 5010	TMPFILE = ' '
	TMPFILE = FORFILE
	CALL FULLNAME(PATH,TMPFILE,PATHFILE)
        OPEN(28,FILE=PATHFILE)


C  OPEN FILE (52) INTO WHICH WILL BE WRITTEN THE INFO FROM FILE 28,

C  ALONG WITH THE CORRECT "TOPS" OF EACH SUBROUTINE (WHETHER OR NOT
C  FILE 28 ALREADY HAS THE CORRECT "TOPS").

	OPEN(52,FILE='TEMP28')

C  PUT ALL LINES IN FILE 28 TO FILE 52, DOWN TO THE BEGINNING OF
C  SUBROUTINE DIFFEQ.

   19   FORMAT(A1000)
   50	READ(28,19,IOSTAT=IEND) READLINE

C  NOTE THAT IEND .LT. 0 --> END OF FILE REACHED.

	 IF(IEND .LT. 0) THEN

	  WRITE(*,22) PATHFILE
   22     FORMAT(/' FILE, ',A73/
     1' IS NOT AN ACCEPTABLE FORTRAN MODEL FILE; IN PARTICULAR, IT HAS'/
     2' NO SUBROUTINE DIFFEQ. '//
     3' THE PROGRAM STOPS. ')
	  CLOSE(28)
	  CLOSE(52)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,22) PATHFILE
        CLOSE(42)

	  CALL PAUSE
	  STOP

	 ENDIF



C  SINCE THE PHRASE, 'SUBROUTINE DIFFEQ' COULD OCCUR IN THE FILE WITHOUT
C  BEING THE START OF THE ACTUAL SUBROUTINE, CHECK FOR THE LOCATION OF
C  A LINE WITH 'SUBROUTINE DIFFEQ' ON IT AND THE FOLLOWING LINE WITH
C  'IMPLICIT REAL*8(A' ON IT.

	CALL CHECKLIN(READLINE,'SUBROUTINE DIFFEQ',IYES)
	IF(IYES .EQ. 0) THEN
	 WRITE(52,19) READLINE
	 GO TO 50
	ENDIF

   	READ(28,19,IOSTAT=IEND) READLIN2

	CALL CHECKLIN(READLIN2,'IMPLICIT REAL*8(A',IYES)
	 IF(IYES .EQ. 0) THEN
	  WRITE(52,19) READLINE
	  WRITE(52,19) READLIN2
	  GO TO 50
	 ENDIF

C  TO GET TO THIS POINT, READLINE AND READLIN2 CONTAIN THE TWO LINES
C  ABOVE, WHICH INDICATE THE START OF SUBROUTINE DIFFEQ.


C  CALL WRITEDIF TO PLACE THE CORRECT "TOP" TO SUBROUTINE DIFFEQ INTO
C  FILE 52 (IVERS GIVES THE DESIRED VERSION).

	CALL WRITEDIF(IVERS)

C  SKIP THROUGH THE REMAINING ORIGINAL "TOP" OF SUBROUTINE DIFFEQ

C  WITHOUT WRITING ANY OF IT TO FILE 52.

   60	READ(28,19,IOSTAT=IEND) READLINE

C  NOTE THAT IEND .LT. 0 --> END OF FILE REACHED.

	 IF(IEND .LT. 0) THEN

	  WRITE(*,27) PATHFILE
   27     FORMAT(/' FILE, ',A73/
     1' IS NOT AN ACCEPTABLE FORTRAN MODEL FILE; IN PARTICULAR, IT'/
     2' DOES NOT HAVE AN ACCEPTABLE SUBROUTINE DIFFEQ. '//
     3' THE PROGRAM STOPS. ')
	  CLOSE(28)
	  CLOSE(52)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,27) PATHFILE
        CLOSE(42)

	  CALL PAUSE
	  STOP

	 ENDIF


C  CALL SKIPLINE TO SEE IF READLINE CONTAINS ANY OF THE KEY WORDS,
C  'COMMON', 'DIMENSION', OR 'CHARACTER'. IF SO, IYES RETURNS AS 1
C  AND SO THIS READLINE SHOULD BE SKIPPED SINCE IT'S PART OF THE
C  ORIGINAL SUBROUTINE DIFFEQ.

	CALL SKIPLINE(READLINE,IYES)
	IF(IYES .EQ. 1) GO TO 60


C  TO GET HERE, THE CURRENT LINE IS NO LONGER PART OF THE "TOP" OF
C  SUBROUTINE DIFFEQ. START WRITING TO FILE 52 THE FIRST LINE BELOW

C  WHICH IS THE FIRST LINE WHICH BEGINS THE CODE WHICH ESTABLISES
C  RATEIV(.) AND CV(.) AS PARTICULAR ENTRIES IN THE R(.) ARRAY.
C  BACKSPACE FILE 28 SO THIS LINE WILL BE READ IN AGAIN AT LABEL 350.
C  NOTE THAT IF THE USER HAS NOT BASED HIS FORTRAN MODEL FILE ON
C  TSTMULTG.FOR, AND THERE IS NO SUCH CODE REGARDING RATEIV AND CV,
C  THE PROGRAM WILL STOP WITH A MESSAGE.


	BACKSPACE(28)


  350	READ(28,19,IOSTAT=IEND) READLINE

C  NOTE THAT IEND .LT. 0 --> END OF FILE REACHED.

	 IF(IEND .LT. 0) THEN

	  WRITE(*,351) PATHFILE
  351     FORMAT(/' FILE, ',A73/
     1' IS NOT AN ACCEPTABLE FORTRAN MODEL FILE BASED ON THE '/
     2' TEMPLATE FILE, TSTMULTG.FOR (OR A NEWER VERSION). '//
     3' THE MODEL FILE MUST HAVE DO LOOPS IN SUBROUTINE DIFFEQ'/
     4' WHICH INITIALIZE RATEIV(.) AND CV(.), AND ANOTHER IN'/
     5' SUBROUTINE OUTPUT WHICH INITIALIZES CV(.).'//
     3' THE PROGRAM STOPS. ')
	  CLOSE(28)
	  CLOSE(52)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,351) PATHFILE
        CLOSE(42)

	  CALL PAUSE
	  STOP

	 ENDIF


	CALL CHECKLIN(READLINE,'****** ESTABLISH ',IYES)

	IF(IYES .EQ. 0) THEN
	 GO TO 350

	ENDIF

C  TO GET HERE, READLINE CONTAINS THE FIRST LINE OF THE TSTMULTG.FOR
C  CODE WHICH ESTABLISHES THE RATEIV(.) AND CV(.) ARRAYS IN
C  SUBROUTINE DIFFEQ. WRITE IT AND ALL THE REST OF DIFFEQ TO FILE 52.

	  WRITE(52,19) READLINE


C  PUT ALL LINES IN FILE 28 TO FILE 52, DOWN TO THE BEGINNING OF
C  SUBROUTINE OUTPUT.


  100	READ(28,19,IOSTAT=IEND) READLINE

C  NOTE THAT IEND .LT. 0 --> END OF FILE REACHED.

	 IF(IEND .LT. 0) THEN

	  WRITE(*,23) PATHFILE
   23     FORMAT(/' FILE, ',A73/
     1' IS NOT AN ACCEPTABLE FORTRAN MODEL FILE; IN PARTICULAR, IT HAS'/
     2' NO SUBROUTINE OUTPUT. '//
     3' THE PROGRAM STOPS. ')
	  CLOSE(28)
        CLOSE(52)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,23) PATHFILE
        CLOSE(42)


	  CALL PAUSE
	  STOP

	 ENDIF

C  SINCE THE PHRASE, 'SUBROUTINE OUTPUT' COULD OCCUR IN THE FILE WITHOUT
C  BEING THE START OF THE ACTUAL SUBROUTINE, CHECK FOR THE LOCATION OF
C  A LINE WITH 'SUBROUTINE OUTPUT' ON IT AND THE FOLLOWING LINE WITH
C  'IMPLICIT REAL*8(A' ON IT.

	CALL CHECKLIN(READLINE,'SUBROUTINE OUTPUT',IYES)
	IF(IYES .EQ. 0) THEN
	 WRITE(52,19) READLINE
	 GO TO 100
	ENDIF

   	READ(28,19,IOSTAT=IEND) READLIN2

	CALL CHECKLIN(READLIN2,'IMPLICIT REAL*8(A',IYES)
	 IF(IYES .EQ. 0) THEN

	  WRITE(52,19) READLINE
	  WRITE(52,19) READLIN2
	  GO TO 100
	 ENDIF

C  TO GET TO THIS POINT, READLINE AND READLIN2 CONTAIN THE TWO LINES
C  ABOVE, WHICH INDICATE THE START OF SUBROUTINE OUTPUT.

C  CALL WRITEOUT TO PLACE THE CORRECT "TOP" TO SUBROUTINE OUTPUT INTO
C  FILE 52 (IVERS GIVES THE DESIRED VERSION).



	CALL WRITEOUT(IVERS)


C  SKIP THROUGH THE REMAINING ORIGINAL "TOP" OF SUBROUTINE OUTPUT
C  WITHOUT WRITING ANY OF IT TO FILE 52.

  110	READ(28,19,IOSTAT=IEND) READLINE

C  NOTE THAT IEND .LT. 0 --> END OF FILE REACHED.

	 IF(IEND .LT. 0) THEN

	  WRITE(*,28) PATHFILE
   28     FORMAT(/' FILE, ',A73/
     1' IS NOT AN ACCEPTABLE FORTRAN MODEL FILE; IN PARTICULAR, IT'/
     2' DOES NOT HAVE AN ACCEPTABLE SUBROUTINE OUTPUT. '//
     3' THE PROGRAM STOPS. ')
	  CLOSE(28)
	  CLOSE(52)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,28) PATHFILE
        CLOSE(42)

	  CALL PAUSE
	  STOP

	 ENDIF

C  CALL SKIPLINE TO SEE IF READLINE CONTAINS ANY OF THE KEY WORDS,
C  'COMMON', 'DIMENSION', OR 'CHARACTER'. IF SO, IYES RETURNS AS 1
C  AND SO THIS READLINE SHOULD BE SKIPPED SINCE IT'S PART OF THE
C  ORIGINAL SUBROUTINE OUTPUT.

	CALL SKIPLINE(READLINE,IYES)
	IF(IYES .EQ. 1) GO TO 110


C  TO GET HERE, THE CURRENT LINE IS NO LONGER PART OF THE "TOP" OF
C  SUBROUTINE OUTPUT. START WRITING TO FILE 52 THE FIRST LINE BELOW
C  WHICH IS THE FIRST LINE WHICH BEGINS THE CODE WHICH ESTABLISES
C  CV(.) AS PARTICULAR ENTRIES IN THE R(.) ARRAY.
C  BACKSPACE FILE 28 SO THIS LINE WILL BE READ IN AGAIN AT LABEL 450.
C  NOTE THAT IF THE USER HAS NOT BASED HIS FORTRAN MODEL FILE ON
C  TSTMULTG.FOR, AND THERE IS NO SUCH CODE REGARDING CV,
C  THE PROGRAM WILL STOP WITH A MESSAGE.


	BACKSPACE(28)


  450	READ(28,19,IOSTAT=IEND) READLINE

C  NOTE THAT IEND .LT. 0 --> END OF FILE REACHED.


	 IF(IEND .LT. 0) THEN

	  WRITE(*,351) PATHFILE

	  CLOSE(28)
	  CLOSE(52)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,351) PATHFILE
        CLOSE(42)

	  CALL PAUSE
	  STOP

	 ENDIF

	CALL CHECKLIN(READLINE,'****** ESTABLISH ',IYES)
	IF(IYES .EQ. 0) THEN
	 GO TO 450
	ENDIF

C  TO GET HERE, READLINE CONTAINS THE FIRST LINE OF THE TSTMULTG.FOR
C  CODE WHICH ESTABLISHES THE CV(.) ARRAY IN SUBROUTINE OUTPUT. WRITE
C  IT AND ALL THE REST OF OUTPUT TO FILE 52.

	  WRITE(52,19) READLINE



C  PUT ALL LINES IN FILE 28 TO FILE 52, DOWN TO THE BEGINNING OF
C  SUBROUTINE SYMBOL.

  150	READ(28,19,IOSTAT=IEND) READLINE


C  NOTE THAT IEND .LT. 0 --> END OF FILE REACHED.

	 IF(IEND .LT. 0) THEN

	  WRITE(*,24) PATHFILE
   24     FORMAT(/' FILE, ',A73/
     1' IS NOT AN ACCEPTABLE FORTRAN MODEL FILE; IN PARTICULAR, IT HAS'/
     2' NO SUBROUTINE SYMBOL. '//
     3' THE PROGRAM STOPS. ')
	  CLOSE(28)
	  CLOSE(52)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,24) PATHFILE
        CLOSE(42)

	  CALL PAUSE
	  STOP

	 ENDIF

C  SINCE THE PHRASE, 'SUBROUTINE SYMBOL' COULD OCCUR IN THE FILE WITHOUT
C  BEING THE START OF THE ACTUAL SUBROUTINE, CHECK FOR THE LOCATION OF
C  A LINE WITH 'SUBROUTINE SYMBOL' ON IT AND THE FOLLOWING LINE WITH
C  'IMPLICIT REAL*8(A' ON IT.


	CALL CHECKLIN(READLINE,'SUBROUTINE SYMBOL',IYES)
	IF(IYES .EQ. 0) THEN
	 WRITE(52,19) READLINE
	 GO TO 150
	ENDIF

   	READ(28,19,IOSTAT=IEND) READLIN2

	CALL CHECKLIN(READLIN2,'IMPLICIT REAL*8(A',IYES)
	 IF(IYES .EQ. 0) THEN
	  WRITE(52,19) READLINE
	  WRITE(52,19) READLIN2
	  GO TO 150
	 ENDIF

C  TO GET TO THIS POINT, READLINE AND READLIN2 CONTAIN THE TWO LINES
C  ABOVE, WHICH INDICATE THE START OF SUBROUTINE SYMBOL.

C  CALL WRITESYM TO PLACE THE CORRECT "TOP" TO SUBROUTINE SYMBOL INTO
C  FILE 52 (IVERS GIVES THE DESIRED VERSION).

	CALL WRITESYM(IVERS)

C  SKIP THROUGH THE REMAINING ORIGINAL "TOP" OF SUBROUTINE SYMBOL
C  WITHOUT WRITING ANY OF IT TO FILE 52.

  160	READ(28,19,IOSTAT=IEND) READLINE


C  NOTE THAT IEND .LT. 0 --> END OF FILE REACHED.


	 IF(IEND .LT. 0) THEN

	  WRITE(*,29) PATHFILE
   29     FORMAT(/' FILE, ',A73/
     1' IS NOT AN ACCEPTABLE FORTRAN MODEL FILE; IN PARTICULAR, IT'/
     2' DOES NOT HAVE AN ACCEPTABLE SUBROUTINE SYMBOL. '//
     3' THE PROGRAM STOPS. ')

	  CLOSE(28)
	  CLOSE(52)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,29) PATHFILE
        CLOSE(42)

	  CALL PAUSE
	  STOP

	 ENDIF

C  CALL SKIPLINE TO SEE IF READLINE CONTAINS ANY OF THE KEY WORDS,
C  'COMMON', 'DIMENSION', OR 'CHARACTER'. IF SO, IYES RETURNS AS 1
C  AND SO THIS READLINE SHOULD BE SKIPPED SINCE IT'S PART OF THE
C  ORIGINAL SUBROUTINE SYMBOL.

	CALL SKIPLINE(READLINE,IYES)
	IF(IYES .EQ. 1) GO TO 160

C  TO GET HERE, THE CURRENT LINE IS NO LONGER PART OF THE "TOP" OF
C  SUBROUTINE SYMBOL. WRITE IT TO FILE 52 AND CONTINUE.

	  WRITE(52,19) READLINE


C  PUT ALL LINES IN FILE 28 TO FILE 52, DOWN TO THE BEGINNING OF
C  SUBROUTINE GETFA.

  550	READ(28,19,IOSTAT=IEND) READLINE

C  NOTE THAT IEND .LT. 0 --> END OF FILE REACHED.

	 IF(IEND .LT. 0) THEN

	  WRITE(*,124) PATHFILE
  124     FORMAT(/' FILE, ',A73/
     1' IS NOT AN ACCEPTABLE FORTRAN MODEL FILE; IN PARTICULAR, IT HAS'/
     2' NO SUBROUTINE GETFA. '//
     3' THE PROGRAM STOPS. ')

	  CLOSE(28)
	  CLOSE(52)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,124) PATHFILE

        CLOSE(42)

	  CALL PAUSE
	  STOP

	 ENDIF

C  SINCE THE PHRASE, 'SUBROUTINE GETFA(' COULD OCCUR IN THE FILE WITHOUT
C  BEING THE START OF THE ACTUAL SUBROUTINE, CHECK FOR THE LOCATION OF
C  A LINE WITH 'SUBROUTINE GETFA(' ON IT AND THE FOLLOWING LINE WITH
C  'IMPLICIT REAL*8(A' ON IT.

	CALL CHECKLIN(READLINE,'SUBROUTINE GETFA(',IYES)
	IF(IYES .EQ. 0) THEN

	 WRITE(52,19) READLINE
	 GO TO 550
	ENDIF

   	READ(28,19,IOSTAT=IEND) READLIN2

	CALL CHECKLIN(READLIN2,'IMPLICIT REAL*8(A',IYES)
	 IF(IYES .EQ. 0) THEN
	  WRITE(52,19) READLINE
	  WRITE(52,19) READLIN2

	  GO TO 550

	 ENDIF


C  TO GET TO THIS POINT, READLINE AND READLIN2 CONTAIN THE TWO LINES
C  ABOVE, WHICH INDICATE THE START OF SUBROUTINE GETFA. WRITE THEM
C  TO FILE 52 AND CONTINUE.

	  WRITE(52,19) READLINE
	  WRITE(52,19) READLIN2


C  PUT ALL LINES IN FILE 28 TO FILE 52, DOWN TO THE BEGINNING OF
C  SUBROUTINE GETIX.

  650	READ(28,19,IOSTAT=IEND) READLINE

C  NOTE THAT IEND .LT. 0 --> END OF FILE REACHED.


	 IF(IEND .LT. 0) THEN

	  WRITE(*,224) PATHFILE
  224     FORMAT(/' FILE, ',A73/
     1' IS NOT AN ACCEPTABLE FORTRAN MODEL FILE; IN PARTICULAR, IT HAS'/
     2' NO SUBROUTINE GETIX. '//
     3' THE PROGRAM STOPS. ')
	  CLOSE(28)

	  CLOSE(52)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,224) PATHFILE
        CLOSE(42)

	  CALL PAUSE
	  STOP
	 ENDIF


C  SINCE THE PHRASE, 'SUBROUTINE GETIX(' COULD OCCUR IN THE FILE WITHOUT
C  BEING THE START OF THE ACTUAL SUBROUTINE, CHECK FOR THE LOCATION OF
C  A LINE WITH 'SUBROUTINE GETIX(' ON IT AND THE FOLLOWING LINE WITH
C  'IMPLICIT REAL*8(A' ON IT.

	CALL CHECKLIN(READLINE,'SUBROUTINE GETIX(',IYES)
	IF(IYES .EQ. 0) THEN
	 WRITE(52,19) READLINE
	 GO TO 650
	ENDIF

   	READ(28,19,IOSTAT=IEND) READLIN2

	CALL CHECKLIN(READLIN2,'IMPLICIT REAL*8(A',IYES)
	 IF(IYES .EQ. 0) THEN
	  WRITE(52,19) READLINE

	  WRITE(52,19) READLIN2
	  GO TO 650
	 ENDIF

C  TO GET TO THIS POINT, READLINE AND READLIN2 CONTAIN THE TWO LINES
C  ABOVE, WHICH INDICATE THE START OF SUBROUTINE GETIX. WRITE THEM
C  TO FILE 52 AND CONTINUE.


	  WRITE(52,19) READLINE
	  WRITE(52,19) READLIN2


C  PUT ALL LINES IN FILE 28 TO FILE 52, DOWN TO THE BEGINNING OF
C  SUBROUTINE GETTLAG.

  750	READ(28,19,IOSTAT=IEND) READLINE

C  NOTE THAT IEND .LT. 0 --> END OF FILE REACHED.

	 IF(IEND .LT. 0) THEN

	  WRITE(*,324) PATHFILE
  324     FORMAT(/' FILE, ',A73/
     1' IS NOT AN ACCEPTABLE FORTRAN MODEL FILE; IN PARTICULAR, IT HAS'/
     2' NO SUBROUTINE GETTLAG. '//
     3' THE PROGRAM STOPS. ')
	  CLOSE(28)
	  CLOSE(52)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,324) PATHFILE
        CLOSE(42)

	  CALL PAUSE
	  STOP

	 ENDIF

C  SINCE THE PHRASE, 'SUBROUTINE GETTLA' COULD OCCUR IN THE FILE WITHOUT

C  BEING THE START OF THE ACTUAL SUBROUTINE, CHECK FOR THE LOCATION OF
C  A LINE WITH 'SUBROUTINE GETTLA' ON IT AND THE FOLLOWING LINE WITH
C  'IMPLICIT REAL*8(A' ON IT.

	CALL CHECKLIN(READLINE,'SUBROUTINE GETTLA',IYES)
	IF(IYES .EQ. 0) THEN
	 WRITE(52,19) READLINE
	 GO TO 750
	ENDIF

   	READ(28,19,IOSTAT=IEND) READLIN2

	CALL CHECKLIN(READLIN2,'IMPLICIT REAL*8(A',IYES)
	 IF(IYES .EQ. 0) THEN
	  WRITE(52,19) READLINE
	  WRITE(52,19) READLIN2
	  GO TO 750

	 ENDIF

C  TO GET TO THIS POINT, READLINE AND READLIN2 CONTAIN THE TWO LINES
C  ABOVE, WHICH INDICATE THE START OF SUBROUTINE GETTLAG. WRITE THEM
C  TO FILE 52 AND CONTINUE.

	  WRITE(52,19) READLINE
	  WRITE(52,19) READLIN2


  200	READ(28,19,IOSTAT=IEND) READLINE

C  NOTE THAT IEND .LT. 0 --> END OF FILE REACHED.

	IF(IEND .LT. 0) GO TO 250
	WRITE(52,19) READLINE
	GO TO 200

  250   CLOSE(52)
	CLOSE(28)

C  BEFORE COPYING 'TEMP28' TO PATHFILE (FORFILE WITH ITS PATH), COPY

C  PATHFILE TO A FILE WITH THE SAME NAME, BUT WITH AN EXTRA '.OLD' AT
C  THE END.

	WRITE(*,251) PATHFILE
  251   FORMAT(/' YOUR ORIGINAL MODEL FILE IS ABOUT TO BE COPIED INTO'/
     1' A FILE WITH THE SAME NAME, BUT WITH "OLD" PRECEEDING IT. '//
     2' THE CORRECT MODEL FORTRAN CODE FOR THE LOCATION WHERE YOU ARE'/
     3' HAVING YOUR PROGRAM RUN WILL BE PLACED INTO YOUR ORIGINAL FILE .
     4..'/
     5' ',A73)


	READLINE = CopyFile//PATH(1:NOB)//FORFILE//' '//PATH(1:NOB)//
     1'OLD'//FORFILE
        CALL SYSTEM(READLINE)


        CALL SYSTEM(CopyFile//' TEMP28 '//PATH(1:NOB)//FORFILE)

C  DELETE THE TEMP FILE CREATED ABOVE,

	CALL SYSTEM(DeleteFile//' TEMP28')


	RETURN
	END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
	SUBROUTINE CHECKLIN(READLINE,TARGET,IYES)
	CHARACTER TARGET*17,READLINE*1000

C  THIS ROUTINE, CALLED BY SUBROUTINE DETECT, CHECKS READLINE TO SEE IF
C  ANYWHERE IN IT (STARTING WITH COLUMN 7) IS THE 17-CHARACTER PHRASE,
C  TARGET. IF SO, IYES RETURNS AS 1; OTHERWISE IYES RETURNS AS 0.

	IYES = 0

	DO I=7,67
	 IF(READLINE(I:I+16) .EQ. TARGET) THEN
	  IYES = 1
	  GO TO 10
	 ENDIF
	END DO


   10   RETURN
	END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
	SUBROUTINE WRITEDIF(IVERS)
	CHARACTER READLINE*1000

C  THIS ROUTINE, CALLED BY DETECT, WRITES TO FILE 52 THE "TOP" OF
C  SUBROUTINE DIFFEQ (OF THE FORTRAN MODEL FILE). THE CORRECT VERSION
C  OF THIS "TOP" IS DETERMINED BY IVERS.

C  IF IVERS = 1 --> PARALLELIZED VERSION AT SDSC OR USC LABORATORY;
C             0 --> UNPARALLELIZED (BETA) VERSION ON USC sun.

C  THE TOP 5 LINES ARE THE SAME REGARDLESS OF THE VERSION.

    1   FORMAT(A1000)
	READLINE = '      SUBROUTINE DIFFEQ(NDIM,T,X,XP,RPAR,IPAR)'
	WRITE(52,1) READLINE
	READLINE = '      IMPLICIT REAL*8(A-H,O-Z)'
	WRITE(52,1) READLINE
	READLINE = '      COMMON /PARAMD/ P'
	WRITE(52,1) READLINE
	READLINE = '      COMMON /INPUT/ R,B'
	WRITE(52,1) READLINE
	READLINE = '      COMMON /DESCR/ AGE,HEIGHT,ISEX,IETHFLG'
	WRITE(52,1) READLINE



	IF(IVERS .EQ. 0) THEN
	 READLINE = '      COMMON /CNST2/ NPL,NUMEQT,NDRUG,NADD'
	 WRITE(52,1) READLINE
	ENDIF

	IF(IVERS .EQ. 1)
     1  READLINE = '      DIMENSION X(NDIM),XP(NDIM),P(25),R(37),B(20)'
	IF(IVERS .EQ. 0)
     1  READLINE = '      DIMENSION X(NDIM),XP(NDIM),P(32),R(37),B(20)'
	WRITE(52,1) READLINE

	IF(IVERS .EQ. 0) THEN
         READLINE = '      DIMENSION CV(26),RATEIV(7)'
	 WRITE(52,1) READLINE
	ENDIF

	WRITE(52,*)

	END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
	SUBROUTINE WRITEOUT(IVERS)
	CHARACTER READLINE*1000

C  THIS ROUTINE, CALLED BY DETECT, WRITES TO FILE 52 THE "TOP" OF
C  SUBROUTINE OUTPUT (OF THE FORTRAN MODEL FILE). THE CORRECT VERSION
C  OF THIS "TOP" IS DETERMINED BY IVERS.

C  IF IVERS = 1 --> PARALLELIZED VERSION AT SDSC OR USC LABORATORY;
C             0 --> UNPARALLELIZED (BETA) VERSION ON USC sun.

C  LINES 2 - 6 ARE THE SAME REGARDLESS OF THE VERSION.

    1   FORMAT(A1000)


	IF(IVERS .EQ. 1)
     1  READLINE = '      SUBROUTINE OUTPUT(Y)'
	IF(IVERS .EQ. 0)
     1  READLINE = '      SUBROUTINE OUTPUT(T,Y)'
	WRITE(52,1) READLINE

	READLINE = '      IMPLICIT REAL*8(A-H,O-Z)'
	WRITE(52,1) READLINE
	READLINE = '      COMMON /PARAMD/ P'
	WRITE(52,1) READLINE
	READLINE = '      COMMON /STATE/ X'
	WRITE(52,1) READLINE
	READLINE = '      COMMON /INPUT/ R,B'
	WRITE(52,1) READLINE
	READLINE = '      COMMON /DESCR/ AGE,HEIGHT,ISEX,IETHFLG'
	WRITE(52,1) READLINE

	IF(IVERS .EQ. 0) THEN
	 READLINE = '      COMMON /CNST2/ NPL,NUMEQT,NDRUG,NADD'
	 WRITE(52,1) READLINE
	ENDIF

	IF(IVERS .EQ. 1)
     1  READLINE = '      DIMENSION X(20),P(25),Y(6),R(37),B(20)'
	IF(IVERS .EQ. 0)
     1  READLINE = '      DIMENSION X(20),P(32),Y(6),R(37),B(20)'
C  NOTE THAT SUBROUTINE WRITEOUT IS NO LONGER CALLED BECAUSE SUBROUTINE
C  DETECT IS NO LONGER CALLED. SO, IN NPAG113.FOR, THERE IS NO REASON
C  TO CHANGE THE Y(6) ABOVE TO Y(MAXNUMEQ).


	WRITE(52,1) READLINE

	IF(IVERS .EQ. 0) THEN
         READLINE = '      DIMENSION CV(26)'
	 WRITE(52,1) READLINE
	ENDIF

	WRITE(52,*)


	RETURN
	END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
	SUBROUTINE WRITESYM(IVERS)
	CHARACTER READLINE*1000

C  THIS ROUTINE, CALLED BY DETECT, WRITES TO FILE 52 THE "TOP" OF
C  SUBROUTINE SYMBOL (OF THE FORTRAN MODEL FILE). THE CORRECT VERSION
C  OF THIS "TOP" IS DETERMINED BY IVERS.

C  IF IVERS = 1 --> PARALLELIZED VERSION AT SDSC OR USC LABORATORY;
C             0 --> UNPARALLELIZED (BETA) VERSION ON USC sun.

C  THE 1ST 3 LINES ARE THE SAME REGARDLESS OF THE VERSION. THE NEXT
C  LINES DEPEND ON THE VERSION.

    1   FORMAT(A1000)
	READLINE = '      SUBROUTINE SYMBOL'
	WRITE(52,1) READLINE
        READLINE = '      IMPLICIT REAL*8(A-H,O-Z)'
	WRITE(52,1) READLINE
	READLINE = '      CHARACTER PSYM(32)*11'
	WRITE(52,1) READLINE

	IF(IVERS .EQ. 1) THEN
	 READLINE = '      COMMON /CNST/ N,ND,NI,NUP,NUIC,NP'
	 WRITE(52,1) READLINE
	ENDIF

	IF(IVERS .EQ. 0) THEN
	 READLINE = '      COMMON /CNST/ N,ND,NI,NUP,NUIC,NP'
	 WRITE(52,1) READLINE
	 READLINE = '      COMMON/BOLUSCOMP/NBCOMP'
	 WRITE(52,1) READLINE
	 READLINE = '      DIMENSION NBCOMP(7)'
	 WRITE(52,1) READLINE
	ENDIF

	RETURN
	END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
	SUBROUTINE SKIPLINE(READLINE,IYES)
	CHARACTER READLINE*1000

C  SUBROUTINE SKIPLINE IS CALLED BY DETECT TO SEE IF READLINEN HAS ANY
C  OF THE KEY WORDS, 'COMMON', 'DIMENSION', OR 'CHARACTER'. IF SO, IYES
C  RETURNS AS 1. OTHERWISE, IYES RETURNS AS 0.


	IYES = 1
	DO I=7,64
	 IF(READLINE(I:I+5) .EQ. 'COMMON') RETURN
	 IF(READLINE(I:I+8) .EQ. 'DIMENSION') RETURN
	 IF(READLINE(I:I+8) .EQ. 'CHARACTER') RETURN
	END DO

C  TO GET HERE MEANS THAT READLINE CONTAINED NONE OF THE KEY WORDS, SO
C  SET IYES = 0 AND RETURN.

	IYES = 0
	RETURN
	END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
	SUBROUTINE SEPARATE
	CHARACTER READLINE*1000

C  THIS ROUTINE, CALLED BY PREVRUN, SEPARATES THE INFO IN FILE 45 INTO



C  4 NEW FILES:

C  FILE 25 WILL CONTAIN THE 1ST PART OF FILE 45(THE OLD "OUTPUT" INFO).
C  FILE 34 WILL CONTAIN THE 2ND PART OF FILE 45(THE OLD "DENSITY" INFO).
C  FILE 27 WILL CONTAIN THE 3RD PART OF FILE 45(THE PATIENT DATA INFO).
C  FILE 47 WILL CONTAIN THE 4TH PART OF FILE 45(THE npagdriv.f INFO).

    1   FORMAT(A1000)

	OPEN(25)
C       CALL PAUSE
C  ABOVE PAUSE  NEEDED SO PROGRAM WON'T BOMB AFTER OPENING FILE
C  (REASON UNKNOWN).

	OPEN(34)
C	CALL PAUSE
C  ABOVE PAUSE NEEDED SO PROGRAM WON'T BOMB AFTER OPENING FILE
C  (REASON UNKNOWN).

	OPEN(27)
C	CALL PAUSE
C  ABOVE PAUSE NEEDED SO PROGRAM WON'T BOMB AFTER OPENING FILE
C  (REASON UNKNOWN).


	OPEN(47)

	REWIND(45)


   10	READ(45,1) READLINE
	IF(READLINE(17:42) .EQ. '* END OF THE OUTPUT FILE *') GO TO 20
	WRITE(25,1) READLINE
	GO TO 10

   20	READ(45,1) READLINE
	IF(READLINE(1:7) .NE. 'DENSITY') GO TO 20
   	WRITE(34,1) READLINE
   30   READ(45,1) READLINE
	IF(READLINE(17:43) .EQ. '* END OF THE DENSITY FILE *') GO TO 40
	WRITE(34,1) READLINE
	GO TO 30


   40   READ(45,1) READLINE
	IF(READLINE(3:16) .NE. 'LAST AND FIRST') GO TO 40
   	WRITE(27,1) READLINE
   50   READ(45,1) READLINE
	IF(READLINE(17:43) .EQ. '* END OF THE PATIENT DATA I') GO TO 60
	WRITE(27,1) READLINE
	GO TO 50

   60   READ(45,1) READLINE
	IF(READLINE(17:43) .NE. '* START OF THE npagdriv.f F') GO TO 60
   	WRITE(47,1) READLINE
   70   READ(45,1) READLINE

	IF(READLINE(17:43) .EQ. '* END OF THE npagdriv.f FIL') GO TO 80
	WRITE(47,1) READLINE
	GO TO 70


   80   WRITE(47,1) READLINE

	REWIND(25)

	REWIND(34)
	REWIND(27)
	REWIND(47)
	CLOSE(45)

	RETURN
	END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
	SUBROUTINE GETNUM(NUMEQT)
	IMPLICIT REAL*8(A-H,O-Z)
	CHARACTER READLINE*1000,ERRFIL*20

      COMMON/ERROR/ERRFIL
C  COMMON/ERROR/ IS SUPPLIED TO ALL THE ROUTINES WHICH COULD WRITE TO
C  ERRFIL. 

C  THIS SUBROUTINE, CALLED BY PREVRUN, READS DOWN IN FILE 27, WHICH IS
C  ALREADY REWOUND TO OBTAIN THE NO. OF OUTPUT EQUATIONS (NUMEQT).

    2   FORMAT(A1000)

C  NOTE THAT NUMEQT IS ON THE LINE WITH "NO. OF TOTAL OUTPUT EQUATIONS"

C  IN COLUMNS 12:40. IF NO LINE HAS THESE WORDS, THIS PATIENT DATA
C  FILE IS NOT A NEW-STYLE WORKING COPY FILE FROM ANDREAS' NEW
C  BOXES PROGRAM.

   35	READ(27,2,IOSTAT=IEND) READLINE


	IF(IEND .LT. 0) THEN

	 WRITE(*,57)
   57    FORMAT(//' THE COMBINATION OUTPUT FILE YOU HAVE ENTERED TO'/
     1' THIS PROGRAM WAS NOT MADE BY A RECENT NPAG PROGRAM.'//
     2' SUCH A FILE MUST HAVE CONCATENATED PATIENT DATA FILES HAVING'/
     3' A LINE WITH "NO. OF TOTAL OUTPUT EQUATIONS" IN COLUMNS 12:40.'//
     3' THE PROGRAM STOPS. '//)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,57) 
        CLOSE(42)

	 CALL PAUSE
	 STOP

	ENDIF

	IF(READLINE(12:40) .NE. 'NO. OF TOTAL OUTPUT EQUATIONS')GO TO 35
	BACKSPACE(27)
   13   FORMAT(T2,I5)
        READ(27,13) NUMEQT

	RETURN
	END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
	SUBROUTINE GETCOVR2(NCOV,DESCR)
	IMPLICIT REAL*8(A-H,O-Z)
	CHARACTER READLINE*1000,DESCR(26)*20

C  THIS ROUTINE IS CALLED BY SUBROUTINE PREVRUN TO OBTAIN, FROM FILE
C  27, THE NO. OF COVARIATES (NCOV), AND THEIR NAMES(DESCR(I),I=1,NCOV).



    2   FORMAT(A20)
   33   FORMAT(A1000)


	REWIND(27)

C  VERIFY THAT THE FIRST PATIENT DATA FILE IN FILE 27 (WHICH IS THE
C  CONCATENATED PATIENT DATA FILE) IS A 'CURRENT' TYPE WORKING COPY-LIKE
C  FILE (I.E., CREATED BY CONVRTI.FOR OR LATER VERSION). IF NOT, IT
C  DOESN'T HAVE ANY EXTRA COVARIATE INFO, OR EVEN AGE, SEX, HEIGHT,
C  ETHNICITY FLAG, AND SO IT IS A WASTE TO USE THIS PROGRAM WITH ITS
C  EXPANDED MENU ON FILES WHICH (BECAUSE THEY HAVE NO EXTRA

C  COVARIATES/DESCRIPTORS) CAN'T POSSIBLY TAKE ADVANTAGE OF IT.

C  AS OF NPBIG11.FOR, THE WORKING COPY FILES REQUIRED ARE THE NEWEST
C  TYPE (FROM THE NEW BOXES PROGRAM BY ANDREAS). BUT THE PROGRAM WOULD
C  NOT HAVE GOTTEN TO THIS POINT (I.E., PAST SUBROUTINE STACK, CALLED
C  BY SUBROUTINE PREVRUN) IF THE FILES WERE NOT THE CORRECT TYPE. SO
C  NO CHECKING OF THE FILE FORMAT IS REQUIRED HERE.

C  THE NO. OF ADDITIONAL COVARIATES IS ON THE LINE HAVING
C  "NO. OF ADDITIONAL COVARIATES" STARTING IN ENTRY 12.

   10	READ(27,33) READLINE
	IF(READLINE(12:28) .NE. 'NO. OF ADDITIONAL') GO TO 10

	BACKSPACE(27)
    3   FORMAT(T2,I5)
        READ(27,3) NADD

C  THE TOTAL NO. OF COVARIATES WILL BE 4 + NADD, SINCE THERE WILL
C  ALWAYS BE THE STANDARD 4 COVARIATES (AGE, SEX, HEIGHT,

C  ETHNICITY FLAG), IN ADDITION TO THE EXTRA ONES.

	NCOV = 4 + NADD
 
C  READ THE 1ST NCOV - 4 COVARIATE NAMES FROM BELOW THE LINE HAVING
C  "COVARIATE NAMES" STARTING IN COLUMN 2. IF NCOV = 4, NO NAMES 
C  WILL BE READ.



   20	READ(27,33) READLINE


	IF(READLINE(2:16) .NE. 'COVARIATE NAMES') GO TO 20


        IF(NCOV .GT. 4) THEN

         DO J = 1,NCOV-4

          READ(27,33) READLINE

C  FOR THIS COVARIATE, ESTABLISH DESCR(J) AS THE PORTION OF THE

C  CURRENT READLINE UP TO THE  FIRST SPACE, WHICH WILL BE ASSUMED TO BE
C  THE END OF THE COV. NAME. IN CASE THERE IS A SPACE OR TWO AT THE
C  BEGINNING OF READLINE FOR SOME REASON, START CHECKING FOR SPACES AT
C  ENTRY 3.

          DO I = 3,20
           IF(READLINE(I:I) .EQ. ' ') GO TO 30
          END DO

   30     DESCR(J) = READLINE(1:I-1)

         END DO

        ENDIF


C  THE ABOVE ENDIF IS FOR THE  IF(NCOV .GT. 4)  CONDITION.



     	DESCR(NCOV-3) = 'AGE'
	DESCR(NCOV-2) = 'SEX'
	DESCR(NCOV-1) = 'HEIGHT'
	DESCR(NCOV) = 'ETHNICITY FLAG'

	REWIND(27)

	RETURN
	END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

C
	SUBROUTINE GETIPAT(NSUBTOT,NSUB,ISUBALL,MAXSUB,IPATVEC)
	DIMENSION IPATVEC(MAXSUB),IPATVECC(9999)
	CHARACTER READLINE*1000

C  SUBROUTINE GETIPAT IS CALLED TO OBTAIN THE NO. OF SUBJECTS IN THE
C  ENTIRE DATA SET, NSUBTOT, THE NO. OF THESE SUBJECTS TO BE USED
C  IN THE CURRENT ANALYSIS, NSUB, AND THE INDICES OF THESE "ACTIVE"
C  SUBJECTS, IPATVEC(I),I=1,NSUB. NOTE ALSO THAT ISUBALL = 1 IF ALL
C  SUBJECTS ARE USED (I.E., NSUB = NSUBTOT) AND 0 OTHERWISE.

    3   FORMAT(A1000)
 4070	WRITE(*,121)
  121   FORMAT(/' ENTER THE NO. OF SUBJECTS IN YOUR ENTIRE DATA SET.'/
     1' THIS MAY BE DIFFERENT THAN THE NO. OF SUBJECTS TO BE TO BE '/

     2' ANALYZED IN THIS PARTICULAR RUN (SEE BELOW): ')
 	READ(*,*,ERR=4070) NSUBTOT
	IF(NSUBTOT .LE. 0) GO TO 4070

 4170	WRITE(*,2121) NSUBTOT
 2121   FORMAT(/' ENTER 1 IF ALL ',I4,' SUBJECTS IN YOUR DATA SET ARE'/

     1' 	TO BE ANALYZED IN THIS RUN; '/

     2'		ENTER 0 IF YOU WANT TO ANALYZE A SUBSET OF THIS SET: ')
	READ(*,*,ERR=4170) ISUBALL
	IF(ISUBALL .NE. 1 .AND. ISUBALL .NE. 0) GO TO 4170


	IF(ISUBALL .EQ. 1) THEN

	 NSUB = NSUBTOT

C  PUT ALL SUBJECT NOS. INTO THE VECTOR, IPATVEC.



	 DO I=1,NSUB
	  IPATVEC(I) = I
	 END DO


	ENDIF


     	IF(ISUBALL .EQ. 0) THEN

 4180	 WRITE(*,2122)
 2122    FORMAT(/' ENTER 1 IF YOU WANT TO SELECT WHICH PATIENTS ARE TO'/
     1' 	BE INCLUDED IN THE ANALYSIS; '/
     2' ENTER 2 IF YOU WANT TO SELECT WHICH PATIENTS ARE NOT TO BE'/
     3'		INCLUDED IN THE ANALYSIS: ')
	 READ(*,*,ERR= 4180) IINCLUDE
	 IF(IINCLUDE .NE. 1 .AND. IINCLUDE .NE. 2) GO TO 4180


C  IF IINCLUDE = 1, THE NOS. THE USERS ENTERS BELOW WILL BE THE INDICES
C  OF THE SUBJECTS TO BE INCLUDED IN THE ANALYSIS. IF IINCLUDE = 2, THE

C  NOS. ENTERED WILL BE THE INDICES OF THE SUBJECTS TO BE EXCLUDED IN
C  THE ANALYSIS.

	  NSUBB = 0
	  NUMCUR = 0


C  NSUBB WILL BE THE NO. OF SUBJECTS SELECTED BY THE USER. IT IS
C  INITIALIZED AS 0, AND WILL GROW AS THE USER ENTERS THE PATIENT NOS.
C  TO BE INCLUDED (IF IINCLUDE = 1) OR EXCLUDED (IF IINCLUDE = 2) IN THE
C  ANALYSIS.

C  NUMCUR IS THE INDEX OF THE HIGHEST PATIENT NO. ENTERED SO FAR.


 4200	   IF(IINCLUDE .EQ. 1) WRITE(*,2124)
 2124      FORMAT(/' ON EACH LINE, ENTER A SUBJECT OR A RANGE OF '/
     1' SUBJECTS TO BE INCLUDED IN THE ANALYSIS. YOU MAY ENTER '/
     2' MULTIPLE SUBJECTS USING HYPHENS, COMMAS, AND SPACES. FOR'/
     3' EXAMPLE, 17 - 28 INDICATES SUBJECTS 17 THROUGH 28; '/



     4'          17,28 INDICATES SUBJECTS 17 AND 28;'/
     5'          17 28 INDICATES SUBJECTS 17 AND 28. '//
     6' RESTRICTIONS: 1. ON EACH LINE, USE NO MORE THAN 70 CHARACTERS.'/
     7'		      2. PATIENT NOS., OR RANGES OF PATIENT NOS.,'/
     8'		         MUST BE LISTED IN ASCENDING ORDER.'//
     9' ENTER 0 WHEN YOU ARE FINISHED ENTERING PATIENT NOS.'//)

	IF(IINCLUDE .EQ. 2) WRITE(*,2123)
 2123      FORMAT(/' ON EACH LINE, ENTER A SUBJECT OR A RANGE OF '/

     1' SUBJECTS TO BE EXCLUDED IN THE ANALYSIS. YOU MAY ENTER '/

     2' MULTIPLE SUBJECTS USING HYPHENS, COMMAS, AND SPACES. FOR'/
     3' EXAMPLE, 17 - 28 INDICATES SUBJECTS 17 THROUGH 28; '/
     4'          17,28 INDICATES SUBJECTS 17 AND 28;'/

     5'          17 28 INDICATES SUBJECTS 17 AND 28. '//
     6' RESTRICTIONS: 1. ON EACH LINE, USE NO MORE THAN 70 CHARACTERS.'/
     7'		      2. PATIENT NOS., OR RANGES OF PATIENT NOS.,'/
     8'		         MUST BE LISTED IN ASCENDING ORDER.'//
     9' ENTER 0 WHEN YOU ARE FINISHED ENTERING PATIENT NOS.'//)

 4210	   READ(*,3,ERR=4200) READLINE

C  CALL SUBROUTINE GETNUMS TO UPDATE NSUBB AND IPATVECC, WHERE IPATVECC
C  IS THE VECTOR WHICH CONTAINS THE PATIENT NOS. TO BE INCLUDED IN THE
C  ANALYSIS IF IINCLUDE = 1, AND THE PATIENT NOS. TO BE EXCLUDED IF
C  IINCLUDE = 2.

C  NOTE THAT ISTOP RETURNS AS 0 IF THE USER IS FINISHED ENTERING
C  PATIENT NOS; IT RETURNS AS -1 IF THE USER HAS ENTERED A CONFLICTING
C  SET OF PATIENT NOS. (SEE RESTRICTION ABOVE) OR A PATIENT NO. LARGER
C  THAN NSUBTOT (THE MAXIMUM ALLOWABLE NO. OF SUBJECTS); AND IT RETURNS
C  AS 1 IF THE USER HAS CORRECTLY ENTERED PATIENT DATA AND WANTS TO
C  CONTINUE ENTERING OTHER NOS.

	   CALL GETNUMS(IINCLUDE,READLINE,NSUBB,NSUBTOT,NUMCUR,ISTOP,
     1                  MAXSUB,IPATVECC)
	   IF(ISTOP .EQ. -1) GO TO 4200
	   IF(ISTOP .EQ. 1) GO TO 4210

C  TO GET TO THIS POINT, ISTOP = 0 --> USER HAS STOPPED ENTERING
C  PATIENT NOS.

C  IF IINCLUDE = 1, SET NSUB = NSUBB, THE NO. OF PATIENTS TO BE INCLUDED

C  IN THE ANALYSIS, AND SET IPATVEC = IPATVECC (WHICH IS THE VECTOR OF
C  INDICES OF THESE PATIENTS).

C  IF IINCLUDE = 2, SET NSUB = NSUBTOT - NSUBB (SINCE NSUBB IS THE NO.
C  OF PATIENTS TO BE EXCLUDED), AND SET IPATVEC TO CONTAIN THE INDICES

C  WHICH ARE NOT IN IPATVECC.

	IF(IINCLUDE .EQ. 1) THEN
	 NSUB = NSUBB
	  DO I = 1,NSUB
	   IPATVEC(I) = IPATVECC(I)
	  END DO
	ENDIF


	IF(IINCLUDE .EQ. 2) THEN

	 NSUB = NSUBTOT - NSUBB
	 INDPAT = 1
	 NEXT = 0

	 DO I = 1,NSUBTOT

	  IF(I .NE. IPATVECC(INDPAT)) THEN
	   NEXT = NEXT + 1
	   IPATVEC(NEXT) = I
	  ENDIF

	  IF(I .EQ. IPATVECC(INDPAT)) INDPAT = INDPAT + 1

	 END DO

	ENDIF


	ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(ISUBALL .EQ. 0)  CONDITION.


C  NOW THE SUBJECT INDICES FOR THOSE PATIENTS TO BE ANALYZED IN
C  THIS RUN ARE IN IPATVEC(I),I=1,NSUB.

	RETURN
	END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
	SUBROUTINE GETNUMS(IINCLUDE,READLINE,NSUBB,NSUBTOT,NUMCUR,ISTOP,


     1                  MAXSUB,IPATVECC)

	DIMENSION IPATVECC(MAXSUB)

	CHARACTER READLINE*1000


C  SUBROUTINE GETNUMS IS CALLED BY GETIPAT AND GETIPATF (OVER AND OVER)
C  TO ESTABLISH NSUBB AND IPATVECC, WHERE NSUBB IS THE NO. OF SUBJECTS
C  TO BE INCLUDED (IF IINCLUDE = 1) OR EXCLUDED (IF IINCLUDE = 2) IN THE
C  ANALYSIS, AND IPATVECC IS THE VECTOR WHICH CONTAINS THE CORRESPONDING
C  PATIENT NOS. EACH CALL TO GETNUMS EITHER ADDS TO THE VALUES IN
C  IPATVECC (AND INCREASES NSUBB) OR STOPS THE PROCESS.


C  NOTE THAT ISTOP RETURNS AS 0 IF THE USER IS FINISHED ENTERING
C  PATIENT NOS; IT RETURNS AS -1 IF THE USER HAS ENTERED A CONFLICTING
C  SET OF PATIENT NOS. (EACH PATIENT NO. OR RANGE OF NUMBERS MUST BE
C  GREATER THAN ANY PATIENT NO. ALREADY ENTERED ... THE LARGEST PATIENT

C  NO. ENTERED SO FAR IS NUMCUR) OR A PATIENT NO. LARGER THAN NSUBTOT
C  (THE MAXIMUM ALLOWABLE NO. OF SUBJECTS); AND IT RETURNS AS 1 IF THE
C  USER HAS CORRECTLY ENTERED PATIENT DATA AND WANTS TO CONTINUE
C  ENTERING OTHER NOS.


	ISTOP = 1

C  CHECK TO SEE IF THIS IS A BLANK LINE. IF SO, RETURN ISTOP = -1
C  WITH A MESSAGE TO THE USER.

	DO J = 1,70
	 IF(READLINE(J:J) .NE. ' ') GO TO 10
	END DO

C  TO GET HERE --> READLINE IS COMPLETELY BLANK.

	IF(NSUBB .EQ. 0) WRITE(*,1)
    1   FORMAT(/' YOU HAVE ENTERED A BLANK LINE. PLEASE ENTER SUBJECT'/
     1' NOS. AS INDICATED BELOW.' /)

	IF(NSUBB .GT. 0) WRITE(*,2) NSUBB,NUMCUR
    2   FORMAT(/' YOU HAVE ENTERED A BLANK LINE. THE LAST ACCEPTED '/
     1' SUBJECT NO. IS ',I4//
     3' PLEASE ENTER SUBJECT NOS. AS INDICATED BELOW. ')
	ISTOP = -1
	RETURN



   10   CONTINUE

C  CHECK TO SEE IF THIS LINE HAS JUST A 0 ON IT. IF SO, RETURN ISTOP
C  = 0, UNLESS NSUBB = 0 AND IINCLUDE = 1, IN WHICH CASE THIS IS AN

C  ERROR. SIMPLY CHECK THE FIRST NON-BLANK CHARACTER (THERE MUST BE ONE
C  SINCE IF THE LINE IS COMPLETELY BLANK, THE CODE ABOVE ABOVE WOULD
C  HAVE DETECTED IT AND RETURNED CONTROL TO THE CALLING ROUTINE) AND
C  SEE IF a. IT IS A 0, AND b. EVERY OTHER CHARACTER IS A BLANK. IF
C  a. AND b. ARE TRUE, THE LINE JUST HAS A 0 IN IT. OTHERWISE NOT.

	DO J = 1,70
	 IF(READLINE(J:J) .NE. ' ') GO TO 20
	END DO

   20   ISTART = J
	IF(READLINE(ISTART:ISTART) .NE. '0') GO TO 30


	DO I = ISTART+1,70
	 IF(READLINE(I:I) .NE. ' ') GO TO 30

	END DO

C  TO GET HERE --> READLINE HAS JUST A 0 ON IT AND NOTHING ELSE.

C  IF THE USER HAS ENTERED A 0 WITH NSUBB = 0 (I.E., HE HAS NOT
C  ENTERED PREVIOUS SUBJECT NOS.), THIS IS OK IF IINCLUDE = 2 (SINCE

C  IT IS OK TO EXCLUDE 0 PATIENTS), BUT IT IS NOT OK IF IINCLUDE = 1
C  (SINCE THIS WOULD MEAN THE ANALYSIS WOULD BE ON 0 SUBJECTS).

	IF(IINCLUDE .EQ. 1 .AND. NSUBB .EQ. 0) THEN
	 WRITE(*,3)
    3    FORMAT(/' YOU MUST ENTER AT LEAST ONE SUBJECT NO. TO BE'/
     1' ANALYZED. ')

	 ISTOP = -1
	 RETURN
	ENDIF

	IF(IINCLUDE .EQ. 2 .OR. NSUBB .GT. 0) THEN
	 ISTOP = 0
	 RETURN
	ENDIF


   30   CONTINUE


C  TO GET TO THIS POINT MEANS READLINE HAS A POTENTIAL NO. BEGINNING
C  AT ENTRY ISTART. IF THIS IS A LEGITIMATE NO., IT ENDS THE ENTRY
C  BEFORE THE NEXT SPACE, COMMA, DASH, WHICHEVER COMES FIRST.

     	DO I = ISTART+1,70

	 IF(READLINE(I:I) .EQ. ' ' .OR. READLINE(I:I) .EQ. ',' .OR.
     1      READLINE(I:I) .EQ. '-') GO TO 40
	END DO

   40   IEND = I-1


C  CALL ROUTINE GETSUB WHICH OBTAINS THE SUBJECT NO. FROM THE
C  CHARACTERS IN READLINE(ISTART:IEND).

	CALL GETSUB(READLINE,ISTART,IEND,ISUB,IERROR)

C  IF IERROR RETURNS AS -1, IT MEANS THE USER HAS ENTERED A NON-NUMERIC

C  CHARACTER. IN THIS CASE, PRINT AN ERROR MESSAGE AND RETURN.

	IF(IERROR .EQ. -1) THEN
	 WRITE(*,7) NUMCUR
    7    FORMAT(/' YOU HAVE ENTERED AN INVALID CHARACTER; THE LAST'/
     1' ACCEPTED PATIENT NUMBER IS ',I4//
     2' PLEASE ENTER SUBJECT NOS. AS INDICATED BELOW. ')
	 ISTOP = -1
	 RETURN
	ENDIF


C  IF ISUB IS .LE. NUMCUR, THE LAST (AND HIGHEST PATIENT NO. ENTERED
C  PREVIOUSLY), WRITE AN ERROR MESSAGE TO THE USER AND RETURN.
C  SIMILARLY, IF ISUB .GE. NSUBTOT.


	IF(ISUB .LE. NUMCUR) THEN
	 WRITE(*,4) ISUB,NUMCUR
    4    FORMAT(/' YOU MAY NOT ENTER A SUBJECT NO. (',I4,' ) WHICH IS '/
     1' LESS THAN OR EQUAL TO A PREVIOUSLY ENTERED SUBJECT NO.,'/
     2' IN PARTICULAR ',I4,' WHICH IS THE LAST ACCEPTED SUBJECT NO.'//
     3' PLEASE ENTER SUBJECT NOS. AS INDICATED BELOW. ')
	 ISTOP = -1
	 RETURN
	ENDIF


	IF(ISUB .GT. NSUBTOT) THEN
	 WRITE(*,6) ISUB,NSUBTOT,NUMCUR
    6    FORMAT(/' YOU MAY NOT ENTER A SUBJECT NO. (',I4,' ) WHICH'/
     1' IS GREATER THAN THE NO. OF SUBJECTS IN YOUR DATA FILE = ',I4/
     2' THE LAST ACCEPTED SUBJECT NO. IS ',I4//
     3' PLEASE ENTER SUBJECT NOS. AS INDICATED BELOW. ')
	 ISTOP = -1
	 RETURN
	ENDIF

C  TO GET TO THIS POINT, THE PATIENT NO., ISUB, IS LEGITIMATE. I.E.,
C  IT IS .GT. NUMCUR AND .LE. NSUBTOT. THERE ARE 4 POSSIBILITIES:

C  1. IF THERE ARE NO OTHER ENTRIES IN READLINE PAST THIS POINT,
C  ISUB IS A SINGLE PATIENT NO.
C  2. IF THE NEXT NON-BLANK ENTRY IN READLINE IS A COMMA OR ANOTHER
C  NUMBER, ISUB IS A SINGLE PATIENT NO.
C  3. IF THE NEXT NON-BLANK ENTRY IN READLINE IS A DASH, ISUB IS THE
C  START OF A PATIENT RANGE.
C  4. IF THE NEXT NON-BLANK ENTRY IN READLINE IS ANOTHER CHARACTER
C  (I.E., NOT A NUMBER, DASH, OR COMMA), THE LINE HAS BEEN ENTERED
C  INCORRECTLY BY THE USER.


C  CHECK FOR NO. 1. ABOVE ...

	DO I = IEND+1,70
	 IF(READLINE(I:I) .NE. ' ') GO TO 50
	END DO

C  TO GET TO THIS POINT, ISUB IS AN INDIVIDUAL SUBJECT NO., AND THE
C  LAST NO. ON THE LINE. INCREASE NSUBB, NUMCUR, AND PUT THIS SUBJECT
C  NO. INTO IPATVECC BEFORE RETURNING.

	NUMCUR = ISUB
	NSUBB = NSUBB + 1
	IPATVECC(NSUBB) = ISUB
	RETURN


   50   CONTINUE

C  CHECK FOR NOS. 2,3, OR 4 (SEE ABOVE).


C  TO GET TO THIS POINT, THERE IS AT LEAST ONE CHARACTER ENTRY AFTER
C  ISUB, AND THE FIRST OCCURS AT LOCATION I. IF THIS CHARACTER IS A

C  COMMA THEN ISUB IS AN INDIVIDUAL SUBJECT NO.

	IF(READLINE(I:I) .EQ. ',') THEN

	 NUMCUR = ISUB
 	 NSUBB = NSUBB + 1
	 IPATVECC(NSUBB) = ISUB


C  CHECK TO SEE IF THERE IS ANOTHER ENTRY ON THIS LINE. IF SO,
C  RETURN CONTROL TO LABEL 30 AND CONTINUE CHECKING FOR OTHER NOS. IF
C  NOT, IT MEANS THE USER HAS ENDED THE LINE WITH A COMMA ... WHICH
C  IS ASSUMED TO BE SUPERFLOUS.


	 DO J = I+1,70
	  IF(READLINE(J:J) .NE. ' ') GO TO 60
	 END DO


	 RETURN

   60    ISTART = J
	 GO TO 30

	ENDIF


C  TO GET TO THIS POINT, THERE IS AT LEAST ONE CHARACTER ENTRY AFTER
C  ISUB, AND THE FIRST OCCURS AT LOCATION I ... AND THIS ENTRY IS NOT
C  A COMMA. CHECK TO SEE IF IT IS ANOTHER NUMBER. IN THIS CASE, ISUB
C  IS AN INDIVIDUAL SUBJECT NO.

	INUM = 0
	IF(READLINE(I:I) .EQ. '0') INUM = 1
	IF(READLINE(I:I) .EQ. '1') INUM = 1
	IF(READLINE(I:I) .EQ. '2') INUM = 1
	IF(READLINE(I:I) .EQ. '3') INUM = 1


	IF(READLINE(I:I) .EQ. '4') INUM = 1
	IF(READLINE(I:I) .EQ. '5') INUM = 1
	IF(READLINE(I:I) .EQ. '6') INUM = 1
	IF(READLINE(I:I) .EQ. '7') INUM = 1
	IF(READLINE(I:I) .EQ. '8') INUM = 1
	IF(READLINE(I:I) .EQ. '9') INUM = 1

	IF(INUM .EQ. 1) THEN
	 NUMCUR = ISUB
 	 NSUBB = NSUBB + 1
	 IPATVECC(NSUBB) = ISUB

C  RETURN CONTROL TO LABEL 30 AND CONTINUE CHECKING FOR OTHER NOS.
C  STARTING WITH LOCATION I.

         ISTART = I
	 GO TO 30


	ENDIF


C  TO GET TO THIS POINT, THERE IS AT LEAST ONE CHARACTER ENTRY AFTER
C  ISUB, AND THE FIRST OCCURS AT LOCATION I ... AND THIS ENTRY IS NOT

C  A COMMA OR A NUMBER. CHECK TO SEE IF IT IS A DASH. IN THIS CASE,
C  ISUB IS THE FIRST NO. IN A RANGE OF PATIENT NUMBERS.

	IF(READLINE(I:I) .EQ. '-') THEN

C  STORE ISUB INTO NUMCUR1, BUT NOT NUMCUR. IN CASE THE USER
C  HAS NOT ENTERED A LEGITIMATE NO. AFTER THE DASH, KEEP THE PREVIOUS
C  VALUE OF NUMCUR (THE LAST PATIENT INDEX PUT INTO IPATVECC) INTACT.


	 NUMCUR1 = ISUB


C  READ UNTIL THE NEXT NON-BLANK CHARACTER, WHICH SHOULD BE THE
C  BEGINNING OF THE NUMBER WHICH ENDS THE RANGE.

	 DO J = I+1,70
	  IF(READLINE(J:J) .NE. ' ') GO TO 70

	 END DO

C  TO GET TO THIS POINT MEANS THE USER ENDED A LINE WITH A DASH, WHICH

C  IS NOT ALLOWED. WRITE AN ERROR MESSAGE AND RETURN.

	 WRITE(*,8) NUMCUR
    8    FORMAT(/' YOU MAY NOT END A LINE WITH A DASH. THE LAST '/
     1' PATIENT NO. ASSUMED TO BE ENTERED IS ',I4//
     3' PLEASE ENTER SUBJECT NOS. AS INDICATED BELOW. ')
	 ISTOP = -1
	 RETURN

   70   ISTART = J

C  TO GET TO THIS POINT, THERE IS AN ENTRY IN LOCATION ISTART, WHICH

C  SHOULD BE THE BEGINNING OF THE ENDING PATIENT NO. OF A RANGE OF
C  PATIENT NOS. THIS NUMBER ENDS THE ENTRY BEFORE A SPACE OR A
C  COMMA.

     	DO K = ISTART+1,70
	 IF(READLINE(K:K) .EQ. ' ' .OR. READLINE(K:K) .EQ. ',')
     1    GO TO 80
	END DO

   80   IEND = K-1

C  CALL ROUTINE GETSUB WHICH OBTAINS THE SUBJECT NO. FROM THE
C  CHARACTERS IN READLINE(ISTART:IEND).

	CALL GETSUB(READLINE,ISTART,IEND,ISUB,IERROR)

C  IF IERROR RETURNS AS -1, IT MEANS THE USER HAS ENTERED A NON-NUMERIC
C  CHARACTER. IN THIS CASE, PRINT AN ERROR MESSAGE AND RETURN.

	IF(IERROR .EQ. -1) THEN
	 WRITE(*,7) NUMCUR
	 ISTOP = -1
	 RETURN

	ENDIF

C  IF ISUB IS .LE. NUMCUR1 (THE BEGINNING NO. IN THIS RANGE), WRITE AN
C  ERROR MESSAGE TO THE USER AND RETURN. SIMILARLY, IF ISUB .GE.
C  NSUBTOT


	IF(ISUB .LE. NUMCUR1) THEN
	 WRITE(*,9) NUMCUR
    9    FORMAT(/' YOU MAY NOT ENTER A RANGE OF SUBJECT NOS. WITH THE'/
     1' ENDING NO. LESS THAN OR EQUAL TO THE BEGINNING NO. THE LAST'/
     2' ACCEPTED SUBJECT NO. IS ',I4//
     3' PLEASE ENTER SUBJECT NOS. AS INDICATED BELOW. ')
	 ISTOP = -1
	 RETURN
	ENDIF

	IF(ISUB .GT. NSUBTOT) THEN
	 WRITE(*,6) ISUB,NSUBTOT,NUMCUR
	 ISTOP = -1
	 RETURN
	ENDIF


C  TO GET TO THIS POINT MEANS THE USER HAS CORRECTLY ENTERED A RANGE
C  OF PATIENT NOS. FROM NUMCUR1 TO ISUB. UPDATE NSUBB, NUMCUR, AND
C  IPATVECC.

	 NUMCUR = ISUB
	 NN = NSUBB
 	 NSUBB = NSUBB + (NUMCUR - NUMCUR1) + 1


	 NONEW = 0
	 DO K = NN+1,NSUBB
	  NONEW = NONEW + 1
	  IPATVECC(K) = NUMCUR1 - 1 + NONEW
	 END DO

C  CHECK TO SEE IF THERE IS ANOTHER CHARACTER ON THE LINE AFTER
C  LOCATION IEND (IGNORE A COMMA AT THIS POINT, SINCE IT IS POSSIBLE
C  THAT THE USER HAS PUT IN A COMMA AT THE END OF HIS SUBJECT RANGE).
C  IF SO, RETURN CONTROL TO LABEL 30 AND CONTINUE CHECKING FOR OTHER
C  NOS. IF NOT, RETURN.

	 DO J = IEND+1,70
	  IF(READLINE(J:J) .NE. ' ' .AND. READLINE(J:J) .NE. ',' )
     1    GO TO 90
	 END DO


	 RETURN

   90    ISTART = J
	 GO TO 30

	ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(READLINE(I:I) .EQ. '-')  CONDITION.


C  TO GET TO THIS POINT, THERE IS AT LEAST ONE CHARACTER ENTRY AFTER
C  ISUB, AND THE FIRST OCCURS AT LOCATION I ... AND THIS ENTRY IS NOT
C  A COMMA, A NUMBER, OR A DASH, WHICH MEANS IT IS AN ERRONEOUS ENTRY.
C  WRITE AN ERROR MESSAGE TO THE USER AND RETURN.

	WRITE(*,7) NUMCUR
	ISTOP = -1


	RETURN
	END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
	SUBROUTINE GETSUB(READLINE,ISTART,IEND,ISUB,IERROR)
	CHARACTER READLINE*1000

C  THIS ROUTINE, CALLED BY GETNUMS, OBTAINS THE SUBJECT NO., ISUB,
C  FROM THE CHARACTERS IN READLINE(ISTART:IEND).


    3   FORMAT(A1000)


	IERROR = 0
  	ISIZE = IEND-ISTART

	ISUB = 0
	 DO K=ISTART,IEND
	  IVAL = -9
	  IF(READLINE(K:K) .EQ. '0') IVAL = 0
	  IF(READLINE(K:K) .EQ. '1') IVAL = 1
	  IF(READLINE(K:K) .EQ. '2') IVAL = 2
	  IF(READLINE(K:K) .EQ. '3') IVAL = 3
	  IF(READLINE(K:K) .EQ. '4') IVAL = 4
	  IF(READLINE(K:K) .EQ. '5') IVAL = 5
	  IF(READLINE(K:K) .EQ. '6') IVAL = 6
	  IF(READLINE(K:K) .EQ. '7') IVAL = 7
	  IF(READLINE(K:K) .EQ. '8') IVAL = 8
	  IF(READLINE(K:K) .EQ. '9') IVAL = 9

	  IF(IVAL .EQ. -9) THEN
	   IERROR = -1
	   RETURN
	  ENDIF

	  ISUB = ISUB + IVAL*10**ISIZE
	  ISIZE = ISIZE-1

	 END DO

	RETURN
	END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

C
	SUBROUTINE WRITEPAT(NSUB,MAXSUB,IPATVEC)
	DIMENSION IPATVEC(MAXSUB)

C  THIS ROUTINE WRITES THE PATIENT NOS. TO THE SCREEN.


	WRITE(*,*)
	ILINES = 1

C  ILINES IS THE RUNNING TOTAL OF LINES PRINTED TO THE SCREEN SINCE THE
C  LAST PAUSE. EVERYTIME IT GETS TO 15, PAUSE THE OUTPUT.


C  INSTEAD OF WRITING OUT THE PATIENT NOS. ONE TO A LINE, WRITE OUT
C  CONTINUOUS SETS ON EACH LINE. E.G., IF SUBJECTS 1,4,5,6,9,10,12 ARE


C  TO BE WRITTEN OUT, WRITE 1 ON THE 1ST LINE, 4 - 6 ON THE 2ND LINE,
C  9 - 10 OR THE 3RD LINE, AND 12 ON THE 4TH.

C  NEXTIND IS THE INDEX OF THE NEXT SUBJECT NO. TO BE WRITTEN.

	NEXTIND = 0


   50   NEXTIND = NEXTIND + 1

C  IF NEXTIND .GT. NSUB, THE NOS. HAVE ALL BEEN WRITTEN OUT, SO STOP
C  THE WRITING.

	IF(NEXTIND .GT. NSUB) GO TO 100

C  ESTABLISH THE NOS. TO BE WRITTEN ON THE NEXT LINE. THE FIRST NO.
C  WILL BE IPATVEC(NEXTIND)


	IFIRST = IPATVEC(NEXTIND)

C  IF NEXTIND = NSUB, THIS IS THE LAST PATIENT NO. TO BE WRITTEN OUT.

	IF(NEXTIND .EQ. NSUB) THEN
	 WRITE(*,222) IFIRST
	 ILINES=ILINES+1
	  IF(ILINES .EQ. 20) THEN


	   ILINES=0

	  ENDIF
  222    FORMAT(1X,I5)

	 GO TO 100
	ENDIF

C  IF THE NEXT PATIENT NO. IN IPATVEC = IFIRST + 1, THEN IFIRST IS THE
C  FIRST OF A STRING OF CONSECUTIVE NUMBERS (FIND THE LAST NO. IN THIS
C  STRING AND WRITE THE STRING OUT). OTHERWISE, IFIRST WILL BE WRITTEN

C  OUT BY ITSELF.

	IF(IPATVEC(NEXTIND+1) .NE. IFIRST + 1) THEN
	 WRITE(*,222) IFIRST
	 ILINES=ILINES+1
	  IF(ILINES .EQ. 20) THEN

	   ILINES=0
	  ENDIF

	 GO TO 50
	ENDIF

C  SET ILAST = THE LAST NO. IN THE STRING USING THE FOLLOWING DO LOOP.

	ILAST = IPATVEC(NEXTIND+1)
	NEXT = NEXTIND+1

	DO I = NEXTIND+2,NSUB
	 IF(IPATVEC(I) .NE. ILAST + 1) GO TO 80
	 ILAST = IPATVEC(I)
	 NEXT = I
	END DO


   80	WRITE(*,221) IFIRST,ILAST
  221   FORMAT(1X,I5,'   - ',I5)
	ILINES=ILINES+1
	 IF(ILINES .EQ. 20) THEN

	  ILINES=0
	 ENDIF

C  THE INDEX OF THE LAST NO. WRITTEN OUT IS NEXT.

	NEXTIND = NEXT

	GO TO 50

  100   RETURN
	END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
	SUBROUTINE WRITEPT2(IFILE,NSUB,MAXSUB,IPATVEC)
	DIMENSION IPATVEC(MAXSUB)


C  THIS ROUTINE WRITES THE PATIENT NOS. TO FILE IFILE.

C  INSTEAD OF WRITING OUT THE PATIENT NOS. ONE TO A LINE, WRITE OUT


C  CONTINUOUS SETS ON EACH LINE. E.G., IF SUBJECTS 1,4,5,6,9,10,12 ARE
C  TO BE WRITTEN OUT, WRITE 1 ON THE 1ST LINE, 4 - 6 ON THE 2ND LINE,
C  9 - 10 OR THE 3RD LINE, AND 12 ON THE 4TH.

C  NEXTIND IS THE INDEX OF THE NEXT SUBJECT NO. TO BE WRITTEN.


	NEXTIND = 0


   50   NEXTIND = NEXTIND + 1

C  IF NEXTIND .GT. NSUB, THE NOS. HAVE ALL BEEN WRITTEN OUT, SO STOP
C  THE WRITING.

	IF(NEXTIND .GT. NSUB) GO TO 100


C  ESTABLISH THE NOS. TO BE WRITTEN ON THE NEXT LINE. THE FIRST NO.
C  WILL BE IPATVEC(NEXTIND)

	IFIRST = IPATVEC(NEXTIND)

C  IF NEXTIND = NSUB, THIS IS THE LAST PATIENT NO. TO BE WRITTEN OUT.

	IF(NEXTIND .EQ. NSUB) THEN
	 IF(IFILE .EQ. 27) WRITE(27,222) IFIRST
	 IF(IFILE .EQ. 29) WRITE(29,222) IFIRST
  222    FORMAT(1X,I5)
	 GO TO 100
	ENDIF

C  IF THE NEXT PATIENT NO. IN IPATVEC = IFIRST + 1, THEN IFIRST IS THE
C  FIRST OF A STRING OF CONSECUTIVE NUMBERS (FIND THE LAST NO. IN THIS
C  STRING AND WRITE THE STRING OUT). OTHERWISE, IFIRST WILL BE WRITTEN
C  OUT BY ITSELF.

	IF(IPATVEC(NEXTIND+1) .NE. IFIRST + 1) THEN
	 IF(IFILE .EQ. 27) WRITE(27,222) IFIRST
	 IF(IFILE .EQ. 29) WRITE(29,222) IFIRST
	 GO TO 50
	ENDIF

C  SET ILAST = THE LAST NO. IN THE STRING USING THE FOLLOWING DO LOOP.

	ILAST = IPATVEC(NEXTIND+1)
	NEXT = NEXTIND+1

	DO I = NEXTIND+2,NSUB
	 IF(IPATVEC(I) .NE. ILAST + 1) GO TO 80
	 ILAST = IPATVEC(I)
	 NEXT = I
	END DO




   80	IF(IFILE .EQ. 27) WRITE(27,221) IFIRST,ILAST
   	IF(IFILE .EQ. 29) WRITE(29,221) IFIRST,ILAST
  221   FORMAT(1X,I5,'   - ',I5)

C  THE INDEX OF THE LAST NO. WRITTEN OUT IS NEXT.


	NEXTIND = NEXT

	GO TO 50


  100   RETURN
	END
C

CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
	SUBROUTINE GETIPATF(IFILE,NSUBTOT,NSUB,MAXSUB,
     1   IPATVEC,IERRR)
	DIMENSION IPATVEC(MAXSUB)
	CHARACTER READLINE*1000
     


C  SUBROUTINE GETIPATF IS CALLED BY MAIN TO OBTAIN THE INDICES OF

C  THE "ACTIVE" SUBJECTS, IPATVEC(I),I=1,NSUB, FOR THIS RUN. THESE
C  INDICES ARE OBTAINED FROM FILE IFILE.

    3   FORMAT(A1000)

	NSUBB = 0
	NUMCUR = 0

C  NSUBB WILL BE THE NO. OF SUBJECTS SELECTED BY THE USER. IT IS
C  INITIALIZED AS 0, AND WILL GROW AS EACH LINE OF THE FILE IS READ.

C  NUMCUR IS THE INDEX OF THE HIGHEST PATIENT NO. ENTERED SO FAR.

C  NOTE THAT EACH LINE CONTAINS EITHER A SUBJECT NO. OR A RANGE OF

C  SUBJECT NOS. TO BE INCLUDED IN THE ANALYSIS. MULTIPLE SUBJECTS
C  CAN BE ENTERED USING COMMAS, SPACES AND/OR HYPHENS. FOR EXAMPLE,
C  2, 17 - 28 INDICATES SUBJECTS 2 AND 17 THROUGH 28;

C  17,28 INDICATES SUBJECTS 17 AND 28;
C  17 28 INDICATES SUBJECTS 17 AND 28.

C  RESTRICTIONS: 1. ON EACH LINE, USE NO MORE THAN 70 CHARACTERS;
C                2. PATIENT NOS., OR RANGES OF PATIENT NOS.
C                   MUST BE LISTED IN ASCENDING ORDER.


C  A LINE WITH JUST A 0 --> END OF THE LIST OF SUBJECT NOS.

 4210	IF(IFILE .EQ. 23) READ(23,3,ERR=4200) READLINE
	IF(IFILE .EQ. 25) READ(25,3,ERR=4200) READLINE

C  CALL SUBROUTINE GETNUMSF TO UPDATE NSUBB AND IPATVEC, WHERE IPATVEC
C  IS THE VECTOR WHICH CONTAINS THE PATIENT NOS. TO BE INCLUDED IN THE
C  ANALYSIS.

C  NOTE THAT ISTOP RETURNS AS 0 TO INDICATE THE END OF THE LIST OF
C  PATIENT NOS; IT RETURNS AS -1 IF THERE IS A CONFLICT IN THE LIST
C  (SEE RESTRICTION ABOVE) OR A PATIENT NO. LARGER THAN NSUBTOT
C  (THE MAXIMUM ALLOWABLE NO. OF SUBJECTS) HAS BEEN READ IN; AND IT

C  RETURNS AS 1 IF THERE ARE MORE LINES TO BE READ IN.

	CALL GETNUMSF(1,READLINE,NSUBB,NSUBTOT,NUMCUR,ISTOP,
     1                  MAXSUB,IPATVEC)
	IF(ISTOP .EQ. -1) GO TO 4200
	IF(ISTOP .EQ. 1) GO TO 4210

C  TO GET TO THIS POINT, ISTOP = 0 --> USER HAS STOPPED ENTERING
C  PATIENT NOS.

C  CHECK THAT NSUB, AS INPUT TO THIS ROUTINE (FROM MAIN) IS THE SAME
C  AS NSUBB, AS OBTAINED FROM THE LIST OF SUBJECTS TO BE INCLUDED IN
C  THE ANALYSIS. IF NOT, TELL USER AND RETURN IERRR = -1 SO THE USER
C  CAN MAKE A CORRECTION.

	IF(NSUB .EQ. NSUBB) THEN
	 IERRR = 0
	 RETURN
	ENDIF

	IF(NSUB .NE. NSUBB) THEN
         WRITE(*,2)
    2   FORMAT(//' THERE WAS AN ERROR IN THE READING OF PATIENT NOS.'/
     1' TO BE USED FOR THIS ANALYSIS. IN PARTICULAR, THE NO. OF '/
     2' SUBJECTS TO BE INCLUDED IN THE ANALYSIS, AS ENTERED IN THE'/
     3' INSTRUCTION FILE, DOES NOT MATCH THE LIST OF SUBJECT NOS.'/
     4' WHICH FOLLOW THAT NUMBER. PLEASE ENTER DATA VIA THE KEYBOARD'/
     5' OR USING ANOTHER INSTRUCTION FILE.'/)

       IERRR = -1
	 RETURN
	ENDIF

 4200   WRITE(*,1)
    1   FORMAT(//' THERE WAS AN ERROR IN THE READING OF PATIENT NOS.'/
     1' TO BE USED FOR THIS ANALYSIS. PLEASE ENTER DATA VIA THE '/
     2' KEYBOARD OR USING ANOTHER INSTRUCTION FILE.'/)
	IERRR = -1


	RETURN
	END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
	SUBROUTINE GETNUMSF(IINCLUDE,READLINE,NSUBB,NSUBTOT,NUMCUR,
     1    ISTOP,MAXSUB,IPATVECC)
	DIMENSION IPATVECC(MAXSUB)
	CHARACTER READLINE*1000

C  SUBROUTINE GETNUMSF IS CALLED BY GETIPATF (OVER AND OVER)
C  TO ESTABLISH NSUBB AND IPATVECC, WHERE NSUBB IS THE NO. OF SUBJECTS
C  TO BE INCLUDED (IF IINCLUDE = 1) OR EXCLUDED (IF IINCLUDE = 2) IN THE
C  ANALYSIS, AND IPATVECC IS THE VECTOR WHICH CONTAINS THE CORRESPONDING
C  PATIENT NOS. EACH CALL TO GETNUMSF EITHER ADDS TO THE VALUES IN
C  IPATVECC (AND INCREASES NSUBB) OR STOPS THE PROCESS.

C  NOTE THAT GETNUMSF IS THE SAME AS GETNUMS EXCEPT THAT THE COMMENTS
C  TO THE USER ARE DIFFERENT SINCE THIS ROUTINE IS CALLED BY GETIPATF

C  WHICH IS READING A FILE, RATHER THAN KEYBOARD ENTRIES.


C  NOTE THAT ISTOP RETURNS AS 0 IF THE USER IS FINISHED ENTERING
C  PATIENT NOS; IT RETURNS AS -1 IF THE USER HAS ENTERED A CONFLICTING

C  SET OF PATIENT NOS. (EACH PATIENT NO. OR RANGE OF NUMBERS MUST BE
C  GREATER THAN ANY PATIENT NO. ALREADY ENTERED ... THE LARGEST PATIENT
C  NO. ENTERED SO FAR IS NUMCUR) OR A PATIENT NO. LARGER THAN NSUBTOT
C  (THE MAXIMUM ALLOWABLE NO. OF SUBJECTS); AND IT RETURNS AS 1 IF THE

C  USER HAS CORRECTLY ENTERED PATIENT DATA AND WANTS TO CONTINUE
C  ENTERING OTHER NOS.

	ISTOP = 1

C  CHECK TO SEE IF THIS IS A BLANK LINE. IF SO, RETURN ISTOP = -1

C  WITH A MESSAGE TO THE USER.

	DO J = 1,70
	 IF(READLINE(J:J) .NE. ' ') GO TO 10
	END DO


C  TO GET HERE --> READLINE IS COMPLETELY BLANK.

	IF(NSUBB .EQ. 0) WRITE(*,1)
    1   FORMAT(/' THE INSTRUCTION OR OUTPUT FILE HAS AN IMPROPER BLANK'/
     1' LINE IN THE PATIENT NUMBER SECTION. ')
	ISTOP = -1
	RETURN


   10   CONTINUE

C  CHECK TO SEE IF THIS LINE HAS JUST A 0 ON IT. IF SO, RETURN ISTOP
C  = 0, UNLESS NSUBB = 0 AND IINCLUDE = 1, IN WHICH CASE THIS IS AN
C  ERROR. SIMPLY CHECK THE FIRST NON-BLANK CHARACTER (THERE MUST BE ONE
C  SINCE IF THE LINE IS COMPLETELY BLANK, THE CODE ABOVE ABOVE WOULD
C  HAVE DETECTED IT AND RETURNED CONTROL TO THE CALLING ROUTINE) AND
C  SEE IF a. IT IS A 0, AND b. EVERY OTHER CHARACTER IS A BLANK. IF
C  a. AND b. ARE TRUE, THE LINE JUST HAS A 0 IN IT. OTHERWISE NOT.


	DO J = 1,70
	 IF(READLINE(J:J) .NE. ' ') GO TO 20
	END DO

   20   ISTART = J
	IF(READLINE(ISTART:ISTART) .NE. '0') GO TO 30

	DO I = ISTART+1,70
	 IF(READLINE(I:I) .NE. ' ') GO TO 30
	END DO

C  TO GET HERE --> READLINE HAS JUST A 0 ON IT AND NOTHING ELSE.

C  IF THE USER HAS ENTERED A 0 WITH NSUBB = 0 (I.E., HE HAS NOT
C  ENTERED PREVIOUS SUBJECT NOS.), THIS IS OK IF IINCLUDE = 2 (SINCE
C  IT IS OK TO EXCLUDE 0 PATIENTS), BUT IT IS NOT OK IF IINCLUDE = 1
C  (SINCE THIS WOULD MEAN THE ANALYSIS WOULD BE ON 0 SUBJECTS).

	IF(IINCLUDE .EQ. 1 .AND. NSUBB .EQ. 0) THEN
	 WRITE(*,3)
    3    FORMAT(/' THE INSTRUCTION OR OUTPUT FILE HAS AN IMPROPER '/
     1' LINE - WITH JUST A "0" ON IT - IN THE PATIENT NUMBER SECTION.')
	 ISTOP = -1
	 RETURN
	ENDIF

	IF(IINCLUDE .EQ. 2 .OR. NSUBB .GT. 0) THEN
	 ISTOP = 0
	 RETURN
	ENDIF


   30   CONTINUE


C  TO GET TO THIS POINT MEANS READLINE HAS A POTENTIAL NO. BEGINNING
C  AT ENTRY ISTART. IF THIS IS A LEGITIMATE NO., IT ENDS THE ENTRY

C  BEFORE THE NEXT SPACE, COMMA, DASH, WHICHEVER COMES FIRST.

     	DO I = ISTART+1,70

	 IF(READLINE(I:I) .EQ. ' ' .OR. READLINE(I:I) .EQ. ',' .OR.
     1      READLINE(I:I) .EQ. '-') GO TO 40
	END DO

   40   IEND = I-1

C  CALL ROUTINE GETSUB WHICH OBTAINS THE SUBJECT NO. FROM THE
C  CHARACTERS IN READLINE(ISTART:IEND).

	CALL GETSUB(READLINE,ISTART,IEND,ISUB,IERROR)

C  IF IERROR RETURNS AS -1, IT MEANS THE USER HAS ENTERED A NON-NUMERIC
C  CHARACTER. IN THIS CASE, PRINT AN ERROR MESSAGE AND RETURN.

	IF(IERROR .EQ. -1) THEN
	 WRITE(*,7)
    7    FORMAT(/' THE INSTRUCTION OR OUTPUT FILE HAS AN IMPROPER '/
     1' LINE - WITH AN INVALID CHARACTER ON IT - IN THE PATIENT '/
     2' NUMBER SECTION.')
	 ISTOP = -1
	 RETURN

	ENDIF

C  IF ISUB IS .LE. NUMCUR, THE LAST (AND HIGHEST PATIENT NO. ENTERED
C  PREVIOUSLY), WRITE AN ERROR MESSAGE TO THE USER AND RETURN.
C  SIMILARLY, IF ISUB .GE. NSUBTOT.


	IF(ISUB .LE. NUMCUR) THEN
	 WRITE(*,4) ISUB,NUMCUR
    4    FORMAT(/' THE INSTRUCTION OR OUTPUT FILE HAS AN IMPROPER '/
     1' LINE IN IT IN THE PATIENT NUMBER SECTION.'//
     2' IT HAS A SUBJECT NO. (',I4,' ) WHICH IS LESS THAN OR EQUAL TO '/
     3' A PREVIOUSLY ENTERED SUBJECT NO. (',I4,').')
	 ISTOP = -1
	 RETURN
	ENDIF

	IF(ISUB .GT. NSUBTOT) THEN
	 WRITE(*,6) ISUB,NSUBTOT
    6    FORMAT(/' THE INSTRUCTION OR OUTPUT FILE HAS AN IMPROPER '/
     1' LINE IN IT IN THE PATIENT NUMBER SECTION.'//
     2' IT HAS A SUBJECT NO. (',I4,' ) WHICH IS GREATER THAN THE NO.'/
     3' OF SUBJECTS IN YOUR DATA FILE (',I4,').')
	 ISTOP = -1
	 RETURN
	ENDIF

C  TO GET TO THIS POINT, THE PATIENT NO., ISUB, IS LEGITIMATE. I.E.,
C  IT IS .GT. NUMCUR AND .LE. NSUBTOT. THERE ARE 4 POSSIBILITIES:

C  1. IF THERE ARE NO OTHER ENTRIES IN READLINE PAST THIS POINT,
C  ISUB IS A SINGLE PATIENT NO.
C  2. IF THE NEXT NON-BLANK ENTRY IN READLINE IS A COMMA OR ANOTHER
C  NUMBER, ISUB IS A SINGLE PATIENT NO.

C  3. IF THE NEXT NON-BLANK ENTRY IN READLINE IS A DASH, ISUB IS THE
C  START OF A PATIENT RANGE.
C  4. IF THE NEXT NON-BLANK ENTRY IN READLINE IS ANOTHER CHARACTER
C  (I.E., NOT A NUMBER, DASH, OR COMMA), THE LINE HAS BEEN ENTERED
C  INCORRECTLY BY THE USER.


C  CHECK FOR NO. 1. ABOVE ...


	DO I = IEND+1,70
	 IF(READLINE(I:I) .NE. ' ') GO TO 50
	END DO

C  TO GET TO THIS POINT, ISUB IS AN INDIVIDUAL SUBJECT NO., AND THE
C  LAST NO. ON THE LINE. INCREASE NSUBB, NUMCUR, AND PUT THIS SUBJECT

C  NO. INTO IPATVECC BEFORE RETURNING.

	NUMCUR = ISUB
	NSUBB = NSUBB + 1
	IPATVECC(NSUBB) = ISUB
	RETURN


   50   CONTINUE

C  CHECK FOR NOS. 2,3, OR 4 (SEE ABOVE).

C  TO GET TO THIS POINT, THERE IS AT LEAST ONE CHARACTER ENTRY AFTER
C  ISUB, AND THE FIRST OCCURS AT LOCATION I. IF THIS CHARACTER IS A


C  COMMA THEN ISUB IS AN INDIVIDUAL SUBJECT NO.

	IF(READLINE(I:I) .EQ. ',') THEN

	 NUMCUR = ISUB
 	 NSUBB = NSUBB + 1
	 IPATVECC(NSUBB) = ISUB

C  CHECK TO SEE IF THERE IS ANOTHER ENTRY ON THIS LINE. IF SO,
C  RETURN CONTROL TO LABEL 30 AND CONTINUE CHECKING FOR OTHER NOS. IF
C  NOT, IT MEANS THE USER HAS ENDED THE LINE WITH A COMMA ... WHICH
C  IS ASSUMED TO BE SUPERFLOUS.

	 DO J = I+1,70
	  IF(READLINE(J:J) .NE. ' ') GO TO 60

	 END DO

	 RETURN

   60    ISTART = J
	 GO TO 30

	ENDIF


C  TO GET TO THIS POINT, THERE IS AT LEAST ONE CHARACTER ENTRY AFTER
C  ISUB, AND THE FIRST OCCURS AT LOCATION I ... AND THIS ENTRY IS NOT
C  A COMMA. CHECK TO SEE IF IT IS ANOTHER NUMBER. IN THIS CASE, ISUB
C  IS AN INDIVIDUAL SUBJECT NO.

	INUM = 0
	IF(READLINE(I:I) .EQ. '0') INUM = 1
	IF(READLINE(I:I) .EQ. '1') INUM = 1
	IF(READLINE(I:I) .EQ. '2') INUM = 1
	IF(READLINE(I:I) .EQ. '3') INUM = 1
	IF(READLINE(I:I) .EQ. '4') INUM = 1
	IF(READLINE(I:I) .EQ. '5') INUM = 1
	IF(READLINE(I:I) .EQ. '6') INUM = 1
	IF(READLINE(I:I) .EQ. '7') INUM = 1
	IF(READLINE(I:I) .EQ. '8') INUM = 1
	IF(READLINE(I:I) .EQ. '9') INUM = 1

	IF(INUM .EQ. 1) THEN
	 NUMCUR = ISUB
 	 NSUBB = NSUBB + 1
	 IPATVECC(NSUBB) = ISUB

C  RETURN CONTROL TO LABEL 30 AND CONTINUE CHECKING FOR OTHER NOS.
C  STARTING WITH LOCATION I.

         ISTART = I
	 GO TO 30

	ENDIF


C  TO GET TO THIS POINT, THERE IS AT LEAST ONE CHARACTER ENTRY AFTER
C  ISUB, AND THE FIRST OCCURS AT LOCATION I ... AND THIS ENTRY IS NOT
C  A COMMA OR A NUMBER. CHECK TO SEE IF IT IS A DASH. IN THIS CASE,
C  ISUB IS THE FIRST NO. IN A RANGE OF PATIENT NUMBERS.

	IF(READLINE(I:I) .EQ. '-') THEN

C  STORE ISUB INTO NUMCUR1, BUT NOT NUMCUR. IN CASE THE USER
C  HAS NOT ENTERED A LEGITIMATE NO. AFTER THE DASH, KEEP THE PREVIOUS

C  VALUE OF NUMCUR (THE LAST PATIENT INDEX PUT INTO IPATVECC) INTACT.

	 NUMCUR1 = ISUB

C  READ UNTIL THE NEXT NON-BLANK CHARACTER, WHICH SHOULD BE THE
C  BEGINNING OF THE NUMBER WHICH ENDS THE RANGE.

	 DO J = I+1,70

	  IF(READLINE(J:J) .NE. ' ') GO TO 70
	 END DO

C  TO GET TO THIS POINT MEANS THE USER ENDED A LINE WITH A DASH, WHICH
C  IS NOT ALLOWED. WRITE AN ERROR MESSAGE AND RETURN.

	 WRITE(*,8)
    8    FORMAT(/' THE INSTRUCTION OR OUTPUT FILE HAS AN IMPROPER '/

     1' LINE IN IT IN THE PATIENT NUMBER SECTION.'//
     2' A LINE HAS BEEN ENDED WITH A DASH.')
	 ISTOP = -1
	 RETURN

   70   ISTART = J

C  TO GET TO THIS POINT, THERE IS AN ENTRY IN LOCATION ISTART, WHICH
C  SHOULD BE THE BEGINNING OF THE ENDING PATIENT NO. OF A RANGE OF
C  PATIENT NOS. THIS NUMBER ENDS THE ENTRY BEFORE A SPACE OR A
C  COMMA.

     	DO K = ISTART+1,70
	 IF(READLINE(K:K) .EQ. ' ' .OR. READLINE(K:K) .EQ. ',')
     1    GO TO 80
	END DO

   80   IEND = K-1

C  CALL ROUTINE GETSUB WHICH OBTAINS THE SUBJECT NO. FROM THE
C  CHARACTERS IN READLINE(ISTART:IEND).

	CALL GETSUB(READLINE,ISTART,IEND,ISUB,IERROR)

C  IF IERROR RETURNS AS -1, IT MEANS THE USER HAS ENTERED A NON-NUMERIC
C  CHARACTER. IN THIS CASE, PRINT AN ERROR MESSAGE AND RETURN.


	IF(IERROR .EQ. -1) THEN
	 WRITE(*,7)
	 ISTOP = -1
	 RETURN
	ENDIF

C  IF ISUB IS .LE. NUMCUR1 (THE BEGINNING NO. IN THIS RANGE), WRITE AN
C  ERROR MESSAGE TO THE USER AND RETURN. SIMILARLY, IF ISUB .GE.
C  NSUBTOT

	IF(ISUB .LE. NUMCUR1) THEN
	 WRITE(*,9)
    9    FORMAT(/' THE INSTRUCTION OR OUTPUT FILE HAS AN IMPROPER '/
     1' LINE IN IT IN THE PATIENT NUMBER SECTION.'//
     2' IT HAS A RANGE OF SUBJECT NOS. WITH THE ENDING NO. LESS THAN '/
     3' OR EQUAL TO THE BEGINNING NO.')
	 ISTOP = -1
	 RETURN
	ENDIF

	IF(ISUB .GT. NSUBTOT) THEN
	 WRITE(*,6) ISUB,NSUBTOT
	 ISTOP = -1
	 RETURN
	ENDIF


C  TO GET TO THIS POINT MEANS THE USER HAS CORRECTLY ENTERED A RANGE
C  OF PATIENT NOS. FROM NUMCUR1 TO ISUB. UPDATE NSUBB, NUMCUR, AND
C  IPATVECC.

	 NUMCUR = ISUB
	 NN = NSUBB
 	 NSUBB = NSUBB + (NUMCUR - NUMCUR1) + 1

	 NONEW = 0
	 DO K = NN+1,NSUBB
	  NONEW = NONEW + 1
	  IPATVECC(K) = NUMCUR1 - 1 + NONEW
	 END DO

C  CHECK TO SEE IF THERE IS ANOTHER CHARACTER ON THE LINE AFTER
C  LOCATION IEND (IGNORE A COMMA AT THIS POINT, SINCE IT IS POSSIBLE
C  THAT THE USER HAS PUT IN A COMMA AT THE END OF HIS SUBJECT RANGE).
C  IF SO, RETURN CONTROL TO LABEL 30 AND CONTINUE CHECKING FOR OTHER
C  NOS. IF NOT, RETURN.

	 DO J = IEND+1,70
	  IF(READLINE(J:J) .NE. ' ' .AND. READLINE(J:J) .NE. ',' )
     1    GO TO 90
	 END DO

	 RETURN

   90    ISTART = J
	 GO TO 30

	ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(READLINE(I:I) .EQ. '-')  CONDITION.



C  TO GET TO THIS POINT, THERE IS AT LEAST ONE CHARACTER ENTRY AFTER
C  ISUB, AND THE FIRST OCCURS AT LOCATION I ... AND THIS ENTRY IS NOT
C  A COMMA, A NUMBER, OR A DASH, WHICH MEANS IT IS AN ERRONEOUS ENTRY.

C  WRITE AN ERROR MESSAGE TO THE USER AND RETURN.


	WRITE(*,7)
	ISTOP = -1


	RETURN
	END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
	SUBROUTINE GETNSUB2(NSUBTOT)
	CHARACTER READLINE*1000

C  THIS ROUTINE IS A VARIATION OF TEST38.FOR, WHICH READS AN INTEGER
C  ANYWHERE ON A GIVEN LINE WITH A PARTICULAR SET OF WORDS AT THE START
C  OF THAT LINE.

        CHARACTER ERRFIL*20

      COMMON/ERROR/ERRFIL
C  COMMON/ERROR/ IS SUPPLIED TO ALL THE ROUTINES WHICH COULD WRITE TO
C  ERRFIL. 


    2   FORMAT(A1000)

C  READ UNTIL THE LINE WHICH HAS THE WORDS "CTS IN THE DATA SET IS" ON
C  IT SOMEWHERE.

   10   READ(25,2) READLINE
	ILINE=0
	 DO I=1,51
	  IF(READLINE(I:I+21) .EQ. 'CTS IN THE DATA SET IS') THEN
	   ILINE=1
	   GO TO 20
	  ENDIF
	 END DO
   20   IF(ILINE .EQ. 0) GO TO 10

C  SOMEWHERE AFTER THE CHARACTERS IN ENTRIES I:I+21 IS THE INTEGER.

C  READ THE CHARACTERS FOR THIS INTEGER, AND THEN CONVERT IT TO

C  AN INTEGER VALUE. AFTER THE FOLLOWING LOOP, THESE CHARACTERS WILL BE
C  IN READLINE(ISTART:IEND).

	 IEND = 0
	 ISTART = 0

	  DO J = I+22, 72

	   IF(ISTART .EQ. 0 .AND. READLINE(J:J) .NE. ' ') ISTART = J
	   IF(ISTART .NE. 0 .AND. READLINE(J:J) .EQ. ' ') THEN
	    IEND = J-1
	    GO TO 30

	   ENDIF
	  END DO

C  CHECK TO MAKE SURE THAT THE NO. OF CHARACTERS READ IN FOR THE INTEGER
C  IS NOT MORE THAN 4 (I.E., 4 CHARACTERS ALLOW A MAXIMUM SIZE OF 9999
C  WHICH IS MORE THAN THE LARGEST VALUE THIS INTEGER CAN BE).

   30	ISIZE = IEND-ISTART

	IF(ISIZE .GT. 3) THEN

	 WRITE(*,*)' NSUBTOT IS ',NSUBTOT,' WHICH IS TOO LARGE. '
	 WRITE(*,*)' THE PROGRAM STOPS. '

        OPEN(42,FILE=ERRFIL)
         WRITE(42,*)' NSUBTOT IS ',NSUBTOT,' WHICH IS TOO LARGE. '
         WRITE(42,*)' THE PROGRAM STOPS. '
        CLOSE(42)

	 CALL PAUSE
	 STOP

	ENDIF

C  CONVERT AS INDICATED ABOVE.

	NSUBTOT = 0
	 DO K=ISTART,IEND
	  IF(READLINE(K:K) .EQ. '0') IVAL = 0
	  IF(READLINE(K:K) .EQ. '1') IVAL = 1
	  IF(READLINE(K:K) .EQ. '2') IVAL = 2
	  IF(READLINE(K:K) .EQ. '3') IVAL = 3
	  IF(READLINE(K:K) .EQ. '4') IVAL = 4
	  IF(READLINE(K:K) .EQ. '5') IVAL = 5

	  IF(READLINE(K:K) .EQ. '6') IVAL = 6

	  IF(READLINE(K:K) .EQ. '7') IVAL = 7
	  IF(READLINE(K:K) .EQ. '8') IVAL = 8
	  IF(READLINE(K:K) .EQ. '9') IVAL = 9
	  NSUBTOT = NSUBTOT + IVAL*10**ISIZE
	  ISIZE = ISIZE-1

	 END DO


	RETURN
	END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

C
	SUBROUTINE GETIPATFF(IFILE,NSUBTOT,NSUB,MAXSUB,
     1   IPATVEC,IERRR)
	DIMENSION IPATVEC(MAXSUB)
	CHARACTER READLINE*1000

C  SUBROUTINE GETIPATFF IS THE SAME AS GETIPATF, EXCEPT THE ERROR
C  MESSAGES TO THE USER ARE DIFFERENT.

C  SUBROUTINE GETIPATFF IS CALLED BY PREVRUN TO OBTAIN THE INDICES OF
C  THE "ACTIVE" SUBJECTS, IPATVEC(I),I=1,NSUB, FOR THIS RUN. THESE
C  INDICES ARE OBTAINED FROM FILE IFILE.

    3   FORMAT(A1000)

	NSUBB = 0
	NUMCUR = 0



C  NSUBB WILL BE THE NO. OF SUBJECTS SELECTED BY THE USER. IT IS

C  INITIALIZED AS 0, AND WILL GROW AS EACH LINE OF THE FILE IS READ.

C  NUMCUR IS THE INDEX OF THE HIGHEST PATIENT NO. ENTERED SO FAR.

C  NOTE THAT EACH LINE CONTAINS EITHER A SUBJECT NO. OR A RANGE OF


C  SUBJECT NOS. TO BE INCLUDED IN THE ANALYSIS. MULTIPLE SUBJECTS
C  CAN BE ENTERED USING COMMAS, SPACES AND/OR HYPHENS. FOR EXAMPLE,
C  2, 17 - 28 INDICATES SUBJECTS 2 AND 17 THROUGH 28;
C  17,28 INDICATES SUBJECTS 17 AND 28;
C  17 28 INDICATES SUBJECTS 17 AND 28.

C  RESTRICTIONS: 1. ON EACH LINE, USE NO MORE THAN 70 CHARACTERS;
C                2. PATIENT NOS., OR RANGES OF PATIENT NOS.
C                   MUST BE LISTED IN ASCENDING ORDER.

C  A LINE WITH JUST A 0 --> END OF THE LIST OF SUBJECT NOS.


 4210	IF(IFILE .EQ. 23) READ(23,3,ERR=4200) READLINE

	IF(IFILE .EQ. 25) READ(25,3,ERR=4200) READLINE

C  CALL SUBROUTINE GETNUMSF TO UPDATE NSUBB AND IPATVEC, WHERE IPATVEC
C  IS THE VECTOR WHICH CONTAINS THE PATIENT NOS. TO BE INCLUDED IN THE
C  ANALYSIS.

C  NOTE THAT ISTOP RETURNS AS 0 TO INDICATE THE END OF THE LIST OF
C  PATIENT NOS; IT RETURNS AS -1 IF THERE IS A CONFLICT IN THE LIST
C  (SEE RESTRICTION ABOVE) OR A PATIENT NO. LARGER THAN NSUBTOT

C  (THE MAXIMUM ALLOWABLE NO. OF SUBJECTS) HAS BEEN READ IN; AND IT

C  RETURNS AS 1 IF THERE ARE MORE LINES TO BE READ IN.

	CALL GETNUMSF(1,READLINE,NSUBB,NSUBTOT,NUMCUR,ISTOP,
     1                  MAXSUB,IPATVEC)
	IF(ISTOP .EQ. -1) GO TO 4200

	IF(ISTOP .EQ. 1) GO TO 4210

C  TO GET TO THIS POINT, ISTOP = 0 --> USER HAS STOPPED ENTERING
C  PATIENT NOS.

C  CHECK THAT NSUB, AS INPUT TO THIS ROUTINE (FROM MAIN) IS THE SAME
C  AS NSUBB, AS OBTAINED FROM THE LIST OF SUBJECTS TO BE INCLUDED IN
C  THE ANALYSIS. IF NOT, TELL USER AND RETURN IERRR = -1 SO THE USER

C  CAN MAKE A CORRECTION.

	IF(NSUB .EQ. NSUBB) THEN
	 IERRR = 0
	 RETURN

	ENDIF

	IF(NSUB .NE. NSUBB) THEN
         WRITE(*,2)
    2   FORMAT(//' THERE WAS AN ERROR IN THE READING OF PATIENT NOS.'/
     1' USED FOR THIS ANALYSIS. IN PARTICULAR, THE NO. OF '/
     2' SUBJECTS TO BE INCLUDED IN THE ANALYSIS, AS ENTERED IN THE'/
     3' OUTPUT FILE, DOES NOT MATCH THE LIST OF SUBJECT NOS.'/
     4' WHICH FOLLOW THAT NUMBER. IF YOU DID NOT MANUALLY EDIT THE'/

     5' OUTPUT FILE AFTER THE RUN, PLEASE CONTACT LAPK AND REPORT THIS'/
     6' ERROR.'//)
	IERRR = -1
	 RETURN
	ENDIF

 4200   WRITE(*,1)
    1   FORMAT(//' THERE WAS AN ERROR IN THE READING OF PATIENT NOS.'/
     1' USED FOR THIS ANALYSIS FROM THE OUTPUT FILE. IF YOU DID NOT '/
     2' MANUALLY EDIT THE OUTPUT FILE AFTER THE RUN, PLEASE CONTACT '/
     3' LAPK AND REPORT THIS ERROR.'//)

	IERRR = -1

	RETURN
	END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
	SUBROUTINE READBLOCK(ICALL,NSUB,MAXSUB,NOUT,NDRUG,PATH,C0P,C1P,
     1 C2P,C3P,MAXNUMEQ)

	IMPLICIT REAL*8(A-H,O-Z)

        CHARACTER ERRFIL*20

      COMMON/TOWRITE/IALLIN,IVERIFY,NCOVA,ICOVTYPE,COVNAME
      COMMON/ERROR/ERRFIL
C  COMMON/ERROR/ IS SUPPLIED TO ALL THE ROUTINES WHICH COULD WRITE TO
C  ERRFIL. 

C  AS OF NPAG112.FOR, COMMON/TOWRITE IS PROVIDED TO 
C  SUBROUTINE WRITEINFILE FROM READBLOCK, OR PROVIDED TO READBLOCK
C  FROM MAIN.
 

C  AS OF NPAG106.FOR, ARRAYS AGE, ETHNIC, DATE, HEIGHT, WEIGHT,
C  CCR ARE TAKEN OUT OF THE DIMENSION STMT. BELOW. THEY WERE NOT USED.
C  SIMILARLY FOR PATNAME, SEXI, PAT, SEX IN THE PARAMETER STMT. BELOW.

	DIMENSION TIMOUT(MAXSUB,MAXNUMEQ,650),TIMIV(MAXSUB,7,650),
     1 NTIMOUT(MAXSUB,MAXNUMEQ),NTIMIV(MAXSUB,7),RATEIV(MAXSUB,7,650),
     2 BOLUS(MAXSUB,7,650),OUT(MAXSUB,MAXNUMEQ,650),COV(MAXSUB,26,650),
     3 ICOVTYPE(26),TIMBOL(MAXSUB,7,650),NTIMBOL(MAXSUB,7),
     4 NTIMCOV(MAXSUB,26),TIMCOV(MAXSUB,26,650),TIMALL(MAXSUB,5000),
     5 NTIMALL(MAXSUB),TIMI(5000),C0P(MAXNUMEQ),C1P(MAXNUMEQ),
     6 C2P(MAXNUMEQ),C3P(MAXNUMEQ),CSUB(MAXSUB,4,MAXNUMEQ),
     7 NSST(MAXSUB),DOSELINEST(MAXSUB,99,100)

      CHARACTER READLINE*1000,COVNAME(26)*11,NUMBER(MAXSUB)*3,PATFIL*20,
     1 CHARSUB*3,SUBID*11,SUBIDPREV*11,SUBARRAY(MAXSUB)*11,
     3 PATH*60,TMPFILE*13,PATHFILE*73


C  THIS ROUTINE IS BASED ON THE STAND-A-LONE PROGRAM, TESTRD8.FOR.

C  IT READS IN THE PATIENT DATA FROM ALREADY OPENED FILE 66, AND

C  IF ICALL = 1, CREATES INDIVIDUAL SUJBECT FILES WITH PREFIX XQZPJ,
C                AND SUFFIX ZMQ.
C  IF ICALL = 2, ESTABLISHES THE VALUE NOUT (THE NO. OF OUTPUT EQS.),
C                AND THE VALUE OF NDRUG (THE NO. OF DRUGS), AND RETURNS
C                THEM TO SUBROUTINE GETNUMEQ.


    1   FORMAT(A1000)


C  INITIALIZE NDRUG (THE NO. OF DRUGS IN THE PATIENT DATA SET) TO BE
C  0. EVERY TIME IDRUGNO IS READ BELOW, NDRUG WILL BE SET =
C  MAX(NDRUG,IDRUGNO).

C  SIMILARLY, INITIALIZE NOUT (THE NO. OF OUTPUT EQUATIONS IN THE
C  PATIENT DATA SET) TO BE 0. EVERY TIME IOUTEQ IS READ BELOW,
C  NOUT WILL BE SET = MAX(NOUT,IOUTEQ).

	NDRUG = 0
	NOUT = 0

C  INITIALIZE NSST(ISUB) TO 0. IT GIVES THE NO. OF STEADY STATE DOSE
C  LINES THAT WILL BE WRITTEN TO THE DOSAGE BLOCK FOR EACH SUBJECT. 

      DO ISUB = 1,MAXSUB
       NSST(ISUB) = 0
      END DO
   

C  NOTE THAT ANY LINE STARTING WITH A # WILL BE IGNORED. THE FIRST LINE
C  WILL ALSO BE IGNORED - IT HAS ALREADY BEEN VERIFIED TO HAVE THE
C  REQUIRED CODE IN IT.

      READ(66,*)

C  READ THE 2ND LINE, WHICH MUST HAVE A # AS THE FIRST CHARACTER. IT HAS
C  THE NAMES OF THE COLUMNS. COUNT THE NO. OF COMMAS ON THE LINE. THE 
C  NO. OF COVARIATES WILL BE THE NO. OF COMMAS - 11 (SINCE THERE ARE 12
C  FIXED ENTRIES WHICH POTENTIALLY SHOW UP ON EACH LINE: PATIENT ID, 
C  EVENT ID, TIME, INFUSION DURATION, TOTAL DOSE, INPUT DRUG NO.,
C  OUTPUT VALUE, OUTPUT EQ., AND 4 SPOTS FOR ASSAY COEFFICIENTS WHICH 
C  ONLY SHOW UP ON OUTPUT LINES). NOTE THAT THIS VALUE WILL BE CALLED
C  NCOVA, WHICH MEANS NO. OF ADDITION COVARIATES (IN ADDITION TO THE 4
C  PERMANENT ONES AT THE TOP OF EACH PATIENT'S WORKING COPY FILE (AGE,
C  SEX, HEIGHT, ETHNICITY FLAG), TO DISTINGUISH IT FROM NCOV USED IN 
C  THE REST OF THE PROGRAM, WHICH REPRESENTS THE TOTAL NO. OF COVARIATES
C  INCLUDING THE PERMANENT 4 ONES.

	  READ(66,1) READLINE

        NCOMMA = 0

        DO ISTART = 1,1000	 
         IF(READLINE(ISTART:ISTART) .EQ. ',') THEN
          NCOMMA = NCOMMA + 1
         ENDIF
        END DO

        NCOVA = NCOMMA - 11



	IF(NCOVA .GT. 0) THEN

C  READ THE NAMES OF THE NCOVA COVARIATES FROM THE LINE STARTING WITH
C  #ID OR "#ID.

C  NOTE THAT AFTERCOMMA OPENS AND PUTS INTO FILE 57 THE PART OF READLINE
C  WHICH IS BETWEEN COMMA C AND COMMA C+1, WHERE C IS THE 3RD ARGUMENT.
C  ALSO,NOTE THAT NCOVA MUST BE PROVIDED TO AFTERCOMMA SO IT WILL KNOW
C  THE TOTAL NO. OF COMMAS IN READLINE (WHICH = 11 + NCOVA).

	REWIND(66)
  120	READ(66,1) READLINE
	IF(READLINE(1:3) .NE. '#ID' .AND. READLINE(1:4).NE. '"#ID'
     1  .AND. READLINE(1:3) .NE. '#id' .AND. READLINE(1:4).NE. '"#id')
     2   GO TO 120

	 DO ICOV = 1,NCOVA
	  CALL AFTERCOMMA(NCOVA,READLINE,11+ICOV)
	  BACKSPACE(57)

	  READ(57,2) COVNAME(ICOV)
    2   FORMAT(A11)
	  CLOSE(57)
	 END DO


	ENDIF


C  THE ABOVE ENDIF IS FOR THE  IF(NCOVA .GT. 0)  CONDITION.


C  AS OF NPAG111.FOR, GETMAXTIM WILL NOT BE CALLED IF ICALL = 2 (TIMADD
C  IS UNNEEDED IN THIS CASE, AND WILL BE SET = 0).

      TIMADD = 0

      IF(ICALL .EQ. 1) THEN

C  CALL SUBROUTINE GETMAXTIM TO GET THE MAXIMUM TIME OVER ALL THE
C  SUBJECTS IN FILE 66. THIS INCLUDES THE ENDING TIME OVER ALL IV
C  EVENTS. THEN SET TIMADD = THIS TIME + 1. FOR EACH SUBJECT BELOW,
C  EACH TIME WILL HAVE TIMADD*NRESET ADDED TO IT, WHERE NRESET IS THE
C  NO. OF TIME RESETS (FOR THAT SUBJECT) UP TO AND INCLUDING THAT TIME.
C  THIS WILL MAKE EACH TIME A UNIQUE TIME (I.E., WITH TIME RESETS IN
C  THE BLOCK FORMAT FILE, THERE COULD BE MANY TIMES WITH THE SAME
C  VALUE).


	CALL GETMAXTIM(NCOVA,TIMAX)

C  VERIFY THAT TIMAX WAS CALCULATED CORRECTLY - I.E., THAT IT IS NOT
C  STILL THE INITIALIZED NEGATIVE VALUE IN GETMAXTIM.


	IF(TIMAX .LT. 0) THEN

	 WRITE(*,11)
   11  FORMAT(/' THERE IS SOMETHING WRONG WITH YOUR BLOCK FORMAT'/
     1' FILE. THE TIMES IN COLUMN 3 AND/OR THE TIME DURATIONS'/
     2' IN COLUMN 4 ARE BAD. PLEASE CHECK YOUR VALUES. '//
     3' THE PROGRAM STOPS.')

        OPEN(42,FILE=ERRFIL)
         WRITE(42,11) 
        CLOSE(42)	

	 CALL PAUSE
	 STOP

	ENDIF

   	TIMADD = TIMAX + 1.D0

      ENDIF

C  ENDIF ABOVE IS FOR THE  IF(ICALL .EQ. 1)  CONDITION.



C  REWIND FILE 66, READ PAST THE FIRST LINE WHICH HAS THE CODE, AND
C  THE SECOND LINE, WHICH HAS THE COVARIATE INFORMATION ON IT, AND
C  THEN READ ALL LINES, EXCEPT THOSE THAT START WITH # OR "#.
C  GO THROUGH EACH SUCCEEDING LINE IN FILE 66 AND EXTRACT ALL THE
C  INFORMATION. NOTE THAT EACH LINE CAN CONTAIN OUTPUT INFO OR DOSAGE
C  INFO (INCLUDING COVARIATE VALUES), DEPENDING ON THE VALUE FOR IDEVENT
C  (THE 2ND ENTRY IN EACH LINE), BUT NOT BOTH. IN PARTICULAR, IF
C  IDEVENT = 0 --> THE ROW HAS OUTPUT EQUATION INFO.

C  IDEVENT = 1 --> THE ROW HAS DOSAGE/COVARIATE INFO.
C  IDEVENT = 4 --> SAME AS IDEVENT = 1, EXCEPT THIS ROW REPRESENTS A 
C                  TIME RESET.

	REWIND(66)
	READ(66,1)
	READ(66,1)

C  INITIALIZE SUBIDPREV (THE PREVIOUS SUBJECT ID) TO BE '%^&*' SO THE
C  FIRST SUJBECT ID READ IN BELOW WILL BE DIFFERENT THAN THIS, AND SO
C  START THE SUBJECT ID LOGIC. ALSO, INITIALIZE THE SUBJECT NO. TO 0.

	SUBIDPREV = '%^&*'
	NSUB = 0

C  NOTE THAT IEND .LT. 0 --> END OF FILE REACHED.

   10	READ(66,1,IOSTAT=IEND) READLINE
	IF(IEND .LT. 0) GO TO 100
	IF(READLINE(1:1) .EQ. '#' .OR. READLINE(1:2) .EQ. '"#') GO TO 10

C  THE FIRST VALUE (I.E., AFTER COMMA NO. 0) IS THE SUBJECT ID.

	CALL AFTERCOMMA(NCOVA,READLINE,0)
	BACKSPACE(57)
	READ(57,2) SUBID
	CLOSE(57)

C  NOTE THAT SUBID CONTAINS THE 1ST 11 CHARACTERS OF THE LINE, BUT THE
C  SUBJECT ID IS JUST THE SET OF CHARACTERS PRIOR TO THE 1ST COMMA.
C  CALL SUBROUTINE GETID TO CORRECT THE VALUE OF SUBID.

	CALL GETID(SUBID)


C  IF SUBID = SUBIDPREV, THIS IS ANOTHER LINE FOR THE CURRENT SUBJECT.
C  IF SUBID .NE. SUBIDPREV, THIS IS THE 1ST EVENT FOR A NEW SUBJECT, SO
C  INCREASE NSUB, AND SET THE NO. OF INFUSIONS (FOR EACH DRUG), BOLI,
C  OBSERVATION, AND COVARIATE TIMES FOR THIS SUBJECT TO 0 (THEY WILL
C  BE UPDATED BELOW AS REQUIRED). SIMILARY SET THE TOTAL NO. OF DOSE
C  EVENTS = 0.


C  ALSO, SINCE THIS IS A NEW SUBJECT, DEFAULT THE ASSAY COEFFICIENTS FOR
C  OUTPUT EQ. IEQ TO [C0P(IEQ),C1P(IEQ),C2P(IEQ),C3P(IEQ)], 
C  IEQ = 1,MAXNUMEQ (THE MAX VALUE OF NUMEQT). THEN, AS THIS 
C  SUBJECT'S INFO IS BEING READ BELOW, ANY ASSAY C'S SPECIFIED FOR
C  THIS SUBJECT WILL OVERWRITE THE DEFAULT VALUES. AND NOTE THAT IF
C  A SUBJECT HAS MORE THAN ONE SET OF ASSAY C'S FOR A GIVEN OUTPUT EQ.,
C  THE LAST SET WILL BE USED.

C  NOTE THAT AFTER READBLOCK HAS FINISHED READING THE PATIENT INFO,
C  CSUB(I,J,K), J=1,4 WILL BE ASSAY C'S [C0 C1 C2 C3] FOR SUBJECT I
C  AND OUTPUT EQ. K.  


	IF(SUBID .NE. SUBIDPREV) THEN

	 SUBIDPREV = SUBID
	 NSUB = NSUB + 1

	 WRITE(*,8888) NSUB
 8888    FORMAT('+ ',' NOW WORKING ON SUBJECT NO. ',I4)

	 SUBARRAY(NSUB) = SUBID

	 NTIMALL(NSUB) = 0

	 DO K = 1,7
	  NTIMIV(NSUB,K) = 0
	  NTIMBOL(NSUB,K) = 0
	 END DO


	 DO K = 1,26
	  NTIMCOV(NSUB,K) = 0
	 END DO


        DO K = 1,MAXNUMEQ
         NTIMOUT(NSUB,K) = 0
         CSUB(NSUB,1,K) = C0P(K)
         CSUB(NSUB,2,K) = C1P(K)
         CSUB(NSUB,3,K) = C2P(K)
         CSUB(NSUB,4,K) = C3P(K)
        END DO

 
C  SEE LOGIC BELOW. IF THIS ROW REPRESENTS A TIME RESET, THEN AN
C  EXTRA VALUE (-99) AT AN EXTRA TIME (0) WILL BE ADDED TO EACH OUTPUT
C  EQUATION ARRAY. BUT THIS NEEDS TO BE DONE JUST ONCE FOR EACH TIME
C  RESET, NOT FOR EACH DOSAGE LINE THAT HAS A RESET. I.E., IF THERE
C  ARE 5 DRUGS, THEN THERE COULD BE AS MANY AS 5 DOSE LINES WITH A
C  RESET VALUE. ALSO, WITHIN EACH LINE, A DOSE AND/OR A COVARIATE
C  COULD HAVE A RESET TIME OF 0. THEREFORE EACH BLOCK OF CODE BELOW,
C  FOR EACH DRUG NO. AND EACH COVARIATE, IS TESTED FOR A TIME RESET,
C  AND IN EACH CASE, EXTRA LINES ARE POTENTIALLY ADDED TO THE OUPUT
C  ARRAYS. TO PREVENT MORE EXTRA LINES (OF OUTPUT VALUES = -99 AT
C  TIMES = 0) THAN ARE NECESSARY, INITIALIZE NRESETADD = 0. THIS
C  TELLS THE PROGRAM THAT NO EXTRA LINES HAVE BEEN ADDED TO THE OUTPUT
C  ARRAYS SINCE THE LAST ACTUAL OUTPUT VALUE WAS PUT INTO ONE OF THE
C  ARRAYS. NRESETADD WILL BE CHANGED TO 1 WHENEVER EXTRA LINES HAVE
C  BEEN ADDED TO THE OUTPUT ARRAYS, AND THEN BACK TO 0 WHENEVER ANOTHER


C  ACTUAL OUTPUT VALUE HAS BEEN PUT INTO AN ARRAY.

	NRESETADD = 0


C  INITIALIZE NRESET TO 0. IT WILL BE THE NO. OF TIME RESETS THAT
C  HAVE OCCURRED UP TO ANY TIME. ALSO INITIALIZE TIMERESET = 0; THIS
C  WILL BE THE RUNNING TIME TO BE ADDED TO EACH ACTUAL TIME. IT WILL
C  ALWAYS BE SET = TIMADD*NRESET BELOW.

	NRESET = 0
	TIMERESET = TIMADD*NRESET


C  ALSO INITIALIZE NRESETLAST = -1 (SEE CODE BELOW).

       NRESETLAST = -1

       DOSELINEST(NSUB,1,100) = -99

C  DOSELINEST(NSUB,1,100) IS INITIALIZED TO BE -99. IF IT CHANGES BELOW
C  TO BE .GE. 0, IT MEANS THAT THERE IS AT LEAST ONE STEADY STATE DOSE
C  SET, AND THE FIRST ONE OCCURS AT THE VALUE OF NRESET =
C  DOSELINEST(NSUB,1,100).


C  VERIFY THAT THE 2ND VALUE (I.E., AFTER COMMA NO. 1), WHICH IS THE
C  EVENT ID, IDEVENT, IS 1 SINCE THE FIRST EVENT FOR EACH SUBJECT
C  SHOULD BE 1 (A NON-TIME-RESET DOSE EVENT).

	CALL AFTERCOMMA(NCOVA,READLINE,1)

	BACKSPACE(57)
      READ(57,*,ERR=470) IDEVENT
	CLOSE(57)

	IF(IDEVENT .NE. 1) THEN

	 WRITE(*,402) SUBARRAY(NSUB),IDEVENT
  402    FORMAT(/' THERE IS AN ERROR IN THE BLOCK FORMAT. FOR SUBJECT '/
     1 1X,A11,', THE FIRST EVENT ID IS NOT 1 AS REQUIRED. IT IS ',I3/
     3' THE PROGRAM STOPS.'/)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,402) SUBARRAY(NSUB),IDEVENT
        CLOSE(42)	

	 CALL PAUSE
	 STOP

	ENDIF


	ENDIF


C  THE ABOVE ENDIF IS FOR THE  IF(SUBID .NE. SUBIDPREV)  CONDITION.


C  THE 2ND VALUE (I.E., AFTER COMMA NO. 1) IS THE EVENT ID, IDEVENT
C  (SEE ABOVE).


	CALL AFTERCOMMA(NCOVA,READLINE,1)
	BACKSPACE(57)	
      READ(57,*,ERR=470) IDEVENT
	CLOSE(57)
      GO TO 480

  470  WRITE(*,471) NSUB,READLINE(1:75)
  471  FORMAT(/' THERE IS AN ERROR IN YOUR BLOCK FORMAT FILE FOR '/
     1' SUBJECT NO. ',I5,'. THERE IS NO EVENT ID. THE 1ST 75'/
     2' CHARACTERS OF THE LINE ARE:'/
     2A75//
     3' THE PROGRAM STOPS.'/)
	 WRITE(*,401) NSUB,SUBARRAY(NSUB)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,471) NSUB,READLINE(1:75)
         WRITE(42,401) NSUB,SUBARRAY(NSUB)
        CLOSE(42)	

  	 CALL PAUSE
	 STOP


  480  CONTINUE

C  IF THE ID OF THIS EVENT IS NO. 4, IT IS A TIME RESET EVENT. IN THIS
C  CASE, INCREASE NRESET AND TIMERESET AS INDICATED ABOVE.

	IF(IDEVENT .EQ. 4) THEN

	 NRESET = NRESET + 1
	 TIMERESET = TIMADD*NRESET

	ENDIF



C  THE 3RD VALUE (I.E., AFTER COMMA NO. 2) IS THE TIME OF THE EVENT.
C  READ THIS VALUE NOW.


	CALL AFTERCOMMA(NCOVA,READLINE,2)
	BACKSPACE(57)
	READ(57,*) TIMEVENT
	CLOSE(57)


      IF(TIMEVENT .LT. 0.D0) THEN

C  STORE INTO DOSELINEST(.,.,.) ALL THE INFO FOR THE WORKING COPY FILE
C  FOR THIS STEADY STATE DOSE SET.

C  COMPARE NRESET WITH THE PREVIOUS VALUE OF NRESET WHEN THIS PART OF
C  THE CODE WAS USED: IF THEY ARE THE SAME, THIS LINE WILL PROVIDES
C  MORE INFO (FOR A DIFFERENT DRUG NO.) FOR THE SAME STEADY STATE DOSE
C  EVENT TO BE PUT INTO THE WORKING COPY FILE. IF THEY ARE DIFFERENT,
C  THIS LINE IS THE FIRST LINE OF A NEW STEADY STATE DOSE SET.

       IF(NRESET .GT. NRESETLAST) THEN

C  PUT IN NEW INFO FOR A NEW LINE (FOR A NEW STEADY STATE DOSE SET).
C  THIS LINE IS THE FIRST LINE WITH INFO ON A NEW STEADY STATE DOSE SET.
C  STORE ALL THE INFO FROM THIS LINE, INCLUDING NRESET, SO SUBROUTINE
C  WRITEDOS CAN WRITE THE INFO FOR THIS LINE SEPARATELY. NOTE THAT THIS
C  LINE WILL NOT BE A PART OF THE LOGIC BELOW WHICH STORES ALL DOSE 
C  INFO, AND THEN SORTS IT BY TIME. NOTE THAT NRESET IS STORED INTO
C  ENTRY 100 FOR THIS LINE.

        NSST(NSUB) = NSST(NSUB) + 1


        IF(NSST(NSUB) .GT. 99) THEN

         WRITE(*,172) NSUB
  172    FORMAT(/' FOR SUBJECT NO. ',I5,' THE NO. OF STEADY STATE DOSE'/

     1' SETS IS MORE THAN 99, THE MAXIMUM ALLOWED. PLEASE RERUN THE'/
     2' PROGRAM AFTER REDUCING THE NO. OF STEADY STATE DOSE SETS TO'/
     3' NO MORE THAN 99.'//
     4' THE PROGRAM STOPS.'/)
	  WRITE(*,401) NSUB,SUBARRAY(NSUB)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,172) NSUB
         WRITE(42,401) NSUB,SUBARRAY(NSUB)
        CLOSE(42)	

         CALL PAUSE
         STOP

        ENDIF


        DOSELINEST(NSUB,NSST(NSUB),100) = NRESET

C  TIMEVENT IS THE NEGATIVE OF THE INTERDOSE INTERVAL, WHICH WILL SHOW
C  UP IN THE TIME COLUMN OF THE WORKING COPY FILE.

        DOSELINEST(NSUB,NSST(NSUB),1) = TIMEVENT


C  ZERO OUT ALL THE IV AND BOLUS ENTRIES FOR ALL POSSIBLE DRUGS
C  (I.E., THERE COULD BE AS MANY AS 7 DRUGS).

        DO I = 1,7
         DOSELINEST(NSUB,NSST(NSUB),2*I) = 0.D0
         DOSELINEST(NSUB,NSST(NSUB),2*I+1) = 0.D0
        END DO


C  STORE ANY COVARIATE INFO INTO THE COVARIATE ENTRIES. NOTE IT IS NOT
C  KNOWN AT THIS POINT HOW MANY TOTAL DRUGS ARE USED IN THE MODEL SINCE
C  THE VALUE FOR NDRUG HAS NOT YET FINISHED UPDATING (IN THE CODE BELOW,
C  IT IS SET = IDRUGNO IF NDRUG .LT. IDRUGNO). SO, THE COVARIATE VALUES
C  WILL BE STORED FAR ENOUGH OUT IN THE DOSELINEST(.,.,.) ARRAY TO NOT
C  INTERFERE WITH THE ENTRIES FOR THE MAXIMUM NO. OF POSSIBLE DRUGS.
C  SINCE THERE ARE AT MOST 7 POSSIBLE DRUGS, ENTRIES 2,3,...,14,15 WILL
C  BE RESERVED FOR THESE DRUG VALUES, AND THE COVARIATE VALUES WILL
C  START WITH ENTRY NO. 20.

        IF(NCOVA .GT. 0) THEN
         
         DO 110 ICOV = 1,NCOVA
          CALL AFTERCOMMA(NCOVA,READLINE,11+ICOV)
          BACKSPACE(57)
 	    READ(57,*,ERR=95) COVVAL
	    CLOSE(57)
          DOSELINEST(NSUB,NSST(NSUB),19+ICOV) = COVVAL
          GO TO 110
   95     DOSELINEST(NSUB,NSST(NSUB),19+ICOV) = -99.D0
  110    CONTINUE

        ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(NCOVA .GT. 0)  CONDITION.


C  FOR NPAG104.FOR, ADD LOGIC FOR EXTRA OBS. LINE WITH VALUES OF -99'S.

C  THIS IS EITHER A TIME RESET EVENT, OR THE TOP OF THE PATIENT'S FILE.
C  IF IT IS THE TOP OF THE PATIENT'S FILE, NRESET WILL = 0. IF IT IS A 
C  TIME RESET EVENT, NRESET WILL BE > 0, AND IN THIS CASE, MUST STORE 
C  VALUES INTO THE OUPUT ARRAYS (SEE LOGIC BELOW) WHICH INDICATE THAT
C  SUBSEQUENT OUTPUT TIMES ARE BASED ON THIS TIME RESET.

       IF(NRESET .GT. 0) THEN
        DO IOUTEQ = 1,MAXNUMEQ
         NTIMOUT(NSUB,IOUTEQ) = NTIMOUT(NSUB,IOUTEQ) + 1
         TIMOUT(NSUB,IOUTEQ,NTIMOUT(NSUB,IOUTEQ)) = TIMERESET
         OUT(NSUB,IOUTEQ,NTIMOUT(NSUB,IOUTEQ)) = -99.D0
        END DO
       ENDIF



       ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(NRESET .GT. NRESETLAST)  CONDITION.


C  ESTABLISH THE DURATION, (4TH VALUE, AFTER THE 3RD COMMA), DOSE (5TH
C  VALUE, AFTER THE 4TH COMMA), AND DRUG NO. (6TH VALUE, AFTER THE 5TH
C  COMMA) FOR THIS LINE.

        CALL AFTERCOMMA(NCOVA,READLINE,3)
        BACKSPACE(57)
        READ(57,*,ERR=170) DUR
        CLOSE(57)

        CALL AFTERCOMMA(NCOVA,READLINE,4)
        BACKSPACE(57)
        READ(57,*,ERR=170) TOTDOS
        CLOSE(57)

        CALL AFTERCOMMA(NCOVA,READLINE,5)
        BACKSPACE(57)
        READ(57,*,ERR=170) IDRUGNO
	  IF(NDRUG .LT. IDRUGNO) NDRUG = IDRUGNO
        CLOSE(57)

C  STORE THE IV RATE INTO THE IV ENTRY FOR DRUG NO. IDRUGNO; SIMILARLY,
C  STORE THE TOTAL DOSE INTO THE BOLUS ENTRY FOR DRUG NO. IDRUGNO.
C  NOTE THAT IF DUR = 0, THIS LINE REPRESENTS A STEADY STATE OF BOLUS 
C  VALUES. IN THIS CASE, SET THE IV RATE TO 0.



        IF(DUR .LE. 0.D0) 
     1   DOSELINEST(NSUB,NSST(NSUB),2*IDRUGNO) = 0.D0
        IF(DUR .GT. 0.D0)
     1   DOSELINEST(NSUB,NSST(NSUB),2*IDRUGNO) = TOTDOS/DUR
        DOSELINEST(NSUB,NSST(NSUB),2*IDRUGNO+1) = TOTDOS



C  NOTE THAT COVARIATE VALUES ARE ONLY READ FOR THE FIRST DOSE LINE
C  IN A STEADY STATE SET (I.E., WHEN NRESET .GT. NRESETLAST). IT IS
C  POSSIBLE THAT THE USER'S .csv FILE HAS A DIFFERENT SET OF COV. VALUES
C  FOR EACH LINE (FOR A DIFFERENT DRUG) THAT IS INCLUDED IN THE 
C  CURRENT STEADY STATE DOSE SET. BUT, THIS WOULD BE A MISTAKE SINCE
C  ONLY 1 SET OF COV. VALUES CAN BE USED FOR THE STEADY STATE SET. THE
C  FIRST SET OF VALUES WILL BE USED (AND ALL OTHERS WILL BE IGNORED).
 
C  SET NRESETLAST = NRESET SO IF ANOTHER LINE OF DOSE INFO FOR THE
C  CURRENT STEADY STATE SET FOLLOWS, THE PROGRAM WILL KNOW IT IS
C  MORE INFO ON THE CURRENT SET, AND NOT NEW INFO ON THE NEXT SET.
  
       NRESETLAST = NRESET

       GO TO 10


  170  WRITE(*,171) NSUB,READLINE(1:75)
  171  FORMAT(/' THERE IS AN ERROR IN YOUR BLOCK FORMAT FILE FOR '/
     1' SUBJECT NO. ',I5,'. EITHER THE DURATION, THE DOSE, OR THE '/
     2' DRUG NUMBER IS MISSING. THE 1ST 75 CHARACTERS OF THE LINE ARE:'/
     2A75//
     3' THE PROGRAM STOPS.'/)
	 WRITE(*,401) NSUB,SUBARRAY(NSUB)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,171) NSUB,READLINE(1:75)
         WRITE(42,401) NSUB,SUBARRAY(NSUB)
        CLOSE(42)	

  	 CALL PAUSE
	 STOP


      ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(TIMEVENT .LT. 0.D0)  CONDITION.

     
	TIMEVENT = TIMEVENT + TIMERESET


C  IF IDEVENT = 0, IT MEANS THAT THIS ROW IS AN OBSERVED VALUE ROW.
C  IN THIS CASE, READ THE OBSERVED VALUE INFO.

	IF(IDEVENT .EQ. 0) THEN

C  THE 7TH ENTRY (AFTER COMMA NO. 6) IS AN OUTPUT VALUE FOR THIS TIME
C  IF THERE IS AN ERROR, IT IS ASSUMED THAT THE PROGRAM READ A DOT,


C  WHICH WOULD BE INCONSISTENT SINCE IDEVENT = 0 (MEANING THERE SHOULD

C  BE AN OUTPUT VALUE ON THE ROW).

	CALL AFTERCOMMA(NCOVA,READLINE,6)
	BACKSPACE(57)
	READ(57,*,ERR=30) YVAL
	CLOSE(57)


C  TO GET TO THIS POINT --> YVAL CONTAINS AN OUTPUT VALUE FOR THIS
C  LINE. BEFORE THIS VALUE CAN BE STORED, MUST READ THE OUTPUT EQUATION
C  NO. AFTER COMMA NO. 7.

	CALL AFTERCOMMA(NCOVA,READLINE,7)
	BACKSPACE(57)
	READ(57,*,ERR=30) IOUTEQ
	IF(NOUT .LT. IOUTEQ) NOUT = IOUTEQ
	CLOSE(57)

C  STORE THIS VALUE. ALSO STORE THE TIME OF THIS EVENT INTO THE ARRAY
C  WHICH STORES OUTPUT TIMES.

	NTIMOUT(NSUB,IOUTEQ) = NTIMOUT(NSUB,IOUTEQ) + 1
	TIMOUT(NSUB,IOUTEQ,NTIMOUT(NSUB,IOUTEQ)) = TIMEVENT
	OUT(NSUB,IOUTEQ,NTIMOUT(NSUB,IOUTEQ)) = YVAL
	NRESETADD = 0



C  SEE CODE ABOVE REGARDING NRESEADD.

	GO TO 20

   30   WRITE(*,31) NSUB, TIMEVENT - TIMERESET
   31   FORMAT(/' THERE IS AN ERROR IN THE BLOCK FORMAT. FOR SUBJECT '/
     1' NO. ',I4,' AND TIME ',F10.4, ' A LINE HAS AN EVENT ID OF 0 IN'/
     2' COL. 2, INDICATING OBSERVED VALUE INFORMATION. BUT THERE IS '/
     3' EITHER NO OBSERVED VALUE IN COL. 7, OR NO OUTPUT EQUATION NO.'/
     4' IN ENTRY 8. '//
     3' THE PROGRAM STOPS.')
	WRITE(*,401) NSUB,SUBARRAY(NSUB)
  401   FORMAT(/' NOTE: THE ID FOR SUBJECT NO. ',I4,' IS ',A11/)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,31) NSUB, TIMEVENT - TIMERESET
         WRITE(42,401) NSUB,SUBARRAY(NSUB)
        CLOSE(42)	

	CALL PAUSE
	STOP


   20 CONTINUE

C  THE 9TH - 12TH ENTRIES FOR THIS ROW POTENTIALLY HOLD NEW ASSAY 
C  COEFFICIENTS FOR THIS SUBJECT (NSUB) AND OUTPUT EQ. (IOUTEQ).
C  READ THESE VALUES. IF THEY ARE NOT MISSING, UPDATE THE ASSAY
C  COEFFICIENT INFO FOR THIS SUBJECT/OUTPUT EQ.

C  NOTE THAT THESE ENTRIES SHOULD ALL BE MISSING (DOTS OR n's) OR ALL
C  BE NUMBERS. IF THERE IS A COMBINATION  OF MISSING VALUES AND NUMBERS,
C  STOP THE PROGRAM AND TELL THE USER.


        IMISSC0 = 0
        IMISSC1 = 0   
        IMISSC2 = 0
        IMISSC3 = 0
      
        CALL AFTERCOMMA(NCOVA,READLINE,8)
        BACKSPACE(57)
        READ(57,*,ERR=230) C0
        CLOSE(57)


        GO TO 235
  230   IMISSC0 = 1

  235   CALL AFTERCOMMA(NCOVA,READLINE,9)
        BACKSPACE(57)
        READ(57,*,ERR=240) C1
        CLOSE(57)

        GO TO 245
  240   IMISSC1 = 1


  245   CALL AFTERCOMMA(NCOVA,READLINE,10)
        BACKSPACE(57)
        READ(57,*,ERR=250) C2
        CLOSE(57)

        GO TO 255
  250   IMISSC2 = 1


  255   CALL AFTERCOMMA(NCOVA,READLINE,11)
        BACKSPACE(57)
        READ(57,*,ERR=260) C3
        CLOSE(57)

        GO TO 265
  260   IMISSC3 = 1

  265   CONTINUE

C  IF ALL IMISSCx VALUES ARE 0, UPDATE THE ASSAY C'S FOR THIS
C  SUBJECT AND OUTPUT EQ. NO. IF ALL IMISSCx VALUES ARE 1, THEY
C  ARE ALL MISSING, SO JUST CONTINUE. IF SOME OF THE IMISSCx VALUES
C  ARE 0 AND SOME ARE 1, THIS IS AN INCONSISTENCY (I.E., THE USER HAS
C  ENTERED SOME BUT NOT ALL OF THE ASSAY C'S). IN THIS CASE, STOP THE
C  PROGRAM AFTER INFORMING THE USER OF HIS ERROR.

        ISUMC = IMISSC0 + IMISSC1 + IMISSC2 + IMISSC3

        IF(ISUMC .EQ. 0) THEN
         CSUB(NSUB,1,IOUTEQ) = C0
         CSUB(NSUB,2,IOUTEQ) = C1
         CSUB(NSUB,3,IOUTEQ) = C2
         CSUB(NSUB,4,IOUTEQ) = C3
        ENDIF

        IF(ISUMC .NE. 0 .AND. ISUMC .NE. 4) THEN

         WRITE(*,231) NSUB, TIMEVENT - TIMERESET,IOUTEQ
  231    FORMAT(/' THERE IS AN ERROR IN THE BLOCK FORMAT. FOR SUBJECT '/
     1' NO. ',I4,' AND TIME ',F10.4, ' A LINE HAS AN EVENT ID OF 0 IN'/
     2' COL. 2, INDICATING OBSERVED VALUE INFORMATION, BUT THIS LINE'/
     3' HAS AN INCOMPLETE SET OF ASSAY COEFFICIENTS FOR OUTPUT EQ. '/
     4' NUMBER ',I3,'. THERE MUST BE EITHER 4 ASSAY COEFFICIENTS ON'/
     5' AN OUTPUT LINE, OR NONE (IF NO OUTPUT LINES FOR A PARTICULAR'/
     6' SUBJECT x OUTPUT EQ. COMBO HAVE ASSAY COEFFICIENTS, THEN THE'/
     7' POPULATION COEFFICIENTS WILL BE USED).'//
     8' THE PROGRAM STOPS.')
         WRITE(*,401) NSUB,SUBARRAY(NSUB)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,231) NSUB, TIMEVENT - TIMERESET,IOUTEQ
         WRITE(42,401) NSUB,SUBARRAY(NSUB)
        CLOSE(42)	

         CALL PAUSE
         STOP

        ENDIF



	ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(IDEVENT .EQ. 0)  CONDITION.


	IF(IDEVENT .EQ. 1 .OR. IDEVENT .EQ. 4) THEN


C  IDEVENT = 1 OR 4 --> DOSE AND/OR COVARITE INFO IS TO BE READ IN.

C  THE 4TH ENTRY (AFTER COMMA NO. 3) IS AN INFUSION DURATION, AND THE
C  5TH ENTRY (AFTER COMMA NO. 4) IS THE TOTAL DOSE ... IF THIS LINE
C  HAS DOSE INFORMATION. NOTE THAT IF THERE IS NO DOSE, THE TOTAL DOSE
C  ENTRY WILL BE A DOT ("."). ALSO, IF THERE IS A TOTAL DOSE, BUT THE
C  INFUSION DURATION IS 0, THIS LINE REPRESENTS A BOLUS INPUT.

C  SO, 1ST TRY READING THE TOTAL DOSE AS A REAL NUMBER; IF THERE IS AN
C  ERROR, IT IS ASSUMED THAT THE PROGRAM READ A DOT.


	CALL AFTERCOMMA(NCOVA,READLINE,4)
	BACKSPACE(57)
	READ(57,*,ERR=40) TOTDOS
	CLOSE(57)


C  TO GET TO THIS POINT --> TOTDOS CONTAINS A TOTAL DOSE VALUE FOR THIS
C  LINE. READ THE INFUSION DURATION AFTER COMMA NO. 3 TO SEE IF THIS
C  DOSE IS AN INFUSION (WITH A POSITIVE DURATION) OR A BOLUS (WITH A
C  0 DURATION).

	CALL AFTERCOMMA(NCOVA,READLINE,3)
	BACKSPACE(57)
	READ(57,*,ERR=50) DUR
	CLOSE(57)

C  BEFORE THIS VALUE CAN BE STORED, MUST READ THE DRUG NO. AFTER COMMA
C  NO. 5.

	CALL AFTERCOMMA(NCOVA,READLINE,5)
	BACKSPACE(57)
	READ(57,*,ERR=50) IDRUGNO
	IF(NDRUG .LT. IDRUGNO) NDRUG = IDRUGNO
	CLOSE(57)

C  STORE THE ABOVE VALUES DEPENDING ON WHETHER THEY REPRESENT AN
C  INFUSION OR A BOLUS INPUT.

C  INCREASE THE NO. OF DOSAGE LINES FOR THIS SUBJECT. IF DUR > 0, THE
C  NO. OF DOSAGE LINES INCREASES BY 2 SINCE THERE WILL BE A START TIME


C  AND AN ENDING TIME. IF DUR = 0, THE NO. OF DOSAGE LINES WILL INCREASE
C  BY 1.

	IF(DUR .GT. 0) THEN

C  THE INFUSION RATE IS TOTDOS/DUR. SO THE DOSE VALUE THE 1ST DOSE
C  TIME BELOW WILL BE THIS INFUSION RATE, AND THE DOSE VALUE AT THE
C  2ND DOSE TIME BELOW WILL BE 0.

C  NOTE THAT EVERYTIME NTIMALL(NSUB) IS INCREASED, THE PROGRAM CHECKS
C  THAT IT HAS NOT GONE PAST 5000. IF SO, A MESSAGE TO THE USER IS
C  WRITTEN THAT THIS IS NOT ALLOWED AND THE PROGRAM STOPS.

	 NTIMALL(NSUB) = NTIMALL(NSUB) + 1

	 IF(NTIMALL(NSUB) .GT. 5000) THEN

	  WRITE(*,3001) NSUB
 3001     FORMAT(/' THE NO. OF LINES IN THE DOSAGE REGIMEN FOR SUBJECT'/
     1' NO. ',I5,' IS MORE THAN THE LIMIT OF 5000. PLEASE RERUN THE'/
     2' PROGRAM AFTER REDUCING THIS NO. TO BE LESS THAN 5000.'/)
	  WRITE(*,401) NSUB,SUBARRAY(NSUB)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,3001) NSUB
         WRITE(42,401) NSUB,SUBARRAY(NSUB)
        CLOSE(42)	


	  CALL PAUSE
	  STOP

	 ENDIF

	 TIMALL(NSUB,NTIMALL(NSUB)) = TIMEVENT


	 IF(IDEVENT .EQ. 4) THEN

C  IF IDEVENT = 4, IT MEANS THAT THIS IS A TIME RESET POINT (I.E., A
C  TIME IN THE DISTANT FUTURE WHICH WILL SHOW UP AS T = 0 IN THE
C  WORKING COPY FORMAT FILE.

C  IN THIS CASE, IF NRESETADD = 0, ADD VALUES TO NTIMOUT, TIMOUT, AND
C  OUT FOR EACH  OF THE MAXNUMEQ POSSIBLE OUTPUT EQUATIONS (THERE ARE
C  NOUT OUTPUT EQUATIONS SO FAR, BUT IN SUBSEQUENT ROWS, NOUT COULD
C  INCREASE TO AT MOST MAXNUMEQ) TO INDICATE THAT
C  ANY OUTPUTS FOLLOWING THIS TIME ARE BASED ON THE TIME RESET. TO DO
C  THIS, PUT IN THE CURRENT TIME IN TIMOUT, AND A CORRESPONDING VALUE OF
C  -99 (MISSING VALUE), FOR EACH OUTPUT EQUATION.

C  STORE VALUES INTO THE OUPUT ARRAYS (TIME = 0 AND VALUE = -99) WHICH
C  INDICATE THAT SUBSEQUENT OUTPUT TIMES ARE BASED ON THIS TIME RESET.
C  ... BUT ONLY STORE THESE EXTRA VALUES IF NRESETADD = 0. IF
C  NRESETADD = 1, IT MEANS THAT THESE LINES HAVE ALREADY BEEN ADDED
C  SINCE THE LAST ACTUAL OUTPUT VALUE WAS PUT INTO ONE OF THE OUTPUT
C  ARRAYS.

	  IF(NRESETADD .EQ. 0) THEN
           DO IOUTEQ = 1,MAXNUMEQ
	    NTIMOUT(NSUB,IOUTEQ) = NTIMOUT(NSUB,IOUTEQ) + 1
            TIMOUT(NSUB,IOUTEQ,NTIMOUT(NSUB,IOUTEQ)) = TIMEVENT
   	    OUT(NSUB,IOUTEQ,NTIMOUT(NSUB,IOUTEQ)) = -99.D0
	   END DO
	   NRESETADD = 1
	  ENDIF


	 ENDIF


C  THE ABOVE ENDIF IS FOR THE  IF(IDEVENT .EQ. 4)  CONDITION.

C  IF THE CURRENT TIME IS THE SAME AS THE ENDING TIME OF THE PREVIOUS 
C  IV, DO NOT INCREASE NTIMIV(.,.) BELOW, BECAUSE THE NEW STARTING IV 
C  RATE MUST REPLACE THE 0.0 FROM THE ENDING OF THE PREVIOUS IV.

        ISAME = 0
        IF(NTIMIV(NSUB,IDRUGNO) .GT. 0)
     1   CALL THESAME(TIMEVENT,TIMIV(NSUB,IDRUGNO,NTIMIV(NSUB,IDRUGNO)),
     2    ISAME)

        IF(ISAME .EQ. 0) NTIMIV(NSUB,IDRUGNO) = NTIMIV(NSUB,IDRUGNO) + 1
        TIMIV(NSUB,IDRUGNO,NTIMIV(NSUB,IDRUGNO)) = TIMEVENT
        RATEIV(NSUB,IDRUGNO,NTIMIV(NSUB,IDRUGNO)) = TOTDOS/DUR

	 NTIMALL(NSUB) = NTIMALL(NSUB) + 1

	 IF(NTIMALL(NSUB) .GT. 5000) THEN


	  WRITE(*,3001) NSUB
	  WRITE(*,401) NSUB,SUBARRAY(NSUB)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,3001) NSUB
         WRITE(42,401) NSUB,SUBARRAY(NSUB)
        CLOSE(42)	

	  CALL PAUSE
	  STOP

	 ENDIF

	 TIMALL(NSUB,NTIMALL(NSUB)) = TIMEVENT + DUR

	 NTIMIV(NSUB,IDRUGNO) = NTIMIV(NSUB,IDRUGNO) + 1
	 TIMIV(NSUB,IDRUGNO,NTIMIV(NSUB,IDRUGNO)) = TIMEVENT + DUR
	 RATEIV(NSUB,IDRUGNO,NTIMIV(NSUB,IDRUGNO)) = 0.D0

	ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(DUR .GT. 0)  CONDITION.



	IF(DUR .LE. 0) THEN

C  STORE THE BOLUS VALUE AT THE INDICATED TIME, TIMEVENT.

	 NTIMALL(NSUB) = NTIMALL(NSUB) + 1

	 IF(NTIMALL(NSUB) .GT. 5000) THEN

	  WRITE(*,3001) NSUB
	  WRITE(*,401) NSUB,SUBARRAY(NSUB)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,3001) NSUB
         WRITE(42,401) NSUB,SUBARRAY(NSUB)
        CLOSE(42)	

	  CALL PAUSE
	  STOP

	 ENDIF

	 TIMALL(NSUB,NTIMALL(NSUB)) = TIMEVENT


	 IF(IDEVENT .EQ. 4) THEN

C  SEE LOGIC ABOVE FOR TIME RESET LOGIC, AND ADDING LINES TO THE
C  OUTPUT EQUATION VALUES IN THAT CASE.


C  STORE VALUES INTO THE OUPUT ARRAYS (SEE LOGIC ABOVE) WHICH
C  INDICATE THAT SUBSEQUENT OUTPUT TIMES ARE BASED ON THIS TIME RESET.
C  ... BUT ONLY STORE THESE EXTRA VALUES IF NRESETADD = 0. IF
C  NRESETADD = 1, IT MEANS THAT THESE LINES HAVE ALREADY BEEN ADDED
C  SINCE THE LAST ACTUAL OUTPUT VALUE WAS PUT INTO ONE OF THE OUTPUT
C  ARRAYS.


	  IF(NRESETADD .EQ. 0) THEN
           DO IOUTEQ = 1,MAXNUMEQ
	    NTIMOUT(NSUB,IOUTEQ) = NTIMOUT(NSUB,IOUTEQ) + 1
            TIMOUT(NSUB,IOUTEQ,NTIMOUT(NSUB,IOUTEQ)) = TIMEVENT
   	    OUT(NSUB,IOUTEQ,NTIMOUT(NSUB,IOUTEQ)) = -99.D0
	   END DO
	   NRESETADD = 1
	  ENDIF


	 ENDIF


C  THE ABOVE ENDIF IS FOR THE  IF(IDEVENT .EQ. 4)  CONDITION.

	 NTIMBOL(NSUB,IDRUGNO) = NTIMBOL(NSUB,IDRUGNO) + 1
	 TIMBOL(NSUB,IDRUGNO,NTIMBOL(NSUB,IDRUGNO)) = TIMEVENT
	 BOLUS(NSUB,IDRUGNO,NTIMBOL(NSUB,IDRUGNO)) = TOTDOS

	ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(DUR .LE. 0)  CONDITION.


	GO TO 40


   50   WRITE(*,51) NSUB, TIMEVENT - TIMERESET
   51   FORMAT(/' THERE IS AN ERROR IN THE BLOCK FORMAT. FOR SUBJECT '/
     1' NO. ',I4,' AND TIME ',F10.4,' A LINE HAS A DOSAGE AMT., BUT NO'/
     2' DURATION (EVEN A BOLUS SHOULD HAVE A DURATION OF 0) IN '/
     3' ENTRY 4., OR NO DRUG NO. IN ENTRY 5.'//
     3' THE PROGRAM STOPS.')
	WRITE(*,401) NSUB,SUBARRAY(NSUB)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,51) NSUB, TIMEVENT - TIMERESET
         WRITE(42,401) NSUB,SUBARRAY(NSUB)
        CLOSE(42)	

	CALL PAUSE
	STOP


   40   CONTINUE


C  READ IN ANY COVARIATE VALUES IF NCOVA .GT. 0.

	IF(NCOVA .GT. 0) THEN

       DO 60 ICOV = 1,NCOVA

	  CALL AFTERCOMMA(NCOVA,READLINE,11+ICOV)
	  BACKSPACE(57)
 	  READ(57,*,ERR=70) COVVAL
	  CLOSE(57)

C  TO GET TO THIS POINT --> COVVAL REPRESENTS THE VALUE OF COV. NO.
C  ICOV. STORE IT AT THE INDICATED TIME, TIMEVENT.


	  NTIMALL(NSUB) = NTIMALL(NSUB) + 1

	 IF(NTIMALL(NSUB) .GT. 5000) THEN

	  WRITE(*,3001) NSUB
	  WRITE(*,401) NSUB,SUBARRAY(NSUB)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,3001) NSUB
         WRITE(42,401) NSUB,SUBARRAY(NSUB)
        CLOSE(42)	

	  CALL PAUSE
	  STOP

	 ENDIF

	 TIMALL(NSUB,NTIMALL(NSUB)) = TIMEVENT


	 IF(IDEVENT .EQ. 4) THEN

C  SEE LOGIC ABOVE FOR TIME RESET LOGIC, AND ADDING LINES TO THE
C  OUTPUT EQUATION VALUES IN THAT CASE.

C  STORE VALUES INTO THE OUPUT ARRAYS (TIME = 0 AND VALUE = -99) WHICH
C  INDICATE THAT SUBSEQUENT OUTPUT TIMES ARE BASED ON THIS TIME RESET.

C  ... BUT ONLY STORE THESE EXTRA VALUES IF NRESETADD = 0. IF
C  NRESETADD = 1, IT MEANS THAT THESE LINES HAVE ALREADY BEEN ADDED
C  SINCE THE LAST ACTUAL OUTPUT VALUE WAS PUT INTO ONE OF THE OUTPUT
C  ARRAYS.

	  IF(NRESETADD .EQ. 0) THEN
           DO IOUTEQ = 1,MAXNUMEQ
	    NTIMOUT(NSUB,IOUTEQ) = NTIMOUT(NSUB,IOUTEQ) + 1
            TIMOUT(NSUB,IOUTEQ,NTIMOUT(NSUB,IOUTEQ)) = TIMEVENT
   	    OUT(NSUB,IOUTEQ,NTIMOUT(NSUB,IOUTEQ)) = -99.D0
	   END DO
	   NRESETADD = 1
	  ENDIF

	 ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(IDEVENT .EQ. 4)  CONDITION.

C  SINCE MULTIPLE DOSE LINES CAN OCCUR AT THE SAME TIME (DEFINING
C  DOSES FOR DIFFERENT DRUGS OR IV VS. BOLUS VALUES, IT IS POSSIBLE
C  THAT A COVARIATE VALUE IS BEING RESET AT THE SAME TIME AS IN A
C  PREVIOUS LINE. IF THIS IS TRUE, TELL THE USER THAT THE COVARIATE
C  VALUE FROM THE FIRST LINE WILL BE USED. THIS MUST BE CHECKED ONLY
C  IF THE INDEX OF THE NO. OF COVARIATE VALUES IS > 0 - OTHERWISE
C  THIS IS THE FIRST LINE WITH A COVARIATE VALUE ON IT).


C  BUT, ONLY WRITE THIS WARNING IF THE TWO COVARIATE VALUES ARE
C  ACTUALLY DIFFERENT, BECAUSE IF THEY ARE THE SAME, THERE IS NO
C  CONFLICT, JUST REDUNDANCY.



	  IF(NTIMCOV(NSUB,ICOV) .GT. 0) THEN

	   CALL THESAME(TIMEVENT,TIMCOV(NSUB,ICOV,NTIMCOV(NSUB,ICOV)),
     1                  ISAMETIME)


	   CALL THESAME(COVVAL,COV(NSUB,ICOV,NTIMCOV(NSUB,ICOV)),
     1                  ISAMECOV)

	   IF(ISAMETIME .EQ. 1 .AND. ISAMECOV .EQ. 1) GO TO 60

	   IF(ISAMETIME .EQ. 1 .AND. ISAMECOV .EQ. 0) THEN
            WRITE(*,41) NSUB,TIMEVENT-TIMERESET,ICOV,
     1       COV(NSUB,ICOV,NTIMCOV(NSUB,ICOV)),COVVAL
   41       FORMAT(/' FOR SUBJECT, 'I2,' AT TIME ',G12.4,', COVARIATE'/
     1' NO. ',I2,' WAS SET TO BOTH ',G12.4,' AND ',G12.4,'. YOU SHOULD'/
     2' CHECK YOUR BLOCK FILE. FOR NOW, THE FIRST VALUE WILL BE USED.')

	    GO TO 60

	   ENDIF

	  ENDIF

	  NTIMCOV(NSUB,ICOV) = NTIMCOV(NSUB,ICOV) + 1
	  TIMCOV(NSUB,ICOV,NTIMCOV(NSUB,ICOV)) = TIMEVENT
	  COV(NSUB,ICOV,NTIMCOV(NSUB,ICOV)) = COVVAL


	  GO TO 60

   70     CONTINUE


C  TO GET TO LABEL 70 --> THERE WAS NO NUMBER IN THE ENTRY FOR
C  COVARIATE, ICOV.

   60   CONTINUE



	ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(NCOVA .EQ. 0)  CONDITION.



	ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(IDEVENT .EQ. 1 .OR. IDEVENT .EQ. 4)
C  CONDITION.



C  RETURN TO LABEL 10 TO READ THE NEXT LINE IN THE BLOCK PATIENT
C  DATA FILE.

	GO TO 10


  100   CONTINUE



C  IF ICALL = 2, THE CALL TO THIS ROUTINE WAS FROM GETNUMEQ. IN
C  THIS CASE, RETURN AT THIS POINT, SINCE GETNUMEQ ONLY NEEDS THE
C  VALUES FOR NOUT AND NDRUG.

	IF(ICALL .EQ. 2) RETURN



C  TO GET TO THIS POINT, ICALL = 1.


C  AS OF NPAG112.FOR, IALLIN AND IVERIFY ARE PROVIDED TO THIS
C  ROUTINE BY COMMON/TOWRITE FROM MAIN. IF IALLIN = 1 AND IVERIFY = 0, 
C  ICOVTYPE HAS ALREADY BEEN ESTABLISHED FROM THE INSTRUCTION FILE,
C  AND THE USER WANTS TO RUN THE PROGRAM WITH NO MORE INTERACTION.
C  IN THIS CASE, SKIP THE IF(NCOVA .GT. 0) CODE BELOW.
C  BUT NOTE THAT IN CASE THE USER USED AN INSTRUCTION FILE WITH
C  THE ICOVTYPE(.) VALUES NOT SPECIFIED (IN WHICH CASE ICOVTYPE(.)
C  COULD HAVE GARBAGE VALUES), DEFAULT THE VALUES TO BE INTERPOLATED,
C  WHICH IS A VALUE OF 2. SO THIS IS EQUIVALENT TO SETTING ANY
C  ICOVTYPE(.) VALUE NOT = 1 TO BE 2.

      IF(IALLIN .EQ. 1 .AND. IVERIFY .EQ. 0) THEN
  
       DO ICOV = 1,NCOVA
        IF(ICOVTYPE(ICOV) .NE. 1) ICOVTYPE(ICOV) = 2
       END DO
   
       GO TO 1050

      ENDIF

 
	IF(NCOVA .GT. 0) THEN

	 WRITE(*,111) NCOVA
  111    FORMAT(/' YOUR BLOCK FORMAT PATIENT INFORMATION FILE SHOWS'/
     1' ',I2,' COVARIATES. EACH COVARIATE MUST BE SPECIFIED TO BE '/
     2' EITHER A PIECEWISE CONSTANT COVARIATE OR AN INTERPOLATED '/
     3' COVARIATE.'//
     4' A PIECEWISE CONSTANT COVARIATE WILL HAVE THE SAME VALUE FROM'/
     5' ONE EXPLICITLY CODED VALUE, THROUGH ALL INTERVEENING DOSE'/
     6' TIMES, TO THE NEXT EXPLICITLY CODED VALUE (WHEN IT WILL CHANGE).
     7 '//
     8' AN INTERPOLATED COVARIATE WILL HAVE INTERPOLATED VALUES FROM'/
     9' ONE EXPLICITY CODED VALUE, THROUGH ALL INTERVEENING DOSE '/
     1' TIMES, TO THE NEXT EXPLCITLY CODED VALUE.'//)


	 DO ICOV = 1,NCOVA
  130	  WRITE(*,112) COVNAME(ICOV)
  112     FORMAT(/' FOR COVARIATE ',A11/
     1'  ENTER 1 IF IT IS TO BE PIECEWISE CONSTANT; '/
     2'  ENTER 2 IF IT IS TO BE INTERPOLATED: ')
	  READ(*,*,ERR=130) ITYPE
	  IF(ITYPE .NE. 1 .AND. ITYPE .NE. 2) GO TO 130
	  ICOVTYPE(ICOV) = ITYPE
	 END DO

	ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(NCOVA .GT. 0)  CONDITION.


 1050 CONTINUE


C  WRITE OUT ALL THE INFO IN THE ABOVE ARRAYS INTO A WORKING COPY
C  FORMAT. ACTUALLY, FOR NOW, JUST TRY TO CREATE THE DOSAGE AND
C  OBSERVATION PART OF A FILE SIMILAR TO 2DRUG001 (I.E., DON'T
C  WORRY NOW ABOUT THE TOP PART OF THE FILE, OR THE BOTTOM).

C  FIRST, CALL SUBROUTINE GETCHAR TO ESTABLISH THE NUMBER ARRAY.

	DO JSUB = 1,NSUB
	 CALL GETCHAR(JSUB,CHARSUB)
	 NUMBER(JSUB) = CHARSUB
	END DO


	DO 1000 ISUB = 1,NSUB

C  NOTE THAT THE WORKING COPY SUBJECTS WILL BE PLACED INTO THE
C  WORKING DIRECTORY. THE PREFIX WILL BE HARDCODED TO 'XQZPJ', AND THE

C  SUFFIX TO 'ZMQ'.

	 PATFIL = 'XQZPJ'//NUMBER(ISUB)//'.ZMQ'

C  CALL FULLNAME WHICH CONVERTS THE FILENAME TO PATHFILE, THE COMPLETE
C  NAME OF THE FILE, WHICH INCLUDES THE PATH (IF THE PATH IS NOT THE
C  CURRENT DIRECTORY).

         TMPFILE = ' '
	 TMPFILE = PATFIL
	 CALL FULLNAME(PATH,TMPFILE,PATHFILE)

	 OPEN(33,FILE=PATHFILE)

	 IF(NDRUG .GT. 7) THEN

	  WRITE(*,101) NDRUG
  101     FORMAT(/' NO. OF DRUGS IN THIS PATIENT DATA SET IS ',I2/
     1'  THIS IS MORE THAN 7, THE MAXIMUM --> PROGRAM STOPS.'/)
	  WRITE(*,401) ISUB,SUBARRAY(ISUB)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,101) NDRUG
         WRITE(42,401) ISUB,SUBARRAY(ISUB)
        CLOSE(42)	

	  CALL PAUSE
	  STOP

	 ENDIF


	 IF(NOUT .GT. MAXNUMEQ) THEN

	  WRITE(*,106) NOUT,MAXNUMEQ
  106     FORMAT(/' NO. OF OUTPUT EQS. THIS PATIENT DATA SET IS ',I2/
     1' THIS IS MORE THAN THE MAX. ALLOWED VALUE OF ',I2,'. SO THE'/
     2' PROGRAM STOPS.'/)
	  WRITE(*,401) ISUB,SUBARRAY(ISUB)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,106) NOUT,MAXNUMEQ
         WRITE(42,401) ISUB,SUBARRAY(ISUB)
        CLOSE(42)	

	  CALL PAUSE
	  STOP

	 ENDIF

	 IF(NCOVA .GT. 26) THEN

	  WRITE(*,103) NCOVA
  103     FORMAT(/' NO. OF COVARIATES IN THIS PATIENT DATA SET IS ',I3/
     1'  THIS IS MORE THAN 26, THE MAXIMUM --> PROGRAM STOPS.'/)
	  WRITE(*,401) ISUB,SUBARRAY(ISUB)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,103) NCOVA
         WRITE(42,401) ISUB,SUBARRAY(ISUB)
        CLOSE(42)	

	  CALL PAUSE
	  STOP

	 ENDIF



C  BEFORE CALLING WRITEDOS, CALL TIMESET FOR THIS SUBJECT TO
C  ELIMINATE ALL THE DUPLICATE TIMES IN TIMALL(ISUB,.). THERE COULD BE
C  DUPLICATE TIMES BECAUSE NTIMALL(ISUB) WAS INCREASED BY 1 FOR EACH
C  BOLUS, IV, OR COVARIATE VALUE, AND SOME OF THESE VALUES OCCUR AT THE
C  SAME TIME.  TIMESET ALSO ORDERS THE TIMES AND THEY COULD BE OUT OF
C  ORDER DUE TO AN IV RATE WHOSE DURATION RESULTS IN THE ENDING TIME
C  BEING PAST THE NEXT DOSE EVENT.

C  TIMESET RETURNS THE COMPLETE SET OF TIMES FOR THIS SUBJECT'S DOSAGE
C  REGIMEN IN TIMI (AND THERE ARE NTIMI OF THEM).

       CALL TIMESET(MAXSUB,ISUB,SUBARRAY(ISUB),NTIMALL,TIMALL,NTIMI,
     1    TIMI)

       
C  CALL WRITEDOS TO WRITE THE PATIENT INFO TO PATHFILE = FILE 33.

	 CALL WRITEDOS(ISUB,NTIMIV,TIMIV,RATEIV,NTIMBOL,TIMBOL,BOLUS,
     1    NTIMCOV,TIMCOV,COV,ICOVTYPE,NDRUG,NCOVA,NOUT,NTIMOUT,
     2    TIMOUT,OUT,SUBARRAY(ISUB),COVNAME,MAXSUB,NTIMI,TIMI,TIMADD,
     3    CSUB,NSST,DOSELINEST,MAXNUMEQ)


 1000   CONTINUE


	RETURN
	END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
	SUBROUTINE AFTERCOMMA(NCOVA,READLINE,NCOMMA)
	CHARACTER READLINE*1000

C  OPEN AND WRITE INTO SCRATCH FILE 57 THE PART OF READLINE THAT
C  IS BETWEEN COMMAS NCOMMA AND NCOMMA+1 ... UNLESS NCOMMA IS THE MAX.
C  NO. OF COMMAS (11+NCOVA). IN THIS CASE, WRITE INTO SCRATCH FILE 57 
C  THE PART OF READLINE THAT FOLLOWS COMMA NCOMMA (SINCE THERE WILL NOT
C  BE ANOTHER COMMA).

        CHARACTER ERRFIL*20

      COMMON/ERROR/ERRFIL
C  COMMON/ERROR/ IS SUPPLIED TO ALL THE ROUTINES WHICH COULD WRITE TO
C  ERRFIL. 


    1   FORMAT(A1000)

C  IF NCOMMA = 0, SET ISTART = 0 AND GO TO LABEL 10.

	IF(NCOMMA .EQ. 0) THEN
	 ISTART = 0
	 GO TO 10
	ENDIF


	ICOMMA = 0


	DO ISTART = 1,300
	 IF(READLINE(ISTART:ISTART) .EQ. ',') THEN
	  ICOMMA = ICOMMA + 1
	  IF(ICOMMA .EQ. NCOMMA) GO TO 10
	 ENDIF
	END DO


C  TO GET TO THIS POINT MEANS THAT THE NO. OF COMMAS IN LINE
C  READLINE IS LESS THAN NCOMMA. WRITE A MESSAGE AND STOP.

	WRITE(*,2) NCOMMA,ICOMMA,READLINE
    2   FORMAT(/' THE FOLLOWING LINE WAS SUPPOSED TO HAVE AT LEAST ',I3/
     1' COMMAS, BUT IT HAD ONLY ',I3,' SO THE PROGRAM STOPS.'//
     2A1000)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,2) NCOMMA,ICOMMA,READLINE
        CLOSE(42)	

	CALL PAUSE
	STOP




C  TO REACH LABEL 10, ISTART IS NOW THE COLUMN NO. WHICH HAS THE
C  NCOMMAth COMMA IN LINE READLINE.  FIND IEND, WHICH IS THE COLUMN NO.
C  WHICH HAS THE NCOMMA+1 ST COMMA IN THE LINE. THEN WRITE THE PORTION
C  OF READLINE WHICH IS BETWEEN ISTART AND IEND INTO FILE57.


   10	ICOMMA = 0

	DO IEND = 1,300
	 IF(READLINE(IEND:IEND) .EQ. ',') THEN
	  ICOMMA = ICOMMA + 1
	  IF(ICOMMA .EQ. NCOMMA+1) GO TO 20
	 ENDIF
	END DO

C  TO GET TO THIS POINT MEANS THAT THE NO. OF COMMAS IN LINE
C  READLINE IS LESS THAN NCOMMA+1. THIS IS OK IF NCOMMA IS THE MAXIMUM
C  NO. OF COMMAS, WHICH IS 11+NCOVA. OTHERWISE, WRITE A MESSAGE AND 
C  STOP.


	IF(NCOMMA .LT. 11 + NCOVA) THEN

	 WRITE(*,2) NCOMMA+1,ICOMMA,READLINE

        OPEN(42,FILE=ERRFIL)
         WRITE(42,2) NCOMMA+1,ICOMMA,READLINE
        CLOSE(42)	

	 CALL PAUSE
	 STOP

	ENDIF

	IF(NCOMMA .EQ. 11 + NCOVA) IEND = 301

   20	  OPEN(57,STATUS='SCRATCH')

C  SEE CODE AT TOP OF NPBG15E3.FOR TO SEE WHY FORMATTED WRITE 
C  STATEMENTS ARE USED (UNLESS NUMCHAR BELOW IS > 11, IN WHICH CASE
C  A FREE FORMAT WRITE STATEMENT IS STILL USED).

        NUMCHAR = IEND - ISTART - 1
	
        IF(NUMCHAR .EQ. 1) WRITE(57,101) READLINE(ISTART+1:IEND-1)
  101   FORMAT(A1)

        IF(NUMCHAR .EQ. 2) WRITE(57,102) READLINE(ISTART+1:IEND-1)
  102   FORMAT(A2)


        IF(NUMCHAR .EQ. 3) WRITE(57,103) READLINE(ISTART+1:IEND-1)
  103   FORMAT(A3)

        IF(NUMCHAR .EQ. 4) WRITE(57,104) READLINE(ISTART+1:IEND-1)
  104   FORMAT(A4)

        IF(NUMCHAR .EQ. 5) WRITE(57,105) READLINE(ISTART+1:IEND-1)
  105   FORMAT(A5)

        IF(NUMCHAR .EQ. 6) WRITE(57,106) READLINE(ISTART+1:IEND-1)
  106   FORMAT(A6)

        IF(NUMCHAR .EQ. 7) WRITE(57,107) READLINE(ISTART+1:IEND-1)
  107   FORMAT(A7)

        IF(NUMCHAR .EQ. 8) WRITE(57,108) READLINE(ISTART+1:IEND-1)
  108   FORMAT(A8)

        IF(NUMCHAR .EQ. 9) WRITE(57,109) READLINE(ISTART+1:IEND-1)
  109   FORMAT(A9)

        IF(NUMCHAR .EQ. 10) WRITE(57,110) READLINE(ISTART+1:IEND-1)
  110   FORMAT(A10)


        IF(NUMCHAR .EQ. 11) WRITE(57,111) READLINE(ISTART+1:IEND-1)
  111   FORMAT(A11)


        IF(NUMCHAR .GT. 11) WRITE(57,*) READLINE(ISTART+1:IEND-1)


	RETURN
	END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C	SUBROUTINE GETCHAR(JSUB,CHARSUB)

C  THIS ROUTINE IS INCLUDED IN THE MODULE SCAT72XX.FOR.

C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
	SUBROUTINE WRITEDOS(ISUB,NTIMIV,TIMIV,RATEIV,NTIMBOL,TIMBOL,
     1   BOLUS,NTIMCOV,TIMCOV,COV,ICOVTYPE,NDRUG,NCOVA,NOUT,NTIMOUT,
     2   TIMOUT,OUT,SUBID,COVNAME,MAXSUB,NTIMI,TIMI,TIMADD,CSUB,NSST,
     3   DOSELINEST,MAXNUMEQ)

	IMPLICIT REAL*8(A-H,O-Z)

	DIMENSION BOLVAL(7),COVVAL(26),XIVVAL(7),DOSELINE(650,43),

     1 TIMOUT(MAXSUB,MAXNUMEQ,650),TIMIV(MAXSUB,7,650),
     2 NTIMOUT(MAXSUB,MAXNUMEQ),
     2 NTIMIV(MAXSUB,7),RATEIV(MAXSUB,7,650),BOLUS(MAXSUB,7,650),

     3 OUT(MAXSUB,MAXNUMEQ,650),COV(MAXSUB,26,650),ICOVTYPE(26),
     4 TIMBOL(MAXSUB,7,650),NTIMBOL(MAXSUB,7),NTIMCOV(MAXSUB,26),
     5 TIMCOV(MAXSUB,26,650),INDIV(7),INDBOL(7),INDCOV(26),
     6 TIMI(5000),TIMORD(3900),BLOCKOUT(3900,MAXNUMEQ),
     7 CSUB(MAXSUB,4,MAXNUMEQ),
     7 NSST(MAXSUB),DOSELINEST(MAXSUB,99,100),DOSELINES(100)

	CHARACTER SUBID*11,COVNAME(26)*11,ERRFIL*20

      COMMON/ERROR/ERRFIL
C  COMMON/ERROR/ IS SUPPLIED TO ALL THE ROUTINES WHICH COULD WRITE TO
C  ERRFIL. 


C  THIS ROUTINE WRITES THE DOSE EVENTS AND THE OBSERVATION EVENTS OF
C  THE PATIENT DATA FILE TO FILE33. NOTE THAT A DOSE EVENT OCCURS
C  WHENEVER THERE IS A BOLUS APPLIED, AN IV RATE CHANGE, AND/OR A
C  COVARIATE VALUE APPLIED.



C----------------- WRITE THE TOP OF FILE BELOW -------------------------

	WRITE(33,301) SUBID
  301   FORMAT('  LAST AND FIRST NAMES ARE: ',A11)
	WRITE(33,302) SUBID
  302   FORMAT(' CHART NUMBER IS: ',A11//
     1' WARD NO, PATIENT AGE (YEARS), SEX, HEIGHT (INCHES),'/
     2' ETHNICITY FLAG, AND ETHNICITY DESCRIPTION (IF ANY)   FOLLOW ON'/
     3' THE NEXT 6 LINES:'/
     4'-99'/
     5'-99'/
     6'M'/
     7'-99'/
     8'1'/

     9'Ethnicity Description'//
     1' DATE OF FIRST THERAPY IS   1   1   08'/

     2'CCR ML/MIN/    0.00 150.00'/
     3'HOURS    MG     MG/HR    MCG/ML KG       MG/DL    60  .00 ')


C----------------- WRITE THE TOP OF FILE ABOVE -------------------------



C----------------- WRITE THE DOSE EVENTS BELOW -------------------------


	 WRITE(33,102) NDRUG
  102    FORMAT(/'     ',I1,' ... NO. OF DRUGS')

C  NOTE THAT NCOVA IS THE NO. OF COVARIATES IN THE USER'S BLOCK FORMAT
C  FILE. THIS AUTOMATICALLY BECOMES NADD, THE NO. OF "ADDITIONAL"
C  COVARIATES IN THE WORKING COPY FILE.

	 WRITE(33,104) NCOVA
  104    FORMAT('    ',I2,' ... NO. OF ADDITIONAL COVARIATES')


C  INCREASE THE NO. OF DOSE EVENTS BY THE NO. OF STEADY STATE DOSE LINES
C  THAT WILL BE IN THE FILE (THESE WERE NOT PART OF THE ARRAY EXAMINED
C  BY SUBROUTINE TIMESET).

	WRITE(33,2) NTIMI + NSST(ISUB)
    2   FORMAT('   ',I3,' ... NO. OF DOSE EVENTS'//
     1'    TIME, IV/PO FOR EACH DRUG; ADDITIONAL COVARIATES IF ANY')


C  SET THE IVs FOR EACH DRUG TO 0. EACH DRUG IV VALUE STAYS THE SAME
C  AS ITS PREVIOUS VALUE UNTIL CHANGED. ALSO INITIALIZE EACH BOLUS
C  VALUE TO 0.

	DO IDRUG = 1,NDRUG

	 XIVVAL(IDRUG) = 0.D0
	 BOLVAL(IDRUG) = 0.D0
	END DO

C  SET EACH COVARIATE VALUE TO ITS INITIAL VALUE. IT IS ASSUMED THAT
C  EACH COV. HAS ITS FIRST VALUE SET AT THE FIRST DOSE TIME (T=0).
C  IF THIS IS NOT TRUE, SEE REMARK BELOW WHERE THE COVARIATE VALUES
C  ARE SET FOR EACH TIME.

	DO ICOV = 1,NCOVA
	 COVVAL(ICOV) = COV(ISUB,ICOV,1)
	END DO


C  INITIALIZE THE INDEX OF THE NEXT TIME IN EACH TIME ARRAY TO BE 1.

	DO IDRUG = 1,NDRUG
	 INDIV(IDRUG) = 1
	 INDBOL(IDRUG) = 1
	END DO

	DO ICOV = 1,NCOVA
	 INDCOV(ICOV) = 1
	END DO



C  GO THROUGH ALL THE NTIMI DOSAGE BLOCK TIMES IN TIMI AND ESTABLISH ALL
C  IV, BOLUS, AND COV. VALUES AT EACH TIME AND WRITE THEM TO THE DOSAGE

C  REGIMEN, BUT NOTE THAT EACH TIME MUST BE REDUCED BY TIMERESET, WHERE
C  TIMERESET = TIMADD*NRESET, WHERE NRESET IS THE NO. OF TIME RESETS
C  THROUGH THAT TIME (SEE IN READBLOCK THAT TIMERESET WAS ADDED TO EACH
C  TIME).

	NRESET = 0
	TIMERESET = TIMADD*NRESET

C  INITIALIZE NSSEVENTS = 1. THIS WILL BE THE INDEX OF THE NEXT STEADY
C  STATE DOSE EVENT (IF ANY) IN THE CURRENT PATIENT'S DATA FILE. THE
C  TOTAL NO. OF SUCH EVENTS IS NSST(ISUB).


      NSSEVENTS = 1


C  AS OF NPAG104, PUT IN A STEADY STATE LINE AS THE FIRST DOSE EVENT
C  IF ONE EXISTS. 

C  DOSELINEST(ISUB,1,100) = NRESET, THE NO. OF DOSE RESETS BEFORE THE
C  1ST STEADY STATE DOSE SET. 

C  IF DOSELINST(ISUB,1,100) = 0, IT MEANS THAT THERE IS A STEADY STATE
C  DOSE SET AT THE TOP OF THE FILE (I.E., BEFORE ANY RESETS). 

C  IF DOSELINEST(ISUB,1,100) IS = -99, IT MEANS THERE ARE NO STEADY 
C  STATE LINES FOR THIS SUBJECT. 

C  IF DOSELINEST(ISUB,1,100) = N > 0, IT MEANS THE FIRST STEADY STATE
C  DOSE SET OCCURS AFTER RESET NO. N.

      CALL THESAME(DOSELINEST(ISUB,1,100),0.D0,ISAME)

      IF(ISAME .EQ. 1) THEN

C  FILL IN THE ENTRIES TO DOSELINE FOR THE STEADY STATE DOSE AT THE
C  TOP OF THE PATIENT'S FILE.

C  THE FIRST ENTRY IN DOSELINST IS TIMEVENT = THE NEGATIVE OF THE
C  INTERDOSE INTERVAL.


	 DOSELINES(1) = DOSELINEST(ISUB,1,1)
	 NENTRY = 1

C  FOR EACH DRUG, THE IV AND TOTAL VALUES ARE ALREADY STORED INTO
C  DOSELINEST(ISUB,1,2*I) AND DOSELINEST(ISUB,1,2*I+1), I=1,NDRUG.

	 DO IDRUG = 1,NDRUG
	  NENTRY = NENTRY+1
        DOSELINES(NENTRY) = DOSELINEST(ISUB,1,2*IDRUG)
	  NENTRY = NENTRY+1
	  DOSELINES(NENTRY) = DOSELINEST(ISUB,1,2*IDRUG+1)
	 END DO

C  FOR EACH COVARIATE, IF ANY, THE VALUES ARE STORED INTO
C  DOSELINEST(ISUB,1,19+ICOV), ICOV = 1,NCOVA.

       IF(NCOVA .GT. 0) THEN
	  DO ICOV = 1,NCOVA
	   NENTRY = NENTRY+1
	   DOSELINES(NENTRY) = DOSELINEST(ISUB,1,19+ICOV)
	  END DO
       ENDIF

       WRITE(33,1) (DOSELINES(J),J=1,NENTRY)

       NSSEVENTS = NSSEVENTS + 1

      ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(ISAME .EQ. 1)  CONDITION.



	DO 1000 ITIM = 1,NTIMI



	 TIME = TIMI(ITIM)


C  IF THIS TIME = THE NEXT MULTIPLE OF TIMADD, INCREASE THE NO. OF
C  RESETS BY 1 AND RECALCULATE TIMERESET, THE CURRENT AMOUNT THAT EACH
C  TIME MUST BE REDUCED BEFORE BEING WRITTEN INTO THE WORKING COPY
C  FILE.

C  AS OF NPAG104.FOR, THIS TIME COULD BE PAST A TIME RESET POINT. THIS
C  WOULD HAPPEN IF A TIME RESET HAD A STEADY STATE DOSE SET ASSOCIATED
C  WITH IT, WITHOUT A NON STEADY STATE DOSE IMMEDIATELY FOLLWOING IT (IF
C  A NON STEADY STATE DOSE IMMEDIATELY FOLLOWED A STEADY STATE SET, 
C  THEN THERE WILL BE TIMI(.) ENTRY THAT = TIMADD*(NRESET+1)). IN THIS
C  CASE TOO, UPDATE NRESET AND TIMERESET.

C  CALL THESAME HERE TO ESTABLISH THE VALUE FOR ISAMERESET. IT
C  WILL USED BELOW TO SUPPRESS INTERPOLATION OF COVARIATES ACROSS A
C  TIME RESET.

       CALL THESAME(TIME,TIMADD*(NRESET+1),ISAMERESET)   


       IF(TIME .GE. TIMADD*(NRESET+1)) THEN

C  TIME IS AT OR PAST THE NEXT MULTIPLE OF TIMADD (I.E., IT IS A TIME
C  RESET POINT). IN THIS CASE, INCREASE NRESET BY 1 AND RECALCULATE
C  TIMERESET.

	  NRESET = NRESET + 1
	  TIMERESET = TIMADD*NRESET

C  FOR THIS TIME RESET, CHECK TO SEE IF THE FIRST DOSE LINE WILL BE
C  A STEADY STATE DOSE EVENT. THE NO. OF STEADY STATE DOSE EVENTS IN
C  THIS PATIENT'S FILE IS NSST(ISUB), AND THE NO. OF SUCH EVENTS THAT
C  HAVE ALREADY BEEN WRITTEN TO FILE 33 IS NSSEVENTS-1 SO FAR.


        IF(NSSEVENTS .LE. NSST(ISUB)) THEN


C  THE NEXT STEADY STATE DOSE EVENT OCCURS AFTER RESET NO.
C  DOSELINEST(ISUB,NSSEVENTS,100). CHECK TO SEE IF THIS VALUE IS
C  THE SAME AS NRESET. IF SO, THIS RESET STARTS WITH A STEADY STATE
C  LINE.

         XRESET = NRESET

         CALL THESAME(DOSELINEST(ISUB,NSSEVENTS,100),XRESET,ISAME)

         IF(ISAME .EQ. 1) THEN

C  FILL IN THE ENTRIES TO DOSELINE FOR THE STEADY STATE DOSE AT THE
C  BEGINNING OF THIS DOSE RESET.

C  THE FIRST ENTRY IN DOSELINST IS TIMEVENT = THE NEGATIVE OF THE
C  INTERDOSE INTERVAL.

          DOSELINES(1) = DOSELINEST(ISUB,NSSEVENTS,1)
          NENTRY = 1

C  FOR EACH DRUG, THE IV AND TOTAL VALUES ARE ALREADY STORED INTO

C  DOSELINEST(ISUB,NSSEVENTS,2*I) AND DOSELINEST(ISUB,NSSEVENTS,2*I+1),
C  I=1,NDRUG.

          DO IDRUG = 1,NDRUG

           NENTRY = NENTRY+1
           DOSELINES(NENTRY) = DOSELINEST(ISUB,NSSEVENTS,2*IDRUG)
           NENTRY = NENTRY+1
           DOSELINES(NENTRY) = DOSELINEST(ISUB,NSSEVENTS,2*IDRUG+1)
          END DO

C  FOR EACH COVARIATE, IF ANY, THE VALUES ARE STORED INTO
C  DOSELINEST(ISUB,NSSEVENTS,19+ICOV), ICOV = 1,NCOVA.

          IF(NCOVA .GT. 0) THEN
           DO ICOV = 1,NCOVA
            NENTRY = NENTRY+1
            DOSELINES(NENTRY) = DOSELINEST(ISUB,NSSEVENTS,19+ICOV)
           END DO
          ENDIF

          WRITE(33,1) (DOSELINES(J),J=1,NENTRY)

          NSSEVENTS = NSSEVENTS + 1

         ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(ISAME .EQ. 1)  CONDITION.


        ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(NSSEVENTS .LE. NSST(ISUB))  CONDITION.


	 ENDIF

C  THE ABOVE ENDIF IS FOR THE IF(TIME .GE. TIMADD*(NRESET+1)) CONDITION.



C  CHECK TO SEE IF ANY BOLUS TIMES = TIME.

	DO IDRUG = 1,NDRUG

C  IF THE CURRENT INDEX FOR THIS BOLUS IS MORE THAN THE NO.
C  OF ENTRIES IN THE CORRESPONDING ARRAY, IT MEANS THAT THERE ARE NO
C  MORE BOLUS VALUES FOR THIS DRUG. IN THAT CASE, SET ITS TIME TO -99.
C  OTHERWISE, SET ITS TIME TO THE NEXT TIME IN THE ARRAY.

	 IF(INDBOL(IDRUG) .GT. NTIMBOL(ISUB,IDRUG)) TIMEB = -99.D0

	 IF(INDBOL(IDRUG) .LE. NTIMBOL(ISUB,IDRUG)) THEN
	  TIMEB = TIMBOL(ISUB,IDRUG,INDBOL(IDRUG))
	 ENDIF

	 CALL THESAME(TIME,TIMEB,ISAME)


C  IF ISAME RETURNS FROM SUBROUTINE THESAME AS 1, THE TIMES ARE THE
C  "SAME" (I.E., WITHIN 1.D-10). IN THIS CASE, SET THE BOLUS VALUE FOR
C  THIS EVENT TO THE CORRESPONDING VALUE IN BOLUS, AND INCREASE THE
C  INDEX OF THE NEXT TIME BY 1. IF ISAME RETURNS AS 0, SET THE BOLUS
C  VALUE = 0.

	  IF(ISAME .EQ. 0) BOLVAL(IDRUG) = 0.D0


	  IF(ISAME .EQ. 1) THEN
	   BOLVAL(IDRUG) = BOLUS(ISUB,IDRUG,INDBOL(IDRUG))
	   INDBOL(IDRUG) = INDBOL(IDRUG) + 1
	  ENDIF

	 END DO


C  CHECK TO SEE IF ANY COVARIATE TIMES = TIME.

	DO ICOV = 1,NCOVA

C  IF THE CURRENT INDEX FOR THIS COVARIATE IS MORE THAN THE NO.
C  OF ENTRIES IN THE CORRESPONDING ARRAY, IT MEANS THAT THERE ARE NO
C  MORE COV VALUES FOR THIS COVARIATE. IN THAT CASE, SET ITS TIME TO
C  -99. OTHERWISE, SET ITS TIME TO THE NEXT TIME IN THE ARRAY.



	 IF(INDCOV(ICOV) .GT. NTIMCOV(ISUB,ICOV)) TIMEC = -99.D0

	 IF(INDCOV(ICOV) .LE. NTIMCOV(ISUB,ICOV)) THEN
	  TIMEC = TIMCOV(ISUB,ICOV,INDCOV(ICOV))
	 ENDIF

	 CALL THESAME(TIME,TIMEC,ISAME)


C  IF ISAME RETURNS FROM SUBROUTINE THESAME AS 1, THE TIMES ARE THE
C  "SAME" (I.E., WITHIN 1.D-10). IN THIS CASE, SET THE COVARIATE VALUE
C  FOR THIS EVENT TO THE CORRESPONDING VALUE IN COV, AND INCREASE THE
C  INDEX OF THE NEXT TIME BY 1.


        IF(ISAME .EQ. 1) THEN
         COVVAL(ICOV) = COV(ISUB,ICOV,INDCOV(ICOV))	   
         INDCOV(ICOV) = INDCOV(ICOV) + 1
        ENDIF


C  IF ISAME RETURNS AS 0, THE COV. VALUE WILL BE THE SAME AS IT WAS
C  PREVIOUSLY IF ICOVTYPE(ICOV) = 1 OR 0 (I.E., IF THIS IS A PIECEWISE
C  CONTINOUS COVARIATE). IT WILL ALSO BE THE SAME AS IT WAS PREVIOUSLY
C  IF ICOVTYPE(ICOV) = 2 (I.E., FOR A LINEARLY INTERPOLATED COVARIATE)
C  IF TIMEC = -99, OR IF ISAMERESET = 1. HERE IS WHY:

C  TIMEC = -99 --> THERE ARE NO MORE COVARIATE VALUES (SEE ABOVE).
C  IF ISAMERESET = 1, THEN THIS IS A TIME RESET POINT. AND IN THIS CASE,
C  EVEN AN INTERPOLATED COVARIATE VALUE SHOULD BE SET = ITS LAST VALUE
C  FROM BEFORE THE RESET, SINCE NO INTERPOLATION IS POSSIBLE FOR OUT OF
C  ORDER TIMES (E.G., (T,COV) = (24,400), FOLLOWED BY (T,COV) =
C  (20,1000) --> INTERPOLATED VALUE AT 0 WOULD BE:
C  (0-24)/(20-24) * (1000 - 400) + 400 = 4000, WHICH IS PREPOSTEROUS).


	IF(ISAME .EQ. 0) THEN

C  SET INTERP = 1, WHICH MEANS THAT THIS COVARIATE VALUE SHOULD BE
C  INTERPOLATED FROM THE TWO SURROUNDING COVARIATE VALUES (WHICH HAVE
C  BEEN EXPLICITLY SPECIFIED IN THE BLOCK FORMAT FILE). CHANGE INTERP
C  TO 0 IF THIS IS NOT AN INTERPOLATED COVARIATE (ICOVTYPE(ICOV) = 1
C  OR 0) OR IF THIS IS AN INTERPOLATED COVARIATE BUT THERE ARE NO MORE
C  COVARIATE VALUES FOR THIS COVARIATE (TIMEC = -99) OR IF THIS IS A
C  TIME RESET VALUE (ISAMERESET = 1), OR IF THE CURRENT COVARIATE TIME
C  (WHICH WOULD BE USED IN THE INTERPOLATION) IS AT OR PAST THE NEXT
C  TIME RESET.


	 INTERP = 1
	 IF(ICOVTYPE(ICOV) .EQ. 1 .OR. ICOVTYPE(ICOV) .EQ. 0)
     1    INTERP = 0
	 IF(TIMEC .LE. -99) INTERP = 0
	 IF(ISAMERESET .EQ. 1) INTERP = 0
	 IF(TIMEC .GE. TIMERESET + TIMADD) INTERP = 0


C  IF INTERP = 1:

C  NOTE THAT INDCOV(ICOV) MUST BE .GE. 2 UNLESS THE USER HAS MADE A
C  MISTAKE SINCE THE FIRST TIME (TIME = 0) IS SUPPOSED TO HAVE ALL
C  COVARIATE VALUES SPECIFIED, WHICH MEANS THE FIRST TIME THROUGH THIS
C  PART OF THE CODE ABOVE, INDCOV(ICOV) WAS INCREASED BY 1 (FROM ITS
C  ORIGINAL VALUE OF 1). IF THIS IS NOT TRUE, WRITE A MESSAGE TO THE
C  USER AND STOP.


	 IF(INDCOV(ICOV) .EQ. 1) THEN

	  WRITE(*,111) ICOV
  111     FORMAT(/' THERE IS A MISTAKE IN THE BLOCK FORMAT PATIENT'/
     1' DATA FILE. THE FIRST VALUE FOR COVARIATE NO. ',I2,' WAS NOT'/
     2' SPECIFIED AT THE ORIGINAL TIME = 0, AS IS REQUIRED. PLEASE'/
     3' FIX THIS ERROR AND RERUN THE PROGRAM. '//)
	  WRITE(*,401) ISUB,SUBID
  401     FORMAT(/' NOTE: THE ID FOR SUBJECT NO. ',I4,' IS ',A11/)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,111) ICOV
         WRITE(42,401) ISUB,SUBID
        CLOSE(42)	

	  CALL PAUSE
	  STOP

	 ENDIF


	 CLAST = COV(ISUB,ICOV,INDCOV(ICOV)-1)

	 IF(INTERP .EQ. 0) COVVAL(ICOV) = CLAST

	 IF(INTERP .EQ. 1) THEN


C  NOTE: THE LAST COV. VALUE WAS CLAST WHICH OCCURRED AT TLAST. THE NEXT
C  COV VALUE IS CNEXT WHICH OCCURS AT TNEXT. SO ESTABLISH THE
C  LINEARLY INTERPOLATED VALUE FOR THIS TIME, TIME. NOTE THAT THE TIMES,
C  TLAST AND TNEXT, MUST BE RECAST AS THEIR ACTUAL TIMES (BY REDUCING
C  THEM BY TIMERESET) FIRST.

	  TLAST = TIMCOV(ISUB,ICOV,INDCOV(ICOV)-1) - TIMERESET
	  CNEXT = COV(ISUB,ICOV,INDCOV(ICOV))
	  TNEXT = TIMCOV(ISUB,ICOV,INDCOV(ICOV)) - TIMERESET
	  TIMEREAL = TIME - TIMERESET
	  COVVAL(ICOV) = (TIMEREAL-TLAST)/(TNEXT-TLAST) * (CNEXT-CLAST)
     1     + CLAST
	 ENDIF


	ENDIF


C  THE ABOVE ENDIF IS FOR THE  IF(ISAME .EQ. 0)  CONDITION.




	 END DO

C  THE ABOVE END DO IS FOR THE  DO ICOV = 1,NCOVA  LOOP.




C  CHECK TO SEE IF ANY IV TIMES = TIME.

	DO IDRUG = 1,NDRUG

C  IF THE CURRENT INDEX FOR THIS IV IS MORE THAN THE NO.
C  OF ENTRIES IN THE CORRESPONDING ARRAY, IT MEANS THAT THERE ARE NO
C  MORE IV VALUES FOR THIS DRUG. IN THAT CASE, SET ITS TIME TO -99.
C  OTHERWISE, SET ITS TIME TO THE NEXT TIME IN THE ARRAY.

	 IF(INDIV(IDRUG) .GT. NTIMIV(ISUB,IDRUG)) TIMEI = -99.D0

	 IF(INDIV(IDRUG) .LE. NTIMIV(ISUB,IDRUG)) THEN
	  TIMEI = TIMIV(ISUB,IDRUG,INDIV(IDRUG))
	 ENDIF

	 CALL THESAME(TIME,TIMEI,ISAME)


C  IF ISAME RETURNS FROM SUBROUTINE THESAME AS 1, THE TIMES ARE THE
C  "SAME" (I.E., WITHIN 1.D-10). IN THIS CASE, SET THE IV VALUE FOR
C  THIS EVENT TO THE CORRESPONDING VALUE IN RATEIV, AND INCREASE THE
C  INDEX OF THE NEXT TIME BY 1. IF ISAME RETURNS AS 0, THE IV VALUE
C  WILL REMAIN WHAT IT WAS PREVIOUSLY.


	  IF(ISAME .EQ. 1) THEN
	   XIVVAL(IDRUG) = RATEIV(ISUB,IDRUG,INDIV(IDRUG))
	   INDIV(IDRUG) = INDIV(IDRUG) + 1
	  ENDIF

	 END DO


C  PUT THE ACTUAL TIME (I.E., TIME - TIMERESET) INTO THE 1ST ENTRY FOR
C  THIS ROW. THEN PUT IN THE IV/BOLUS VALUES FOR EACH OF THE NDRUG DRUGS
C  IN ORDER; THEN ALL ADDITIONAL COV. VALUES.

	 DOSELINE(ITIM,1) = TIME - TIMERESET
	 NENTRY = 1

	 DO IDRUG = 1,NDRUG
	  NENTRY = NENTRY+1
	  DOSELINE(ITIM,NENTRY) = XIVVAL(IDRUG)
	  NENTRY = NENTRY+1
	  DOSELINE(ITIM,NENTRY) = BOLVAL(IDRUG)
	 END DO

	 DO ICOV = 1,NCOVA
	  NENTRY = NENTRY+1
	  DOSELINE(ITIM,NENTRY) = COVVAL(ICOV)
	 END DO

       WRITE(33,1) (DOSELINE(ITIM,J),J=1,NENTRY)
    1  FORMAT(43(G19.9,1X))

 1000   CONTINUE

C  THE ABOVE LABEL IS THE END OF THE  DO 1000 ITIM = 1,NTIMI  LOOP.


C  NOW CHECK TO SEE IF THE DOSAGE REGIMEN ENDS WITH ONE OR MORE STEADY
C  STATE EVENTS. NOTE THAT THERE ARE NSST(ISUB) STEADY STATE EVENTS,
C  AND NSSEVENTS - 1 OF THESE HAVE BEEN WRITTEN TO THE WORKING COPY FILE


C  SO FAR. 

 1010   CONTINUE


        IF(NSSEVENTS .LE. NSST(ISUB)) THEN


C  THE NEXT STEADY STATE DOSE EVENT OCCURS AFTER RESET NO.
C  DOSELINEST(ISUB,NSSEVENTS,100). 

C  FILL IN THE ENTRIES TO DOSELINE FOR THE STEADY STATE DOSE AT THE
C  BEGINNING OF THIS DOSE RESET.

C  THE FIRST ENTRY IN DOSELINST IS TIMEVENT = THE NEGATIVE OF THE
C  INTERDOSE INTERVAL.

          DOSELINES(1) = DOSELINEST(ISUB,NSSEVENTS,1)

          NENTRY = 1

C  FOR EACH DRUG, THE IV AND TOTAL VALUES ARE ALREADY STORED INTO
C  DOSELINEST(ISUB,NSSEVENTS,2*I) AND DOSELINEST(ISUB,NSSEVENTS,2*I+1),
C  I=1,NDRUG.

          DO IDRUG = 1,NDRUG

           NENTRY = NENTRY+1
           DOSELINES(NENTRY) = DOSELINEST(ISUB,NSSEVENTS,2*IDRUG)

           NENTRY = NENTRY+1
           DOSELINES(NENTRY) = DOSELINEST(ISUB,NSSEVENTS,2*IDRUG+1)
          END DO

C  FOR EACH COVARIATE, IF ANY, THE VALUES ARE STORED INTO
C  DOSELINEST(ISUB,NSSEVENTS,19+ICOV), ICOV = 1,NCOVA.


          IF(NCOVA .GT. 0) THEN
           DO ICOV = 1,NCOVA
            NENTRY = NENTRY+1
            DOSELINES(NENTRY) = DOSELINEST(ISUB,NSSEVENTS,19+ICOV)
           END DO
          ENDIF

          WRITE(33,1) (DOSELINES(J),J=1,NENTRY)

          NSSEVENTS = NSSEVENTS + 1
 

          GO TO 1010

        ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(NSSEVENTS .LE. NSST(ISUB))  CONDITION.



C----------------- WRITE THE DOSE EVENTS ABOVE -------------------------


C----------------- WRITE THE OBSERVATION EVENTS BELOW ------------------


	WRITE(33,106) NOUT
  106   FORMAT(/'     ',I1,' ... NO. OF TOTAL OUTPUT EQUATIONS')

C  EACH SET OF TIMES FOR EACH OUTPUT EQUATION, TIMOUT(ISUB,IOUT,I),
C  I = 1,NTIMOUT(ISUB,IOUT), IS IN ORDER, BUT EACH TIME HAS ADDED
C  TO IT TIMADD*NRESET, WHERE NRESET IS THE NO. OF TIME RESETS UP TO
C  AND TIME.

C  CALL FIXOUTIM TO OBTAIN NTIMORD, TIMORD, AND BLOCKOUT, WHERE
C  NTIMORD IS THE TOTAL NO. OF UNIQUE TIMES TO BE PUT INTO THE
C  OBSERVATION BLOCK; TIMORD(.) IS THE ORDERED ACTUAL TIMES (I.E., EACH
C  OF THE TIMES IN TIMOUT(.,.,.) HAS BEEN REDUCED BY TIMADD*NRESET - SEE
C  ABOVE), EXCEPT THAT EACH TIME OF 0 IS NOT ORDERED (IT INDICATES THE
C  NEXT TIME RESET) FOR THE OBSERVATION BLOCK; AND BLOCKOUT IS THE
C  CORRESPONDING ARRAY OF OBSERVED VALUES FOR THE NOUT OUTPUT EQUATIONS
C  AT THE TIMES IN TIMORD.


	CALL FIXOUTIM(MAXSUB,ISUB,SUBID,NOUT,NTIMOUT,TIMOUT,OUT,NTIMORD,
     1   TIMORD,BLOCKOUT,TIMADD,MAXNUMEQ)

      	WRITE(33,62) NTIMORD
   62   FORMAT('   ',I3,' ... NO. OF OBSERVED VALUE TIMES')

	DO I = 1,NTIMORD
	 WRITE(33,63) TIMORD(I),(BLOCKOUT(I,J),J=1,NOUT)
   63    FORMAT(7(G16.8,1X))
	END DO


C----------------- WRITE THE OBSERVATION EVENTS ABOVE ------------------




C----------------- WRITE THE BOTTOM OF FILE BELOW ----------------------

	WRITE(33,303)
  303   FORMAT(/' COVARIATE NAMES AND VALUES (1ST, LAST, AND MEAN) FOLLO
     1W:')

C  FOR NOW, THE MEAN VALUE OF EACH COV. WILL BE -99 ... UNTIL WE DECIDE
C  WHAT KIND OF MEAN WE WANT. E.G., IF A COV. = 100 AT T=0 AND
C  200 AT T = 10 AND 300 AT T = 11, WHICH IS THE LAST TIME, DO WE
C  SIMPLY AVERAGE 100,200, AND 300, OR DO WE TAKE A WEIGHTED MEAN
C  WHICH WOULD BE (100*10 + 200*1 + 300*0)/11, OR SOMETHING ELSE

	XMEAN = -99
	DO ICOV = 1,NCOVA
   	 WRITE(33,304) COVNAME(ICOV),COV(ISUB,ICOV,1),
     1    COV(ISUB,ICOV,NTIMCOV(ISUB,ICOV)),XMEAN
	END DO
  304   FORMAT(A11,3X,3(F15.5,1X))

	WRITE(33,306)
  306   FORMAT(/'ASSAY COEFFICIENTS FOLLOW, ONE SET FOR EACH OUTPUT EQUA
     1TION:')

        DO K = 1,NOUT
         WRITE(33,3061) (CSUB(ISUB,I,K),I=1,4)
        END DO

 3061   FORMAT(4(F17.8,1X))


C----------------- WRITE THE BOTTOM OF FILE ABOVE ----------------------

	CLOSE(33)


	RETURN
	END

C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
	SUBROUTINE THESAME(X1,X2,ISAME)
	IMPLICIT REAL*8(A-H,O-Z)

C  THIS ROUTINE CHECKS TO SEE IF X1 AND X2 ARE VIRTUALLY THE SAME
C  VALUES (I.E., IF THEY ARE WITHIN 1.D-10 OF EACH OTHER). IF SO,
C  ISAME RETURNS AS 1; IF NOT ISAME RETURNS AS 0.

	ISAME = 0
	XDEL = DABS(X1-X2)
	IF(XDEL .LE. 1.D-10) ISAME = 1

	RETURN
	END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
	SUBROUTINE GETID(SUBID)
	CHARACTER SUBID*11,SUB*11

C  THIS ROUTINE IS CALLED TO REPLACE SUBID (WHICH HAS 11 CHARACTERS IN
C  IT) WITH THE CHARACTERS UP TO BUT NOT INCLUDING THE 1ST COMMA.

	SUB = '           '


	DO I = 1,11
	 IF(SUBID(I:I) .NE. ',') SUB(I:I) = SUBID(I:I)
	 IF(SUBID(I:I) .EQ. ',') GO TO 10
	END DO

   10   SUBID = SUB


	RETURN
	END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
	SUBROUTINE TIMESET(MAXSUB,ISUB,SUBID,NTIMALL,TIMALL,NTIMI,
     1    TIMI)

	IMPLICIT REAL*8(A-H,O-Z)
	DIMENSION TIMALL(MAXSUB,5000),NTIMALL(MAXSUB),TIMI(5000),
     1   TIM(5000)
	CHARACTER SUBID*11



C  THIS ROUTINE IS CALLED BY READBLOCK, TO ORDER ALL THE NTIMALL(ISUB)

C  TIMES IN TIMALL(ISUB,.), ELIMINATING DUPLICATE TIMES.

C  RETURNED TO READBLOCK IS THE VECTOR TIMI, WITH NTIMI TIMES,
C  ESTABLISHED AS INDICATED ABOVE.



C  THE FIRST TIME IS TIMALL(ISUB,1) AND SHOULD BE 0. CHECK THIS FIRST.

	CALL THESAME(TIMALL(ISUB,1),0.D0,ISAME)

C  IF ISAME RETURNS FROM SUBROUTINE THESAME AS 1, THE TIMES ARE THE
C  "SAME" (I.E., WITHIN 1.D-10). OTHERWISE, THE TIMES ARE NOT THE
C  SAME AND ISAME = 0.

C  STARTING WITH NPAG104.FOR, DO NOT CHECK THAT THE FIRST DOSE TIME IN
C  EACH PATIENT IS 0, SINCE THE FIRST TIME MAY BE NEGATIVE (WHICH 
C  SIGNIFIES THE DOSAGE REGIMEN BEGINS WITH A STEADY STATE OF DOSES).


C	IF(ISAME .EQ. 0) THEN
C	 WRITE(*,1) ISUB,TIMALL(ISUB,1)
C   1    FORMAT(/' THE FIRST TIME IN THE DOSAGE BLOCK FOR SUBJECT ',I5,
C    1' IS NOT 0; IT IS ',G14.5//
C    2' THIS IS NOT ALLOWED. PLEASE SET THE FIRST TIME IN THE DOSAGE'/
C    3' BLOCKS FOR ALL SUBJECTS TO BE 0, AND RERUN THE PROGRAM.')
C	 WRITE(*,401) ISUB,SUBID
C 401    FORMAT(/' NOTE: THE ID FOR SUBJECT NO. ',I4,' IS ',A11/)
C      CALL PAUSE
C	 STOP
C	ENDIF




C  CALL SUBROUTINE PUTORDER TO ORDER THE NTIMALL(ISUB) VALUES IN
C  TIMALL(ISUB,.).


	DO I = 1,NTIMALL(ISUB)
	 TIM(I) = TIMALL(ISUB,I)

	END DO


	CALL PUTORDER(NTIMALL(ISUB),TIM)


C  THE NTIMALL(ISUB) VALUES ARE NOW ORDERED IN TIM.


C  THE CODE BELOW BELOW WILL REMOVE DUPLICATE TIMES.

	TIMELAST = -1.D39

	NTIMI = 0

	DO I = 1,NTIMALL(ISUB)

	 TIME = TIM(I)
	 CALL THESAME(TIME,TIMELAST,ISAME)

C  IF ISAME RETURNS FROM SUBROUTINE THESAME AS 1, TIME = TIMELAST (OR AT
C  LEAST, THEY ARE WITHIN 1.D-10), AND THIS TIME CAN BE IGNORED SINCE IT
C  WAS ALREADY PUT INTO TIMI (ACTUALLY THE VALUE REDUCED BY TIMERESET)
C  BY A PREVIOUS TIME.

	 IF(ISAME .EQ. 1) GO TO 30

C  TO GET HERE, ISAME = 0, WHICH MEANS THIS IS A NEW TIME. SO PUT
C  TIME INTO TIMI. THEN SET TIMELAST = TIME AND CONTINUE THE LOOP.

	  NTIMI = NTIMI + 1

	  TIMI(NTIMI) = TIME
	  TIMELAST = TIME


   30    CONTINUE

	END DO


	RETURN
	END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

C
	SUBROUTINE PUTORDER(NX,XX)

C  SUBROUTINE PUTORDER IS CALLED BY SUBROUTINE TIMESET. IT INPUTS XX, A
C  VECTOR OF SIZE, NX, AND RETURNS XX, BUT WITH THE VALUES
C  ORDERED FROM LOW TO HIGH.

	IMPLICIT REAL*8(A-H,O-Z)
	DIMENSION XX(5000),Y(5000),IZ(5000),IZZ(5000)


C  ORDER THE NX VALUES IN X AS FOLLOWS:

C  PUT THE NX VALUES INTO VECTOR Y TO START.
C  INITIALIZE VECTOR IZ TO BE -99 IN ALL ITS NX LOCATIONS. THEN, FOR
C  EXAMPLE, IF ENTRY 17 IS THE SMALLEST VALUE IN Y, IZ(17) WILL BE
C  SET = 0, AND THE PROGRAM WILL KNOW NOT TO CHECK THE 17TH ENTRY
C  AGAIN (SINCE IT HAS ALREADY BEEN SELECTED). IF THE NEXT SMALLEST
C  ENTRY HAS INDEX 37, THEN IZ(37) WILL BE SET = 0, ETC.

C  NOTE THAT IZZ WILL BE THE ARRAY WHICH CONTAINS THE ACTUAL ORDERING.
C  IN THE EXAMPLE ABOVE, IZZ(1) = 17, IZZ(2) = 37. IT WILL BE EASY TO
C  ASSIGN ORDERED VALUES BACK INTO XX USING IZZ. IN THE EXAMPLE ABOVE,
C  XX(1) = Y(IZZ(1)) = Y(17), XX(2) = Y(IZZ(2)) = Y(37), ETC.

	 DO I=1,NX
	  Y(I) = XX(I)
	  IZ(I) = -99
	 END DO


	 DO IPLACE = 1,NX

C  PUT THE NEXT LOWEST VALUE OF Y INTO THE IPLACE LOCATION OF
C  IZZ.

C  TEMP IS THE RUNNING VALUE OF THE NEXT VALUE TO BE PLACED INTO Y.
C  INITIALIZE IT TO BE VERY HIGH VALUE SO THE FIRST VALUE Y WILL BE
C  SURE TO BE LOWER THAN IT IS.

	  TEMP = 1.D50

	  DO I=1,NX
	   IF(Y(I) .LT. TEMP .AND. IZ(I) .EQ. -99) THEN
	    TEMP = Y(I)
	    IND = I
	   ENDIF
	  END DO

C  AT THIS POINT, IND IS THE INDEX OF THE SMALLEST REMAINING VALUE
C  (TEMP) IN Y. PUT THIS INFORMATION INTO IZZ. ALSO,
C  SET IZ(IND) = 0 --> THE IND LOCATION IN Y HAS BEEN USED.

	  IZZ(IPLACE) = IND
	  IZ(IND) = 0

	 END DO

C  AT THIS POINT IZZ CONTAINS THE ORDERED INDICES (LOW TO HIGH) OF Y.
C  USE THIS TO RE-ESTABLISH X TO BE ORDERED LOW TO HIGH.

	 DO I = 1,NX
	  XX(I) = Y(IZZ(I))
	 END DO




	RETURN
	END

C

CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

C
	SUBROUTINE FIXOUTIM(MAXSUB,ISUB,SUBID,NOUT,NTIMOUT,TIMOUT,OUT,
     1   NTIMORD,TIMORD,BLOCKOUT,TIMADD,MAXNUMEQ)

	IMPLICIT REAL*8(A-H,O-Z)

	DIMENSION TIMOUT(MAXSUB,MAXNUMEQ,650),NTIMOUT(MAXSUB,MAXNUMEQ),
     1 IENTRY(MAXNUMEQ),OUT(MAXSUB,MAXNUMEQ,650),TIMORD(3900),
     2 BLOCKOUT(3900,MAXNUMEQ)

	CHARACTER SUBID*11,ERRFIL*20

      COMMON/ERROR/ERRFIL
C  COMMON/ERROR/ IS SUPPLIED TO ALL THE ROUTINES WHICH COULD WRITE TO
C  ERRFIL. 


C  FIXOUTIM IS CALLED BY WRITEDOS TO ORDER THE OUTPUT TIMES AMONG ALL
C  THE NOUT OUTPUT EQUATIONS. NOTE THAT EACH OF THE TIMES CURRENTLY IN
C  TIMOUT HAS BEEN INCREASE BY TIMERESET = TIMADD*NRESET, WHERE NRESET
C  IS THE NO. OF TIME RESETS UP TO AND INCLUDING THAT TIME (THIS WAS
C  DONE IN SUBROUTINE READBLOCK).


C  RETURNED TO SUBROUTINE WRITEDOS ARE:

C  NTIMORD = NO. OF TIME VALUES IN TIMORD.

C  TIMORD(I), I=1,NTIMORD = THE ORDERED SET OF TIMES (EXCEPT FOR 0'S
C   WHICH INDICATE A TIME RESET) OVER ALL THE NOUT TIME ARRAYS.


C  BLOCKOUT(I,J) = OBSERVED VALUE FOR IOUTPUT EQUATION J, FOR THE TIME
C   VALUE, TIMORD(I), I=1,NEXT; J = I,NOUT.


C  NOTE THAT EACH OF THE TIME ARRAYS, TIMOUT(ISUB,IOUT,.) HAS ITS OWN
C  VALUES IN ORDER (THEY WERE FILLED IN ORDER IN READBLOCK). NOW,
C  ESTABLISH THE ARRAY, TIMORD, WHICH HAS THE ORDERED SET OF
C  TIMES OVER ALL THE NOUT TIME ARRAYS. ALSO, REDUCE EACH TIME BY
C  TIMRESET = NRESET*TIMADD TO RETURN EACH TIME TO ITS ORIGINAL VALUE.
C  NOTE THAT THIS WILL HAVE THE EFFECT OF SETTING TO 0 THE TIMES WHICH
C  ARE THE TIME RESET POINTS (THEIR ACCOMPANYING OUTPUT VALUES WILL
C  OF COURSE BE SET TO -99).

C  INITIALIZE THE NEXT TIME TO BE PUT INTO TIMORD TO BE A LARGE NO.
C  AND INITIALIZE THE INDEX OF THE NEXT ENTRY IN EACH OF THE TIMOUT
C  ARRAYS TO BE 1. ALSO INITIALIZE INEXT TO BE 1. IT WILL BE THE
C  RUNNING INDEX OF THE NEXT ENTRY TO BE PUT INTO TIMORD.




	DO IOUT = 1,NOUT
	 IENTRY(IOUT) = 1
	END DO

	INEXT = 1

   20	TIMENEXT = 1.D50

C  SET IANOTHER = 0. IF IT STAYS 0, THERE ARE NO MORE TIMES IN
C  ANY OF THE ARRAYS.

	 IANOTHER = 0


        DO IOUT	= 1,NOUT

C  FOR OUTPUT EQUATION IOUT, IF IENTRY(IOUT) .LE. THE NO. OF ENTRIES
C  IN THE TIME ARRAY FOR IOUT, THEN THIS ENTRY IS EQUATION IOUT'S
C  CANDIDATE FOR THE NEXT LOWEST TIME.

	 IF(IENTRY(IOUT) .LE. NTIMOUT(ISUB,IOUT)) THEN
	  IANOTHER = 1
	  IF(TIMOUT(ISUB,IOUT,IENTRY(IOUT)) .LE. TIMENEXT)
     1     TIMENEXT = TIMOUT(ISUB,IOUT,IENTRY(IOUT))
	 ENDIF


	END DO


C  IF IANOTHER = 0, ALL TIME ARRAY, AND CORRESPONDING OBSERVED, VALUES
C  HAVE BEEN STORED, SO GO TO 100 TO RECAST TIMORD BEFORE RETURNING.

	IF(IANOTHER .EQ. 0) GO TO 100


C  AT THIS POINT, TIMENEXT IS THE NEXT LOWEST TIME OVER ALL THE NOUT
C  TIMOUT ARRAYS. PUT IT INTO TIMORD, AND PUT THE CORRESPONDING ENTRIES
C  FOR EACH OF THE NOUT OUTPUT EQUATIONS INTO THE ARRAY BLOCKOUT. ALSO,
C  INCREASE THE ENTRY NO. FOR THE TIME ARRAY(S) WHICH HAD THIS TIME.
C  BUT CHECK THAT THE NO. OF ENTRIES INTO TIMORD IS NOT > THE MAX, 3900.
C  IF IT IS, STOP.

	IF(INEXT .GT. 3900) THEN


	 WRITE(*,1)
    1    FORMAT(/' THE TOTAL NO. OF OBSERVATION TIMES IS GREATER THAN'/
     1' THE MAXIMUM ALLOWABLE VALUE OF 3900 (SUBROUTINE FIXOUTIM).'/
     2' RERUN THE PROGRAM AFTER REDUCING THE NO. OF OBS. TIMES.'/)
	 WRITE(*,401) ISUB,SUBID
  401    FORMAT(/' NOTE: THE ID FOR SUBJECT NO. ',I4,' IS ',A11/)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,1) 
         WRITE(42,401) ISUB,SUBID
        CLOSE(42)	


	 CALL PAUSE
	 STOP

	ENDIF

	TIMORD(INEXT) = TIMENEXT


        DO IOUT	= 1,NOUT

	  BLOCKOUT(INEXT,IOUT) = -99.D0
	  CALL THESAME(TIMENEXT,TIMOUT(ISUB,IOUT,IENTRY(IOUT)),ISAME)


	  IF(ISAME .EQ. 1) THEN
	   BLOCKOUT(INEXT,IOUT) = OUT(ISUB,IOUT,IENTRY(IOUT))
	   IENTRY(IOUT) = IENTRY(IOUT) + 1
	  ENDIF

	END DO


	INEXT = INEXT + 1

	GO TO 20


  100   NTIMORD = INEXT - 1


C  NOW, RECAST TIMORD TO BE THE CORRECT TIME VALUES. RECALL THAT,
C  CURRENTLY, EACH TIME HAS NRESET*TIMADD ADDED TO ITS VALUE WHERE
C  NRESET IS THE NO. OF TIME RESET 0'S UP TO AND INCLUDING THAT TIME

C  VALUE.

C  INITIALIZE NRESET = 0. THIS IS THE RUNNING NUMBER OF TIME RESETS
C  THAT HAVE OCCURED. ALSO INITIALIZE TIMERESET AS THE CURRENT AMOUNT
C  OF TIME TO SUBTRACT TO DO THE RECASTING.

	NRESET = 0

	TIMERESET = TIMADD*NRESET

	DO I = 1,NTIMORD
	 CALL THESAME(TIMORD(I),TIMADD*(NRESET+1),ISAME)

	 IF(ISAME .EQ. 1) THEN
	  NRESET = NRESET + 1
	  TIMERESET = TIMADD*NRESET
	 ENDIF

	 TIMORD(I) = TIMORD(I) - TIMERESET
	END DO


	RETURN

	END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

C
	SUBROUTINE GETMAXTIM(NCOVA,TIMAX)

	IMPLICIT REAL*8(A-H,O-Z)
	CHARACTER READLINE*1000


C  THIS SUBROUTINE IS CALLED BY READBLOCK TO GET TIMAX, THE MAXIMUM TIME
C  OVER ALL SUBJECTS IN FILE 66. THIS MAXIMUM TIME INCLUDES THE ENDING
C  TIME FOR ALL IV RATES.



C  GO THROUGH ALL THE ROWS OF THE BLOCK FORMAT FILE. READ THE EVENT
C  TIMES IN ENTRY 3. IF THE ROW IS AN IV ROW, ADD THIS VALUE TO THE
C  DURATION TIME IN ENTRY 4. THEN UPDATE TIMAX IF THIS TOTAL TIME IS
C  > TIMAX, WHICH IS INITIALIZED BELOW TO BE NEGATIVE.


C  AS OF NPAG109.FOR, WRITE LINE TO THE SCREEN INFO ABOUT THE 
C  MAXIMUM TIME SO FAR IN CASE THERE ARE A LARGE NO. OF PATIENTS
C  WITH A LOT OF DATA. OTHERWISE, THERE COULD BE A LONG "DEAD" TIME ON
C  THE SCREEN MAKING THE PROGRAM LOOK LIKE IT HAS "HUNG".

      WRITE(*,103) 
  103 FORMAT(' FINDING THE MAXIMUM TIME OVER ALL SUBJECTS ... '/)



      TIMAX = -1.D0

   10 READ(66,1,IOSTAT=IEND) READLINE
    1 FORMAT(A1000)
      IF(IEND .LT. 0) RETURN
      IF(READLINE(1:1) .EQ. '#' .OR. READLINE(1:2) .EQ. '"#') GO TO 10

      CALL AFTERCOMMA(NCOVA,READLINE,2)
      BACKSPACE(57)
      READ(57,*) TIMEVENT
      CLOSE(57)

      CALL AFTERCOMMA(NCOVA,READLINE,3)
      BACKSPACE(57)
      READ(57,*,ERR=15) TIMDUR
      GO TO 20
   15 TIMDUR = 0.D0
   20 TIME = TIMEVENT + TIMDUR
      CLOSE(57)

      IF(TIMAX .LT. TIME) TIMAX = TIME

C  AS OF NPAG109.FOR (SEE ABOVE), WRITE OUT THE TIME TO THE SCREEN.
      WRITE(*,104) TIME,TIMAX
  104 FORMAT(' TIME AND MAX TIME ARE: ',2(G20.10,2X))




      GO TO 10

      END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
      SUBROUTINE WRITEINFILE(NENTRY,PATHFILAST,IDELTA,XMIC,ICENT,
     1   AUCINT,AF,INDPTS,MAXCYC,JSTOP,TOLC,NUMEQT,C0P,C1P,C2P,C3P,
     2   IERRMOD,GAMLAM0,IASS,NOFIX,VALFIX,NVAR,AB,NSUB,NSUBTOT,MAXSUB,
     3   IPATVEC,IFORMT,BLOCKPAT,PREFIX,EXT,NDRUG,FORFILE,NDIM,NP,IRAN,
     4   PAR,PARFIX,TOLER,INPRI,PRIFIL2,MAXNUMEQ,NRANFIX,PARRANFIX,
     5   RANFIXEST)

	IMPLICIT REAL*8(A-H,O-Z)

      COMMON/TOWRITE/IALLIN,IVERIFY,NCOVA,ICOVTYPE,COVNAME

C  AS OF NPAG112.FOR, COMMON/TOWRITE IS PROVIDED TO 
C  SUBROUTINE WRITEINFILE FROM READBLOCK, OR PROVIDED TO READBLOCK
C  FROM MAIN.


      DIMENSION C0P(MAXNUMEQ),C1P(MAXNUMEQ),C2P(MAXNUMEQ),C3P(MAXNUMEQ),
     1 IASS(MAXNUMEQ),VALFIX(20),AB(30,2),IPATVEC(MAXSUB),AF(7),
     2 IRAN(32),ICOVTYPE(26),RANFIXEST(20)


	CHARACTER PATHFILAST*73,PREFIX*5,EXT*3,BLOCKPAT*20,PAR(30)*11,
     1  PARFIX(20)*11,PRIFIL2*20,FORFILE*20,COVNAME(26)*11,
     2  PARRANFIX(20)*11

C  WRITEINFILE IS CALLED BY MAIN AND VERIF1 TO WRITE INTO FILE, 

C  PATHFILAST, THE FIRST NENTRY SETS OF ENTRIES OF STORED INFO. ALL
C  SUBSEQUENT ENTRIES ARE WRITTEN WITH DEFAULT VALUES OR -99's SINCE 
C  THEY HAVE NOT YET BEEN READ IN.

	IF(NENTRY .LT. 2) THEN
	 NSUB = 1
	 NSUBTOT = NSUB
	 IPATVEC(1) = I
	ENDIF

	IF(NENTRY .LT. 3) THEN

       NDRUG = 1
       AF(1) = 1.D0

	 IF(NOFIX .GT. 0) THEN
	  DO I = 1,NOFIX
	   VALFIX(I) = -99.D0
	  END DO
	 ENDIF

	 IF(NRANFIX .GT. 0) THEN
	  DO I = 1,NRANFIX
	   RANFIXEST(I) = -99.D0
	  END DO
	 ENDIF


	 DO I=1,NVAR
	  AB(I,1) = -99.D0
	  AB(I,2) = -99.D0
	 END DO

	ENDIF


	IF(NENTRY .LT. 4) THEN

	 IF(NENTRY .LT. 3) NUMEQT = 1

	 DO IEQ = 1,NUMEQT
	  C0P(IEQ) = 0
	  C1P(IEQ) = .1
	  C2P(IEQ) = 0
	  C3P(IEQ) = 0
        IASS(IEQ) = 1
	 END DO


	 IERRMOD = 1
	 GAMLAM0 = -99.D0

	ENDIF


	IF(NENTRY .LT. 5) THEN

C  NDRUG HAS BEEN READ IN SINCE NENTRY = 3, BUT THE AF(I),I=1,NDRUG
C  WILL NOT BE READ IN UNTIL NENTRY = 5. SO DEFAULT THEM TO 1 HERE.

       DO I = 1,NDRUG
        AF(I) = 1.D0
       END DO

	 INDPTS=6
	 MAXCYC=99
	 JSTOP=3
       TOLC = .01D0


	ENDIF


	IF(NENTRY .LT. 6) THEN
	 IDELTA=12
	 XMIC=1.D0
	 ICENT=2
	 AUCINT = 24.D0
	ENDIF

      IF(NENTRY .LT. 7) THEN
       INPRI = 1
       PRIFIL2 = ' '
      ENDIF

      IF(NENTRY .LT. 8) THEN
       NCOVA = -99
      ENDIF 



C  NOW OPEN AND REWRITE FILE, PATHFILAST.

        OPEN(29,FILE=PATHFILAST)

        WRITE(29,7123) 'REM_BAK OCT_15'
7123    FORMAT(A14)

C  THE FIRST ENTRY IS IVERIFY. IF IVERIFY = 0, THIS CODE WOULD BE
C  IRRELEVANT SINCE THE INSTRUCTION FILE WILL BE USED WITHOUT CHANGE.
C  SO WRITE FILE AS IF IVERIFY = 1, BECAUSE THAT'S THE ONLY CONDITION
C  IN WHICH THIS FILE WILL BE USED.

        IVERIFY = 1
        WRITE(29,9111)
 9111   FORMAT(' IVERIFY: 1 --> YES; 0 --> NO')
        WRITE(29,*) IVERIFY

        WRITE(29,9112)
 9112   FORMAT(' FORTRAN MODEL FILE')
        WRITE(29,2) FORFILE
    2   FORMAT(A20)

        WRITE(29,9113)
 9113   FORMAT(' NDIM')
        WRITE(29,*) NDIM

        WRITE(29,9114)
 9114   FORMAT(' NP')
        WRITE(29,*) NP

        WRITE(29,9116)
 9116   FORMAT(' IRAN INDICES')
        WRITE(29,*) (IRAN(I),I=1,NP)

        WRITE(29,9117) 
 9117   FORMAT(' NVAR')
        WRITE(29,*) NVAR

        WRITE(29,9118)
 9118   FORMAT(' PAR(I),I=1,NVAR')
        DO I = 1,NVAR
         WRITE(29,1717) PAR(I)
        END DO
 1717   FORMAT(A11)
    
        WRITE(29,9119)
 9119   FORMAT(' AB ARRAY')
        DO I = 1,NVAR
         WRITE(29,*) (AB(I,J),J=1,2)
        END DO    

        WRITE(29,9121)
 9121   FORMAT(' NOFIX')
        WRITE(29,*) NOFIX

        WRITE(29,9122)
 9122   FORMAT(' PARFIX(I),I=1,NOFIX, IF NOFIX > 0')
        IF(NOFIX .GT. 0) THEN
         DO I = 1,NOFIX
          WRITE(29,1717) PARFIX(I)
         END DO
        ENDIF

        WRITE(29,9123)
 9123   FORMAT(' VALFIX ARRAY IF NOFIX > 0')
        IF(NOFIX .GT. 0) WRITE(29,*) (VALFIX(I),I=1,NOFIX)


        WRITE(29,9137)
 9137   FORMAT(' NRANFIX')
        WRITE(29,*) NRANFIX

        WRITE(29,9138)
 9138   FORMAT(' PARRANFIX(I),I=1,NRANFIX, IF NRANFIX > 0')
        IF(NRANFIX .GT. 0) THEN
         DO I = 1,NRANFIX
          WRITE(29,1717) PARRANFIX(I)
         END DO
        ENDIF

        WRITE(29,9139)
 9139   FORMAT(' RANFIXEST ARRAY IF NRANFIX > 0')
        IF(NRANFIX .GT. 0) WRITE(29,*) (RANFIXEST(I),I=1,NRANFIX)


        WRITE(29,9124)
 9124   FORMAT(' O.D.E. TOLERANCE')
        WRITE(29,*) TOLER

        WRITE(29,8111)
 8111   FORMAT(' IFORMT ')


        IF(IFORMT .EQ. 3) IFORMTT = 1
        IF(IFORMT .EQ. 1) IFORMTT = 2
        WRITE(29,*) IFORMTT

        IF(IFORMT .EQ. 1) THEN
         WRITE(29,8112)

 8112    FORMAT(' PREFIX')
         WRITE(29,2222) PREFIX
 2222    FORMAT(A5)

         WRITE(29,8113)
 8113    FORMAT(' EXT')
         WRITE(29,222) EXT
  222    FORMAT(A3)
        ENDIF


        IF(IFORMT .EQ. 3) THEN

         WRITE(29,8114)
 8114    FORMAT(' BLOCKPAT')
         WRITE(29,2) BLOCKPAT

         WRITE(29,9141)
 9141    FORMAT(' NCOVA')
         WRITE(29,*) NCOVA  

         WRITE(29,9142)
 9142    FORMAT(' COVNAME(I),I=1,NCOVA, IF NCOVA > 0')
         IF(NCOVA .GT. 0) THEN
         DO I = 1,NCOVA
          WRITE(29,1717) COVNAME(I)
         END DO
        ENDIF

        WRITE(29,9143)
 9143   FORMAT(' ICOVTYPE ARRAY IF NCOVA > 0')
        IF(NCOVA .GT. 0) WRITE(29,*) (ICOVTYPE(I),I=1,NCOVA)
 
        ENDIF

C  ABOVE ENDIF IS FOR THE  IF(IFORMT .EQ. 3)  CONDITION.

        WRITE(29,8116)
 8116   FORMAT(' NSUBTOT')
        WRITE(29,*) NSUBTOT

        WRITE(29,8117)
 8117   FORMAT(' NSUB')
        WRITE(29,*) NSUB

        WRITE(29,8118)
 8118   FORMAT(' ACTIVE PATIENT NUMBERS, FOLLOWED BY A LINE WITH 0')


C  CALL SUBROUTINE WRITEPT2 TO WRITE THE PATIENT NOS. TO BE USED IN
C  THE ANALYSIS TO FILE 29 ... IN AN "EFFICIENT" WAY, AS OPPOSED TO
C  ONE INDEX PER LINE. NOTE THAT THE FIRST ARGUMENT TELLS WRITEPT2
C  TO WRITE TO FILE 29. NOTE THAT THE '    0' AFTER THE CALL TO
C  WRITEPT2 TELLS THE PROGRAM READING THIS FILE THAT THE PATIENT
C  NOS. HAVE ENDED.

        CALL WRITEPT2(29,NSUB,MAXSUB,IPATVEC)
        WRITE(29,*) '    0'

        WRITE(29,8124)
 8124   FORMAT(' NUMEQT')
        WRITE(29,*) NUMEQT

        WRITE(29,8126)
 8126   FORMAT(' NUMEQT LINES OF ASSAY COEFFICIENTS')

        DO IEQ=1,NUMEQT
         WRITE(29,161) C0P(IEQ),C1P(IEQ),C2P(IEQ),C3P(IEQ)
        END DO
  161   FORMAT(4(G16.10,2X))

        WRITE(29,8127)
 8127   FORMAT(' IERRMOD')
        WRITE(29,*) IERRMOD

        WRITE(29,8128)
 8128   FORMAT(' GAMLAM0')
        WRITE(29,*) GAMLAM0

        WRITE(29,8129)
 8129   FORMAT(' IASS(I),I=1,NUMEQT')

        WRITE(29,*) (IASS(I),I=1,NUMEQT)

        WRITE(29,9131)
 9131   FORMAT(' NDRUG')
        WRITE(29,*) NDRUG

        WRITE(29,8131)
 8131   FORMAT(' AF(I),I=1,NDRUG')
        WRITE(29,*) (AF(I),I=1,NDRUG)

        WRITE(29,8132)

 8132   FORMAT(' INDPTS')
        WRITE(29,*) INDPTS

        WRITE(29,8133)
 8133   FORMAT(' MAXCYC')
        WRITE(29,*) MAXCYC

        WRITE(29,8134)
 8134   FORMAT(' JSTOP')
        WRITE(29,*) JSTOP

        WRITE(29,8136)
 8136   FORMAT(' IF JSTOP .NE. 1, TOLC IS ON NEXT LINE')
        IF(JSTOP .NE. 1) WRITE(29,*) TOLC

        WRITE(29,8137)
 8137   FORMAT(' IDELTA')
        WRITE(29,*) IDELTA

        WRITE(29,8138)
 8138   FORMAT(' XMIC')
        WRITE(29,*) XMIC

        WRITE(29,8139)
8139   FORMAT(' ICENT, WHICH IS NOW IRRELEVANT')
        WRITE(29,*) ICENT

        WRITE(29,8141) 
 8141   FORMAT(' AUCINT')
        WRITE(29,*) AUCINT

        WRITE(29,9126)
 9126   FORMAT(' INPRI')
        WRITE(29,*) INPRI

        WRITE(29,9127)
 9127   FORMAT(' NAME OF APRIORI DENSITY FILE IF INPRI = 0')
        IF(INPRI .EQ. 0) WRITE(29,2) PRIFIL2


        CLOSE(29)

        RETURN
        END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
        SUBROUTINE PAUSE


C  THIS ROUTINE IS USED TO REPLACE A PAUSE STATEMENT, WHICH CAUSES 
C  WARNINGS WHEN THIS PROGRAM IS COMPILED AND LINKED USING gfortran
C  (AND FORCES THE USER TO TYPE "go" INSTEAD OF SIMPLY HITTING THE
C  ENTER KEY).

        WRITE(*,1)
    1   FORMAT(' HIT ANY KEY TO CONTINUE: ')
        READ(*,*,ERR=10) IKEY
        IF(IKEY .EQ. 1) RETURN
   10   RETURN
        END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
        SUBROUTINE NEWCSV

C  NEWCSV IS CALLED BY MAIN TO CONVERT THE .CSV FILE IN FILE 77 TO
C  A NEW .CSV FILE IN FILE 67, WITH ALL MISSING VALUE DOTS CHANGED TO
C  n's. THIS CODE IS BASED ON THE STAND-A-LONE PROGRAM NEWCSV.FOR.

C  IN PARTICULAR, THE FOLLOWING SEQUENCES WILL BE REPLACED AS SHOWN:

C   ,.,  WILL BE REPLACED BY  ,n,
C   ,.   WILL BE REPLACED BY  ,n  <-- THIS OCCURS AT END OF LINES.


C  NOTE THAT THE SECOND SEQUENCE ABOVE IS COMMA/DOT/SPACE, NOT JUST
C  COMMA/DOT SINCE WE DON'T WANT ,.35  REPLACED BY ,n35, FOR EXAMPLE.

        IMPLICIT REAL*8(A-H,O-Z)

        CHARACTER READLINE*1000

C  WRITE EACH LINE OF FILE 77 TO FILE 67, BUT REPLACE ALL MISSING VALUE
C  DOTS WITH n's.  


   10   READ(77,4,IOSTAT=IEND) READLINE
    4   FORMAT(A1000)
        IF(IEND .LT. 0) GO TO 100

C  FOR THIS LINE, READLINE, FIND IENDL, THE LAST CHARACTER WHICH IS NOT
C  BLANK. THEN ONLY CHARACTERS 1:IENDL WILL BE WRITTEN TO FILEOUT.

        DO IENDL = 1000,1,-1
         IF(READLINE(IENDL:IENDL) .NE. ' ') GO TO 20
        END DO


   20   CONTINUE

C  BEFORE WRITING READLINE(1:IENDL) TO FILE 22, GO THROUGH THE LINE AND
C  REPLACE ANY DOTS WHICH REPRESENT MISSING VALUES WITH n's.

C  NOTE THAT, AS EXPLAINED ABOVE, THIS MEANS REPLACING AS FOLLOWS:
C   ,.,  WILL BE REPLACED BY  ,n,
C   ,.   WILL BE REPLACED BY  ,n  <-- THIS OCCURS AT END OF LINES.

        DO I = 1,IENDL-2
         IF(READLINE(I:I+2) .EQ. ',.,') READLINE(I:I+2) = ',n,'
        END DO


        IF(READLINE(IENDL-1:IENDL) .EQ. ',.') 
     1   READLINE(IENDL-1:IENDL) = ',n'
      

C  CANNOT USE WRITE(67,4) READLINE(1:IENDL) SINCE, FOR SOME REASON,
C  WRITING LIKE THIS "RIGHT JUSTIFIES" THE CHARACTERS AT THE END
C  OF THE A1000 FORMAT. INSTEAD MUST WRITE (67,__) READLINE, WHERE
C  THE FORMAT IS DETERMINED BY THE LAST NON-BLANK CHARACTER (IENDL)
C  IN READLINE.


	IF(IENDL .LE. 26) THEN
	 WRITE(67,26) READLINE
   26    FORMAT(A26)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 51) THEN
	 WRITE(67,51) READLINE
   51    FORMAT(A51)

	 GO TO 10
	ENDIF

	IF(IENDL .LE. 76) THEN
	 WRITE(67,76) READLINE
   76    FORMAT(A76)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 101) THEN


	 WRITE(67,101) READLINE
  101    FORMAT(A101)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 126) THEN
	 WRITE(67,126) READLINE
  126    FORMAT(A126)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 151) THEN
	 WRITE(67,151) READLINE
  151    FORMAT(A151)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 176) THEN
	 WRITE(67,176) READLINE
  176    FORMAT(A176)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 201) THEN
	 WRITE(67,201) READLINE
  201    FORMAT(A201)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 226) THEN
	 WRITE(67,226) READLINE
  226    FORMAT(A226)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 251) THEN
	 WRITE(67,251) READLINE
  251    FORMAT(A251)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 276) THEN
	 WRITE(67,276) READLINE
  276    FORMAT(A276)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 301) THEN
	 WRITE(67,301) READLINE
  301    FORMAT(A301)
	 GO TO 10
	ENDIF


	IF(IENDL .LE. 326) THEN
	 WRITE(67,326) READLINE

  326    FORMAT(A326)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 351) THEN
	 WRITE(67,351) READLINE
  351    FORMAT(A351)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 376) THEN
	 WRITE(67,376) READLINE
  376    FORMAT(A376)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 401) THEN
	 WRITE(67,401) READLINE
  401    FORMAT(A401)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 426) THEN
	 WRITE(67,426) READLINE
  426    FORMAT(A426)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 451) THEN
	 WRITE(67,451) READLINE
  451    FORMAT(A451)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 476) THEN

	 WRITE(67,476) READLINE
  476    FORMAT(A476)
	 GO TO 10
	ENDIF



	IF(IENDL .LE. 501) THEN

	 WRITE(67,501) READLINE
  501    FORMAT(A501)
	 GO TO 10

	ENDIF


	IF(IENDL .LE. 526) THEN
	 WRITE(67,526) READLINE
  526    FORMAT(A526)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 551) THEN
	 WRITE(67,551) READLINE



  551    FORMAT(A551)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 576) THEN
	 WRITE(67,576) READLINE
  576    FORMAT(A576)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 601) THEN
	 WRITE(67,601) READLINE
  601    FORMAT(A601)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 626) THEN
	 WRITE(67,626) READLINE
  626    FORMAT(A626)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 651) THEN
	 WRITE(67,651) READLINE
  651    FORMAT(A651)
	 GO TO 10

	ENDIF

	IF(IENDL .LE. 676) THEN
	 WRITE(67,676) READLINE
  676    FORMAT(A676)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 701) THEN
	 WRITE(67,701) READLINE
  701    FORMAT(A701)
	 GO TO 10

	ENDIF

	IF(IENDL .LE. 726) THEN
	 WRITE(67,726) READLINE

  726    FORMAT(A726)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 751) THEN
	 WRITE(67,751) READLINE
  751    FORMAT(A751)
	 GO TO 10
	ENDIF


	IF(IENDL .LE. 776) THEN
	 WRITE(67,776) READLINE

  776    FORMAT(A776)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 801) THEN
	 WRITE(67,801) READLINE


  801    FORMAT(A801)
	 GO TO 10

	ENDIF

	IF(IENDL .LE. 826) THEN
	 WRITE(67,826) READLINE
  826    FORMAT(A826)
	 GO TO 10

	ENDIF

	IF(IENDL .LE. 851) THEN
	 WRITE(67,851) READLINE
  851    FORMAT(A851)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 876) THEN
	 WRITE(67,876) READLINE
  876    FORMAT(A876)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 901) THEN
	 WRITE(67,901) READLINE

  901    FORMAT(A901)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 926) THEN
	 WRITE(67,926) READLINE
  926    FORMAT(A926)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 951) THEN
	 WRITE(67,951) READLINE
  951    FORMAT(A951)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 976) THEN
	 WRITE(67,976) READLINE
  976    FORMAT(A976)
	 GO TO 10
	ENDIF

	WRITE(67,4) READLINE
	GO TO 10


  100   CLOSE(77)
        REWIND(67)

        RETURN
        END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
      SUBROUTINE CONVERTCSV
      IMPLICIT REAL*8(A-H,O-Z)
      CHARACTER READLINE*1000,ERRFIL*20

      COMMON/ERROR/ERRFIL
C  COMMON/ERROR/ IS SUPPLIED TO ALL THE ROUTINES WHICH COULD WRITE TO
C  ERRFIL. 


C  SUBROUTINE CONVERTCSV READS FILE 87 AND WRITES SCRATCH FILE 77.
C  IF FILE 87 IS ALREADY IN THE TYPICAL "AMERICAN" .CSV FORMAT, 
C  FILE 77 IS THE SAME AS FILE 87. 

C  IF FILE 87 IS IN THE "EUROPEAN" .CSV FORMAT, WHERE SEMICOLONS
C  ARE THE FIELD SEPARATORS, AND COMMAS ARE USED TO SEPARATE THE
C  WHOLE AND FRACTIONAL PARTS OF NUMBERS, IT WILL BE WRITTEN TO
C  FILE 77 WITH THE INDICATED CHANGES BELOW.


C  FILE 87 IS AT LINE 1. READ PAST THIS LINE TO READ LINE 2 AND CHECK
C  FOR A SEMICOLON. IF ONE IS FOUND, THEN THIS IS A "EUROPEAN" VERSION OF
C  A .CSV FILE. NOTE THAT IT IS ONLY NECESSARY TO CHECK THE FIRST FEW
C  CHARACTERS OF THIS LINE - EITHER THERE WILL BE COMMAS OR SEMICOLONS.
C  IF THERE ARE BOTH COMMAS AND SEMICOLONS, SOMETHING IS WRONG WITH THE
C  FILE; IN THIS CASE, PRINT A MESSAGE TO THE USER AND STOP.
C  NOTE THAT, EVEN IN THE "EURO" VERSION, IT WILL STILL BE ASSUMED THAT
C  A DOT REPRESENTS AN UNNEEDED VALUE.

        READ(87,*)
        READ(87,4) READLINE

        ICOMMA = 0
        ISEMICOLON = 0

        DO I = 1,20
         IF(READLINE(I:I) .EQ. ',') ICOMMA = 1
         IF(READLINE(I:I) .EQ. ';') ISEMICOLON = 1
        END DO

C  IF ICOMMA = 1 AND ISEMICOLON = 0, NO CONVERSION IS NEEDED AS THIS
C  FILE IS A TYPICAL .CSV FILE. IN THIS CASE SET ICONVERT = 0.

C  IF ICOMMA = 0 AND ISEMICOLON = 1, CONVERT THIS FILE AS FOLLOWS:
C  a. CHANGE ALL COMMAS TO PERIODS; THEN
C  b. CHANGE ALL SEMICOLONS TO COMMAS.
C  IN THIS CASE, SET ICONVERT = 1.

C  IF ICOMMA = 1 AND ISEMICOLON = 1, STOP THE PROGRAM WITH A MESSAGE TO
C  THE USER.

        IF(ICOMMA .EQ. 1 .AND. ISEMICOLON .EQ. 1) THEN

         WRITE(*,121)
  121    FORMAT(/' YOUR .CSV FILE HAS BOTH COMMAS AND SEMICOLONS IN '/

     1' THE SECOND LINE. THIS IS A CONFLICT. IF YOU ARE USING THE '/
     2' "EUROPEAN" VERSION OF A .CSV FILE, WITH SEMICOLONS AS FIELD'/
     3' SEPARATORS AND COMMAS TO SEPARATE THE WHOLE AND FRACTIONAL'/
     4' PARTS OF NUMBERS, THERE SHOULD BE NO COMMAS IN THE SECOND'/
     5' LINE.'//
     6' SIMILARLY IF YOU ARE USING THE "AMERICAN" VERSION OF A .CSV'/
     7' FILE, WITH COMMAS AS FIELD SEPARATORS, AND PERIODS TO SEPARTE'/
     8' THE WHOLE AND FRACTIONAL PARTS OF NUMBERS, THERE SHOULD BE NO'/
     9' SEMICOLONS IN THE SECOND LINE.'//
     1' PLEASE CORRECT YOUR .CSV FILE AND RERUN THE PROGRAM.'//)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,121) 
        CLOSE(42)	

         CALL PAUSE
         STOP

        ENDIF


        IF(ICOMMA .EQ. 1 .AND. ISEMICOLON .EQ. 0) ICONVERT = 0
        IF(ICOMMA .EQ. 0 .AND. ISEMICOLON .EQ. 1) ICONVERT = 1      

        REWIND(87)
        OPEN(77)


C  COPY FILE 87 TO FILE 77 BUT MAKE THE INDICATED CHANGES, IF
C  ICONVERT = 1, LINE BY LINE.

   10   READ(87,4,IOSTAT=IEND) READLINE
    4   FORMAT(A1000)
        IF(IEND .LT. 0) GO TO 100

C  FOR THIS LINE, READLINE, FIND IENDL, THE LAST CHARACTER WHICH IS NOT
C  BLANK. THEN ONLY CHARACTERS 1:IENDL WILL BE WRITTEN TO FILEOUT.

        DO IENDL = 1000,1,-1
         IF(READLINE(IENDL:IENDL) .NE. ' ') GO TO 20
        END DO


   20   CONTINUE

        DO I = 1,IENDL
         IF(ICONVERT .EQ. 1) THEN
          IF(READLINE(I:I) .EQ. ',') READLINE(I:I) = '.'
          IF(READLINE(I:I) .EQ. ';') READLINE(I:I) = ','
         ENDIF
        END DO


C  CANNOT USE WRITE(77,4) READLINE(1:IENDL) SINCE, FOR SOME REASON,
C  WRITING LIKE THIS "RIGHT JUSTIFIES" THE CHARACTERS AT THE END
C  OF THE A1000 FORMAT. INSTEAD MUST WRITE (77,__) READLINE, WHERE
C  THE FORMAT IS DETERMINED BY THE LAST NON-BLANK CHARACTER (IENDL)
C  IN READLINE.

	IF(IENDL .LE. 26) THEN
	 WRITE(77,26) READLINE
   26    FORMAT(A26)
	 GO TO 10
	ENDIF


	IF(IENDL .LE. 51) THEN
	 WRITE(77,51) READLINE
   51    FORMAT(A51)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 76) THEN
	 WRITE(77,76) READLINE
   76    FORMAT(A76)
	 GO TO 10

	ENDIF

	IF(IENDL .LE. 101) THEN

	 WRITE(77,101) READLINE
  101    FORMAT(A101)

	 GO TO 10
	ENDIF

	IF(IENDL .LE. 126) THEN
	 WRITE(77,126) READLINE
  126    FORMAT(A126)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 151) THEN
	 WRITE(77,151) READLINE
  151    FORMAT(A151)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 176) THEN
	 WRITE(77,176) READLINE
  176    FORMAT(A176)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 201) THEN
	 WRITE(77,201) READLINE
  201    FORMAT(A201)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 226) THEN
	 WRITE(77,226) READLINE
  226    FORMAT(A226)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 251) THEN

	 WRITE(77,251) READLINE
  251    FORMAT(A251)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 276) THEN
	 WRITE(77,276) READLINE
  276    FORMAT(A276)

	 GO TO 10
	ENDIF

	IF(IENDL .LE. 301) THEN
	 WRITE(77,301) READLINE
  301    FORMAT(A301)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 326) THEN

	 WRITE(77,326) READLINE
  326    FORMAT(A326)
	 GO TO 10
	ENDIF


	IF(IENDL .LE. 351) THEN
	 WRITE(77,351) READLINE
  351    FORMAT(A351)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 376) THEN
	 WRITE(77,376) READLINE
  376    FORMAT(A376)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 401) THEN
	 WRITE(77,401) READLINE
  401    FORMAT(A401)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 426) THEN
	 WRITE(77,426) READLINE
  426    FORMAT(A426)
	 GO TO 10
	ENDIF


	IF(IENDL .LE. 451) THEN
	 WRITE(77,451) READLINE
  451    FORMAT(A451)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 476) THEN

	 WRITE(77,476) READLINE
  476    FORMAT(A476)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 501) THEN
	 WRITE(77,501) READLINE
  501    FORMAT(A501)
	 GO TO 10
	ENDIF


	IF(IENDL .LE. 526) THEN
	 WRITE(77,526) READLINE
  526    FORMAT(A526)
	 GO TO 10
	ENDIF


	IF(IENDL .LE. 551) THEN

	 WRITE(77,551) READLINE
  551    FORMAT(A551)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 576) THEN
	 WRITE(77,576) READLINE
  576    FORMAT(A576)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 601) THEN
	 WRITE(77,601) READLINE
  601    FORMAT(A601)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 626) THEN
	 WRITE(77,626) READLINE
  626    FORMAT(A626)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 651) THEN
	 WRITE(77,651) READLINE
  651    FORMAT(A651)
	 GO TO 10
	ENDIF


	IF(IENDL .LE. 676) THEN
	 WRITE(77,676) READLINE
  676    FORMAT(A676)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 701) THEN
	 WRITE(77,701) READLINE
  701    FORMAT(A701)
	 GO TO 10

	ENDIF


	IF(IENDL .LE. 726) THEN
	 WRITE(77,726) READLINE
  726    FORMAT(A726)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 751) THEN
	 WRITE(77,751) READLINE
  751    FORMAT(A751)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 776) THEN
	 WRITE(77,776) READLINE

  776    FORMAT(A776)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 801) THEN
	 WRITE(77,801) READLINE
  801    FORMAT(A801)
	 GO TO 10

	ENDIF

	IF(IENDL .LE. 826) THEN
	 WRITE(77,826) READLINE
  826    FORMAT(A826)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 851) THEN
	 WRITE(77,851) READLINE
  851    FORMAT(A851)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 876) THEN
	 WRITE(77,876) READLINE

  876    FORMAT(A876)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 901) THEN
	 WRITE(77,901) READLINE
  901    FORMAT(A901)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 926) THEN
	 WRITE(77,926) READLINE
  926    FORMAT(A926)
	 GO TO 10
	ENDIF

	IF(IENDL .LE. 951) THEN
	 WRITE(77,951) READLINE
  951    FORMAT(A951)
	 GO TO 10
	ENDIF


	IF(IENDL .LE. 976) THEN
	 WRITE(77,976) READLINE
  976    FORMAT(A976)
	 GO TO 10
	ENDIF

	WRITE(77,4) READLINE
	GO TO 10



  100   CLOSE(87)
        REWIND(77)


        RETURN
        END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
      SUBROUTINE CSVCHANGE

C  SUBROUTINE CSVCHANGE IS CALLED BY MAIN AND SUBROUTINE GETNUMEQ TO
C  CHANGE .csv FILES WITH CODE OF POPDATA DEC_11 (I.E., THOSE WITH 2
C  EXTRA COLUMNS FOR ADDL AND II) TO EQUIVALENT .csv FILES WITH CODE OF
C  POPDATA APR_11 (THOSE WITHOUT THE TWO EXTRA COLUMNS). IT READS
C  FILE 67, AND WRITES THE INFORMATION TO SCRATCH FILE 66. NOTE THAT IF
C  THE .csv FILE READ IN ALREADY IS THE OLDER VERSION (WITH CODE 
C  POPDATA APR_11), THIS ROUTINE SIMPLY REWRITES IT TO FILE 66, WHICH IS
C  THEN READ BY SUBROUTINE READBLOCK.

C  THIS ROUTINE IS BASED ON THE STAND-A-LONE PROGRAM, CSVCHANGE.FOR.
C  AS OF IT2B104.FOR, THIS ROUTINE IS BASED ON CSVCHANGE2.FOR.

C  CSVCHANGE.FOR                                           12/6/11


C  THIS PROGRAM CONVERTS THE NEW-STYLE .csv FILES (WITH TWO ADDITIONAL
C  COLUMNS (ADDL AND II) TO THE PREVIOUS .csv FORMAT.

C  ADDL GIVES THE NO. OF ADDITIONAL DOSES FOR ANY DOSE EVENT, AND II
C  GIVES THE INTERDOSE INTERVAL FOR THE ADDITIONAL DOSES.

C  EX: IF TIME = 0, DUR = 2, DOSE = 1000, ADDL = 2, II = 12, THIS
C  PROGRAM WOULD PUT IN TWO EXTRA LINES AS FOLLOWS:

C  TIME    DUR    DOSE  ADDL  II    
C   0       2     1000   2    12  <-- ONLY LINE IN NEW-STYLE FILE
C  12       2     1000   <-- THESE TWO LINES ARE ADDED TO THE OLD
C  24       2     1000       STYLE FILE (WHICH DOESN'T HAVE ADDL AND
C                            II COLUMNS.

C  NOTE THAT ADDL = -1 IS A STEADY STATE DOSE INDICATOR. IN THIS CASE,
C  CHANGE THE TIME OF THE DOSE TO -II, SO SUBROUTINES READBLOCK/WRITEDOS
C  WILL RECOGNIZE THE LINE AS THE BEGINNING OF A STEADY STATE DOSE SET.

C  NOTE THAT ONCE ALL THE ADDITIONAL DOSES ARE ADDED TO THE DOSE
C  ARRAY, THEY MUST ALL BE ORDERED AMONG THEMSELVES (UNTIL THE NEXT
C  DOSE/TIME RESET) SINCE READBLOCK EXPECTS ORDERED DOSES. BUT IT IS
C  OK FOR ALL THE DOSES IN A GIVEN REGION TO COME FIRST, AND THEN ALL
C  THE OBSERVATIONS TO FOLLOW (I.E., THE DOSES SHOULD BE ORDERED AMONG
C  THEMSELVES AND THE OBSERVATIONS FOLLOW THE DOSES, ORDERED AMONG
C  THEMSELVES).

C  NOTE THAT ADDL AND II ENTRIES ARE IGNORED IF EVID = 0 (I.E.,THE
C  EVENT IS AN OBSERVATION).

C  NOTE THAT IF ADDL AND II ARE MISSING FOR A DOSE EVENT (EVID = 1 OR
C  4) THEN ADDL IS ASSUME TO BE 0 (NO ADDITIONAL DOSES) AND II IS
C  IRRELEVANT.

C  NOTE THAT THIS PROGRAM WILL OPEN AND READ THE NEW-STYLE .csv
C  FILE FROM FILE 67, AND THEN WRITE THE PREVIOUS .csv FORMAT TO FILE
C  66.

      IMPLICIT REAL*8(A-H,O-Z)
      DIMENSION TIMENTRY(99999),IDENTRY(99999)

      CHARACTER READLINE*1000,CODEPAT*15,
     1 READLINE2*1000,HOLDMAT(99999)*1000,TIMCHAR*50,SUBID*11,
     2 SUBIDPREV*11,ERRFIL*20

      COMMON/ERROR/ERRFIL
C  COMMON/ERROR/ IS SUPPLIED TO ALL THE ROUTINES WHICH COULD WRITE TO
C  ERRFIL. 



    1 FORMAT(A1000)

    2 FORMAT(A20)

      OPEN(66)

      ICODEPAT = 0


    6 FORMAT(A15)
      ICODEPAT = -1


      READ(67,6) CODEPAT

      IF(CODEPAT .EQ. '"POPDATA DEC_11') ICODEPAT = 1
      IF(CODEPAT(1:14) .EQ. 'POPDATA DEC_11') ICODEPAT = 1


      IF(CODEPAT .EQ. '"POPDATA APR_11') ICODEPAT = 0
      IF(CODEPAT(1:14) .EQ. 'POPDATA APR_11') ICODEPAT = 0


      IF(ICODEPAT .EQ. -1) THEN

       WRITE(*,7)
    7  FORMAT(//' YOUR PATIENT DATA BLOCK FILE IS NOT FROM THE'/
     1' ALLOWABLE SET OF SUCH FILES.'//
     2' A PATIENT DATA BLOCK FILE MUST HAVE "POPDATA XXX_XX IN'/
     3' COLUMNS 1 THROUGH 15 ON LINE 1, WHERE  XXX_XX  IS APR_11 OR A '/
     4' MORE RECENT DATE.'//)
       WRITE(*,*)' THE PROGRAM STOPS.'

        OPEN(42,FILE=ERRFIL)
         WRITE(42,7) 
         WRITE(42,*)' THE PROGRAM STOPS.'
        CLOSE(42)	

       CALL PAUSE
       STOP

      ENDIF

C  IF ICODEPAT = 0, THE INPUT .csv FILE IS ALREADY IN THE CORRECT FORM

C  TO BE READ BY SUBROUTINE READBLOCK. IN THIS CASE, JUST COPY FILE 67,
C  LINE BY LINE TO FILE 66.


      IF(ICODEPAT .EQ. 0) THEN

C  WRITE THE TOP LINE (WITH THE CODE) TO FILE 66.

       CODEPAT = 'POPDATA APR_11'
       WRITE(66,6) CODEPAT


 1020  READ(67,1,IOSTAT=IEND) READLINE
        IF(IEND .LT. 0) THEN
         CLOSE(67)
         RETURN
        ENDIF
       WRITE(66,1) READLINE
       GO TO 1020

      ENDIF


C  ICODEPAT = 1. SO WRITE THE INFO IN FILE 67 TO FILE 66 IN THE OLD
C  FORMAT (WITHOUT THE TWO COLUMNS FOR ADDL AND II).

C  WRITE THE TOP LINE (WITH THE CODE) TO FILE 66.

      CODEPAT = 'POPDATA APR_11'
      WRITE(66,6) CODEPAT

C  READ THE 2ND LINE OF FILE 67 AND WRITE THIS LINE TO FILE 66, BUT
C  WITHOUT THE ADDL AND II NAMES. 

      READ(67,1) READLINE

C  SEARCH FOR THE CHARACTER STRING  ",ADDL,II"  IN THE EARLY PART OF

C  READLINE AND ELIMINATE IT, BEFORE WRITING THE LINE TO FILE 66. IF
C  THIS STRING IS NOT FOUND, TELL THE USER HIS FILE 67 HAS AN ERROR IN 
C  IT, AND STOP


      DO I = 1,50
       IF(READLINE(I:I+7) .EQ. ',ADDL,II') THEN
        ISS = I
        GO TO 10
       ENDIF
      END DO


C  TO GET HERE MEANS THE ABOVE STRING WAS NEVER FOUND. SO WRITE A 
C  MESSAGE TO THE USER AND STOP.

       WRITE(*,8)
    8  FORMAT(//' YOUR PATIENT DATA BLOCK FILE IS NOT FROM THE '/
     1' ALLOWABLE SET OF SUCH FILES.'//
     2' A PATIENT DATA BLOCK FILE MUST HAVE ",ADDL,II" AS THE 6TH AND'/
     3' 7TH COLUMN HEADINGS ON LINE 2.'//)
       WRITE(*,*)' THE PROGRAM STOPS.'

        OPEN(42,FILE=ERRFIL)
         WRITE(42,8) 
         WRITE(42,*)' THE PROGRAM STOPS.'
        CLOSE(42)	

       CALL PAUSE
       STOP


   10 CONTINUE

C  PUT ALL OF READLINE, EXCEPT ENTRIES ISS:ISS+7 INTO READLINE2,
C  AND WRITE READLINE2 INTO FILE 66.

      READLINE2(1:ISS-1) = READLINE(1:ISS-1)
      READLINE2(ISS:992) = READLINE(ISS+8:1000)
      WRITE(66,1) READLINE2


C  EACH LINE IN FILE 67, STARTING WITH LINE 3 (EXCEPT FOR LINES 
C  BEGINNING WITH #) HAS A SUBJECT ID IN THE 1ST 11 ENTRIES. THEN
C  THE ENTRIES ARE, IN ORDER, EVID, TIME, DUR, DOSE, ADDL, II, INPUT,
C  ...


C  READ EACH DOSE LINE (EVID = 1 OR 4) TO OBTAIN THE VALUES OF ADDL AND
C  II FOR THOSE. ADDL IS THE NO. OF ADDITIONAL DOSE LINES THAT ARE 
C  IDENTICAL TO THE CURRENT LINE, AND II IS THE ASSOCIATED INTERDOSE
C  INTERVAL. IF ADDL = -1, THIS REPRESENTS A STEADY STATE SET OF DOSES.

C  FOR A DOSE LINE, IF ADDL = 0 OR IS MISSING (WHICH MEANS ADDL IS
C  ASSUMED TO BE 0), WRITE THE LINE, WITHOUT THE ADDL AND II VALUES,
C  INTO HOLDMAT. 

C  FOR EACH DOSE LINE WITH AN ADDL > 0, WRITE THAT LINE
C  WITHOUT THE ADDL AND II VALUES, AND ADDL MORE SIMILAR LINES INTO THE
C  HOLDMAT, MAKING SURE THAT THE TIME FOR EACH SUCCESSIVE LINE
C  IS INCREASED BY II FROM THE PREVIOUS LINE.

C  NOTE THAT THE ABOVE PROCESS CAN CAUSE THE DOSE LINES TO BE OUT OF
C  ORDER IN HOLDMAT. EACH BLOCK OF DOSE LINES WILL BE 
C  ORDERED UP TO THE NEXT DOSE/TIME RESET LINE BELOW. AND NOTE THAT
C  ALL THE DOSES IN EACH REGION (UNTIL THE NEXT TIME RESET LINE - I.E.,
C  UNTIL THE NEXT EVID = 4) WILL BE WRITTEN TOGETHER, AND THEN BE
C  FOLLOWED BY ALL THE OBSERVATION LINES IN THAT REGION).

C  NOTE BELOW THAT AFTERCOMMA OPENS AND PUTS INTO FILE 57 THE PART OF
C  READLINE WHICH IS BETWEEN COMMA C AND COMMA C+1, WHERE C IS THE 3RD
C  ARGUMENT. ALSO,NOTE THAT NCOVA MUST BE PROVIDED TO AFTERCOMMA SO IT
C  WILL KNOW THE TOTAL NO. OF COMMAS IN READLINE, WHICH = 13 + NCOVA 
C  SINCE THIS FILE HAS 14 FIXED FIELDS (COUNTING THE 2 NEWS ONES, 
C  ADDL AND II).
C  
C  SO, FIRST FIND NCOVA FROM READLINE JUST READ IN (THE 2ND LINE OF THE
C  .csv FILE).

        NCOMMA = 0

        DO ISTART = 1,1000	 
         IF(READLINE(ISTART:ISTART) .EQ. ',') THEN
          NCOMMA = NCOMMA + 1
         ENDIF
        END DO

        NCOVA = NCOMMA - 13

C  INITIALIZE SUBIDPREV (THE PREVIOUS SUBJECT ID), AND THE CURRENT
C  SUBJECT TO BE '%^&*'.

	SUBIDPREV = '%^&*'
	SUBID = '%^&*'
      NROW = 0


C  NROW IS THE RUNNING INDEX OF THE NEXT LINE TO BE PUT INTO THE
C  HOLDMAT.


   20 READ(67,1,IOSTAT=IEND) READLINE


C  IF IEND .LT. 0, THE FILE HAS BEEN READ THROUGH COMPLETELY, SO GO TO
C  LABEL 100 TO WRITE THE LAST SUBJECT'S ROWS TO FILE 66.

	IF(IEND .LT. 0) GO TO 100

C  IF READLINE(1:1) IS #, THIS LINE IS A COMMENT LINE AND CAN BE
C  SKIPPED (I.E., NOT WRITTEN INTO HOLDMAT).

      IF(READLINE(1:1) .EQ. '#') GO TO 20



C  WILL ALSO GO TO LABEL 100 IF THIS SUBJECT ID IS DIFFERENT THAN
C  SUBIDPREV (SINCE THAT MEANS THAT THE PREVIOUS SUBJECT'S LINES ARE
C  READY TO BE WRITTEN TO FILE 66).    


C  THE FIRST VALUE (I.E., AFTER COMMA NO. 0) IS THE SUBJECT ID.

	CALL AFTERCOMMA(NCOVA,READLINE,0)
	BACKSPACE(57)
	READ(57,222) SUBID
  222 FORMAT(A11)
	CLOSE(57)

C  NOTE THAT SUBID CONTAINS THE 1ST 11 CHARACTERS OF THE LINE, BUT THE
C  SUBJECT ID IS JUST THE SET OF CHARACTERS PRIOR TO THE 1ST COMMA.
C  CALL SUBROUTINE GETID TO CORRECT THE VALUE OF SUBID.

	CALL GETID(SUBID)

      IF(SUBID .NE. SUBIDPREV) GO TO 100


C  TO GET TO THIS POINT, SUBID = SUBIDPREV, WHICH MEANS THIS IS A
C  LINE FOR THE CURRENT SUBJECT.

C  IF THE EVENT ID, IN ENTRY NO. 2 (I.E., AFTER COMMA NO. 1) IN 
C  READLINE IS 0, THE LINE REPRESENTS AN OBSERVATION AND CAN BE WRITTEN
C  INTO HOLDMAT, EXCEPT FOR ADDL AND II AS DONE ABOVE.

	CALL AFTERCOMMA(NCOVA,READLINE,1)
	BACKSPACE(57)
      READ(57,*,ERR=470) IDEVENT
	CLOSE(57)
      GO TO 480

  470  WRITE(*,471) READLINE(1:75)
  471  FORMAT(/' THERE IS AN ERROR IN YOUR BLOCK FORMAT FILE FOR '/
     1' ONE OF YOUR SUBJECTS. THE EVENT ID IS MISSING. THE 1ST 75'/
     2' CHARACTERS OF THE LINE ARE: '/
     2A75//
     3' THE PROGRAM STOPS.'/)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,471) READLINE(1:75)
        CLOSE(42)	

  	 CALL PAUSE
	 STOP

 480  CONTINUE

      IF(IDEVENT .EQ. 0) THEN
       NROW = NROW + 1
       CALL GETCOM(NCOMMA,READLINE,I5,I7)
       HOLDMAT(NROW) = READLINE(1:I5)//READLINE(I7+1:1000)
      ENDIF

C  IF THE EVENT ID IS 1 OR 4, THE LINE REPRESENTS A DOSE
C  EVENT (1 -> REGULAR DOSE; 4 -> TIME RESET EVENT WITH A DOSE). EITHER
C  WAY IF THE ENTRY FOR ADDL IS MISSING OR A 0, IT MEANS THAT THIS LINE
C  REPRESENTS A SINGLE DOSE. IF ADDL > 0, THIS LINE MUST BE COPIED
C  ADDL TIMES. NOTE THAT THE ADDL ENTRY IS NO. 6, AFTER COMMA NO. 5.

      IF(IDEVENT .EQ. 1 .OR. IDEVENT .EQ. 4) THEN


       CALL AFTERCOMMA(NCOVA,READLINE,5)
       BACKSPACE(57)
       READ(57,*,ERR=25) IADDL
       CLOSE(57)
       GO TO 30

   25  IADDL = 0


C  TO GET TO LABEL 25 MEANS IADDL TRIED TO READ A NON-NUMBER, WHICH 
C  MEANS IT IS MISSING --> IT IS EQUIVALENT TO 0. IN THIS CASE, WRITE
C  THE LINE INTO HOLDMAT, EXCEPT FOR IADDL AND II AS 
C  DONE ABOVE.

   30  CONTINUE
       

       IF(IADDL .GE. 0) THEN
        NROW = NROW + 1
        CALL GETCOM(NCOMMA,READLINE,I5,I7)
        HOLDMAT(NROW) = READLINE(1:I5)//READLINE(I7+1:1000)
       ENDIF

       IF(IADDL .GT. 0) THEN

C  THIS LINE MUST BE COPIED IADDL TIMES, BUT EACH LINE MUST HAVE ITS 
C  TIME ENTRY INCREASED BY XII (THE INTERDOSE INTERVAL) FROM THE 
C  PREVIOUS LINE. FIRST FIND THE VALUE OF XII, IN THE 7TH ENTRY, AFTER
C  THE 6TH COMMA. IF XII IS MISSING, STOP THE PROGRAM TELLING THE USER
C  THAT THE .cvs FILE HAS AN ERROR; IT HAS A ROW WITH AN IADDL > 0, BUT
C  WITH AN ACCOMPANYING INTERDOSE INTERVAL WHICH IS MISSING. NOTE THAT
C  THIS LINE NO. IS 2 (THE TOP 2 LINES) + NROW + 1 = NROW + 3.

	  CALL AFTERCOMMA(NCOVA,READLINE,6)
	  BACKSPACE(57)
	  READ(57,*,ERR=35) XII

	  CLOSE(57)
        GO TO 40
        
   35   WRITE(*,36) NROW + 3
   36   FORMAT(/' THE INTERDOSE INTERVAL IS MISSING ON LINE NO. ',I6//
     1' PLEASE CORRECT YOUR .csv FILE AND RERUN THE PROGRAM.'/)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,36) NROW + 3 
        CLOSE(42)	

        CALL PAUSE
        STOP

   40   CONTINUE

C  THE TIME FOR THE ORIGINAL DOSE IS IN ENTRY NO. 3, AFTER COMMA NO. 2.

	  CALL AFTERCOMMA(NCOVA,READLINE,2)
	  BACKSPACE(57)
	  READ(57,*) TIM
	  CLOSE(57)

        DO IADD = 1,IADDL

C  NOTE THAT THE ORIGINAL LINE FOR THIS DOSE HAS ALREADY BEEN WRITTEN
C  TO HOLDMAT (IN THE IF(IADDL .GE. 0) SECTION ABOVE). SO
C  NOW MUST WRITE IADDL LINES TO HOLDMAT, EACH IDENTICAL TO
C  THE CURRENT LINE, EXCEPT EACH TIM WILL BE INCREMENTED BY
C  XII. TO DO THIS, WRITE THE NEXT TIM + XII TO SCRATCH FILE 57; THEN
C  REREAD THIS VALUE AS A CHARACTER SO IT CAN BE INSERTED INTO
C  THE CHARACTER STRING READLINE AND THEN WRITTEN TO THE HOLDING
C  MATRIX.

C  ... AND ...

C  BUG CORRECTION FOR NPAG111.FOR. EACH REPEATED ROW MUST HAVE IDEVENT
C  SET TO 1. I.E., IF IDEVENT FOR THE ORIGINAL ROW (WHICH IS BEING
C  REPEATED IADDL TIMES) IS 4, THIS IS A TIME RESET EVENT, BUT THE
C  REPEATED ROWS WILL ALL HAVE IDEVENTS OF 1 (OTHERWISE IT WOULD LOOK
C  LIKE REPEATED TIME RESET EVENTS WHICH IS NOT WHAT IS INTENDED).

C  FOR EXAMPLE, IADDL = 3 IN AN IDEVENT = 4 LINE --> THE FIRST LINE IN
C  FILE 66 SHOULD HAVE IDEVENT = 4, BUT THE NEXT TWO LINES MUST HAVE
C  IDEVENT = 1 (I.E., THEY ARE REGULAR DOSE LINES THAT FOLLOW THE
C  IDEVENT = 4 LINE AT TIME INTERVALS OF XII).

C  FIRST RESET READLINE TO HOLDMAT(NROW), WHICH DOES NOT HAVE THE
C  ADDL AND II ENTRIES.

         READLINE(1:1000) = HOLDMAT(NROW)

         OPEN(57,STATUS='SCRATCH')
         WRITE(57,*) TIM + XII*IADD
         BACKSPACE(57)
         READ(57,41) TIMCHAR
   41    FORMAT(A50)
         CLOSE(57)


C  TAKE OUT ALL SPACES AT THE END OF TIMCHAR.

         DO IEND = 50,1,-1
          IF(TIMCHAR(IEND:IEND) .NE. ' ') GO TO 50
         END DO

   50    CONTINUE

C  NOW TIMCHAR(1:IEND) IS THE CONDENSED FORM OF THE TIME FOR THIS
C  ROW. REPLACE WHAT IS CURRENTLY BETWEEN COMMAS 2 AND 3 OF 
C  HOLDMAT(NROW) WITH THIS, AND STORE IT INTO THE NEXT ROW OF HOLDMAT.
C  ALSO, DETERMINE I1 = CHARACTER NO. FOR COMMA 1, IN ORDER TO KNOW
C  WHERE TO WRITE THE IDEVENT NO. WHICH WILL ALWAYS BE 1. 

         ICOMMA = 0

         DO I = 1,1000
          IF(READLINE(I:I) .EQ. ',') THEN
           ICOMMA = ICOMMA + 1
           IF(ICOMMA .EQ. 1) I1 = I
           IF(ICOMMA .EQ. 2) I2 = I
           IF(ICOMMA .EQ. 3) THEN
            I3 = I
            GO TO 60
           ENDIF
          ENDIF
         END DO

   60    READLINE2 =
     1    READLINE(1:I1)//'1,'//TIMCHAR(1:IEND)//READLINE(I3:1000)
         NROW = NROW + 1         
         HOLDMAT(NROW) = READLINE2(1:1000)
         
        END DO

C  THE ABOVE END DO IS FOR THE  DO IADD = 1,IADDL  LOOP.


       ENDIF

C  THE ABOVE ENDIF IS FOR THE  IF(IADDL .GT. 0)  CONDITION.



       IF(IADDL .EQ. -1) THEN


C  WRITE JUST ONE LINE TO THE NEW .CSV FILE, EVEN THOUGH IADDL = -1
C  REPRESENTS A STEADY STATE DOSE SET OF 100 DOSES. MAKE THE TIME FOR
C  THIS EVENT = -II SO READBLOCK/WRITEDOS WILL KNOW THIS IS A LINE WITH
C  STEADY STATE DOSE INFO.

	  CALL AFTERCOMMA(NCOVA,READLINE,6)
	  BACKSPACE(57)
	  READ(57,*,ERR=65) XII
	  CLOSE(57)
        GO TO 70

        
   65   WRITE(*,36) NROW + 3

        OPEN(42,FILE=ERRFIL)
         WRITE(42,36) NROW + 3 
        CLOSE(42)	

        CALL PAUSE
        STOP

   70   CONTINUE


C  NOW ESTABLISH THE NEXT LINE OF HOLDMAT AS THE CURRENT
C  READLINE, BUT WITHOUT THE ENTRIES FOR ADDL AND II; THEN RESET
C  READLINE TO BE THIS NEW LINE.


        NROW = NROW + 1
        CALL GETCOM(NCOMMA,READLINE,I5,I7)
        HOLDMAT(NROW) = READLINE(1:I5)//READLINE(I7+1:1000)
        READLINE(1:1000) = HOLDMAT(NROW)

C  NOW ESTABLISH READLINE2 = READLINE, BUT WITH THE TIME VALUE RESET
C  TO BE TIME = -XII. TO DO THIS, WRITE -XII TO SCRATCH FILE 57; THEN
C  REREAD THIS VALUE AS A CHARACTER SO IT CAN BE INSERTED INTO
C  THE CHARACTER STRING READLINE AND THEN WRITTEN TO THE HOLDING
C  MATRIX.


         OPEN(57,STATUS='SCRATCH')
         WRITE(57,*) -XII
         BACKSPACE(57)
         READ(57,41) TIMCHAR

         CLOSE(57)

C  TAKE OUT ALL SPACES AT THE END OF TIMCHAR.

         DO IEND = 50,1,-1
          IF(TIMCHAR(IEND:IEND) .NE. ' ') GO TO 80
         END DO

   80    CONTINUE

C  NOW TIMCHAR(1:IEND) IS THE CONDENSED FORM OF THE TIME FOR THIS
C  ROW. REPLACE WHAT IS CURRENTLY BETWEEN COMMAS 2 AND 3 OF 
C  HOLDMAT(NROW) WITH THIS, AND STORE IT BACK INTO THE SAME ROW OF 
C  HOLDMAT.

         ICOMMA = 0

         DO I = 1,1000
          IF(READLINE(I:I) .EQ. ',') THEN
           ICOMMA = ICOMMA + 1
           IF(ICOMMA .EQ. 2) I2 = I
           IF(ICOMMA .EQ. 3) THEN
            I3 = I
            GO TO 90
           ENDIF
          ENDIF
         END DO

   90    READLINE2 =
     1    READLINE(1:I2)//TIMCHAR(1:IEND)//READLINE(I3:1000)
         HOLDMAT(NROW) = READLINE2(1:1000)


       ENDIF 

C  THE ABOVE ENDIF IS FOR THE  IF(IADDL .EQ. -1)  CONDITION.


      ENDIF

C  THE ABOVE ENDIF IS FOR THE  
C   IF(IDEVENT .EQ. 1 .OR. IDEVENT .EQ. 4)  CONDITION.


      GO TO 20


  100 CONTINUE

C  AS OF NPAG109.FOR, WRITE LINE TO THE SCREEN TELLING THE USER WHICH
C  SUBJECT IS BEING CONVERTED, IN CASE THERE ARE A LARGE NO. OF PATIENTS
C  WITH A LOT OF DATA. OTHERWISE, THERE COULD BE A LONG "DEAD" TIME ON
C  THE SCREEN MAKING THE PROGRAM LOOK LIKE IT HAS "HUNG".

      WRITE(*,103) SUBID
  103 FORMAT(' EXAMINING .CSV FORMAT FOR SUBJECT  ',A11)


C  THE FIRST TWO LINES OF FILE 66 WERE WRITTEN ABOVE. NOW WRITE THE 
C  REST OF THE FILE.

C  NOTE THAT IN EACH SECTION OF DOSES (I.E., UNTIL THE NEXT IDEVENT 
C  = 4), MUST ORDER THE DOSES SINCE THEY COULD BE OUT OF ORDER DUE TO
C  THE ADDL ENTRY. 

C  FOR EXAMPLE, A DOSE OF T = 0 WITH ADDL = 2 AND II = 12 --> DOSES AT
C  T = 0, 12, AND 24. THEN ANOTHER DOSE (FOR A DIFFERENT DRUG, OR THE
C  SAME DRUG WITH A DIFFERENT ROUTE) COULD OCCUR AT T = 8. THEN, FROM
C  THE ABOVE CODE, THE CURRENT DOSE TIMES WOULD BE [0 12 24 8].

C  SO GO THROUGH THE NROW ROWS OF HOLDMAT, AND ORDER THE ROWS IN EACH
C  SECTION (I.E., UNTL THE NEXT IDEVENT = 4 ROW). IN PARTICULAR, FIRST
C  ORDER THE DOSE ROWS (IDEVENT = 1). IF THESE ROWS FOLLOW AN 
C  IDEVENT = 4 ROW, THAT ROW GOES FIRST OF COURSE. THEN WRITE IN THE
C  OBSERVATION ROWS (THEY SHOULD ALREADY BE IN ORDER).

C  PUT ALL THE IDEVENT ENTRIES IN HOLDMAT INTO IDENTRY(.), AND PUT ALL
C  THE TIME ENTRIES IN HOLDMAT INTO TIMENTRY(.).

      DO I = 1,NROW


       READLINE(1:1000) = HOLDMAT(I)

	CALL AFTERCOMMA(NCOVA,READLINE,1)
	BACKSPACE(57)
      READ(57,*,ERR=570) IDEVENT
	CLOSE(57)
      GO TO 580

  570  WRITE(*,471) READLINE(1:75)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,471) READLINE(1:75)
        CLOSE(42)	

  	 CALL PAUSE
	 STOP

 580  CONTINUE


       IDENTRY(I) = IDEVENT
	 CLOSE(57)

       CALL AFTERCOMMA(NCOVA,READLINE,2)
	 BACKSPACE(57)
	 READ(57,*) TIM
       TIMENTRY(I) = TIM
	 CLOSE(57)

      END DO


      NN = 0
      NFIRST = 1

C  NN IS THE RUNNING INDEX OF THE ROW IN HOLDMAT UNDER CONSIDERATION.
C  NFIRST IS THE RUNNING INDEX OF THE FIRST ROW IN THE NEXT SECTION
C  UNDER CONSIDERATION.


  150 CONTINUE


C  ORDER ALL THE ROWS UNTIL THE NEXT IDENTRY(.) = 4, OR UNTIL THE 
C  END OF THE ROWS IS ENCOUNTERED, WHICHEVER COMES FIRST.

      NN = NN + 1
      IF(NN .GT. NROW) GO TO 200

      IF(IDENTRY(NN) .NE. 4 .AND. NN .LT. NROW) GO TO 150



C  ORDER THE ENTRIES IN HOLDMAT FROM NFIRST TO EITHER NROW
C  (IF NN = NROW) OR TO NN-1 (IF IDENTRY(NN) = 4), AND THEN

C  WRITE THEM INTO FILE 66.

      IF(NN .EQ. NROW) NLAST = NROW
      IF(IDENTRY(NN) .EQ. 4) NLAST = NN - 1
      CALL ORDERHOLD(HOLDMAT,NFIRST,NLAST,IDENTRY,TIMENTRY)


C  NOTE THAT SINCE HOLDMAT(I) IS DIMENSIONED 1000, BUT IS LIKELY
C  TO HOLD A LOT FEWER CHARACTERS, TO SAVE SPACE IN FILE 66, 
C  CALL SUBROUTINE CONDENSE TO WRITE EACH LINE IN AS OPTIMUM A 
C  WAY AS POSSIBLE.

      DO I = NFIRST,NLAST
       CALL CONDENSE(HOLDMAT(I))
      END DO      

      NFIRST = NLAST + 1

      GO TO 150

     
  200 CONTINUE

C  IF FILE 67 HAS BEEN COMPLETELY READ, RETURN.

	IF(IEND .LT. 0) THEN
       CLOSE(67)
       RETURN

      ENDIF


C  SINCE IEND .GE. 0, THE FILE HAS NOT BEEN COMPLETELY READ. SO, RESET
C  SUBIDPREV = SUBID AND NROW TO BE 0, AND BACKSPACE FILE 67 SINCE THE
C  FIRST LINE FOR THE NEXT SUBJECT WAS ALREADY READ (I.E., THE NEXT
C  READ OF FILE 67 SHOULD REREAD THIS FIRST LINE) AND GO BACK TO LABEL
C  20 TO CONTINUE READING THE FILE.

      SUBIDPREV = SUBID
      NROW = 0
      BACKSPACE(67)
      GO TO 20


      END

C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
      SUBROUTINE GETCOM(NCOMMA,READLINE,I5,I7)

      CHARACTER READLINE*1000,ERRFIL*20

      COMMON/ERROR/ERRFIL
C  COMMON/ERROR/ IS SUPPLIED TO ALL THE ROUTINES WHICH COULD WRITE TO
C  ERRFIL. 


C  GETCOM IS CALLED BY CVSCHANGE TO FIND THE ENTRY NO. FOR COMMA NO. 5
C (I5), AND THE ENTRY FOR COMMA NO. 7 (I7).

    1 FORMAT(A1000)
 
      ICOMMA = 0

      DO I = 1,300
       IF(READLINE(I:I) .EQ. ',') THEN
        ICOMMA = ICOMMA + 1

         IF(ICOMMA .EQ. 5) I5 = I
          IF(ICOMMA .EQ. 7) THEN
           I7 = I
           RETURN
          ENDIF
       ENDIF
      END DO

C  TO GET TO THIS POINT MEANS THAT READLINE DOESN'T HAVE 7 COMMAS IN
C  IT. REPORT THIS ERROR TO THE USER AND STOP.


      WRITE(*,2) NCOMMA,READLINE(1:70)
    2 FORMAT(/' ONE OF THE LINES IN YOUR .cvs FILE HAS AN ERROR.'/
     1' IT IS SUPPOSED TO HAVE ',I2,' COMMAS, BUT IT HAS FEWER THAN'/
     2' 7. THE FOLLOWING LINE SHOWS THE 1ST 70 CHARACTERS OF THE LINE:'/
     3' ',A70//
     4' THE PROGRAM STOPS.'/)

        OPEN(42,FILE=ERRFIL)
         WRITE(42,2) NCOMMA,READLINE(1:70)
        CLOSE(42)	

      CALL PAUSE
      STOP
    
      END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
      SUBROUTINE ORDERHOLD(HOLDMAT,NFIRST,NLAST,IDENTRY,TIMENTRY)

      IMPLICIT REAL*8(A-H,O-Z)

      DIMENSION TIMENTRY(99999),IDENTRY(99999),IZ(99999),IZZ(99999),
     1 DOSTIME(99999)
      CHARACTER HOLDMAT(99999)*1000,HOLDMAT2(99999)*1000

C  ORDER THE ENTRIES IN HOLDMAT FROM NFIRST TO NLAST, AS FOLLOWS:

C  1. PUT ALL THE DOSE EVENTS (IDENTRY(.) = 1 OR 4) FIRST, ORDERED BY

C  INCREASING TIMENTRY(.).

C  2. PUT ALL THE OBSERVATION EVENTS (IDENTRY(.) = 0) AFTER THE DOSE
C  EVENTS (THEY SHOULD ALREADY BE ORDERED).


C  FIRST, STORE THE DOSE ROWS FROM NFIRST TO NLAST IN HOLDMAT TO 
C  HOLDMAT2, STARTING AT ROW 1 IN HOLDMAT2.


C  ALSO, PUT ALL THE DOSE EVENTS TIMES INTO DOSTIME, AND INITIALIZE

C  VECTOR IZ TO BE -99 IN ALL ITS NDOSE LOCATIONS

      NDOSE = 0


      DO I = NFIRST,NLAST
       IF(IDENTRY(I) .EQ. 1 .OR. IDENTRY(I) .EQ. 4) THEN

        NDOSE = NDOSE + 1

        HOLDMAT2(NDOSE) = HOLDMAT(I)
        DOSTIME(NDOSE) = TIMENTRY(I)

        IZ(NDOSE) = -99
       ENDIF
      END DO

C  NOW, FOR EXAMPLE, IF ENTRY 17 IS THE SMALLEST VALUE IN DOSTIME,
C  IZ(17) WILL BE SET = 0, AND THE PROGRAM WILL KNOW NOT TO CHECK THE
C  17TH ENTRY AGAIN (SINCE IT HAS ALREADY BEEN SELECTED). IF THE NEXT
C  SMALLEST ENTRY HAS INDEX 37, THEN IZ(37) WILL BE SET = 0, ETC.

C  NOTE THAT IZZ WILL BE THE ARRAY WHICH CONTAINS THE ACTUAL ORDERING.
C  IN THE EXAMPLE ABOVE, IZZ(1) = 17, IZZ(2) = 37. IT WILL BE EASY TO
C  ASSIGN ORDERED VALUES BACK INTO HOLDMAT USING IZZ. IN THE EXAMPLE
C  ABOVE, HOLDMAT(1) WILL HAVE DOSE TIME = DOSTIME(IZZ(1)) =
C  DOSTIME(17); HOLDMAT(2) WILL HAVE DOSE TIME = DOSTIME(IZZ(2)) =
C  DOSTIME(37); ETC.


C  NOW PUT THE OBSERVATION ROWS FROM NFIRST TO NLAST IN HOLDMAT TO
C  HOLDMAT2, STARTING AT ROW NDOSE + 1 IN HOLDMAT2.

      NEXT = NDOSE

      DO I = NFIRST,NLAST
       IF(IDENTRY(I) .EQ. 0) THEN
        NEXT = NEXT + 1
        HOLDMAT2(NEXT) = HOLDMAT(I)
       ENDIF
      END DO


C  NOW ORDER THE FIRST NDOSE ROWS IN HOLDMAT2 ACCORDING TO THE DOSE
C  TIMES, LOW TO HIGH.

	 DO IPLACE = 1,NDOSE

C  PUT THE NEXT LOWEST VALUE OF DOSTIME INTO THE IPLACE LOCATION OF
C  IZZ.


C  TEMP IS THE RUNNING VALUE OF THE NEXT VALUE TO BE PLACED INTO 
C  DOSTIME. INITIALIZE IT TO BE VERY HIGH VALUE SO THE FIRST VALUE 
C  OF DOSTIME WILL BE SURE TO BE LOWER THAN IT IS.

	  TEMP = 1.D50


	  DO I=1,NDOSE
	   IF(DOSTIME(I) .LT. TEMP .AND. IZ(I) .EQ. -99) THEN
	    TEMP = DOSTIME(I)
	    IND = I
	   ENDIF
	  END DO

C  AT THIS POINT, IND IS THE INDEX OF THE SMALLEST REMAINING VALUE
C  (TEMP) IN DOSTIME. PUT THIS INFORMATION INTO IZZ. ALSO, SET
C  IZ(IND) = 0 --> THE IND LOCATION IN DOSTIME HAS BEEN USED.

	  IZZ(IPLACE) = IND
	  IZ(IND) = 0

	 END DO

C  AT THIS POINT IZZ CONTAINS THE ORDERED INDICES (LOW TO HIGH) OF THE
C  NDOSE VALUES IN DOSTIME, AND SO GIVES THE ORDER THAT THE NDOSE ROWS
C  NOW IN HOLDMAT2 SHOULD BE WRITTEN.

C  WRITE THESE NDOSE DOSE ROWS IN THE CORRECT ORDER INTO HOLDMAT, AND
C  THEN WRITE THE REMAINING ROWS (OBSERVATION ROWS) INTO HOLDMAT. 

      DO IDOSE = 1,NDOSE
       HOLDMAT(NFIRST-1+IDOSE) = HOLDMAT2(IZZ(IDOSE))
      END DO

C  STORE THE OBSERVATION ROWS INTO ENTRIES NFIRST + NDOSE,..., NLAST OF
C  HOLDMAT. THEY WERE STORED INTO THE LAST NOBS ROWS OF HOLDMAT2 ABOVE. 

      NEXT = NDOSE

      DO IOBS = NFIRST + NDOSE,NLAST
       NEXT = NEXT + 1
       HOLDMAT(IOBS) = HOLDMAT2(NEXT)
      END DO

     
       
      RETURN
      END

C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
        SUBROUTINE CONDENSE(READLINE)
        CHARACTER READLINE*1000        

C  SUBROUTINE CONDENSE IS CALLED BY SUBROUTINE CSVCHANGE TO WRITE 
C  READLINE WITH AS SMALL A FORMAT AS POSSIBLE (WITHIN 25 CHARACTERS) 
C  TO FILE 66

C  FOR THIS LINE, READLINE, FIND IEND, THE LAST CHARACTER WHICH IS NOT
C  BLANK. THEN ONLY CHARACTERS 1:IEND WILL BE WRITTEN TO FILE 66.


	DO IEND = 1000,1,-1
	 IF(READLINE(IEND:IEND) .NE. ' ') GO TO 20
	END DO

   20   CONTINUE

C  CANNOT USE WRITE(66,_) READLINE(1:IEND) SINCE, FOR SOME REASON,
C  WRITING LIKE THIS "RIGHT JUSTIFIES" THE CHARACTERS AT THE END
C  OF THE A1000 FORMAT. INSTEAD MUST WRITE (66,__) READLINE, WHERE
C  THE FORMAT IS DETERMINED BY THE LAST NON-BLANK CHARACTER (IEND)
C  IN READLINE.


	IF(IEND .LE. 26) THEN
	 WRITE(66,26) READLINE
   26    FORMAT(A26)
	 RETURN

	ENDIF

	IF(IEND .LE. 51) THEN
	 WRITE(66,51) READLINE
   51    FORMAT(A51)
	 RETURN
	ENDIF

	IF(IEND .LE. 76) THEN
	 WRITE(66,76) READLINE
   76    FORMAT(A76)
	 RETURN
	ENDIF


	IF(IEND .LE. 101) THEN
	 WRITE(66,101) READLINE
  101    FORMAT(A101)
	 RETURN
	ENDIF

	IF(IEND .LE. 126) THEN
	 WRITE(66,126) READLINE
  126    FORMAT(A126)
	 RETURN
	ENDIF

	IF(IEND .LE. 151) THEN
	 WRITE(66,151) READLINE
  151    FORMAT(A151)
	 RETURN
	ENDIF

	IF(IEND .LE. 176) THEN

	 WRITE(66,176) READLINE
  176    FORMAT(A176)
	 RETURN
	ENDIF

	IF(IEND .LE. 201) THEN
	 WRITE(66,201) READLINE
  201    FORMAT(A201)
	 RETURN
	ENDIF

	IF(IEND .LE. 226) THEN
	 WRITE(66,226) READLINE

  226    FORMAT(A226)
	 RETURN
	ENDIF


	IF(IEND .LE. 251) THEN
	 WRITE(66,251) READLINE
  251    FORMAT(A251)

	 RETURN
	ENDIF

	IF(IEND .LE. 276) THEN
	 WRITE(66,276) READLINE
  276    FORMAT(A276)
	 RETURN
	ENDIF

	IF(IEND .LE. 301) THEN
	 WRITE(66,301) READLINE
  301    FORMAT(A301)
	 RETURN
	ENDIF

	IF(IEND .LE. 326) THEN
	 WRITE(66,326) READLINE
  326    FORMAT(A326)
	 RETURN
	ENDIF

	IF(IEND .LE. 351) THEN
	 WRITE(66,351) READLINE
  351    FORMAT(A351)
	 RETURN
	ENDIF

	IF(IEND .LE. 376) THEN
	 WRITE(66,376) READLINE
  376    FORMAT(A376)
	 RETURN
	ENDIF

	IF(IEND .LE. 401) THEN
	 WRITE(66,401) READLINE

  401    FORMAT(A401)
	 RETURN
	ENDIF

	IF(IEND .LE. 426) THEN
	 WRITE(66,426) READLINE
  426    FORMAT(A426)
	 RETURN
	ENDIF

	IF(IEND .LE. 451) THEN
	 WRITE(66,451) READLINE
  451    FORMAT(A451)
	 RETURN
	ENDIF

	IF(IEND .LE. 476) THEN

	 WRITE(66,476) READLINE
  476    FORMAT(A476)
	 RETURN
	ENDIF

	IF(IEND .LE. 501) THEN
	 WRITE(66,501) READLINE
  501    FORMAT(A501)
	 RETURN
	ENDIF

	IF(IEND .LE. 526) THEN
	 WRITE(66,526) READLINE
  526    FORMAT(A526)
	 RETURN
	ENDIF

	IF(IEND .LE. 551) THEN
	 WRITE(66,551) READLINE
  551    FORMAT(A551)
	 RETURN
	ENDIF

	IF(IEND .LE. 576) THEN
	 WRITE(66,576) READLINE
  576    FORMAT(A576)
	 RETURN
	ENDIF


	IF(IEND .LE. 601) THEN
	 WRITE(66,601) READLINE
  601    FORMAT(A601)
	 RETURN
	ENDIF

	IF(IEND .LE. 626) THEN
	 WRITE(66,626) READLINE
  626    FORMAT(A626)
	 RETURN
	ENDIF

	IF(IEND .LE. 651) THEN
	 WRITE(66,651) READLINE
  651    FORMAT(A651)
	 RETURN
	ENDIF

	IF(IEND .LE. 676) THEN
	 WRITE(66,676) READLINE
  676    FORMAT(A676)
	 RETURN
	ENDIF


	IF(IEND .LE. 701) THEN
	 WRITE(66,701) READLINE
  701    FORMAT(A701)
	 RETURN
	ENDIF


	IF(IEND .LE. 726) THEN
	 WRITE(66,726) READLINE
  726    FORMAT(A726)
	 RETURN
	ENDIF

	IF(IEND .LE. 751) THEN
	 WRITE(66,751) READLINE

  751    FORMAT(A751)
	 RETURN
	ENDIF


	IF(IEND .LE. 776) THEN

	 WRITE(66,776) READLINE
  776    FORMAT(A776)
	 RETURN
	ENDIF

	IF(IEND .LE. 801) THEN
	 WRITE(66,801) READLINE
  801    FORMAT(A801)
	 RETURN
	ENDIF

	IF(IEND .LE. 826) THEN

	 WRITE(66,826) READLINE
  826    FORMAT(A826)
	 RETURN
	ENDIF


	IF(IEND .LE. 851) THEN
	 WRITE(66,851) READLINE
  851    FORMAT(A851)
	 RETURN
	ENDIF

	IF(IEND .LE. 876) THEN
	 WRITE(66,876) READLINE
  876    FORMAT(A876)
	 RETURN
	ENDIF

	IF(IEND .LE. 901) THEN
	 WRITE(66,901) READLINE
  901    FORMAT(A901)
	 RETURN
	ENDIF

	IF(IEND .LE. 926) THEN
	 WRITE(66,926) READLINE
  926    FORMAT(A926)
	 RETURN
	ENDIF

	IF(IEND .LE. 951) THEN
	 WRITE(66,951) READLINE
  951    FORMAT(A951)
	 RETURN
	ENDIF

	IF(IEND .LE. 976) THEN
	 WRITE(66,976) READLINE
  976    FORMAT(A976)
	 RETURN
	ENDIF

	WRITE(66,4) READLINE
    4    FORMAT(A1000)
        RETURN

        END







